{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/System/getFunction.impl": "\n/*!\n * \\file   getFunction.impl\n * \\brief  ths file implements some C wrappers around the dlsym\n * system call.\n * \\author Helfer Thomas\n * \\date   18 december 2008\n */\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#include<cstdlib>\n#include<cstring>\n#define dlsym(handle, func) GetProcAddress (handle, func)\n#else\n#include<stdlib.h>\n#include<string.h>\n#include<dlfcn.h>\n#define nullptr NULL\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n\n#include\"TFEL/System/getFunction.h\"\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n  int tfel_getCastemFunctionNumberOfVariables(LibraryHandlerPtr lib,\n\t\t\t\t\t      const char * const name){\n    unsigned short * n;\n    size_t len = strlen(name);\n    char *myname = (char *) malloc((len+7u)*sizeof(char));\n    if(myname==nullptr){\n      return -1;\n    }\n    strncpy(myname,name,len);\n    myname[len]='_';\n    myname[len+1u]='n';\n    myname[len+2u]='a';\n    myname[len+3u]='r';\n    myname[len+4u]='g';\n    myname[len+5u]='s';\n    myname[len+6u]='\\0';\n    n= (unsigned short *) dlsym(lib,myname);\n    free(myname);\n    if(n==nullptr){\n      return -1;\n    }  \n    return *n;\n  } \n\n  int tfel_getUMATRequiresStiffnessTensor(LibraryHandlerPtr l,\n\t\t\t\t\t  const char * const f)\n  {\n    unsigned short * n;\n    size_t len = strlen(f);\n    char *myname = (char *) malloc((len+25u)*sizeof(char));\n    if(myname==nullptr){\n      return -1;\n    }\n    strncpy(myname,f,len+1);\n    strncat(myname,\"_requiresStiffnessTensor\",24u);\n    n= (unsigned short *) dlsym(l,myname);\n    free(myname);\n    if(n==nullptr){\n      return -1;\n    }  \n    return *n;\n  }\n\n  int tfel_getUMATRequiresThermalExpansionCoefficientTensor(LibraryHandlerPtr l,\n\t\t\t\t\t\t\t    const char * const f)\n  {\n    unsigned short * n;\n    size_t len = strlen(f);\n    char *myname = (char *) malloc((len+43u)*sizeof(char));\n    if(myname==nullptr){\n      return -1;\n    }\n    strncpy(myname,f,len+1);\n    strncat(myname,\"_requiresThermalExpansionCoefficientTensor\",42u);\n    n= (unsigned short *) dlsym(l,myname);\n    free(myname);\n    if(n==nullptr){\n      return -1;\n    }  \n    return *n;\n  }\n\n  int tfel_checkIfAsterBehaviourSavesTangentOperator(LibraryHandlerPtr l,\n\t\t\t\t\t\t     const char * const f)\n  {\n    unsigned short * n;\n    size_t len = strlen(f);\n    char *myname = (char *) malloc((len+22u)*sizeof(char));\n    if(myname==nullptr){\n      return -1;\n    }\n    strncpy(myname,f,len);\n    myname[len]='_';\n    myname[len+1u]='s';\n    myname[len+2u]='a';\n    myname[len+3u]='v';\n    myname[len+4u]='e';\n    myname[len+5u]='s';\n    myname[len+6u]='T';\n    myname[len+7u]='a';\n    myname[len+8u]='n';\n    myname[len+9u]='g';\n    myname[len+10u]='e';\n    myname[len+11u]='n';\n    myname[len+12u]='t';\n    myname[len+13u]='O';\n    myname[len+14u]='p';\n    myname[len+15u]='e';\n    myname[len+16u]='r';\n    myname[len+17u]='a';\n    myname[len+18u]='t';\n    myname[len+19u]='o';\n    myname[len+20u]='r';\n    myname[len+21u]='\\0';\n    n= (unsigned short *) dlsym(l,myname);\n    free(myname);\n    if(n==nullptr){\n      return -1;\n    }\n    return *n;\n  }\n\n  double tfel_getDouble(LibraryHandlerPtr lib,\n\t   \t        const char * const name){\n    double * n = (double *) dlsym(lib,name);\n    if(n==nullptr){\n      return 0.;\n    }  \n    return *n;\n  } \n\n  long  double tfel_getLongDouble(LibraryHandlerPtr lib,\n\t\t\t\t  const char * const name){\n    long double * n = (long double *) dlsym(lib,name);\n    if(n==nullptr){\n      return 0.;\n    }  \n    return *n;\n  } \n\n  int tfel_getInteger(LibraryHandlerPtr lib,\n\t\t      const char * const name){\n    int * n = (int *) dlsym(lib,name);\n    if(n==nullptr){\n      return 0.;\n    }  \n    return *n;\n  } \n\n  int tfel_getUnsignedShort(LibraryHandlerPtr lib,\n\t\t\t    const char * const name){\n    unsigned short * n;\n    n= (unsigned short *) dlsym(lib,name);\n    if(n==nullptr){\n      return -1;\n    }  \n    return *n;\n  } \n\n  int tfel_getBool(LibraryHandlerPtr lib,\n\t\t   const char * const name){\n    unsigned short * n;\n    n= (unsigned short *) dlsym(lib,name);\n    if(n==nullptr){\n      return -1;\n    }  \n    return (int) *n;\n  }\n\n  char **\n  tfel_getArrayOfStrings(LibraryHandlerPtr lib,\n\t\t\t const char * const name)\n  {\n    char ** v;\n    v = (char **) dlsym(lib,name);\n    return v;\n  }\n\n  int *\n  tfel_getArrayOfInt(LibraryHandlerPtr lib,\n\t\t     const char * const name)\n  {\n    int * v;\n    v = (int *) dlsym(lib,name);\n    return v;\n  }\n\n  char **\n  tfel_getCastemFunctionVariables(LibraryHandlerPtr lib,\n\t\t\t\t  const char * const name)\n  {\n    char ** v;\n    size_t len = strlen(name);\n    char *myname = (char *) malloc((len+6u)*sizeof(char));\n    if(myname==nullptr){\n      return nullptr;\n    }\n    strncpy(myname,name,len);\n    myname[len]='_';\n    myname[len+1u]='a';\n    myname[len+2u]='r';\n    myname[len+3u]='g';\n    myname[len+4u]='s';\n    myname[len+5u]='\\0';\n    v = (char **) dlsym(lib,myname);\n    free(myname);\n    return v;\n  }\n\n  int (TFEL_ADDCALL_PTR tfel_getSetOutOfBoundsPolicyFunction(LibraryHandlerPtr lib,\n\t\t\t\t\t\t\t     const char * const name))(const int){\n    return (int (TFEL_ADDCALL_PTR)(const int)) dlsym(lib,name);\n  } \n\n  int (TFEL_ADDCALL_PTR tfel_getSetParameterFunction(LibraryHandlerPtr lib,const char * const name))(const char* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double){\n    return (int (TFEL_ADDCALL_PTR)(const char*const,\n\t\t\t\t   const double)) dlsym(lib,name);\n  } \n\n  int (TFEL_ADDCALL_PTR tfel_getSetIntegerParameterFunction(LibraryHandlerPtr lib,const char * const name))(const char* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t    const int){\n    return (int (TFEL_ADDCALL_PTR)(const char*const,\n\t\t\t\t   const int)) dlsym(lib,name);\n  }\n\n  int (TFEL_ADDCALL_PTR tfel_getSetUnsignedShortParameterFunction(LibraryHandlerPtr lib,const char * const name))(const char* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  const unsigned short){\n    return (int (TFEL_ADDCALL_PTR)(const char*const,\n\t\t\t\t   const unsigned short)) dlsym(lib,name);\n  }\n\n  double (TFEL_ADDCALL_PTR tfel_getCastemFunction(LibraryHandlerPtr lib,const char * const name))(const double*const){\n    return (double (TFEL_ADDCALL_PTR)(const double*const)) dlsym(lib,name);\n  } \n\n  void (TFEL_ADDCALL_PTR tfel_getCyranoFunction(LibraryHandlerPtr lib,\n\t\t\t\t\t\tconst char * const name))(const CyranoIntegerType  *const,\n\t\t\t\t\t\t\t\t\t  const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  const CyranoIntegerType  *const,\n\t\t\t\t\t\t\t\t\t  const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  const CyranoIntegerType  *const,\n\t\t\t\t\t\t\t\t\t  CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t  const CyranoIntegerType  *const,\n\t\t\t\t\t\t\t\t\t  CyranoIntegerType  *const)\n  {\n    return (void (TFEL_ADDCALL_PTR)(const CyranoIntegerType  *const,\n\t\t\t\t    const CyranoRealType *const,\n\t\t\t\t    const CyranoRealType *const,\n\t\t\t\t    CyranoRealType *const,\n\t\t\t\t    const CyranoRealType *const,\n\t\t\t\t    const CyranoRealType *const,\n\t\t\t\t    const CyranoRealType *const,\n\t\t\t\t    const CyranoRealType *const,\n\t\t\t\t    const CyranoRealType *const,\n\t\t\t\t    const CyranoIntegerType  *const,\n\t\t\t\t    const CyranoRealType *const,\n\t\t\t\t    const CyranoRealType *const,\n\t\t\t\t    CyranoRealType *const,\n\t\t\t\t    const CyranoIntegerType  *const,\n\t\t\t\t    CyranoRealType *const,\n\t\t\t\t    const CyranoIntegerType  *const,\n\t\t\t\t    CyranoIntegerType  *const)) dlsym(lib,name);\n  }\n\n  void (TFEL_ADDCALL_PTR tfel_getAnsysExternalBehaviourFunction(LibraryHandlerPtr l,\n\t\t\t\t\t\t\t\tconst char * const f))(const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const)\n  {\n    return (void (TFEL_ADDCALL_PTR)(const AnsysIntegerType *const,const AnsysIntegerType *const,const AnsysIntegerType *const,\n\t\t\t\t    const AnsysIntegerType *const,const AnsysIntegerType *const,const AnsysIntegerType *const,\n\t\t\t\t    const AnsysIntegerType *const,AnsysIntegerType *const,const AnsysIntegerType *const,\n\t\t\t\t    const AnsysIntegerType *const,const AnsysIntegerType *const,const AnsysIntegerType *const,\n\t\t\t\t    const AnsysIntegerType *const,const AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t    const AnsysRealType *const,const AnsysRealType *const,AnsysRealType *const,\n\t\t\t\t    AnsysRealType *const,AnsysRealType *const,AnsysRealType *const,\n\t\t\t\t    AnsysRealType *const,AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t    const AnsysRealType *const,AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t    const AnsysRealType *const,const AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t    const AnsysRealType *const,const AnsysRealType *const,AnsysRealType *const,\n\t\t\t\t    const AnsysRealType *const,const AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t    const AnsysRealType *const,const AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t    const AnsysRealType *const,const AnsysRealType *const)) dlsym(l,f);\n  }\n  \n  void (TFEL_ADDCALL_PTR tfel_getAbaqusExplicitExternalBehaviourFunction(LibraryHandlerPtr l,\n\t\t\t\t\t\t\t\t\t const char * const f))(const AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst char* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tAbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tAbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tAbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tAbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst int)\n  {\n    return (void (TFEL_ADDCALL_PTR)(const AbaqusIntegerType *const,const AbaqusIntegerType *const,\n\t\t\t\t    const AbaqusIntegerType *const,const AbaqusIntegerType *const,\n\t\t\t\t    const AbaqusIntegerType *const,const AbaqusIntegerType *const,\n\t\t\t\t    const AbaqusIntegerType *const,const AbaqusRealType* const,\n\t\t\t\t    const AbaqusRealType    *const,const AbaqusRealType* const,\n\t\t\t\t    const char* const,             const AbaqusRealType* const,\n\t\t\t\t    const AbaqusRealType    * const,const AbaqusRealType* const,\n\t\t\t\t    const AbaqusRealType    * const,const AbaqusRealType* const,\n\t\t\t\t    const AbaqusRealType    * const,const AbaqusRealType* const,\n\t\t\t\t    const AbaqusRealType    * const,const AbaqusRealType* const,\n\t\t\t\t    const AbaqusRealType    * const,const AbaqusRealType* const,\n\t\t\t\t    const AbaqusRealType    * const,const AbaqusRealType* const,\n\t\t\t\t    const AbaqusRealType    * const,const AbaqusRealType* const,\n\t\t\t\t    const AbaqusRealType    * const,const AbaqusRealType* const,\n\t\t\t\t    const AbaqusRealType    * const,      AbaqusRealType* const,\n\t\t\t\t          AbaqusRealType    * const,      AbaqusRealType* const,\n\t\t\t\t    AbaqusRealType    * const,const int))dlsym(l,f);\n  }\n  \n  void (TFEL_ADDCALL_PTR tfel_getAbaqusExternalBehaviourFunction(LibraryHandlerPtr l,\n\t\t\t\t\t\t\t\t const char * const n))(AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tAbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tAbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tAbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tAbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tAbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tAbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tAbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tAbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tAbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst char      *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tAbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\tconst AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\tAbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\tconst int)\n  {\n    return (void (TFEL_ADDCALL_PTR)(AbaqusRealType *const,AbaqusRealType *const,AbaqusRealType *const,AbaqusRealType *const,\n\t\t\t\t    AbaqusRealType *const,AbaqusRealType *const,\n\t\t\t\t    AbaqusRealType *const,AbaqusRealType *const,\n\t\t\t\t    AbaqusRealType *const,AbaqusRealType *const,\n\t\t\t\t    const AbaqusRealType *const,const AbaqusRealType *const,\n\t\t\t\t    const AbaqusRealType *const,const AbaqusRealType *const,\n\t\t\t\t    const AbaqusRealType *const,const AbaqusRealType *const,\n\t\t\t\t    const AbaqusRealType *const,const AbaqusRealType *const,\n\t\t\t\t    const char      *const,const AbaqusIntegerType  *const,\n\t\t\t\t    const AbaqusIntegerType  *const,const AbaqusIntegerType  *const,\n\t\t\t\t    const AbaqusIntegerType  *const,const AbaqusRealType *const,\n\t\t\t\t    const AbaqusIntegerType  *const,const AbaqusRealType *const,\n\t\t\t\t    const AbaqusRealType *const,AbaqusRealType *const,\n\t\t\t\t    const AbaqusRealType *const,const AbaqusRealType *const,\n\t\t\t\t    const AbaqusRealType *const,const AbaqusIntegerType  *const,\n\t\t\t\t    const AbaqusIntegerType  *const,const AbaqusIntegerType  *const,\n\t\t\t\t    const AbaqusIntegerType  *const,const AbaqusIntegerType  *const,\n\t\t\t\t    AbaqusIntegerType  *const,const int))dlsym(l,n);\n  }\n\n  void (TFEL_ADDCALL_PTR tfel_getCastemExternalBehaviourFunction(LibraryHandlerPtr l,\n\t\t\t\t\t\t\t\t const char * const n))(CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst char      *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\tCastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\tconst int)\n  {\n    return (void (TFEL_ADDCALL_PTR)(CastemRealType *const,CastemRealType *const,\n\t\t\t\t    CastemRealType *const,CastemRealType *const,\n\t\t\t\t    CastemRealType *const,CastemRealType *const,\n\t\t\t\t    CastemRealType *const,CastemRealType *const,\n\t\t\t\t    CastemRealType *const,CastemRealType *const,\n\t\t\t\t    const CastemRealType *const,const CastemRealType *const,\n\t\t\t\t    const CastemRealType *const,const CastemRealType *const,\n\t\t\t\t    const CastemRealType *const,const CastemRealType *const,\n\t\t\t\t    const CastemRealType *const,const CastemRealType *const,\n\t\t\t\t    const char      *const,const CastemIntegerType  *const,\n\t\t\t\t    const CastemIntegerType  *const,const CastemIntegerType  *const,\n\t\t\t\t    const CastemIntegerType  *const,const CastemRealType *const,\n\t\t\t\t    const CastemIntegerType  *const,const CastemRealType *const,\n\t\t\t\t    const CastemRealType *const,CastemRealType *const,\n\t\t\t\t    const CastemRealType *const,const CastemRealType *const,\n\t\t\t\t    const CastemRealType *const,const CastemIntegerType  *const,\n\t\t\t\t    const CastemIntegerType  *const,const CastemIntegerType  *const,\n\t\t\t\t    const CastemIntegerType  *const,const CastemIntegerType  *const,\n\t\t\t\t    CastemIntegerType  *const,const int))dlsym(l,n);\n  }\n  \n  void (TFEL_ADDCALL_PTR tfel_getAsterFunction(LibraryHandlerPtr lib,\n\t\t\t\t\t       const char * const name))(AsterRealType *const,\n\t\t\t\t\t\t\t\t\t AsterRealType *const,\n\t\t\t\t\t\t\t\t\t AsterRealType *const,\n\t\t\t\t\t\t\t\t\t const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t const AsterIntegerType  *const,\n\t\t\t\t\t\t\t\t\t const AsterIntegerType  *const,\n\t\t\t\t\t\t\t\t\t const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t const AsterIntegerType  *const,\n\t\t\t\t\t\t\t\t\t const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t AsterRealType *const,\n\t\t\t\t\t\t\t\t\t const AsterIntegerType  *const)\n  {\n    return (void (TFEL_ADDCALL_PTR)(AsterRealType *const,AsterRealType *const,\n\t\t\t\t    AsterRealType *const,const AsterRealType *const,\n\t\t\t\t    const AsterRealType *const,const AsterRealType *const,\n\t\t\t\t    const AsterRealType *const,const AsterRealType *const,\n\t\t\t\t    const AsterRealType *const,const AsterRealType *const,\n\t\t\t\t    const AsterIntegerType  *const,const AsterIntegerType  *const,\n\t\t\t\t    const AsterRealType *const,const AsterIntegerType  *const,\n\t\t\t\t    const AsterRealType *const,AsterRealType *const,\n\t\t\t\t    const AsterIntegerType  *const))dlsym(lib,name);\n  }\n  \n  const char * (TFEL_ADDCALL_PTR tfel_getAsterIntegrationErrorMessage(LibraryHandlerPtr lib,\n\t\t\t\t\t\t\t\t const char * const name))()\n  {\n    return (const char* (TFEL_ADDCALL_PTR)())dlsym(lib,name);\n  }\n\n  void (TFEL_ADDCALL_PTR tfel_getEuroplexusFunction(LibraryHandlerPtr l,\n\t\t\t\t\t\t    const char * const n))(EuroplexusIntegerType *const,\n\t\t\t\t\t\t\t\t\t   EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   EuroplexusIntegerType *const,\t\t   \n\t\t\t\t\t\t\t\t\t   char *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n   \t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t   const EuroplexusIntegerType  *const)\n  {\n    return (void (TFEL_ADDCALL_PTR)(      EuroplexusIntegerType  *const,       EuroplexusRealType     *const,\n\t\t\t\t          EuroplexusRealType     *const,       EuroplexusRealType     *const,\n\t\t\t\t          EuroplexusRealType     *const,       EuroplexusIntegerType  *const,\t\t   \n\t\t\t\t\t  char                   *const,\n\t\t\t\t    const EuroplexusIntegerType  *const, const EuroplexusIntegerType  *const,\n\t\t\t\t    const EuroplexusRealType     *const, const EuroplexusRealType     *const,\n\t\t\t\t    const EuroplexusRealType     *const, const EuroplexusRealType     *const,\n    \t\t\t\t    const EuroplexusRealType     *const, const EuroplexusIntegerType  *const,\n\t\t\t\t    const EuroplexusRealType     *const, const EuroplexusRealType     *const,\n\t\t\t\t    const EuroplexusRealType     *const, const EuroplexusRealType     *const,\n\t\t\t\t    const EuroplexusIntegerType  *const))dlsym(l,n);\n  }\n\n  void (TFEL_ADDCALL_PTR tfel_getCalculiXExternalBehaviourFunction(LibraryHandlerPtr l,\n\t\t\t\t\t\t\t\t   const char * const n))(const char * const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t  const int)\n  {\n    return (void (TFEL_ADDCALL_PTR)(const char * const,const CalculiXIntegerType* const,const CalculiXIntegerType* const,\n\t\t\t\t    const CalculiXIntegerType* const,const CalculiXRealType* const,const CalculiXRealType* const,\n\t\t\t\t    const CalculiXRealType* const,const CalculiXRealType* const,const CalculiXRealType* const,\n\t\t\t\t    const CalculiXRealType* const,const CalculiXRealType* const,const CalculiXRealType* const,\n\t\t\t\t    const CalculiXIntegerType* const,const CalculiXRealType* const,const CalculiXRealType* const,\n\t\t\t\t    const CalculiXRealType* const,const CalculiXRealType* const,const CalculiXIntegerType* const,\n\t\t\t\t    const CalculiXIntegerType* const,const CalculiXIntegerType* const,const CalculiXIntegerType* const,\n\t\t\t\t    const CalculiXRealType* const,CalculiXRealType* const,CalculiXRealType* const,\n\t\t\t\t    CalculiXRealType* const,const CalculiXIntegerType* const,const CalculiXRealType* const,\n\t\t\t\t    const CalculiXRealType* const,CalculiXRealType* const,const CalculiXIntegerType* const,\n\t\t\t\t    const int))dlsym(l,n);\n  }\n  \n  double (TFEL_ADDCALL_PTR tfel_getCFunction0(LibraryHandlerPtr lib,const char * const name))(){\n    return (double (TFEL_ADDCALL_PTR)()) dlsym(lib,name);\n  } \n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction1(LibraryHandlerPtr lib,const char * const name))(double){\n    return (double (TFEL_ADDCALL_PTR)(double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction2(LibraryHandlerPtr lib,const char * const name))(double,double){\n    return (double (TFEL_ADDCALL_PTR)(double,double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction3(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction4(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction5(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double,\n\t\t\t\t      double)) dlsym(lib,name);\n  }\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction6(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double,\n\t\t\t\t      double,double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction7(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double,\n\t\t\t\t      double,double,double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction8(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double,\n\t\t\t\t      double,double,double,double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction9(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t\t      double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double,\n\t\t\t\t      double,double,double,double,\n\t\t\t\t      double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction10(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double,\n\t\t\t\t      double,double,double,double,\n\t\t\t\t      double,double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction11(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double,\n\t\t\t\t      double,double,double,double,\n\t\t\t\t      double,double,double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction12(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double,\n\t\t\t\t      double,double,double,double,\n\t\t\t\t      double,double,double,double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction13(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double,\n\t\t\t\t      double,double,double,double,\n\t\t\t\t      double,double,double,double,\n\t\t\t\t      double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction14(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double,\n\t\t\t\t      double,double,double,double,\n\t\t\t\t      double,double,double,double,\n\t\t\t\t      double,double)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getCFunction15(LibraryHandlerPtr lib,const char * const name))(double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double,double,\n\t\t\t\t\t\t\t\t\t\t\t       double){\n    return (double (TFEL_ADDCALL_PTR)(double,double,double,double,\n\t\t\t\t      double,double,double,double,\n\t\t\t\t      double,double,double,double,\n\t\t\t\t      double,double,double)) dlsym(lib,name);\n  }\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction0(LibraryHandlerPtr lib,const char * const name))(){\n    return (double (TFEL_ADDCALL_PTR)()) dlsym(lib,name);\n  } \n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction1(LibraryHandlerPtr lib,const char * const name))(const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction2(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction3(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction4(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction5(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const)) dlsym(lib,name);\n  }\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction6(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction7(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction8(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction9(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t    const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction10(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction11(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction12(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction13(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction14(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const)) dlsym(lib,name);\n  }\n\n\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction15(LibraryHandlerPtr lib,const char * const name))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t\t     const double* const){\n    return (double (TFEL_ADDCALL_PTR)(const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const,const double* const,\n\t\t\t\t      const double* const,const double* const,const double* const)) dlsym(lib,name);\n  }\n\n#ifdef\t__cplusplus\n}\n#endif /* __cplusplus */\n",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/System/ExternalLibraryManager.cxx": "/*!\n * \\file   src/System/ExternalLibraryManager.cxx\n * \\brief    \n * \\author Thomas Helfer\n * \\date   31 Oct 2007\n * \\copyright Copyright (C) 2006-2018 CEA/DEN, EDF R&D. All rights \n * reserved. \n * This project is publicly released under either the GNU GPL Licence \n * or the CECILL-A licence. A copy of thoses licences are delivered \n * with the sources of TFEL. CEA or EDF may also distribute this \n * project under specific licensing conditions. \n */\n\n#include<cctype>\n#include<cstring>\n#include<fstream>\n#include<stdexcept>\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#ifndef NOMINMAX\n#define NOMINMAX\n#endif\n#include <windows.h>\n#else\n#include<dlfcn.h>\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n\n#include<iterator>\n\n#include\"TFEL/Raise.hxx\"\n#include\"TFEL/System/getFunction.h\"\n#include\"TFEL/System/LibraryInformation.hxx\"\n#include\"TFEL/System/ExternalLibraryManager.hxx\"\n\nnamespace tfel\n{\n  namespace system\n  {\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n    // code retrieved from\n    // http://www.codeproject.com/Tips/479880/GetLastError-as-std-string\n    static std::string getLastWin32Error()\n    {\n      const DWORD error = GetLastError();\n      if (error){\n\tLPVOID lpMsgBuf;\n\tDWORD bufLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | \n\t\t\t\t     FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t\t     FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\t\t\t     nullptr,error,\n\t\t\t\t     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t\t     (LPTSTR) &lpMsgBuf,0, nullptr );\n\tif (bufLen){\n\t  LPCSTR lpMsgStr = (LPTSTR) lpMsgBuf;\n\t  std::string result(lpMsgStr, lpMsgStr+bufLen);\n\t  LocalFree(lpMsgBuf);\n\t  return result;\n\t}\n      }\n      return std::string();\n    }\n#endif /*  (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n\n    static std::string getErrorMessage()\n    {\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n      return getLastWin32Error();\n#else\n      const auto e = ::dlerror();\n      if(e!=nullptr){\n\treturn std::string(e);\n      }\n      return \"\";\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    } // end of  getErrorMessage\n    \n    static void\n    ExternalLibraryManagerCheckModellingHypothesisName(const std::string& h)\n    {\n      raise_if(!((h==\"AxisymmetricalGeneralisedPlaneStrain\")||\n\t\t (h==\"AxisymmetricalGeneralisedPlaneStress\")||\n\t\t (h==\"Axisymmetrical\")||\n\t\t (h==\"PlaneStress\")||\n\t\t (h==\"PlaneStrain\")||\n\t\t (h==\"GeneralisedPlaneStrain\")||\n\t\t (h==\"Tridimensional\")),\n\t       \"ExternalLibraryManagerCheckModellingHypothesisName : \"\n\t       \"invalid or unsupported hypothesis '\"+h+\"'. The following \"\n\t       \"hypotheses are supported:\\n\"\n\t       \"- AxisymmetricalGeneralisedPlaneStrain\\n\"\n\t       \"- Axisymmetrical\\n\"\n\t       \"- PlaneStress\\n\"\n\t       \"- PlaneStrain\\n\"\n\t       \"- GeneralisedPlaneStrain\\n\"\n\t       \"- Tridimensional\");\n    } // end of ExternalLibraryManagerCheckModellingHypothesisName\n\n    static std::string decomposeVariableName(const std::string& n)\n    {\n      auto throw_if = [](const bool c,const std::string& m){\n\traise_if(c,\"tfel::system::decomposeVariableName: \"+m);\n      };\n      auto p  = n.cbegin();\n      auto pe = n.cend();\n      while((p!=pe)&&(*p!='[')){\n\t++p;\n      }\n      if(p==pe){\n\treturn n;\n      }\n      auto r = std::string{n.cbegin(),p};\n      ++p;\n      throw_if(p==pe,\"unexpected end of string 'n'\");\n      throw_if(!std::isdigit(*p),\"unexpected a digit 'n'\");\n      r+=\"__\";\n      while((p!=pe)&&(std::isdigit(*p))){\n\tr.push_back(*p);\n\t++p;\n      }\n      throw_if(p==pe,\"unexpected end of string '\"+n+\"'\");\n      throw_if(*p!=']',\"invalid variable name '\"+n+\"'\");\n      ++p;\n      throw_if(p!=pe,\"invalid variable name '\"+n+\"'\");\n      r+=\"__\";\n      return r;\n    } // end of decomposeVariableName\n    \n    ExternalLibraryManager&\n    ExternalLibraryManager::getExternalLibraryManager()\n    {\n      static ExternalLibraryManager elm;\n      return elm;\n    } // end of ExternalLibraryManager::getExternalLibraryManager()\n\n    ExternalLibraryManager::ExternalLibraryManager() = default;\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n    static HINSTANCE__*\n#else\n    static void *\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    load_library(const std::string& l){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n      return ::LoadLibrary(TEXT (l.c_str()));\n#else\n      return ::dlopen(l.c_str(),RTLD_NOW);\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    } // end of load_library\n    \n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n    static std::pair<HINSTANCE__*,std::string>\n#else\n    static std::pair<void *,std::string>\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    try_open(const std::string& l){\n      auto starts_with = [](const std::string& s1,\n      \t\t\t    const char* const s2){\n\tconst auto ls2 = std::strlen(s2);\n      \treturn ((s1.size()>=ls2) &&\n      \t\t(std::equal(s2,s2+ls2,s1.begin())));\n      }; // end of starts_with\n      auto ends_with = [](const std::string& s1,\n\t\t\t  const char* const s2){\n\tconst auto ls2 = std::strlen(s2);\n      \tif(!(s1.size()>=ls2)){\n\t  return false;\n\t}\n\treturn std::equal(s2,s2+ls2,s1.begin()+(s1.size()-ls2));\n      }; // end of ends_with\n#if (defined(macintosh) || defined(Macintosh) || \\\n     (defined(__APPLE__) && defined(__MACH__)))\n      const char * const ext = \".dylib\";\n#elif (defined(_WIN32) || defined(_WIN64) || defined(__CYGWIN__))\n      const char * const ext = \".dll\";\n#else\n      const char * const ext = \".so\";\n#endif\n      auto ln  = l;\n      auto lib = load_library(l);\n#if defined(__CYGWIN__)\n      if((lib==nullptr)&&(!starts_with(l,\"cyg\"))){\n\tln  = \"cyg\"+l;\n\tlib = load_library(ln);\n\tif(lib==nullptr){\n\t  if(!ends_with(l,ext)){\n\t    ln  = \"cyg\"+l+ext;\n\t    lib = load_library(ln);\n\t  }\n\t}\n      }\n#endif\n#if !(defined(_WIN32) || defined(_WIN64))\n      if((lib==nullptr)&&(!starts_with(l,\"lib\"))){\n\tln  = \"lib\"+l;\n\tlib = load_library(ln);\n\tif(lib==nullptr){\n\t  if(!ends_with(l,ext)){\n\t    ln  = \"lib\"+l+ext;\n\t    lib = load_library(ln);\n\t  }\n\t}\n      }\n#endif\n      if((lib==nullptr)&&(!ends_with(l,ext))){\n\tln  = l+ext;\n\tlib = load_library(ln);\n      }\n      // retrieving the initial error message\n      if(lib==nullptr){\n\tln  = l;\n\tlib = load_library(ln);\n      }\n      return {lib,ln};\n    } // end of try_open\n\n    std::string ExternalLibraryManager::getLibraryPath(const std::string& l){\n      auto throw_if = [](const bool c,const std::string& m){\n\traise_if(c,\"ExternalLibraryManager::getLibraryPath: \"+m);\n      };\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n      auto lib = this->loadLibrary(l);\n      char path[MAX_PATH];\n      GetModuleFileNameA(lib,path,sizeof(path));\n      return std::string{path};\n#else\n      auto tokenize = [](const std::string& s,const char c){\n\tstd::vector<std::string> r;\n\tstd::string::size_type b = 0u;\n\tstd::string::size_type e = s.find_first_of(c, b);\n\twhile (std::string::npos != e || std::string::npos != b){\n\t// Found a token, add it to the vector.\n\t  r.push_back(s.substr(b, e - b));\n\t  b = s.find_first_not_of(c, e);\n\t  e = s.find_first_of(c, b);\n\t}\n\treturn r;\n      };\n      auto exists = [](const std::string& f){\n\tstd::ifstream file(f);\n\treturn static_cast<bool>(file);\n      };\n      auto lib = try_open(l);\n      throw_if(lib.first==nullptr,\"can't load library '\"+l+\"'\");\n      // check if file exists\n      if(exists(lib.second)){\n\treturn lib.second;\n      }\n      // look in LD_LIBRARY_PATH\n      const auto ld = std::getenv(\"LD_LIBRARY_PATH\");\n      throw_if(ld==nullptr,\"can't find library '\"+l+\"'\");\n      for(const auto& p : tokenize(ld,':')){\n\tconst auto lp = p+'/'+lib.second;\n\tif(exists(lp)){\n\t  return lp;\n\t}\n      }\n      throw_if(true,\"can't find library '\"+l+\"'\");\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */      \n    } // end of ExternalLibraryManager::getLibraryPath\n    \n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n    HINSTANCE__*\n#else\n    void *\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    ExternalLibraryManager::loadLibrary(const std::string& name,\n\t\t\t\t\tconst bool b)\n    {\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n#else \n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */      \n      auto p=this->librairies.find(name);\n      if(p==librairies.end()){\n\t// this library has not been \n\tauto r = try_open(name);\n\tauto lib = r.first;\n\traise_if((lib==nullptr)&&(!b),\n\t\t \"ExternalLibraryManager::loadLibrary:\"\n\t\t \" library '\"+name+\"' could not be loaded, \"\n\t\t \"(\"+getErrorMessage()+\")\");\n\tif((lib==nullptr)&&(b)){\n\t  return lib;\n\t}\n\tthis->librairies.insert({name,lib});\n\treturn lib;\n      }\n      return p->second;\n    } // end of ExternalLibraryManager::loadLibrary\n\n    std::vector<std::string>\n    ExternalLibraryManager::getEntryPoints(const std::string& l)\n    {\n      auto ends_with = [](const std::string& s1,\n\t\t\t  const std::string& s2){\n\treturn ((s1.size()>=s2.size()) &&\n\t\t(std::equal(s2.rbegin(),s2.rend(),s1.rbegin())));\n      }; // end of ends_with\n      auto r  = std::vector<std::string>{};\n      auto lib = try_open(l);\n      raise_if(lib.first==nullptr,\n\t       \"ExternalLibraryManager::getEntryPoints:\"\n\t       \" library '\"+l+\"' could not be loaded, \"\n\t       \"(\"+getErrorMessage()+\")\");\n      auto pl = this->getLibraryPath(lib.second);\n      for(const auto& s : LibraryInformation(pl).symbols()){\n\tif(ends_with(s,\"_mfront_ept\")){\n\t  r.push_back(s.substr(0,s.size()-11));\n\t}\n      }\n      return r;\n    } // end of ExternalLibraryManager::getEntryPoints\n\n    unsigned short\n    ExternalLibraryManager::getMaterialKnowledgeType(const std::string& l,\n\t\t\t\t\t\t     const std::string& f)\n    {\n      auto throw_if = [l,f](const bool c,const std::string& m){\n\traise_if(c,\"ExternalLibraryManager::getMaterialKnowledgeType: \"+m);\n      };\n      const auto lib = this->loadLibrary(l);\n      const int nb = ::tfel_getUnsignedShort(lib,(f+\"_mfront_mkt\").c_str());\n      throw_if(nb==-1,\"the material knowledge type could not be read \"\n\t       \"(\"+getErrorMessage()+\")\");\n      if(nb==0){\n\treturn 0u;\n      } else if(nb==1){\n\treturn 1u;\n      }\n      throw_if(nb!=2,\"invalid material knowledge type\");\n      return 2u;\n    } // end of ExternalLibraryManager::getMaterialKnowledgeType\n    \n    bool ExternalLibraryManager::contains(const std::string& l,\n\t\t\t\t\t  const std::string& s)\n    {\n      const auto lib = this->loadLibrary(l);\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n      int (*p)()   = (int (*)()) ::GetProcAddress(lib,s.c_str());\n      return p!=static_cast<int (*)()>(nullptr);\n#else\n      void * p   = ::dlsym(lib,s.c_str());\n      return p!=nullptr;\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    } // end of ExternalLibraryManager::contains\n\n    std::string ExternalLibraryManager::getSource(const std::string& l,\n\t\t\t\t\t\t  const std::string& f)\n    {\n      auto s = std::string{};\n      const auto lib = this->loadLibrary(l);\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n      const auto p  = (const char* const *) ::GetProcAddress(lib,(f+\"_src\").c_str());\n#else\n      auto p   = ::dlsym(lib,(f+\"_src\").c_str());\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n      if(p!=nullptr){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n\ts = *p;\n#else\n\ts = *(static_cast<const char* const *>(p));\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n      }\n      return s;\n    } // end of ExternalLibraryManager::getSource\n\n    std::string ExternalLibraryManager::getInterface(const std::string& l,\n\t\t\t\t\t\t     const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n      const auto p   = (const char* const *) ::GetProcAddress(lib,(f+\"_mfront_interface\").c_str());\n#else\n      const auto p   = ::dlsym(lib,(f+\"_mfront_interface\").c_str());\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n      raise_if(p==nullptr,\"ExternalLibraryManager::getInterface: \"\n\t       \"no interface found for entry point '\"+f+\"' \"\n\t       \"in library '\"+l+\"'\");\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n      return *p;\n#else\n      return *(static_cast<const char* const *>(p));\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    } // end of ExternalLibraryManager::getInterface\n\n    std::string ExternalLibraryManager::getMaterial(const std::string& l,\n\t\t\t\t\t\t     const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n      const auto p   = (const char* const *) ::GetProcAddress(lib,(f+\"_mfront_material\").c_str());\n#else\n      const auto p   = ::dlsym(lib,(f+\"_mfront_material\").c_str());\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n      if(p==nullptr){\n\treturn \"\";\n      }\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n      return *p;\n#else\n      return *(static_cast<const char* const *>(p));\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    } // end of ExternalLibraryManager::getMaterial\n\n    std::string ExternalLibraryManager::getTFELVersion(const std::string& l,\n\t\t\t\t\t\t       const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n      const auto p   = (const char* const *) ::GetProcAddress(lib,(f+\"_tfel_version\").c_str());\n#else\n      const auto p   = ::dlsym(lib,(f+\"_tfel_version\").c_str());\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n      if(p==nullptr){\n\treturn \"\";\n      }\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) \n      return *p;\n#else\n      return *(static_cast<const char* const *>(p));\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    } // end of ExternalLibraryManager::getTFELVersion\n    \n    std::vector<std::string>\n    ExternalLibraryManager::getSupportedModellingHypotheses(const std::string& l,\n\t\t\t\t\t\t\t    const std::string& f)\n    {\n      std::vector<std::string> h;\n      const auto lib = this->loadLibrary(l);\n      const auto nb  = ::tfel_getUnsignedShort(lib,(f+\"_nModellingHypotheses\").c_str());\n      char ** res;\n      raise_if(nb==-1,\"ExternalLibraryManager::\"\n\t       \"getSupportedModellingHypotheses: \"\n\t       \"number of modelling hypotheses could not be read (\"\n\t       +getErrorMessage()+\")\");\n      res = ::tfel_getArrayOfStrings(lib,(f+\"_ModellingHypotheses\").c_str());\n      raise_if(res==nullptr,\"ExternalLibraryManager::\"\n\t       \"getSupportedModellingHypotheses: \"\n\t       \"modelling hypotheses could not be read (\"\n\t       +getErrorMessage()+\")\");\n      std::copy(res,res+nb,std::back_inserter(h));\n      return h;\n    } // end of ExternalLibraryManager::getSupportedModellingHypotheses\n\n    void\n    ExternalLibraryManager::setOutOfBoundsPolicy(const std::string& l,\n\t\t\t\t\t\t const std::string& f,\n\t\t\t\t\t\t const tfel::material::OutOfBoundsPolicy p)\n    {\n      const auto lib = this->loadLibrary(l);\n      int (TFEL_ADDCALL_PTR fct)(int);\n      fct = ::tfel_getSetOutOfBoundsPolicyFunction(lib,(f+\"_setOutOfBoundsPolicy\").c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::setOutOfBoundsPolicy: \"\n\t       \"can't get the '\"+f+\"_setOutOfBoundsPolicy' function \"\n\t       \"(\"+getErrorMessage()+\")\");\n      if(p==tfel::material::None){\n\tfct(0);\n      } else if(p==tfel::material::Warning){\n\tfct(1);\n      } else if(p==tfel::material::Strict){\n\tfct(2);\n      } else {\n\traise(\"ExternalLibraryManager::setOutOfBoundsPolicy: \"\n\t      \"unsupported policy\");\n      }\n    } // end of ExternalLibraryManager::setParameter\n    \n    void ExternalLibraryManager::setParameter(const std::string& l,\n\t\t\t\t\t      const std::string& f,\n\t\t\t\t\t      const std::string& p,\n\t\t\t\t\t      const double v)\n    {\n      const auto lib = this->loadLibrary(l);\n      int (TFEL_ADDCALL_PTR fct)(const char*const,const double);\n      fct = ::tfel_getSetParameterFunction(lib,(f+\"_setParameter\").c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"can't get the '\"+f+\"_setParameter' function (\"\n\t       +getErrorMessage()+\")\");\n      raise_if(!fct(p.c_str(),v),\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"call to the '\"+f+\"_setParameter' function failed\");\n    } // end of ExternalLibraryManager::setParameter\n\n    void ExternalLibraryManager::setParameter(const std::string& l,\n\t\t\t\t\t      const std::string& f,\n\t\t\t\t\t      const std::string& p,\n\t\t\t\t\t      const int v)\n    {\n      const auto lib = this->loadLibrary(l);\n      int (TFEL_ADDCALL_PTR fct)(const char*const,const int);\n      fct = ::tfel_getSetIntegerParameterFunction(lib,(f+\"_setIntegerParameter\").c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"can't get the '\"+f+\"_setParameter' function (\"\n\t       +getErrorMessage()+\")\");\n      raise_if(!fct(p.c_str(),v),\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"call to the '\"+f+\"_setParameter' function failed\");\n    } // end of ExternalLibraryManager::setParameter\n    \n    void ExternalLibraryManager::setParameter(const std::string& l,\n\t\t\t\t\t      const std::string& f,\n\t\t\t\t\t      const std::string& p,\n\t\t\t\t\t      const unsigned short v)\n    {\n      const auto lib = this->loadLibrary(l);\n      int (TFEL_ADDCALL_PTR fct)(const char*const,const unsigned short);\n      fct = ::tfel_getSetUnsignedShortParameterFunction(lib,(f+\"_setUnsignedShortParameter\").c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"can't get the '\"+f+\"_setParameter' function (\"\n\t       +getErrorMessage()+\")\");\n      raise_if(!fct(p.c_str(),v),\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"call to the '\"+f+\"_setParameter' function failed\");\n    } // end of ExternalLibraryManager::setParameter\n        \n    void ExternalLibraryManager::setParameter(const std::string& l,\n\t\t\t\t\t      const std::string& f,\n\t\t\t\t\t      const std::string& h,\n\t\t\t\t\t      const std::string& p,\n\t\t\t\t\t      const double v)\n    {\n      const auto lib = this->loadLibrary(l);\n      int (TFEL_ADDCALL_PTR fct)(const char*const,const double);\n      fct = ::tfel_getSetParameterFunction(lib,(f+\"_\"+h+\"_setParameter\").c_str());\n      if(fct==nullptr){\n\tfct = ::tfel_getSetParameterFunction(lib,(f+\"_setParameter\").c_str());\n      }\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"can't get the '\"+f+\"_setParameter' function (\"\n\t       +getErrorMessage()+\")\");\n      raise_if(!fct(p.c_str(),v),\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"call to the '\"+f+\"_setParameter' function failed\");\n    } // end of ExternalLibraryManager::setParameter\n\n    void ExternalLibraryManager::setParameter(const std::string& l,\n\t\t\t\t\t      const std::string& f,\n\t\t\t\t\t      const std::string& h,\n\t\t\t\t\t      const std::string& p,\n\t\t\t\t\t      const int v)\n    {\n      const auto lib = this->loadLibrary(l);\n      int (TFEL_ADDCALL_PTR fct)(const char*const,const int);\n      fct = ::tfel_getSetIntegerParameterFunction(lib,(f+\"_\"+h+\"_setIntegerParameter\").c_str());\n      if(fct==nullptr){\n\tfct = ::tfel_getSetIntegerParameterFunction(lib,(f+\"_setIntegerParameter\").c_str());\n      }\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"can't get the '\"+f+\"_setParameter' function (\"\n\t       +getErrorMessage()+\")\");\n      raise_if(!fct(p.c_str(),v),\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"call to the '\"+f+\"_setParameter' function failed\");\n    } // end of ExternalLibraryManager::setParameter\n    \n    void ExternalLibraryManager::setParameter(const std::string& l,\n\t\t\t\t\t      const std::string& f,\n\t\t\t\t\t      const std::string& h,\n\t\t\t\t\t      const std::string& p,\n\t\t\t\t\t      const unsigned short v)\n    {\n      const auto lib = this->loadLibrary(l);\n      int (TFEL_ADDCALL_PTR fct)(const char*const,const unsigned short);\n      fct = ::tfel_getSetUnsignedShortParameterFunction(lib,(f+\"_\"+h+\"_setUnsignedShortParameter\").c_str());\n      if(fct==nullptr){\n\tfct = ::tfel_getSetUnsignedShortParameterFunction(lib,(f+\"_setUnsignedShortParameter\").c_str());\n      }\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"can't get the '\"+f+\"_setParameter' function (\"\n\t       +getErrorMessage()+\")\");\n      raise_if(!fct(p.c_str(),v),\n\t       \"ExternalLibraryManager::setParameter: \"\n\t       \"call to the '\"+f+\"_setParameter' function failed\");\n    } // end of ExternalLibraryManager::setParameter\n\n    double ExternalLibraryManager::getRealParameterDefaultValue(const std::string& l,\n\t\t\t\t\t\t\t\tconst std::string& f,\n\t\t\t\t\t\t\t\tconst std::string& h,\n\t\t\t\t\t\t\t\tconst std::string& p)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto pn  = decomposeVariableName(p);\n      const auto n1 = f+\"_\"+h+\"_\"+pn+\"_ParameterDefaultValue\";\n      if(this->contains(l,n1)){\n\treturn tfel_getDouble(lib,n1.c_str());\n      }\n      const auto n2 = f+\"_\"+pn+\"_ParameterDefaultValue\";\n      raise_if(!this->contains(l,n2),\n\t       \"ExternalLibraryManager::getRealParameterDefaultValue: \"\n\t       \"can't get default value for parameter '\"+p+\"'\");\n      return tfel_getDouble(lib,n2.c_str());\n    } // end of ExternalLibraryManager::getRealParameterDefaultValue\n\n    int ExternalLibraryManager::getIntegerParameterDefaultValue(const std::string& l,\n\t\t\t\t\t\t\t\tconst std::string& f,\n\t\t\t\t\t\t\t\tconst std::string& h,\n\t\t\t\t\t\t\t\tconst std::string& p)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto pn  = decomposeVariableName(p);\n      const auto n1 = f+\"_\"+h+\"_\"+pn+\"_ParameterDefaultValue\";\n      if(this->contains(l,n1)){\n\treturn tfel_getInteger(lib,n1.c_str());\n      }\n      const auto n2 = f+\"_\"+pn+\"_ParameterDefaultValue\";\n      raise_if(!this->contains(l,n2),\n\t       \"ExternalLibraryManager::getIntegerParameterDefaultValue: \"\n\t       \"can't get default value for parameter '\"+p+\"'\");\n      return tfel_getInteger(lib,n2.c_str());\n    } // end of ExternalLibraryManager::getIntegerParameterDefaultValue\n\n    unsigned short\n    ExternalLibraryManager::getUnsignedShortParameterDefaultValue(const std::string& l,\n\t\t\t\t\t\t\t\t  const std::string& f,\n\t\t\t\t\t\t\t\t  const std::string& h,\n\t\t\t\t\t\t\t\t  const std::string& p)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto pn  = decomposeVariableName(p);\n      const auto n1 = f+\"_\"+h+\"_\"+pn+\"_ParameterDefaultValue\";\n      auto res = ::tfel_getUnsignedShort(lib,n1.c_str());\n      if(res<0){\n\tres = ::tfel_getUnsignedShort(lib,(f+\"_\"+pn+\"_ParameterDefaultValue\").c_str());\n\traise_if(res<0,\"ExternalLibraryManager::\"\n\t\t \"getUnsignedShortParameterDefaultValue: \"\n\t\t \"information could not be read (\"\n\t\t +getErrorMessage()+\")\");\n      }\n      return static_cast<unsigned short>(res);\n    } // end of ExternalLibraryManager::getUnsignedShortParameterDefaultValue\n\n    bool ExternalLibraryManager::hasBounds(const std::string& l,\n\t\t\t\t\t   const std::string& f,\n\t\t\t\t\t   const std::string& h,\n\t\t\t\t\t   const std::string& n)\n    {\n      const auto vn = decomposeVariableName(n);\n      const auto n1 = f+\"_\"+h+\"_\"+vn+\"_LowerBound\";\n      const auto n2 = f+\"_\"+h+\"_\"+vn+\"_UpperBound\";\n      const auto n3 = f+\"_\"+n+\"_LowerBound\";\n      const auto n4 = f+\"_\"+n+\"_UpperBound\";\n      return ((this->contains(l,n1))||(this->contains(l,n2))||\n\t      (this->contains(l,n3))||(this->contains(l,n4)));\n    } // end of ExternalLibraryManager::hasBounds\n\n    bool ExternalLibraryManager::hasLowerBound(const std::string& l,\n\t\t\t\t\t       const std::string& f,\n\t\t\t\t\t       const std::string& h,\n\t\t\t\t\t       const std::string& n)\n    {\n      const auto vn = decomposeVariableName(n);\n      const auto n1 = f+\"_\"+h+\"_\"+vn+\"_LowerBound\";\n      const auto n2 = f+\"_\"+vn+\"_LowerBound\";\n      return ((this->contains(l,n1))||(this->contains(l,n2)));\n    } // end of ExternalLibraryManager::hasLowerBound\n\n    bool ExternalLibraryManager::hasUpperBound(const std::string& l,\n\t\t\t\t\t       const std::string& f,\n\t\t\t\t\t       const std::string& h,\n\t\t\t\t\t       const std::string& n)\n    {\n      const auto vn = decomposeVariableName(n);\n      const auto n1 = f+\"_\"+h+\"_\"+vn+\"_UpperBound\";\n      const auto n2 = f+\"_\"+vn+\"_UpperBound\";\n      return ((this->contains(l,n1))||(this->contains(l,n2)));\n    } // end of ExternalLibraryManager::hasUpperBound\n\n    long double ExternalLibraryManager::getLowerBound(const std::string& l,\n\t\t\t\t\t\t      const std::string& f,\n\t\t\t\t\t\t      const std::string& h,\n\t\t\t\t\t\t      const std::string& n)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto vn = decomposeVariableName(n);\n      const auto n1 = f+\"_\"+h+\"_\"+vn+\"_LowerBound\";\n      if(this->contains(l,n1)){\n\treturn tfel_getLongDouble(lib,n1.c_str());\n      }\n      const auto n2 = f+\"_\"+vn+\"_LowerBound\";\n      raise_if(!this->contains(l,n2),\n\t       \"ExternalLibraryManager::getLowerBound: \"\n\t       \"no lower bound associated to variable '\"+vn+\"'\");\n      return tfel_getLongDouble(lib,n2.c_str());\n    } // end of ExternalLibraryManager::getLowerBound\n    \n    long double ExternalLibraryManager::getUpperBound(const std::string& l,\n\t\t\t\t\t\t      const std::string& f,\n\t\t\t\t\t\t      const std::string& h,\n\t\t\t\t\t\t      const std::string& n)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto vn = decomposeVariableName(n);\n      const auto n1 = f+\"_\"+h+\"_\"+vn+\"_UpperBound\";\n      if(this->contains(l,n1)){\n\treturn tfel_getLongDouble(lib,n1.c_str());\n      }\n      const auto n2 = f+\"_\"+vn+\"_UpperBound\";\n      raise_if(!this->contains(l,n2),\n\t       \"ExternalLibraryManager::getUpperBound: \"\n\t       \"no upper bound associated to variable '\"+vn+\"'\");\n      return tfel_getLongDouble(lib,n2.c_str());\n    } // end of ExternalLibraryManager::getUpperBound\n    \n    bool ExternalLibraryManager::hasPhysicalBounds(const std::string& l,\n\t\t\t\t\t\t   const std::string& f,\n\t\t\t\t\t\t   const std::string& h,\n\t\t\t\t\t\t   const std::string& n)\n    {\n      const auto vn = decomposeVariableName(n);\n      const auto n1 = f+\"_\"+h+\"_\"+vn+\"_LowerPhysicalBound\";\n      const auto n2 = f+\"_\"+h+\"_\"+vn+\"_UpperPhysicalBound\";\n      const auto n3 = f+\"_\"+vn+\"_LowerPhysicalBound\";\n      const auto n4 = f+\"_\"+vn+\"_UpperPhysicalBound\";\n      return ((this->contains(l,n1))||(this->contains(l,n2))||\n\t      (this->contains(l,n3))||(this->contains(l,n4)));\n    } // end of ExternalLibraryManager::hasPhysicalBounds\n\n    bool ExternalLibraryManager::hasLowerPhysicalBound(const std::string& l,\n\t\t\t\t\t\t       const std::string& f,\n\t\t\t\t\t\t       const std::string& h,\n\t\t\t\t\t\t       const std::string& n)\n    {\n      const auto vn = decomposeVariableName(n);\n      const auto n1 = f+\"_\"+h+\"_\"+vn+\"_LowerPhysicalBound\";\n      const auto n2 = f+\"_\"+vn+\"_LowerPhysicalBound\";\n      return ((this->contains(l,n1))||(this->contains(l,n2)));\n    } // end of ExternalLibraryManager::hasLowerPhysicalBound\n\n    bool ExternalLibraryManager::hasUpperPhysicalBound(const std::string& l,\n\t\t\t\t\t\t       const std::string& f,\n\t\t\t\t\t\t       const std::string& h,\n\t\t\t\t\t\t       const std::string& n)\n    {\n      const auto vn = decomposeVariableName(n);\n      const auto n1 = f+\"_\"+h+\"_\"+vn+\"_UpperPhysicalBound\";\n      const auto n2 = f+\"_\"+vn+\"_UpperPhysicalBound\";\n      return ((this->contains(l,n1))||(this->contains(l,n2)));\n    } // end of ExternalLibraryManager::hasUpperPhysicalBound\n\n    long double ExternalLibraryManager::getLowerPhysicalBound(const std::string& l,\n\t\t\t\t\t\t\t      const std::string& f,\n\t\t\t\t\t\t\t      const std::string& h,\n\t\t\t\t\t\t\t      const std::string& n)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto vn = decomposeVariableName(n);\n      const auto n1 = f+\"_\"+h+\"_\"+vn+\"_LowerPhysicalBound\";\n      if(this->contains(l,n1)){\n\treturn tfel_getLongDouble(lib,n1.c_str());\n      }\n      const auto n2 = f+\"_\"+vn+\"_LowerPhysicalBound\";\n      raise_if(!this->contains(l,n2),\n\t       \"ExternalLibraryManager::getLowerPhysicalBound: \"\n\t       \"no physical lower bound associated to variable '\"+vn+\"'\");\n      return tfel_getLongDouble(lib,n2.c_str());\n    } // end of ExternalLibraryManager::getLowerPhysicalBound\n    \n    long double ExternalLibraryManager::getUpperPhysicalBound(const std::string& l,\n\t\t\t\t\t\t\t      const std::string& f,\n\t\t\t\t\t\t\t      const std::string& h,\n\t\t\t\t\t\t\t      const std::string& n)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto vn = decomposeVariableName(n);\n      const auto n1 = f+\"_\"+h+\"_\"+vn+\"_UpperPhysicalBound\";\n      if(this->contains(l,n1)){\n\treturn tfel_getLongDouble(lib,n1.c_str());\n      }\n      const auto n2 = f+\"_\"+vn+\"_UpperPhysicalBound\";\n      raise_if(!this->contains(l,n2),\n\t       \"ExternalLibraryManager::getUpperPhysicalBound: \"\n\t       \"no physical upper bound associated to variable '\"+vn+\"'\");\n      return tfel_getLongDouble(lib,n2.c_str());\n    } // end of ExternalLibraryManager::getUpperPhysicalBound\n    \n    unsigned short\n    ExternalLibraryManager::getCastemFunctionNumberOfVariables(const std::string& l,\n\t\t\t\t\t\t\t       const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto res = ::tfel_getCastemFunctionNumberOfVariables(lib,f.c_str());\n      raise_if(res<0,\n\t       \"ExternalLibraryManager::getCastemFunctionNumberOfVariables: \"\n\t       \"number of variables could not be read (\"\n\t       +getErrorMessage()+\")\");\n      return static_cast<unsigned short>(res);\n    }\n\n    bool\n    ExternalLibraryManager::getUMATRequiresStiffnessTensor(const std::string& l,\n\t\t\t\t\t\t\t   const std::string& f,\n\t\t\t\t\t\t\t   const std::string& h)\n    {\n      ExternalLibraryManagerCheckModellingHypothesisName(h);\n      int res;\n      const auto lib = this->loadLibrary(l);\n      res = ::tfel_getUMATRequiresStiffnessTensor(lib,(f+\"_\"+h).c_str());\n      if(res<0){\n\tres = ::tfel_getUMATRequiresStiffnessTensor(lib,f.c_str());\n      }\n      raise_if(res<0,\n\t       \"ExternalLibraryManager::getUMATRequiresStiffnessTensor: \"\n\t       \"information could not be read (\"+getErrorMessage()+\")\");\n      if(res==1){\n\treturn true;\n      }\n      raise_if(res!=0,\n\t       \"ExternalLibraryManager::getUMATRequiresStiffnessTensor: \"\n\t       \"invalid returned value\");\n      return false;\n    } // end of ExternalLibraryManager::getUMATRequiresStiffnessTensor\n \n    bool\n    ExternalLibraryManager::getUMATRequiresThermalExpansionCoefficientTensor(const std::string& l,\n\t\t\t\t\t\t\t\t\t     const std::string& f,\n\t\t\t\t\t\t\t\t\t     const std::string& h)\n    {\n      ExternalLibraryManagerCheckModellingHypothesisName(h);\n      auto lib = this->loadLibrary(l);\n      auto res = ::tfel_getUMATRequiresThermalExpansionCoefficientTensor(lib,(f+\"_\"+h).c_str());\n      if(res<0){\n\tres = ::tfel_getUMATRequiresThermalExpansionCoefficientTensor(lib,f.c_str());\n      }\n      raise_if(res<0,\"ExternalLibraryManager::\"\n\t       \"getUMATRequiresThermalExpansionCoefficientTensor: \"\n\t       \"information could not be read (\"+getErrorMessage()+\")\");\n      if(res==1){\n\treturn true;\n      }\n      raise_if(res!=0,\"ExternalLibraryManager::\"\n\t       \"getUMATRequiresThermalExpansionCoefficientTensor: \"\n\t       \"invalid returned value\");\n      return false;\n    } // end of ExternalLibraryManager::getUMATRequiresThermalExpansionCoefficientTensor\n\n    bool\n    ExternalLibraryManager::checkIfAsterBehaviourSavesTangentOperator(const std::string& l,\n\t\t\t\t\t\t\t\t      const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto res = ::tfel_checkIfAsterBehaviourSavesTangentOperator(lib,f.c_str());\n      raise_if(res<0,\"ExternalLibraryManager::\"\n\t       \"checkIfAsterBehaviourSaveTangentOperator: \"\n\t       \"information could not be read (\"\n\t       +getErrorMessage()+\")\");\n      if(res==1){\n\treturn true;\n      }\n      raise_if(res!=0,\"ExternalLibraryManager::\"\n\t       \"checkIfAsterBehaviourSaveTangentOperator: \"\n\t       \"invalid returned value\");\n      return false;\n    } // end of ExternalLibraryManager::checkIfAsterBehaviourSaveTangentOperator\n\n    unsigned short\n    ExternalLibraryManager::getAsterFiniteStrainFormulation(const std::string& l,\n\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto s   = f+\"_FiniteStrainFormulation\";\n      const auto res = ::tfel_getUnsignedShort(lib,s.c_str());\n      raise_if(res<0,\"ExternalLibraryManager::\"\n\t       \"getAsterFiniteStrainFormulation: \"\n\t       \"information could not be read (\"\n\t       +getErrorMessage()+\")\");\n      raise_if((res!=1)&&(res!=2),\n\t       \"ExternalLibraryManager::\"\n\t       \"getAsterFiniteStrainFormulation: \"\n\t       \"invalid returned value\");\n      return static_cast<unsigned short>(res);\n    } // end of ExternalLibraryManager::getAsterFiniteStrainFormulation\n\n    AsterIntegrationErrorMessageFctPtr\n    ExternalLibraryManager::getAsterIntegrationErrorMessageFunction(const std::string& l,\n\t\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto s   = f+\"_getIntegrationErrorMessage\";\n      return ::tfel_getAsterIntegrationErrorMessage(lib,s.c_str());\n    } // end of ExternalLibraryManager::getAsterIntegrationErrorMessage\n    \n    unsigned short\n    ExternalLibraryManager::getAbaqusOrthotropyManagementPolicy(const std::string& l,\n\t\t\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto s   = f+\"_OrthotropyManagementPolicy\";\n      const auto res = ::tfel_getUnsignedShort(lib,s.c_str());\n      raise_if(res<0,\"ExternalLibraryManager::\"\n\t       \"getAbaqusOrthotropyManagementPolicy: \"\n\t       \"information could not be read (\"\n\t       +getErrorMessage()+\")\");\n      raise_if((res!=0)&&(res!=1)&&(res!=2),\n\t       \"ExternalLibraryManager::\"\n\t       \"getAbaqusOrthotropyManagementPolicy: \"\n\t       \"invalid returned value\");\n      return static_cast<unsigned short>(res);\n    } // end of ExternalLibraryManager::getAbaqusOrthotropyManagementPolicy\n    \n    std::vector<std::string>\n    ExternalLibraryManager::getCastemFunctionVariables(const std::string& l,\n\t\t\t\t\t\t       const std::string& f)\n    {\n      std::vector<std::string> vars;\n      this->getCastemFunctionVariables(vars,l,f);\n      return vars;\n    } // end of ExternalLibraryManager::getCastemFunctionVariables\n\n    void\n    ExternalLibraryManager::getCastemFunctionVariables(std::vector<std::string>& vars,\n\t\t\t\t\t\t       const std::string& l,\n\t\t\t\t\t\t       const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      unsigned short nb = this->getCastemFunctionNumberOfVariables(l,f);\n      char ** res = ::tfel_getCastemFunctionVariables(lib,f.c_str());\n      char **p;\n      raise_if(res==nullptr,\n\t       \"ExternalLibraryManager::getCastemFunctionNumberOfVariables: \"\n\t       \" variables names could not be read (\"+getErrorMessage()+\")\");\n      for(p=res;p!=res+nb;++p){\n\tvars.emplace_back(*p);\n      }\n    } // end of ExternalLibraryManager::getCastemFunctionVariables\n\n    CyranoFctPtr ExternalLibraryManager::getCyranoFunction(const std::string& l,\n\t\t\t\t\t\t\t   const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCyranoFunction(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCyranoFunction: \"\n\t       \"could not load Cyrano function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    AbaqusFctPtr\n    ExternalLibraryManager::getAbaqusExternalBehaviourFunction(const std::string& l,\n\t\t\t\t\t\t\t       const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getAbaqusExternalBehaviourFunction(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getAbaqusExternalBehaviourFunction: \"\n\t       \"could not load Abaqus external behaviour '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    AnsysFctPtr\n    ExternalLibraryManager::getAnsysExternalBehaviourFunction(const std::string& l,\n\t\t\t\t\t\t\t      const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getAnsysExternalBehaviourFunction(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getAnsysExternalBehaviourFunction: \"\n\t       \"could not load Ansys external behaviour '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n    \n    AbaqusExplicitFctPtr\n    ExternalLibraryManager::getAbaqusExplicitExternalBehaviourFunction(const std::string& l,\n\t\t\t\t\t\t\t\t       const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getAbaqusExplicitExternalBehaviourFunction(lib,f.c_str());\n      raise_if(fct==nullptr,\"ExternalLibraryManager::\"\n\t       \"getAbaqusExplicitExternalBehaviourFunction: \"\n\t       \"could not load AbaqusExplicit external \"\n\t       \"behaviour '\"+f+\"' (\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CalculiXFctPtr\n    ExternalLibraryManager::getCalculiXExternalBehaviourFunction(const std::string& l,\n\t\t\t\t\t\t\t\t const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      auto fct = ::tfel_getCalculiXExternalBehaviourFunction(lib,f.c_str());\n      raise_if(fct==nullptr,\"ExternalLibraryManager::\"\n\t       \"getCalculiXExternalBehaviourFunction: \"\n\t       \"could not load CalculiX external behaviour '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n    \n    CastemFctPtr\n    ExternalLibraryManager::getCastemExternalBehaviourFunction(const std::string& l,\n\t\t\t\t\t\t\t       const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCastemExternalBehaviourFunction(lib,f.c_str());\n      raise_if(fct==nullptr,\"ExternalLibraryManager::\"\n\t       \"getCastemExternalBehaviourFunction: \"\n\t       \"could not load castem external behaviour '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n    \n    AsterFctPtr\n    ExternalLibraryManager::getAsterFunction(const std::string& l,\n\t\t\t\t\t     const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getAsterFunction(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getAsterFunction: \"\n\t       \"could not load Aster function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    EuroplexusFctPtr\n    ExternalLibraryManager::getEuroplexusFunction(const std::string& l,\n\t\t\t\t\t\t  const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getEuroplexusFunction(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getEuroplexusFunction: \"\n\t       \" could not load Europlexus function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n    \n    void\n    ExternalLibraryManager::getUMATNames(std::vector<std::string>& vars,\n\t\t\t\t\t const std::string& l,\n\t\t\t\t\t const std::string& f,\n\t\t\t\t\t const std::string& h,\n\t\t\t\t\t const std::string& n)\n    {\n      ExternalLibraryManagerCheckModellingHypothesisName(h);\n      const auto lib = this->loadLibrary(l);\n      ExternalLibraryManagerCheckModellingHypothesisName(h);\n      auto nb = ::tfel_getUnsignedShort(lib,(f+\"_\"+h+\"_n\"+n).c_str());\n      if(nb==-1){\n\tnb = ::tfel_getUnsignedShort(lib,(f+\"_n\"+n).c_str());\n      }\n      char ** res;\n      raise_if(nb==-1,\"ExternalLibraryManager::getUMATNames: \"\n\t       \"number of variables names could not be read \"\n\t       \"(\"+getErrorMessage()+\")\");\n      res = ::tfel_getArrayOfStrings(lib,(f+\"_\"+h+'_'+n).c_str());\n      if(res==nullptr){\n\tres = ::tfel_getArrayOfStrings(lib,(f+'_'+n).c_str());\n      }\n      raise_if(res==nullptr,\"ExternalLibraryManager::getUMATNames: \"\n\t       \"variables names could not be read \"\n\t       \"(\"+getErrorMessage()+\")\");\n      std::copy(res,res+nb,std::back_inserter(vars));\n    } // end of ExternalLibraryManager::getUMATNames\n\n    bool\n    ExternalLibraryManager::isUMATBehaviourUsableInPurelyImplicitResolution(const std::string& l,\n\t\t\t\t\t\t\t\t\t    const std::string& f,\n\t\t\t\t\t\t\t\t\t    const std::string& h)\n    {\n     ExternalLibraryManagerCheckModellingHypothesisName(h);\n      const auto lib = this->loadLibrary(l);\n      int b = ::tfel_getBool(lib,(f+\"_\"+h+\"_UsableInPurelyImplicitResolution\").c_str());\n      if(b==-1){\n\tb = ::tfel_getBool(lib,(f+\"_UsableInPurelyImplicitResolution\").c_str());\n      }\n      if(b==-1){\n\treturn false;\n      }\n      return (b==1);\n    } // end of ExternalLibraryManager::isUMATBehaviourUsableInPurelyImplicitResolution\n\n\n    bool\n    ExternalLibraryManager::checkIfUMATBehaviourUsesGenericPlaneStressAlgorithm(const std::string& l,\n\t\t\t\t\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto b = ::tfel_getBool(lib,(f+\"_UsesGenericPlaneStressAlgorithm\").c_str());\n      if(b==-1){\n\treturn false;\n      }\n      return b==1;\n    } // end of ExternalLibraryManager::checkIfUMATBehaviourUsesGenericPlaneStressAlgorithm\n\n    unsigned short\n    ExternalLibraryManager::getUMATBehaviourType(const std::string& l,\n\t\t\t\t\t\t const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto u = ::tfel_getUnsignedShort(lib,(f+\"_BehaviourType\").c_str());\n      raise_if(u==-1,\"ExternalLibraryManager::getUMATBehaviourType: \"\n\t       \"behaviour type could not be read (\"+getErrorMessage()+\")\");\n      return static_cast<unsigned short>(u);\n    } // end of ExternalLibraryManager::getUMATBehaviourType\n\n    unsigned short\n    ExternalLibraryManager::getUMATBehaviourKinematic(const std::string& l,\n\t\t\t\t\t\t      const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto u = ::tfel_getUnsignedShort(lib,(f+\"_BehaviourKinematic\").c_str());\n      raise_if(u==-1,\"ExternalLibraryManager::getUMATBehaviourKinematic: \"\n\t       \"behaviour type could not be read (\"+getErrorMessage()+\")\");\n      return static_cast<unsigned short>(u);\n    } // end of ExternalLibraryManager::getUMATBehaviourKinematic\n    \n    unsigned short\n    ExternalLibraryManager::getUMATSymmetryType(const std::string& l,\n\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto u = ::tfel_getUnsignedShort(lib,(f+\"_SymmetryType\").c_str());\n      raise_if(u==-1,\"ExternalLibraryManager::getUMATSymmetryType: \"\n\t       \"symmetry type could not be read (\"+getErrorMessage()+\")\");\n      return static_cast<unsigned short>(u);\n    } // end of ExternalLibraryManager::getUMATSymmetryType\n\n    unsigned short\n    ExternalLibraryManager::getUMATElasticSymmetryType(const std::string& l,\n\t\t\t\t\t\t       const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto u = ::tfel_getUnsignedShort(lib,(f+\"_ElasticSymmetryType\").c_str());\n      raise_if(u==-1,\"ExternalLibraryManager::getUMATElasticSymmetryType: \"\n\t       \"elastic symmetry type could not be read \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return static_cast<unsigned short>(u);\n    } // end of ExternalLibraryManager::getUMATElasticSymmetryType\n\n    std::vector<std::string>\n    ExternalLibraryManager::getUMATMaterialPropertiesNames(const std::string& l,\n\t\t\t\t\t\t\t   const std::string& f,\n\t\t\t\t\t\t\t   const std::string& h)\n    {\n      std::vector<std::string> vars;\n      this->getUMATNames(vars,l,f,h,\"MaterialProperties\");\n      return vars;\n    } // end of ExternalLibraryManager::getUMATMaterialPropertiesNames\n\n\n    std::vector<std::string>\n    ExternalLibraryManager::getUMATInternalStateVariablesNames(const std::string& l,\n\t\t\t\t\t\t\t       const std::string& f,\n\t\t\t\t\t\t\t       const std::string& h)\n    {\n      std::vector<std::string> vars;\n      this->getUMATNames(vars,l,f,h,\"InternalStateVariables\");\n      return vars;\n    } // end of ExternalLibraryManager::getUMATMaterialPropertiesNames\n\n    std::vector<int>\n    ExternalLibraryManager::getUMATInternalStateVariablesTypes(const std::string& l,\n\t\t\t\t\t\t\t       const std::string& f,\n\t\t\t\t\t\t\t       const std::string& h)\n    {\n      ExternalLibraryManagerCheckModellingHypothesisName(h);\n      std::vector<int> types;\n      const auto lib = this->loadLibrary(l);\n      auto nb = ::tfel_getUnsignedShort(lib,(f+\"_\"+h+\"_nInternalStateVariables\").c_str());\n      if(nb==-1){\n\tnb = ::tfel_getUnsignedShort(lib,(f+\"_nInternalStateVariables\").c_str());\n      }\n      int * res;\n      raise_if(nb==-1,\n\t       \"ExternalLibraryManager::getUMATInternalStateVariablesTypes: \"\n\t       \"number of variables names could not be read \"\n\t       \"(\"+getErrorMessage()+\")\");\n      res = ::tfel_getArrayOfInt(lib,(f+\"_\"+h+\"_InternalStateVariablesTypes\").c_str());\n      if(res==nullptr){\n\tres = ::tfel_getArrayOfInt(lib,(f+\"_InternalStateVariablesTypes\").c_str());\n      }\n      raise_if(res==nullptr,\"ExternalLibraryManager::\"\n\t       \"getUMATInternalStateVariablesTypes: \"\n\t       \"internal state variables types could not be read \"\n\t       \"(\"+getErrorMessage()+\")\");\n      std::copy(res,res+nb,std::back_inserter(types));\n      return types;\n    } // end of ExternalLibraryManager::getUMATInternalVariablesTypes\n    \n    std::vector<std::string>\n    ExternalLibraryManager::getUMATExternalStateVariablesNames(const std::string& l,\n\t\t\t\t\t\t\t       const std::string& f,\n\t\t\t\t\t\t\t       const std::string& h)\n    {\n      std::vector<std::string> vars;\n      this->getUMATNames(vars,l,f,h,\"ExternalStateVariables\");\n      return vars;\n    } // end of ExternalLibraryManager::getUMATMaterialPropertiesNames\n\n    std::vector<std::string>\n    ExternalLibraryManager::getUMATParametersNames(const std::string& l,\n\t\t\t\t\t\t   const std::string& f,\n\t\t\t\t\t\t   const std::string& h)\n    {\n      std::vector<std::string> vars;\n      this->getUMATNames(vars,l,f,h,\"Parameters\");\n      return vars;\n    } // end of ExternalLibraryManager::getUMATMaterialPropertiesNames\n\n    std::vector<int>\n    ExternalLibraryManager::getUMATParametersTypes(const std::string& l,\n\t\t\t\t\t\t   const std::string& f,\n\t\t\t\t\t\t   const std::string& h)\n    {\n      ExternalLibraryManagerCheckModellingHypothesisName(h);\n      std::vector<int> types;\n      const auto lib = this->loadLibrary(l);\n      auto nb = ::tfel_getUnsignedShort(lib,(f+\"_\"+h+\"_nParameters\").c_str());\n      if(nb==-1){\n\tnb = ::tfel_getUnsignedShort(lib,(f+\"_nParameters\").c_str());\n      }\n      int * res;\n      raise_if(nb==-1,\"ExternalLibraryManager::getUMATParametersTypes: \"\n\t       \"number of variables names could not be read \"\n\t       \"(\"+getErrorMessage()+\")\");\n      res = ::tfel_getArrayOfInt(lib,(f+\"_\"+h+\"_ParametersTypes\").c_str());\n      if(res==nullptr){\n\tres = ::tfel_getArrayOfInt(lib,(f+\"_ParametersTypes\").c_str());\n      }\n      raise_if(res==nullptr,\n\t       \"ExternalLibraryManager::getUMATParametersTypes: \"\n\t       \"internal state variables types could not be read \"\n\t       \"(\"+getErrorMessage()+\")\");\n      std::copy(res,res+nb,std::back_inserter(types));\n      return types;\n    } // end of ExternalLibraryManager::getUMATInternalVariablesTypes\n    \n    CastemFunctionPtr\n    ExternalLibraryManager::getCastemFunction(const std::string& l,\n\t\t\t\t\t      const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      auto fct = ::tfel_getCastemFunction(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCastemFunction: \"\n\t       \"could not load castem function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction0Ptr ExternalLibraryManager::getCFunction0(const std::string& l,\n\t\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction0(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction0: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction1Ptr ExternalLibraryManager::getCFunction1(const std::string& l,\n\t\t\t\t\t\t\tconst std::string& f)\n    {\n      using namespace std;\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction1(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction1: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction2Ptr ExternalLibraryManager::getCFunction2(const std::string& l,\n\t\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction2(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction2: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction3Ptr ExternalLibraryManager::getCFunction3(const std::string& l,\n\t\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction3(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction3: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction4Ptr ExternalLibraryManager::getCFunction4(const std::string& l,\n\t\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction4(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction4: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction5Ptr ExternalLibraryManager::getCFunction5(const std::string& l,\n\t\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction5(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction5: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction6Ptr ExternalLibraryManager::getCFunction6(const std::string& l,\n\t\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction6(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction6: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction7Ptr ExternalLibraryManager::getCFunction7(const std::string& l,\n\t\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction7(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction7: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction8Ptr ExternalLibraryManager::getCFunction8(const std::string& l,\n\t\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction8(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction8: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction9Ptr ExternalLibraryManager::getCFunction9(const std::string& l,\n\t\t\t\t\t\t\tconst std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction9(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction9: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction10Ptr ExternalLibraryManager::getCFunction10(const std::string& l,\n\t\t\t\t\t\t\t  const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction10(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction10: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction11Ptr ExternalLibraryManager::getCFunction11(const std::string& l,\n\t\t\t\t\t\t\t  const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction11(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction11: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction12Ptr ExternalLibraryManager::getCFunction12(const std::string& l,\n\t\t\t\t\t\t\t  const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction12(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction12: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction13Ptr ExternalLibraryManager::getCFunction13(const std::string& l,\n\t\t\t\t\t\t\t  const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction13(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction13: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction14Ptr ExternalLibraryManager::getCFunction14(const std::string& l,\n\t\t\t\t\t\t\t  const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction14(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction14: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    CFunction15Ptr ExternalLibraryManager::getCFunction15(const std::string& l,\n\t\t\t\t\t\t\t  const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getCFunction15(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getCFunction15: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction0Ptr ExternalLibraryManager::getFortranFunction0(const std::string& l,\n\t\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction0(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction0: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction1Ptr ExternalLibraryManager::getFortranFunction1(const std::string& l,\n\t\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction1(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction1: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction2Ptr ExternalLibraryManager::getFortranFunction2(const std::string& l,\n\t\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction2(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction2: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction3Ptr ExternalLibraryManager::getFortranFunction3(const std::string& l,\n\t\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction3(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction3: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction4Ptr ExternalLibraryManager::getFortranFunction4(const std::string& l,\n\t\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction4(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction4: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction5Ptr ExternalLibraryManager::getFortranFunction5(const std::string& l,\n\t\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction5(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction5: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction6Ptr ExternalLibraryManager::getFortranFunction6(const std::string& l,\n\t\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction6(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction6: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction7Ptr ExternalLibraryManager::getFortranFunction7(const std::string& l,\n\t\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction7(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction7: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction8Ptr ExternalLibraryManager::getFortranFunction8(const std::string& l,\n\t\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction8(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction8: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction9Ptr ExternalLibraryManager::getFortranFunction9(const std::string& l,\n\t\t\t\t\t\t\t\t    const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction9(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction9: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction10Ptr ExternalLibraryManager::getFortranFunction10(const std::string& l,\n\t\t\t\t\t\t\t\t      const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction10(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction10: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction11Ptr ExternalLibraryManager::getFortranFunction11(const std::string& l,\n\t\t\t\t\t\t\t\t      const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction11(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction11: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction12Ptr ExternalLibraryManager::getFortranFunction12(const std::string& l,\n\t\t\t\t\t\t\t\t      const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction12(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction12: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction13Ptr ExternalLibraryManager::getFortranFunction13(const std::string& l,\n\t\t\t\t\t\t\t\t      const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction13(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction13: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction14Ptr ExternalLibraryManager::getFortranFunction14(const std::string& l,\n\t\t\t\t\t\t\t\t      const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction14(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction14: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n\n    FortranFunction15Ptr ExternalLibraryManager::getFortranFunction15(const std::string& l,\n\t\t\t\t\t\t\t\t      const std::string& f)\n    {\n      const auto lib = this->loadLibrary(l);\n      const auto fct = ::tfel_getFortranFunction15(lib,f.c_str());\n      raise_if(fct==nullptr,\n\t       \"ExternalLibraryManager::getFortranFunction15: \"\n\t       \"could not load function '\"+f+\"' \"\n\t       \"(\"+getErrorMessage()+\")\");\n      return fct;\n    }\n    \n    ExternalLibraryManager::~ExternalLibraryManager() = default;\n\n  } // end of namespace system\n\n} // end of namespace tfel\n",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/System/getFunction.c": "/*!\n * \\file   getFunction.impl\n * \\brief  ths file implements some C wrappers around the dlsym\n * system call.\n * \\author Helfer Thomas\n * \\date   18 december 2008\n */\n\n#include\"getFunction.impl\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/System/getFunction.h": "/*!\n * \\file   getFunction.h\n * \\brief  this file declares some C wrappers around the dlsym\n * system call.\n * \\author Helfer Thomas\n * \\date   13 d\u00e9c 2008\n */\n\n#ifndef LIB_TFEL_GETFUNCTION_H_\n#define LIB_TFEL_GETFUNCTION_H_\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#ifndef NOMINMAX\n#define NOMINMAX\n#endif\n#include <windows.h>\ntypedef HINSTANCE__* LibraryHandlerPtr;\n#else\ntypedef void*        LibraryHandlerPtr;\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n\n#include\"TFEL/System/ExternalFunctionsPrototypes.hxx\"\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif /* LIB_TFEL_GETFUNCTION_H_ */\n\n  /*!\n   * \\brief this function get if the number of argument of the\n   * specified function\n   *\n   * This function search a symbol called name+'_nargs' and interpret\n   * it as and unsigned short. The value of that unsigned short\n   * compared to the number given in argument.\n   *\n   * The name 'castem' comes from an extension we wrote for that\n   * finite element code that uses function with the following\n   * prototype double (*)(const double* const);\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return int, the number of variables (-1 if on error).\n   */\n  int tfel_getCastemFunctionNumberOfVariables(LibraryHandlerPtr,\n\t\t\t\t\t      const char * const);\n  /*!\n   * \\brief this function returns true if the given behaviour requires\n   * an offset for the elastic properties.\n   * \\param l: link to library opened through dlopen\n   * \\param f: name of the behaviour to be checked\n   * \\return int, 0 if false, 1 if true, -1 if an error occured.\n   */\n  int tfel_getUMATRequiresStiffnessTensor(LibraryHandlerPtr,\n\t\t\t\t\t  const char * const);\n  /*!\n   * \\brief this function returns true if the given behaviour requires\n   * an offset of the thermal expansions coefficients.\n   * \\param l: link to library opened through dlopen\n   * \\param f: name of the behaviour to be checked\n   * \\return int, 0 if false, 1 if true, -1 if an error occured.\n   */\n  int tfel_getUMATRequiresThermalExpansionCoefficientTensor(LibraryHandlerPtr,\n\t\t\t\t\t\t\t    const char * const);\n\n  /*!\n   * \\brief this function returns true if the given behaviour saves the tangent operator\n   * \\param l: link to library opened through dlopen\n   * \\param f: name of the behaviour to be checked\n   * \\return int, 0 if false, 1 if true, -1 if an error occured.\n   */\n  int tfel_checkIfAsterBehaviourSavesTangentOperator(LibraryHandlerPtr,\n\t\t\t\t\t\t     const char * const);\n\n  int tfel_getBool(LibraryHandlerPtr,\n\t\t   const char * const);\n\n  int tfel_getUnsignedShort(LibraryHandlerPtr,\n\t\t\t    const char * const);\n\n  double tfel_getDouble(LibraryHandlerPtr,\n\t\t\tconst char * const);\n\n  long double tfel_getLongDouble(LibraryHandlerPtr,\n\t\t\t\t const char * const);\n  \n  int tfel_getInteger(LibraryHandlerPtr,\n\t\t      const char * const);\n  \n  char **\n  tfel_getArrayOfStrings(LibraryHandlerPtr,\n\t\t\t const char * const);\n\n  int *\n  tfel_getArrayOfInt(LibraryHandlerPtr,\n\t\t     const char * const);\n\n  char **\n  tfel_getCastemFunctionVariables(LibraryHandlerPtr,\n\t\t\t\t  const char * const);\n\n  int (TFEL_ADDCALL_PTR tfel_getSetOutOfBoundsPolicyFunction(LibraryHandlerPtr lib,\n\t\t\t\t\t\t\t     const char * const name))(const int);\n\n  int (TFEL_ADDCALL_PTR tfel_getSetParameterFunction(LibraryHandlerPtr lib,\n\t\t\t\t\t\t     const char * const name))(const char* const,\n\t\t\t\t\t\t\t\t\t       const double);\n\n  int (TFEL_ADDCALL_PTR tfel_getSetIntegerParameterFunction(LibraryHandlerPtr lib,\n\t\t\t\t\t\t\t    const char * const name))(const char* const,\n\t\t\t\t\t\t\t\t\t\t      const int);\n\n  int (TFEL_ADDCALL_PTR tfel_getSetUnsignedShortParameterFunction(LibraryHandlerPtr lib,\n\t\t\t\t\t\t\t\t  const char * const name))(const char* const,\n\t\t\t\t\t\t\t\t\t\t\t    const unsigned short);\n  /*!\n   * \\brief this function returns a function of type\n   * void (*)(const CyranoIntegerType  *const,\n   *          const CyranoRealType *const,\n   *          const CyranoRealType *const,\n   *          CyranoRealType *const,\n   * \t      const CyranoRealType *const,\n   * \t      const CyranoRealType *const,\n   * \t      const CyranoRealType *const,\n   * \t      const CyranoRealType *const,\n   * \t      const CyranoRealType *const,\n   * \t      const CyranoIntegerType  *const,\n   * \t      const CyranoRealType *const,\n   * \t      const CyranoRealType *const,\n   * \t      CyranoRealType *const,\n   * \t      const CyranoIntegerType  *const,\n   * \t      CyranoRealType *const,\n   * \t      const CyranoIntegerType  *const,\n   * \t      CyranoIntegerType  *const);\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  void (TFEL_ADDCALL_PTR tfel_getCyranoFunction(LibraryHandlerPtr,const char * const))(const CyranoIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t       CyranoRealType *const,\n\t\t\t\t\t\t\t\t\t\t       const CyranoIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t       CyranoIntegerType  *const);\n  /*!\n   * \\return a pointer to an Abaqus/Standard (umat) external behaviour\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param[in] l: link to library opened through dlopen\n   * \\param[in] n: name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  void (TFEL_ADDCALL_PTR tfel_getAbaqusExternalBehaviourFunction(LibraryHandlerPtr,const char * const))(AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t       AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const char      *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t     AbaqusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t     const int);\n  /*!\n   * \\return a pointer to a Abaqus/Explicit (vumat) external behaviour\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param[in] l: link to library opened through dlopen\n   * \\param[in] n: name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  void (TFEL_ADDCALL_PTR tfel_getAbaqusExplicitExternalBehaviourFunction(LibraryHandlerPtr,\n\t\t\t\t\t\t\t\t\t const char * const))(const AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const char* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     const AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t     AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t      AbaqusRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t      const int);\n  /*!\n   * \\return a pointer to an Ansys (usermat) behaviour\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param[in] l: link to library opened through dlopen\n   * \\param[in] n: name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  void (TFEL_ADDCALL_PTR tfel_getAnsysExternalBehaviourFunction(LibraryHandlerPtr,const char * const))(const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\t       const AnsysRealType *const);\n  /*!\n   * \\return a pointer to a Castem external behaviour\n   * \\param[in] l : library\n   * \\param[in] n : external behaviour name\n   */\n  void (TFEL_ADDCALL_PTR tfel_getCastemExternalBehaviourFunction(LibraryHandlerPtr,const char * const))(CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst char      *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tCastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst CastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t\tCastemIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t\tconst int);\n\n /*!\n   * \\brief this function returns a function of type\n   *  void (*)(AsterRealType *const,\n   *\t       AsterRealType *const,\n   *\t       AsterRealType *const,\n   *\t       const AsterRealType *const,\n   *\t       const AsterRealType *const,\n   *\t       const AsterRealType *const,\n   *\t       const AsterRealType *const,\n   *\t       const AsterRealType *const,\n   *\t       const AsterRealType *const,\n   *\t       const AsterRealType *const,\n   *\t       const AsterIntegerType  *const,\n   *\t       const AsterIntegerType  *const,\n   *\t       const AsterRealType *const,\n   *\t       const AsterIntegerType  *const,\n   *\t       const AsterRealType *const,\n   *\t       AsterRealType *const,\n   *\t       const AsterIntegerType  *const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  void (TFEL_ADDCALL_PTR tfel_getAsterFunction(LibraryHandlerPtr,const char * const))(AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      AsterRealType *const,\n\t\t\t\t\t\t\t\t\t\t      const AsterIntegerType  *const);\n /*!\n   * \\brief this function returns a function of type\n   *  const char* (*)(void)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param[in] lib: handler to the library opened through dlopen\n   * \\param[in] f: name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  const char* (TFEL_ADDCALL_PTR tfel_getAsterIntegrationErrorMessage(LibraryHandlerPtr,const char * const))();\n /*!\n   * \\brief this function returns a pointer to an europlexus external\n   * function.\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param l: library opened through dlopen\n   * \\param f: name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  void (TFEL_ADDCALL_PTR tfel_getEuroplexusFunction(LibraryHandlerPtr,const char * const))(EuroplexusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t   EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   EuroplexusIntegerType *const,\n\t\t\t\t\t\t\t\t\t\t\t   char *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusIntegerType  *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusRealType *const,\n\t\t\t\t\t\t\t\t\t\t\t   const EuroplexusIntegerType  *const);\n  /*!\n   * \\return a pointer to an CalculiX external behaviour\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param[in] l: link to library opened through dlopen\n   * \\param[in] n: name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  void (TFEL_ADDCALL_PTR tfel_getCalculiXExternalBehaviourFunction(LibraryHandlerPtr,const char * const))(const char * const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CalculiXRealType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const CalculiXIntegerType* const,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  const int);\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double * const)\n   *\n   * The name 'castem' comes from an extension we wrote for that\n   * finite element code that uses function with the following\n   * prototype double (*)(const double* const);\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCastemFunction(LibraryHandlerPtr,const char * const))(const double*const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(void)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction0(LibraryHandlerPtr,const char * const))(void);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction1(LibraryHandlerPtr,const char * const))(double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction2(LibraryHandlerPtr,const char * const))(double,double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction3(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t     double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction4(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction5(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double,\n\t\t\t\t\t\t\t\t\t\t     double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double,double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction6(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double,double,double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction7(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double,\n\t\t\t\t\t\t\t\t\t\t     double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double,double,double,double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction8(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double,double,double,double,double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction9(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double,\n\t\t\t\t\t\t\t\t\t\t     double,double,\n\t\t\t\t\t\t\t\t\t\t     double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double,double,double,double,double,double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction10(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double,\n   *          double,double,double,double,\n   *          double,double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction11(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double,\n   *          double,double,double,double,\n   *          double,double,double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction12(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double,\n   *          double,double,double,double,\n   *          double,double,double,double,\n   *          double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction13(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double,\n   *          double,double,double,double,\n   *          double,double,double,double,\n   *          double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction14(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(double,double,double,double,\n   *          double,double,double,double,\n   *          double,double,double,double,\n   *          double,double,double)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getCFunction15(LibraryHandlerPtr,const char * const))(double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double,double,\n\t\t\t\t\t\t\t\t\t\t      double);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(void)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction0(LibraryHandlerPtr,const char * const))(void);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction1(LibraryHandlerPtr,const char * const))(const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction2(LibraryHandlerPtr,const char * const))(const double* const,const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction3(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction4(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction5(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const,const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction6(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const,const double* const,const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction7(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const,const double* const,const double* const,const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction8(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const,const double* const,const double* const,const double* const,const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction9(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t   const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const,const double* const,const double* const,const double* const,const double* const,const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction10(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction11(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const,const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction12(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const,const double* const,const double* const,\n   *          const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction13(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction14(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const);\n\n  /*!\n   * \\brief this function returns a function of type\n   * double (*)(const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const,const double* const,const double* const,\n   *          const double* const,const double* const,const double* const)\n   *\n   * This function is a simple wrapper around dlsym. We can check if a\n   * symbol with the given name exists but cannot check if it points to\n   * a function with that prototype.\n   *\n   * \\param LibraryHandlerPtr, link to library opened through dlopen\n   * \\param const char * const, name of the function to be checked\n   * \\return a function pointer if the call succeed, the NULL pointer if not.\n   */\n  double (TFEL_ADDCALL_PTR tfel_getFortranFunction15(LibraryHandlerPtr,const char * const))(const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const,const double* const,\n\t\t\t\t\t\t\t\t\t\t\t    const double* const);\n#ifdef\t__cplusplus\n}\n#endif /* LIB_TFEL_GETFUNCTION_H_ */\n\n#endif /* LIB_TFEL_GETFUNCTION_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/ansys/usermat.cpp": "#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#include <windows.h>\n#else /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n#include <dlfcn.h>\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n\n#include<vector>\n#include<string>\n#include<cstdlib>\n#include<sstream>\n#include<fstream>\n#include<iostream>\n#include<algorithm>\n\nstatic std::vector<std::string>\ntokenize(const std::string& s,\n\t const char c)\n{\n  using namespace std;\n  vector<string> res;\n  string::size_type b = 0u;\n  string::size_type e = s.find_first_of(c, b);\n  while (string::npos != e || string::npos != b){\n    // Found a token, add it to the vector.\n    res.push_back(s.substr(b, e - b));\n    b = s.find_first_not_of(c, e);\n    e = s.find_first_of(c, b);\n  }\n  return res;\n} // end of tokenize\n\nstatic std::string strim_front(const std::string& s)\n{\n  std::string::size_type b = 0u;\n  std::string::size_type e = s.size();\n  while(b!=e){\n    if(!std::isspace(s[b])){\n      return s.substr(b);\n    }\n    ++b;\n  }\n  return \"\";\n}\n\nstatic std::string strim_back(const std::string& s)\n{\n  std::string::size_type b = 0u;\n  std::string::size_type e = s.size();\n  while(b!=e){\n    if(std::isspace(s[b])){\n      return s.substr(0,b);\n    }\n    ++b;\n  }\n  return s;\n}\n\nstatic std::string strim(const std::string& s)\n{\n  return strim_front(strim_back(s));\n} // end of tokenize\n\nstatic std::vector<std::string>\nstrim(const std::vector<std::string>& v)\n{\n  auto r = std::vector<std::string>{};\n  r.reserve(v.size());\n  for(const auto& s : v){\n    auto ss = strim(s);\n    if(!ss.empty()){\n      r.push_back(std::move(ss));\n    }\n  }\n  return r;\n} // end of tokenize\n\nnamespace ansys{\n\n  /*!\n   * structure in charge of associating a MFront behaviour to a\n   * material by reading the `mfront-usermat.dat` file in the current\n   * directory.\n   */\n  struct UserMaterialManager\n  {\n    //! a simple alias\n    using AnsysIntegerType = int;\n    //! a simple alias\n    using AnsysRealType    = double;\n    //! a simple alias\n    using  AnsysFctPtr     = void (*)(const AnsysIntegerType *const,const AnsysIntegerType *const,\n\t\t\t\t      const AnsysIntegerType *const,const AnsysIntegerType *const,\n\t\t\t\t      const AnsysIntegerType *const,const AnsysIntegerType *const,\n\t\t\t\t      const AnsysIntegerType *const,AnsysIntegerType *const,\n\t\t\t\t      const AnsysIntegerType *const,const AnsysIntegerType *const,\n\t\t\t\t      const AnsysIntegerType *const,const AnsysIntegerType *const,\n\t\t\t\t      const AnsysIntegerType *const,const AnsysRealType *const,\n\t\t\t\t      const AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t      const AnsysRealType *const,AnsysRealType *const,\n\t\t\t\t      AnsysRealType *const,AnsysRealType *const,\n\t\t\t\t      AnsysRealType *const,AnsysRealType *const,\n\t\t\t\t      AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t      const AnsysRealType *const,AnsysRealType *const,\n\t\t\t\t      const AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t      const AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t      const AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t      AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t      const AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t      const AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t      const AnsysRealType *const,const AnsysRealType *const,\n\t\t\t\t      const AnsysRealType *const);\n    //! default constructor\n    UserMaterialManager();\n    /*!\n     * \\return the function associated to a material identifier\n     * \\param[in] id: material identifier\n     */\n    AnsysFctPtr getBehaviour(const AnsysIntegerType) const;\n    //! destructor\n    ~UserMaterialManager();\n  private:\n    //! a simple alias\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n    using libhandler = HINSTANCE__*;\n#else /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    using libhandler = void*;\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    /*!\n     * \\brief internal data structure storing pointers to MFront\n     * behavour and the associated material identifier\n     */\n    struct UserMaterialHander{\n      //! material identifier\n      const int id;\n      //! pointer to the MFront behaviour\n      const AnsysFctPtr f;\n    }; // end of struct UserMaterialHander\n    //! internal data structure storing pointers to external libraries\n    struct ExternalLibraryHandler{\n      //! library name\n      const std::string name;\n      //! library handler\n      const libhandler  l;\n    }; // end of struct ExternalLibraryHandler\n    //! list of all registred behaviours\n    std::vector<UserMaterialHander> handlers;\n    //! list of all loaded library\n    std::vector<ExternalLibraryHandler> libraries;\n    /* deleted methods */\n    UserMaterialManager(UserMaterialManager&&) = delete;\n    UserMaterialManager(const UserMaterialManager&) = delete;\n    UserMaterialManager& operator=(UserMaterialManager&&) = delete;\n    UserMaterialManager& operator=(const UserMaterialManager&) = delete;\n  }; // end of struct UserMaterialManager\n\n  UserMaterialManager::UserMaterialManager()\n  {\n    auto exit_if = [](const bool b,const std::string& m){\n      if(b){\n\tstd::cerr << \"UserMaterialManager::UserMaterialManager: \"\n\t<< m  << '\\n';\n\tstd::exit(-1);\n      }\n    };\n    auto find_library = [this](const std::string&n){\n      return std::find_if(this->libraries.begin(),\n\t\t\t  this->libraries.end(),[&n](const ExternalLibraryHandler& l){\n\t\t\t    return l.name==n;\n\t\t\t  });\n    };\n    std::ifstream in(\"mfront-usermat.dat\");\n    exit_if(!in,\"unable to open file 'mfront-usermat.dat'\");\n    std::string line;\n    size_t ln = 1u;\n    while(getline(in, line)) {\n      auto tokens = strim(tokenize(line,','));\n      for(const auto& w : tokens){\n\tstd::cout << \"'\" << w << \"'\";\n      }\n      std::cout << std::endl;\n      if((tokens.empty())||(tokens[0]==\"/com\")){\n\tcontinue;\n      }\n      if(tokens[0]==\"tb\"){\n\texit_if(tokens.size()<2,\"invalid line '\"+std::to_string(ln)+\"' in file 'mfront-usermat.dat'\");\n\texit_if(tokens[1]!=\"mfront\",\"invalid line '\"+std::to_string(ln)+\"' in file 'mfront-usermat.dat'\");\n\texit_if(tokens.size()!=5,\"invalid line '\"+std::to_string(ln)+\"' in file 'mfront-usermat.dat'\");\n\tconst auto id  = std::stoi(tokens[2]);\n\tconst auto lib = tokens[3];\n\tconst auto fct = tokens[3];\n\tstd::cout << \"UserMaterialManager::UserMaterialManager: \"\n\t\t  << \"associating material '\" << id << \"' to behaviour '\"\n\t\t  << fct << \"' in library '\" << lib << \"'\\n\";\n\tauto ptr = find_library(lib);\n\tif(ptr==this->libraries.end()){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#error \"unsupported yet\"\n#else  /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n\t  libhandler l = ::dlopen(lib.c_str(),RTLD_NOW);\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n\t  exit_if(l==nullptr,\"unable to load library '\"+lib+\"'\");\n\t  this->libraries.push_back(ExternalLibraryHandler{lib,l});\n\t  ptr = std::prev(this->libraries.end());\n\t}\n\texit_if(this->getBehaviour(id)!=nullptr,\n\t\t\"a behaviour has already been associated to material \"\n\t\t\"identifier '\"+std::to_string(id)+\"'\");\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#error \"unsupported yet\"\n#else  /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n\tauto f = reinterpret_cast<AnsysFctPtr>(::dlsym(ptr->l,fct.c_str()));\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n\texit_if(f==nullptr,\"could not load behavour '\"+fct+\"' in library '\"+lib+\"'\");\n\tthis->handlers.push_back(std::move(UserMaterialHander{id,f}));\n      }\n      ++ln;\n    }\n    exit_if(in.bad(),\"error while reading file 'mfront-usermat.dat'\");\n    in.close();\n  } // end of UserMaterialManager::UserMaterialManager\n\n  UserMaterialManager::AnsysFctPtr\n  UserMaterialManager::getBehaviour(const AnsysIntegerType id) const{\n    for(const auto& h: this->handlers){\n      if(h.id==id){\n\treturn h.f;\n      }\n    }\n    return nullptr;\n  }\n  \n  UserMaterialManager::~UserMaterialManager()\n  {\n    for(auto& l:this->libraries){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#error \"unsupported yet\"\n#else  /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n      ::dlclose(l.l);\n#endif /* (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__) */\n    }\n  } // end of UserMaterialManager::~UserMaterialManager\n\n  \n} // end of namespace ansys\n\nextern \"C\" {\n\n  void usermat(const int *const matId,const int *const elemId,const int *const kDomIntPt,\n\t       const int *const kLayer,const int *const kSectPt,const int *const ldsetp,\n\t       const int *const isubst,int *const keycut,const int *const nDirect,\n\t       const int *const nShear,const int *const ncomp,const int *const nSatev,\n\t       const int *const nProp,const double *const Time,const double *const dTime,\n\t       const double *const Temp,const double *const dTemp,double *const stress,\n\t       double *const statev,double *const dsdePl,double *const sedEl,\n\t       double *const sedPl,double *const epseq,const double *const Strain,\n\t       const double *const dStrain,double *const epsPl,const double *const prop,\n\t       const double *const coords,const double *const rotateM,const double *const defGrad_t,\n\t       const double *const defGrad,const double *const tsstif,double *const epsZZ,\n\t       const double *const var1,const double *const var2,const double *const var3,\n\t       const double *const var4,const double *const var5,const double *const var6,\n\t       const double *const var7,const double *const var8)\n  {\n    static ansys::UserMaterialManager m;\n    auto f = m.getBehaviour(*matId);\n    if(f==nullptr){\n      std::cerr << \"usermat: no behaviour associated to material id '\"\n\t\t<< *matId << \"'\\n\";\n      std::exit(-1);\n    }\n    f(matId,elemId,kDomIntPt,kLayer,kSectPt,\n      ldsetp,isubst,keycut,nDirect,nShear,\n      ncomp,nSatev,nProp,Time,dTime,Temp,\n      dTemp,stress,statev,dsdePl,sedEl,\n      sedPl,epseq,Strain,dStrain,epsPl,\n      prop,coords,rotateM,defGrad_t,defGrad,\n      tsstif,epsZZ,var1,var2,var3,var4,\n      var5,var6,var7,var8);\n  } // end of usermat\n  \n} // end of extern \"C\"\n\n// int main(void){\n//   ansys::UserMaterialManager m;\n//   return m.getBehaviour(2)!=nullptr;\n// }\n",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/general/mfront.tex.in": "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% File      : mfront.tex\n% Author    : Helfer Thomas\n% Date      : 15 oct. 2012\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n% \\documentclass[rectoverso,pleiades,pstricks,leqno,anti]{note_technique_2010}\n\\documentclass[rectoverso,pleiades,pstricks,leqno,anti,projet]{note_technique_2010}\n\n% \\usepackage{draftcopy}\n% \\draftcopySetGrey{0.8}\n% \\draftcopyName{Version provisoire}{80}\n\n\\usepackage[dvips]{graphicx}\n\\usepackage[dvips,breaklinks]{hyperref}\n\n\\usepackage{mathematiques}\n\\usepackage{mecanique}\n\\usepackage{couleurs}\n\\usepackage{presentation}\n\n\\usepackage{pst-plot}\n\\usepackage{array}\n\\usepackage{subfigure}\n\\usepackage{relsize}\n\\usepackage{multind}\n\n% one column index\n\\makeatletter\n\\def\\printindex#1#2{\\section*{#2}\n\\addcontentsline{toc}{section}{#2}\n\\@input{#1.ind}}\n\\makeatother\n\n\\usepackage[frenchb]{babel}\n\n\\newcommand{\\pleiades}{\\texttt{pleiades}}\n\\newcommand{\\TFEL}{\\texttt{tfel}}\n\\newcommand{\\mfront}{\\texttt{mfront}}\n\\newcommand{\\licos}{\\texttt{licos}}\n\\newcommand{\\cyrano}{\\texttt{cyrano}}\n\\newcommand{\\alcyone}{\\texttt{alcyone}}\n\\newcommand{\\germinal}{\\texttt{germinal}}\n\\newcommand{\\celaeno}{\\texttt{celaeno}}\n\\newcommand{\\galileo}{\\texttt{galileo}}\n\\newcommand{\\castem}{\\texttt{Cast3M}}\n\\newcommand{\\gibiane}{\\texttt{gibiane}}\n\\newcommand{\\tmfft}{\\texttt{TMFFT}}\n\\newcommand{\\aster}{\\href{http://www.code-aster.org/}{\\texttt{Aster}}}\n\\newcommand{\\pycastem}{\\texttt{pyCast3M}}\n\\newcommand{\\umat}{\\texttt{umat}}\n\\newcommand{\\sirius}{\\texttt{sirius}}\n\\newcommand{\\fortran}{\\texttt{fortran}}\n\n\\newcommand{\\cmake}{\\href{http://www.cmake.org/}{\\texttt{cmake}}}\n\\newcommand{\\autotools}{\\href{http://fr.wikipedia.org/wiki/Autotools}{\\texttt{autotools}}}\n\\newcommand{\\python}{\\href{http://python.org}{\\texttt{python}}}\n\\newcommand{\\gnuplot}{\\href{http://www.gnuplot.info}{\\texttt{gnuplot}}}\n\\newcommand{\\latex}{\\href{http://www.latex-project.org}{\\LaTeX2e{}}}\n\\newcommand{\\make}{\\href{http://www.gnu.org/software/make/}{\\texttt{make}}}\n\\newcommand{\\doxygen}{\\href{http://www.stack.nl/~dimitri/doxygen/}{\\texttt{doxygen}}}\n\\newcommand{\\valgrind}{\\href{http://www.valgrind.org/}{\\texttt{valgrind}}}\n\n\\newcommand{\\mkey}[1]{\\index{mkeys}{#1@\\symbol{64}#1}{\\texttt{@#1}}}\n\\newcommand{\\mkeyb}[2]{\\index{mkeys}{#1@\\symbol{64}#1}{\\texttt{@#2}}}\n\n\\newcommand{\\env}[1]{\\index{env}{#1}{\\texttt{#1}}}\n\\newcommand{\\envb}[2]{\\index{env}{#1}{\\texttt{#2}}}\n\n\\newcommand{\\moption}[1]{\\texttt{-{}-#1}}\n\n\\newcommand{\\bigO}[1]{\\ensuremath{\\mathop{}\\mathopen{}O\\mathopen{}\\left(#1\\right)}}\n\n\\newcommand{\\bqc}{\\ensuremath{B_{4}C}}\n\\newcommand{\\bd}{\\ensuremath{\\mbox{}^{10}B}}\n\n%c from texinfo.tex\n\\def\\ifmonospace{\\ifdim\\fontdimen3\\font=0pt }\n\n%c C plus plus\n\\def\\cpp{%\n\\ifmonospace%\n    C++%\n\\else%\n    C\\kern.1em\\raise.20ex\\hbox{\\smaller{++}}%\n\\fi%\n\\spacefactor1000 }\n\n\\newcommand{\\varcpp}[1]{\\texttt{#1}}\n\n\\newcommand{\\sigmaH}{\\ensuremath{\\sigma_{H}}}\n\n\\newcommand{\\nbzrc}{$NbZrC$}\n\\newcommand{\\upuc}{$\\paren{U,Pu}C$}\n\\newcommand{\\sic}{$SiC$}\n\n\\newcommand{\\cea}{CEA}\n\\newcommand{\\windows}{\\href{http://www.microsoft.com/france/windows/default.mspx}{\\texttt{Windows}}}\n\\newcommand{\\unix}{\\href{http://www.kernel.org/}{\\texttt{unix}}}\n\\newcommand{\\msys}{\\href{http://www.mingw.org/wiki/MSYS}{\\texttt{msys}}}\n\\newcommand{\\cygwin}{\\href{http://www.cygwin.com/}{\\texttt{cygwin}}}\n\\newcommand{\\linux}{\\href{http://www.kernel.org/}{\\texttt{linux}}}\n\\newcommand{\\debian}{\\href{http://www.debian.org/}{\\texttt{Debian}}}\n\\newcommand{\\ubuntu}{\\href{http://www.ubuntu.com}{\\texttt{Ubuntu}}}\n\\newcommand{\\redhat}{\\href{http://www.redhat.com}{\\texttt{Red Hat}}}\n\\newcommand{\\mandriva}{\\href{http://www.mandriva.com}{\\texttt{Mandriva}}}\n\\newcommand{\\excel}{\\href{http://www.microsoft.com/france/office/2007/programs/excel/overview.mspx}{\\texttt{Microsoft Office Excel}}}\n\n\\newcommand{\\debutpas}[1]{\\ensuremath{\\left.#1\\right|_{t}}}\n\\newcommand{\\milieupas}[1]{\\ensuremath{\\left.#1\\right|_{t+\\theta\\, \\Delta\\, t}}}\n\\newcommand{\\finpas}[1]{\\ensuremath{\\left.#1\\right|_{t+\\Delta\\, t}}}\n\\newcommand{\\demipas}[1]{\\ensuremath{\\left.#1\\right|_{t+\\frac{\\Delta\\, t}{2}}}}\n\n\\newcommand{\\code}[1]{\n  \\psframebox[linecolor=ceaorange]{\n    \\begin{minipage}[htbp]{1.0\\linewidth}\n      \\ttfamily #1\n    \\end{minipage}\n  }\n}\n\n\\newcommand{\\bash}[1]{\n  \\begin{center}\n    \\begin{minipage}{0.8\\linewidth}\n      \\footnotesize{}\n      \\texttt{\\$#1}\n    \\end{minipage}\n  \\end{center}\n}\n\n\\include{Champs}\n\n\\resumecea{\n  L'une des missions de la plate-forme \\pleiades{} est de capitaliser\n  les connaissances mat\u00e9riau utilis\u00e9es pour la simulation des \u00e9l\u00e9ments\n  combustibles et absorbants.\n\n  \\mfront{} est un g\u00e9n\u00e9rateur de code d\u00e9di\u00e9 aux connaissances\n  mat\u00e9riau. Son domaine d'application couvre~:\n  \\begin{itemize}\n    \\item les propri\u00e9t\u00e9s mat\u00e9riau~;\n    \\item les lois de comportement~;\n    \\item les mod\u00e8les,\n  \\end{itemize} \n  pour lesquels il rassemble un important savoir-faire\n  physique, num\u00e9rique et informatique.\n\n  Coupl\u00e9 \u00e0 la base de donn\u00e9es \\sirius{}, \\mfront{} vise \u00e0 garantir une\n  gestion p\u00e9renne, robuste, efficace et \u00e9volutive des connaissances\n  mat\u00e9riau dans la plate-forme\n  \\pleiades{}~\\cite{michel_etude_2009,helfer_bilan_2011}. Il permet \u00e9galement \u00e0\n  des utilisateurs non d\u00e9veloppeur d'\u00e9crire leurs propres\n  connaissances mat\u00e9riau~\\cite{helfer_ajout_2010}.\n\n  Il s'agit d'un outil mature, qui se veut de qualit\u00e9 industrielle et\n  qui int\u00e9resse fortement diff\u00e9rents d\u00e9partements du\n  \\cea{}~\\cite{helfer_presentation_2011,darrigo_notice_2012} ainsi que ses\n  partenaires, Areva~\\cite{olagnon_analysis_2013} et\n  \u00c9DF~\\cite{proix_integration_2013}.\n\n  Nous d\u00e9crivons dans cette note l'utilisation de \\mfront{} et\n  d\u00e9taillons comment \u00e9crire des propri\u00e9t\u00e9s mat\u00e9riau et des\n  mod\u00e8les. Les lois de comportement m\u00e9caniques sont d\u00e9taill\u00e9es dans\n  une note \u00e0 part~\\cite{helfer_generateur_2013}.\n}\n\n\\makeindex{env}\n\\makeindex{mkeys}\n\n\\begin{document}\n\n\\clearpage\n\\newpage\n\\section{Introduction}\n\nCette note donne une vue g\u00e9n\u00e9rale du g\u00e9n\u00e9rateur de code \\mfront{} et\nde son application aux propri\u00e9t\u00e9s mat\u00e9riau et aux mod\u00e8les\nphysico-chimiques. Elle est compl\u00e9t\u00e9e par trois autres notes qui\ntraitent\\footnote{Un guide de r\u00e9f\u00e9rence de la librairie \\TFEL{} est\n  \u00e9galement en cours de r\u00e9daction. Cette note \u00e9tant assez ambitieuse,\n  sa r\u00e9daction s'\u00e9talera dans le temps. Elle est cependant disponible\n  en version projet dans les sources de la librairie. Elle contient en\n  particulier le guide d'installation de la librairie.}~:\n\\begin{itemize}\n\\item des lois de comportement\n  m\u00e9canique~\\cite{helfer_generateur_2013}~;\n\\item de l'interface {\\tt umat} utilis\u00e9e par le code aux \u00e9l\u00e9ments\n  finis \\castem{}~\\cite{helfer_interface_2013}~;\n\\item de l'interface utilis\u00e9e par le code aux \u00e9l\u00e9ments finis\n  \\aster{}~\\cite{helfer_interface_2013-1}~;\n\\end{itemize}\n\n\\mfront{} fait partie d'une librairie math\u00e9matique g\u00e9n\u00e9raliste nomm\u00e9e\n\\TFEL{} tr\u00e8s utilis\u00e9e par \\mfront{}, mais qui a \u00e9galement de\nnombreuses autres utilisations dans la plate-forme \\pleiades{}.  Ces\nnotes sont int\u00e9gr\u00e9es \u00e0 la gestion de configuration de \\TFEL{} et\n\u00e9voluent contin\u00fbment avec les d\u00e9veloppements de \\TFEL{}\\footnote{ La\n  version la plus \u00e0 jour est obtenue dans le r\u00e9pertoire de compilation\n  des sources par la commande~:\n\\begin{center}\n  {\\tt make doc-pdf}\n\\end{center}}. Le pr\u00e9sent document a \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9 \u00e0 partir de la\nr\u00e9vision @TFEL_SVN_REVISION@.\n\n\\subsection{Objectif de \\mfront{}}\n\nD\u00e9velopp\u00e9 dans le cadre de la plateforme \\pleiades{} du \\cea{},\n\\mfront{} vise \u00e0 garantir une gestion p\u00e9renne, robuste, efficace et\n\u00e9volutive (au sens du suivi des \u00e9volutions logicielles) des\nconnaissances mat\u00e9riau et \u00e0 faciliter leurs \u00e9critures par des\nutilisateurs non d\u00e9veloppeurs~\\cite{michel_etude_2009,helfer_bilan_2011}~:\n\\begin{itemize}\n\\item la p\u00e9rennisation et le caract\u00e8re \u00e9volutif des connaissances\n  mat\u00e9riau est assur\u00e9 par~:\n  \\begin{itemize}\n  \\item l'\u00e9criture des connaissances mat\u00e9riau dans un fichier\n    ind\u00e9pendant du contexte logiciel cible (code ou langage de\n    programmation). Ce fichier contient uniquement l'information\n    physique et, \u00e9ventuellement, des informations num\u00e9riques. Ce\n    fichier sert \u00e0 g\u00e9n\u00e9rer des sources \\cpp{} qui sont adapt\u00e9es au\n    contexte par l'utilisation de la notion d'interface (voir\n    section~\\ref{sec:mfront:interface}). Si le code ou le langage\n    cible \u00e9volue, il suffit de faire \u00e9voluer l'interface, sans\n    modifier le fichier \\mfront{}\\footnote{Pour illustrer notre\n      propos, donnons quelques exemples~:\n      \\begin{itemize}\n      \\item l'architecture \\(V2.0\\) fournit une interface aux\n        propri\u00e9t\u00e9s mat\u00e9riau qui a permis de porter l'ensemble de\n        propri\u00e9t\u00e9s mat\u00e9riau de {\\tt MAIA}. Le temps de d\u00e9veloppement\n        de l'interface est de l'ordre de l'heure~;\n      \\item toutes les lois de comportement m\u00e9canique \u00e9crites avec\n        \\mfront{} peuvent \u00eatre utilis\u00e9es ou dans le code aux \u00e9l\u00e9ments\n        finis \\castem{}~\\cite{cea_site_2013} ou dans le code\n        \\aster{}~\\cite{edf_site_2013}. Le support d'autres codes est\n        envisageable~;\n      \\item certains mod\u00e8les utilis\u00e9s dans \\licos{} sont rest\u00e9s\n        inchang\u00e9s depuis leur \u00e9criture pour l'application \\celaeno{}\n        (les deux codes n'ont plus grand chose de commun)~;\n      \\item Les mod\u00e8les \\mfront{} sont interchangeables entre les\n        \\licos{} et \\germinal{}, ce qui n'est pas le cas des mod\u00e8les\n        \u00e9crits en \\cpp{}~;\n      \\item Les mod\u00e8les \\mfront{} utilis\u00e9s dans \\germinal{} ne seront\n        pas modifi\u00e9s par le passage \u00e0 l'architecture \\(2.0\\).\n      \\end{itemize}\n    }\n  \\item l'utilisation du langage \\cpp{}, actuellement consid\u00e9r\u00e9 comme\n    l'un des langages les plus utilis\u00e9s au monde\\footnote{Il s'agit du\n      langage le plus utilis\u00e9 si on consid\u00e8re le langage \\texttt{C}\n      comme un sous-ensemble du \\cpp{}, et du troisi\u00e8me ou quatri\u00e8me\n      langage si on les distingue~\\cite{software_programming_2013}.} et qui est\n    particuli\u00e8rement utilis\u00e9 dans le monde scientifique~;\n  \\end{itemize}\n\\item les performances, en particulier pour les lois de comportement\n  m\u00e9caniques, sont \u00e9galement assur\u00e9es par l'utilisation du langage\n  \\cpp{} qui permet d'utiliser des techniques de programmation\n  extr\u00eamement efficaces. Ces bonnes performances ont \u00e9t\u00e9 constat\u00e9es \u00e0\n  plusieurs\n  reprises~\\cite{michel_etude_2009,helfer_bilan_2011,proix_integration_2013,olagnon_analysis_2013}~;\n\\item la simplicit\u00e9 d'utilisation est li\u00e9e \u00e0 l'utilisation de la\n  g\u00e9n\u00e9ration de code, qui permet de masquer la plupart des d\u00e9tails\n  informatiques. Dans le cas des lois de comportement m\u00e9canique,\n  l'\u00e9criture d'une biblioth\u00e8que de calcul tensorielle permet de\n  d\u00e9crire les \u00e9quations r\u00e9gissant l'\u00e9volution des variables internes\n  sous une forme quasi-symbolique.\n\\end{itemize}\n\nLes fichiers \u00e9crits en \\mfront{} sont capitalis\u00e9s dans une base de\ndonn\u00e9es propre \u00e0 la plate-forme nomm\u00e9e \\sirius{}.\n\n\\subsection{Plan de la note}\n\nLa premi\u00e8re partie constitue une pr\u00e9sentation g\u00e9n\u00e9rale de\n\\mfront{} et de son utilisation.\n\nLa seconde partie d\u00e9crit comment \u00e9crire des propri\u00e9t\u00e9s mat\u00e9riau.\n\nLa troisi\u00e8me partie est d\u00e9di\u00e9e \u00e0 l'\u00e9criture des mod\u00e8les\nphysico-chimiques.\n\nLes annexes traitent des questions suivantes~:\n\\begin{itemize}\n\\item le contr\u00f4le de la compilation des fichiers \\mfront{} en\n  librairies dynamiques~;\n\\item l'interface {\\tt C} aux propri\u00e9t\u00e9s mat\u00e9riau~;\n\\item l'interface \\castem{} aux propri\u00e9t\u00e9s mat\u00e9riau~;\n\\item l'interface \\python{} aux propri\u00e9t\u00e9s mat\u00e9riau~;\n\\item l'appel de propri\u00e9t\u00e9s mat\u00e9riaux externes dans \\castem{} et des\n  modifications qui ont \u00e9t\u00e9 effectu\u00e9es \u00e0 ce code pour permettre cet\n  appel~;\n\\item l'utilisation des propri\u00e9t\u00e9s mat\u00e9riau dans le tableur \\excel{}\n  via l'interface \\castem{}.\n\\end{itemize}\n\n\\clearpage\n\\newpage\n\\section{Pr\u00e9sentation g\u00e9n\u00e9rale de \\mfront{}}\n\\label{sec:pres-gener-de}\n\n\\mfront{} est un g\u00e9n\u00e9rateur de code d\u00e9di\u00e9 aux connaissances mat\u00e9riau~:\npartant d'un fichier contenant les informations physiques et\nnum\u00e9riques utiles, \\mfront{} g\u00e9n\u00e8re un ou plusieurs fichiers \\cpp{}\nutilisables dans diff\u00e9rents contextes logiciels, ce qui englobe des\ncodes de calculs ou des langages de programmation. \\mfront{} peut\n\u00e9ventuellement g\u00e9rer leurs compilations.\n\nPour proposer une solution adapt\u00e9e aux diff\u00e9rentes situations,\nplusieurs analyseurs syntaxiques sont disponibles. Pour chaque\nanalyseur, diff\u00e9rentes interfaces sont disponibles qui permettent\nd'adapter le code g\u00e9n\u00e9r\u00e9 au contexte logiciel cible.\n\nNous commen\u00e7ons par pr\u00e9senter la structure du fichier de donn\u00e9e\n(paragraphe~\\ref{sec:fichiers-dentree}) et les directives communes \u00e0\ntous les analyseurs (paragraphe~\\ref{sec:mfront:pres:common}).\n\nPuis, nous d\u00e9crivons les {\\em analyseurs}\n(paragraphe~\\ref{sec:mfront:parser}) et les interfaces\n(paragraphe~\\ref{sec:mfront:interface}) disponibles.\n\n\\subsection{Fichiers d'entr\u00e9e}\n\\label{sec:fichiers-dentree}\n\n\\begin{figure}[htbp]\n  \\centering\n  \\code{{\\ttfamily \\input{@abs_top_srcdir@/docs/mfront/mfront/SICCreepBehaviour.tex}}}  \n  \\caption{Implantation de la loi de comportement viscoplastique\n    du \\sic{} en \\mfront{}.}\n  \\label{fig:mfront_sic_behaviour}\n\\end{figure}\n\nLa figure~\\ref{fig:mfront_sic_behaviour} donne un premier exemple de\nfichier \\mfront{}. Nous d\u00e9crivons en d\u00e9tail cet exemple dans la note\nd\u00e9di\u00e9e aux lois de comportement\nm\u00e9canique~\\cite{helfer_generateur_2013} et nous insistons ici\nsur sa structure, puis nous d\u00e9crivons certains mots cl\u00e9s communs \u00e0\nl'ensemble des analyseurs.\n\n\\paragraph{Le type {\\tt real}} Pour repr\u00e9senter les nombres flottants,\nnous avons introduit un type nomm\u00e9 {\\tt real}. Les interfaces doivent\nd\u00e9finir ce type pour la cible vis\u00e9e. Les connaissances mat\u00e9riaux\n\u00e9crites en \\mfront{} peuvent ainsi \u00eatre utilis\u00e9e en simple, double ou\nquadruple pr\u00e9cision.\n\n\\paragraph{Noms de glossaire}\nPour l'int\u00e9gration des fichiers g\u00e9n\u00e9r\u00e9s dans les applications de la\nplateforme \\pleiades{}, il est possible d'affecter aux variables\nd'entr\u00e9e et de sortie des connaissances mat\u00e9riau des noms de\nglossaire.  Ces noms de glossaire servent \u00e0 assurer le bon \u00e9change\nd'information.\n\nL'annexe~\\ref{sec:mfront:glossary} d\u00e9crit les noms de glossaire les\nplus fr\u00e9quemment utilis\u00e9s dans le code \\licos{}.\n\n\\subsubsection{Structure du fichier d'entr\u00e9e}\n\nUn fichier d'entr\u00e9e de \\mfront{} repr\u00e9sente une unique connaissance\nmat\u00e9riau (une propri\u00e9t\u00e9 mat\u00e9riau, une loi de comportement, un mod\u00e8le).\n\nIl se pr\u00e9sente sous la forme d'une liste de mots cl\u00e9s, appel\u00e9s\n\u00e9galement directives dans la suite du document, commen\u00e7ant par une\narobase \\texttt{@}. Dans la mesure du possible, nous avons recherch\u00e9 \u00e0\nnous rapprocher le plus possible de la syntaxe utilis\u00e9e par le langage\nC++ et certaines parties du fichier sont directement \u00e9crites en\nC++. La surcouche apport\u00e9e par \\mfront{} a cependant \u00e9t\u00e9 cr\u00e9\u00e9e pour\nminimiser les d\u00e9tails propres \u00e0 ce langage. Le retour d'exp\u00e9rience\nmontre que l'\u00e9criture d'un fichier \\mfront{} est accessible, dans les\ncas usuels, \u00e0 des personnes n'ayant pas ou peu de comp\u00e9tences en\nd\u00e9veloppement informatique.\n\n\\paragraph{Ordre des directives} L'ordre des directives n'est pas\nimpos\u00e9. Il faut cependant souligner que \\mfront{} analyse le fichier\nde mani\u00e8re s\u00e9quentielle et n'autorisera pas qu'une variable soit\nutilis\u00e9e avant d'avoir \u00e9t\u00e9 d\u00e9clar\u00e9e.\n\nPar exemple, il est impossible de pr\u00e9ciser la plage de validit\u00e9 en\ntemp\u00e9rature d'une propri\u00e9t\u00e9 de mat\u00e9riau avant de d\u00e9clarer que la\npropri\u00e9t\u00e9 d\u00e9pend de la temp\u00e9rature.\n\n\\paragraph{Commentaires} Les deux types de commentaires introduits par\nle langage C++ sont support\u00e9s~:\n\\begin{itemize}\n\\item les commentaires commen\u00e7ant par les caract\u00e8res \\texttt{/*} et\n  finissant par les caract\u00e8res \\texttt{*/}. Ces commentaires peuvent\n  s'\u00e9tendre sur plusieurs lignes~;\n\\item les commentaires commen\u00e7ant par les caract\u00e8res \\texttt{//}\n  s'\u00e9tendent jusqu'\u00e0 la fin de la ligne courante~;\n\\end{itemize}\n\n\\subsection{Directives communes \u00e0 l'ensemble des analyseurs}\n\\label{sec:mfront:pres:common}\n\nNous d\u00e9crivons dans ce paragraphe diff\u00e9rentes directives communes \u00e0\nl'ensemble des analyseurs.\n\n\\paragraph{La directive \\mkey{Parser}} La directive \\mkey{Parser}\npermet de pr\u00e9ciser l'analyseur utilis\u00e9. Cette directive est suivie du\nnom de l'analyseur \u00e0 utiliser et d'un point virgule. La liste des\nanalyseurs disponible est donn\u00e9e au\nparagraphe~\\ref{sec:mfront:parser}. Par d\u00e9faut, l'analyseur {\\tt\n  Default\\-Parser} est utilis\u00e9.\n\n\\subsubsection{Directives informatives}\n\nNous d\u00e9crivons dans ce paragraphe quatre directives optionnelles dont\nle but est uniquement informatif\\footnote{Dans le cadre de la\n  plateforme \\pleiades{}, ces informations sont utilis\u00e9es lors de\n  l'insertion d'un fichier \\mfront{} dans la base de donn\u00e9es\n  \\sirius{}.}. Elles devraient \u00e9galement servir \u00e0 terme lors de la\ng\u00e9n\u00e9ration automatique d'une documentation \u00e0 partir d'un fichier\n\\mfront{}.\n\n\\paragraph{La directive \\mkey{Description}} La directive\n\\mkey{Description} permet de documenter le fichier \\mfront{}.  Cette\ndocumentation est donn\u00e9e dans un bloc commen\u00e7ant par une accolade\nouvrante \\texttt{\\{} et se terminant par une accolade fermante\n\\texttt{\\}}. Elle doit id\u00e9alement contenir la r\u00e9f\u00e9rence d'o\u00f9 est\nextraite la connaissance mat\u00e9riau trait\u00e9e, les \u00e9ventuelles adaptations\nfaites et le cadre d'utilisation.\n\n\\paragraph{La directive \\mkey{Author}} Le mot cl\u00e9 \\mkey{Author} donne le\nnom de la personne qui a \u00e9crit le fichier \\mfront{}. Ce mot cl\u00e9 est\nsuivi du nom jusqu'\u00e0 ce qu'un point virgule soit rencontr\u00e9.\n\n\\paragraph{La directive \\mkey{Date}} Le mot cl\u00e9 \\mkey{Date} donne la\ndate d'\u00e9criture du fichier \\mfront{}. Ce mot cl\u00e9 est suivi de cette\ndate jusqu'\u00e0 ce qu'un point virgule soit rencontr\u00e9.\n\n\\paragraph{La directive \\mkey{Material}} La directive \\mkey{Material}\npr\u00e9cise le nom du mat\u00e9riau auquel se r\u00e9f\u00e8re la connaissance mat\u00e9riau. Ce\nmot cl\u00e9 est suivi du nom du mat\u00e9riau et d'un point virgule.\n\nCe nom de mat\u00e9riau est g\u00e9n\u00e9ralement utilis\u00e9 pour construire le nom des\nfonctions ou des classes g\u00e9n\u00e9r\u00e9es, il est donc soumis \u00e0 certaines\nrestrictions~: un nom de mat\u00e9riau ne peut commencer par un chiffre et\nne peut contenir que des lettres alphab\u00e9tiques ou des chiffres. Le nom\ndu mat\u00e9riau peut \u00e9galement \u00eatre utilis\u00e9 pour construire le nom de la\nlibrairie g\u00e9n\u00e9r\u00e9e.\n\n\\subsubsection{Appel aux propri\u00e9t\u00e9s mat\u00e9riau \u00e9crites en \\mfront{}}\n\nAfin de minimiser la duplication du code (et donc le risque d'erreur),\nil est naturel que les diff\u00e9rentes connaissances mat\u00e9riau puissent\nutiliser des propri\u00e9t\u00e9s mat\u00e9riau d\u00e9finies par ailleurs\\footnote{Les\n  propri\u00e9t\u00e9s mat\u00e9riau ont un statut particulier~:\n\\begin{itemize}\n\\item elles n'ont de sens que relativement \u00e0 une loi de comportement\n  ou \u00e0 un mod\u00e8le. Ainsi, un module d'\\nom{Young} n'a de sens que si le\n  comportement \u00e9lastique du mat\u00e9riau est suppos\u00e9 repr\u00e9sent\u00e9 par une\n  loi de \\nom{Hooke}.\n\\item les propri\u00e9t\u00e9s mat\u00e9riau peuvent \u00eatre li\u00e9es. Par exemple, pour un\n  mat\u00e9riau dont le comportement m\u00e9canique est bas\u00e9 sur une loi\n  d'\u00e9lasticit\u00e9 lin\u00e9aire isotrope, le module d'\\nom{Young} \\(E\\), le\n  coefficient de \\nom{Poisson} \\(\\nu\\) et le module de cisaillement\n  \\(G\\) sont reli\u00e9s par~:\n  \\[\n  \\nu=\\Frac{E}{2\\,G}-1\n  \\]\n\\end{itemize}\n}.\n\nNous avons introduit la directive \\mkey{MaterialLaw} pour traiter ces\ncas. Cette directive est suivie d'un tableau de cha\u00eenes de caract\u00e8res\nd\u00e9signant des fichiers \\mfront{} et d'un point virgule.\n\nLes fichiers d\u00e9sign\u00e9s sont analys\u00e9s par \\mfront{} avec deux effets~:\n\\begin{itemize}\n\\item ces fichiers vont \u00eatre analys\u00e9s par une interface sp\u00e9ciale\n  nomm\u00e9e \\mfront{}\\footnote{L'utilisation de cette interface \u00e9vite\n    d'\u00e9ventuels conflits de nom.} et les fichiers g\u00e9n\u00e9r\u00e9s vont \u00eatre\n  ajout\u00e9s \u00e0 la liste des fichiers \u00e0 compiler\\footnote{La gestion de la\n    compilation des fichiers est d\u00e9crite en\n    annexe~\\ref{sec:mfront:compilation}.}~;\n  \\item l'interface \\mfront{} rend disponibles des fonctions dont le nom\n  est donn\u00e9 par~:\n  \\begin{itemize}\n  \\item le nom du mat\u00e9riau, suivi du caract\u00e8re tiret-bas (underscore)\n    \\texttt{\\textunderscore} et par le nom de la propri\u00e9t\u00e9, donn\u00e9 par\n    la directive \\mkey{Law}, si le nom du mat\u00e9riau est d\u00e9fini par la\n    directive \\mkey{Material} (voir\n    section~\\ref{sec:MaterialProperty})~;\n    \\item le nom de la propri\u00e9t\u00e9, donn\u00e9 par la directive \\mkey{Law}, si\n    le nom du mat\u00e9riau n'est pas d\u00e9fini.\n  \\end{itemize}\n\\end{itemize}\n\nCes diff\u00e9rentes fonctions sont accessibles dans les diff\u00e9rents blocs\nde code d\u00e9finis par l'utilisateur. Les arguments de ces fonctions sont\nceux d\u00e9clar\u00e9s dans le fichier par la directive \\mkey{Input} (voir\nsection~\\ref{sec:MaterialProperty}) et doivent \u00eatre fournis dans\nl'ordre de d\u00e9claration.\n\n\\begin{figure}[htbp]\n  \\centering \\code{{\\ttfamily\n      \\input{@abs_top_srcdir@/docs/mfront/mfront/A316TiHyperTrempe_CreepExponent.tex}}}\n  \\caption{Exemple de d\u00e9finition d'une propri\u00e9t\u00e9 mat\u00e9riau.}\n  \\label{fig:mfront_a316tihy_creepexp}\n\\end{figure}\n\n\\begin{figure}[htbp]\n  \\centering\n  \\code{{\\ttfamily \\input{@abs_top_srcdir@/docs/mfront/mfront/MaterialLaw.tex}}}  \n  \\caption{Exemple d'utilisation de la directive\n    \\texttt{MaterialLaw}. Utilisation de la propri\u00e9t\u00e9 mat\u00e9riau d\u00e9finie\n    en figure~\\ref{fig:mfront_a316tihy_creepexp}.}\n  \\label{fig:mfront_materiallaw}\n\\end{figure}\n\nUn exemple d'utilisation de la directive \\mkey{MaterialLaw} est\nillustr\u00e9e par les figures~\\ref{fig:mfront_a316tihy_creepexp}\net~\\ref{fig:mfront_materiallaw}. Deux propri\u00e9t\u00e9s mat\u00e9riau externes\nsont d\u00e9clar\u00e9es. Le code de la premi\u00e8re d'entre elles est donn\u00e9 en\nfigure~\\ref{fig:mfront_a316tihy_creepexp}. Elles sont utilis\u00e9es en\nfigure~\\ref{fig:mfront_materiallaw} pour initialiser des variables\ndans un bloc commen\u00e7ant par la directive \\mkey{InitLocalVariables}.\n\n\\paragraph{Note} Il est important de noter que le nom du fichier\n\\mfront{} n'intervient pas dans le nom des fonctions g\u00e9n\u00e9r\u00e9es. Il est\ncependant souhaitable et pratique de garder une certaine coh\u00e9rence\nentre le nom du fichier et le nom des fonctions g\u00e9n\u00e9r\u00e9es.\n\n\\paragraph{Chemins de recherche} La directive \\mkey{MaterialLaw}\nrecherche le fichier \u00e0 inclure~:\n\\begin{itemize}\n\\item dans le r\u00e9pertoire courant~;\n\\item dans les r\u00e9pertoires pr\u00e9cis\u00e9s en ligne de commandes par l'option\n  \\moption{search-path} (voir la section~\\ref{sec:mfront:using})~;\n\\item dans les r\u00e9pertoires point\u00e9s par la variable d'environnement\n  \\envb{MFRONT\\_INCLUDE\\_PATH}{MFRONT\\_\\-INCLUDE\\_\\-PATH}. Cette\n  variable fournit une liste de chemins s\u00e9par\u00e9s par le caract\u00e8re {\\tt\n    ':'}.\n\\end{itemize}\n\n\\subsubsection{Inclusion d'autres fichiers {\\tt mfront}}\n\nLa directive \\mkey{Import} permet d'inclure un fichier {\\tt mfront}\ndans le fichier courant.\n\nCette directive pr\u00e9sente un int\u00e9r\u00eat particulier pour les lois de\ncomportement m\u00e9canique\\footnote{Pour comprendre ce paragraphe, une\n  lecture pr\u00e9alable de la note d\u00e9di\u00e9e aux lois de comportement\n  m\u00e9canique peut s'av\u00e9rer\n  n\u00e9cessaire~\\cite{helfer_generateur_2013}.}. En effet,\nbeaucoup de lois de comportement utilisent le m\u00eame formalisme et ne se\ndiff\u00e9rencient que par leurs coefficients. Une solution classique\nconsiste \u00e0 rajouter des propri\u00e9t\u00e9s mat\u00e9riau \u00e0 la liste d'appel de la\nloi de comportement. Cette solution pr\u00e9sente plusieurs inconv\u00e9nients~:\n\\begin{itemize}\n\\item on s'\u00e9loigne du choix \\pleiades{} de proposer des lois de\n  comportement m\u00e9canique sp\u00e9cifiques aux mat\u00e9riaux~;\n\\item il augmente le risque d'erreur de la part de l'utilisateur, qui\n  doit correctement renseigner son jeu de donn\u00e9es dans le code\n  appelant~;\n\\item il est difficile de passer d'un coefficient ind\u00e9pendant de la\n  temp\u00e9rature \u00e0 un coefficient d\u00e9pendant de la\n  temp\u00e9rature\\footnote{Les propri\u00e9t\u00e9s mat\u00e9riau fournies par le code\n    appelant sont constantes sur le pas de temps et l'instant auquel\n    elles sont \u00e9valu\u00e9es n'est pas n\u00e9cessairement coh\u00e9rent avec le\n    sch\u00e9ma d'int\u00e9gration utilis\u00e9 par la loi de comportement.} alors\n  que cela se fait naturellement dans les sch\u00e9mas d'int\u00e9gration\n  implicite\\footnote{Pour des raisons intrins\u00e8ques \u00e0 ces sch\u00e9mas\n    d'int\u00e9gration, il est possible de substituer une propri\u00e9t\u00e9\n    mat\u00e9riau variable dans le temps par sa valeur \\og~en milieu de pas\n    de temps~\\fg{}. Cette remarque n'est absolument pas valable pour\n    les sch\u00e9mas d'int\u00e9gration explicite de type \\nom{Runge-Kutta}.}.\n\\item dans la plupart des codes appelant, la gestion des propri\u00e9t\u00e9s\n  mat\u00e9riau a un co\u00fbt non n\u00e9gligeable.\n\\end{itemize}\n\nLa solution qu'apporte la directive \\mkey{Import} est la suivante~:\n\\begin{itemize}\n\\item on \u00e9crit un fichier ma\u00eetre d\u00e9finissant les diff\u00e9rents\n  coefficients. La fa\u00e7on de d\u00e9finir ces coefficients (propri\u00e9t\u00e9\n  mat\u00e9riau\\footnote{Voir le mot cl\u00e9 \\mkey{MaterialProperty}.},\n  variable locale\\footnote{Voir le mot cl\u00e9 \\mkey{LocalVariable}.},\n  etc..) et \u00e9ventuellement la fa\u00e7on de les initialiser\\footnote{Voir\n    le mot cl\u00e9 \\mkey{InitLocalVariable}.} d\u00e9pend du cas trait\u00e9.\n\\item ce fichier ma\u00eetre inclut un fichier patron (\\og~\\tt\n  template~\\fg{} en anglais) contenant tout le d\u00e9tail de\nl'int\u00e9gration.\n\\end{itemize}\n\n\\paragraph{Chemins de recherche} La directive \\mkey{Import} recherche\nle fichier \u00e0 inclure~:\n\\begin{itemize}\n\\item dans le r\u00e9pertoire courant~;\n\\item dans les r\u00e9pertoires pr\u00e9cis\u00e9s en ligne de commandes par l'option\n  \\moption{search-path} (voir la section~\\ref{sec:mfront:using})~;\n\\item dans les r\u00e9pertoires point\u00e9s par la variable d'environnement\n  \\envb{MFRONT\\_INCLUDE\\_PATH}{MFRONT\\_\\-INCLUDE\\_\\-PATH}. Cette\n  variable fournit une liste de chemins s\u00e9par\u00e9s par le caract\u00e8re {\\tt\n    ':'}.\n\\end{itemize}\n\n\\paragraph{Une limitation} Il est aujourd'hui n\u00e9cessaire de pr\u00e9ciser\nl'analyseur \u00e0 utiliser dans le fichier principal\\footnote{Voir le mot\n  cl\u00e9 \\mkey{Parser}.}.\n\n\\subsubsection{Directives de compilation}\n\nTrois directives sont li\u00e9es \u00e0 la compilation des sources. Les\ndirectives \\mkey{Includes} et \\mkey{Link} ont une importance\nparticuli\u00e8re pour une utilisation avanc\u00e9e de \\mfront{}~: ces\ndirectives permettent d'utiliser des fonctionnalit\u00e9s d\u00e9finies dans des\nlibrairies \\cpp{} externes.\n\n\\paragraph{La directive \\mkey{Library}} La directive sp\u00e9cifie le nom de\nla librairie g\u00e9n\u00e9r\u00e9e.\n\nCette information est optionnelle.\n\n\\paragraph{La directive \\mkey{Includes}} La directive \\mkey{Includes}\npermet de d\u00e9clarer des lignes de codes \\cpp{} introduites en t\u00eate des\nfichiers g\u00e9n\u00e9r\u00e9s. Ces lignes sont donn\u00e9es dans un bloc commen\u00e7ant par\nune accolade ouvrante \\texttt{\\{} et se terminant par une accolade\nfermante \\texttt{\\}}.\n\nLe nom de cette directive est due au fait que ces instructions se\nr\u00e9sument g\u00e9n\u00e9ralement \u00e0 une suite d'inclusions de fichiers d'ent\u00eate par\nle mot cl\u00e9 \\texttt{\\#include} du pr\u00e9processeur \\cpp{}.\n\n\\begin{figure}[htbp]\n  \\centering\n  \\code{{\\ttfamily \\input{@abs_top_srcdir@/docs/mfront/mfront/Includes.tex}}}  \n  \\caption{Exemple d'utilisation de la directive {\\tt Includes}.}\n  \\label{fig:mfront:Includes}\n\\end{figure}\n\nLa figure~\\ref{fig:mfront:Includes} donne un exemple d'utilisation de la\ndirective \\mkey{Includes}.\n\n\\paragraph{La directive \\mkey{Link}} La directive \\mkey{Link} est\nutilis\u00e9e pour lier les librairies g\u00e9n\u00e9r\u00e9es \u00e0 des librairies externes.\n\nElle est suivie d'une cha\u00eene de caract\u00e8res (entre doubles quotes)\ncontenant des instructions \u00e0 fournir \u00e0 l'\u00e9diteur de\nliens. L'utilisation des doubles quotes permet l'utilisation de\ncaract\u00e8res sp\u00e9ciaux.\n\n\\begin{figure}[htbp]\n  \\centering\n  \\code{{\\ttfamily \\input{@abs_top_srcdir@/docs/mfront/mfront/Link.tex}}}  \n  \\caption{Exemple d'utilisation de la directive {\\tt Link}.}\n  \\label{fig:mfront:Link}\n\\end{figure}\n\nLa figure~\\ref{fig:mfront:Link} donne un exemple d'utilisation de la\ndirective \\mkey{Link}.\n\n\\subsubsection{Gestion des bornes}\n\\label{sec:mfront:bounds}\n\nLes variables d'\u00e9tats peuvent poss\u00e9der des bornes intrins\u00e8ques~: une\ntemp\u00e9rature ne peut \u00eatre n\u00e9gative, une porosit\u00e9 sup\u00e9rieure \u00e0\n\\(1\\). Ces bornes intrins\u00e8ques sont d\u00e9nomm\u00e9es dans la suite \\og~bornes\nphysiques~\\fg. Par ailleurs, la corr\u00e9lation d\u00e9finissant la propri\u00e9t\u00e9\nmat\u00e9riau a souvent \u00e9t\u00e9 \u00e9tablie sur un certain domaine~: les limites de\nce domaine exp\u00e9rimental seront d\u00e9nomm\u00e9es \\og~bornes de validit\u00e9~\\fg\n(de la corr\u00e9lation).\n\n\\begin{figure}[htbp]\n  \\centering\n  \\code{{\\ttfamily \\input{@abs_top_srcdir@/docs/mfront/mfront/Bounds.tex}}}  \n  \\caption{Exemple d'utilisation des directives {\\tt Bounds} et\n    \\texttt{@Physical\\-Bounds}.}\n  \\label{fig:mfront:Bounds}\n\\end{figure}\n\n\\paragraph{Le mot cl\u00e9 \\texttt{@Bounds}} Le mot cl\u00e9 \\mkey{Bounds} d\u00e9finit\nles bornes de validit\u00e9 de la corr\u00e9lation utilis\u00e9e pour chacune des\ndiff\u00e9rentes variables d'entr\u00e9e. Le traitement du d\u00e9passement d'une de\nces bornes d\u00e9pend de l'interface utilis\u00e9e.\n\n\\paragraph{Le mot cl\u00e9 \\texttt{@Physical\\-Bounds}} Le mot cl\u00e9\n\\mkeyb{PhysicalBounds}{Physical\\-Bounds} d\u00e9finit les valeurs\nadmissibles des diff\u00e9rentes variables d'entr\u00e9e. Le d\u00e9passement d'une\nde ces bornes doit arr\u00eater le calcul.\n\nLa figure~\\ref{fig:mfront:Bounds} donne un exemple d'utilisation des\ndirectives \\mkey{Bounds} et \\mkeyb{PhysicalBounds}{Physical\\-Bounds}.\n\n\\subsubsection{Notion de param\u00e8tre}\n\\label{sec:mfront:parameters}\n\nLes \u00e9tudes r\u00e9alis\u00e9es dans le cadre de la plate-forme \\pleiades{} sont\nsouvent param\u00e9triques~: il s'agit de mesurer l'impact d'une incertitude\nsur une quantit\u00e9 (conductivit\u00e9 thermique, coefficient d'\u00e9change) ou\nl'impact d'une valeur num\u00e9rique (crit\u00e8re de convergence) sur les\nr\u00e9sultats du code.\n\nIl est donc int\u00e9ressant de pourvoir param\u00e9trer une connaissance\nmat\u00e9riau. Plusieurs solutions sont possibles.\n\nLa plus \u00e9vidente est de pr\u00e9voir une ou plusieurs entr\u00e9es\nsuppl\u00e9mentaire. Par exemple, si l'on veut introduire un coefficient\nd'incertitude sur une conductivit\u00e9 thermique, il est toujours possible\nde passer ce coefficient comme un argument suppl\u00e9mentaire de la\nfonction qui r\u00e9alise le calcul de cette conductivit\u00e9.\n\nCette approche est tr\u00e8s utilis\u00e9e dans le code \\licos{}~: une\nconnaissance mat\u00e9riau livr\u00e9e avec le code est reprise par\nl'utilisateur qui rajoute le ou les param\u00e8tres d'int\u00e9r\u00eats, recompile\nsa connaissance mat\u00e9riau dans une biblioth\u00e8que qui lui est propre et\nrelance son calcul en utilisant cette biblioth\u00e8que. Cette m\u00eame\napproche est utilis\u00e9e par les utilisateurs du code \\castem{}.\n\nCette approche ne peut que difficilement \u00eatre utilis\u00e9e dans les\napplications fili\u00e8res qui n'ont pas l'algorithme de gestion de\nd\u00e9pendances de \\licos{}~: en plus des \u00e9tapes pr\u00e9c\u00e9dentes, il faudrait\nque l'utilisateur fasse les \\og~branchements~\\fg{} \u00e0 la main dans le\ncode source de l'application, ce qui peut s'av\u00e9rer complexe.\n\nLe second d\u00e9savantage de cette m\u00e9thode est d'alourdir l'appel aux\nconnaissances mat\u00e9riau, ce qui peut avoir un co\u00fbt non\nn\u00e9gligeable\\footnote{Dans le cas de l'application \\licos{}, ce surco\u00fbt\n  est g\u00e9n\u00e9ralement n\u00e9gligeable, mais il peut \u00eatre nettement sensible sur\n  des calculs \\(1D\\).}.\n\nPour contourner ces difficult\u00e9s, \\mfront{} introduit une notion de\n{\\em param\u00e8tre}, c'est \u00e0 dire une valeur, consid\u00e9r\u00e9e comme constante au\ncours d'un calcul, mais pouvant \u00eatre modifi\u00e9e par l'utilisateur au\nmoment de l'initialisation. Pour les propri\u00e9t\u00e9s, les param\u00e8tres sont des\nvaleurs r\u00e9elles. Pour les lois de comportements, les param\u00e8tres peuvent\n\u00eatre des valeurs r\u00e9elles ou enti\u00e8res\\footnote{Nous avons distingu\u00e9 deux\n  types d'entier correspondant respectivement aux types C {\\tt int} et\n  {\\tt unsigned short} (entiers positifs).}. Pour les mod\u00e8les, les\nparam\u00e8tres peuvent avoir diff\u00e9rents types (valeurs r\u00e9elles ou enti\u00e8res,\ntableaux, etc..).\n\nLes interfaces qui le souhaitent peuvent mettre en place une gestion\nappropri\u00e9e de ces param\u00e8tres\\footnote{Par d\u00e9faut, la plupart des\n  interfaces d\u00e9crites plus bas se contentent de traiter les param\u00e8tres\n  de la m\u00eame mani\u00e8re que des valeurs constantes.}. Par exemple,\nl'interface \\castem{} aux propri\u00e9t\u00e9s mat\u00e9riau et l'interface \\umat{}\naux loi de comportement cr\u00e9ent automatiquement une fonction permettant\nde modifier les diff\u00e9rents param\u00e8tres qui sont stock\u00e9s dans des\nvariables globales. Il est facile de mettre en place un m\u00e9canisme\ng\u00e9n\u00e9rique, c'est \u00e0 dire ind\u00e9pendant de toute connaissance mat\u00e9riau,\npermettant la modification des valeurs des param\u00e8tres depuis le jeu de\ndonn\u00e9es\\footnote{Par exemple, dans \\licos{}, le mot cl\u00e9 {\\tt\n    Parameter} a \u00e9t\u00e9 introduit. Ce mot cl\u00e9 est suivi du nom de la\n  biblioth\u00e8que mat\u00e9riau, du nom de la connaissance mat\u00e9riau, du nom du\n  param\u00e8tre et de sa valeur. Cette solution devrait \u00eatre g\u00e9n\u00e9ralis\u00e9e \u00e0\n  toutes les applications de la plate-forme.}.\n\nCette solution corrige les d\u00e9fauts de la premi\u00e8re approche. En\nparticulier, l'acc\u00e8s aux valeurs des param\u00e8tres n'a pratiquement aucun\nco\u00fbt num\u00e9rique. Cette solution introduit cependant un inconv\u00e9nient~:\ntous les mat\u00e9riaux utilisant cette connaissance sont affect\u00e9s alors\nque dans la premi\u00e8re solution la modification pouvait \u00eatre faite\nmat\u00e9riau par mat\u00e9riau. Nous pouvons donner deux cas pouvant poser\nprobl\u00e8me~:\n\\begin{itemize}\n\\item dans le cas d'une aiguille absorbante, il arrive que la partie\n  inf\u00e9rieure de la colonne absorbante est constitu\u00e9e de \\(\\bqc\\) \u00e0 un\n  enrichissement en \\(\\bd\\) donn\u00e9 tandis que la partie sup\u00e9rieure soit\n  constitu\u00e9e de \\(\\bqc\\) \u00e0 un enrichissement diff\u00e9rent. Il est naturel\n  de d\u00e9finir deux mat\u00e9riaux distincts pour d\u00e9crire cette situation que\n  l'ont d\u00e9crira \u00e0 l'aide des m\u00eames propri\u00e9t\u00e9s mat\u00e9riaux. Dans ce cas\n  la notion de param\u00e8tre ne permet pas distinguer les parties basses\n  et hautes.\n\\item pour des crayons combustibles m\u00e9langeant des parties oxydes\n  \\(UO_{2}\\) et \\(MOX\\), la notion de param\u00e8tre ne permet pas de\n  modifier une propri\u00e9t\u00e9 ou un mod\u00e8le sur le combustible oxyde\n  uniquement~;\n\\end{itemize}\n\nDans le cas de l'application \\licos{}, l'utilisateur pourra choisir la\nsolution la plus adapt\u00e9e \u00e0 son besoin. Dans \\castem{}, seule la\npremi\u00e8re solution est possible.\n\n\\paragraph{D\u00e9finition de param\u00e8tres}\nPour les propri\u00e9t\u00e9s et les lois de comportements, la directive\n\\mkey{Parameter} a \u00e9t\u00e9 d\u00e9finie. Elle est suivie du nom du param\u00e8tre,\ndu signe \u00e9gal, de sa valeur par d\u00e9faut et d'un point-virgule.\n\nPour les mod\u00e8les, les param\u00e8tres propres aux mod\u00e8les, utilis\u00e9s pour\nleur sp\u00e9cialisation\\footnote{Nous renvoyons \u00e0 la documentation des\n  codes de la plate-forme \\pleiades{} pour une utilisation concr\u00e8te de\n  ces param\u00e8tres.}, sont distingu\u00e9s des param\u00e8tres dits globaux qui\npeuvent \u00eatre mis en commun avec plusieurs mod\u00e8les. Les premiers sont\nd\u00e9finis par la directive \\mkey{LocalParameter}, les seconds par la\ndirective \\mkey{GlobalParameter}. Ces mots cl\u00e9s sont suivis du type du\nparam\u00e8tre, de son nom et d'un point-virgule. Une valeur par d\u00e9faut\npeut \u00eatre fournie par la m\u00e9thode {\\tt setDefaultValue}.\n\n\\paragraph{Param\u00e8tres automatiquement d\u00e9clar\u00e9s}\n\nLes lois de comportement m\u00e9caniques introduites par \\mfront{} peuvent\nd\u00e9clarer automatiquement un certain nombre de param\u00e8tres. La valeur du\ncrit\u00e8re de convergence ou le nombre maximum d'it\u00e9ration sont des\nexemples de tels param\u00e8tres.\n\nNous d\u00e9taillerons dans la documentation propre \u00e0 chaque analyseur\nles param\u00e8tres d\u00e9clar\u00e9s automatiquement.\n\n\\subsection{Analyseurs disponibles}\n\\label{sec:mfront:parser}\n\nLes connaissances mat\u00e9riaux support\u00e9es par \\mfront{} sont class\u00e9es en\ntrois cat\u00e9gories~:\n\\begin{itemize}\n  \\item les propri\u00e9t\u00e9s mat\u00e9riau~;\n  \\item les lois de comportement m\u00e9canique~;\n  \\item les mod\u00e8les.\n\\end{itemize}\n\nPour traiter ces connaissances, diff\u00e9rents analyseurs sont\ndisponibles~:\n\\begin{itemize}\n  \\item l'analyseur {\\tt Material\\-Law} qui traite de propri\u00e9t\u00e9s\n  mat\u00e9riau. La section~\\ref{sec:MaterialProperty} lui est consacr\u00e9e~;\n  \\item l'analyseur \\texttt{DefaultParser} qui permet de traiter\n  tous types de lois de comportements~;\n  \\item l'analyseur \\texttt{RungeKutta} qui propose la r\u00e9solution\n  d'une loi de comportement m\u00e9canique quelconque \u00e0 l'aide de l'une des\n  m\u00e9thodes de \\nom{Runge-Kutta}~;\n\\item l'analyseur \\texttt{IsotropicMisesCreep} qui g\u00e8re exclusivement\n  des lois de type \\nom{Norton}, c'est \u00e0 dire des comportements\n  viscoplastiques incompressibles sans \u00e9crouissage de mat\u00e9riaux\n  isotropes~;\n\\item l'analyseur \\texttt{IsotropicStrainHardeningMisesCreep} qui g\u00e8re\n  exclusivement les lois de type \\nom{Lema\u00eetre} \\cite{chaboche_mecanique_2009}, c'est\n  \u00e0 dire des comportements m\u00e9caniques viscoplastiques incompressibles\n  avec \u00e9crouissage des mat\u00e9riaux isotropes~;\n  \\item l'analyseur \\texttt{IsotropicPlasticMisesFlow} qui g\u00e8re\n  exclusivement les lois de comportement m\u00e9canique plastique\n  incompressible des mat\u00e9riaux isotropes~;\n  \\item l'analyseur \\texttt{MultipleIsotropicMisesFlows} qui g\u00e8re\n  une combinaison arbitraire d'\u00e9coulements des trois types pr\u00e9c\u00e9dents.\n  Les diff\u00e9rents \u00e9coulements sont alors suppos\u00e9s non coupl\u00e9s~;\n\\item les analyseurs \\texttt{Implicit} et \\texttt{ImplicitII} qui\n  simplifient la r\u00e9solution d'une loi de comportement m\u00e9canique\n  quelconque \u00e0 l'aide d'une int\u00e9gration implicite~;\n\\item l'analyseur \\texttt{Model} qui permet de traiter des\n  mod\u00e8les. Cet analyseur fait l'objet de la\n  section~\\ref{sec:mfront:models}.\n\\end{itemize}\n\nLes analyseurs d\u00e9di\u00e9s aux lois de comportement m\u00e9caniques sont\nlargement majoritaires. Ils sont d\u00e9crits dans une note\nsp\u00e9cifique~\\cite{helfer_generateur_2013}, mais la lecture de la\npr\u00e9sente section est n\u00e9cessaire pour l'aborder.\n\nL'\u00e9criture de propri\u00e9t\u00e9s mat\u00e9riau est d\u00e9crite en\nsection~\\ref{sec:MaterialProperty}, celle des mod\u00e8les\nphysico-chimiques en section~\\ref{sec:mfront:models}.\n\nLa directive \\mkey{Parser} (voir\nfigure~\\ref{fig:mfront_sic_behaviour}) est utilis\u00e9e pour pr\u00e9ciser quel\nanalyseur doit \u00eatre utilis\u00e9 pour interpr\u00e9ter le fichier\nconsid\u00e9r\u00e9\\footnote{Cette directive est traditionnellement plac\u00e9e en\n  t\u00eate du fichier \\mfront{} bien que cela ne soit pas n\u00e9cessaire.}.\n\n\\subsection{Interfaces}\n\\label{sec:mfront:interface}\n\n\\mfront{} permet d'\u00e9crire les connaissances mat\u00e9riau de mani\u00e8re\nind\u00e9pendante du code ou du langage cible\\footnote{Pr\u00e9cisons enfin si\n  une interface vise \u00e0 fournir un code utilisable dans un langage de\n  programmation particulier, {\\em le code g\u00e9n\u00e9r\u00e9 est toujours du\n    C++}. Il est ainsi possible d'utiliser toute la richesse de ce\n  langage.}.\n\nPour que celles-ci soient utilisables dans un code particulier,\n\\mfront{} introduit la notion d'{\\em interface}~: le code source\ng\u00e9n\u00e9r\u00e9 d\u00e9pend de l'interface choisie par l'utilisateur et cherche \u00e0\ns'int\u00e9grer au mieux dans le contexte du code cible et \u00e0 en tirer le\nmeilleur parti.\n\nInsistons sur l'originalit\u00e9 de cette d\u00e9marche. Dans des solutions plus\nhabituelles, un code source fixe est g\u00e9n\u00e9r\u00e9 puis une couche d'enrobage\npermet d'utiliser ce code dans des cibles distinctes. Cette solution\nconduit souvent \u00e0 des conversions de donn\u00e9es et des allocations\nm\u00e9moires inutiles. Dans l'approche \\mfront{}, le code source fixe est\nlimit\u00e9 au maximum~: il se limite souvent au code fourni par\nl'utilisateur (s'il n'est pas transform\u00e9) afin de cr\u00e9er un code qui\ns'utilise de mani\u00e8re optimale dans le contexte logiciel cible.\n\n\\subsubsection{Interfaces disponibles}\n\nPar exemple, \\mfront{} est livr\u00e9 avec diff\u00e9rentes interfaces pour les\npropri\u00e9t\u00e9s mat\u00e9riau~:\n\\begin{itemize}\n\\item les interfaces \\texttt{c}, \\texttt{fortran}, \\cpp{} et\n  \\texttt{python} pour pouvoir utiliser les propri\u00e9t\u00e9s dans les\n  langages du m\u00eame nom~;\n\\item l'interface \\texttt{castem} pour pouvoir utiliser les propri\u00e9t\u00e9s\n  dans le code aux \u00e9l\u00e9ments finis \\castem{}~;\n  \\item l'interface \\texttt{gnuplot} pour une visualisation des\n  courbes d'\u00e9volution des propri\u00e9t\u00e9s mat\u00e9riau~;\n\\end{itemize}\n\nPour les lois de comportement, deux interfaces sont actuellement\ndisponibles~:\n\\begin{itemize}\n\\item l'interface {\\tt umat} pour une utilisation des lois g\u00e9n\u00e9r\u00e9es\n  dans le code aux \u00e9l\u00e9ments finis \\castem{}~\\cite{cea_site_2013}. Cette\n  interface est d\u00e9crite dans une note d\u00e9di\u00e9e~\\cite{helfer_interface_2013}~;\n\\item l'interface {\\tt aster} pour une utilisation des lois g\u00e9n\u00e9r\u00e9es\n  dans le code aux \u00e9l\u00e9ments finis \\aster{}~\\cite{edf_site_2013}. Cette\n  interface est d\u00e9crite dans une note d\u00e9di\u00e9e~\\cite{helfer_interface_2013-1}.\n\\end{itemize}\n\n\\subsubsection{Ajout d'interfaces}\n\nIl est possible de rajouter dynamiquement de nouvelles interfaces par\nl'utilisation de la variable d'environnement {\\tt\n  MFRONT\\textunderscore{}\\-ADDITIONAL\\textunderscore{}\\-LIBRARIES} qui\ndoit d\u00e9signer une liste de librairies automatiquement charg\u00e9es au\nd\u00e9marrage de \\mfront{} \\footnote{Ce m\u00e9canisme est utilis\u00e9 par exemple\n  par l'architecture \\pleiades{} pour g\u00e9n\u00e9rer l'interface {\\tt\n    pleiades} aux propri\u00e9t\u00e9s mat\u00e9riau, interface qui \u00e9volue avec les\n  versions de l'architecture.}.\n\nCe m\u00e9canisme permet donc de cr\u00e9er des interfaces sans modifier\n\\mfront{}. Il est principalement utilis\u00e9 par les applications de la\nplate-forme \\pleiades{} pour que \\TFEL{} puisse \u00eatre consid\u00e9r\u00e9 comme un\npr\u00e9-recquis.\n\n\\clearpage\n\\newpage\n\\section{Utilisation de \\mfront{} en ligne de commande}\n\\label{sec:mfront:using}\n\nNous d\u00e9crivons dans ce paragraphe l'utilisation de \\mfront{} sous\n \\unix{}. Les commandes pr\u00e9sent\u00e9es restent valides sous \\windows{} \u00e0\ncondition d'utiliser l'un des environnements \\msys{} ou \\cygwin{}.\n\n\\subsection{Appel \u00e0 \\mfront{} en ligne de commande}\n\n\\mfront{} s'utilise ainsi~:\n\\begin{center}\n  {\\tt mfront [options] fichier1.mfront fichier2.mfront \\ldots}\n\\end{center}\n\nL'option la plus utilis\u00e9e est \\moption{interface} qui permet de\nchoisir la cible de la compilation.\n\nLes fichiers g\u00e9n\u00e9r\u00e9s se trouvent g\u00e9n\u00e9ralement dans un sous-r\u00e9pertoire\nnomm\u00e9 {\\tt src} pour les fichiers source et {\\tt include} pour les\nfichiers d'ent\u00eate.\n\nCette commande conduit \u00e0 la g\u00e9n\u00e9ration~:\n\\begin{itemize}\n  \\item de fichiers sources~;\n  \\item de fichiers de d\u00e9pendances~;\n  \\item de fichiers de cibles.\n\\end{itemize}\nCes derniers fichiers permettent d'utiliser \\mfront{} de mani\u00e8re\ns\u00e9quentielle. \\mfront{} peut d'abord \u00eatre appel\u00e9 sur plusieurs fichiers\npour g\u00e9n\u00e9rer les fichiers sources puis lancer la compilation des\nlibrairies ainsi~:\n\\begin{center}\n  \\begin{minipage}{0.6\\textwidth}\n    \\textcolor{ceagrisclair}{\\tt \\# G\u00e9n\u00e9ration des fichiers sources}\\\\\n    {\\tt mfront --interface=?? fichier1.mfront} \\\\\n    {\\tt mfront --interface=?? fichier2.mfront} \\\\\n    {\\tt \\ldots} \\\\\n    \\textcolor{ceagrisclair}{\\tt \\# G\u00e9n\u00e9ration d'un fichier Makefile et lancement de la compilation}\\\\\n    {\\tt mfront --obuild} \\\\\n  \\end{minipage}\n\\end{center}\n\nDans une utilisation avanc\u00e9e, l'utilisateur peut avoir un contr\u00f4le\nassez fin sur le processus de compilation. Nous renvoyons le lecteur \u00e0\nl'annexe~\\ref{sec:mfront:compilation} pour plus de d\u00e9tails.\n\n\\paragraph{Note sur la g\u00e9n\u00e9ration des fichiers en\n  parall\u00e8le} La g\u00e9n\u00e9ration de fichiers \\mfront{} en parall\u00e8le est\npossible. Pour cela, un verrou global est pos\u00e9 au moment de l'\u00e9criture\ndes fichiers afin que les diff\u00e9rents processus \\mfront{} ne modifient\npas les m\u00eames fichiers en m\u00eame temps (fichiers cibles et fichiers de\nd\u00e9pendances notamment).\n\nCela pourrait conduire \u00e0 des blocages si \\mfront{} se termine sans\nlib\u00e9rer ce verrou\\footnote{Nous devons cependant pr\u00e9ciser que ce\n  probl\u00e8me ne s'est pr\u00e9sent\u00e9 qu'une unique fois.}. Dans ce cas, il est\nn\u00e9cessaire de retirer ce verrou global \u00e0 la main. Sous \\linux{}, il\ns'agit de supprimer le fichier~:\n\\begin{center}\n \\texttt{/dev/shm/sem-mfront.\\${UID}}\n\\end{center}\n\nUn moyen plus brutal consiste \u00e0 red\u00e9marrer la machine.\n\n\\subsection{Options de la ligne de commande}\n\n\\paragraph{L'option \\moption{help}} L'option \\moption{help} liste\nl'ensemble des options disponibles et quitte le programme.\n\n\\paragraph{L'option \\moption{list-parsers}} L'option\n\\moption{list-parsers} affiche la liste des analyseurs disponibles et\nquitte le programme.\n\n\\paragraph{L'option \\moption{help-keywords-list}} L'option\n\\moption{help-\\-key\\-words-\\-list} liste l'ensemble des mots cl\u00e9s\nd'une interface et quitte le programme. Par exemple~:\n\\begin{center}\n  {\\tt mfront -{}-help-keywords-list=MaterialLaw}\n\\end{center}\n\n\\paragraph{L'option \\moption{help-keyword}} L'option\n\\moption{help-\\-key\\-word} affiche la documentation d'un des mots cl\u00e9s\nd'une interface et quitte le programme. Par exemple~:\n\\begin{center}\n  {\\tt mfront -{}-help-keyword=MaterialLaw:@Function}\n\\end{center}\n\n\\paragraph{L'option \\moption{version}} L'option \\moption{version}\naffiche la version de \\mfront{} utilis\u00e9e et quitte le programme.\n\n\\paragraph{L'option \\moption{interface}} L'option \\moption{interface}\nsp\u00e9cifie la ou les interfaces \u00e0 utiliser pour g\u00e9n\u00e9rer les fichiers\nsources. Les diff\u00e9rentes interfaces sont s\u00e9par\u00e9es par une virgule.\n\n\\paragraph{L'option \\moption{verbose}} L'option \\moption{verbose}\ndemande l'affichage de messages suppl\u00e9mentaires.\n\n\\paragraph{L'option \\moption{warning}} L'option \\moption{warning}\ndemande l'affichage de messages d'avertissement suppl\u00e9mentaires.\n\n\\paragraph{L'option \\moption{debug}} L'option \\moption{debug} modifie\nla g\u00e9n\u00e9ration des fichiers de compilation et son effet d\u00e9pend de\nl'analyseur choisi.\\footnote{Dans un mode de fonctionnement normal de\n  \\mfront{} ins\u00e8re des directives \\texttt{\\#line} pour rep\u00e9rer la\n  position des erreurs dans le fichier \\mfront{} d'origine (le\n  compilateur indique l'erreur dans le fichier \\mfront{} d'origine et\n  non dans le fichier g\u00e9n\u00e9r\u00e9). L'option \\moption{debug} d\u00e9sactive\n  l'insertion de ces directives \\texttt{\\#line}.}.\n\n\\paragraph{L'option \\moption{make}} L'option \\moption{make} conduit \u00e0 la\ng\u00e9n\u00e9ration d'un fichier {\\tt Makefile.mfront}.\n\n\\paragraph{L'option \\moption{omake}} L'option \\moption{omake} conduit \u00e0 la\ng\u00e9n\u00e9ration d'un fichier {\\tt Makefile.mfront} avec des directives de\ncompilation optimis\u00e9es.\n\nLes options de compilation optimis\u00e9es sont donn\u00e9es par le r\u00e9sultat de la\ncommande~\n\\begin{center}\n  {\\tt tfel-config -{}-oflags}\n\\end{center}\n\n\\paragraph{L'option \\moption{clean}} L'option \\moption{clean} conduit \u00e0 la\ng\u00e9n\u00e9ration d'un fichier {\\tt Makefile.mfront} et lance la commande~:\n\\begin{center}\n  {\\tt make -C src -f Makefile.mfront clean}\n\\end{center}\n\n\\paragraph{L'option \\moption{build}} L'option \\moption{build} conduit \u00e0 la\ng\u00e9n\u00e9ration d'un fichier {\\tt Makefile.mfront} et lance la commande~:\n\\begin{center}\n  {\\tt make -C src -f Makefile.mfront}\n\\end{center}\n\n\\paragraph{L'option \\moption{obuild}} L'option \\moption{obuild} conduit \u00e0 la\ng\u00e9n\u00e9ration d'un fichier {\\tt Makefile.mfront} avec des directives de\ncompilation optimis\u00e9es et lance la commande~:\n\\begin{center}\n  {\\tt make -C src -f Makefile.mfront}\n\\end{center}\n\n\\paragraph{L'option \\moption{search-path}} Un fichier \\mfront{} peut\ninclure d'autres fichiers gr\u00e2ce \u00e0 la directive {\\tt @Import}. L'option\n\\moption{search-path} permet d'ajouter un ou plusieurs chemins de\nrecherche pour ces fichiers. Plusieurs chemins peuvent \u00eatre pr\u00e9cis\u00e9s\nen les s\u00e9parant par le caract\u00e8re {\\tt ':'}.\n\n\\paragraph{L'option \\moption{include}} L'option \\moption{include} est\nsynonyme de l'option \\moption{search-path}.\n\n\\paragraph{L'option \\moption{nodeps}} L'option \\moption{nodeps}\nemp\u00eache l'inclusion des r\u00e8gles de d\u00e9pendances dans le fichier {\\tt\n  Make\\-file\\-.mfront} g\u00e9n\u00e9r\u00e9. Cette option a \u00e9t\u00e9 introduite pour\n\u00e9viter certains probl\u00e8mes sous \\windows{}.\n\n\\paragraph{L'option \\moption{silent-build}}\nL'option \\moption{silent-build} est sp\u00e9cifi\u00e9e avec l'option {\\tt\n  false}, les lignes de compilation utilis\u00e9es seront affich\u00e9es.\n\n\\paragraph{L'option \\moption{otarget}} L'option\n\\moption{otarget} permet de ne compiler qu'une des librairies de mani\u00e8re\noptimis\u00e9e. Cette option est suivie du nom de la cible.\n\n\\paragraph{L'option \\moption{target}} L'option\n\\moption{target} permet de ne compiler qu'une des librairies.\n\n\\paragraph{L'option \\moption{win32}} L'option \\moption{win32} est\nutilis\u00e9e pour permettre la compilation crois\u00e9e sous \\linux{} de\nlibrairies dynamiques pour \\windows{}. Cette possibilit\u00e9 est d\u00e9crite\nen annexe~\\ref{sec:mfront:comp_croisee_lib_windows_linux}.\n\n\\paragraph{Ajout de directives} Il est possible d'ajouter des\ndirectives \u00e0 un fichier depuis la ligne de commande.\n\nLa ligne de commande suivante~:\n\\begin{center}\n  {\\tt mfront --@AsterCompareToNumericalTangentOperator=true implicit.mfront}\n\\end{center}\ndonnera le m\u00eame r\u00e9sultat que si on avait rajouter la ligne suivante en\nt\u00eate du fichier {\\tt implicit.mfront}~:\n\\begin{center}\n  @AsterCompareToNumericalTangentOperator true;\n\\end{center}\n\nLa r\u00e8gle g\u00e9n\u00e9rale est la suivante~: toute option de la ligne de\ncommande commen\u00e7ant par une arobase est interpr\u00e9t\u00e9e comme une\ndirective \u00e0 ajouter en d\u00e9but de l'analyse du fichier.\n\n\\clearpage\n\\newpage\n\\section{Propri\u00e9t\u00e9s mat\u00e9riaux}\n\\label{sec:MaterialProperty}\n\nLes propri\u00e9t\u00e9s mat\u00e9riau sont l'un des \u00e9l\u00e9ments de connaissance\nessentiel des mat\u00e9riaux. Une propri\u00e9t\u00e9 mat\u00e9riau est une fonction d'un\nensemble de variables d'\u00e9tat thermodynamique du mat\u00e9riau.\n\n\\subsection{Les diff\u00e9rents types de variables}\n\nCe paragraphe d\u00e9crit les diff\u00e9rents types de variables manipul\u00e9s\nlorsque l'on \u00e9crit des propri\u00e9t\u00e9s mat\u00e9riau.\n\n\\subsubsection{Variable de sortie}\n\nLa variable de sortie est par d\u00e9faut nomm\u00e9e \\texttt{res}. Ce nom peut\n\u00eatre chang\u00e9 par la directive \\mkey{Output}.\n\n\\subsubsection{Variables d'entr\u00e9e}\n\nLes variables d'entr\u00e9e des propri\u00e9t\u00e9s mat\u00e9riau sont d\u00e9finies par la\ndirective \\mkey{Input}.\n\nCes variables d'entr\u00e9e peuvent utiliser la m\u00e9thode {\\tt\n  set\\-Glossary\\-Name} pour d\u00e9finir son nom de glossaire. Si aucun nom\nde glossaire adapt\u00e9 n'existe, ces variables peuvent utiliser la m\u00e9thode\n{\\tt set\\-Entry\\-Name} pour \u00eatre utilisable dans l'architecture\n\\pleiades{}.\n\nNous avons vu au paragraphe~\\ref{sec:mfront:bounds} comment affecter\ndes bornes aux variables d'entr\u00e9e.\n\n\\subsubsection{Variables statiques}\n\nLa directive \\mkey{StaticVariable} permet d'introduire une variable\nstatique au sens du langage \\cpp{}.\n\n\\subsubsection{Param\u00e8tres}\n\nLa directive \\mkey{Parameter} a \u00e9t\u00e9 d\u00e9crite au\nparagraphe~\\ref{sec:mfront:parameters}.\n\n\\subsubsection{Constantes}\n\nLa directive \\mkey{Constant} est synonyme de la directive\n\\mkey{StaticVariable} pour des variables r\u00e9elles.\n\n\\subsection{Mots cl\u00e9s sp\u00e9cifiques}\n\nLa directive \\mkey{Namespaces} a \u00e9t\u00e9 introduite pour inclure les\nfonctions ou les classes g\u00e9n\u00e9r\u00e9es dans un espace de nom distinct. Ce\nmot cl\u00e9 n'est utilis\u00e9 que par l'interface \\cpp{} et peut\n\u00e9ventuellement \u00eatre utilis\u00e9e par l'interface \\pleiades{}.\n\nLa directive \\mkey{UseTemplate} demande la g\u00e9n\u00e9ration de fonctions ou\nde classes param\u00e9tr\u00e9es par le type num\u00e9rique utilis\u00e9 (par d\u00e9faut, les\ninterfaces utilisent g\u00e9n\u00e9ralement des valeurs r\u00e9elles en double\npr\u00e9cision). Cette directive n'est pour l'instant utilis\u00e9e que par\nl'interface \\cpp{}.\n\n\\subsection{Interfaces disponibles} Les interfaces disponibles par\nd\u00e9faut pour les propri\u00e9t\u00e9s mat\u00e9riaux sont~:\n\\begin{itemize}\n\\item l'interface \\texttt{c} pour une utilisation dans des codes\n  \u00e9crits dans ce langage. Cette interface est d\u00e9crite en\n  annexe~\\ref{sec:linterface-textttc}~;\n  \\item l'interface \\texttt{fortran} pour une utilisation dans des codes\n  \u00e9crits dans ce langage~;\n  \\item l'interface \\texttt{c++} pour une utilisation dans des codes\n  \u00e9crits dans ce langage~;\n\\item l'interface \\texttt{castem} pour une utilisation dans le code\n  aux \u00e9l\u00e9ments finis \\castem{}. Cette interface est d\u00e9crite en\n  annexe~\\ref{sec:lint-textttcastem}~;\n\\item l'interface \\texttt{python} pour une utilisation dans des codes\n  \u00e9crits dans ce langage. Cette interface est d\u00e9crite en\n  annexe~\\ref{sec:lint-textttpyth}~;\n  \\item l'interface \\texttt{gnuplot} pour une visualisation des courbes\n  d'\u00e9volution des propri\u00e9t\u00e9s mat\u00e9riau en fonction de leur param\u00e8tres~;\n\\end{itemize}\n\n\\subsection{Exemple du module d'\\nom{Young} du \\sic{}}\n\\label{sec:module-dnomyoung-du}\n\n\\nom{Snead} a propos\u00e9 une corr\u00e9lation donnant le module\nd'\\nom{Young} du \\sic{} en fonction de la temp\u00e9rature et de la porosit\u00e9\nsous la forme~:\n\\begin{equation}\n  \\label{eq:youngmodulussnead}\n  E\\paren{T,p} =\n  \\paren{E_{0}-B\\,T\\,\\exp\\paren{-\\Frac{T_{0}}{T}}}\\exp\\paren{-C\\,p}\n\\end{equation}\no\u00f9~:\n\\begin{minipage}[t]{0.75\\linewidth}\n  \\begin{itemize}\n    \\item \\(T\\) est la temp\u00e9rature~;\n    \\item \\(p\\) est la porosit\u00e9~;\n    \\item \\(E_{0}\\), \\(B\\), \\(T_{0}\\) \\(C\\) sont des\n    coefficients.\n  \\end{itemize}\n\\end{minipage}\n\n\\begin{figure}[htbp]\n  \\centering\n  \\code{{\\ttfamily \\input{@abs_top_srcdir@/docs/mfront/mfront/SIC_YoungModulus_SNEAD.tex}}}  \n  \\caption{Implantation du module d'\\nom{Young} du \\sic{} en \\mfront{}.}\n  \\label{fig:mfront_sic_youngmodulus}\n\\end{figure}\n\nLa figure~\\ref{fig:mfront_sic_youngmodulus} reproduit le fichier\n\\mfront{} impl\u00e9mentant cette corr\u00e9lation.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Parser}} La premi\u00e8re ligne, commen\u00e7ant\npar le mot cl\u00e9 \\mkey{Parser}, d\u00e9crit le type d'analyseur utilis\u00e9,\nici \\texttt{MaterialLaw}.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Law}} La second ligne, commen\u00e7ant par\nle mot cl\u00e9 \\mkey{Law}, donne le nom de la propri\u00e9t\u00e9 mat\u00e9riau. Ce\nnom sera utilis\u00e9 pour l'appel \u00e0 la propri\u00e9t\u00e9 mat\u00e9riau (nom de la\nfonction ou de la classe g\u00e9n\u00e9r\u00e9e suivant l'interface utilis\u00e9e).\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Material}} Le mot cl\u00e9 \\mkey{Material}, non\nutilis\u00e9 ici, sert \u00e0 regrouper plusieurs propri\u00e9t\u00e9s d'un m\u00eame mat\u00e9riau\ndans une m\u00eame biblioth\u00e8que.\n\n\\paragraph{Les mots cl\u00e9 \\mkey{Author} et \\mkey{Date}} La troisi\u00e8me et\nla quatri\u00e8me ligne renseignent respectivement l'auteur du fichier et la\ndate de cr\u00e9ation \u00e0 l'aide des mots cl\u00e9s \\mkey{Author} et \\mkey{Date}.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Description}} Le mot cl\u00e9\n\\mkey{Description} permet de donner les r\u00e9f\u00e9rences bibliographiques\nd'o\u00f9 la corr\u00e9lation est extraite ou tout commentaire sur son origine.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Output}} Le mot cl\u00e9 \\mkey{Output}\nchange le nom de la propri\u00e9t\u00e9 mat\u00e9riau calcul\u00e9e. Par d\u00e9faut, celle-ci\ns'appelle \\texttt{res}.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Input}} Le mot cl\u00e9 \\mkey{Input} donne la\nliste des variables d'\u00e9tat dont d\u00e9pend la propri\u00e9t\u00e9. Les variables\npeuvent \u00eatre d\u00e9clar\u00e9es en une fois ou par plusieurs utilisations\ncons\u00e9cutives du mot cl\u00e9 \\mkey{Input}. L'ordre de d\u00e9claration des\nvariables peut \u00eatre important suivant l'interface utilis\u00e9~: ainsi la\nfonction g\u00e9n\u00e9r\u00e9e par les interfaces \\texttt{c} ou \\texttt{castem}\nprendront leurs arguments dans l'ordre de d\u00e9claration utilis\u00e9 dans le\nfichier \\mfront{}.\n\n\\paragraph{La m\u00e9thode \\texttt{setGlossaryName}} La m\u00e9thode\n\\texttt{setGlossaryName}, non utilis\u00e9e ici, permet de pr\u00e9ciser un nom\nassoci\u00e9 \u00e0 une variable d'entr\u00e9e. Ce nom est utilis\u00e9 par les\napplications de la plateforme \\pleiades{} pour assurer l'\u00e9change\nd'informations.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{PhysicalBounds}} Le mot cl\u00e9\n\\mkey{PhysicalBounds} d\u00e9finit les bornes physiques des variables\nd'\u00e9tat d\u00e9finies plus haut. Ici nous indiquons qu'une temp\u00e9rature ne\npeut \u00eatre n\u00e9gative et qu'une porosit\u00e9 est comprise entre \\(0\\) et\n\\(1\\). Les cas de d\u00e9passement de ces bornes sont tr\u00e8s souvent li\u00e9s \u00e0\ndes probl\u00e8mes graves des codes (erreur de programmation, solutions\ninacceptables). Pour ces raisons, la plupart des interfaces\nsignaleront une erreur au code appelant, conduisant g\u00e9n\u00e9ralement \u00e0 son\narr\u00eat.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Function}} Le mot cl\u00e9\n\\mkey{Function} permet de d\u00e9finir le code (en \\texttt{c++}) utilis\u00e9\npour d\u00e9finir la propri\u00e9t\u00e9 mat\u00e9riau. Le fait que le code soit en fait\ndu \\texttt{c++} est ici anecdotique tant le code est proche de\nl'\u00e9quation~\\eqref{eq:youngmodulussnead}.\n\n% \\subsection{Exemple de propri\u00e9t\u00e9s dont seules des mesures sont connues}\n\n\\clearpage\n\\newpage\n\\section{Mod\u00e8les}\n\\label{sec:mfront:models}\n\nDeux types de mod\u00e8les sont usuellement distingu\u00e9s~:\n\\begin{itemize}\n\\item les mod\u00e8les demandant une r\u00e9solution globale sur l'ensemble du\n  domaine consid\u00e9r\u00e9. Ces mod\u00e8les concernent g\u00e9n\u00e9ralement la diffusion\n  (thermique ou chimique) et l'\u00e9quilibre m\u00e9canique. Ce type de mod\u00e8le\n  \u00e9tant co\u00fbteux \u00e0 d\u00e9velopper, n\u00e9cessitant le recours \u00e0 des techniques\n  de discr\u00e9tisation telles que les \u00e9l\u00e9ments finis, ils sont\n  g\u00e9n\u00e9ralement \u00e9crits de mani\u00e8re g\u00e9n\u00e9rique, la sp\u00e9cialisation au\n  probl\u00e8me concret \u00e0 traiter se faisant en renseignant ou des\n  propri\u00e9t\u00e9s mat\u00e9riau ou des lois de comportement~;\n\\item les mod\u00e8les dits \\og~point~\\fg d\u00e9crivant l'\u00e9volution locale du\n  mat\u00e9riau en fonction de son \u00e9tat thermodynamique local. Ce type de mod\u00e8le\n  regroupe les mod\u00e8les de production de gaz de fission, de concentration\n  isotopique (en l'absence de diffusion), de corrosion, de gonflement, etc..~;\n\\end{itemize}\n\n\\mfront{} ne permet pas de traiter les mod\u00e8les demandant une\nr\u00e9solution globale. Nous nous int\u00e9resserons uniquement aux mod\u00e8les\n\\og~point~\\fg.\n\nPour traiter ces mod\u00e8les, \\mfront{} propose l'analyseur \\texttt{Model}.\n\n\\subsection{G\u00e9n\u00e9ralit\u00e9s sur les mod\u00e8les \\og~points~\\fg}\n\nLes mod\u00e8les \\og~point~\\fg{} s'appuient sur un ou plusieurs domaines.\nLes valeurs des diff\u00e9rentes variables d'\u00e9tats du mat\u00e9riau sont\nrepr\u00e9sent\u00e9es par des champs aux points de discr\u00e9tisation du ou des\ndomaines consid\u00e9r\u00e9s.\n\nComme les lois de comportement, les mod\u00e8les n\u00e9cessitent\n\\textit{a priori} le recours \u00e0 des m\u00e9thodes d'int\u00e9gration.\nEn pratique, pour les mod\u00e8les courants, notamment les mod\u00e8les\nde gonflement, une estimation par une m\u00e9thode des\ntrap\u00e8zes (les valeurs des champs d'entr\u00e9e \u00e9tant prises en\nmilieu de pas de temps) est g\u00e9n\u00e9ralement suffisante.\n\n\\subsection{Mod\u00e8le de gonflement solide de l'\\upuc{}}\n\nNous d\u00e9crivons ici l'introduction du mod\u00e8le de gonflement\nsolide de l'\\upuc{}~\\cite{pelletier_recueil_2004}.\n\n\\begin{figure}[htbp]\n  \\centering\n  \\code{{\\ttfamily \\input{@abs_top_srcdir@/docs/mfront/mfront/UPuC_SolidSwellingModel.tex}}}  \n  \\caption{Implantation du mod\u00e8le de gonflement solide\n    de l'\\upuc{} en \\mfront{}.}\n  \\label{fig:mfront_upuc_solid_swelling}\n\\end{figure}\n\nLe code source est donn\u00e9 en figure~\\ref{fig:mfront_upuc_solid_swelling}.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Parser}} La premi\u00e8re ligne, commen\u00e7ant\npar le mot cl\u00e9 \\mkey{Parser}, d\u00e9crit le type d'analyseur utilis\u00e9,\nici \\texttt{Model}.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Model}} La second ligne, commen\u00e7ant par\nle mot cl\u00e9 \\mkey{Model}, donne le nom du mod\u00e8le.\n\n\\paragraph{Les mots cl\u00e9 \\mkey{Author} et \\mkey{Date}} La\ntroisi\u00e8me et la quatri\u00e8me ligne renseignent respectivement l'auteur du\nfichier et la date de cr\u00e9ation \u00e0 l'aide des mots cl\u00e9s \\mkey{Author}\net \\mkey{Date}.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Description}} Le mot cl\u00e9\n\\mkey{Description} permet de donner les r\u00e9f\u00e9rences bibliographiques\nd'o\u00f9 le mod\u00e8le est extrait.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{LocalParameter}} Le mot cl\u00e9\n\\mkey{LocalParameter} permet de d\u00e9clarer une variable\nlocale, propre au mod\u00e8le.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{GlobalParameter}}\nDe la m\u00eame mani\u00e8re, le mot cl\u00e9 \\mkey{GlobalParameter}\npermet de d\u00e9clarer un param\u00e8tre dont la valeur sera\nlue dans le fichier d'entr\u00e9e.\n\n% \\paragraph{La m\u00e9thode \\texttt{setDefaultValue}}\n% La m\u00e9thode {\\tt setDefaultValue} permet de pr\u00e9ciser\n% la valeur par d\u00e9faut de la variable \\texttt{domains}.\n\n% \\paragraph{Le mot cl\u00e9 \\mkey{Domain}} \n% Le mot cl\u00e9 \\mkey{Domain} permet de pr\u00e9ciser le domaine\n% d'application du mod\u00e8le. Sa valeur peut \u00eatre une expression\n% rationnelle. Le mot cl\u00e9 \\mkey{Domains} permet quand \u00e0 lui de\n% d\u00e9finir une liste de domaines.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Output}} Le mot cl\u00e9 \\mkey{Output}\npermet de pr\u00e9ciser un des champs de sortie du mod\u00e8le.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Input}} Le mot cl\u00e9 \\mkey{Input} permet de\npr\u00e9ciser un des champs d'entr\u00e9e du mod\u00e8le.\n\n\\paragraph{La m\u00e9thode \\texttt{setDepth}} La m\u00e9thode \\texttt{setDepth}\npermet de pr\u00e9ciser la profondeur d'un champ, c'est \u00e0 dire le nombre de\npas de temps ant\u00e9rieurs auquel l'on a acc\u00e8s. Une profondeur de $1$\npermet d'avoir acc\u00e8s \u00e0 la valeur courante (en fin de pas de temps) du\nchamp et \u00e0 sa valeur au d\u00e9but du pas.\n\n\\paragraph{La m\u00e9thode \\texttt{setGlossaryName}} La m\u00e9thode\n\\texttt{setGlossaryName} permet de pr\u00e9ciser le nom\nd'un champ dans \\pleiades{}.\n\n\\paragraph{Le mot cl\u00e9 \\mkey{Function}} Le mot cl\u00e9 \\mkey{Function}\npermet d'introduire l'implantation du mod\u00e8le. Un m\u00eame mod\u00e8le pouvant\navoir plusieurs fonctions, un identifiant, ici \\texttt{compute}, doit\n\u00eatre pr\u00e9cis\u00e9. L'implantation du mod\u00e8le est faite en C++. Dans le code\npr\u00e9sent\u00e9, la variable \\texttt{s\\textunderscore{}1} repr\u00e9sente la\nvaleur du champ $s$ au d\u00e9but du pas de temps et la variable $s$ sa\nvaleur en fin de pas de temps.\n\n\\subsection{Interface disponible} \u00c0 ce jour, aucune interface pour les\nmod\u00e8les n'est disponible par d\u00e9faut. Certaines applications de la\nplateforme \\pleiades{} fournissent leurs propres interfaces d\u00e9di\u00e9es\n(\\licos{}, \\germinal{}).\n\n\\clearpage\n\\newpage\n\\referencecea\n%\\listetableaux\n\\listefigures\n\n\\appendix\n\n\\clearpage\n\\newpage\n\\include{glossary}\n\n\\clearpage\n\\newpage\n\\section{Gestion de la compilation}\n\\label{sec:mfront:compilation}\n\nEn plus de g\u00e9n\u00e9rer des fichiers source, \\mfront{} peut g\u00e9rer leurs\ncompilations sous forme de librairies dynamiques. Cette compilation se\nfait en plusieurs \u00e9tapes~:\n\\begin{itemize}\n\\item g\u00e9n\u00e9ration d'un fichier {\\tt Makefile.mfront} dans le\n  sous-r\u00e9pertoire des sources {\\tt src}. La g\u00e9n\u00e9ration du fichier\n  Makefile se fait en analysant le r\u00e9pertoire {\\tt src} qui contient\n  (apr\u00e8s la phase de g\u00e9n\u00e9ration des sources) diff\u00e9rents fichiers\n  pr\u00e9cisant les noms des libraires \u00e0 g\u00e9n\u00e9rer, la liste de leurs\n  sources et de leurs d\u00e9pendances, etc..~;\n  \\item le lancement du processus de compilation. Il s'agit\n  essentiellement d'un appel \u00e0 l'utilitaire {\\tt make}.\n\\end{itemize}\n\n\\subsection{Variables affectant le processus de compilation}\n\nBien que cela ne soit g\u00e9n\u00e9ralement pas n\u00e9cessaire, l'utilisateur\n\\mfront{} peut affecter le processus de compilation \u00e0 l'aide de\nvariables d'environnement. Cela est utile dans les situations\nsuivantes~:\n\\begin{itemize}\n  \\item utilisation d'une librairie tierce (variables\n  \\env{INCLUDES} et \\env{LDFLAGS})~;\n  \\item utilisation d'un compilateur diff\u00e9rent du compilateur\n  syst\u00e8me (variables \\env{CC} et \\env{CXX})~;\n  \\item utiliser des options de compilation particuli\u00e8res\n  (variables \\env{CFLAGS} et \\env{CXXFLAGS})~;\n\\item g\u00e9n\u00e9ration de binaire pour un syst\u00e8me diff\u00e9rent\n  (cross-compilation) (variables \\env{CC}, \\env{CXX} \\env{RANLIB},\n  \\env{DLLTOOL} et \\env{AR})~;\n\\end{itemize}\n\nLe fichier {\\tt Makefile.mfront} suit les r\u00e8gles des fichiers {\\tt\n  Makefile}~: il est sensible aux variables d'environnement suivantes~:\n\\begin{itemize}\n  \\item \\env{CC} qui d\u00e9signe le compilateur {\\tt C} \u00e0 utiliser~;\n  \\item \\env{CXX} qui d\u00e9signe le compilateur \\cpp \u00e0 utiliser. Ce\n    compilateur est \u00e9galement utilis\u00e9 pour l'\u00e9dition de liens~;\n  \\item \\env{INCLUDES} qui d\u00e9signe des directives de\n  pr\u00e9processeur \u00e0 utiliser en plus des directives d\u00e9finies par les\n  sources~;\n\\item \\env{CFLAGS} qui d\u00e9signe les directives de compilation \u00e0\n  utiliser pour les sources {\\texttt c}. Si cette variable n'est pas\n  d\u00e9finie, \\mfront{} utilisera les valeurs suivantes~:\n  \\begin{itemize}\n    \\item la sortie de la commande {\\tt tfel-config -{}-oflags}\n    si l'une des options {\\tt -{}-obuild} ou {\\tt -{}-omake} a \u00e9t\u00e9\n    utilis\u00e9e~;\n    \\item {\\tt -O2} sinon.\n  \\end{itemize}\n  \\item \\env{CXXFLAGS} qui d\u00e9signe les directives de compilation\n  \u00e0 utiliser pour les source \\cpp. Si cette variable n'est pas d\u00e9finie,\n  \\mfront{} utilisera les valeurs suivantes~:\n  \\begin{itemize}\n    \\item la sortie de la commande {\\tt tfel-config -{}-oflags}\n    si l'une des options {\\tt -{}-obuild} ou {\\tt -{}-omake} a \u00e9t\u00e9\n    utilis\u00e9e~;\n    \\item {\\tt -O2} sinon.\n  \\end{itemize}\n  \\item \\env{LDFLAGS} qui d\u00e9signe des directives \u00e0 passer \u00e0\n  l'\u00e9diteur de liens~;\n  \\item \\env{RANLIB}, \\env{DLLTOOL} et \\env{AR} qui ont \u00e9t\u00e9\n  introduits pour la compilation crois\u00e9e de librairies dynamiques pour\n  \\windows{} depuis \\linux{}.\n\\end{itemize}\n\n\\subsection{Compilation crois\u00e9e de\n  librairies dynamiques pour \\windows{} depuis \\linux{}}\n\\label{sec:mfront:comp_croisee_lib_windows_linux}\n\n\u00c0 partir d'une version \\linux{} de \\mfront{}, il est possible de\ng\u00e9n\u00e9rer des librairies dynamiques pour \\windows{} dans le cas des\npropri\u00e9t\u00e9s mat\u00e9riau. Il faut cependant que ces propri\u00e9t\u00e9s ne fassent pas\nappel \u00e0 des librairies externes, ou, si tel est le cas de disposer des\nversions \\windows{} de ces librairies\\footnote{Pour compiler des lois de\n  comportements, il serait n\u00e9cessaire de disposer des librairies\n  math\u00e9matiques de TFEL pour \\windows{}~: il faut donc compiler\n  l'ensemble de {\\tt TFEL} et \\mfront{} en cross-compilation et utiliser\n  la version \\windows{} de \\mfront{}. Ceci est effectivement possible\n  via l'\u00e9mulateur {\\tt wine}, mais cette mani\u00e8re de proc\u00e9der sort du\n  cadre de ce paragraphe.}.\n\nPour g\u00e9n\u00e9rer des librairies dynamiques pour \\windows{} depuis\n\\linux{}, il est tout d'abord n\u00e9cessaire de disposer d'un\ncross-compilateur. Sous \\debian{}, l'utilisateur pourra installer les\npaquets {\\tt mingw32} (\\windows{} 32 bits) ou {\\tt mingw64} (\\windows{}\n32 et 64 bits).\n\nIl est alors n\u00e9cessaire de d\u00e9finir les variables d'environnement\n\\env{CC}, \\env{CXX} \\env{RANLIB}, \\env{DLLTOOL} et \\env{AR} et\nd'utiliser l'option \\moption{win32}.\n\nVoici un exemple de g\u00e9n\u00e9ration de librairie dynamique pour\n\\windows{} depuis \\linux{}~:\n\\begin{flushleft}\n{\\tt AR=i586-mingw32msvc-ar RANLIB=i586-mingw32msvc-ranlib\nDLLTOOL=i586-mingw32msvc-dlltool CXX=i586-mingw32msvc-g++\n../../src/mfront --win32 --obuild --interface=c\nYoungModulus.mfront}\n\\end{flushleft}\n\n\\clearpage\n\\newpage\n\\section{L'interface \\texttt{c}}\n\\label{sec:linterface-textttc}\n\nCette annexe est d\u00e9di\u00e9e \u00e0 l'interface \\texttt{c} aux propri\u00e9t\u00e9s\nmat\u00e9riau.\n\n\\subsection{Noms des fonctions g\u00e9n\u00e9r\u00e9es} Par propri\u00e9t\u00e9 mat\u00e9riau, une ou\ndeux fonctions sont g\u00e9n\u00e9r\u00e9es.\n\nLa premi\u00e8re calcule effectivement la valeur de la propri\u00e9t\u00e9 mat\u00e9riau\nen reprenant le code fourni apr\u00e8s la directive \\mkey{Function}. Un nom\nde propri\u00e9t\u00e9 doit n\u00e9cessairement avoir \u00e9t\u00e9 d\u00e9fini par la directive\n\\mkey{Law}.  Deux cas se pr\u00e9sentent alors~:\n\\begin{itemize}\n  \\item si un nom de mat\u00e9riau a \u00e9t\u00e9 sp\u00e9cifi\u00e9, le nom de la fonction sera\n  {\\texttt{mat\\textunderscore{}law}}, o\u00f9 \\texttt{mat} est le nom du\n  mat\u00e9riau et \\texttt{law} le nom de la propri\u00e9t\u00e9~;\n  \\item si aucun nom de mat\u00e9riau n'a \u00e9t\u00e9 sp\u00e9cifi\u00e9, le nom de la fonction\n  sera {\\texttt{law}}, o\u00f9 \\texttt{law} est le nom de la propri\u00e9t\u00e9.\n\\end{itemize}\n\nCette fonction prend des r\u00e9els en double pr\u00e9cision en arguments, dans\nl'ordre de d\u00e9claration des entr\u00e9es de la propri\u00e9t\u00e9 mat\u00e9riau, introduites\npar la directive \\mkey{Input}.\n\n\\subsection{Gestion des bornes} Une deuxi\u00e8me fonction est g\u00e9n\u00e9r\u00e9e si des\nbornes ont \u00e9t\u00e9 fournies. Cette deuxi\u00e8me fonction renvoie~:\n\\begin{itemize}\n\\item un nombre positif si une borne de validit\u00e9 de la loi est\n  viol\u00e9e~;\n  \\item un nombre n\u00e9gatif si une borne physique l'est~;\n  \\item \\texttt{0} si aucune borne n'est viol\u00e9e.\n\\end{itemize}\nLa valeur absolue du nombre est l'ordre de d\u00e9claration de la variable\nmise en cause.\n\nCette fonction a le nom de la premi\u00e8re fonction suivi de\n\\texttt{\\textunderscore{}checkBounds}. Elle prend les m\u00eames arguments,\ndonn\u00e9s dans le m\u00eame ordre, que la premi\u00e8re fonction.\n\n\\subsection{Noms de la librairie g\u00e9n\u00e9r\u00e9e} Diff\u00e9rents cas se pr\u00e9sentent~:\n\\begin{itemize}\n  \\item si un nom de librairie a \u00e9t\u00e9 d\u00e9fini par la directive\n  \\mkey{Library}, le nom de la librairie sera {\\tt libXXX.so} o\u00f9\n  \\texttt{XXX} est le nom fourni par l'utilisateur~;\n  \\item si aucun nom de librairie n'est sp\u00e9cifi\u00e9 mais qu'un nom de\n  mat\u00e9riau a \u00e9t\u00e9 fourni, le nom de la librairie sera {\\tt libMMM.so} o\u00f9\n  \\texttt{MMM} est le nom du mat\u00e9riau fourni par l'utilisateur~;\n  \\item si aucun nom de librairie ni aucun nom de mat\u00e9riau n'ont \u00e9t\u00e9\n  sp\u00e9cifi\u00e9s, la librairie s'appellera {\\tt lib\\-Material\\-Law.so}.\n\\end{itemize}\n\n\\clearpage\n\\newpage\n\\section{L'interface \\texttt{castem}}\n\\label{sec:lint-textttcastem}\n\nCette annexe est d\u00e9di\u00e9e \u00e0 l'interface \\texttt{castem} aux propri\u00e9t\u00e9s\nmat\u00e9riau. L'utilisation de cette interface est d\u00e9crite dans\nl'annexe~\\ref{sec:castem:materialproperties}. Une utilisation directe de\nla librairie g\u00e9n\u00e9r\u00e9e n\u00e9cessite une version modifi\u00e9e de \\castem{}\nutilis\u00e9e et maintenue au sein de la plateforme \\pleiades{}.\nL'utilisation dans la version officielle est possible, mais il faut\npasser par une modification de la m\u00e9thode {\\tt compute} et une\nrecompilation partielle de \\castem{}.\n\n\\subsection{Nom de la fonction g\u00e9n\u00e9r\u00e9e} Par propri\u00e9t\u00e9 mat\u00e9riau, une\nfonction est g\u00e9n\u00e9r\u00e9e en reprenant le code fourni apr\u00e8s la directive\n\\mkey{Function}.\n\nUn nom de propri\u00e9t\u00e9 doit n\u00e9cessairement avoir \u00e9t\u00e9\nd\u00e9fini par la directive \\mkey{Law}. Deux cas se pr\u00e9sentent alors~:\n\\begin{itemize}\n  \\item si un nom de mat\u00e9riau a \u00e9t\u00e9 sp\u00e9cifi\u00e9, le nom de la fonction sera\n  {\\texttt{mat\\textunderscore{}law}}, o\u00f9 \\texttt{mat} est le nom du\n  mat\u00e9riau et \\texttt{law} le nom de la propri\u00e9t\u00e9~;\n  \\item si aucun nom de mat\u00e9riau n'a \u00e9t\u00e9 sp\u00e9cifi\u00e9, le nom de la fonction\n  sera {\\texttt{law}}, o\u00f9 \\texttt{law} est le nom de la propri\u00e9t\u00e9.\n\\end{itemize}\n\nCette fonction prend un tableau de r\u00e9els en double pr\u00e9cision en\nargument. Dans ce tableau, les valeurs des entr\u00e9es de la propri\u00e9t\u00e9\nmat\u00e9riau, introduites par la directive \\mkey{Input}, doivent \u00eatre\nfournies dans l'ordre de d\u00e9claration.\n\n\\subsection{Gestion des bornes} Si une borne physique est viol\u00e9e, la\nfonction renvoie la valeur sp\u00e9ciale \\texttt{NaN} (pour \\texttt{not a\n  number}), d\u00e9finie dans la norme IEEE 754. Cette valeur de retour\nconduit \u00e0 un arr\u00eat des calculs.\n\nLe traitement d'une violation des bornes de validit\u00e9 exp\u00e9rimentale\nd\u00e9pend de la politique d\u00e9finie par l'utilisateur \u00e0 l'aide de la\nvariable d'environnement\n\\envb{CASTEM\\_OUT\\_OF\\_BOUND\\_POLICY}{CASTEM\\_\\-OUT\\_\\-OF\\_\\-BOUND\\_\\-POLICY}.\nTrois politiques sont sont possibles~:\n\\begin{itemize}\n  \\item \\texttt{STRICT}, qui traite un d\u00e9passement comme une erreur,\n  avec un traitement similaire \u00e0 ce qui est fait pour les bornes\n  physiques~;\n  \\item \\texttt{WARNING}, qui conduit \u00e0 afficher un message\n  d'avertissement sans g\u00e9n\u00e9ration d'erreur~;\n  \\item \\texttt{NONE}, qui ignore le d\u00e9passement~;\n\\end{itemize}\n\nSi la variable\n\\envb{CASTEM\\_OUT\\_OF\\_BOUND\\_POLICY}{CASTEM\\_\\-OUT\\_\\-OF\\_\\-BOUND\\_\\-POLICY}\nn'est pas d\u00e9finie, les d\u00e9passements sont ignor\u00e9s.\n\n\\subsection{Noms de la librairie g\u00e9n\u00e9r\u00e9e} Diff\u00e9rents cas se pr\u00e9sentent~:\n\\begin{itemize}\n  \\item si un nom de librairie a \u00e9t\u00e9 d\u00e9fini par la directive\n  \\mkey{Library}, le nom de la librairie sera {\\tt libCastemXXX.so} o\u00f9\n  \\texttt{XXX} est le nom fourni par l'utilisateur~;\n  \\item si aucun nom de librairie n'est sp\u00e9cifi\u00e9 mais qu'un nom de\n  mat\u00e9riau a \u00e9t\u00e9 fourni, le nom de la librairie sera {\\tt\n    libCastemMMM.so} o\u00f9 \\texttt{MMM} est le nom du mat\u00e9riau fourni par\n  l'utilisateur~;\n  \\item si aucun nom de librairie ni aucun nom de mat\u00e9riau n'ont \u00e9t\u00e9\n  sp\u00e9cifi\u00e9s, la librairie s'appellera {\\tt lib\\-Castem\\-Material\\-Law.so}.\n\\end{itemize}\n\n\\clearpage\n\\newpage\n\\section{L'interface \\texttt{python}}\n\\label{sec:lint-textttpyth}\n\nCette annexe est d\u00e9di\u00e9e \u00e0 l'interface \\texttt{python} aux propri\u00e9t\u00e9s\nmat\u00e9riau.\n\nPar propri\u00e9t\u00e9 mat\u00e9riau, deux fonctions sont g\u00e9n\u00e9r\u00e9es~:\n\\begin{itemize}\n  \\item la premi\u00e8re implante effectivement la propri\u00e9t\u00e9 mat\u00e9riau~;\n  \\item la seconde fonction est en fait propre \u00e0 la librairie g\u00e9n\u00e9r\u00e9e\n    et d\u00e9clare les diff\u00e9rentes informations implant\u00e9es dans cette\n    librairie.  Elle ne sera pas d\u00e9crite plus avant dans cette annexe.\n\\end{itemize}\n\n\\subsection{Nom de la fonction g\u00e9n\u00e9r\u00e9e} La premi\u00e8re fonction g\u00e9n\u00e9r\u00e9e\nreprend le code fourni apr\u00e8s la directive \\mkey{Function}.\n\nUn nom de propri\u00e9t\u00e9 doit n\u00e9cessairement avoir \u00e9t\u00e9\nd\u00e9fini par la directive \\mkey{Law}. Deux cas se pr\u00e9sentent alors~:\n\\begin{itemize}\n  \\item si un nom de mat\u00e9riau a \u00e9t\u00e9 sp\u00e9cifi\u00e9, le nom de la fonction sera\n  {\\texttt{mat\\textunderscore{}law}}, o\u00f9 \\texttt{mat} est le nom du\n  mat\u00e9riau et \\texttt{law} le nom de la propri\u00e9t\u00e9~;\n  \\item si aucun nom de mat\u00e9riau n'a \u00e9t\u00e9 sp\u00e9cifi\u00e9, le nom de la fonction\n  sera {\\texttt{law}}, o\u00f9 \\texttt{law} est le nom de la propri\u00e9t\u00e9.\n\\end{itemize}\n\nCette fonction prend un tableau de r\u00e9els en double pr\u00e9cision en\nargument. Dans ce tableau, les valeurs des entr\u00e9es de la propri\u00e9t\u00e9\nmat\u00e9riau, introduites par la directive \\mkey{Input}, doivent \u00eatre\nfournies dans l'ordre de d\u00e9claration.\n\n\\subsection{Gestion des bornes} Si une borne physique est viol\u00e9e, la\nfonction renvoie une exception du type \\texttt{Runtime\\-Error}.\n\nLe traitement d'une violation des bornes de validit\u00e9 exp\u00e9rimentale\nd\u00e9pend de la politique d\u00e9finie par l'utilisateur \u00e0 l'aide de la\nvariable d'environnement\n\\envb{PYTHON\\_OUT\\_OF\\_BOUND\\_POLICY}{PYTHON\\_\\-OUT\\_\\-OF\\_\\-BOUND\\_\\-POLICY}.\nTrois politiques sont possibles~:\n\\begin{itemize}\n  \\item \\texttt{STRICT}, qui traite un d\u00e9passement comme une erreur,\n  avec un traitement similaire \u00e0 ce qui est fait pour les bornes\n  physiques~;\n  \\item \\texttt{WARNING}, qui conduit \u00e0 afficher un message\n  d'avertissement sans g\u00e9n\u00e9ration d'erreur~;\n  \\item \\texttt{NONE}, qui ignore le d\u00e9passement~;\n\\end{itemize}\n\nSi la variable\n\\envb{PYTHON\\_OUT\\_OF\\_BOUND\\_POLICY}{PYTHON\\_\\-OUT\\_\\-OF\\_\\-BOUND\\_\\-POLICY}\nn'est pas d\u00e9finie, les d\u00e9passements sont ignor\u00e9s.\n\n\\subsection{Noms de la librairie g\u00e9n\u00e9r\u00e9e} Diff\u00e9rents cas se pr\u00e9sentent~:\n\\begin{itemize}\n  \\item si un nom de librairie a \u00e9t\u00e9 d\u00e9fini par la directive\n  \\mkey{Library}, le nom de la librairie sera {\\tt XXX.so} o\u00f9\n  \\texttt{XXX} est le nom fourni par l'utilisateur~;\n  \\item si aucun nom de librairie n'est sp\u00e9cifi\u00e9 mais qu'un nom de\n  mat\u00e9riau a \u00e9t\u00e9 fourni, le nom de la librairie sera {\\tt MMM.so} o\u00f9\n  \\texttt{MMM} est le nom du mat\u00e9riau fourni par l'utilisateur~;\n  \\item si aucun nom de librairie ni aucun nom de mat\u00e9riau n'ont \u00e9t\u00e9\n  sp\u00e9cifi\u00e9s, la librairie s'appellera {\\tt MaterialLaw.so}.\n\\end{itemize}\n\n\\clearpage\n\\newpage\n\\section{Appel de propri\u00e9t\u00e9s mat\u00e9riaux externes dans \\castem{}}\n\\label{sec:castem:materialproperties}\n\nPour les besoins du projet \\pleiades{}, nous avons modifi\u00e9 le code aux\n\u00e9l\u00e9ments finis \\castem{} pour pouvoir appeler des propri\u00e9t\u00e9s mat\u00e9riau\nd\u00e9finies dans des librairies externes. Cette section d\u00e9crit les\nmodifications faites au code aux \u00e9l\u00e9ments finis \\castem{} et\nl'utilisation de librairies externes depuis le {\\tt gibiane}.\n\n\\subsection{Fichiers modifi\u00e9s et impl\u00e9mentation}\n\n\\paragraph{Modification des sources de \\castem{}} L'\u00e9volution propos\u00e9e\ndemande de modifier deux fichiers source du code \\castem{}~:\n\\begin{itemize}\n  \\item {\\tt varinu.eso}, impl\u00e9mentation {\\tt esope} de l'op\u00e9rateur {\\tt\n    VARI} charg\u00e9 de l'appel aux lois externes~;\n  \\item {\\tt excha1.eso}, impl\u00e9mentation {\\tt esope} de l'op\u00e9rateur {\\tt\n    EXTR} pour l'extraction des composantes variables d'un champ par\n  \u00e9l\u00e9ment et des param\u00e8tres dont d\u00e9pendent les composantes variables.\n  Cette fonctionnalit\u00e9 est utilis\u00e9e par les proc\u00e9dures {\\tt TRANSNON} et\n  {\\tt PASAPAS}~;\n\\end{itemize}\nCes modifications ont pour objet de pouvoir d\u00e9finir une propri\u00e9t\u00e9 de\nmat\u00e9riau \u00e0 partir d'une table. La syntaxe utilis\u00e9e est d\u00e9crite au\nparagraphe suivant.\n\n\\paragraph{Portabilit\u00e9 de la solution propos\u00e9e} L'appel aux fonctions\nexternes se fait par l'appel aux fonctions {\\tt dlopen}, {\\tt dlsym} et\n{\\tt dlclose} d\u00e9clar\u00e9es dans le fichier d'ent\u00eate {\\tt dlfcn.h}. Ces\nfonctions ont \u00e9t\u00e9 d\u00e9finies dans la norme POSIX\\footnote{POSIX est\n  l'acronyme de Portable Operating System Interface for uniX. Cette\n  norme a pour objet d'\u00e9tablir une interface de programmation support\u00e9e\n  par l'ensemble des syst\u00e8mes d'exploitation d\u00e9riv\u00e9s d'UNIX.} et sont de\nce fait utilisables sur la plupart des syst\u00e8mes d\u00e9riv\u00e9s d'UNIX actuels.\nSous \\windows{}, les fonctions syst\u00e8me {\\tt Load\\-Library} et {\\tt\n  Get\\-Proc\\-Address} sont utilis\u00e9es.\n\nNous faisons \u00e9galement trois hypoth\u00e8ses qui peuvent limiter la portabilit\u00e9 de la solution\npropos\u00e9e~:\n\\begin{itemize}\n\\item nous supposons que le type double pr\u00e9cision du fortran ({\\tt REAL*8}) \n  et le type double pr\u00e9cision du C/\\cpp ({\\tt double}) correspondent.\n\\item nous supposons que le type entier du fortran ({\\tt INTEGER}) correspond au type \n  entier du C/\\cpp ({\\tt int})~;\n\\item nous supposons que la taille d'une variable enti\u00e8re de type ({\\tt int}) est plus \ngrande que la taille d'un pointeur~;\n\\end{itemize}\n\nLes deux premi\u00e8res hypoth\u00e8ses sont g\u00e9n\u00e9ralement v\u00e9rifi\u00e9es, mais aucune\nnorme ne l'impose \u00e0 notre connaissance. La derni\u00e8re hypoth\u00e8se est sans\ndoute la plus restrictive~: cette pratique de transf\u00e9rer des pointeurs\npar des entiers a longtemps \u00e9t\u00e9 utilis\u00e9e en C, mais il semble que cela\nne soit plus le cas sur les architectures 64 bits\nactuelles~\\cite{foundation_gnu_2006}. Il est int\u00e9ressant de noter qu'une\nhypoth\u00e8se similaire est faite en python pour l'impl\u00e9mentation de l'appel\naux fonctions externes via le module {\\tt\n  dl}~\\cite{von_rossum_python_2007}.\n\nLa n\u00e9cessit\u00e9 de convertir un pointeur en entier est li\u00e9e \u00e0 un \u00e9change\nn\u00e9cessaire entre le fortran et le \\cpp. Cette restriction peut {\\it a\n  priori} \u00eatre lev\u00e9e en \u00e9changeant entre le fortran et le \\cpp non plus\nun entier mais un tableau de taille ad\u00e9quate et de recopier\n\\og~caract\u00e8re par carat\u00e8re~\\fg le pointeur dans ce tableau et effectuer\nl'op\u00e9ration inverse lorsque le pointeur doit \u00eatre r\u00e9cup\u00e9r\u00e9\\footnote{Ceci\n  se base sur le fait que toute structure C \u00e0 une taille multiple de la\n  taille d'un caract\u00e8re.}.\n\n\\paragraph{Co\u00fbt de la solution propos\u00e9e} L'utilisation de la solution\npropos\u00e9e peut avoir un co\u00fbt car les biblioth\u00e8ques externes sont charg\u00e9es\net d\u00e9charg\u00e9es pour chaque \u00e9valuation d'une propri\u00e9t\u00e9 de mat\u00e9riau sur un\ndomaine g\u00e9om\u00e9trique. {\\it A priori}, ce co\u00fbt est faible, sauf pour des\ndomaines petits. Nous avons pr\u00e9vu la possibilit\u00e9 de \\og~pr\u00e9-lier~\\fg la\nbiblioth\u00e8que \\castem{} avec une biblioth\u00e8que de propri\u00e9t\u00e9s de mat\u00e9riau,\nce qui \u00e9viterait le chargement et le d\u00e9chargement de cette biblioth\u00e8que.\n\n\\subsection{Utilisation dans \\castem{}}\n\\label{sec:util-dans-cast}\n\nNous d\u00e9taillons ici comment d\u00e9clarer un mod\u00e8le et un mat\u00e9riau utilisant\nune propri\u00e9t\u00e9 d\u00e9finie dans une fonction externe. Nous avons choisi de\nprendre pour exemple un mod\u00e8le thermique isotrope dont la conductivit\u00e9\nthermique est \u00e9valu\u00e9e par une fonction externe.\n\nLe code {\\tt gibiane} utilis\u00e9 est d\u00e9crit en figure\n\\ref{fig:delaration_modele_materiau}.\n\n\\begin{figure}[htbp]\n  \\centering\n  \\code{\n    \\textcolor{blue}{* Cr\u00e9ation d'un mod\u00e8le thermique isotrope}\\\\    \n    ModT1 = '\\textcolor{green}{MODELISER}' s1 '\\textcolor{red}{THERMIQUE}' '\\textcolor{red}{ISOTROPE}' ; \\\\\n    \\\\\n    \\textcolor{blue}{* Cr\u00e9ation d'une table contenant les donn\u00e9es relatives }\\\\\n    \\textcolor{blue}{* \u00e0 la loi externe : }\\\\\n    \\textcolor{blue}{* - 'LOI' contient le nom de la fonction appel\u00e9e }\\\\\n    \\textcolor{blue}{* - 'LIBRAIRIE' contient le nom de la librairie externe }\\\\\n    \\textcolor{blue}{*   dans laquelle cette fonction est d\u00e9finie }\\\\\n    \\textcolor{blue}{* - 'PARAMETRES' contient la liste des param\u00e8tres dont d\u00e9pend }\\\\\n    \\textcolor{blue}{*   la fonction appel\u00e9e  }\\\\\n    Tmat = '\\textcolor{green}{TABLE}'; \\\\\n    Tmat. '\\textcolor{red}{LOI}' = '\\textcolor{red}{UO2\\_THERMALCONDUCTIVITY\\_METEOR}' ; \\\\\n    Tmat. '\\textcolor{red}{LIBRAIRIE}' = '\\textcolor{red}{libinterface.so}' ; \\\\\n    Tmat. '\\textcolor{red}{PARAMETRES}' = '\\textcolor{green}{MOTS}' '\\textcolor{red}{T}' '\\textcolor{red}{FIMA}' '\\textcolor{red}{PORO}'; \\\\\n    \\\\\n    \\textcolor{blue}{* Cr\u00e9ation du mat\u00e9riau associ\u00e9. }\\\\\n    \\textcolor{blue}{* La propri\u00e9t\u00e9 de mat\u00e9riau 'K' (diffusivit\u00e9 thermique) est \u00e9valu\u00e9e }\\\\\n    \\textcolor{blue}{* par appel \u00e0 la fonction 'UO2\\_THERMALCONDUCTIVITY\\_METEOR' de }\\\\\n    \\textcolor{blue}{* la librairie 'libinterface.so' }\\\\\n    MatT1 = '\\textcolor{green}{MATERIAU}' ModT1 '\\textcolor{red}{K}' Tmat;\n  }\n  \\caption{D\u00e9claration d'un mod\u00e8le et d'un mat\u00e9riau utilisant une propri\u00e9t\u00e9 de mat\u00e9riau externe.}\n  \\label{fig:delaration_modele_materiau}\n\\end{figure}\n\nNous commen\u00e7ons par d\u00e9clarer un mod\u00e8le thermique isotrope. Nous\nd\u00e9clarons ensuite une table contenant trois indices~:\n\\begin{itemize}\n  \\item {\\tt 'LOI'}, nom du symbole appel\u00e9 dans la biblioth\u00e8que\n  externe~;\n  \\item {\\tt 'LIBRAIRIE'}, nom de la biblioth\u00e8que externe~;\n  \\item {\\tt 'PARAMETRES'}, liste des param\u00e8tres dont d\u00e9pend la\n  fonction.\n\\end{itemize}\nLes noms des ces indices ont \u00e9t\u00e9 choisis en coh\u00e9rence avec les\nconventions usuelles du code \\castem{}.\n\nLa fonction externe utilis\u00e9e ici d\u00e9pend de la temp\u00e9rature 'T', du taux\nde combustion 'FIMA' et de la porosit\u00e9 'PORO'. Conform\u00e9ment aux\nlimitations de \\castem{}, ces noms de variables ne peuvent avoir plus\nde quatre caract\u00e8res.\n\nLe mat\u00e9riau associ\u00e9 est alors d\u00e9fini. La conductivit\u00e9 thermique est\ninitialis\u00e9e par le tableau pr\u00e9c\u00e9dent.\n\n\\paragraph{Chargements externes associ\u00e9s aux param\u00e8tres de la loi} Les\nobjets mod\u00e8le et mat\u00e9riau d\u00e9finis pr\u00e9c\u00e9demment s'utilisent de mani\u00e8re\nclassique. Il est cependant n\u00e9cessaire de d\u00e9finir l'\u00e9volution au cours\ndu pas de temps des param\u00e8tres externes \u00e0 la r\u00e9solution, dans notre cas\nles param\u00e8tres 'FIMA' et 'PORO'. Si l'on utilise les proc\u00e9dures {\\tt\n  PASAPAS} ou {\\tt TRANSNON}, ceci est fait en d\u00e9finissant des\nchargements associ\u00e9s \u00e0 ces param\u00e8tres contenant leur \u00e9volution sur le\npas de temps et en passant ces chargements \u00e0 l'indice {\\tt\n  'CHARGEMENTS'} de la table utilis\u00e9e en entr\u00e9e de ces proc\u00e9dures.\n\n\\paragraph{Pr\u00e9cautions relatives au \"name mangling\" des symboles}\nL'indice 'LOI' doit faire l'objet d'une attention particuli\u00e8re~: il\ncorrespond au nom du symbole de la biblioth\u00e8que et peut \u00eatre diff\u00e9rent\ndu nom de la fonction d\u00e9fini dans le fichier source ayant servi \u00e0\ng\u00e9n\u00e9rer la biblioth\u00e8que.\n\nLe langage C est le seul pour lequel le nom de la fonction et le nom du\nsymbole sont identiques.\n\nEn \\cpp, des fonctions ayant des arguments diff\u00e9rents peuvent porter le\nm\u00eame nom. Or un symbole ne peut faire r\u00e9f\u00e9rence qu'\u00e0 une fonction aux\narguments d\u00e9termin\u00e9s. Le \\cpp utilise alors une technique appel\u00e9e \"name\nmangling\" pour r\u00e9soudre les conflits et assurer une relation biunivoque\nentre le symbole et une fonction~\\cite{wikipedia_name_2009}. La m\u00eame\ntechnique est \u00e9galement utilis\u00e9e pour distinguer des fonctions portant\nle m\u00eame nom mais d\u00e9finies dans des espaces de noms diff\u00e9rents. Le\nlangage a cependant pr\u00e9vu cette difficult\u00e9 et a introduit une syntaxe\nparticuli\u00e8re pour \u00e9viter le \"name mangling\"~: une fonction d\u00e9clar\u00e9e dans\nun bloc commen\u00e7ant par la directive {\\tt extern \"C\"} est soumise aux\nr\u00e8gles du langage C et se voit associ\u00e9e un symbole du m\u00eame nom qu'elle.\n\nLe \"name mangling\" des fonctions est \u00e9galement n\u00e9cessaire en fortran,\nmais pour des raisons diff\u00e9rentes~: le fortran a une syntaxe\ninsensible \u00e0 la casse (les lettres majuscules et miniscules ne sont\npas distingu\u00e9es) alors que les symboles font cette distinction. Il n'y\na jamais eu de consensus entre les vendeurs de compilateur fortran\nautour d'un choix unique de \"name mangling\". Ceci constitue un souci\nde portabilit\u00e9 majeur des codes m\u00e9langeant des sources fortran et des\nsources C ou \\cpp~: les appels aux fonctions fortran d\u00e9pendent du\ncompilateur utilis\u00e9\\footnote{Voir~\\cite{gnu_documentation_2007} pour\n  plus de d\u00e9tails.}. En pratique, le symbole associ\u00e9 \u00e0 une fonction\nfortran peut \u00eatre le nom de cette fonction \u00e9crit uniquement en\nmajuscules ou en minuscules, \u00e9ventuellement suivi du caract\u00e8re '\\_'\n({\\em underscore}).  Dans le cas du compilateur gnu fortran (g77 ou\ngfortran suivant la version utilis\u00e9e), utilis\u00e9 en g\u00e9n\u00e9ral par les\napplications de la plateforme {\\tt Pl\u00e9iades}, une fonction appel\u00e9e\n{\\tt THERMALCONDUCTIVITY} dans le fichier source aura un symbole\nassoci\u00e9 du nom {\\tt thermalconductivity\\_}. Ces difficult\u00e9s nous ont\namen\u00e9s \u00e0 {\\it exclure} la possibilit\u00e9 de d\u00e9finir des lois externes en\nfortran.\n\nDans la suite, nous supposerons que les noms de fonctions et les noms de\nsymboles associ\u00e9s sont identiques, c'est \u00e0 dire que la fonction externe\na \u00e9t\u00e9 \u00e9crite en C ou en \\cpp \u00e0 l'int\u00e9rieur d'un bloc {\\tt extern \"C\"}.\n\n\\paragraph{Pr\u00e9cautions relatives aux d\u00e9clarations de param\u00e8tres} La\nd\u00e9claration des param\u00e8tres dans l'indice 'PARAMETRES' doit \u00e9galement\nfaire l'objet d'une attention particuli\u00e8re. L'ordre de leur d\u00e9claration\ndoit correspondre \u00e0 l'ordre des arguments de la fonction. Le nombre des\narguments est v\u00e9rifi\u00e9 automatiquement (voir paragraphe suivant).\n\nNotons enfin qu'il est impossible dans l'op\u00e9rateur {\\tt PASAPAS}\nd'utiliser des propri\u00e9t\u00e9s de mat\u00e9riau externes ne d\u00e9pendent d'aucun\nparam\u00e8tre externe (propri\u00e9t\u00e9s constantes). En effet, la proc\u00e9dure\nteste s'il est n\u00e9cessaire d'utiliser l'op\u00e9rateur {\\tt VARI} en\ncomptabilisant le nombre de d\u00e9pendances \u00e0 des param\u00e8tres des\npropri\u00e9t\u00e9s du mat\u00e9riau~: si ce nombre est nul, l'op\u00e9rateur {\\tt VARI}\nn'est pas appel\u00e9 et l'appel \u00e0 {\\tt PASAPAS} \u00e9choue avec un message\nd'erreur peu explicite. En fait, une tel cas n'a pas \u00e9t\u00e9 pr\u00e9vu car la\nd\u00e9claration de propri\u00e9t\u00e9 constante peut et doit se faire explicitement\ndans l'op\u00e9rateur {\\tt 'MATE'}.\n\n\\subsection{Une proc\u00e9dure de trac\u00e9 des propri\u00e9t\u00e9s mat\u00e9riau dans\n  \\castem{}}\n\nL'usage a montr\u00e9 qu'il \u00e9tait tr\u00e8s pratique de pouvoir tracer les\npropri\u00e9t\u00e9s mat\u00e9riau dans \\castem{}, pour v\u00e9rification. Nous nous\nbasons sur l'exemple du module d'\\nom{Young} du \\sic{}, d\u00e9taill\u00e9 au\nparagraphe~\\ref{sec:module-dnomyoung-du} pour illustrer notre propos.\n\nLa proc\u00e9dure \\texttt{GETEVOL}, reproduite en figure~\\ref{fig:getEvol} a\n\u00e9t\u00e9 \u00e9crite dans ce but.\n\n\\begin{figure}[htbp]\n  \\centering\n  \\code{\n    \\input{@abs_top_srcdir@/docs/mfront/mfront/TestGetEvol.tex}\n  }\n  \\caption{Utilisation de la proc\u00e9dure \\texttt{GETEVOL}.}\n  \\label{fig:TestGetEvol}\n\\end{figure}\n\nUn exemple d'utilisation de cette proc\u00e9dure est donn\u00e9e en\nfigure~\\ref{fig:TestGetEvol} o\u00f9 est trac\u00e9e la d\u00e9pendance du module\nd'\\nom{Young} du \\sic{} en fonction de la temp\u00e9rature entre \\(300\\) et\n\\(1500\\) Kelvins pour une porosit\u00e9 de \\(0,1\\) avec un \u00e9chantillonnage\nde \\(100\\) valeurs. La tableau \\texttt{val} contient ici les valeurs\nde toutes les variables autres que celle servant au trac\u00e9.\n\n\\begin{figure}[htbp]\n  \\centering\n  \\includegraphics[width=9cm,angle=90]{@abs_top_srcdir@/docs/mfront/mfront/GetEvol.eps}\n  \\caption{R\u00e9sultat de la proc\u00e9dure \\texttt{GETEVOL}.}\n  \\label{fig:TestGetEvol2}\n\\end{figure}\n\nLa courbe r\u00e9sultante est repr\u00e9sent\u00e9e en figure~\\ref{fig:TestGetEvol2}.\n\n\\clearpage\n\\newpage\n\\section{Utilisation des propri\u00e9t\u00e9s mat\u00e9riau dans \\excel{} via\n  l'interface \\castem{}}\n\\label{sec:inter-avec-excel}\n\n% \\excel{} appara\u00eet comme un logiciel particuli\u00e8rement appr\u00e9ci\u00e9 par les\n% utilisateurs \\celaeno{}. Nous montrons ici que \\mfront{} permet\n% simplement d'interagir avec lui. \n\nBien qu'il existe une interface \\excel{} d\u00e9di\u00e9e, il est pratique de\nr\u00e9utiliser dans ce logiciel des librairies mat\u00e9riau g\u00e9n\u00e9r\u00e9es par\n\\mfront{} en utilisant l'interface \\castem{} (cela \u00e9vite la g\u00e9n\u00e9ration\nde deux librairies distinctes).\n\nNous d\u00e9taillons dans cette annexe comment proc\u00e9der. Nous nous basons sur\nl'exemple du module d'\\nom{Young} du \\sic{}, d\u00e9taill\u00e9 au\nparagraphe~\\ref{sec:module-dnomyoung-du} pour illustrer notre propos.\n\n\\subsection{De \\mfront{} \u00e0 \\excel{}}\n\nEn premier lieu, les librairies de propri\u00e9t\u00e9s mat\u00e9riau g\u00e9n\u00e9r\u00e9es par\n\\mfront{} avec l'interface \\castem{} peuvent \u00eatre directement appel\u00e9es\ndepuis \\excel{}.\n\n\\begin{figure}[htbp]\n  \\centering\n  \\code{\n    \\input{@abs_top_srcdir@/docs/mfront/mfront/loimat.tex}\n  }\n  \\caption{Appel d'une loi externe depuis \\excel{}.}\n  \\label{fig:excelvba}\n\\end{figure}\n\nLa figure~\\ref{fig:excelvba} repr\u00e9sente une macro\n\\texttt{Visual Basic} permettant cet appel. Elle d\u00e9clare une fonction\n\\texttt{LoiMat} qui peut \u00eatre directement utilis\u00e9e dans un classeur\nsous la forme~:\n\\begin{center}\n  \\begin{minipage}[htbp]{0.9\\linewidth}\n    \\small\n    \\texttt{=LoiMat(\\$A\\$1,A3)}\n  \\end{minipage}\n\\end{center}\nqui calculera dans cet exemple le module d'\\nom{Young} du \\sic{} en\nfonction de la valeur de la temp\u00e9rature, lue dans la cellule\n\\texttt{\\$A\\$1} et de la valeur de la porosit\u00e9, lue dans la cellule\n\\texttt{A3}. \n\nLe passage par la macro \\texttt{Visual Basic} d\u00e9crite en\nfigure~\\ref{fig:excelvba} est assez lourd et nous pensons \u00eatre en\nmesure de nous en passer prochainement, rendant encore plus simple\nl'utilisation des librairies mat\u00e9riau issue de \\mfront{} dans\n\\excel{}.\n\n\\begin{figure}[htbp]\n  \\centering\n  \\includegraphics[width=9cm]{@top_srcdir@/docs/mfront/Images/mfrontexcel.eps}\n  \\caption{Graphique \\excel{} r\u00e9alis\u00e9 \u00e0 partir d'une\n    biblioth\u00e8que dynamique g\u00e9n\u00e9r\u00e9 par \\mfront{}.}\n  \\label{fig:mfrontexcel}\n\\end{figure}\n\nLa figure~\\ref{fig:mfrontexcel} montre la d\u00e9pendance du module\nd'\\nom{Young} du \\sic{} en fonction de la porosit\u00e9 en se basant\nsur l'exemple trait\u00e9 au paragraphe~\\ref{sec:module-dnomyoung-du}.\n\n\\begin{figure}[htbp]\n  \\centering\n  \\includegraphics[width=6cm]{@top_srcdir@/docs/mfront/Images/mfront.eps}\n  \\caption{Export d'une formule \\excel{} en \\mfront{}.}\n  \\label{fig:exceltomfront}\n\\end{figure}\n\n\\subsection{De \\excel{} \u00e0 \\mfront{}} De plus il est apparu utile (et\nrelativement facile \u00e0 mettre en \\oe{}uvre) de pouvoir directement g\u00e9n\u00e9r\u00e9\ndes fichiers \\mfront{} depuis des formules \\excel{}. Une macro\n\\texttt{Visual Basic} a \u00e9t\u00e9 \u00e9crite par \\nom{\u00c9. Gohier} dans ce but. La\nfigure~\\ref{fig:exceltomfront} montre un exemple de son utilisation.\n\n\\begin{figure}[htbp]\n  \\centering\n  \\code{\n    \\input{@abs_top_srcdir@/docs/mfront/mfront/GetEvol.tex}\n  }\n  \\caption[Code de la proc\u00e9dure \\texttt{GETEVOL}]{Proc\u00e9dure utilis\u00e9e\n    pour tracer les valeurs d'une fonction en fonction d'une de ces\n    variables (les autres \u00e9tant fix\u00e9es).}\n  \\label{fig:getEvol}\n\\end{figure}\n\n\\clearpage\n\\newpage\n\\printindex{env}{Index des variables d'environnement}\n\n\\clearpage\n\\newpage\n\\printindex{mkeys}{Index des directives}\n\n\\end{document}",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/abaqus/umat.cpp": "/*!\n * \\file   umat.cpp\n * \\brief    \n * \\author Thomas Helfer\n * \\date   21/03/2016\n */\n\n#include<iostream>\n#include<cstdlib>\n\n#include<map>\n#include<string>\n#include<cctype>\n#include<vector>\n#include<utility>\n#include<cstring>\n#include<stdexcept>\n#include<algorithm>\n\n#if __cplusplus >= 201103L\n#include<mutex>\n#define HAVE_STD_MUTEX\n#define NULLPTR(X) nullptr\n#else  /* __cplusplus >= 201103L */\n#define NULLPTR(X) static_cast<X>(0)\n#endif /* __cplusplus >= 201103L */\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#ifndef NOMINMAX\n#define NOMINMAX\n#endif\n#include<windows.h>\n#ifdef min\n#undef min\n#endif\n\n#ifdef max\n#undef max\n#endif\ntypedef HINSTANCE__*  libptr;\n\n#ifndef HAVE_STD_MUTEX\n\nstruct Mutex\n{\n  static Mutex& getMutex(){\n    static Mutex m;\n    return m;\n  }\n  HANDLE m;\nprivate:\n  Mutex(){\n    this->m = CreateMutex(NULL,  // default security attributes\n\t\t\tFALSE, // initially not owned\n\t\t\tNULL); // unnamed mutex\n  }\n};\n\nstruct lock\n{\n  lock(){\n    DWORD r = WaitForSingleObject(Mutex::getMutex().m,\n\t\t\t\t  INFINITE);\n    if(r==WAIT_ABANDONED){\n      std::cerr << \"umat: abandonned mutex\" << std::endl;\n      std::exit(EXIT_FAILURE);\n    }\n  }\n  ~lock(){\n    CloseHandle(Mutex::getMutex().m);\n  }\n};\n#endif /* HAVE_STD_MUTEX */\n\n// code retrieved from\n// http://www.codeproject.com/Tips/479880/GetLastError-as-std-string\nstatic std::string getLastWin32Error()\n{\n  const DWORD error = GetLastError();\n  if (error){\n    LPVOID lpMsgBuf;\n    DWORD bufLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | \n\t\t\t\t FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t\t FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\t\t\t NULL,error,\n\t\t\t\t MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t\t (LPTSTR) &lpMsgBuf,0,NULL );\n    if (bufLen){\n      LPCSTR lpMsgStr = (LPTSTR) lpMsgBuf;\n      std::string result(lpMsgStr, lpMsgStr+bufLen);\n      LocalFree(lpMsgBuf);\n      return result;\n    }\n  }\n  return std::string();\n}\n\n#else\n#include<dlfcn.h>\ntypedef void * libptr;\n#ifndef HAVE_STD_MUTEX\n#error \"Unsupported platform\"\n#endif /* HAVE_STD_MUTEX */\n#endif\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#define UMATFCT  umat\n#define UMATFCT2 umat2\n#else\n#define UMATFCT  umat_\n#define UMATFCT2 umat2_\n#endif\n\n#if (defined _WIN32) && (!defined _WIN64)\ntypedef int    fortran_string_size;\n#elif defined _WIN64\ntypedef size_t fortran_string_size;\n#else\ntypedef int    fortran_string_size;\n#endif\n\ntypedef double abaqus_real;\ntypedef int    abaqus_int;\n\ntypedef  void (*umatptr)(abaqus_real *const,\n\t\t\t abaqus_real *const,\n\t\t\t abaqus_real *const,\n\t\t\t abaqus_real *const,\n\t\t\t abaqus_real *const,\n\t\t\t abaqus_real *const,\n\t\t\t abaqus_real *const,\n\t\t\t abaqus_real *const,\n\t\t\t abaqus_real *const,\n\t\t\t abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const char        *const,\n\t\t\t const abaqus_int  *const,\n\t\t\t const abaqus_int  *const,\n\t\t\t const abaqus_int  *const,\n\t\t\t const abaqus_int  *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_int  *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_real *const,\n\t\t\t const abaqus_int  *const,\n\t\t\t const abaqus_int  *const,\n\t\t\t const abaqus_int  *const,\n\t\t\t const abaqus_int  *const,\n\t\t\t const abaqus_int  *const,\n\t\t\t abaqus_int  *const,\n\t\t\t const int);\n\nextern \"C\" {\n  void UMATFCT(abaqus_real *const,\n\t       abaqus_real *const,\n\t       abaqus_real *const,\n\t       abaqus_real *const,\n\t       abaqus_real *const,\n\t       abaqus_real *const,\n\t       abaqus_real *const,\n\t       abaqus_real *const,\n\t       abaqus_real *const,\n\t       abaqus_real *const,\n\t       const abaqus_real *const,\n\t       const abaqus_real *const,\n\t       const abaqus_real *const,\n\t       const abaqus_real *const,\n\t       const abaqus_real *const,\n\t       const abaqus_real *const,\n\t       const abaqus_real *const,\n\t       const abaqus_real *const,\n\t       const char        *const,\n\t       const abaqus_int  *const,\n\t       const abaqus_int  *const,\n\t       const abaqus_int  *const,\n\t       const abaqus_int  *const,\n\t       const abaqus_real *const,\n\t       const abaqus_int  *const,\n\t       const abaqus_real *const,\n\t       const abaqus_real *const,\n\t       abaqus_real *const,\n\t       const abaqus_real *const,\n\t       const abaqus_real *const,\n\t       const abaqus_real *const,\n\t       const abaqus_int  *const,\n\t       const abaqus_int  *const,\n\t       const abaqus_int  *const,\n\t       const abaqus_int  *const,\n\t       const abaqus_int  *const,\n\t       abaqus_int  *const,\n\t       const fortran_string_size);\n\n  void UMATFCT2(abaqus_real *const,\n\t\tabaqus_real *const,\n\t\tabaqus_real *const,\n\t\tabaqus_real *const,\n\t\tabaqus_real *const,\n\t\tabaqus_real *const,\n\t\tabaqus_real *const,\n\t\tabaqus_real *const,\n\t\tabaqus_real *const,\n\t\tabaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tconst char        *const,\n\t\tconst abaqus_int  *const,\n\t\tconst abaqus_int  *const,\n\t\tconst abaqus_int  *const,\n\t\tconst abaqus_int  *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_int  *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tabaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_real *const,\n\t\tconst abaqus_int  *const,\n\t\tconst abaqus_int  *const,\n\t\tconst abaqus_int  *const,\n\t\tconst abaqus_int  *const,\n\t\tconst abaqus_int  *const,\n\t\tabaqus_int  *const,\n\t\tconst fortran_string_size);\n}\n\nstruct LibrariesHandler\n  : public std::map<std::string,libptr>\n{\n  ~LibrariesHandler(){\n    for(iterator pl=this->begin();pl!=this->end();++pl){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n      ::FreeLibrary(pl->second);\n#else\n      ::dlclose(pl->second);\n#endif\n    }\n  } // end of ~LibrariesHandler\n}; // end of LibrariesHandler\n\nstruct UmatPtrHandler\n{\n  std::string name;\n  umatptr ptr;\n}; // end of UmatPtrHandler\n\nstatic void report(const std::string& ln,\n\t\t   const std::string& fn,\n\t\t   const std::string& en,\n\t\t   const char * const n){\n  std::cerr << \"umat::load : could not load behaviour '\"\n  << std::string(n,n+80) << '\\'';\n  if(!ln.empty()){\n    std::cerr << \"\\nTried library '\" << ln << '\\'';\n  }\n  if(!fn.empty()){\n    std::cerr << \"\\nTried function '\" << fn << '\\'';\n  }\n  if(!en.empty()){\n    std::cerr << '\\n' << en;\n  }\n  std::cerr << std::endl;\n}\n\nstruct UMATNameCompare\n{\n  UMATNameCompare(const char* const s)\n    : n(s)\n  {} // end of UMATNameCompare\n  UMATNameCompare(const UMATNameCompare &p)\n    : n(p.n)\n  {}\n  bool operator()(const UmatPtrHandler& h) const{\n    return ::strncmp(h.name.data(),n,std::min(h.name.size(),\n\t\t\t\t\t      std::string::size_type(79)))==0;\n  }\nprivate:\n  const char* const n;\n};\nstatic void error_msg(const char* const msg){\n  std::cerr << \"umat: \" << msg << std::endl;\n}\n\nstatic std::string extract(const char*& p,\n\t\t\t   const char* const pe,\n\t\t\t   const char* const msg)\n{\n  if(p==pe){\n    error_msg(msg);\n    return \"\";\n  }\n  const char* const n = std::find(p,pe,'_');\n  if(n==p){\n    error_msg(msg);\n    return \"\";\n  }\n  std::string r = std::string(p,n);\n  p=n;\n  return r;\n}\n\nstatic std::pair<std::string,std::string> decompose(const char * const n)\n{\n  const char* pn = n;\n  const char* pne = n+80;\n  // removing spaces at the end\n  while((pne!=pn)&&((std::isspace(*(pne-1)))||(*(pne-1)=='\\0'))){\n    --pne;\n  }\n  if(pn==pne){\n    error_msg(\"empty string\");\n    return std::make_pair(std::string(),std::string());\n  };\n  const std::string ln = extract(pn,pne,\"can't extract library name\");\n#ifdef _WIN32\t\t\t \n  std::string lib = \"lib\" + ln + \".dll\";\n#else\n  std::string lib = \"lib\" + ln + \".so\";\n#endif\n  if(pn==pne){\n    error_msg(\"extract function name\");\n    return std::make_pair(std::string(),std::string());\n  }\n  ++pn;\n  std::string fct = extract(pn,pne,\"can't extract function name\");\n  if(fct.empty()){\n    return std::make_pair(std::string(),std::string());\n  }\n  if(pn!=pne){\n    ++pn;\n    fct += '_'+extract(pn,pne,\"can't extract hypothesis\");\n  }\n#ifdef MFRONT_UMAT_DEBUG\n  std::cout << \"library: \"   << lib << std::endl;\n  std::cout << \"behaviour: \" << fct << std::endl;\n  if(pn!=pne){\n    ++pn;\n    if(pn!=pne){\n      std::cout << \"suffix: '\" << std::string(pn,pne) << \"'\" << std::endl; \n    }\n  }\n#endif /* MFRONT_UMAT_DEBUG */\n  return std::make_pair(lib,fct);\n}\n\nstatic umatptr load(const char* n){\n  typedef std::vector<UmatPtrHandler> UmatPtrContainer;\n  static LibrariesHandler libraries;\n  static UmatPtrContainer fcts;\n#ifdef HAVE_STD_MUTEX\n   static std::mutex m;\n   std::lock_guard<std::mutex> lock(m);\n#else /* HAVE_STD_MUTEX */\n   lock l;\n#endif  /* HAVE_STD_MUTEX */\n  try{\n    UmatPtrContainer::const_iterator p;\n    p = std::find_if(fcts.begin(),fcts.end(),UMATNameCompare(n));\n    if(p==fcts.end()){\n      const std::pair<std::string,std::string> lf = decompose(n);\n      const std::string& lib = lf.first;\n      const std::string& fct = lf.second;\n      if(lib.empty()){\n\treport(\"\",\"\",\"\",n);\n\treturn NULLPTR(umatptr);\n      }\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n      libptr l = ::LoadLibrary(TEXT (lib.c_str()));\n#else\n      libptr l = ::dlopen(lib.c_str(),RTLD_NOW);\n#endif\n      if(l==NULLPTR(libptr)){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n\treport(lib,\"\",getLastWin32Error(),n);\n#else\n\treport(lib,\"\",::dlerror(),n);\n#endif\t\n\treturn NULLPTR(umatptr);\n      }\n      libraries.insert(std::make_pair(lib,l));\n      union {\n\tvoid *ptr;\n\tumatptr f;\n      } r;\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n      r.f = reinterpret_cast<umatptr>(::GetProcAddress(l,fct.c_str()));\n#else\n      r.ptr = ::dlsym(l,fct.c_str());\n#endif\n      if(r.ptr==NULLPTR(void *)){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n\treport(lib,fct,getLastWin32Error(),n);\n#else\n\treport(lib,fct,::dlerror(),n);\n#endif\t\n\treturn NULLPTR(umatptr);\n      }\n      UmatPtrHandler h;\n      h.name = std::string(n,n+80);\n      h.ptr  = r.f;\n      fcts.push_back(h);\n      return r.f;\n    }\n    return p->ptr;\n  }\n  catch(const std::exception& e){\n    std::cerr << \"umat::load : \" << e.what() << std::endl;\n  }\n  catch(...){\n    std::cerr << \"umat::load : unknown exception\" << std::endl;\n  }\n  return NULLPTR(umatptr);\n}\n\nextern \"C\" {\n\n  void UMATFCT(abaqus_real *const STRESS,\n\t       abaqus_real *const STATEV,\n\t       abaqus_real *const DDSDDE,\n\t       abaqus_real *const SSE,\n\t       abaqus_real *const SPD,\n\t       abaqus_real *const SCD,\n\t       abaqus_real *const RPL,\n\t       abaqus_real *const DDSDDT,\n\t       abaqus_real *const DRPLDE,\n\t       abaqus_real *const DRPLDT,\n\t       const abaqus_real *const STRAN,\n\t       const abaqus_real *const DSTRAN,\n\t       const abaqus_real *const TIME,\n\t       const abaqus_real *const DTIME,\n\t       const abaqus_real *const TEMP,\n\t       const abaqus_real *const DTEMP,\n\t       const abaqus_real *const PREDEF,\n\t       const abaqus_real *const DPRED,\n\t       const char           *const CMNAME,\n\t       const abaqus_int  *const NDI,\n\t       const abaqus_int  *const NSHR,\n\t       const abaqus_int  *const NTENS,\n\t       const abaqus_int  *const NSTATV,\n\t       const abaqus_real *const PROPS,\n\t       const abaqus_int  *const NPROPS,\n\t       const abaqus_real *const COORDS,\n\t       const abaqus_real *const DROT,\n\t       abaqus_real *const PNEWDT,\n\t       const abaqus_real *const CELENT,\n\t       const abaqus_real *const DFGRD0,\n\t       const abaqus_real *const DFGRD1,\n\t       const abaqus_int  *const NOEL,\n\t       const abaqus_int  *const NPT,\n\t       const abaqus_int  *const LAYER,\n\t       const abaqus_int  *const KSPT,\n\t       const abaqus_int  *const KSTEP,\n\t       abaqus_int  *const KINC,\n\t       const fortran_string_size size){\n    umatptr f = load(CMNAME);\n    if(f!=NULLPTR(umatptr)){\n      f(STRESS,STATEV,DDSDDE,SSE,SPD,SCD,RPL,\n\tDDSDDT,DRPLDE,DRPLDT,STRAN,DSTRAN,TIME,\n\tDTIME,TEMP,DTEMP,PREDEF,DPRED,CMNAME,\n\tNDI,NSHR,NTENS,NSTATV,PROPS,NPROPS,\n\tCOORDS,DROT,PNEWDT,CELENT,DFGRD0,DFGRD1,\n\tNOEL,NPT,LAYER,KSPT,KSTEP,KINC,size);\n      return;\n    }\n\n    /*\n     * by default, we fail if we could not load an external function\n     */\n    \n    std::cout << \"umat : unsupported material\" << std::endl;\n    ::exit(-1);\n\n    /*\n     * However, if we want to combine mfront laws and standard umat,\n     * it is possible:\n     * - just rename your standard umat subroutine in umat2\n     * - comment the two previous lines\n     * - uncomment the newt lines\n     */\n    \n    //     UMATFCT2(STRESS,STATEV,DDSDDE,SSE,SPD,SCD,RPL,\n    // \t   DDSDDT,DRPLDE,DRPLDT,STRAN,DSTRAN,TIME,\n    // \t   DTIME,TEMP,DTEMP,PREDEF,DPRED,CMNAME,\n    // \t   NDI,NSHR,NTENS,NSTATV,PROPS,NPROPS,\n    // \t   COORDS,DROT,PNEWDT,CELENT,DFGRD0,DFGRD1,\n    // \t   NOEL,NPT,LAYER,KSPT,KSTEP,KINC,size);\n    \n  } // end of umat_\n  \n} // end of extern \"C\"\n\n// int main(void){\n//   char n[80] = {'\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n// \t\t'\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n// \t\t'\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n// \t\t'\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n// \t\t'\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n// \t\t'\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n// \t\t'\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0',\n// \t\t'\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0','\\0'};\n//   const char * b = \"UMATBEHAVIOUR_CHABOCHE_3D_1\";\n//   std::copy(b,b+std::strlen(b),n);\n//   std::pair<std::string,std::string> r = decompose(n);\n//   std::cout << r.first << std::endl;\n//   std::cout << r.second << std::endl;\n//   std::fill(n,n+80,'\\0');\n//   const char * b2 = \"UMATBEHAVIOUR_CHABOCHE_PSTRAIN\";\n//   std::copy(b2,b2+std::strlen(b2),n);\n//   r = decompose(n);\n//   std::cout << r.first << std::endl;\n//   std::cout << r.second << std::endl;\n//   std::fill(n,n+80,'\\0');\n//   r = decompose(n);\n//   std::cout << r.first << std::endl;\n//   std::cout << r.second << std::endl;\n//   return 0;\n// }\n",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/abaqus/vumat-sp.cpp": "/*!\n * \\file   vumat-dp.cpp\n * \\brief    \n * \\author Thomas Helfer\n * \\date   21/03/2016\n */\n\n#include<iostream>\n#include<cstdlib>\n\n#include<map>\n#include<string>\n#include<cctype>\n#include<vector>\n#include<utility>\n#include<cstring>\n#include<stdexcept>\n#include<algorithm>\n\n#if __cplusplus >= 201103L\n#include<mutex>\n#define HAVE_STD_MUTEX\n#define NULLPTR(X) nullptr\n#else  /* __cplusplus >= 201103L */\n#define NULLPTR(X) static_cast<X>(0)\n#endif /* __cplusplus >= 201103L */\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#ifndef NOMINMAX\n#define NOMINMAX\n#endif\n#include<windows.h>\n#ifdef min\n#undef min\n#endif\n\n#ifdef max\n#undef max\n#endif\ntypedef HINSTANCE__*  libptr;\n\n#ifndef HAVE_STD_MUTEX\n\nstruct Mutex\n{\n  static Mutex& getMutex(){\n    static Mutex m;\n    return m;\n  }\n  HANDLE m;\nprivate:\n  Mutex(){\n    this->m = CreateMutex(NULL,  // default security attributes\n\t\t\tFALSE, // initially not owned\n\t\t\tNULL); // unnamed mutex\n  }\n};\n\nstruct lock\n{\n  lock(){\n    DWORD r = WaitForSingleObject(Mutex::getMutex().m,\n\t\t\t\t  INFINITE);\n    if(r==WAIT_ABANDONED){\n      std::cerr << \"vumat: abandonned mutex\" << std::endl;\n      std::exit(EXIT_FAILURE);\n    }\n  }\n  ~lock(){\n    CloseHandle(Mutex::getMutex().m);\n  }\n};\n#endif /* HAVE_STD_MUTEX */\n\n// code retrieved from\n// http://www.codeproject.com/Tips/479880/GetLastError-as-std-string\nstatic std::string getLastWin32Error()\n{\n  const DWORD error = GetLastError();\n  if (error){\n    LPVOID lpMsgBuf;\n    DWORD bufLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | \n\t\t\t\t FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t\t FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\t\t\t NULL,error,\n\t\t\t\t MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t\t (LPTSTR) &lpMsgBuf,0,NULL );\n    if (bufLen){\n      LPCSTR lpMsgStr = (LPTSTR) lpMsgBuf;\n      std::string result(lpMsgStr, lpMsgStr+bufLen);\n      LocalFree(lpMsgBuf);\n      return result;\n    }\n  }\n  return std::string();\n}\n\n#else\n#include<dlfcn.h>\ntypedef void * libptr;\n#ifndef HAVE_STD_MUTEX\n#error \"Unsupported platform\"\n#endif /* HAVE_STD_MUTEX */\n#endif\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#define VUMATFCT  vumat\n#define VUMATFCT2 vumat2\n#else\n#define VUMATFCT  vumat_\n#define VUMATFCT2 vumat2_\n#endif\n\n#if (defined _WIN32) && (!defined _WIN64)\ntypedef int    fortran_string_size;\n#elif defined _WIN64\ntypedef size_t fortran_string_size;\n#else\ntypedef int    fortran_string_size;\n#endif\n\ntypedef float abaqus_real;\ntypedef int   abaqus_int;\n\ntypedef  void (*vumatptr)(const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const char* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real*,\n\t\t\t  const abaqus_real*,\n\t\t\t  const abaqus_real*,\n\t\t\t  const abaqus_real*,\n\t\t\t  const fortran_string_size);\n\nextern \"C\" {\n  void VUMATFCT(const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const char* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real*,\n\t       const abaqus_real*,\n\t       const abaqus_real*,\n\t       const abaqus_real*,\n\t       const fortran_string_size);\n\n  void VUMATFCT2(const abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst char* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real*,\n\t\tconst abaqus_real*,\n\t\tconst abaqus_real*,\n\t\tconst abaqus_real*,\n\t\tconst fortran_string_size);\n}\n\nstruct LibrariesHandler\n  : public std::map<std::string,libptr>\n{\n  ~LibrariesHandler(){\n    for(iterator pl=this->begin();pl!=this->end();++pl){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n      ::FreeLibrary(pl->second);\n#else\n      ::dlclose(pl->second);\n#endif\n    }\n  } // end of ~LibrariesHandler\n}; // end of LibrariesHandler\n\nstruct VUMATPtrHandler\n{\n  std::string name;\n  vumatptr ptr;\n}; // end of VUMATPtrHandler\n\nstatic void report(const std::string& ln,\n\t\t   const std::string& fn,\n\t\t   const std::string& en,\n\t\t   const char * const n){\n  std::cerr << \"vumat::load : could not load behaviour '\"\n  << std::string(n,n+80) << '\\'';\n  if(!ln.empty()){\n    std::cerr << \"\\nTried library '\" << ln << '\\'';\n  }\n  if(!fn.empty()){\n    std::cerr << \"\\nTried function '\" << fn << '\\'';\n  }\n  if(!en.empty()){\n    std::cerr << '\\n' << en;\n  }\n  std::cerr << std::endl;\n}\n\nstruct VUMATNameCompare\n{\n  VUMATNameCompare(const char* const s)\n    : n(s)\n  {} // end of VUMATNameCompare\n  VUMATNameCompare(const VUMATNameCompare &p)\n    : n(p.n)\n  {}\n  bool operator()(const VUMATPtrHandler& h) const{\n    return ::strncmp(h.name.data(),n,std::min(h.name.size(),\n\t\t\t\t\t      std::string::size_type(79)))==0;\n  }\nprivate:\n  const char* const n;\n};\nstatic void error_msg(const char* const msg){\n  std::cerr << \"vumat: \" << msg << std::endl;\n}\n\nstatic std::string extract(const char*& p,\n\t\t\t   const char* const pe,\n\t\t\t   const char* const msg)\n{\n  if(p==pe){\n    error_msg(msg);\n    return \"\";\n  }\n  const char* const n = std::find(p,pe,'_');\n  if(n==p){\n    error_msg(msg);\n    return \"\";\n  }\n  std::string r = std::string(p,n);\n  p=n;\n  return r;\n}\n\nstatic std::pair<std::string,std::string> decompose(const char * const n)\n{\n  const char* pn = n;\n  const char* pne = n+80;\n  // removing spaces at the end\n  while((pne!=pn)&&((std::isspace(*(pne-1)))||(*(pne-1)=='\\0'))){\n    --pne;\n  }\n  if(pn==pne){\n    error_msg(\"empty string\");\n    return std::make_pair(std::string(),std::string());\n  };\n  const std::string ln = extract(pn,pne,\"can't extract library name\");\n#ifdef _WIN32\t\t\t \n  std::string lib = \"lib\" + ln + \".dll\";\n#else\n  std::string lib = \"lib\" + ln + \".so\";\n#endif\n  if(pn==pne){\n    error_msg(\"extract function name\");\n    return std::make_pair(std::string(),std::string());\n  }\n  ++pn;\n  std::string fct = extract(pn,pne,\"can't extract function name\");\n  if(fct.empty()){\n    return std::make_pair(std::string(),std::string());\n  }\n  if(pn!=pne){\n    ++pn;\n    fct += '_'+extract(pn,pne,\"can't extract hypothesis\");\n  }\n  fct += \"_f\"; // simple precision\n#ifdef MFRONT_VUMAT_DEBUG\n  std::cout << \"library: \"   << lib << std::endl;\n  std::cout << \"behaviour: \" << fct << std::endl;\n  if(pn!=pne){\n    ++pn;\n    if(pn!=pne){\n      std::cout << \"suffix: '\" << std::string(pn,pne) << \"'\" << std::endl; \n    }\n  }\n#endif /* MFRONT_VUMAT_DEBUG */\n  return std::make_pair(lib,fct);\n}\n\nstatic vumatptr load(const char* n){\n  typedef std::vector<VUMATPtrHandler> VUMATPtrContainer;\n  static LibrariesHandler libraries;\n  static VUMATPtrContainer fcts;\n#ifdef HAVE_STD_MUTEX\n   static std::mutex m;\n   std::lock_guard<std::mutex> lock(m);\n#else /* HAVE_STD_MUTEX */\n   lock l;\n#endif  /* HAVE_STD_MUTEX */\n  try{\n    VUMATPtrContainer::const_iterator p;\n    p = std::find_if(fcts.begin(),fcts.end(),VUMATNameCompare(n));\n    if(p==fcts.end()){\n      const std::pair<std::string,std::string> lf = decompose(n);\n      const std::string& lib = lf.first;\n      const std::string& fct = lf.second;\n      if(lib.empty()){\n\treport(\"\",\"\",\"\",n);\n\treturn NULLPTR(vumatptr);\n      }\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n      libptr l = ::LoadLibrary(TEXT (lib.c_str()));\n#else\n      libptr l = ::dlopen(lib.c_str(),RTLD_NOW);\n#endif\n      if(l==NULLPTR(libptr)){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n\treport(lib,\"\",getLastWin32Error(),n);\n#else\n\treport(lib,\"\",::dlerror(),n);\n#endif\t\n\treturn NULLPTR(vumatptr);\n      }\n      libraries.insert(std::make_pair(lib,l));\n      union {\n\tvoid *ptr;\n\tvumatptr f;\n      } r;\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n      r.f = reinterpret_cast<vumatptr>(::GetProcAddress(l,fct.c_str()));\n#else\n      r.ptr = ::dlsym(l,fct.c_str());\n#endif\n      if(r.ptr==NULLPTR(void *)){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n\treport(lib,fct,getLastWin32Error(),n);\n#else\n\treport(lib,fct,::dlerror(),n);\n#endif\t\n\treturn NULLPTR(vumatptr);\n      }\n      VUMATPtrHandler h;\n      h.name = std::string(n,n+80);\n      h.ptr  = r.f;\n      fcts.push_back(h);\n      return r.f;\n    }\n    return p->ptr;\n  }\n  catch(const std::exception& e){\n    std::cerr << \"vumat::load : \" << e.what() << std::endl;\n  }\n  catch(...){\n    std::cerr << \"vumat::load : unknown exception\" << std::endl;\n  }\n  return NULLPTR(vumatptr);\n}\n\nextern \"C\" {\n\n  void VUMATFCT(const abaqus_int *const nblock,\n\t\tconst abaqus_int *const ndir,\n\t\tconst abaqus_int *const nshr,\n\t\tconst abaqus_int *const nstatev,\n\t\tconst abaqus_int *const nfieldv,\n\t\tconst abaqus_int *const nprops,\n\t\tconst abaqus_int * const lanneal,\n\t\tconst abaqus_real* const stepTime,\n\t\tconst abaqus_real* const totalTime,\n\t\tconst abaqus_real* const dt,\n\t\tconst char* const cmname,\n\t\tconst abaqus_real* const coordMp,\n\t\tconst abaqus_real* const charLength,\n\t\tconst abaqus_real* const props,\n\t\tconst abaqus_real* const density,\n\t\tconst abaqus_real* const strainInc,\n\t\tconst abaqus_real* const relSpinInc,\n\t\tconst abaqus_real* const tempOld,\n\t\tconst abaqus_real* const stretchOld,\n\t\tconst abaqus_real* const defgradOld,\n\t\tconst abaqus_real* const fieldOld,\n\t\tconst abaqus_real* const stressOld,\n\t\tconst abaqus_real* const stateOld,\n\t\tconst abaqus_real* const enerInternOld,\n\t\tconst abaqus_real* const enerInelasOld,\n\t\tconst abaqus_real* const tempNew,\n\t\tconst abaqus_real* const stretchNew,\n\t\tconst abaqus_real* const defgradNew,\n\t\tconst abaqus_real* const fieldNew,\n\t\tconst abaqus_real* stressNew,\n\t\tconst abaqus_real* stateNew,\n\t\tconst abaqus_real* enerInternNew,\n\t\tconst abaqus_real* enerInelasNew,\n\t       const fortran_string_size size){\n    const vumatptr f = load(cmname);\n    if(f!=NULLPTR(vumatptr)){\n      f(nblock,ndir,nshr,nstatev,nfieldv,nprops,\n\tlanneal,stepTime,totalTime,dt,\n\tcmname,coordMp,charLength,props,\n\tdensity,strainInc,relSpinInc,tempOld,\n\tstretchOld,defgradOld,fieldOld,stressOld,\n\tstateOld,enerInternOld,enerInelasOld,tempNew,\n\tstretchNew,defgradNew,fieldNew,stressNew,\n\tstateNew,enerInternNew,enerInelasNew,size);\n      return;\n    }\n\n    /*\n     * by default, we fail if we could not load an external function\n     */\n    \n    std::cout << \"vumat : unsupported material\" << std::endl;\n    ::exit(-1);\n\n    /*\n     * However, if we want to combine mfront laws and standard vumat,\n     * it is possible:\n     * - just rename your standard vumat subroutine in vumat2\n     * - comment the two previous lines\n     * - uncomment the newt lines\n     */\n    \n    // VUMATFCT2(nblock,ndir,nshr,nstatev,nfieldv,nprops,\n    // \t         lanneal,stepTime,totalTime,dt,\n    // \t         cmname,coordMp,charLength,props,\n    // \t         density,strainInc,relSpinInc,tempOld,\n    // \t         stretchOld,defgradOld,fieldOld,stressOld,\n    // \t         stateOld,enerInternOld,enerInelasOld,tempNew,\n    // \t         stretchNew,defgradNew,fieldNew,stressNew,\n    // \t         stateNew,enerInternNew,enerInelasNew,size);\n    \n  } // end of vumat_\n  \n} // end of extern \"C\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/abaqus/vumat-dp.cpp": "/*!\n * \\file   vumat-dp.cpp\n * \\brief    \n * \\author Thomas Helfer\n * \\date   21/03/2016\n */\n\n#include<iostream>\n#include<cstdlib>\n\n#include<map>\n#include<string>\n#include<cctype>\n#include<vector>\n#include<utility>\n#include<cstring>\n#include<stdexcept>\n#include<algorithm>\n\n#if __cplusplus >= 201103L\n#include<mutex>\n#define HAVE_STD_MUTEX\n#define NULLPTR(X) nullptr\n#else  /* __cplusplus >= 201103L */\n#define NULLPTR(X) static_cast<X>(0)\n#endif /* __cplusplus >= 201103L */\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#ifndef NOMINMAX\n#define NOMINMAX\n#endif\n#include<windows.h>\n#ifdef min\n#undef min\n#endif\n\n#ifdef max\n#undef max\n#endif\ntypedef HINSTANCE__*  libptr;\n\n#ifndef HAVE_STD_MUTEX\n\nstruct Mutex\n{\n  static Mutex& getMutex(){\n    static Mutex m;\n    return m;\n  }\n  HANDLE m;\nprivate:\n  Mutex(){\n    this->m = CreateMutex(NULL,  // default security attributes\n\t\t\tFALSE, // initially not owned\n\t\t\tNULL); // unnamed mutex\n  }\n};\n\nstruct lock\n{\n  lock(){\n    DWORD r = WaitForSingleObject(Mutex::getMutex().m,\n\t\t\t\t  INFINITE);\n    if(r==WAIT_ABANDONED){\n      std::cerr << \"vumat: abandonned mutex\" << std::endl;\n      std::exit(EXIT_FAILURE);\n    }\n  }\n  ~lock(){\n    CloseHandle(Mutex::getMutex().m);\n  }\n};\n#endif /* HAVE_STD_MUTEX */\n\n// code retrieved from\n// http://www.codeproject.com/Tips/479880/GetLastError-as-std-string\nstatic std::string getLastWin32Error()\n{\n  const DWORD error = GetLastError();\n  if (error){\n    LPVOID lpMsgBuf;\n    DWORD bufLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | \n\t\t\t\t FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t\t FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\t\t\t NULL,error,\n\t\t\t\t MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t\t\t\t (LPTSTR) &lpMsgBuf,0,NULL );\n    if (bufLen){\n      LPCSTR lpMsgStr = (LPTSTR) lpMsgBuf;\n      std::string result(lpMsgStr, lpMsgStr+bufLen);\n      LocalFree(lpMsgBuf);\n      return result;\n    }\n  }\n  return std::string();\n}\n\n#else\n#include<dlfcn.h>\ntypedef void * libptr;\n#ifndef HAVE_STD_MUTEX\n#error \"Unsupported platform\"\n#endif /* HAVE_STD_MUTEX */\n#endif\n\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n#define VUMATFCT  vumat\n#define VUMATFCT2 vumat2\n#else\n#define VUMATFCT  vumat_\n#define VUMATFCT2 vumat2_\n#endif\n\n#if (defined _WIN32) && (!defined _WIN64)\ntypedef int    fortran_string_size;\n#elif defined _WIN64\ntypedef size_t fortran_string_size;\n#else\ntypedef int    fortran_string_size;\n#endif\n\ntypedef double abaqus_real;\ntypedef int    abaqus_int;\n\ntypedef  void (*vumatptr)(const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_int *const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const char* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real* const,\n\t\t\t  const abaqus_real*,\n\t\t\t  const abaqus_real*,\n\t\t\t  const abaqus_real*,\n\t\t\t  const abaqus_real*,\n\t\t\t  const fortran_string_size);\n\nextern \"C\" {\n  void VUMATFCT(const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_int *const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const char* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real* const,\n\t       const abaqus_real*,\n\t       const abaqus_real*,\n\t       const abaqus_real*,\n\t       const abaqus_real*,\n\t       const fortran_string_size);\n\n  void VUMATFCT2(const abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_int *const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst char* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real* const,\n\t\tconst abaqus_real*,\n\t\tconst abaqus_real*,\n\t\tconst abaqus_real*,\n\t\tconst abaqus_real*,\n\t\tconst fortran_string_size);\n}\n\nstruct LibrariesHandler\n  : public std::map<std::string,libptr>\n{\n  ~LibrariesHandler(){\n    for(iterator pl=this->begin();pl!=this->end();++pl){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n      ::FreeLibrary(pl->second);\n#else\n      ::dlclose(pl->second);\n#endif\n    }\n  } // end of ~LibrariesHandler\n}; // end of LibrariesHandler\n\nstruct VUMATPtrHandler\n{\n  std::string name;\n  vumatptr ptr;\n}; // end of VUMATPtrHandler\n\nstatic void report(const std::string& ln,\n\t\t   const std::string& fn,\n\t\t   const std::string& en,\n\t\t   const char * const n){\n  std::cerr << \"vumat::load : could not load behaviour '\"\n  << std::string(n,n+80) << '\\'';\n  if(!ln.empty()){\n    std::cerr << \"\\nTried library '\" << ln << '\\'';\n  }\n  if(!fn.empty()){\n    std::cerr << \"\\nTried function '\" << fn << '\\'';\n  }\n  if(!en.empty()){\n    std::cerr << '\\n' << en;\n  }\n  std::cerr << std::endl;\n}\n\nstruct VUMATNameCompare\n{\n  VUMATNameCompare(const char* const s)\n    : n(s)\n  {} // end of VUMATNameCompare\n  VUMATNameCompare(const VUMATNameCompare &p)\n    : n(p.n)\n  {}\n  bool operator()(const VUMATPtrHandler& h) const{\n    return ::strncmp(h.name.data(),n,std::min(h.name.size(),\n\t\t\t\t\t      std::string::size_type(79)))==0;\n  }\nprivate:\n  const char* const n;\n};\n\nstatic void error_msg(const char* const msg){\n  std::cerr << \"vumat: \" << msg << std::endl;\n}\n\nstatic std::string extract(const char*& p,\n\t\t\t   const char* const pe,\n\t\t\t   const char* const msg)\n{\n  if(p==pe){\n    error_msg(msg);\n    return \"\";\n  }\n  const char* const n = std::find(p,pe,'_');\n  if(n==p){\n    error_msg(msg);\n    return \"\";\n  }\n  std::string r = std::string(p,n);\n  p=n;\n  return r;\n}\n\nstatic std::pair<std::string,std::string> decompose(const char * const n)\n{\n  const char* pn = n;\n  const char* pne = n+80;\n  // removing spaces at the end\n  while((pne!=pn)&&((std::isspace(*(pne-1)))||(*(pne-1)=='\\0'))){\n    --pne;\n  }\n  if(pn==pne){\n    error_msg(\"empty string\");\n    return std::make_pair(std::string(),std::string());\n  };\n  const std::string ln = extract(pn,pne,\"can't extract library name\");\n#ifdef _WIN32\t\t\t \n  std::string lib = \"lib\" + ln + \".dll\";\n#else\n  std::string lib = \"lib\" + ln + \".so\";\n#endif\n  if(pn==pne){\n    error_msg(\"extract function name\");\n    return std::make_pair(std::string(),std::string());\n  }\n  ++pn;\n  std::string fct = extract(pn,pne,\"can't extract function name\");\n  if(fct.empty()){\n    return std::make_pair(std::string(),std::string());\n  }\n  if(pn!=pne){\n    ++pn;\n    fct += '_'+extract(pn,pne,\"can't extract hypothesis\");\n  }\n#ifdef MFRONT_VUMAT_DEBUG\n  std::cout << \"library: \"   << lib << std::endl;\n  std::cout << \"behaviour: \" << fct << std::endl;\n  if(pn!=pne){\n    ++pn;\n    if(pn!=pne){\n      std::cout << \"suffix: '\" << std::string(pn,pne) << \"'\" << std::endl; \n    }\n  }\n#endif /* MFRONT_VUMAT_DEBUG */\n  return std::make_pair(lib,fct);\n}\n\nstatic vumatptr load(const char* n){\n  typedef std::vector<VUMATPtrHandler> VUMATPtrContainer;\n  static LibrariesHandler libraries;\n  static VUMATPtrContainer fcts;\n#ifdef HAVE_STD_MUTEX\n   static std::mutex m;\n   std::lock_guard<std::mutex> lock(m);\n#else /* HAVE_STD_MUTEX */\n   lock l;\n#endif  /* HAVE_STD_MUTEX */\n  try{\n    VUMATPtrContainer::const_iterator p;\n    p = std::find_if(fcts.begin(),fcts.end(),VUMATNameCompare(n));\n    if(p==fcts.end()){\n      const std::pair<std::string,std::string> lf = decompose(n);\n      const std::string& lib = lf.first;\n      const std::string& fct = lf.second;\n      if(lib.empty()){\n\treport(\"\",\"\",\"\",n);\n\treturn NULLPTR(vumatptr);\n      }\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n      libptr l = ::LoadLibrary(TEXT (lib.c_str()));\n#else\n      libptr l = ::dlopen(lib.c_str(),RTLD_NOW);\n#endif\n      if(l==NULLPTR(libptr)){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n\treport(lib,\"\",getLastWin32Error(),n);\n#else\n\treport(lib,\"\",::dlerror(),n);\n#endif\t\n\treturn NULLPTR(vumatptr);\n      }\n      libraries.insert(std::make_pair(lib,l));\n      union {\n\tvoid *ptr;\n\tvumatptr f;\n      } r;\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n      r.f = reinterpret_cast<vumatptr>(::GetProcAddress(l,fct.c_str()));\n#else\n      r.ptr = ::dlsym(l,fct.c_str());\n#endif\n      if(r.ptr==NULLPTR(void *)){\n#if (defined _WIN32 || defined _WIN64) && (!defined __CYGWIN__)\n\treport(lib,fct,getLastWin32Error(),n);\n#else\n\treport(lib,fct,::dlerror(),n);\n#endif\t\n\treturn NULLPTR(vumatptr);\n      }\n      VUMATPtrHandler h;\n      h.name = std::string(n,n+80);\n      h.ptr  = r.f;\n      fcts.push_back(h);\n      return r.f;\n    }\n    return p->ptr;\n  }\n  catch(const std::exception& e){\n    std::cerr << \"vumat::load : \" << e.what() << std::endl;\n  }\n  catch(...){\n    std::cerr << \"vumat::load : unknown exception\" << std::endl;\n  }\n  return NULLPTR(vumatptr);\n}\n\nextern \"C\" {\n\n  void VUMATFCT(const abaqus_int *const nblock,\n\t\tconst abaqus_int *const ndir,\n\t\tconst abaqus_int *const nshr,\n\t\tconst abaqus_int *const nstatev,\n\t\tconst abaqus_int *const nfieldv,\n\t\tconst abaqus_int *const nprops,\n\t\tconst abaqus_int * const lanneal,\n\t\tconst abaqus_real* const stepTime,\n\t\tconst abaqus_real* const totalTime,\n\t\tconst abaqus_real* const dt,\n\t\tconst char* const cmname,\n\t\tconst abaqus_real* const coordMp,\n\t\tconst abaqus_real* const charLength,\n\t\tconst abaqus_real* const props,\n\t\tconst abaqus_real* const density,\n\t\tconst abaqus_real* const strainInc,\n\t\tconst abaqus_real* const relSpinInc,\n\t\tconst abaqus_real* const tempOld,\n\t\tconst abaqus_real* const stretchOld,\n\t\tconst abaqus_real* const defgradOld,\n\t\tconst abaqus_real* const fieldOld,\n\t\tconst abaqus_real* const stressOld,\n\t\tconst abaqus_real* const stateOld,\n\t\tconst abaqus_real* const enerInternOld,\n\t\tconst abaqus_real* const enerInelasOld,\n\t\tconst abaqus_real* const tempNew,\n\t\tconst abaqus_real* const stretchNew,\n\t\tconst abaqus_real* const defgradNew,\n\t\tconst abaqus_real* const fieldNew,\n\t\tconst abaqus_real* stressNew,\n\t\tconst abaqus_real* stateNew,\n\t\tconst abaqus_real* enerInternNew,\n\t\tconst abaqus_real* enerInelasNew,\n\t       const fortran_string_size size){\n    const vumatptr f = load(cmname);\n    if(f!=NULLPTR(vumatptr)){\n      f(nblock,ndir,nshr,nstatev,nfieldv,nprops,\n\tlanneal,stepTime,totalTime,dt,\n\tcmname,coordMp,charLength,props,\n\tdensity,strainInc,relSpinInc,tempOld,\n\tstretchOld,defgradOld,fieldOld,stressOld,\n\tstateOld,enerInternOld,enerInelasOld,tempNew,\n\tstretchNew,defgradNew,fieldNew,stressNew,\n\tstateNew,enerInternNew,enerInelasNew,size);\n      return;\n    }\n\n    /*\n     * by default, we fail if we could not load an external function\n     */\n    \n    std::cout << \"vumat : unsupported material\" << std::endl;\n    ::exit(-1);\n\n    /*\n     * However, if we want to combine mfront laws and standard vumat,\n     * it is possible:\n     * - just rename your standard vumat subroutine in vumat2\n     * - comment the two previous lines\n     * - uncomment the newt lines\n     */\n    \n    // VUMATFCT2(nblock,ndir,nshr,nstatev,nfieldv,nprops,\n    // \t         lanneal,stepTime,totalTime,dt,\n    // \t         cmname,coordMp,charLength,props,\n    // \t         density,strainInc,relSpinInc,tempOld,\n    // \t         stretchOld,defgradOld,fieldOld,stressOld,\n    // \t         stateOld,enerInternOld,enerInelasOld,tempNew,\n    // \t         stretchNew,defgradNew,fieldNew,stressNew,\n    // \t         stateNew,enerInternNew,enerInelasNew,size);\n    \n  } // end of vumat_\n  \n} // end of extern \"C\"\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/System/System.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/System/BinaryRead.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/System/BinaryWrite.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/Exception/TFELException.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/Math/LevenbergMarquardtExternalFunctionWrapper.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/Math/LevenbergMarquardtEvaluatorWrapper.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/Math/KrigedFunction.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/Math/KrigingUtilities.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/Math/MathException.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/src/Material/MaterialException.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/CubicSpline.ixx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/General/AbsCompare.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/General/DotProduct.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/General/Complex.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/Stensor/StensorConceptOperations.ixx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/Kriging/KrigingUtilities.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/Vector/VectorConceptOperations.ixx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/Vector/VectorVectorDotProduct.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/LevenbergMarquardt/LevenbergMarquardtFunctionWrapper.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/LevenbergMarquardt/LevenbergMarquardtExternalFunctionWrapper.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/LevenbergMarquardt/LevenbergMarquardtEvaluatorWrapper.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/LevenbergMarquardt/LevenbergMarquardtFunctionWrapper.ixx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Math/Tensor/TensorConceptOperations.ixx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/Utilities/GenTypeBase.ixx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/include/TFEL/TypeTraits/IsRandomAccessIterator.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mtest/tests/mtest/castem/mooney.f",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/src/AsterRotationMatrix.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/src/CastemRotationMatrix.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/include/MFront/Europlexus/EuroplexusTraits.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/include/MFront/Aster/AsterTraits.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/include/MFront/Aster/AsterRotationMatrix.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/include/MFront/Ansys/AnsysRotation.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/include/MFront/Ansys/AnsysTraits.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/include/MFront/Cyrano/CyranoTraits.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/include/MFront/Abaqus/AbaqusRotation.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/include/MFront/Abaqus/AbaqusTraits.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/include/MFront/CalculiX/CalculiXTraits.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/include/MFront/Castem/CastemRotationMatrix.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/include/MFront/Castem/CastemTraits.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/behaviours/T91ViscoplasticBehaviour.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/behaviours/castem/dgibi/pipe3D.dgibi",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/behaviours/castem/dgibi/IncompressiblePlaneStressGornetDesmoratBehaviourUniaxialTesting.dgibi",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/behaviours/castem/dgibi/IncompressiblePlaneStressGornetDesmoratBehaviourShearTesting.dgibi",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/models/SiC_IrradiationSwellingModel_GoFaster.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/VanadiumAlloy_SpecificHeat_SRMA.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91MartensiticSteel_C2_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91AusteniticSteel_b_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91MartensiticSteel_F_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91MartensiticSteel_YieldStress_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91MartensiticSteel_C1_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/VanadiumAlloy_YoungModulus_SRMA.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91AusteniticSteel_Kvisc_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91AusteniticSteel_Rinf_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91MartensiticSteel_Kvisc_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/VanadiumAlloy_ThermalExpansion_SRMA.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91MartensiticSteel_Nexp_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91AusteniticSteel_Nexp_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91MartensiticSteel_Rinf_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91AusteniticSteel_F_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91MartensiticSteel_gamma1_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/VanadiumAlloy_ThermalConductivity_SRMA.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/T91MartensiticSteel_b_ROUX2007.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/mfront/tests/properties/VanadiumAlloy_PoissonRatio_SRMA.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/tests/System/Test.mfront",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/tests/FSAlgorithms/test_FSalgorithm2.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/tests/Math/qt3.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/tests/Math/include/promote-header.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/tests/Math/include/CubicRoots-header.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/tests/Math/RungeKutta/include/runge_kutta4-header.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/tests/Math/RungeKutta/include/runge_kutta2-header.hxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/tests/Math/stensor/stensor4.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/bindings/python/tfel/math.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/bindings/python/tfel/stensor.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/bindings/python/tfel/material.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/bindings/python/tfel/utilities.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/bindings/python/tfel/system.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/bindings/python/tfel/tvector.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/bindings/python/tfel/ProcessManagerCommand.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/tfel-config/src/tfel-config.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/tfel-doc/src/LaTeXGenerator.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/tfel-doc/src/Global.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront-en.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront.ico",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/latex/presentation.sty",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/latex/couleurs.sty",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/latex/mathematiques.sty",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/latex/mecanique.sty",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/latex/beamer/themes/beamerthemepleiades.sty",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/latex/beamer/themes/beamerthemecea.sty",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/images/ceaeaDEC.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/images/logoCad.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/images/logoCEADEC.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/images/ceaea.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/images/barre_verte.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/images/CEA_logo_quadri-sur-fond-rouge_CAD.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/images/Energie2010.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/images/logoCEA.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/images/CEA_web_quadri-sur-fond-rouge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/images/CEA_logo_quadri-sur-fond-rouge_DEC.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tex/texmf/tex/images/CEA_logo_quadri-sur-fond-rouge.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/apple-touch-icon-precomposed.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/AMITEX_FFTP_sig1.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/FreeBSD.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/hsnv125.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/mingw-get1.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorielch12-img1.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Behaviour-img9.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/AbaqusFLD.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TFEL-pcbsd.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-7.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-16.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/SalomeMeca2015.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/CalculiX_MFRONT_WSL.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-21.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Norton-web.odt",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-35.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Norton-web.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-22.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Norton-web.docx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-31.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/HureCast3M2014.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Behaviour-img5.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-43.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Norton-full.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/AMITEX_FFTP_website.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/VeRCoRs.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/mingw-get3.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/hsnv125.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/AbaqusFLD.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/AbaqusRotSigTest.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/FissurationPastille.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-9.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-32.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Behaviour-img8.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-14.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/IconeCast3M_verte.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Behaviour-img2.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/mfront-flyer-fr-2017.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-15.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/172_5pc.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Polar_decomposition_of_F.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/twitter.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/mingw-get2.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-19.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/mingw-get3.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-5.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/FuelRod-ddif2.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-25.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/CalculiX_MFRONT_WSL.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/epx.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TFEL-pcbsd.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/freebsdlogo-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/CastemWebSite.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-38.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-34.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-28.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/GreenYieldCriterion.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-6.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-40.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Configuration.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/BrittleFracturePhaseField.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-12.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-10.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/AMITEX_FFTP_sig1.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/FuelRod-ddif2.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Win64.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Behaviour-img3.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/CastemWebSite.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/HureCast3M2014.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/VisualStudioPython.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/VoidsGrowth.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Norton-full.odt",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-30.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-17.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/topfuel2015-poster.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-27.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/VeRCoRs.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-26.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-11.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-36.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-24.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-42.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-23.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/AccesDigiteo.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/twitter.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/mingw-get1.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/172_5pc.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TwitterBanner.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/HosfordStress.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Configuration.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/CodeAster2015Flyer.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/IconeCast3M_jaune.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-29.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/mfront-flyer-en-2017.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Win64.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-20.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TwitterBanner.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-13.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/AbaqusRotSigTest.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-41.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/VoidsGrowth.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-37.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/epx-bars.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/arrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-18.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-33.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/abaqus-isotropichardening1.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/CalculiXBenchmarkSmallStrain.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/AsterTotalLagrangian.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/mingw-get2.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/materiaux2014.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Behaviour-img6.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TrueOS.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/Norton-full.docx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/CauchyStressComponents.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/IconeCast3M_bleue.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/AbaqusFLD.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/abaqus-isotropichardening2.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/tutorial-spanish-39.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/mfront-flyer-en.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TFEL-3.1/VisualStudio-2015.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TFEL-3.1/OpenSolaris-2017.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TFEL-3.1/Cygwin.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TFEL-3.1/Alpine_Linux_3.6.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TFEL-3.1/MINGW-Cast3M2017.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TFEL-3.1/Haiku-51366.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TFEL-3.1/Ghost_BSD-10.3.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TFEL-3.1/Fedora_27_05_12_2017_11_37_17.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/img/TFEL-3.1/TrueOs-07-2017_05_12_2017_08_01_39.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/media/abaqus-explicit.mp4",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/media/SignoriniCompression.mp4",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/media/epx1.mp4",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/media/epx2.mp4",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/media/SignoriniStrip.mp4",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/media/CalculiXSheetForming-50.mp4",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/downloads/example-castem2014.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/downloads/patchs-CalculiX-2.12.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/downloads/patchs-Cast3M-2015.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/downloads/example-zset8.5.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/downloads/windows-install-scripts.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/web/downloads/patchs-Cast3M-2014.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/references/Kopp - 2008 - Efficient numerical diagonalization of hermitian 3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/references/matrixcookbook.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mtest/images/signatures_mtest.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img8.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img1.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img9old.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img11.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img16.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/UO2_YoungModulus_Fink1981.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img13.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/cyclique.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img18.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/code-barre.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/ImplicitDSL.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img19.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img15.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img7.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/Hayhurstiso.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img12.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img14.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/CourbeExpBurger.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/Ktgt2.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/Ktgt.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img4.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img10.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img20.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/Kel.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/Kcoh.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img17.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img9.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img6.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/hayhurst.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/images/tutorielch12-img5.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/mtest/castemellipticcreep-porosity.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/mtest/castemellipticcreep-pv.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/mtest/castemellipticcreep-porosity.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/mtest/castemellipticcreep-pv.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/mtest/castemellipticcreep-convergence.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/mtest/castemellipticcreep-convergence-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/tutorial/mfront/UO2_YoungModulus_Fink1981.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/abaqus/img/ShearLoading-IsotropicElasticity-nlgeom-sxz.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/abaqus/img/IsotropicViscoplasticity-TensileLoading-szz.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/abaqus/img/ShearLoading-IsotropicElasticity-sxz.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/abaqus/img/IsotropicHardeningPlasticity-VonMisesStress.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/abaqus/img/IsotropicHardeningPlasticity-Stress_vs_Strain.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/abaqus/img/SaintVenantKirchhoff-TensileLoading-szz.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/abaqus/img/ShearLoading-Plasticity-sxz.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/Images/hsnv125d.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/Images/polybz.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/Images/Polar_decomposition_of_F.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/Images/FueLPellet-DishingFilling2.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/Images/sirius8.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/mfront/Images/FueLPellet-DishingFilling1.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/league_gothic-webfont.woff",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/league_gothic-webfont.eot",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/league_gothic-webfont.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/league-gothic/league-gothic.eot",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/league-gothic/league-gothic.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/league-gothic/league-gothic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-italic.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-semibold.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-semibolditalic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-regular.eot",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-semibold.woff",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-semibold.eot",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-semibolditalic.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-italic.eot",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/lib/font/source-sans-pro/source-sans-pro-semibolditalic.eot",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/test/examples/assets/image2.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/html/reveal.js/test/examples/assets/image1.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/tutorielch12-img1.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/mfront.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/dplan_mazars_mfront.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/tutorielch12-img3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/traction-torsion-sxy-sxx.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/Mazars_poutre.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/172g.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/NbZrC_CreepBehaviour-mfront.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/tutorielch12-img18.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/hsnv125-sxx-exx.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/gpls-mfront-2.cxx",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/tutorielch12-img19.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/astk.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/traction-torsion-eps.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/Hayhurstiso.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/tutorielch12-img12.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/tutorielch12-img2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/CourbeExpBurger.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/Ktgt2.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/traction-torsion-nrad.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/Ktgt.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/traction-torsion-chargement.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/tutorielch12-img10.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/chaboche-cycles.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/adao-chaboche-ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/tutorielch12-img20.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/adao-chaboche-tout.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/norton-50s.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/hayhurst-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/Kel.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/Kcoh.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/norton.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/MazarsCourbe.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/172gv30pg.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/tutorielch12-img9.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/images/hayhurst.png",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/portable-behaviour/img/pipe.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/presentations/portable-behaviour/img/LogarithmicStrainPlasticity-ssna303.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/ptest/img/Creep.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/ptest/img/Creep-NortonLogarithmicStrain.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/ptest/img/ptest-QuadraticElements-sigzz.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/ptest/img/ptest-LinearElements-sigtt.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/ptest/img/Creep-NortonLogarithmicStrain-ps.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/ptest/img/mesh1D.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/ptest/img/ptest-QuadraticElements-sigtt.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/ptest/img/ptest-LinearElements-sigzz.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/ptest/img/tubeaxi.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/ptest/img/ptest-LinearElements-sigrr.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/ptest/img/ptest-QuadraticElements-sigrr.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-tfel-3.1.2-jr6ovvgfw4gurydpho6cqt36repfizg3/spack-src/docs/release-notes-2.0.3/images/cb.pdf"
    ],
    "total_files": 6141
}