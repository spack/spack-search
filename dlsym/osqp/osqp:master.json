{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-osqp-master-a3lqiwn7raw4wqnjs3jnyu3hxbugqwzs/spack-src/lin_sys/lib_handler.c": "#include \"lib_handler.h\"\n#include <ctype.h> // Needed for tolower functions\n\n#include \"constants.h\"\n#include \"util.h\"\n\nsoHandle_t lh_load_lib(const char *libName) {\n    soHandle_t h = OSQP_NULL;\n\n    if (!libName) {\n        #ifdef PRINTING\n        c_eprint(\"no library name given\");\n        #endif\n        return OSQP_NULL;\n    }\n\n#ifdef IS_WINDOWS\n    h = LoadLibrary (libName);\n    if (!h) {\n        #ifdef PRINTING\n        c_eprint(\"Windows error while loading dynamic library %s, error = %d\",\n                libName, (int)GetLastError());\n        #endif\n    }\n#else\n    h = dlopen (libName, RTLD_LAZY);\n    if (!h) {\n        #ifdef PRINTING\n        c_eprint(\"Error while loading dynamic library %s: %s\", libName, dlerror());\n        #endif\n    }\n#endif\n\n    return h;\n} /* lh_load_lib */\n\n\nc_int lh_unload_lib (soHandle_t h) {\n    c_int rc = 1;\n\n#ifdef IS_WINDOWS\n    rc = FreeLibrary (h);\n    rc = ! rc;\n#else\n    rc = dlclose (h);\n#endif\n\n    return rc;\n} /* LSL_unLoadLib */\n\n\n#ifdef IS_WINDOWS\ntypedef FARPROC symtype;\n#else\ntypedef void* symtype;\n#endif\n/** Loads a symbol from a dynamically linked library.\n * This function is not defined in the header to allow a workaround for the problem that dlsym returns an object instead of a function pointer.\n * However, Windows also needs special care.\n *\n * The method does six attempts to load the symbol. Next to its given name, it also tries variations of lower case and upper case form and with an extra underscore.\n * @param h Handle of dynamically linked library.\n * @param symName Name of the symbol to load.\n * @return A pointer to the symbol, or OSQP_NULL if not found.\n */\nsymtype lh_load_sym (soHandle_t h, const char *symName) {\n    symtype s;\n    const char *from;\n    char *to;\n    const char *tripSym;\n    char* err;\n    char lcbuf[257];\n    char ucbuf[257];\n    char ocbuf[257];\n    size_t symLen;\n    int trip;\n\n    s = OSQP_NULL;\n    err = OSQP_NULL;\n\n    /* search in this order:\n     *  1. original\n     *  2. lower_\n     *  3. upper_\n     *  4. original_\n     *  5. lower\n     *  6. upper\n     */\n\n    symLen = 0;\n    for (trip = 1;  trip <= 6;  trip++) {\n        switch (trip) {\n        case 1:                             /* original */\n            tripSym = symName;\n            break;\n        case 2:                             /* lower_ */\n            for (from = symName, to = lcbuf;  *from;  from++, to++) {\n                *to = tolower(*from);\n            }\n            symLen = from - symName;\n            *to++ = '_';\n            *to = '\\0';\n            tripSym = lcbuf;\n            break;\n        case 3:                             /* upper_ */\n            for (from = symName, to = ucbuf;  *from;  from++, to++) {\n                *to = toupper(*from);\n            }\n            *to++ = '_';\n            *to = '\\0';\n            tripSym = ucbuf;\n            break;\n        case 4:                             /* original_ */\n            c_strcpy(ocbuf, symName);\n            ocbuf[symLen] = '_';\n            ocbuf[symLen+1] = '\\0';\n            tripSym = ocbuf;\n            break;\n        case 5:                             /* lower */\n            lcbuf[symLen] = '\\0';\n            tripSym = lcbuf;\n            break;\n        case 6:                             /* upper */\n            ucbuf[symLen] = '\\0';\n            tripSym = ucbuf;\n            break;\n        default:\n            tripSym = symName;\n        } /* end switch */\n#ifdef IS_WINDOWS\n        s = GetProcAddress (h, tripSym);\n        if (s) {\n            return s;\n        } else {\n            #ifdef PRINTING\n            c_eprint(\"Cannot find symbol %s in dynamic library, error = %d\",\n                    symName, (int)GetLastError());\n            #endif\n        }\n#else\n        s = dlsym (h, tripSym);\n        err = dlerror();  /* we have only one chance; a successive call to dlerror() returns OSQP_NULL */\n        if (err) {\n            #ifdef PRINTING\n            c_eprint(\"Cannot find symbol %s in dynamic library, error = %s\",\n                    symName, err);\n            #endif\n        } else {\n            return s;\n        }\n#endif\n    } /* end loop over symbol name variations */\n\n    return OSQP_NULL;\n} /* lh_load_sym */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-osqp-master-a3lqiwn7raw4wqnjs3jnyu3hxbugqwzs/spack-src/.git/objects/pack/pack-c61d8ba3b92d22467a2240d357f2bccb5f0c4800.idx",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-master-a3lqiwn7raw4wqnjs3jnyu3hxbugqwzs/spack-src/.git/objects/pack/pack-c61d8ba3b92d22467a2240d357f2bccb5f0c4800.pack",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-master-a3lqiwn7raw4wqnjs3jnyu3hxbugqwzs/spack-src/.git/modules/lin_sys/direct/qdldl/qdldl_sources/objects/pack/pack-e8cc360625b8c93b2b6e6674c6bad5939bc3fe89.pack",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-master-a3lqiwn7raw4wqnjs3jnyu3hxbugqwzs/spack-src/.git/modules/lin_sys/direct/qdldl/qdldl_sources/objects/pack/pack-e8cc360625b8c93b2b6e6674c6bad5939bc3fe89.idx",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-master-a3lqiwn7raw4wqnjs3jnyu3hxbugqwzs/spack-src/docs/_static/img/logo.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-master-a3lqiwn7raw4wqnjs3jnyu3hxbugqwzs/spack-src/docs/_static/img/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-osqp-master-a3lqiwn7raw4wqnjs3jnyu3hxbugqwzs/spack-src/docs/_static/img/favicon.ico"
    ],
    "total_files": 240
}