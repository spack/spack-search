{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/track/heaptrack_preload.cpp": "/*\n * Copyright 2014-2017 Milian Wolff <mail@milianw.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"libheaptrack.h\"\n#include \"util/config.h\"\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <dlfcn.h>\n\n#include <atomic>\n#include <type_traits>\n\nusing namespace std;\n\n#if defined(_ISOC11_SOURCE)\n#define HAVE_ALIGNED_ALLOC 1\n#else\n#define HAVE_ALIGNED_ALLOC 0\n#endif\n\nextern \"C\" {\n__attribute__((weak)) void __libc_freeres();\n}\nnamespace __gnu_cxx {\n__attribute__((weak)) extern void __freeres();\n}\n\nnamespace {\n\nnamespace hooks {\n\ntemplate <typename Signature, typename Base>\nstruct hook\n{\n    Signature original = nullptr;\n\n    void init() noexcept\n    {\n        auto ret = dlsym(RTLD_NEXT, Base::identifier);\n        if (!ret) {\n            fprintf(stderr, \"Could not find original function %s\\n\", Base::identifier);\n            abort();\n        }\n        original = reinterpret_cast<Signature>(ret);\n    }\n\n    template <typename... Args>\n    auto operator()(Args... args) const noexcept -> decltype(original(args...))\n    {\n        return original(args...);\n    }\n\n    explicit operator bool() const noexcept\n    {\n        return original;\n    }\n};\n\n#define HOOK(name)                                                                                                     \\\n    struct name##_t : public hook<decltype(&::name), name##_t>                                                         \\\n    {                                                                                                                  \\\n        static constexpr const char* identifier = #name;                                                               \\\n    } name\n\nHOOK(malloc);\nHOOK(free);\nHOOK(calloc);\n#if HAVE_CFREE\nHOOK(cfree);\n#endif\nHOOK(realloc);\nHOOK(posix_memalign);\nHOOK(valloc);\n#if HAVE_ALIGNED_ALLOC\nHOOK(aligned_alloc);\n#endif\nHOOK(dlopen);\nHOOK(dlclose);\n\n/**\n * Dummy implementation, since the call to dlsym from findReal triggers a call\n * to calloc.\n *\n * This is only called at startup and will eventually be replaced by the\n * \"proper\" calloc implementation.\n */\nvoid* dummy_calloc(size_t num, size_t size) noexcept\n{\n    const size_t MAX_SIZE = 1024;\n    static char* buf[MAX_SIZE];\n    static size_t offset = 0;\n    if (!offset) {\n        memset(buf, 0, MAX_SIZE);\n    }\n    size_t oldOffset = offset;\n    offset += num * size;\n    if (offset >= MAX_SIZE) {\n        fprintf(stderr,\n                \"failed to initialize, dummy calloc buf size exhausted: \"\n                \"%zu requested, %zu available\\n\",\n                offset, MAX_SIZE);\n        abort();\n    }\n    return buf + oldOffset;\n}\n\nvoid init()\n{\n    atexit([]() {\n        // free internal libstdc++ resources\n        // see also Valgrind's `--run-cxx-freeres` option\n        if (&__gnu_cxx::__freeres) {\n            __gnu_cxx::__freeres();\n        }\n        // free internal libc resources, cf: https://bugs.kde.org/show_bug.cgi?id=378765\n        // see also Valgrind's `--run-libc-freeres` option\n        if (&__libc_freeres) {\n            __libc_freeres();\n        }\n    });\n    heaptrack_init(getenv(\"DUMP_HEAPTRACK_OUTPUT\"),\n                   [] {\n                       hooks::calloc.original = &dummy_calloc;\n                       hooks::calloc.init();\n                       hooks::dlopen.init();\n                       hooks::dlclose.init();\n                       hooks::malloc.init();\n                       hooks::free.init();\n                       hooks::calloc.init();\n#if HAVE_CFREE\n                       hooks::cfree.init();\n#endif\n                       hooks::realloc.init();\n                       hooks::posix_memalign.init();\n                       hooks::valloc.init();\n#if HAVE_ALIGNED_ALLOC\n                       hooks::aligned_alloc.init();\n#endif\n\n                       // cleanup environment to prevent tracing of child apps\n                       unsetenv(\"LD_PRELOAD\");\n                       unsetenv(\"DUMP_HEAPTRACK_OUTPUT\");\n                   },\n                   nullptr, nullptr);\n}\n}\n}\n\nextern \"C\" {\n\n/// TODO: memalign, pvalloc, ...?\n\nvoid* malloc(size_t size) noexcept\n{\n    if (!hooks::malloc) {\n        hooks::init();\n    }\n\n    void* ptr = hooks::malloc(size);\n    heaptrack_malloc(ptr, size);\n    return ptr;\n}\n\nvoid free(void* ptr) noexcept\n{\n    if (!hooks::free) {\n        hooks::init();\n    }\n\n    // call handler before handing over the real free implementation\n    // to ensure the ptr is not reused in-between and thus the output\n    // stays consistent\n    heaptrack_free(ptr);\n\n    hooks::free(ptr);\n}\n\nvoid* realloc(void* ptr, size_t size) noexcept\n{\n    if (!hooks::realloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::realloc(ptr, size);\n\n    if (ret) {\n        heaptrack_realloc(ptr, size, ret);\n    }\n\n    return ret;\n}\n\nvoid* calloc(size_t num, size_t size) noexcept\n{\n    if (!hooks::calloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::calloc(num, size);\n\n    if (ret) {\n        heaptrack_malloc(ret, num * size);\n    }\n\n    return ret;\n}\n\n#if HAVE_CFREE\nvoid cfree(void* ptr) noexcept\n{\n    if (!hooks::cfree) {\n        hooks::init();\n    }\n\n    // call handler before handing over the real free implementation\n    // to ensure the ptr is not reused in-between and thus the output\n    // stays consistent\n    if (ptr) {\n        heaptrack_free(ptr);\n    }\n\n    hooks::cfree(ptr);\n}\n#endif\n\nint posix_memalign(void** memptr, size_t alignment, size_t size) noexcept\n{\n    if (!hooks::posix_memalign) {\n        hooks::init();\n    }\n\n    int ret = hooks::posix_memalign(memptr, alignment, size);\n\n    if (!ret) {\n        heaptrack_malloc(*memptr, size);\n    }\n\n    return ret;\n}\n\n#if HAVE_ALIGNED_ALLOC\nvoid* aligned_alloc(size_t alignment, size_t size) noexcept\n{\n    if (!hooks::aligned_alloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::aligned_alloc(alignment, size);\n\n    if (ret) {\n        heaptrack_malloc(ret, size);\n    }\n\n    return ret;\n}\n#endif\n\nvoid* valloc(size_t size) noexcept\n{\n    if (!hooks::valloc) {\n        hooks::init();\n    }\n\n    void* ret = hooks::valloc(size);\n\n    if (ret) {\n        heaptrack_malloc(ret, size);\n    }\n\n    return ret;\n}\n\nvoid* dlopen(const char* filename, int flag) noexcept\n{\n    if (!hooks::dlopen) {\n        hooks::init();\n    }\n\n    void* ret = hooks::dlopen(filename, flag);\n\n    if (ret) {\n        heaptrack_invalidate_module_cache();\n    }\n\n    return ret;\n}\n\nint dlclose(void* handle) noexcept\n{\n    if (!hooks::dlclose) {\n        hooks::init();\n    }\n\n    int ret = hooks::dlclose(handle);\n\n    if (!ret) {\n        heaptrack_invalidate_module_cache();\n    }\n\n    return ret;\n}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/track/heaptrack_api.h": "/*\n * Copyright 2016-2017 Milian Wolff <mail@milianw.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n/**\n * @file heaptrack_api.h\n *\n * This file defines a public API for heaptrack to be used in applications and\n * libraries that implement custom allocators that do not use malloc internally.\n *\n * It should be enough to include this header in your code and then add calls\n * to @c heaptrack_report_alloc, @c heaptrack_report_realloc and\n * @c heaptrack_report_free to your code. By default, nothing will happen.\n * Once you run your code within heaptrack though, this information will be\n * picked up and included in the heap profile data.\n *\n * Note: If you use static linking, or have a custom allocator in your main\n * executable, then you must define HEAPTRACK_API_DLSYM before including\n * this header and link against libdl to make this work properly. The other,\n * more common, case of pool allocators in shared libraries will work with the\n * default implementation that relies on weak symbols and the dynamic linker\n * on resolving the symbols for us directly.\n */\n\n#ifndef HEAPTRACK_API_H\n#define HEAPTRACK_API_H\n\n#include <stdlib.h>\n\n#ifndef HEAPTRACK_API_DLSYM\n\n/**\n * By default we rely on weak symbols that get resolved by the dynamic linker.\n * The weak symbols defined here are usually zero, but become non-zero when\n * we run the application with libheaptrack_preload.so loaded in.\n *\n * Note that this does not support run-time attaching yet.\n * Also note that this won't work inside your main executable, nor when you use\n * static linking. In these cases, the dlsym code below should be used instead.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n__attribute__((weak)) void heaptrack_malloc(void* ptr, size_t size);\n__attribute__((weak)) void heaptrack_realloc(void* ptr_in, size_t size, void* ptr_out);\n__attribute__((weak)) void heaptrack_free(void* ptr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#define heaptrack_report_alloc(ptr, size)                                                                              \\\n    if (heaptrack_malloc)                                                                                              \\\n    heaptrack_malloc(ptr, size)\n\n#define heaptrack_report_realloc(ptr_in, size, ptr_out)                                                                \\\n    if (heaptrack_realloc)                                                                                             \\\n    heaptrack_realloc(ptr_in, size, ptr_out)\n\n#define heaptrack_report_free(ptr)                                                                                     \\\n    if (heaptrack_free)                                                                                                \\\n    heaptrack_free(ptr)\n\n#else // HEAPTRACK_API_DLSYM\n\n/**\n * Alternatively, we rely on dlsym to dynamically resolve the symbol to the\n * heaptrack API functions at runtime. This works reliably, also when using\n * static linking or when calling these functions from within your main\n * executable. The caveat is that you need to link to libdl dynamically.\n *\n * @code\n *\n *   gcc -DHEAPTRACK_API_DLSYM=1 -ldl ...\n * @endcode\n */\n\n#ifndef __USE_GNU\n// required for RTLD_NEXT\n#define __USE_GNU\n#endif\n\n#include <dlfcn.h>\n\nstruct heaptrack_api_t\n{\n    void (*malloc)(void*, size_t);\n    void (*free)(void*);\n    void (*realloc)(void*, size_t, void*);\n};\nstatic struct heaptrack_api_t heaptrack_api = {0, 0, 0};\n\nvoid heaptrack_init_api()\n{\n    static int initialized = 0;\n    if (!initialized) {\n        void* sym = dlsym(RTLD_NEXT, \"heaptrack_malloc\");\n        if (sym)\n            heaptrack_api.malloc = (void (*)(void*, size_t))sym;\n\n        sym = dlsym(RTLD_NEXT, \"heaptrack_realloc\");\n        if (sym)\n            heaptrack_api.realloc = (void (*)(void*, size_t, void*))sym;\n\n        sym = dlsym(RTLD_NEXT, \"heaptrack_free\");\n        if (sym)\n            heaptrack_api.free = (void (*)(void*))sym;\n\n        initialized = 1;\n    }\n}\n\n#define heaptrack_report_alloc(ptr, size)                                                                              \\\n    do {                                                                                                               \\\n        heaptrack_init_api();                                                                                          \\\n        if (heaptrack_api.malloc)                                                                                      \\\n            heaptrack_api.malloc(ptr, size);                                                                           \\\n    } while (0)\n\n#define heaptrack_report_realloc(ptr_in, size, ptr_out)                                                                \\\n    do {                                                                                                               \\\n        heaptrack_init_api();                                                                                          \\\n        if (heaptrack_api.realloc)                                                                                     \\\n            heaptrack_api.realloc(ptr_in, size, ptr_out);                                                              \\\n    } while (0)\n\n#define heaptrack_report_free(ptr)                                                                                     \\\n    do {                                                                                                               \\\n        heaptrack_init_api();                                                                                          \\\n        if (heaptrack_api.free)                                                                                        \\\n            heaptrack_api.free(ptr);                                                                                   \\\n    } while (0)\n\n#endif // HEAPTRACK_API_DLSYM\n\n/**\n * Optionally, you can let heaptrack mimick the Valgrind pool-allocator API.\n *\n * This won't work nicely when you want to enable both, Valgrind and heaptrack.\n * Otherwise, it's an easy way to make your code ready for both tools.\n */\n#ifdef HEAPTRACK_DEFINE_VALGRIND_MACROS\n\n#define VALGRIND_DISABLE_ERROR_REPORTING\n#define VALGRIND_ENABLE_ERROR_REPORTING\n#define VALGRIND_CREATE_MEMPOOL(...)\n#define VALGRIND_DESTROY_MEMPOOL(...)\n#define VALGRIND_MAKE_MEM_NOACCESS(...)\n\n#define VALGRIND_MEMPOOL_ALLOC(pool, ptr, size) heaptrack_report_alloc(ptr, size)\n#define VALGRIND_MEMPOOL_FREE(pool, ptr) heaptrack_report_free(ptr)\n\n#endif\n\n#endif // HEAPTRACK_API_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/tests/auto/tst_inject.cpp": "/*\n * Copyright 2018 Milian Wolff <mail@milianw.de>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"3rdparty/catch.hpp\"\n\n#include \"tempfile.h\"\n#include \"tst_config.h\"\n\n#include <dlfcn.h>\n\n#include <iostream>\n\nstatic_assert(RTLD_NOW == 0x2, \"RTLD_NOW needs to equal 0x2\");\n\nusing heaptrack_inject_t = void (*)(const char*);\nusing heaptrack_stop_t = void (*)();\n\nnamespace {\ntemplate <typename T>\nT resolveSymbol(void* handle, const char* symbol)\n{\n    return reinterpret_cast<T>(dlsym(handle, symbol));\n}\n\nheaptrack_inject_t resolveHeaptrackInject(void* handle)\n{\n    return resolveSymbol<heaptrack_inject_t>(handle, \"heaptrack_inject\");\n}\n\nheaptrack_stop_t resolveHeaptrackStop(void* handle)\n{\n    return resolveSymbol<heaptrack_stop_t>(handle, \"heaptrack_stop\");\n}\n\ntemplate <typename Load, typename Unload>\nvoid runInjectTest(Load load, Unload unload)\n{\n    REQUIRE(!resolveHeaptrackInject(RTLD_DEFAULT));\n    REQUIRE(!resolveHeaptrackStop(RTLD_DEFAULT));\n\n    auto* handle = load();\n    REQUIRE(handle);\n\n    auto* heaptrack_inject = resolveHeaptrackInject(handle);\n    REQUIRE(heaptrack_inject);\n\n    auto* heaptrack_stop = resolveHeaptrackStop(handle);\n    REQUIRE(heaptrack_stop);\n\n    TempFile file;\n\n    heaptrack_inject(file.fileName.c_str());\n\n    auto* p = malloc(100);\n    free(p);\n\n    heaptrack_stop();\n\n    unload(handle);\n\n    REQUIRE(!resolveHeaptrackInject(RTLD_DEFAULT));\n    REQUIRE(!resolveHeaptrackStop(RTLD_DEFAULT));\n\n    const auto contents = file.readContents();\n    REQUIRE(!contents.empty());\n    REQUIRE(contents.find(\"\\nA\\n\") != std::string::npos);\n    REQUIRE(contents.find(\"\\n+\") != std::string::npos);\n    REQUIRE(contents.find(\"\\n-\") != std::string::npos);\n}\n}\n\nTEST_CASE (\"inject via dlopen\", \"[inject]\") {\n    runInjectTest(\n        []() -> void* {\n            dlerror(); // clear error\n            auto* handle = dlopen(HEAPTRACK_LIB_INJECT_SO, RTLD_NOW);\n            if (!handle) {\n                std::cerr << \"DLOPEN FAILED: \" << dlerror() << std::endl;\n            }\n            return handle;\n        },\n        [](void* handle) { dlclose(handle); });\n}\n\nextern \"C\" {\n__attribute__((weak)) void* __libc_dlopen_mode(const char* filename, int flag);\n__attribute__((weak)) int __libc_dlclose(void* handle);\n}\n\nTEST_CASE (\"inject via libc\", \"[inject]\") {\n    REQUIRE(__libc_dlopen_mode);\n    runInjectTest([]() { return __libc_dlopen_mode(HEAPTRACK_LIB_INJECT_SO, 0x80000000 | 0x002); },\n                  [](void* handle) { __libc_dlclose(handle); });\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/16-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/64-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/32-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/128-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/48-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/src/analyze/gui/22-apps-heaptrack.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/screenshots/gui_flamegraph.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/screenshots/gui_allocations_chart.png",
        "/tmp/vanessa/spack-stage/spack-stage-heaptrack-1.1.0-55hik3opehvme3dhba26tn7bdk4kkts2/spack-src/screenshots/gui_summary.png"
    ],
    "total_files": 147
}