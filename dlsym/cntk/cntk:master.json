{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Source/Common/File.cpp": "//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\n\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS // \"secure\" CRT not available on all platforms  --add this at the top of all CPP files that give \"function or variable may be unsafe\" warnings\n#endif\n#define _CRT_NONSTDC_NO_DEPRECATE // make VS accept POSIX functions without _\n\n#include \"Basics.h\"\n#define FORMAT_SPECIALIZE // to get the specialized version of the format routines\n#include \"File.h\"\n#include \"Config.h\"\n#include <string>\n#include <stdint.h>\n#include <locale>\n#include <unordered_map>\n#ifdef _WIN32\n#define NOMINMAX\n#include \"Windows.h\"\n#ifndef CNTK_UWP\n#include <VersionHelpers.h>\n#endif\n#include <Shlwapi.h>\n#pragma comment(lib, \"Shlwapi.lib\")\n#endif\n#ifdef __unix__\n#include <unistd.h>\n#include <linux/limits.h> // for PATH_MAX\n#endif\n\n#define PCLOSE_ERROR -1\n#define WRITE_BUFFER_SIZE (1024 * 1024)\n\n#include <boost/algorithm/string.hpp>\n#include \"half.hpp\"\n\nnamespace Microsoft { namespace MSR { namespace CNTK {\n\n// File creation\n// filename - the path\n// fileOptions - options to open the file\nFile::File(const std::wstring& filename, int fileOptions)\n{\n    Init(filename.c_str(), fileOptions);\n}\n\nFile::File(const std::string& filename, int fileOptions)\n{\n    // this converts from string to wstring, and then to wchar_t*\n    Init(Microsoft::MSR::CNTK::ToFixedWStringFromMultiByte(filename).c_str(), fileOptions);\n}\n\nFile::File(const wchar_t* filename, int fileOptions)\n{\n    Init(filename, fileOptions);\n}\n\ntemplate<class String>\nstatic bool IsNonFilePath(const String& filename)\n{\n    return\n        filename.front() == '|' ||                    // \"| command\": output pipe\n        filename.back()  == '|' ||                    // \"command |\": input pipe\n        (filename.size() == 1 && filename[0] == '-'); // \"-\": stdin/stdout\n}\n\n// test if a file exists\n// If the pathname is a pipe, it is considered to exist.\ntemplate<class String>\n/*static*/ bool File::Exists(const String& filename)\n{\n    return IsNonFilePath(filename) || fexists(filename);\n}\n\ntemplate /*static*/ bool File::Exists<string> (const string&  filename);\ntemplate /*static*/ bool File::Exists<wstring>(const wstring& filename);\n\ntemplate<class String>\n/*static*/ void File::MakeIntermediateDirs(const String& filename)\n{\n    if (!IsNonFilePath(filename))\n        msra::files::make_intermediate_dirs(filename);\n}\n\n//template /*static*/ void File::MakeIntermediateDirs<string> (const string&  filename); // implement this if needed\ntemplate /*static*/ void File::MakeIntermediateDirs<wstring>(const wstring& filename);\n\n// all constructors call this\nvoid File::Init(const wchar_t* filename, int fileOptions)\n{\n    m_filename = filename;\n    m_options = fileOptions;\n    if (m_filename.empty())\n        RuntimeError(\"File: filename is empty\");\n    const auto outputPipe = (m_filename.front() == '|');\n    const auto inputPipe  = (m_filename.back()  == '|');\n    // translate the options string into a string for fopen()\n    const auto reading = !!(fileOptions & fileOptionsRead);\n    const auto writing = !!(fileOptions & fileOptionsWrite);\n    const auto appending = !!(fileOptions & fileOptionsAppend);\n    if (!reading && !writing && !appending)\n        RuntimeError(\"File: either fileOptionsRead or fileOptionsWrite or fileOptionsAppend must be specified\");\n    // convert fileOptions to fopen()'s mode string\n    wstring options = reading ? L\"r\" : L\"\";\n    if (writing || appending)\n    {\n        // if we already are reading the file, change to read/write or append\n        options.clear();\n        options.append(writing ? L\"w\" : L\"a\");\n        if (!outputPipe && m_filename != L\"-\")\n        {\n            options.append(L\"+\");\n            msra::files::make_intermediate_dirs(m_filename.c_str()); // writing to regular file -> also create the intermediate directories as a convenience\n        }\n    }\n    if (fileOptions & fileOptionsBinary)\n        options += L\"b\";\n    else\n        options += L\"t\";\n    // add sequential flag to allocate big read buffer\n    if (fileOptions & fileOptionsSequential)\n        options += L\"S\";\n    // now open the file\n    // Special path syntax understood here:\n    //  - \"-\" refers to stdin or stdout\n    //  - \"|cmd\" writes to a pipe\n    //  - \"cmd|\" reads from a pipe\n    m_pcloseNeeded = false;\n    m_seekable = false;\n    if (m_filename == L\"-\") // stdin/stdout\n    {\n        if (writing && reading)\n            RuntimeError(\"File: cannot specify fileOptionsRead and fileOptionsWrite at once with path '-'\");\n        m_file = writing ? stdout : stdin;\n    }\n    else if (outputPipe || inputPipe) // pipe syntax\n    {\n#ifdef CNTK_UWP\n        RuntimeError(\"File: pipes are not supported in UWP\");\n#else\n        if (inputPipe && outputPipe)\n            RuntimeError(\"File: pipes cannot specify fileOptionsRead and fileOptionsWrite at once\");\n        if (inputPipe != reading)\n            RuntimeError(\"File: pipes must use consistent fileOptionsRead/fileOptionsWrite\");\n        const auto command = inputPipe ? m_filename.substr(0, m_filename.size() - 1) : m_filename.substr(1);\n        m_file = _wpopen(command.c_str(), options.c_str());\n        if (!m_file)\n            RuntimeError(\"File: error exexuting pipe command '%S': %s\", command.c_str(), strerror(errno));\n        m_pcloseNeeded = true;\n#endif\n    }\n    else\n        attempt([=]() // regular file: use a retry loop\n                {\n                    m_file = fopenOrDie(filename, options.c_str());\n                    m_seekable = true;\n                });\n}\n\n// determine the directory for a given pathname\n// (wstring only for now; feel free to make this a template if needed)\n/*static*/ wstring File::DirectoryPathOf(wstring path)\n{\n#ifdef _WIN32\n    // Win32 accepts forward slashes, but it seems that PathRemoveFileSpec() does not\n    // TODO:\n    // \"PathCchCanonicalize does the / to \\ conversion as a part of the canonicalization, it's\n    // probably a good idea to do that anyway since I suspect that the '..' characters might\n    // confuse the other PathCch functions\" [Larry Osterman]\n    // \"Consider GetFullPathName both for canonicalization and last element finding.\" [Jay Krell]\n    path = msra::strfun::ReplaceAll<wstring>(path, L\"/\", L\"\\\\\");\n\n    HRESULT hr;\n#ifdef CNTK_UWP // UWP-TODO: find a replacement for PathRemoveFileSpec\n    RuntimeError(\"Not supported for UWP\");\n#else\n    if (IsWindows8OrGreater()) // PathCchRemoveFileSpec() only available on Windows 8+\n    {\n        typedef HRESULT(*PathCchRemoveFileSpecProc)(_Inout_updates_(_Inexpressible_(cchPath)) PWSTR, _In_ size_t);\n        HINSTANCE hinstLib = LoadLibrary(TEXT(\"api-ms-win-core-path-l1-1-0.dll\"));\n        if (hinstLib == nullptr)\n            RuntimeError(\"DirectoryPathOf: LoadLibrary() unexpectedly failed.\");\n        PathCchRemoveFileSpecProc PathCchRemoveFileSpec = reinterpret_cast<PathCchRemoveFileSpecProc>(GetProcAddress(hinstLib, \"PathCchRemoveFileSpec\"));\n        if (!PathCchRemoveFileSpec)\n            RuntimeError(\"DirectoryPathOf: GetProcAddress() unexpectedly failed.\");\n\n        // this is the actual function call we care about\n        hr = PathCchRemoveFileSpec(&path[0], path.size());\n\n        FreeLibrary(hinstLib);\n    }\n    else // on Windows 7-, use older PathRemoveFileSpec() instead\n        hr = PathRemoveFileSpec(&path[0]) ? S_OK : S_FALSE;\n#endif\n\n    if (hr == S_OK) // done\n        path.resize(wcslen(&path[0]));\n    else if (hr == S_FALSE) // nothing to remove: use .\n        path = L\".\";\n    else\n        RuntimeError(\"DirectoryPathOf: Path(Cch)RemoveFileSpec() unexpectedly failed with 0x%08x.\", (unsigned int)hr);\n#else\n    auto pos = path.find_last_of(L\"/\");\n    if (pos != path.npos)\n        path.erase(pos);\n    else // if no directory path at all, use current directory\n        return L\".\";\n#endif\n    return path;\n}\n\n// determine the file name for a given pathname\n// (wstring only for now; feel free to make this a template if needed)\n/*static*/ wstring File::FileNameOf(wstring path)\n{\n#ifdef WIN32\n    static const wstring delim = L\"\\\\:/\";\n#else\n    static const wstring delim = L\"/\";\n#endif\n    auto pos = path.find_last_of(delim);\n    if (pos != path.npos)\n        return path.substr(pos + 1);\n    else // no directory path\n        return path;\n}\n\n// get path of current executable\n/*static*/ wstring File::GetExecutablePath()\n{\n#ifdef WIN32\n    wchar_t path[33000];\n    if (GetModuleFileNameW(NULL, path, _countof(path)) == 0)\n        LogicError(\"GetExecutablePath: GetModuleFileNameW() unexpectedly failed.\");\n    return path;\n#else\n    // from http://stackoverflow.com/questions/4025370/can-an-executable-discover-its-own-path-linux\n    pid_t pid = getpid();\n    char path[PATH_MAX + 1] = { 0 };\n    sprintf(path, \"/proc/%d/exe\", pid);\n    char dest[PATH_MAX + 1] = { 0 };\n    if (readlink(path, dest, PATH_MAX) == -1)\n        RuntimeError(\"GetExecutableDirectory: readlink() call failed.\");\n    else\n        return Microsoft::MSR::CNTK::ToFixedWStringFromMultiByte(dest);\n#endif\n}\n\n// skip to given delimiter character\nvoid File::SkipToDelimiter(int delim)\n{\n    int ch = 0;\n\n    while (ch != delim)\n    {\n        ch = fgetc(m_file);\n        if (feof(m_file))\n        {\n            printf(\"Unexpected end of file\\n\");\n            LogicError(\"Unexpected end of file\\n\");\n        }\n    }\n}\n\nbool File::IsTextBased()\n{\n    return !!(m_options & fileOptionsText);\n}\n\n// File Destructor\n// closes the file\n// Note: this does not check for errors when the File corresponds to pipe stream. In this case, use Flush() before closing a file you are writing.\nFile::~File(void)\n{\n    int rc = 0;\n    if (m_pcloseNeeded)\n    {\n#ifdef CNTK_UWP\n        assert(false); // cannot happen\n#else\n        rc = _pclose(m_file);\n        if ((rc == PCLOSE_ERROR) && !std::uncaught_exception())\n        {\n            RuntimeError(\"File: failed to close file at %S\", m_filename.c_str());\n        }\n#endif\n    }\n    else if (m_file != stdin && m_file != stdout && m_file != stderr)\n    {\n        rc = fclose(m_file);\n        if ((rc != FCLOSE_SUCCESS) && !std::uncaught_exception())\n        {\n            RuntimeError(\"File: failed to close file at %S\", m_filename.c_str());\n        }\n    }\n}\n\nvoid File::Flush()\n{\n    fflushOrDie(m_file);\n}\n\n// read a line\n// End of line is denoted by one of these, i.e. we don't support the old Mac OS convention of CR\n//  - LF\n//  - CR+LF\n//  - EOF\nstatic bool fgetc(char& c, FILE * f) { int ci = getc(f); c = (char) ci; return ci != EOF; }\n\nstatic inline bool BeginsWithUnicodeBOM(const char * s)\n{\n    return ((unsigned char)s[0] == 0xEF && (unsigned char)s[1] == 0xBB && (unsigned char)s[2] == 0xBF);\n}\n\n// read a 8-bit string until newline is hit\ntemplate<class STRING>\nstatic void fgets(STRING & s, FILE * f)\n{\n    s.resize(0);\n    char c;\n    while (fgetc(c, f))\n    {\n        if (c == '\\n' || c == '\\r')\n        {\n            if (c == '\\r' && (!fgetc(c, f) || c != '\\n'))\n                RuntimeError(\"fgets: malformed text file, CR without LF\");\n            break;\n        }\n        s.push_back(c);\n        // strip Unicode BOM\n        // We strip it from any string, not just at the start.\n        // This allows to UNIX-'cat' multiple UTF-8 files with BOMs.\n        // Since the BOM is otherwise invalid within a file, this is well-defined and upwards compatible.\n        if (s.size() == 3 && BeginsWithUnicodeBOM(s.c_str()))\n            s.clear();\n    }\n}\n\n// GetLine - get a line from the file\n// str - string\nvoid File::GetLine(string& str)\n{\n    fgets(str, m_file);\n}\n\nstatic void PushBackString(vector<string>& lines,  const string& s) { lines.push_back(s); }\nstatic void PushBackString(vector<wstring>& lines, string& s)\n{\n    lines.push_back(Microsoft::MSR::CNTK::ToFixedWStringFromMultiByte(s));\n}\n\n// GetLines - get all lines from a file\ntemplate <typename STRING>\nstatic void FileGetLines(File& file, /*out*/ std::vector<STRING>& lines)\n{\n    lines.clear();\n    string line;\n    while (!file.IsEOF())\n    {\n        file.GetLine(line);\n        PushBackString(lines, line);\n    }\n}\nvoid File::GetLines(std::vector<std::wstring>& lines)\n{\n    FileGetLines(*this, lines);\n};\nvoid File::GetLines(std::vector<std::string>& lines)\n{\n    FileGetLines(*this, lines);\n}\n\n// Put a zero/space terminated wstring into a file\n// val - value to write to the file\nFile& File::operator<<(const std::wstring& val)\n{\n    WriteString(val.c_str());\n    return *this;\n}\n\n// Put a zero/space terminated string into a file\n// val - value to write to the file\nFile& File::operator<<(const std::string& val)\n{\n    WriteString(val.c_str());\n    return *this;\n}\n\n// Put a marker in the file, the marker depends on the file type\n// marker - marker to place in the file\nFile& File::operator<<(FileMarker marker)\n{\n    File& file = *this;\n    switch (marker)\n    {\n    case fileMarkerBeginFile: // beginning of file marker\n        // TODO: why not write a BOM?\n        break;\n    case fileMarkerEndFile: // end of file marker\n        // use ^Z for end of file for text files\n        // TODO: What??\n        if (m_options & fileOptionsText)\n            file << char(26);\n        break;\n    case fileMarkerBeginList: // Beginning of list marker\n        // no marker written for either\n        break;\n    case fileMarkerListSeparator: // separate elements of a list\n        // do nothing for now, built in space deliminter for all types (before type)\n        // future: make this customizable, so you can specify a separator (i.e. ',')\n        break;\n    case fileMarkerEndList: // end of line/list marker\n        if (m_options & fileOptionsText)\n            file.WriteString(\"\\r\\n\");\n        break;\n    case fileMarkerBeginSection: // beginning of section\n    case fileMarkerEndSection:   // end of section\n        assert(false);           // sections should use a string modifier\n        break;\n    }\n    return file;\n}\n\n// PutMarker for beginning of list support (lists with a count)\n// count - [in] the number of elements in the list\nFile& File::PutMarker(FileMarker marker, size_t count)\n{\n    assert(marker == fileMarkerBeginList);\n    marker; // only beginning of list supported for count  markers\n    *this << count;\n    return *this;\n}\n\n// PutMarker for section beginning and ending tags\n// section - [in]name of section\nFile& File::PutMarker(FileMarker marker, const std::string& section)\n{\n    File& file = *this;\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    file << section;\n    return file;\n}\n\n// PutMarker for section beginning and ending tags\n// section - [in]name of section\nFile& File::PutMarker(FileMarker marker, const std::wstring& section)\n{\n    File& file = *this;\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    file << section;\n    return file;\n}\n\n// Get a zero terminated wstring from a file\n// val - value to read from the file\nFile& File::operator>>(std::wstring& val)\n{\n    if (IsTextBased())\n        val = fgetwtoken(m_file);\n    else\n        val = fgetwstring(m_file);\n    return *this;\n}\n\n// Get a zero terminated string from a file\n// val - value to read from the file\nFile& File::operator>>(std::string& val)\n{\n    if (IsTextBased())\n        val = fgettoken(m_file);\n    else\n        val = fgetstring(m_file);\n    return *this;\n}\n\n// ReadChars - read a specified number of characters, and reset read pointer if requested\n// val - [in,out] return value will be returned here\n// cnt - number of characters to read\n// reset - reset the read pointer\nvoid File::ReadChars(std::string& val, size_t cnt, bool reset)\n{\n    size_t pos = 0; // (initialize to keep compiler happy)\n    if (reset)\n        pos = GetPosition();\n    val.resize(cnt);\n    char* str = const_cast<char*>(val.c_str());\n    for (int i = 0; i < cnt; ++i)\n        *this >> str[i];\n    if (reset)\n        SetPosition(pos);\n}\n\n// ReadChars - read a specified number of characters, and reset read pointer if requested\n// val - [in,out] return value will be returned here\n// cnt - number of characters to read\n// reset - reset the read pointer\nvoid File::ReadChars(std::wstring& val, size_t cnt, bool reset)\n{\n    size_t pos = 0; // (initialize to keep compiler happy)\n    if (reset)\n        pos = GetPosition();\n    val.resize(cnt);\n    wchar_t* str = const_cast<wchar_t*>(val.c_str());\n    for (int i = 0; i < cnt; ++i)\n        *this >> str[i];\n    if (reset)\n        SetPosition(pos);\n}\n\n// WriteString - outputs a string into the file\n// str - the string to output\n// size - size of the string to output, if zero null terminated\nvoid File::WriteString(const char* str, int size)\n{\n    if (size > 0)\n    {\n        fwprintf(m_file, L\" %.*hs\", size, str);\n    }\n    else\n    {\n        if (IsTextBased())\n            fwprintf(m_file, L\" %hs\", str);\n        else\n            fputstring(m_file, str);\n    }\n}\n\n// ReadString - reads a string into the file\n// str - the string buffer to read the string into\n// size - size of the string buffer incl. zero terminator (we fail if input is too long)\nvoid File::ReadString(char* str, int size)\n{\n    if (IsTextBased())\n    {\n        fgettoken(m_file, str, size);\n        if (BeginsWithUnicodeBOM(str))\n            for (; str[3]; str++)\n                str[0] = str[3];    // delete it from start of line\n    }\n    else\n        fgetstring(m_file, str, size);\n}\n\n// WriteString - outputs a string into the file\n//   if writing to text based file and spaces are embedded, writes quotes around string\n//   BUGBUG: This should be consistent between char and wchar_t versions\n// str - the string to output\n// size - size of the string to output, if zero null terminated\nvoid File::WriteString(const wchar_t* str, int size)\n{\n#ifdef EMBEDDED_SPACES\n    // start of implementation of embedded space support with quoting\n    // not complete, not sure if we need it\n    bool spacefound = false;\n    wchar_t quote = 0;\n    if (IsTextBased())\n    {\n        // search for embedded spaces and quotes\n        wstring searchString = L\" \\\"'~\";\n        const wchar_t* result = NULL;\n        while (result = wcspbrk(str, searchString.c_str()))\n        {\n            if (IsWhiteSpace(*result))\n                spacefound = true;\n            searchString.find(*result, 0);\n        }\n    }\n#endif\n    if (size > 0)\n    {\n        fwprintf(m_file, L\" %.*ls\", size, str);\n    }\n    else\n    {\n        if (IsTextBased())\n            fwprintf(m_file, L\" %ls\", str);\n        else\n            fputstring(m_file, str);\n    }\n}\n\n// ReadString - reads a string from the file\n// str - the string buffer to read the string into\n// size - size of the string string buffer\nvoid File::ReadString(wchar_t* str, int size)\n{\n    if (IsTextBased())\n        fgettoken(m_file, str, size);\n    else\n        fgetstring(m_file, str, size);\n}\n\n// IsUnicodeBOM - is the next characters the Unicode Byte Order Mark?\n// skip - skip the BOM mark if found (defaults to false)\n// returns - true if on a unicode BOM\nbool File::IsUnicodeBOM(bool skip)\n{\n    File& file = *this;\n    uint64_t pos = GetPosition(); // Note: This is where we will fail for non-seekable streams.\n    // if we aren't at the beginning of the file, it can't be the byte order mark\n    if (pos != 0)\n        return false;\n\n    // only exists for UNICODE files\n    bool found = false;\n    if (m_options & fileOptionsText)\n    {\n        char val[3] = { 0 };\n        for (size_t i = 0; i < _countof(val) && !file.IsEOF(); i++)\n            val[i] = (char) getc(m_file);\n        found = BeginsWithUnicodeBOM(val);\n    }\n    // restore pointer if no BOM or we aren't skipping it\n    if (!found || !skip)\n    {\n        SetPosition(pos);\n    }\n    return found;\n}\n\n//Size - return the size of the file\n// WARNING: calling this will reset the EOF marker, so do so with care\nsize_t File::Size()\n{\n    if (!CanSeek())\n        RuntimeError(\"File: attempted to get Size() on non-seekable stream\");\n    return filesize(m_file);\n}\n\n// IsEOF - if we have read past the end of the file\n// return - true if end of file has been found\nbool File::IsEOF()\n{\n    return !!feof(m_file);\n}\n\n// IsWhiteSpace - are the next characters whitespace (space, \\t, \\r, \\n, etc.)?\n// skip - skip the whitespace if found (defaults to false)\n// returns - true if whitespace found\n// TODO: This function actually consumes the white-space characters. Document that behavior.\nbool File::IsWhiteSpace(bool skip)\n{\n    bool spaceFound = false;\n    bool spaceCur = false;\n    int c;\n    do\n    {\n        c = fgetc(m_file);\n        if (c == EOF) // hit the end\n            return spaceFound;\n        spaceCur = !!isspace(c);\n        spaceFound = spaceFound || spaceCur;\n    } while (spaceCur && skip);\n    // put back the last character (EOF is ignored)\n    ungetc(c, m_file);\n\n    return spaceFound;\n}\n\n// EndOfLineOrEOF - are the next characters an end of line sequence ('\\r\\n') possibly preceeded by (space, \\t)? EOF detected too\n// skip - skip the end of line if found (defaults to false)\n// returns - true if end of line found, EOF if end of file found, or false if nothing found, in which case any leading space will have been stripped\nint File::EndOfLineOrEOF(bool skip)\n{\n    if (IsTextBased())\n        return fskipNewline(m_file, skip);\n    else\n        return false;\n}\n\n// Buffer write stream\nint File::Setvbuf()\n{\n    return setvbuf(this->m_file, NULL, _IOFBF, WRITE_BUFFER_SIZE);\n}\n\n// Get a marker from the file\n// some are ignored others are expecting characters\n// must use GetMarker methods for those that require parameters\nFile& File::operator>>(FileMarker marker)\n{\n    File& file = *this;\n\n    switch (marker)\n    {\n    case fileMarkerBeginFile: // beginning of file marker\n        // check for Unicode BOM marker\n        if (IsTextBased() && CanSeek()) // files from a pipe cannot begin with Unicode BOM, sorry\n            IsUnicodeBOM(true);\n        break;\n    case fileMarkerEndFile: // end of file marker, should we throw if it's not the end of the file?\n        if (!IsEOF())\n            RuntimeError(\"fileMarkerEndFile not found\");\n        break;\n    case fileMarkerBeginList: // Beginning of list marker\n        // no marker written unless an list with a count header\n        break;\n    case fileMarkerListSeparator: // separate elements of a list\n        // do nothing for now, built in space deliminter for all types (before type)\n        // future: make this customizable, so you can specify a separator (i.e. ',')\n        break;\n    case fileMarkerEndList: // end of line/list marker\n        if (IsTextBased())\n        {\n            int found = EndOfLineOrEOF(true);\n            if (found != (int) true) // EOF can also be returned\n                RuntimeError(\"Newline not found\");\n        }\n        break;\n    case fileMarkerBeginSection: // beginning of section\n    case fileMarkerEndSection:   // end of section\n        assert(false);           // sections should use a string modifier\n        break;\n    }\n    return file;\n}\n\n// Get a marker from the file\n// some are ignored others are expecting characters\n// must use GetMarker methods for those that require parameters\n// This function will fail for non-seekable streams.\nbool File::IsMarker(FileMarker marker, bool skip)\n{\n    bool retval = false;\n    switch (marker)\n    {\n    case fileMarkerBeginFile: // beginning of file marker\n        // check for Unicode BOM marker\n        retval = IsUnicodeBOM(skip);\n        break;\n    case fileMarkerEndFile: // end of file marker, should we throw if it's not the end of the file?\n        retval = IsEOF();\n        break;\n    case fileMarkerBeginList: // Beginning of list marker\n        // no marker written unless an list with a count header\n        // should we try to validate BOL header (just know it's an int, not negative, etc.)\n        break;\n    case fileMarkerListSeparator: // separate elements of a list\n        // do nothing for now, built in space deliminter for all types (before type)\n        // future: make this customizable, so you can specify a separator (i.e. ',')\n        break;\n    case fileMarkerEndList: // end of line/list marker\n        if (IsTextBased())\n        {\n            int eolSeen = false;\n            eolSeen = EndOfLineOrEOF(skip);\n            retval = (eolSeen == (int) true);\n        }\n        break;\n    case fileMarkerBeginSection: // beginning of section\n    case fileMarkerEndSection:   // end of section\n        // can't destinquish from a string currently\n        break;\n    }\n    return retval;\n}\n\n// GetMarker for beginning of list support (lists with a count)\n// count - [out] returns the number of elements in the list\nFile& File::GetMarker(FileMarker marker, size_t& count)\n{\n    assert(marker == fileMarkerBeginList);\n    marker; // only beginning of list supported for count file markers\n    // use text based try, so it can fail without an exception\n    if (IsTextBased())\n        ftrygetText(m_file, count);\n    else\n        fget(m_file, count);\n    return *this;\n}\n\n// GetMarker for section beginning and ending tags\n// section - [in]name of section that is expected\nFile& File::GetMarker(FileMarker marker, const std::string& section)\n{\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    string str;\n    *this >> str;\n    if (str != section)\n        RuntimeError(\"section name mismatch %s != %s\", str.c_str(), section.c_str());\n    return *this;\n}\n\n// GetMarker for section beginning and ending tags\n// section - [in]name of section that is expected\nFile& File::GetMarker(FileMarker marker, const std::wstring& section)\n{\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    wstring str;\n    *this >> str;\n    if (str != section)\n        RuntimeError(\"section name mismatch %ls != %ls\", str.c_str(), section.c_str());\n    return *this;\n}\n\n// TryGetMarker for section beginning and ending tags\n// section - [in]name of section that is expected\nbool File::TryGetMarker(FileMarker marker, const std::wstring& section)\n{\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    size_t pos = GetPosition();\n    std::wstring str;\n    try\n    {\n        *this >> str;\n        if (str == section)\n            return true;\n    }\n    catch (...)\n    {\n        // eat\n    }\n    SetPosition(pos);\n    return false;\n}\n\n// TryGetMarker for section beginning and ending tags\n// section - [in]name of section that is expected\nbool File::TryGetMarker(FileMarker marker, const std::string& section)\n{\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    size_t pos = GetPosition();\n    std::string str;\n    try\n    {\n        *this >> str;\n        if (str == section)\n            return true;\n    }\n    catch (...)\n    {\n        return false;\n    }\n    SetPosition(pos);\n    return false;\n}\n\n// GetPosition - Get position in a file\nuint64_t File::GetPosition()\n{\n    if (!CanSeek())\n        RuntimeError(\"File: attempted to GetPosition() on non-seekable stream\");\n    return fgetpos(m_file);\n}\n\n// Set the position in the file\n// pos - position in the file\nvoid File::SetPosition(uint64_t pos)\n{\n    if (!CanSeek())\n        RuntimeError(\"File: attempted to SetPosition() on non-seekable stream\");\n    fsetpos(m_file, pos);\n}\n\n// helper to load a matrix from a stream (file or string literal)\n// The input string is expected to contain one line per matrix row (natural printing order for humans).\n// Inputs:\n//  - getLineFn: a lambda that fills a string with the next input line (=next matrix row)\n//               The lambda returns an empty string to denote the end.\n// Outputs:\n//  - numRows, numCols: matrix dimensions inferred from newlines\n//  - array: matrix values in column-major order (ready for SetValue())\ntemplate<class ElemType, class F>\nstatic void LoadMatrixFromLambda(const F& getLineFn, const wstring& locationForMsg, vector<ElemType>& array, size_t& /*out*/ numRows, size_t& /*out*/ numCols)\n{\n    // load matrix into vector of vectors (since we don't know the size in advance)\n    vector<ElemType> vec;\n    std::vector<std::vector<ElemType>> elements;\n    size_t numColsInFirstRow = 0;\n\n    std::string line;\n    for(;;)\n    {\n        // get next input line\n        getLineFn(line);\n        if (line.empty())\n            break;\n\n        // tokenize and parse\n        vec.clear();\n        const char * p = line.c_str();\n        for (;;)\n        {\n            while (isspace((unsigned char)*p))\n                p++;\n            if (!*p)\n                break;\n            char* ep; // will be set to point to first character that failed parsing\n            double value = strtod(p, &ep);\n            if (*ep != 0 && !isspace((unsigned char)*ep))\n                RuntimeError(\"LoadMatrixFromTextFile: Malformed number '%.15s...' in row %d of %ls\", p, (int)elements.size(), locationForMsg.c_str());\n            p = ep;\n            vec.push_back((ElemType)value);\n        }\n\n        size_t numElementsInRow = vec.size();\n        if (elements.empty())\n            numColsInFirstRow = numElementsInRow;\n        else if (numElementsInRow != numColsInFirstRow)\n            RuntimeError(\"Row %d has column dimension %d, inconsistent with previous dimension %d: %ls\", (int)elements.size(), (int)numElementsInRow, (int)numColsInFirstRow, locationForMsg.c_str());\n\n        elements.push_back(vec);\n    }\n\n    numRows = elements.size();\n    numCols = numColsInFirstRow;\n\n    // Perform transpose when copying elements from vectors to ElemType[],\n    // in order to store in column-major format.\n    array.resize(numRows * numCols);\n    for (int i = 0; i < numCols; i++)\n        for (int j = 0; j < numRows; j++)\n            array[i * numRows + j] = elements[j][i];\n}\n\n// Load matrix from file. The file is a simple text file consisting of one line per matrix row, where each line contains the elements of the row separated by white space.\ntemplate <class ElemType>\n/*static*/ vector<ElemType> File::LoadMatrixFromTextFile(const std::wstring& filePath, size_t& /*out*/ numRows, size_t& /*out*/ numCols)\n{\n    File myfile(filePath, FileOptions::fileOptionsText | FileOptions::fileOptionsRead);\n\n    // LoadMatrixFromLambda() reads its input lines from the following lambda\n    // return the next input line, or empty string when the end is reached\n    auto getLineFn = [&](string& line)\n    {\n        while (!myfile.IsEOF())\n        {\n            myfile.GetLine(line);\n            if (!line.empty())\n                return; // got the next line to return\n            // End of file manifests as an empty line at the end.\n            // Also, we allow empty lines within the file, as that may help to visually structure matrices that really are >2D tensors.\n        }\n        line.clear(); // empty line indicates end of file\n    };\n\n    vector<ElemType> array;\n    LoadMatrixFromLambda(getLineFn, filePath, array, numRows, numCols);\n    return array;\n}\n\n// Load matrix from file. The file is a simple text file consisting of one line per matrix row, where each line contains the elements of the row separated by white space.\ntemplate <class ElemType>\n/*static*/ vector<ElemType> File::LoadMatrixFromStringLiteral(const std::string& literal, size_t& /*out*/ numRows, size_t& /*out*/ numCols)\n{\n    // LoadMatrixFromLambda() reads its input lines from the following lambda\n    // return the next input line, or empty string when the end is reached\n    size_t pos = 0; // cursor for traversing the string. The lambda takes this by reference and modifies it.\n    auto getLineFn = [&](string& line)\n    {\n        // find first non-blank character of line\n        pos = literal.find_first_not_of(\" \\r\\n\", pos); // skip previous line end and any leading spaces\n        if (pos == string::npos)\n            return line.clear(); // hit the end: return empty line\n        // find end of line\n        auto endPos = literal.find_first_of(\"\\r\\n\", pos + 1); // find line end\n        if (endPos == string::npos)\n            endPos = literal.size(); // no LF required at very end, so that it looks pretty in BS source code\n        line = literal.substr(pos, endPos - pos);\n        pos = endPos; // and advance cursor (we position it on the LF, which is skipped in next round)\n        return;\n    };\n\n    vector<ElemType> array;\n    LoadMatrixFromLambda(getLineFn, L\"string literal\", array, numRows, numCols);\n    return array;\n}\n\ntemplate vector<float>  File::LoadMatrixFromTextFile<float> (const std::wstring& filePath, size_t& /*out*/ numRows, size_t& /*out*/ numCols);\ntemplate vector<double> File::LoadMatrixFromTextFile<double>(const std::wstring& filePath, size_t& /*out*/ numRows, size_t& /*out*/ numCols);\ntemplate vector<half> File::LoadMatrixFromTextFile<half>(const std::wstring& filePath, size_t& /*out*/ numRows, size_t& /*out*/ numCols);\n\ntemplate vector<float>  File::LoadMatrixFromStringLiteral<float> (const std::string& literal, size_t& /*out*/ numRows, size_t& /*out*/ numCols);\ntemplate vector<double> File::LoadMatrixFromStringLiteral<double>(const std::string& literal, size_t& /*out*/ numRows, size_t& /*out*/ numCols);\ntemplate vector<half> File::LoadMatrixFromStringLiteral<half>(const std::string& literal, size_t& /*out*/ numRows, size_t& /*out*/ numCols);\n\n#ifndef CNTK_COMPONENT_VERSION\n#error CNTK_COMPONENT_VERSION must be set\n#endif\n\n// Note: this is a map that transfers the old reader and writer names to\n//       the new naming scheme\nstatic const std::unordered_map<std::wstring, std::wstring> s_deprecatedReaderWriterNameMap =\n{\n    // legacy reader mapping\n    { L\"HTKMLFReader\",          L\"Cntk.Reader.HTKMLF\" },\n    { L\"LMSequenceReader\",      L\"Cntk.Reader.LMSequence\" },\n    { L\"LUSequenceReader\",      L\"Cntk.Reader.LUSequence\" },\n    { L\"UCIFastReader\",         L\"Cntk.Reader.UCIFast\" },\n    { L\"LibSVMBinaryReader\",    L\"Cntk.Reader.SVMBinary\" },\n    { L\"SparsePCReader\",        L\"Cntk.Reader.SparsePC\" },\n    { L\"Kaldi2Reader\",          L\"Cntk.Reader.Kaldi2\" },\n    { L\"BinaryReader\",          L\"Cntk.Reader.Binary\" },\n\n    // legacy writer mapping\n    { L\"HTKMLFWriter\",          L\"Cntk.Reader.HTKMLF\" },\n    { L\"BinaryWriter\",          L\"Cntk.Reader.Binary\" },\n    { L\"LUSequenceWriter\",      L\"Cntk.Reader.LUSequence\" },\n    { L\"LMSequenceWriter\",      L\"Cntk.Reader.LMSequence\" },\n    { L\"Kaldi2Writer\",          L\"Cntk.Reader.Kaldi2\" },\n\n    // New type of readers/writers\n    { L\"CompositeDataReader\",   L\"Cntk.Composite\" },\n    { L\"HTKDeserializers\",      L\"Cntk.Deserializers.HTK\" },\n    { L\"CNTKTextFormatReader\",  L\"Cntk.Deserializers.TextFormat\" },\n    { L\"CNTKBinaryReader\",      L\"Cntk.Deserializers.Binary\" },\n    { L\"ImageReader\",           L\"Cntk.Deserializers.Image\" },\n\n    // Image writer\n    { L\"ImageWriter\",           L\"Cntk.DelayLoadedExtensions\" },\n};\n\n#ifdef _WIN32\nFARPROC Plugin::LoadInternal(const std::wstring& plugin, const std::string& proc, bool isCNTKPlugin)\n{\n#ifdef CNTK_UWP // UWP-TODO\n    RuntimeError(\"Not supported for UWP\");\n#else\n\n    m_dllName = plugin;\n\n    // For python modules we do not need to append anything.\n    if(!boost::ends_with(m_dllName, L\".pyd\"))\n    {\n        if (isCNTKPlugin)\n        {\n            // map legacy names to new naming scheme\n            auto entry = s_deprecatedReaderWriterNameMap.find(m_dllName);\n            if (entry != s_deprecatedReaderWriterNameMap.end())\n                m_dllName = entry->second;\n            m_dllName += L\"-\" + Microsoft::MSR::CNTK::ToFixedWStringFromMultiByte(CNTK_COMPONENT_VERSION);\n        }\n\n        m_dllName += L\".dll\";\n    }\n\n    m_hModule = LoadLibrary(m_dllName.c_str());\n\n    if (m_hModule == NULL)\n        RuntimeError(\"Plugin not found: '%ls'\", m_dllName.c_str());\n    // create a variable of each type just to call the proper templated version\n    FARPROC entryPoint = GetProcAddress(m_hModule, proc.c_str());\n    if (entryPoint == nullptr)\n        RuntimeError(\"Symbol '%s' not found in plugin '%ls'\", proc.c_str(), m_dllName.c_str());\n    return entryPoint;\n#endif\n}\n\n#else\n\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n\nvoid* Plugin::LoadInternal(const std::string& plugin, const std::string& proc, bool isCNTKPlugin)\n{\n    string soName = plugin;\n    wstring soNameW = Microsoft::MSR::CNTK::ToFixedWStringFromMultiByte(plugin);\n\n    if (!boost::ends_with(soName, \".so\"))\n    {\n        if (isCNTKPlugin)\n        {\n            // map legacy names to new naming scheme\n            auto entry = s_deprecatedReaderWriterNameMap.find(soNameW);\n            if (entry != s_deprecatedReaderWriterNameMap.end())\n                soName = Microsoft::MSR::CNTK::ToLegacyString(Microsoft::MSR::CNTK::ToUTF8(entry->second));\n\n            soName += \"-\" + std::string(TOSTRING(CNTK_COMPONENT_VERSION));\n        }\n        soName += \".so\";\n    }\n\n    void* handle = dlopen(soName.c_str(), RTLD_LAZY);\n    if (handle == NULL)\n        RuntimeError(\"Plugin not found: '%s' (error: %s)\", soName.c_str(), dlerror());\n    void* entryPoint = dlsym(handle, proc.c_str());\n    if (entryPoint == nullptr)\n        RuntimeError(\"Symbol '%s' not found in plugin '%s'\", proc.c_str(), soName.c_str());\n    return entryPoint;\n}\n#endif\n\n}}}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tutorials/SLUHandsOn/slu.forward.lookahead.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tutorials/SLUHandsOn/slu.forward.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tutorials/SLUHandsOn/slu.forward.backward.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tutorials/SLUHandsOn/slu.forward.nobn.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tutorials/ImageHandsOn/cifar10.ResNet.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tutorials/ImageHandsOn/cifar10.pretrained.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/.git/objects/pack/pack-fae03bec735a9dcc4a86de0169308ffb1b7ab471.pack",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/.git/objects/pack/pack-fae03bec735a9dcc4a86de0169308ffb1b7ab471.idx",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/bindings/python/cntk/tests/onnx_test_runner/onnx_test_runner.exe",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/bindings/python/cntk/contrib/deeprl/tests/data/initial_policy_network.dnn",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/bindings/python/doc/images/nn_layers.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/bindings/python/doc/images/lstm_cell.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/bindings/csharp/CNTKLibraryManagedDll/CNTKLibraryManagedDll-CPUOnly-KeyPair.snk",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/bindings/csharp/CNTKLibraryManagedDll/CNTKLibraryManagedDll-GPU-KeyPair.snk",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tools/cntk-binary-drop/linux/gpu/license/CUDNN_License.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tools/cntk-binary-drop/linux/gpu/license/CUDA_EULA.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/Documents/PerformanceChart.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures.vsdm",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/SimpleDemoOutputReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN+TrainingCriterion.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CNTKArch.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CNNComputation.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/SimpleDemoErrorRateReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-1HiddenNN.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-WithDelayNode.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-EfficientGradient.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-ShareWeight.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/SequenceBatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CNNComputation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/SpeechErrorRate.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-EfficientGradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-2Inputs.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/ConfusionData100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-1HiddenNN.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/simpleRNN.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN+TrainingCriterion.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-2Inputs.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/SimpleDemoDataReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-WithDelayNode.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/ConfusionData1.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-ShareWeight.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/SequenceBatch.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CNTKArch.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-NaiveGradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/figures/CN-NaiveGradient.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Documentation/CNTK-TechReport/lyx/CNTKBook-20160217..pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/ReinforcementLearning/FlappingBirdWithKeras/assets/sprites/newbird-upflap.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/ReinforcementLearning/FlappingBirdWithKeras/assets/sprites/newbird-downflap.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/ReinforcementLearning/FlappingBirdWithKeras/assets/sprites/newbird-midflap.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/ReinforcementLearning/FlappingBirdWithKeras/assets/sprites/background-black.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/ReinforcementLearning/FlappingBirdWithKeras/assets/sprites/base.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/ReinforcementLearning/FlappingBirdWithKeras/assets/sprites/cactus-green.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Speech/Miscellaneous/TIMIT/AdditionalFiles/ConfusionData25.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Speech/Miscellaneous/TIMIT/AdditionalFiles/SpeechErrorRate.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Speech/Miscellaneous/TIMIT/AdditionalFiles/ConfusionData100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Speech/Miscellaneous/TIMIT/AdditionalFiles/ConfusionData1.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Speech/AN4/Data/000000000.chunk",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Evaluation/UWPImageRecognition/App/GeneratedCode/CNTKDevelopmentTemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Evaluation/UWPImageRecognition/App/Assets/broccoli.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Evaluation/UWPImageRecognition/App/Assets/LockScreenLogo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Evaluation/UWPImageRecognition/App/Assets/Square150x150Logo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Evaluation/UWPImageRecognition/App/Assets/Wide310x150Logo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Evaluation/UWPImageRecognition/App/Assets/cauliflower.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Evaluation/UWPImageRecognition/App/Assets/SplashScreen.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Evaluation/UWPImageRecognition/App/Assets/Square44x44Logo.targetsize-24_altform-unplated.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Evaluation/UWPImageRecognition/App/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Evaluation/UWPImageRecognition/App/Assets/Square44x44Logo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/FastRCNN/BrainScript/fastRCNN/utils/cython_nms.cp36-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/FastRCNN/BrainScript/fastRCNN/utils/cython_bbox.cp35-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/FastRCNN/BrainScript/fastRCNN/utils/cython_nms.cp35-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/FastRCNN/BrainScript/fastRCNN/utils/cython_bbox.cpython-36m-x86_64-linux-gnu.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/FastRCNN/BrainScript/fastRCNN/utils/cython_nms.cpython-35m-x86_64-linux-gnu.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/FastRCNN/BrainScript/fastRCNN/utils/cython_bbox.cpython-35m-x86_64-linux-gnu.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/FastRCNN/BrainScript/fastRCNN/utils/cython_nms.cpython-36m-x86_64-linux-gnu.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/FastRCNN/BrainScript/fastRCNN/utils/cython_bbox.cp36-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/utils/cython_modules/cpu_nms.cpython-35m-x86_64-linux-gnu.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/utils/cython_modules/cython_bbox.cp35-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/utils/cython_modules/cpu_nms.cpython-36m-x86_64-linux-gnu.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/utils/cython_modules/cython_bbox.cpython-36m-x86_64-linux-gnu.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/utils/cython_modules/cython_bbox.cpython-35m-x86_64-linux-gnu.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/utils/cython_modules/cpu_nms.cp35-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Detection/utils/cython_modules/gpu_nms.cp35-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Image/Classification/ResNet/zebra.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Text/LightRNN/ACLWFR.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Text/LightRNN/ClueWeb09_loss.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/SequenceToSequence/CMUDict/Data/cmudict-0.7b",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/SequenceToSequence/PennTreebank/AdditionalFiles/perplexity.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Examples/Extensibility/ProposalLayer/ProposalLayerLib/Rectangle2D.h",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/Speech/Data/glob_0000.ark",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/Speech/Data/mlf2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/Speech/Data/Features/000000000.chunk",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/Simple2d/AdditionalFiles/SimpleDemoOutputReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/Simple2d/AdditionalFiles/SimpleDemoErrorRateReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/Simple2d/AdditionalFiles/SimpleDemoDataReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/UWPImageRecognitionTest/ImageRecognitionAppCS/GeneratedCode/CNTKDevelopmentTemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/UWPImageRecognitionTest/ImageRecognitionAppCS/Assets/LockScreenLogo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/UWPImageRecognitionTest/ImageRecognitionAppCS/Assets/Square150x150Logo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/UWPImageRecognitionTest/ImageRecognitionAppCS/Assets/Wide310x150Logo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/UWPImageRecognitionTest/ImageRecognitionAppCS/Assets/SplashScreen.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/UWPImageRecognitionTest/ImageRecognitionAppCS/Assets/Square44x44Logo.targetsize-24_altform-unplated.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/UWPImageRecognitionTest/ImageRecognitionAppCS/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/UWPImageRecognitionTest/ImageRecognitionAppCS/Assets/Square44x44Logo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/CNTKLibraryCPPUWPEvalExamplesTests/GeneratedCode/CNTKDevelopmentTemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/CNTKLibraryCPPUWPEvalExamplesTests/Assets/LockScreenLogo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/CNTKLibraryCPPUWPEvalExamplesTests/Assets/Square150x150Logo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/CNTKLibraryCPPUWPEvalExamplesTests/Assets/Wide310x150Logo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/CNTKLibraryCPPUWPEvalExamplesTests/Assets/SplashScreen.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/CNTKLibraryCPPUWPEvalExamplesTests/Assets/Square44x44Logo.targetsize-24_altform-unplated.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/CNTKLibraryCPPUWPEvalExamplesTests/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/EvalClientTests/CNTKLibraryCPPUWPEvalExamplesTests/Assets/Square44x44Logo.scale-200.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/EndToEndTests/ParallelTraining/AsynchronousSGD/ASGD_Resnet.model.1",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/images/simple.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/images/green.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/images/chunk0.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/images/multi.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/images/blue.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/images/chunk1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/images/grayscale.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/images/black.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/images/red.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/100x100x3_jagged_sequences_dense.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/Simple_jagged_sequence.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/50x20_jagged_sequences_dense.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/Simple_dense.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/10x10_dense.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/50x20_jagged_sequences_sparse.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/10x10_sparse.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/MNIST_dense.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/NetworkTests/BatchNorm_NDL_config.cntk",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/NetworkTests/Models/01_OneHidden.dnn",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/NetworkTests/Models/ResNet20_CIFAR10_DataAug.dnn",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/V2LibraryTests/data/v2.0.beta1.0.dictionary.proto.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/V2LibraryTests/data/batch.norm.no.sample.count.v2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/V2LibraryTests/data/batch.norm.no.sample.count.v1.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/V2LibraryTests/data/future.dictionary.proto.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/V2LibraryTests/data/past.dictionary.proto.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/V2LibraryTests/data/learner.checkpoint.backcompat.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/BrainScriptTests/Data/ComputationNetwork/01_OneHidden.dnn",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/BrainScriptTests/Data/ComputationNetwork/LR_reg.dnn",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Tests/UnitTests/BrainScriptTests/Data/ComputationNetwork/MC.dnn",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Source/Readers/LMSequenceReader/SentenceTest.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Source/CNTK/BrainScript/Doc/BrainScript--extending the CNTK config language, Frank Seide August 2015.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-master-4if74mkppufspauxibonw4irretvcs2k/spack-src/Source/Extensibility/EvalWrapper/EvalWrapperKeyPair.snk"
    ],
    "total_files": 2906
}