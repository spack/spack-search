{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Extensibility/BinaryConvolution/BinaryConvolutionLib/halide/halide_convolve.h": "#ifndef HALIDE__halide_convolve_h\n#define HALIDE__halide_convolve_h\n#include <stdint.h>\n\n// Forward declarations of the types used in the interface\n// to the Halide pipeline.\n//\n// Definitions for these structs are below.\n\n// Halide's representation of a multi-dimensional array.\n// Halide::Runtime::Buffer is a more user-friendly wrapper\n// around this. Its declaration is in HalideBuffer.h\nstruct halide_buffer_t;\n\n// Metadata describing the arguments to the generated function.\n// Used to construct calls to the _argv version of the function.\nstruct halide_filter_metadata_t;\n\n// The legacy buffer type. Do not use in new code.\nstruct buffer_t;\n\n#ifndef HALIDE_FUNCTION_ATTRS\n#define HALIDE_FUNCTION_ATTRS\n#endif\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint halide_convolve(struct halide_buffer_t *_weights_buffer, struct halide_buffer_t *_input_buffer, int32_t _size, int32_t _stride, bool _pad, int32_t _outx, int32_t _outy, struct halide_buffer_t *_output_buffer) HALIDE_FUNCTION_ATTRS;\nint halide_convolve_argv(void **args) HALIDE_FUNCTION_ATTRS;\nconst struct halide_filter_metadata_t *halide_convolve_metadata() HALIDE_FUNCTION_ATTRS;\n\nint halide_convolve_old_buffer_t(struct buffer_t *_weights, struct buffer_t *_input, int32_t _size, int32_t _stride, bool _pad, int32_t _outx, int32_t _outy, struct buffer_t *_output) HALIDE_FUNCTION_ATTRS;\n\n#ifdef __cplusplus\n}  // extern \"C\"\n#endif\n\n// The generated object file that goes with this header\n// includes a full copy of the Halide runtime so that it\n// can be used standalone. Declarations for the functions\n// in the Halide runtime are below.\n//\n// The runtime is defined using weak linkage, so it is legal\n// to link multiple Halide-generated object files together,\n// or to clobber any of these functions with your own\n// definition.\n//\n// To generate an object file without a full copy of the\n// runtime, use the -no_runtime target flag. To generate a\n// standalone Halide runtime to use with such object files\n// use the -r flag with any Halide generator binary, e.g.:\n// $ ./my_generator -r halide_runtime -o . target=host\n\n#ifndef HALIDE_HALIDERUNTIME_H\n#define HALIDE_HALIDERUNTIME_H\n\n#ifndef COMPILING_HALIDE_RUNTIME\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#else\n#include \"runtime_internal.h\"\n#endif\n\n#ifdef __cplusplus\n// Forward declare type to allow naming typed handles.\n// See Type.h for documentation.\ntemplate<typename T> struct halide_handle_traits;\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Note that you should not use \"inline\" along with HALIDE_ALWAYS_INLINE;\n// it is not necessary, and may produce warnings for some build configurations.\n#ifdef _MSC_VER\n#define HALIDE_ALWAYS_INLINE __forceinline\n#else\n#define HALIDE_ALWAYS_INLINE __attribute__((always_inline)) inline\n#endif\n\n/** \\file\n *\n * This file declares the routines used by Halide internally in its\n * runtime. On platforms that support weak linking, these can be\n * replaced with user-defined versions by defining an extern \"C\"\n * function with the same name and signature.\n *\n * When doing Just In Time (JIT) compilation methods on the Func being\n * compiled must be called instead. The corresponding methods are\n * documented below.\n *\n * All of these functions take a \"void *user_context\" parameter as their\n * first argument; if the Halide kernel that calls back to any of these\n * functions has been compiled with the UserContext feature set on its Target,\n * then the value of that pointer passed from the code that calls the\n * Halide kernel is piped through to the function.\n *\n * Some of these are also useful to call when using the default\n * implementation. E.g. halide_shutdown_thread_pool.\n *\n * Note that even on platforms with weak linking, some linker setups\n * may not respect the override you provide. E.g. if the override is\n * in a shared library and the halide object files are linked directly\n * into the output, the builtin versions of the runtime functions will\n * be called. See your linker documentation for more details. On\n * Linux, LD_DYNAMIC_WEAK=1 may help.\n *\n */\n\n// Forward-declare to suppress warnings if compiling as C.\nstruct halide_buffer_t;\nstruct buffer_t;\n\n/** Print a message to stderr. Main use is to support tracing\n * functionality, print, and print_when calls. Also called by the default\n * halide_error.  This function can be replaced in JITed code by using\n * halide_custom_print and providing an implementation of halide_print\n * in AOT code. See Func::set_custom_print.\n */\n// @{\nextern void halide_print(void *user_context, const char *);\nextern void halide_default_print(void *user_context, const char *);\ntypedef void (*halide_print_t)(void *, const char *);\nextern halide_print_t halide_set_custom_print(halide_print_t print);\n// @}\n\n/** Halide calls this function on runtime errors (for example bounds\n * checking failures). This function can be replaced in JITed code by\n * using Func::set_error_handler, or in AOT code by calling\n * halide_set_error_handler. In AOT code on platforms that support\n * weak linking (i.e. not Windows), you can also override it by simply\n * defining your own halide_error.\n */\n// @{\nextern void halide_error(void *user_context, const char *);\nextern void halide_default_error(void *user_context, const char *);\ntypedef void (*halide_error_handler_t)(void *, const char *);\nextern halide_error_handler_t halide_set_error_handler(halide_error_handler_t handler);\n// @}\n\n/** Cross-platform mutex. These are allocated statically inside the\n * runtime, hence the fixed size. They must be initialized with\n * zero. The first time halide_mutex_lock is called, the lock must be\n * initialized in a thread safe manner. This incurs a small overhead\n * for a once mechanism, but makes the lock reliably easy to setup and\n * use without depending on e.g. C++ constructor logic.\n */\nstruct halide_mutex {\n    uint64_t _private[8];\n};\n\n/** A basic set of mutex and condition variable functions, which call\n * platform specific code for mutual exclusion. Equivalent to posix\n * calls. Mutexes should initially be set to zero'd memory. Any\n * resources required are created on first lock. Calling destroy\n * re-zeros the memory.\n */\n//@{\nextern void halide_mutex_lock(struct halide_mutex *mutex);\nextern void halide_mutex_unlock(struct halide_mutex *mutex);\nextern void halide_mutex_destroy(struct halide_mutex *mutex);\n//@}\n\n/** Define halide_do_par_for to replace the default thread pool\n * implementation. halide_shutdown_thread_pool can also be called to\n * release resources used by the default thread pool on platforms\n * where it makes sense. (E.g. On Mac OS, Grand Central Dispatch is\n * used so %Halide does not own the threads backing the pool and they\n * cannot be released.)  See Func::set_custom_do_task and\n * Func::set_custom_do_par_for. Should return zero if all the jobs\n * return zero, or an arbitrarily chosen return value from one of the\n * jobs otherwise.\n */\n//@{\ntypedef int (*halide_task_t)(void *user_context, int task_number, uint8_t *closure);\nextern int halide_do_par_for(void *user_context,\n                             halide_task_t task,\n                             int min, int size, uint8_t *closure);\nextern void halide_shutdown_thread_pool();\n//@}\n\n/** Set a custom method for performing a parallel for loop. Returns\n * the old do_par_for handler. */\ntypedef int (*halide_do_par_for_t)(void *, halide_task_t, int, int, uint8_t*);\nextern halide_do_par_for_t halide_set_custom_do_par_for(halide_do_par_for_t do_par_for);\n\n/** If you use the default do_par_for, you can still set a custom\n * handler to perform each individual task. Returns the old handler. */\n//@{\ntypedef int (*halide_do_task_t)(void *, halide_task_t, int, uint8_t *);\nextern halide_do_task_t halide_set_custom_do_task(halide_do_task_t do_task);\nextern int halide_do_task(void *user_context, halide_task_t f, int idx,\n                          uint8_t *closure);\n//@}\n\n/** The default versions of do_task and do_par_for. Can be convenient\n * to call from overrides in certain circumstances. */\n// @{\nextern int halide_default_do_par_for(void *user_context,\n                                     halide_task_t task,\n                                     int min, int size, uint8_t *closure);\nextern int halide_default_do_task(void *user_context, halide_task_t f, int idx,\n                                  uint8_t *closure);\n// @}\n\nstruct halide_thread;\n\n/** Spawn a thread. Returns a handle to the thread for the purposes of\n * joining it. The thread must be joined in order to clean up any\n * resources associated with it. */\nextern struct halide_thread *halide_spawn_thread(void (*f)(void *), void *closure);\n\n/** Join a thread. */\nextern void halide_join_thread(struct halide_thread *);\n\n/** Set the number of threads used by Halide's thread pool. Returns\n * the old number.\n *\n * n < 0  : error condition\n * n == 0 : use a reasonable system default (typically, number of cpus online).\n * n == 1 : use exactly one thread; this will always enforce serial execution\n * n > 1  : use a pool of exactly n threads.\n *\n * Note that the default iOS and OSX behavior will treat n > 1 like n == 0;\n * that is, any positive value other than 1 will use a system-determined number\n * of threads.\n *\n * (Note that this is only guaranteed when using the default implementations\n * of halide_do_par_for(); custom implementations may completely ignore values\n * passed to halide_set_num_threads().)\n */\nextern int halide_set_num_threads(int n);\n\n/** Halide calls these functions to allocate and free memory. To\n * replace in AOT code, use the halide_set_custom_malloc and\n * halide_set_custom_free, or (on platforms that support weak\n * linking), simply define these functions yourself. In JIT-compiled\n * code use Func::set_custom_allocator.\n *\n * If you override them, and find yourself wanting to call the default\n * implementation from within your override, use\n * halide_default_malloc/free.\n *\n * Note that halide_malloc must return a pointer aligned to the\n * maximum meaningful alignment for the platform for the purpose of\n * vector loads and stores. The default implementation uses 32-byte\n * alignment, which is safe for arm and x86. Additionally, it must be\n * safe to read at least 8 bytes before the start and beyond the\n * end.\n */\n//@{\nextern void *halide_malloc(void *user_context, size_t x);\nextern void halide_free(void *user_context, void *ptr);\nextern void *halide_default_malloc(void *user_context, size_t x);\nextern void halide_default_free(void *user_context, void *ptr);\ntypedef void *(*halide_malloc_t)(void *, size_t);\ntypedef void (*halide_free_t)(void *, void *);\nextern halide_malloc_t halide_set_custom_malloc(halide_malloc_t user_malloc);\nextern halide_free_t halide_set_custom_free(halide_free_t user_free);\n//@}\n\n/** Halide calls these functions to interact with the underlying\n * system runtime functions. To replace in AOT code on platforms that\n * support weak linking, define these functions yourself, or use\n * the halide_set_custom_load_library() and halide_set_custom_get_library_symbol()\n * functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().\n *\n * halide_load_library and halide_get_library_symbol are equivalent to\n * dlopen and dlsym. halide_get_symbol(sym) is equivalent to\n * dlsym(RTLD_DEFAULT, sym).\n */\n//@{\nextern void *halide_get_symbol(const char *name);\nextern void *halide_load_library(const char *name);\nextern void *halide_get_library_symbol(void *lib, const char *name);\nextern void *halide_default_get_symbol(const char *name);\nextern void *halide_default_load_library(const char *name);\nextern void *halide_default_get_library_symbol(void *lib, const char *name);\ntypedef void *(*halide_get_symbol_t)(const char *name);\ntypedef void *(*halide_load_library_t)(const char *name);\ntypedef void *(*halide_get_library_symbol_t)(void *lib, const char *name);\nextern halide_get_symbol_t halide_set_custom_get_symbol(halide_get_symbol_t user_get_symbol);\nextern halide_load_library_t halide_set_custom_load_library(halide_load_library_t user_load_library);\nextern halide_get_library_symbol_t halide_set_custom_get_library_symbol(halide_get_library_symbol_t user_get_library_symbol);\n//@}\n\n/** Called when debug_to_file is used inside %Halide code.  See\n * Func::debug_to_file for how this is called\n *\n * Cannot be replaced in JITted code at present.\n */\nextern int32_t halide_debug_to_file(void *user_context, const char *filename,\n                                    int32_t type_code,\n                                    struct halide_buffer_t *buf);\n\n/** Types in the halide type system. They can be ints, unsigned ints,\n * or floats (of various bit-widths), or a handle (which is always 64-bits).\n * Note that the int/uint/float values do not imply a specific bit width\n * (the bit width is expected to be encoded in a separate value).\n */\ntypedef enum halide_type_code_t\n#if __cplusplus >= 201103L\n: uint8_t\n#endif\n{\n    halide_type_int = 0,   //!< signed integers\n    halide_type_uint = 1,  //!< unsigned integers\n    halide_type_float = 2, //!< floating point numbers\n    halide_type_handle = 3 //!< opaque pointer type (void *)\n} halide_type_code_t;\n\n// Note that while __attribute__ can go before or after the declaration,\n// __declspec apparently is only allowed before.\n#ifndef HALIDE_ATTRIBUTE_ALIGN\n    #ifdef _MSC_VER\n        #define HALIDE_ATTRIBUTE_ALIGN(x) __declspec(align(x))\n    #else\n        #define HALIDE_ATTRIBUTE_ALIGN(x) __attribute__((aligned(x)))\n    #endif\n#endif\n\n/** A runtime tag for a type in the halide type system. Can be ints,\n * unsigned ints, or floats of various bit-widths (the 'bits'\n * field). Can also be vectors of the same (by setting the 'lanes'\n * field to something larger than one). This struct should be\n * exactly 32-bits in size. */\nstruct halide_type_t {\n    /** The basic type code: signed integer, unsigned integer, or floating point. */\n#if __cplusplus >= 201103L\n    HALIDE_ATTRIBUTE_ALIGN(1) halide_type_code_t code; // halide_type_code_t\n#else\n    HALIDE_ATTRIBUTE_ALIGN(1) uint8_t code; // halide_type_code_t\n#endif\n\n    /** The number of bits of precision of a single scalar value of this type. */\n    HALIDE_ATTRIBUTE_ALIGN(1) uint8_t bits;\n\n    /** How many elements in a vector. This is 1 for scalar types. */\n    HALIDE_ATTRIBUTE_ALIGN(2) uint16_t lanes;\n\n#ifdef __cplusplus\n    /** Construct a runtime representation of a Halide type from:\n     * code: The fundamental type from an enum.\n     * bits: The bit size of one element.\n     * lanes: The number of vector elements in the type. */\n    HALIDE_ALWAYS_INLINE halide_type_t(halide_type_code_t code, uint8_t bits, uint16_t lanes = 1)\n        : code(code), bits(bits), lanes(lanes) {\n    }\n\n    /** Default constructor is required e.g. to declare halide_trace_event\n     * instances. */\n    HALIDE_ALWAYS_INLINE halide_type_t() : code((halide_type_code_t)0), bits(0), lanes(0) {}\n\n    /** Compare two types for equality. */\n    HALIDE_ALWAYS_INLINE bool operator==(const halide_type_t &other) const {\n        return (code == other.code &&\n                bits == other.bits &&\n                lanes == other.lanes);\n    }\n\n    HALIDE_ALWAYS_INLINE bool operator!=(const halide_type_t &other) const {\n        return !(*this == other);\n    }\n\n    /** Size in bytes for a single element, even if width is not 1, of this type. */\n    HALIDE_ALWAYS_INLINE int bytes() const { return (bits + 7) / 8; }\n#endif\n};\n\nenum halide_trace_event_code_t {halide_trace_load = 0,\n                                halide_trace_store = 1,\n                                halide_trace_begin_realization = 2,\n                                halide_trace_end_realization = 3,\n                                halide_trace_produce = 4,\n                                halide_trace_end_produce = 5,\n                                halide_trace_consume = 6,\n                                halide_trace_end_consume = 7,\n                                halide_trace_begin_pipeline = 8,\n                                halide_trace_end_pipeline = 9};\n\nstruct halide_trace_event_t {\n    /** The name of the Func or Pipeline that this event refers to */\n    const char *func;\n\n    /** If the event type is a load or a store, this points to the\n     * value being loaded or stored. Use the type field to safely cast\n     * this to a concrete pointer type and retrieve it. For other\n     * events this is null. */\n    void *value;\n\n    /** For loads and stores, an array which contains the location\n     * being accessed. For vector loads or stores it is an array of\n     * vectors of coordinates (the vector dimension is innermost).\n     *\n     * For realization or production-related events, this will contain\n     * the mins and extents of the region being accessed, in the order\n     * min0, extent0, min1, extent1, ...\n     *\n     * For pipeline-related events, this will be null.\n     */\n    int32_t *coordinates;\n\n    /** If the event type is a load or a store, this is the type of\n     * the data. Otherwise, the value is meaningless. */\n    struct halide_type_t type;\n\n    /** The type of event */\n    enum halide_trace_event_code_t event;\n\n    /* The ID of the parent event (see below for an explanation of\n     * event ancestry). */\n    int32_t parent_id;\n\n    /** If this was a load or store of a Tuple-valued Func, this is\n     * which tuple element was accessed. */\n    int32_t value_index;\n\n    /** The length of the coordinates array */\n    int32_t dimensions;\n\n#ifdef __cplusplus\n    // If we don't explicitly mark the default ctor as inline,\n    // certain build configurations can fail (notably iOS)\n    HALIDE_ALWAYS_INLINE halide_trace_event_t() {}\n#endif\n};\n\n/** Called when Funcs are marked as trace_load, trace_store, or\n * trace_realization. See Func::set_custom_trace. The default\n * implementation either prints events via halide_print, or if\n * HL_TRACE_FILE is defined, dumps the trace to that file in a\n * sequence of trace packets. The header for a trace packet is defined\n * below. If the trace is going to be large, you may want to make the\n * file a named pipe, and then read from that pipe into gzip.\n *\n * halide_trace returns a unique ID which will be passed to future\n * events that \"belong\" to the earlier event as the parent id. The\n * ownership hierarchy looks like:\n *\n * begin_pipeline\n * +--begin_realization\n * |  +--produce\n * |  |  +--load/store\n * |  |  +--end_produce\n * |  +--consume\n * |  |  +--load\n * |  |  +--end_consume\n * |  +--end_realization\n * +--end_pipeline\n *\n * Threading means that ownership cannot be inferred from the ordering\n * of events. There can be many active realizations of a given\n * function, or many active productions for a single\n * realization. Within a single production, the ordering of events is\n * meaningful.\n */\n// @}\nextern int32_t halide_trace(void *user_context, const struct halide_trace_event_t *event);\nextern int32_t halide_default_trace(void *user_context, const struct halide_trace_event_t *event);\ntypedef int32_t (*halide_trace_t)(void *user_context, const struct halide_trace_event_t *);\nextern halide_trace_t halide_set_custom_trace(halide_trace_t trace);\n// @}\n\n/** The header of a packet in a binary trace. All fields are 32-bit. */\nstruct halide_trace_packet_t {\n    /** The total size of this packet in bytes. Always a multiple of\n     * four. Equivalently, the number of bytes until the next\n     * packet. */\n    uint32_t size;\n\n    /** The id of this packet (for the purpose of parent_id). */\n    int32_t id;\n\n    /** The remaining fields are equivalent to those in halide_trace_event_t */\n    // @{\n    struct halide_type_t type;\n    enum halide_trace_event_code_t event;\n    int32_t parent_id;\n    int32_t value_index;\n    int32_t dimensions;\n    // @}\n\n    #ifdef __cplusplus\n    // If we don't explicitly mark the default ctor as inline,\n    // certain build configurations can fail (notably iOS)\n    HALIDE_ALWAYS_INLINE halide_trace_packet_t() {}\n\n    /** Get the coordinates array, assuming this packet is laid out in\n     * memory as it was written. The coordinates array comes\n     * immediately after the packet header. */\n    HALIDE_ALWAYS_INLINE const int *coordinates() const {\n        return (const int *)(this + 1);\n    }\n\n    /** Get the value, assuming this packet is laid out in memory as\n     * it was written. The packet comes immediately after the coordinates\n     * array. */\n    HALIDE_ALWAYS_INLINE const void *value() const {\n        return (const void *)(coordinates() + dimensions);\n    }\n\n    /** Get the func name, assuming this packet is laid out in memory\n     * as it was written. It comes after the value. */\n    HALIDE_ALWAYS_INLINE const char *func() const {\n        return (const char *)value() + type.lanes * type.bytes();\n    }\n    #endif\n};\n\n\n\n/** Set the file descriptor that Halide should write binary trace\n * events to. If called with 0 as the argument, Halide outputs trace\n * information to stdout in a human-readable format. If never called,\n * Halide checks the for existence of an environment variable called\n * HL_TRACE_FILE and opens that file. If HL_TRACE_FILE is not defined,\n * it outputs trace information to stdout in a human-readable\n * format. */\nextern void halide_set_trace_file(int fd);\n\n/** Halide calls this to retrieve the file descriptor to write binary\n * trace events to. The default implementation returns the value set\n * by halide_set_trace_file. Implement it yourself if you wish to use\n * a custom file descriptor per user_context. Return zero from your\n * implementation to tell Halide to print human-readable trace\n * information to stdout. */\nextern int halide_get_trace_file(void *user_context);\n\n/** If tracing is writing to a file. This call closes that file\n * (flushing the trace). Returns zero on success. */\nextern int halide_shutdown_trace();\n\n/** All Halide GPU or device backend implementations much provide an interface\n * to be used with halide_device_malloc, etc.\n */\nstruct halide_device_interface_t;\n\n/** Release all data associated with the current GPU backend, in particular\n * all resources (memory, texture, context handles) allocated by Halide. Must\n * be called explicitly when using AOT compilation. */\nextern void halide_device_release(void *user_context, const struct halide_device_interface_t *device_interface);\n\n/** Copy image data from device memory to host memory. This must be called\n * explicitly to copy back the results of a GPU-based filter. */\nextern int halide_copy_to_host(void *user_context, struct halide_buffer_t *buf);\n\n/** Copy image data from host memory to device memory. This should not\n * be called directly; Halide handles copying to the device\n * automatically.  If interface is NULL and the bug has a non-zero dev\n * field, the device associated with the dev handle will be\n * used. Otherwise if the dev field is 0 and interface is NULL, an\n * error is returned. */\nextern int halide_copy_to_device(void *user_context, struct halide_buffer_t *buf,\n                                 const struct halide_device_interface_t *device_interface);\n\n/** Wait for current GPU operations to complete. Calling this explicitly\n * should rarely be necessary, except maybe for profiling. */\nextern int halide_device_sync(void *user_context, struct halide_buffer_t *buf);\n\n/** Allocate device memory to back a halide_buffer_t. */\nextern int halide_device_malloc(void *user_context, struct halide_buffer_t *buf,\n                                const struct halide_device_interface_t *device_interface);\n\n/** Free device memory. */\nextern int halide_device_free(void *user_context, struct halide_buffer_t *buf);\n\n/** Get a pointer to halide_device_free if a Halide runtime has been\n * linked in. Returns null if it has not. This requires a different\n * mechanism on different platforms. */\ntypedef int (*halide_device_free_t)(void *, struct halide_buffer_t *);\n#ifdef _MSC_VER\nextern const __declspec(selectany) void *halide_dummy_device_free = NULL;\nextern int halide_weak_device_free(void *user_context, struct halide_buffer_t *buf);\n// The following pragma tells the windows linker to make\n// halide_device_free_weak the same symbol as halide_dummy_device_free\n// if it can't resolve halide_weak_device_free normally\n#ifdef _WIN64\n#pragma comment(linker, \"/alternatename:halide_weak_device_free=halide_dummy_device_free\")\n#else\n#pragma comment(linker, \"/alternatename:_halide_weak_device_free=_halide_dummy_device_free\")\n#endif\ninline halide_device_free_t halide_get_device_free_fn() {\n    if ((const void **)(&halide_weak_device_free) == &halide_dummy_device_free) {\n        return NULL;\n    } else {\n        return &halide_weak_device_free;\n    }\n};\n#elif __MINGW32__\ninline halide_device_free_t halide_get_device_free_fn() {\n    // There is no workable mechanism for doing this that we know of on mingw.\n    return &halide_device_free;\n}\n#else\nextern __attribute__((weak)) int halide_weak_device_free(void *user_context, struct halide_buffer_t *buf);\ninline halide_device_free_t halide_get_device_free_fn() {\n    return &halide_weak_device_free;\n}\n#endif\n\n\n/** Versions of the above functions that accept legacy buffer_t structs. */\n// @{\nextern int halide_copy_to_host_legacy(void *user_context, struct buffer_t *buf);\nextern int halide_copy_to_device_legacy(void *user_context, struct buffer_t *buf,\n                                 const struct halide_device_interface_t *device_interface);\nextern int halide_device_sync_legacy(void *user_context, struct buffer_t *buf);\nextern int halide_device_malloc_legacy(void *user_context, struct buffer_t *buf,\n                                const struct halide_device_interface_t *device_interface);\nextern int halide_device_free_legacy(void *user_context, struct buffer_t *buf);\n// @}\n\n/** Selects which gpu device to use. 0 is usually the display\n * device. If never called, Halide uses the environment variable\n * HL_GPU_DEVICE. If that variable is unset, Halide uses the last\n * device. Set this to -1 to use the last device. */\nextern void halide_set_gpu_device(int n);\n\n/** Halide calls this to get the desired halide gpu device\n * setting. Implement this yourself to use a different gpu device per\n * user_context. The default implementation returns the value set by\n * halide_set_gpu_device, or the environment variable\n * HL_GPU_DEVICE. */\nextern int halide_get_gpu_device(void *user_context);\n\n/** Set the soft maximum amount of memory, in bytes, that the LRU\n *  cache will use to memoize Func results.  This is not a strict\n *  maximum in that concurrency and simultaneous use of memoized\n *  reults larger than the cache size can both cause it to\n *  temporariliy be larger than the size specified here.\n */\nextern void halide_memoization_cache_set_size(int64_t size);\n\n/** Given a cache key for a memoized result, currently constructed\n *  from the Func name and top-level Func name plus the arguments of\n *  the computation, determine if the result is in the cache and\n *  return it if so. (The internals of the cache key should be\n *  considered opaque by this function.) If this routine returns true,\n *  it is a cache miss. Otherwise, it will return false and the\n *  buffers passed in will be filled, via copying, with memoized\n *  data. The last argument is a list if halide_buffer_t pointers which\n *  represents the outputs of the memoized Func. If the Func does not\n *  return a Tuple, there will only be one halide_buffer_t in the list. The\n *  tuple_count parameters determines the length of the list.\n *\n * The return values are:\n * -1: Signals an error.\n *  0: Success and cache hit.\n *  1: Success and cache miss.\n */\nextern int halide_memoization_cache_lookup(void *user_context, const uint8_t *cache_key, int32_t size,\n                                           struct halide_buffer_t *realized_bounds,\n                                           int32_t tuple_count, struct halide_buffer_t **tuple_buffers);\n\n/** Given a cache key for a memoized result, currently constructed\n *  from the Func name and top-level Func name plus the arguments of\n *  the computation, store the result in the cache for futre access by\n *  halide_memoization_cache_lookup. (The internals of the cache key\n *  should be considered opaque by this function.) Data is copied out\n *  from the inputs and inputs are unmodified. The last argument is a\n *  list if halide_buffer_t pointers which represents the outputs of the\n *  memoized Func. If the Func does not return a Tuple, there will\n *  only be one halide_buffer_t in the list. The tuple_count parameters\n *  determines the length of the list.\n *\n * If there is a memory allocation failure, the store does not store\n * the data into the cache.\n */\nextern int halide_memoization_cache_store(void *user_context, const uint8_t *cache_key, int32_t size,\n                                          struct halide_buffer_t *realized_bounds,\n                                          int32_t tuple_count,\n                                          struct halide_buffer_t **tuple_buffers);\n\n/** If halide_memoization_cache_lookup succeeds,\n * halide_memoization_cache_release must be called to signal the\n * storage is no longer being used by the caller. It will be passed\n * the host pointer of one the buffers returned by\n * halide_memoization_cache_lookup. That is\n * halide_memoization_cache_release will be called multiple times for\n * the case where halide_memoization_cache_lookup is handling multiple\n * buffers.  (This corresponds to memoizing a Tuple in Halide.) Note\n * that the host pointer must be sufficient to get to all information\n * the relase operation needs. The default Halide cache impleemntation\n * accomplishes this by storing extra data before the start of the user\n * modifiable host storage.\n *\n * This call is like free and does not have a failure return.\n  */\nextern void halide_memoization_cache_release(void *user_context, void *host);\n\n/** Free all memory and resources associated with the memoization cache.\n * Must be called at a time when no other threads are accessing the cache.\n */\nextern void halide_memoization_cache_cleanup();\n\n/** Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary\n * (but writable) directory; this is typically $TMP or /tmp, but the specific\n * location is not guaranteed. (Note that the exact form of the file name\n * may vary; in particular, the suffix may be ignored on non-Posix systems.)\n * The file is created (but not opened), thus this can be called from\n * different threads (or processes, e.g. when building with parallel make)\n * without risking collision. Note that the caller is always responsible\n * for deleting this file. Returns nonzero value if an error occurs.\n */\nextern int halide_create_temp_file(void *user_context,\n  const char *prefix, const char *suffix,\n  char *path_buf, size_t path_buf_size);\n\n/** Annotate that a given range of memory has been initialized;\n * only used when Target::MSAN is enabled.\n *\n * The default implementation uses the LLVM-provided AnnotateMemoryIsInitialized() function.\n */\nextern void halide_msan_annotate_memory_is_initialized(void *user_context, const void *ptr, uint64_t len);\n\n/** Mark the data pointed to by the buffer_t as initialized (but *not* the buffer_t itself),\n * using halide_msan_annotate_memory_is_initialized() for marking.\n *\n * The default implementation takes pains to only mark the active memory ranges\n * (skipping padding), and sorting into ranges to always mark the smallest number of\n * ranges, in monotonically increasing memory order.\n *\n * Most client code should never need to replace the default implementation.\n */\nextern void halide_msan_annotate_buffer_is_initialized(void *user_context, struct halide_buffer_t *buffer);\nextern void halide_msan_annotate_buffer_is_initialized_as_destructor(void *user_context, void *buffer);\n\n/** The error codes that may be returned by a Halide pipeline. */\nenum halide_error_code_t {\n    /** There was no error. This is the value returned by Halide on success. */\n    halide_error_code_success = 0,\n\n    /** An uncategorized error occurred. Refer to the string passed to halide_error. */\n    halide_error_code_generic_error = -1,\n\n    /** A Func was given an explicit bound via Func::bound, but this\n     * was not large enough to encompass the region that is used of\n     * the Func by the rest of the pipeline. */\n    halide_error_code_explicit_bounds_too_small = -2,\n\n    /** The elem_size field of a halide_buffer_t does not match the size in\n     * bytes of the type of that ImageParam. Probable type mismatch. */\n    halide_error_code_bad_type = -3,\n\n    /** A pipeline would access memory outside of the halide_buffer_t passed\n     * in. */\n    halide_error_code_access_out_of_bounds = -4,\n\n    /** A halide_buffer_t was given that spans more than 2GB of memory. */\n    halide_error_code_buffer_allocation_too_large = -5,\n\n    /** A halide_buffer_t was given with extents that multiply to a number\n     * greater than 2^31-1 */\n    halide_error_code_buffer_extents_too_large = -6,\n\n    /** Applying explicit constraints on the size of an input or\n     * output buffer shrank the size of that buffer below what will be\n     * accessed by the pipeline. */\n    halide_error_code_constraints_make_required_region_smaller = -7,\n\n    /** A constraint on a size or stride of an input or output buffer\n     * was not met by the halide_buffer_t passed in. */\n    halide_error_code_constraint_violated = -8,\n\n    /** A scalar parameter passed in was smaller than its minimum\n     * declared value. */\n    halide_error_code_param_too_small = -9,\n\n    /** A scalar parameter passed in was greater than its minimum\n     * declared value. */\n    halide_error_code_param_too_large = -10,\n\n    /** A call to halide_malloc returned NULL. */\n    halide_error_code_out_of_memory = -11,\n\n    /** A halide_buffer_t pointer passed in was NULL. */\n    halide_error_code_buffer_argument_is_null = -12,\n\n    /** debug_to_file failed to open or write to the specified\n     * file. */\n    halide_error_code_debug_to_file_failed = -13,\n\n    /** The Halide runtime encountered an error while trying to copy\n     * from device to host. Turn on -debug in your target string to\n     * see more details. */\n    halide_error_code_copy_to_host_failed = -14,\n\n    /** The Halide runtime encountered an error while trying to copy\n     * from host to device. Turn on -debug in your target string to\n     * see more details. */\n    halide_error_code_copy_to_device_failed = -15,\n\n    /** The Halide runtime encountered an error while trying to\n     * allocate memory on device. Turn on -debug in your target string\n     * to see more details. */\n    halide_error_code_device_malloc_failed = -16,\n\n    /** The Halide runtime encountered an error while trying to\n     * synchronize with a device. Turn on -debug in your target string\n     * to see more details. */\n    halide_error_code_device_sync_failed = -17,\n\n    /** The Halide runtime encountered an error while trying to free a\n     * device allocation. Turn on -debug in your target string to see\n     * more details. */\n    halide_error_code_device_free_failed = -18,\n\n    /** A device operation was attempted on a buffer with no device\n     * interface. */\n    halide_error_code_no_device_interface = -19,\n\n    /** An error occurred when attempting to initialize the Matlab\n     * runtime. */\n    halide_error_code_matlab_init_failed = -20,\n\n    /** The type of an mxArray did not match the expected type. */\n    halide_error_code_matlab_bad_param_type = -21,\n\n    /** There is a bug in the Halide compiler. */\n    halide_error_code_internal_error = -22,\n\n    /** The Halide runtime encountered an error while trying to launch\n     * a GPU kernel. Turn on -debug in your target string to see more\n     * details. */\n    halide_error_code_device_run_failed = -23,\n\n    /** The Halide runtime encountered a host pointer that violated\n     * the alignment set for it by way of a call to\n     * set_host_alignment */\n    halide_error_code_unaligned_host_ptr = -24,\n\n    /** A fold_storage directive was used on a dimension that is not\n     * accessed in a monotonically increasing or decreasing fashion. */\n    halide_error_code_bad_fold = -25,\n\n    /** A fold_storage directive was used with a fold factor that was\n     * too small to store all the values of a producer needed by the\n     * consumer. */\n    halide_error_code_fold_factor_too_small = -26,\n\n    /** User-specified require() expression was not satisfied. */\n    halide_error_code_requirement_failed = -27,\n\n    /** At least one of the buffer's extents are negative. */\n    halide_error_code_buffer_extents_negative = -28,\n\n    /** A compiled pipeline was passed the old deprecated buffer_t\n     * struct, and it could not be upgraded to a halide_buffer_t. */\n    halide_error_code_failed_to_upgrade_buffer_t = -29,\n\n    /** A compiled pipeline was passed the old deprecated buffer_t\n     * struct in bounds inference mode, but the returned information\n     * can't be expressed in the old buffer_t. */\n    halide_error_code_failed_to_downgrade_buffer_t = -30,\n\n    /** A specialize_fail() schedule branch was selected at runtime. */\n    halide_error_code_specialize_fail = -31,\n\n};\n\n/** Halide calls the functions below on various error conditions. The\n * default implementations construct an error message, call\n * halide_error, then return the matching error code above. On\n * platforms that support weak linking, you can override these to\n * catch the errors individually. */\n\n/** A call into an extern stage for the purposes of bounds inference\n * failed. Returns the error code given by the extern stage. */\nextern int halide_error_bounds_inference_call_failed(void *user_context, const char *extern_stage_name, int result);\n\n/** A call to an extern stage failed. Returned the error code given by\n * the extern stage. */\nextern int halide_error_extern_stage_failed(void *user_context, const char *extern_stage_name, int result);\n\n/** Various other error conditions. See the enum above for a\n * description of each. */\n// @{\nextern int halide_error_explicit_bounds_too_small(void *user_context, const char *func_name, const char *var_name,\n                                                      int min_bound, int max_bound, int min_required, int max_required);\nextern int halide_error_bad_type(void *user_context, const char *func_name,\n                                 uint8_t code_given, uint8_t correct_code,\n                                 uint8_t bits_given, uint8_t correct_bits,\n                                 uint16_t lanes_given, uint16_t correct_lanes);\nextern int halide_error_access_out_of_bounds(void *user_context, const char *func_name,\n                                             int dimension, int min_touched, int max_touched,\n                                             int min_valid, int max_valid);\nextern int halide_error_buffer_allocation_too_large(void *user_context, const char *buffer_name,\n                                                    uint64_t allocation_size, uint64_t max_size);\nextern int halide_error_buffer_extents_negative(void *user_context, const char *buffer_name, int dimension, int extent);\nextern int halide_error_buffer_extents_too_large(void *user_context, const char *buffer_name,\n                                                 int64_t actual_size, int64_t max_size);\nextern int halide_error_constraints_make_required_region_smaller(void *user_context, const char *buffer_name,\n                                                                 int dimension,\n                                                                 int constrained_min, int constrained_extent,\n                                                                 int required_min, int required_extent);\nextern int halide_error_constraint_violated(void *user_context, const char *var, int val,\n                                            const char *constrained_var, int constrained_val);\nextern int halide_error_param_too_small_i64(void *user_context, const char *param_name,\n                                            int64_t val, int64_t min_val);\nextern int halide_error_param_too_small_u64(void *user_context, const char *param_name,\n                                            uint64_t val, uint64_t min_val);\nextern int halide_error_param_too_small_f64(void *user_context, const char *param_name,\n                                            double val, double min_val);\nextern int halide_error_param_too_large_i64(void *user_context, const char *param_name,\n                                            int64_t val, int64_t max_val);\nextern int halide_error_param_too_large_u64(void *user_context, const char *param_name,\n                                            uint64_t val, uint64_t max_val);\nextern int halide_error_param_too_large_f64(void *user_context, const char *param_name,\n                                            double val, double max_val);\nextern int halide_error_out_of_memory(void *user_context);\nextern int halide_error_buffer_argument_is_null(void *user_context, const char *buffer_name);\nextern int halide_error_debug_to_file_failed(void *user_context, const char *func,\n                                             const char *filename, int error_code);\nextern int halide_error_unaligned_host_ptr(void *user_context, const char *func_name, int alignment);\nextern int halide_error_failed_to_upgrade_buffer_t(void *user_context,\n                                                   const char *input_name,\n                                                   const char *reason);\nextern int halide_error_failed_to_downgrade_buffer_t(void *user_context,\n                                                     const char *input_name,\n                                                     const char *reason);\nextern int halide_error_bad_fold(void *user_context, const char *func_name, const char *var_name,\n                                 const char *loop_name);\n\nextern int halide_error_fold_factor_too_small(void *user_context, const char *func_name, const char *var_name,\n                                              int fold_factor, const char *loop_name, int required_extent);\nextern int halide_error_requirement_failed(void *user_context, const char *condition, const char *message);\nextern int halide_error_specialize_fail(void *user_context, const char *message);\n\n// @}\n\n/** Optional features a compilation Target can have.\n */\ntypedef enum halide_target_feature_t {\n    halide_target_feature_jit = 0,  ///< Generate code that will run immediately inside the calling process.\n    halide_target_feature_debug = 1,  ///< Turn on debug info and output for runtime code.\n    halide_target_feature_no_asserts = 2,  ///< Disable all runtime checks, for slightly tighter code.\n    halide_target_feature_no_bounds_query = 3, ///< Disable the bounds querying functionality.\n\n    halide_target_feature_sse41 = 4,  ///< Use SSE 4.1 and earlier instructions. Only relevant on x86.\n    halide_target_feature_avx = 5,  ///< Use AVX 1 instructions. Only relevant on x86.\n    halide_target_feature_avx2 = 6,  ///< Use AVX 2 instructions. Only relevant on x86.\n    halide_target_feature_fma = 7,  ///< Enable x86 FMA instruction\n    halide_target_feature_fma4 = 8,  ///< Enable x86 (AMD) FMA4 instruction set\n    halide_target_feature_f16c = 9,  ///< Enable x86 16-bit float support\n\n    halide_target_feature_armv7s = 10,  ///< Generate code for ARMv7s. Only relevant for 32-bit ARM.\n    halide_target_feature_no_neon = 11,  ///< Avoid using NEON instructions. Only relevant for 32-bit ARM.\n\n    halide_target_feature_vsx = 12,  ///< Use VSX instructions. Only relevant on POWERPC.\n    halide_target_feature_power_arch_2_07 = 13,  ///< Use POWER ISA 2.07 new instructions. Only relevant on POWERPC.\n\n    halide_target_feature_cuda = 14,  ///< Enable the CUDA runtime. Defaults to compute capability 2.0 (Fermi)\n    halide_target_feature_cuda_capability30 = 15,  ///< Enable CUDA compute capability 3.0 (Kepler)\n    halide_target_feature_cuda_capability32 = 16,  ///< Enable CUDA compute capability 3.2 (Tegra K1)\n    halide_target_feature_cuda_capability35 = 17,  ///< Enable CUDA compute capability 3.5 (Kepler)\n    halide_target_feature_cuda_capability50 = 18,  ///< Enable CUDA compute capability 5.0 (Maxwell)\n\n    halide_target_feature_opencl = 19,  ///< Enable the OpenCL runtime.\n    halide_target_feature_cl_doubles = 20,  ///< Enable double support on OpenCL targets\n\n    halide_target_feature_opengl = 21,  ///< Enable the OpenGL runtime.\n    halide_target_feature_openglcompute = 22, ///< Enable OpenGL Compute runtime.\n\n    halide_target_feature_unused_23 = 23, ///< Unused. (Formerly: Enable the RenderScript runtime.)\n\n    halide_target_feature_user_context = 24,  ///< Generated code takes a user_context pointer as first argument\n\n    halide_target_feature_matlab = 25,  ///< Generate a mexFunction compatible with Matlab mex libraries. See tools/mex_halide.m.\n\n    halide_target_feature_profile = 26, ///< Launch a sampling profiler alongside the Halide pipeline that monitors and reports the runtime used by each Func\n    halide_target_feature_no_runtime = 27, ///< Do not include a copy of the Halide runtime in any generated object file or assembly\n\n    halide_target_feature_metal = 28, ///< Enable the (Apple) Metal runtime.\n    halide_target_feature_mingw = 29, ///< For Windows compile to MinGW toolset rather then Visual Studio\n\n    halide_target_feature_c_plus_plus_mangling = 30, ///< Generate C++ mangled names for result function, et al\n\n    halide_target_feature_large_buffers = 31, ///< Enable 64-bit buffer indexing to support buffers > 2GB.\n\n    halide_target_feature_hvx_64 = 32, ///< Enable HVX 64 byte mode.\n    halide_target_feature_hvx_128 = 33, ///< Enable HVX 128 byte mode.\n    halide_target_feature_hvx_v62 = 34, ///< Enable Hexagon v62 architecture.\n    halide_target_feature_fuzz_float_stores = 35, ///< On every floating point store, set the last bit of the mantissa to zero. Pipelines for which the output is very different with this feature enabled may also produce very different output on different processors.\n    halide_target_feature_soft_float_abi = 36, ///< Enable soft float ABI. This only enables the soft float ABI calling convention, which does not necessarily use soft floats.\n    halide_target_feature_msan = 37, ///< Enable hooks for MSAN support.\n    halide_target_feature_avx512 = 38, ///< Enable the base AVX512 subset supported by all AVX512 architectures. The specific feature sets are AVX-512F and AVX512-CD. See https://en.wikipedia.org/wiki/AVX-512 for a description of each AVX subset.\n    halide_target_feature_avx512_knl = 39, ///< Enable the AVX512 features supported by Knight's Landing chips, such as the Xeon Phi x200. This includes the base AVX512 set, and also AVX512-CD and AVX512-ER.\n    halide_target_feature_avx512_skylake = 40, ///< Enable the AVX512 features supported by Skylake Xeon server processors. This adds AVX512-VL, AVX512-BW, and AVX512-DQ to the base set. The main difference from the base AVX512 set is better support for small integer ops. Note that this does not include the Knight's Landing features. Note also that these features are not available on Skylake desktop and mobile processors.\n    halide_target_feature_avx512_cannonlake = 41, ///< Enable the AVX512 features expected to be supported by future Cannonlake processors. This includes all of the Skylake features, plus AVX512-IFMA and AVX512-VBMI.\n    halide_target_feature_hvx_use_shared_object = 42, ///< Deprecated\n    halide_target_feature_trace_loads = 43, ///< Trace all loads done by the pipeline. Equivalent to calling Func::trace_loads on every non-inlined Func.\n    halide_target_feature_trace_stores = 44, ///< Trace all stores done by the pipeline. Equivalent to calling Func::trace_stores on every non-inlined Func.\n    halide_target_feature_trace_realizations = 45, ///< Trace all realizations done by the pipeline. Equivalent to calling Func::trace_realizations on every non-inlined Func.\n    halide_target_feature_cuda_capability61 = 46,  ///< Enable CUDA compute capability 6.1 (Pascal)\n    halide_target_feature_end = 47 ///< A sentinel. Every target is considered to have this feature, and setting this feature does nothing.\n} halide_target_feature_t;\n\n/** This function is called internally by Halide in some situations to determine\n * if the current execution environment can support the given set of\n * halide_target_feature_t flags. The implementation must do the following:\n *\n * -- If there are flags set in features that the function knows *cannot* be supported, return 0.\n * -- Otherwise, return 1.\n * -- Note that any flags set in features that the function doesn't know how to test should be ignored;\n * this implies that a return value of 1 means \"not known to be bad\" rather than \"known to be good\".\n *\n * In other words: a return value of 0 means \"It is not safe to use code compiled with these features\",\n * while a return value of 1 means \"It is not obviously unsafe to use code compiled with these features\".\n *\n * The default implementation simply calls halide_default_can_use_target_features.\n */\n// @{\nextern int halide_can_use_target_features(uint64_t features);\ntypedef int (*halide_can_use_target_features_t)(uint64_t);\nextern halide_can_use_target_features_t halide_set_custom_can_use_target_features(halide_can_use_target_features_t);\n// @}\n\n/**\n * This is the default implementation of halide_can_use_target_features; it is provided\n * for convenience of user code that may wish to extend halide_can_use_target_features\n * but continue providing existing support, e.g.\n *\n *     int halide_can_use_target_features(uint64_t features) {\n *          if (features & halide_target_somefeature) {\n *              if (!can_use_somefeature()) {\n *                  return 0;\n *              }\n *          }\n *          return halide_default_can_use_target_features(features);\n *     }\n */\nextern int halide_default_can_use_target_features(uint64_t features);\n\n\ntypedef struct halide_dimension_t {\n    int32_t min, extent, stride;\n\n    // Per-dimension flags. None are defined yet (This is reserved for future use).\n    uint32_t flags;\n\n#ifdef __cplusplus\n    HALIDE_ALWAYS_INLINE halide_dimension_t() : min(0), extent(0), stride(0), flags(0) {}\n    HALIDE_ALWAYS_INLINE halide_dimension_t(int32_t m, int32_t e, int32_t s, uint32_t f = 0) :\n        min(m), extent(e), stride(s), flags(f) {}\n\n    HALIDE_ALWAYS_INLINE bool operator==(const halide_dimension_t &other) const {\n        return (min == other.min) &&\n            (extent == other.extent) &&\n            (stride == other.stride) &&\n            (flags == other.flags);\n    }\n\n    HALIDE_ALWAYS_INLINE bool operator!=(const halide_dimension_t &other) const {\n        return !(*this == other);\n    }\n#endif\n} halide_dimension_t;\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\ntypedef enum {halide_buffer_flag_host_dirty = 1,\n              halide_buffer_flag_device_dirty = 2} halide_buffer_flags;\n\n/**\n * The raw representation of an image passed around by generated\n * Halide code. It includes some stuff to track whether the image is\n * not actually in main memory, but instead on a device (like a\n * GPU). For a more convenient C++ wrapper, use Halide::Buffer<T>. */\ntypedef struct halide_buffer_t {\n    /** A device-handle for e.g. GPU memory used to back this buffer. */\n    uint64_t device;\n\n    /** The interface used to interpret the above handle. */\n    const struct halide_device_interface_t *device_interface;\n\n    /** A pointer to the start of the data in main memory. In terms of\n     * the Halide coordinate system, this is the address of the min\n     * coordinates (defined below). */\n    uint8_t* host;\n\n    /** flags with various meanings. */\n    uint64_t flags;\n\n    /** The type of each buffer element. */\n    struct halide_type_t type;\n\n    /** The dimensionality of the buffer. */\n    int32_t dimensions;\n\n    /** The shape of the buffer. Halide does not own this array - you\n     * must manage the memory for it yourself. */\n    halide_dimension_t *dim;\n\n    /** Pads the buffer up to a multiple of 8 bytes */\n    void *padding;\n\n#ifdef __cplusplus\n    /** Convenience methods for accessing the flags */\n    // @{\n    HALIDE_ALWAYS_INLINE bool get_flag(halide_buffer_flags flag) const {\n        return (flags & flag) != 0;\n    }\n\n    HALIDE_ALWAYS_INLINE void set_flag(halide_buffer_flags flag, bool value) {\n        if (value) {\n            flags |= flag;\n        } else {\n            flags &= ~flag;\n        }\n    }\n\n    HALIDE_ALWAYS_INLINE bool host_dirty() const {\n        return get_flag(halide_buffer_flag_host_dirty);\n    }\n\n    HALIDE_ALWAYS_INLINE bool device_dirty() const {\n        return get_flag(halide_buffer_flag_device_dirty);\n    }\n\n    HALIDE_ALWAYS_INLINE void set_host_dirty(bool v = true) {\n        set_flag(halide_buffer_flag_host_dirty, v);\n    }\n\n    HALIDE_ALWAYS_INLINE void set_device_dirty(bool v = true) {\n        set_flag(halide_buffer_flag_device_dirty, v);\n    }\n    // @}\n\n    /** The total number of elements this buffer represents. Equal to\n     * the product of the extents */\n    HALIDE_ALWAYS_INLINE size_t number_of_elements() const {\n        size_t s = 1;\n        for (int i = 0; i < dimensions; i++) {\n            s *= dim[i].extent;\n        }\n        return s;\n    }\n\n    /** A pointer to the element with the lowest address. If all\n     * strides are positive, equal to the host pointer. */\n    HALIDE_ALWAYS_INLINE uint8_t *begin() const {\n        ptrdiff_t index = 0;\n        for (int i = 0; i < dimensions; i++) {\n            if (dim[i].stride < 0) {\n                index += dim[i].stride * (dim[i].extent - 1);\n            }\n        }\n        return host + index * type.bytes();\n    }\n\n    /** A pointer to one beyond the element with the highest address. */\n    HALIDE_ALWAYS_INLINE uint8_t *end() const {\n        ptrdiff_t index = 0;\n        for (int i = 0; i < dimensions; i++) {\n            if (dim[i].stride > 0) {\n                index += dim[i].stride * (dim[i].extent - 1);\n            }\n        }\n        index += 1;\n        return host + index * type.bytes();\n    }\n\n    /** The total number of bytes spanned by the data in memory. */\n    HALIDE_ALWAYS_INLINE size_t size_in_bytes() const {\n        return (size_t)(end() - begin());\n    }\n\n    /** A pointer to the element at the given location. */\n    HALIDE_ALWAYS_INLINE uint8_t *address_of(const int *pos) const {\n        ptrdiff_t index = 0;\n        for (int i = 0; i < dimensions; i++) {\n            index += dim[i].stride * (pos[i] - dim[i].min);\n        }\n        return host + index * type.bytes();\n    }\n\n#endif\n} halide_buffer_t;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef HALIDE_ATTRIBUTE_DEPRECATED\n#ifdef HALIDE_ALLOW_DEPRECATED\n#define HALIDE_ATTRIBUTE_DEPRECATED(x)\n#else\n#ifdef _MSC_VER\n#define HALIDE_ATTRIBUTE_DEPRECATED(x) __declspec(deprecated(x))\n#else\n#define HALIDE_ATTRIBUTE_DEPRECATED(x) __attribute__((deprecated(x)))\n#endif\n#endif\n#endif\n\n/** The old buffer_t, included for compatibility with old code. Don't\n * use it. */\n#ifndef BUFFER_T_DEFINED\n#define BUFFER_T_DEFINED\ntypedef struct buffer_t {\n    uint64_t dev;\n    uint8_t* host;\n    int32_t extent[4];\n    int32_t stride[4];\n    int32_t min[4];\n    int32_t elem_size;\n    HALIDE_ATTRIBUTE_ALIGN(1) bool host_dirty;\n    HALIDE_ATTRIBUTE_ALIGN(1) bool dev_dirty;\n    HALIDE_ATTRIBUTE_ALIGN(1) uint8_t _padding[10 - sizeof(void *)];\n} buffer_t;\n#endif // BUFFER_T_DEFINED\n\n/** Copies host pointer, mins, extents, strides, and device state from\n * an old-style buffer_t into a new-style halide_buffer_t. The\n * dimensions and type fields of the new buffer_t should already be\n * set. Returns an error code if the upgrade could not be\n * performed. */\nextern int halide_upgrade_buffer_t(void *user_context, const char *name,\n                                   const buffer_t *old_buf, halide_buffer_t *new_buf);\n\n/** Copies the host pointer, mins, extents, strides, and device state\n * from a halide_buffer_t to a buffer_t. Also sets elem_size. Useful\n * for backporting the results of bounds inference. */\nextern int halide_downgrade_buffer_t(void *user_context, const char *name,\n                                     const halide_buffer_t *new_buf, buffer_t *old_buf);\n\n/** Copies the dirty flags and device allocation state from a new\n * buffer_t back to a legacy buffer_t. */\nextern int halide_downgrade_buffer_t_device_fields(void *user_context, const char *name,\n                                                   const halide_buffer_t *new_buf, buffer_t *old_buf);\n\n/** halide_scalar_value_t is a simple union able to represent all the well-known\n * scalar values in a filter argument. Note that it isn't tagged with a type;\n * you must ensure you know the proper type before accessing. Most user\n * code will never need to create instances of this struct; its primary use\n * is to hold def/min/max values in a halide_filter_argument_t. (Note that\n * this is conceptually just a union; it's wrapped in a struct to ensure\n * that it doesn't get anonymized by LLVM.)\n */\nstruct halide_scalar_value_t {\n    union {\n        bool b;\n        int8_t i8;\n        int16_t i16;\n        int32_t i32;\n        int64_t i64;\n        uint8_t u8;\n        uint16_t u16;\n        uint32_t u32;\n        uint64_t u64;\n        float f32;\n        double f64;\n        void *handle;\n    } u;\n};\n\nenum halide_argument_kind_t {\n    halide_argument_kind_input_scalar = 0,\n    halide_argument_kind_input_buffer = 1,\n    halide_argument_kind_output_buffer = 2\n};\n\n/*\n    These structs must be robust across different compilers and settings; when\n    modifying them, strive for the following rules:\n\n    1) All fields are explicitly sized. I.e. must use int32_t and not \"int\"\n    2) All fields must land on an alignment boundary that is the same as their size\n    3) Explicit padding is added to make that so\n    4) The sizeof the struct is padded out to a multiple of the largest natural size thing in the struct\n    5) don't forget that 32 and 64 bit pointers are different sizes\n*/\n\n/**\n * halide_filter_argument_t is essentially a plain-C-struct equivalent to\n * Halide::Argument; most user code will never need to create one.\n */\nstruct halide_filter_argument_t {\n    const char *name;       // name of the argument; will never be null or empty.\n    int32_t kind;           // actually halide_argument_kind_t\n    int32_t dimensions;     // always zero for scalar arguments\n    struct halide_type_t type;\n    // These pointers should always be null for buffer arguments,\n    // and *may* be null for scalar arguments. (A null value means\n    // there is no def/min/max specified for this argument.)\n    const struct halide_scalar_value_t *def;\n    const struct halide_scalar_value_t *min;\n    const struct halide_scalar_value_t *max;\n};\n\nstruct halide_filter_metadata_t {\n    /** version of this metadata; currently always 0. */\n    int32_t version;\n\n    /** The number of entries in the arguments field. This is always >= 1. */\n    int32_t num_arguments;\n\n    /** An array of the filters input and output arguments; this will never be\n     * null. The order of arguments is not guaranteed (input and output arguments\n     * may come in any order); however, it is guaranteed that all arguments\n     * will have a unique name within a given filter. */\n    const struct halide_filter_argument_t* arguments;\n\n    /** The Target for which the filter was compiled. This is always\n     * a canonical Target string (ie a product of Target::to_string). */\n    const char* target;\n\n    /** The function name of the filter. */\n    const char* name;\n};\n\n/** The functions below here are relevant for pipelines compiled with\n * the -profile target flag, which runs a sampling profiler thread\n * alongside the pipeline. */\n\n/** Per-Func state tracked by the sampling profiler. */\nstruct halide_profiler_func_stats {\n    /** Total time taken evaluating this Func (in nanoseconds). */\n    uint64_t time;\n\n    /** The current memory allocation of this Func. */\n    uint64_t memory_current;\n\n    /** The peak memory allocation of this Func. */\n    uint64_t memory_peak;\n\n    /** The total memory allocation of this Func. */\n    uint64_t memory_total;\n\n    /** The peak stack allocation of this Func's threads. */\n    uint64_t stack_peak;\n\n    /** The average number of thread pool worker threads active while computing this Func. */\n    uint64_t active_threads_numerator, active_threads_denominator;\n\n    /** The name of this Func. A global constant string. */\n    const char *name;\n\n    /** The total number of memory allocation of this Func. */\n    int num_allocs;\n};\n\n/** Per-pipeline state tracked by the sampling profiler. These exist\n * in a linked list. */\nstruct halide_profiler_pipeline_stats {\n    /** Total time spent inside this pipeline (in nanoseconds) */\n    uint64_t time;\n\n    /** The current memory allocation of funcs in this pipeline. */\n    uint64_t memory_current;\n\n    /** The peak memory allocation of funcs in this pipeline. */\n    uint64_t memory_peak;\n\n    /** The total memory allocation of funcs in this pipeline. */\n    uint64_t memory_total;\n\n    /** The average number of thread pool worker threads doing useful\n     * work while computing this pipeline. */\n    uint64_t active_threads_numerator, active_threads_denominator;\n\n    /** The name of this pipeline. A global constant string. */\n    const char *name;\n\n    /** An array containing states for each Func in this pipeline. */\n    struct halide_profiler_func_stats *funcs;\n\n    /** The next pipeline_stats pointer. It's a void * because types\n     * in the Halide runtime may not currently be recursive. */\n    void *next;\n\n    /** The number of funcs in this pipeline. */\n    int num_funcs;\n\n    /** An internal base id used to identify the funcs in this pipeline. */\n    int first_func_id;\n\n    /** The number of times this pipeline has been run. */\n    int runs;\n\n    /** The total number of samples taken inside of this pipeline. */\n    int samples;\n\n    /** The total number of memory allocation of funcs in this pipeline. */\n    int num_allocs;\n};\n\n/** The global state of the profiler. */\nstruct halide_profiler_state {\n    /** Guards access to the fields below. If not locked, the sampling\n     * profiler thread is free to modify things below (including\n     * reordering the linked list of pipeline stats). */\n    struct halide_mutex lock;\n\n    /** The amount of time the profiler thread sleeps between samples\n     * in milliseconds. Defaults to 1 */\n    int sleep_time;\n\n    /** An internal id used for bookkeeping. */\n    int first_free_id;\n\n    /** The id of the current running Func. Set by the pipeline, read\n     * periodically by the profiler thread. */\n    int current_func;\n\n    /** The number of threads currently doing work. */\n    int active_threads;\n\n    /** A linked list of stats gathered for each pipeline. */\n    struct halide_profiler_pipeline_stats *pipelines;\n\n    /** Retrieve remote profiler state. Used so that the sampling\n     * profiler can follow along with execution that occurs elsewhere,\n     * e.g. on a DSP. If null, it reads from the int above instead. */\n    void (*get_remote_profiler_state)(int *func, int *active_workers);\n\n    /** Is the profiler thread running. */\n    bool started;\n};\n\n/** Profiler func ids with special meanings. */\nenum {\n    /// current_func takes on this value when not inside Halide code\n    halide_profiler_outside_of_halide = -1,\n    /// Set current_func to this value to tell the profiling thread to\n    /// halt. It will start up again next time you run a pipeline with\n    /// profiling enabled.\n    halide_profiler_please_stop = -2\n};\n\n/** Get a pointer to the global profiler state for programmatic\n * inspection. Lock it before using to pause the profiler. */\nextern struct halide_profiler_state *halide_profiler_get_state();\n\n/** Get a pointer to the pipeline state associated with pipeline_name.\n * This function grabs the global profiler state's lock on entry. */\nextern struct halide_profiler_pipeline_stats *halide_profiler_get_pipeline_state(const char *pipeline_name);\n\n/** Reset all profiler state.\n * WARNING: Do NOT call this method while any halide pipeline is\n * running; halide_profiler_memory_allocate/free and\n * halide_profiler_stack_peak_update update the profiler pipeline's\n * state without grabbing the global profiler state's lock. */\nextern void halide_profiler_reset();\n\n/** Print out timing statistics for everything run since the last\n * reset. Also happens at process exit. */\nextern void halide_profiler_report(void *user_context);\n\n/// \\name \"Float16\" functions\n/// These functions operate of bits (``uint16_t``) representing a half\n/// precision floating point number (IEEE-754 2008 binary16).\n//{@\n\n/** Read bits representing a half precision floating point number and return\n *  the float that represents the same value */\nextern float halide_float16_bits_to_float(uint16_t);\n\n/** Read bits representing a half precision floating point number and return\n *  the double that represents the same value */\nextern double halide_float16_bits_to_double(uint16_t);\n\n// TODO: Conversion functions to half\n\n//@}\n\n#ifdef __cplusplus\n} // End extern \"C\"\n#endif\n\n#ifdef __cplusplus\n\nnamespace {\ntemplate<typename T> struct check_is_pointer;\ntemplate<typename T> struct check_is_pointer<T *> {};\n}\n\n/** Construct the halide equivalent of a C type */\ntemplate<typename T>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of() {\n    // Create a compile-time error if T is not a pointer (without\n    // using any includes - this code goes into the runtime).\n    check_is_pointer<T> check;\n    (void)check;\n    return halide_type_t(halide_type_handle, 64);\n}\n\ntemplate<>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<float>() {\n    return halide_type_t(halide_type_float, 32);\n}\n\ntemplate<>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<double>() {\n    return halide_type_t(halide_type_float, 64);\n}\n\ntemplate<>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<bool>() {\n    return halide_type_t(halide_type_uint, 1);\n}\n\ntemplate<>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint8_t>() {\n    return halide_type_t(halide_type_uint, 8);\n}\n\ntemplate<>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint16_t>() {\n    return halide_type_t(halide_type_uint, 16);\n}\n\ntemplate<>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint32_t>() {\n    return halide_type_t(halide_type_uint, 32);\n}\n\ntemplate<>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint64_t>() {\n    return halide_type_t(halide_type_uint, 64);\n}\n\ntemplate<>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int8_t>() {\n    return halide_type_t(halide_type_int, 8);\n}\n\ntemplate<>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int16_t>() {\n    return halide_type_t(halide_type_int, 16);\n}\n\ntemplate<>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int32_t>() {\n    return halide_type_t(halide_type_int, 32);\n}\n\ntemplate<>\nHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int64_t>() {\n    return halide_type_t(halide_type_int, 64);\n}\n\n#endif\n\n#endif // HALIDE_HALIDERUNTIME_H\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Source/Common/File.cpp": "//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\n\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS // \"secure\" CRT not available on all platforms  --add this at the top of all CPP files that give \"function or variable may be unsafe\" warnings\n#endif\n#define _CRT_NONSTDC_NO_DEPRECATE // make VS accept POSIX functions without _\n\n#include \"Basics.h\"\n#define FORMAT_SPECIALIZE // to get the specialized version of the format routines\n#include \"File.h\"\n#include \"Config.h\"\n#include <string>\n#include <stdint.h>\n#include <locale>\n#include <unordered_map>\n#ifdef _WIN32\n#define NOMINMAX\n#include \"Windows.h\"\n#include <VersionHelpers.h>\n#include <Shlwapi.h>\n#pragma comment(lib, \"Shlwapi.lib\")\n#endif\n#ifdef __unix__\n#include <unistd.h>\n#include <linux/limits.h> // for PATH_MAX\n#endif\n\n#define PCLOSE_ERROR -1\n#define WRITE_BUFFER_SIZE (1024 * 1024)\n\nnamespace Microsoft { namespace MSR { namespace CNTK {\n\n// File creation\n// filename - the path\n// fileOptions - options to open the file\nFile::File(const std::wstring& filename, int fileOptions)\n{\n    Init(filename.c_str(), fileOptions);\n}\n\nFile::File(const std::string& filename, int fileOptions)\n{\n    // this converts from string to wstring, and then to wchar_t*\n    Init(msra::strfun::utf16(filename).c_str(), fileOptions);\n}\n\nFile::File(const wchar_t* filename, int fileOptions)\n{\n    Init(filename, fileOptions);\n}\n\ntemplate<class String>\nstatic bool IsNonFilePath(const String& filename)\n{\n    return\n        filename.front() == '|' ||                    // \"| command\": output pipe\n        filename.back()  == '|' ||                    // \"command |\": input pipe\n        (filename.size() == 1 && filename[0] == '-'); // \"-\": stdin/stdout\n}\n\n// test if a file exists\n// If the pathname is a pipe, it is considered to exist.\ntemplate<class String>\n/*static*/ bool File::Exists(const String& filename)\n{\n    return IsNonFilePath(filename) || fexists(filename);\n}\n\ntemplate /*static*/ bool File::Exists<string> (const string&  filename);\ntemplate /*static*/ bool File::Exists<wstring>(const wstring& filename);\n\ntemplate<class String>\n/*static*/ void File::MakeIntermediateDirs(const String& filename)\n{\n    if (!IsNonFilePath(filename))\n        msra::files::make_intermediate_dirs(filename);\n}\n\n//template /*static*/ void File::MakeIntermediateDirs<string> (const string&  filename); // implement this if needed\ntemplate /*static*/ void File::MakeIntermediateDirs<wstring>(const wstring& filename);\n\n// all constructors call this\nvoid File::Init(const wchar_t* filename, int fileOptions)\n{\n    m_filename = filename;\n    m_options = fileOptions;\n    if (m_filename.empty())\n        RuntimeError(\"File: filename is empty\");\n    const auto outputPipe = (m_filename.front() == '|');\n    const auto inputPipe  = (m_filename.back()  == '|');\n    // translate the options string into a string for fopen()\n    const auto reading = !!(fileOptions & fileOptionsRead);\n    const auto writing = !!(fileOptions & fileOptionsWrite);\n    if (!reading && !writing)\n        RuntimeError(\"File: either fileOptionsRead or fileOptionsWrite must be specified\");\n    // convert fileOptions to fopen()'s mode string\n    wstring options = reading ? L\"r\" : L\"\";\n    if (writing)\n    {\n        // if we already are reading the file, change to read/write\n        options.clear();\n        options.append(L\"w\");\n        if (!outputPipe && m_filename != L\"-\")\n        {\n            options.append(L\"+\");\n            msra::files::make_intermediate_dirs(m_filename.c_str()); // writing to regular file -> also create the intermediate directories as a convenience\n        }\n    }\n    if (fileOptions & fileOptionsBinary)\n        options += L\"b\";\n    else\n        options += L\"t\";\n    // add sequential flag to allocate big read buffer\n    if (fileOptions & fileOptionsSequential)\n        options += L\"S\";\n    // now open the file\n    // Special path syntax understood here:\n    //  - \"-\" refers to stdin or stdout\n    //  - \"|cmd\" writes to a pipe\n    //  - \"cmd|\" reads from a pipe\n    m_pcloseNeeded = false;\n    m_seekable = false;\n    if (m_filename == L\"-\") // stdin/stdout\n    {\n        if (writing && reading)\n            RuntimeError(\"File: cannot specify fileOptionsRead and fileOptionsWrite at once with path '-'\");\n        m_file = writing ? stdout : stdin;\n    }\n    else if (outputPipe || inputPipe) // pipe syntax\n    {\n        if (inputPipe && outputPipe)\n            RuntimeError(\"File: pipes cannot specify fileOptionsRead and fileOptionsWrite at once\");\n        if (inputPipe != reading)\n            RuntimeError(\"File: pipes must use consistent fileOptionsRead/fileOptionsWrite\");\n        const auto command = inputPipe ? m_filename.substr(0, m_filename.size() - 1) : m_filename.substr(1);\n        m_file = _wpopen(command.c_str(), options.c_str());\n        if (!m_file)\n            RuntimeError(\"File: error exexuting pipe command '%S': %s\", command.c_str(), strerror(errno));\n        m_pcloseNeeded = true;\n    }\n    else\n        attempt([=]() // regular file: use a retry loop\n                {\n                    m_file = fopenOrDie(filename, options.c_str());\n                    m_seekable = true;\n                });\n}\n\n// determine the directory for a given pathname\n// (wstring only for now; feel free to make this a template if needed)\n/*static*/ wstring File::DirectoryPathOf(wstring path)\n{\n#ifdef _WIN32\n    // Win32 accepts forward slashes, but it seems that PathRemoveFileSpec() does not\n    // TODO:\n    // \"PathCchCanonicalize does the / to \\ conversion as a part of the canonicalization, it's\n    // probably a good idea to do that anyway since I suspect that the '..' characters might\n    // confuse the other PathCch functions\" [Larry Osterman]\n    // \"Consider GetFullPathName both for canonicalization and last element finding.\" [Jay Krell]\n    path = msra::strfun::ReplaceAll<wstring>(path, L\"/\", L\"\\\\\");\n\n    HRESULT hr;\n    if (IsWindows8OrGreater()) // PathCchRemoveFileSpec() only available on Windows 8+\n    {\n        typedef HRESULT(*PathCchRemoveFileSpecProc)(_Inout_updates_(_Inexpressible_(cchPath)) PWSTR, _In_ size_t);\n        HINSTANCE hinstLib = LoadLibrary(TEXT(\"api-ms-win-core-path-l1-1-0.dll\"));\n        if (hinstLib == nullptr)\n            RuntimeError(\"DirectoryPathOf: LoadLibrary() unexpectedly failed.\");\n        PathCchRemoveFileSpecProc PathCchRemoveFileSpec = reinterpret_cast<PathCchRemoveFileSpecProc>(GetProcAddress(hinstLib, \"PathCchRemoveFileSpec\"));\n        if (!PathCchRemoveFileSpec)\n            RuntimeError(\"DirectoryPathOf: GetProcAddress() unexpectedly failed.\");\n\n        // this is the actual function call we care about\n        hr = PathCchRemoveFileSpec(&path[0], path.size());\n\n        FreeLibrary(hinstLib);\n    }\n    else // on Windows 7-, use older PathRemoveFileSpec() instead\n        hr = PathRemoveFileSpec(&path[0]) ? S_OK : S_FALSE;\n\n    if (hr == S_OK) // done\n        path.resize(wcslen(&path[0]));\n    else if (hr == S_FALSE) // nothing to remove: use .\n        path = L\".\";\n    else\n        RuntimeError(\"DirectoryPathOf: Path(Cch)RemoveFileSpec() unexpectedly failed with 0x%08x.\", (unsigned int)hr);\n#else\n    auto pos = path.find_last_of(L\"/\");\n    if (pos != path.npos)\n        path.erase(pos);\n    else // if no directory path at all, use current directory\n        return L\".\";\n#endif\n    return path;\n}\n\n// determine the file name for a given pathname\n// (wstring only for now; feel free to make this a template if needed)\n/*static*/ wstring File::FileNameOf(wstring path)\n{\n#ifdef WIN32\n    static const wstring delim = L\"\\\\:/\";\n#else\n    static const wstring delim = L\"/\";\n#endif\n    auto pos = path.find_last_of(delim);\n    if (pos != path.npos)\n        return path.substr(pos + 1);\n    else // no directory path\n        return path;\n}\n\n// get path of current executable\n/*static*/ wstring File::GetExecutablePath()\n{\n#ifdef WIN32\n    wchar_t path[33000];\n    if (GetModuleFileNameW(NULL, path, _countof(path)) == 0)\n        LogicError(\"GetExecutablePath: GetModuleFileNameW() unexpectedly failed.\");\n    return path;\n#else\n    // from http://stackoverflow.com/questions/4025370/can-an-executable-discover-its-own-path-linux\n    pid_t pid = getpid();\n    char path[PATH_MAX + 1] = { 0 };\n    sprintf(path, \"/proc/%d/exe\", pid);\n    char dest[PATH_MAX + 1] = { 0 };\n    if (readlink(path, dest, PATH_MAX) == -1)\n        RuntimeError(\"GetExecutableDirectory: readlink() call failed.\");\n    else\n        return msra::strfun::utf16(dest);\n#endif\n}\n\n// skip to given delimiter character\nvoid File::SkipToDelimiter(int delim)\n{\n    int ch = 0;\n\n    while (ch != delim)\n    {\n        ch = fgetc(m_file);\n        if (feof(m_file))\n        {\n            printf(\"Unexpected end of file\\n\");\n            LogicError(\"Unexpected end of file\\n\");\n        }\n    }\n}\n\nbool File::IsTextBased()\n{\n    return !!(m_options & fileOptionsText);\n}\n\n// File Destructor\n// closes the file\n// Note: this does not check for errors when the File corresponds to pipe stream. In this case, use Flush() before closing a file you are writing.\nFile::~File(void)\n{\n    int rc = 0;\n    if (m_pcloseNeeded)\n    {\n        rc = _pclose(m_file);\n        if ((rc == PCLOSE_ERROR) && !std::uncaught_exception())\n        {\n            RuntimeError(\"File: failed to close file at %S\", m_filename.c_str());\n        }\n    }\n    else if (m_file != stdin && m_file != stdout && m_file != stderr)\n    {\n        rc = fclose(m_file);\n        if ((rc != FCLOSE_SUCCESS) && !std::uncaught_exception())\n        {\n            RuntimeError(\"File: failed to close file at %S\", m_filename.c_str());\n        }\n    }\n}\n\nvoid File::Flush()\n{\n    fflushOrDie(m_file);\n}\n\n// read a line\n// End of line is denoted by one of these, i.e. we don't support the old Mac OS convention of CR\n//  - LF\n//  - CR+LF\n//  - EOF\nstatic bool fgetc(char& c, FILE * f) { int ci = getc(f); c = (char) ci; return ci != EOF; }\n\nstatic inline bool BeginsWithUnicodeBOM(const char * s)\n{\n    return ((unsigned char)s[0] == 0xEF && (unsigned char)s[1] == 0xBB && (unsigned char)s[2] == 0xBF);\n}\n\n// read a 8-bit string until newline is hit\ntemplate<class STRING>\nstatic void fgets(STRING & s, FILE * f)\n{\n    s.resize(0);\n    char c;\n    while (fgetc(c, f))\n    {\n        if (c == '\\n' || c == '\\r')\n        {\n            if (c == '\\r' && (!fgetc(c, f) || c != '\\n'))\n                RuntimeError(\"fgets: malformed text file, CR without LF\");\n            break;\n        }\n        s.push_back(c);\n        // strip Unicode BOM\n        // We strip it from any string, not just at the start.\n        // This allows to UNIX-'cat' multiple UTF-8 files with BOMs.\n        // Since the BOM is otherwise invalid within a file, this is well-defined and upwards compatible.\n        if (s.size() == 3 && BeginsWithUnicodeBOM(s.c_str()))\n            s.clear();\n    }\n}\n\n// GetLine - get a line from the file\n// str - string\nvoid File::GetLine(string& str)\n{\n    fgets(str, m_file);\n}\n\nstatic void PushBackString(vector<string>& lines,  const string& s) { lines.push_back(s); }\nstatic void PushBackString(vector<wstring>& lines, string& s)       { lines.push_back(msra::strfun::utf16(s)); }\n\n// GetLines - get all lines from a file\ntemplate <typename STRING>\nstatic void FileGetLines(File& file, /*out*/ std::vector<STRING>& lines)\n{\n    lines.clear();\n    string line;\n    while (!file.IsEOF())\n    {\n        file.GetLine(line);\n        PushBackString(lines, line);\n    }\n}\nvoid File::GetLines(std::vector<std::wstring>& lines)\n{\n    FileGetLines(*this, lines);\n};\nvoid File::GetLines(std::vector<std::string>& lines)\n{\n    FileGetLines(*this, lines);\n}\n\n// Put a zero/space terminated wstring into a file\n// val - value to write to the file\nFile& File::operator<<(const std::wstring& val)\n{\n    WriteString(val.c_str());\n    return *this;\n}\n\n// Put a zero/space terminated string into a file\n// val - value to write to the file\nFile& File::operator<<(const std::string& val)\n{\n    WriteString(val.c_str());\n    return *this;\n}\n\n// Put a marker in the file, the marker depends on the file type\n// marker - marker to place in the file\nFile& File::operator<<(FileMarker marker)\n{\n    File& file = *this;\n    switch (marker)\n    {\n    case fileMarkerBeginFile: // beginning of file marker\n        // TODO: why not write a BOM?\n        break;\n    case fileMarkerEndFile: // end of file marker\n        // use ^Z for end of file for text files\n        // TODO: What??\n        if (m_options & fileOptionsText)\n            file << char(26);\n        break;\n    case fileMarkerBeginList: // Beginning of list marker\n        // no marker written for either\n        break;\n    case fileMarkerListSeparator: // separate elements of a list\n        // do nothing for now, built in space deliminter for all types (before type)\n        // future: make this customizable, so you can specify a separator (i.e. ',')\n        break;\n    case fileMarkerEndList: // end of line/list marker\n        if (m_options & fileOptionsText)\n            file.WriteString(\"\\r\\n\");\n        break;\n    case fileMarkerBeginSection: // beginning of section\n    case fileMarkerEndSection:   // end of section\n        assert(false);           // sections should use a string modifier\n        break;\n    }\n    return file;\n}\n\n// PutMarker for beginning of list support (lists with a count)\n// count - [in] the number of elements in the list\nFile& File::PutMarker(FileMarker marker, size_t count)\n{\n    assert(marker == fileMarkerBeginList);\n    marker; // only beginning of list supported for count  markers\n    *this << count;\n    return *this;\n}\n\n// PutMarker for section beginning and ending tags\n// section - [in]name of section\nFile& File::PutMarker(FileMarker marker, const std::string& section)\n{\n    File& file = *this;\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    file << section;\n    return file;\n}\n\n// PutMarker for section beginning and ending tags\n// section - [in]name of section\nFile& File::PutMarker(FileMarker marker, const std::wstring& section)\n{\n    File& file = *this;\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    file << section;\n    return file;\n}\n\n// Get a zero terminated wstring from a file\n// val - value to read from the file\nFile& File::operator>>(std::wstring& val)\n{\n    if (IsTextBased())\n        val = fgetwtoken(m_file);\n    else\n        val = fgetwstring(m_file);\n    return *this;\n}\n\n// Get a zero terminated string from a file\n// val - value to read from the file\nFile& File::operator>>(std::string& val)\n{\n    if (IsTextBased())\n        val = fgettoken(m_file);\n    else\n        val = fgetstring(m_file);\n    return *this;\n}\n\n// ReadChars - read a specified number of characters, and reset read pointer if requested\n// val - [in,out] return value will be returned here\n// cnt - number of characters to read\n// reset - reset the read pointer\nvoid File::ReadChars(std::string& val, size_t cnt, bool reset)\n{\n    size_t pos = 0; // (initialize to keep compiler happy)\n    if (reset)\n        pos = GetPosition();\n    val.resize(cnt);\n    char* str = const_cast<char*>(val.c_str());\n    for (int i = 0; i < cnt; ++i)\n        *this >> str[i];\n    if (reset)\n        SetPosition(pos);\n}\n\n// ReadChars - read a specified number of characters, and reset read pointer if requested\n// val - [in,out] return value will be returned here\n// cnt - number of characters to read\n// reset - reset the read pointer\nvoid File::ReadChars(std::wstring& val, size_t cnt, bool reset)\n{\n    size_t pos = 0; // (initialize to keep compiler happy)\n    if (reset)\n        pos = GetPosition();\n    val.resize(cnt);\n    wchar_t* str = const_cast<wchar_t*>(val.c_str());\n    for (int i = 0; i < cnt; ++i)\n        *this >> str[i];\n    if (reset)\n        SetPosition(pos);\n}\n\n// WriteString - outputs a string into the file\n// str - the string to output\n// size - size of the string to output, if zero null terminated\nvoid File::WriteString(const char* str, int size)\n{\n    if (size > 0)\n    {\n        fwprintf(m_file, L\" %.*hs\", size, str);\n    }\n    else\n    {\n        if (IsTextBased())\n            fwprintf(m_file, L\" %hs\", str);\n        else\n            fputstring(m_file, str);\n    }\n}\n\n// ReadString - reads a string into the file\n// str - the string buffer to read the string into\n// size - size of the string buffer incl. zero terminator (we fail if input is too long)\nvoid File::ReadString(char* str, int size)\n{\n    if (IsTextBased())\n    {\n        fgettoken(m_file, str, size);\n        if (BeginsWithUnicodeBOM(str))\n            for (; str[3]; str++)\n                str[0] = str[3];    // delete it from start of line\n    }\n    else\n        fgetstring(m_file, str, size);\n}\n\n// WriteString - outputs a string into the file\n//   if writing to text based file and spaces are embedded, writes quotes around string\n//   BUGBUG: This should be consistent between char and wchar_t versions\n// str - the string to output\n// size - size of the string to output, if zero null terminated\nvoid File::WriteString(const wchar_t* str, int size)\n{\n#ifdef EMBEDDED_SPACES\n    // start of implementation of embedded space support with quoting\n    // not complete, not sure if we need it\n    bool spacefound = false;\n    wchar_t quote = 0;\n    if (IsTextBased())\n    {\n        // search for embedded spaces and quotes\n        wstring searchString = L\" \\\"'~\";\n        const wchar_t* result = NULL;\n        while (result = wcspbrk(str, searchString.c_str()))\n        {\n            if (IsWhiteSpace(*result))\n                spacefound = true;\n            searchString.find(*result, 0);\n        }\n    }\n#endif\n    if (size > 0)\n    {\n        fwprintf(m_file, L\" %.*ls\", size, str);\n    }\n    else\n    {\n        if (IsTextBased())\n            fwprintf(m_file, L\" %ls\", str);\n        else\n            fputstring(m_file, str);\n    }\n}\n\n// ReadString - reads a string from the file\n// str - the string buffer to read the string into\n// size - size of the string string buffer\nvoid File::ReadString(wchar_t* str, int size)\n{\n    if (IsTextBased())\n        fgettoken(m_file, str, size);\n    else\n        fgetstring(m_file, str, size);\n}\n\n// IsUnicodeBOM - is the next characters the Unicode Byte Order Mark?\n// skip - skip the BOM mark if found (defaults to false)\n// returns - true if on a unicode BOM\nbool File::IsUnicodeBOM(bool skip)\n{\n    File& file = *this;\n    uint64_t pos = GetPosition(); // Note: This is where we will fail for non-seekable streams.\n    // if we aren't at the beginning of the file, it can't be the byte order mark\n    if (pos != 0)\n        return false;\n\n    // only exists for UNICODE files\n    bool found = false;\n    if (m_options & fileOptionsText)\n    {\n        char val[3] = { 0 };\n        for (size_t i = 0; i < _countof(val) && !file.IsEOF(); i++)\n            val[i] = (char) getc(m_file);\n        found = BeginsWithUnicodeBOM(val);\n    }\n    // restore pointer if no BOM or we aren't skipping it\n    if (!found || !skip)\n    {\n        SetPosition(pos);\n    }\n    return found;\n}\n\n//Size - return the size of the file\n// WARNING: calling this will reset the EOF marker, so do so with care\nsize_t File::Size()\n{\n    if (!CanSeek())\n        RuntimeError(\"File: attempted to get Size() on non-seekable stream\");\n    return filesize(m_file);\n}\n\n// IsEOF - if we have read past the end of the file\n// return - true if end of file has been found\nbool File::IsEOF()\n{\n    return !!feof(m_file);\n}\n\n// IsWhiteSpace - are the next characters whitespace (space, \\t, \\r, \\n, etc.)?\n// skip - skip the whitespace if found (defaults to false)\n// returns - true if whitespace found\n// TODO: This function actually consumes the white-space characters. Document that behavior.\nbool File::IsWhiteSpace(bool skip)\n{\n    bool spaceFound = false;\n    bool spaceCur = false;\n    int c;\n    do\n    {\n        c = fgetc(m_file);\n        if (c == EOF) // hit the end\n            return spaceFound;\n        spaceCur = !!isspace(c);\n        spaceFound = spaceFound || spaceCur;\n    } while (spaceCur && skip);\n    // put back the last character (EOF is ignored)\n    ungetc(c, m_file);\n\n    return spaceFound;\n}\n\n// EndOfLineOrEOF - are the next characters an end of line sequence ('\\r\\n') possibly preceeded by (space, \\t)? EOF detected too\n// skip - skip the end of line if found (defaults to false)\n// returns - true if end of line found, EOF if end of file found, or false if nothing found, in which case any leading space will have been stripped\nint File::EndOfLineOrEOF(bool skip)\n{\n    if (IsTextBased())\n        return fskipNewline(m_file, skip);\n    else\n        return false;\n}\n\n// Buffer write stream\nint File::Setvbuf()\n{\n    return setvbuf(this->m_file, NULL, _IOFBF, WRITE_BUFFER_SIZE);\n}\n\n// Get a marker from the file\n// some are ignored others are expecting characters\n// must use GetMarker methods for those that require parameters\nFile& File::operator>>(FileMarker marker)\n{\n    File& file = *this;\n\n    switch (marker)\n    {\n    case fileMarkerBeginFile: // beginning of file marker\n        // check for Unicode BOM marker\n        if (IsTextBased() && CanSeek()) // files from a pipe cannot begin with Unicode BOM, sorry\n            IsUnicodeBOM(true);\n        break;\n    case fileMarkerEndFile: // end of file marker, should we throw if it's not the end of the file?\n        if (!IsEOF())\n            RuntimeError(\"fileMarkerEndFile not found\");\n        break;\n    case fileMarkerBeginList: // Beginning of list marker\n        // no marker written unless an list with a count header\n        break;\n    case fileMarkerListSeparator: // separate elements of a list\n        // do nothing for now, built in space deliminter for all types (before type)\n        // future: make this customizable, so you can specify a separator (i.e. ',')\n        break;\n    case fileMarkerEndList: // end of line/list marker\n        if (IsTextBased())\n        {\n            int found = EndOfLineOrEOF(true);\n            if (found != (int) true) // EOF can also be returned\n                RuntimeError(\"Newline not found\");\n        }\n        break;\n    case fileMarkerBeginSection: // beginning of section\n    case fileMarkerEndSection:   // end of section\n        assert(false);           // sections should use a string modifier\n        break;\n    }\n    return file;\n}\n\n// Get a marker from the file\n// some are ignored others are expecting characters\n// must use GetMarker methods for those that require parameters\n// This function will fail for non-seekable streams.\nbool File::IsMarker(FileMarker marker, bool skip)\n{\n    bool retval = false;\n    switch (marker)\n    {\n    case fileMarkerBeginFile: // beginning of file marker\n        // check for Unicode BOM marker\n        retval = IsUnicodeBOM(skip);\n        break;\n    case fileMarkerEndFile: // end of file marker, should we throw if it's not the end of the file?\n        retval = IsEOF();\n        break;\n    case fileMarkerBeginList: // Beginning of list marker\n        // no marker written unless an list with a count header\n        // should we try to validate BOL header (just know it's an int, not negative, etc.)\n        break;\n    case fileMarkerListSeparator: // separate elements of a list\n        // do nothing for now, built in space deliminter for all types (before type)\n        // future: make this customizable, so you can specify a separator (i.e. ',')\n        break;\n    case fileMarkerEndList: // end of line/list marker\n        if (IsTextBased())\n        {\n            int eolSeen = false;\n            eolSeen = EndOfLineOrEOF(skip);\n            retval = (eolSeen == (int) true);\n        }\n        break;\n    case fileMarkerBeginSection: // beginning of section\n    case fileMarkerEndSection:   // end of section\n        // can't destinquish from a string currently\n        break;\n    }\n    return retval;\n}\n\n// GetMarker for beginning of list support (lists with a count)\n// count - [out] returns the number of elements in the list\nFile& File::GetMarker(FileMarker marker, size_t& count)\n{\n    assert(marker == fileMarkerBeginList);\n    marker; // only beginning of list supported for count file markers\n    // use text based try, so it can fail without an exception\n    if (IsTextBased())\n        ftrygetText(m_file, count);\n    else\n        fget(m_file, count);\n    return *this;\n}\n\n// GetMarker for section beginning and ending tags\n// section - [in]name of section that is expected\nFile& File::GetMarker(FileMarker marker, const std::string& section)\n{\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    string str;\n    *this >> str;\n    if (str != section)\n        RuntimeError(\"section name mismatch %s != %s\", str.c_str(), section.c_str());\n    return *this;\n}\n\n// GetMarker for section beginning and ending tags\n// section - [in]name of section that is expected\nFile& File::GetMarker(FileMarker marker, const std::wstring& section)\n{\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    wstring str;\n    *this >> str;\n    if (str != section)\n        RuntimeError(\"section name mismatch %ls != %ls\", str.c_str(), section.c_str());\n    return *this;\n}\n\n// TryGetMarker for section beginning and ending tags\n// section - [in]name of section that is expected\nbool File::TryGetMarker(FileMarker marker, const std::wstring& section)\n{\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    size_t pos = GetPosition();\n    std::wstring str;\n    try\n    {\n        *this >> str;\n        if (str == section)\n            return true;\n    }\n    catch (...)\n    {\n        // eat\n    }\n    SetPosition(pos);\n    return false;\n}\n\n// TryGetMarker for section beginning and ending tags\n// section - [in]name of section that is expected\nbool File::TryGetMarker(FileMarker marker, const std::string& section)\n{\n    // only the section markers take a string parameter\n    assert(marker == fileMarkerBeginSection || marker == fileMarkerEndSection);\n    marker;\n    size_t pos = GetPosition();\n    std::string str;\n    try\n    {\n        *this >> str;\n        if (str == section)\n            return true;\n    }\n    catch (...)\n    {\n        return false;\n    }\n    SetPosition(pos);\n    return false;\n}\n\n// GetPosition - Get position in a file\nuint64_t File::GetPosition()\n{\n    if (!CanSeek())\n        RuntimeError(\"File: attempted to GetPosition() on non-seekable stream\");\n    return fgetpos(m_file);\n}\n\n// Set the position in the file\n// pos - position in the file\nvoid File::SetPosition(uint64_t pos)\n{\n    if (!CanSeek())\n        RuntimeError(\"File: attempted to SetPosition() on non-seekable stream\");\n    fsetpos(m_file, pos);\n}\n\n// helper to load a matrix from a stream (file or string literal)\n// The input string is expected to contain one line per matrix row (natural printing order for humans).\n// Inputs:\n//  - getLineFn: a lambda that fills a string with the next input line (=next matrix row)\n//               The lambda returns an empty string to denote the end.\n// Outputs:\n//  - numRows, numCols: matrix dimensions inferred from newlines\n//  - array: matrix values in column-major order (ready for SetValue())\ntemplate<class ElemType, class F>\nstatic void LoadMatrixFromLambda(const F& getLineFn, const wstring& locationForMsg, vector<ElemType>& array, size_t& /*out*/ numRows, size_t& /*out*/ numCols)\n{\n    // load matrix into vector of vectors (since we don't know the size in advance)\n    vector<ElemType> vec;\n    std::vector<std::vector<ElemType>> elements;\n    size_t numColsInFirstRow = 0;\n\n    std::string line;\n    for(;;)\n    {\n        // get next input line\n        getLineFn(line);\n        if (line.empty())\n            break;\n\n        // tokenize and parse\n        vec.clear();\n        const char * p = line.c_str();\n        for (;;)\n        {\n            while (isspace((unsigned char)*p))\n                p++;\n            if (!*p)\n                break;\n            char* ep; // will be set to point to first character that failed parsing\n            double value = strtod(p, &ep);\n            if (*ep != 0 && !isspace((unsigned char)*ep))\n                RuntimeError(\"LoadMatrixFromTextFile: Malformed number '%.15s...' in row %d of %ls\", p, (int)elements.size(), locationForMsg.c_str());\n            p = ep;\n            vec.push_back((ElemType)value);\n        }\n\n        size_t numElementsInRow = vec.size();\n        if (elements.empty())\n            numColsInFirstRow = numElementsInRow;\n        else if (numElementsInRow != numColsInFirstRow)\n            RuntimeError(\"Row %d has column dimension %d, inconsistent with previous dimension %d: %ls\", (int)elements.size(), (int)numElementsInRow, (int)numColsInFirstRow, locationForMsg.c_str());\n\n        elements.push_back(vec);\n    }\n\n    numRows = elements.size();\n    numCols = numColsInFirstRow;\n\n    // Perform transpose when copying elements from vectors to ElemType[],\n    // in order to store in column-major format.\n    array.resize(numRows * numCols);\n    for (int i = 0; i < numCols; i++)\n        for (int j = 0; j < numRows; j++)\n            array[i * numRows + j] = elements[j][i];\n}\n\n// Load matrix from file. The file is a simple text file consisting of one line per matrix row, where each line contains the elements of the row separated by white space.\ntemplate <class ElemType>\n/*static*/ vector<ElemType> File::LoadMatrixFromTextFile(const std::wstring& filePath, size_t& /*out*/ numRows, size_t& /*out*/ numCols)\n{\n    File myfile(filePath, FileOptions::fileOptionsText | FileOptions::fileOptionsRead);\n\n    // LoadMatrixFromLambda() reads its input lines from the following lambda\n    // return the next input line, or empty string when the end is reached\n    auto getLineFn = [&](string& line)\n    {\n        while (!myfile.IsEOF())\n        {\n            myfile.GetLine(line);\n            if (!line.empty())\n                return; // got the next line to return\n            // End of file manifests as an empty line at the end.\n            // Also, we allow empty lines within the file, as that may help to visually structure matrices that really are >2D tensors.\n        }\n        line.clear(); // empty line indicates end of file\n    };\n\n    vector<ElemType> array;\n    LoadMatrixFromLambda(getLineFn, filePath, array, numRows, numCols);\n    return array;\n}\n\n// Load matrix from file. The file is a simple text file consisting of one line per matrix row, where each line contains the elements of the row separated by white space.\ntemplate <class ElemType>\n/*static*/ vector<ElemType> File::LoadMatrixFromStringLiteral(const std::string& literal, size_t& /*out*/ numRows, size_t& /*out*/ numCols)\n{\n    // LoadMatrixFromLambda() reads its input lines from the following lambda\n    // return the next input line, or empty string when the end is reached\n    size_t pos = 0; // cursor for traversing the string. The lambda takes this by reference and modifies it.\n    auto getLineFn = [&](string& line)\n    {\n        // find first non-blank character of line\n        pos = literal.find_first_not_of(\" \\r\\n\", pos); // skip previous line end and any leading spaces\n        if (pos == string::npos)\n            return line.clear(); // hit the end: return empty line\n        // find end of line\n        auto endPos = literal.find_first_of(\"\\r\\n\", pos + 1); // find line end\n        if (endPos == string::npos)\n            endPos = literal.size(); // no LF required at very end, so that it looks pretty in BS source code\n        line = literal.substr(pos, endPos - pos);\n        pos = endPos; // and advance cursor (we position it on the LF, which is skipped in next round)\n        return;\n    };\n\n    vector<ElemType> array;\n    LoadMatrixFromLambda(getLineFn, L\"string literal\", array, numRows, numCols);\n    return array;\n}\n\ntemplate vector<float>  File::LoadMatrixFromTextFile<float> (const std::wstring& filePath, size_t& /*out*/ numRows, size_t& /*out*/ numCols);\ntemplate vector<double> File::LoadMatrixFromTextFile<double>(const std::wstring& filePath, size_t& /*out*/ numRows, size_t& /*out*/ numCols);\n\ntemplate vector<float>  File::LoadMatrixFromStringLiteral<float> (const std::string& literal, size_t& /*out*/ numRows, size_t& /*out*/ numCols);\ntemplate vector<double> File::LoadMatrixFromStringLiteral<double>(const std::string& literal, size_t& /*out*/ numRows, size_t& /*out*/ numCols);\n\n#ifndef CNTK_COMPONENT_VERSION\n#error CNTK_COMPONENT_VERSION must be set\n#endif\n\nextern std::unordered_map<std::wstring, std::wstring> g_deprecatedReaderWriterNameMap;\n\n#ifdef _WIN32\n\nFARPROC Plugin::LoadInternal(const std::wstring& plugin, const std::string& proc, bool isCNTKPlugin)\n{\n    m_dllName = plugin;\n\n    if (isCNTKPlugin)\n    {\n        // map legacy names to new naming scheme\n        auto entry = g_deprecatedReaderWriterNameMap.find(m_dllName);\n        if (entry != g_deprecatedReaderWriterNameMap.end())\n            m_dllName = entry->second;\n\n        m_dllName += L\"-\" + msra::strfun::utf16(std::string(CNTK_COMPONENT_VERSION));\n    }\n\n    m_dllName += L\".dll\";\n    m_hModule = LoadLibrary(m_dllName.c_str());\n    if (m_hModule == NULL)\n        RuntimeError(\"Plugin not found: '%ls'\", m_dllName.c_str());\n    // create a variable of each type just to call the proper templated version\n    FARPROC entryPoint = GetProcAddress(m_hModule, proc.c_str());\n    if (entryPoint == nullptr)\n        RuntimeError(\"Symbol '%s' not found in plugin '%ls'\", proc.c_str(), m_dllName.c_str());\n    return entryPoint;\n}\n\n#else\n\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n\nvoid* Plugin::LoadInternal(const std::string& plugin, const std::string& proc, bool isCNTKPlugin)\n{\n    string soName = plugin;\n    wstring soNameW = msra::strfun::utf16(plugin);\n\n    if (isCNTKPlugin)\n    {\n        // map legacy names to new naming scheme\n        auto entry = g_deprecatedReaderWriterNameMap.find(soNameW);\n        if (entry != g_deprecatedReaderWriterNameMap.end())\n            soName = msra::strfun::utf8(entry->second);\n\n        soName += \"-\" + std::string(TOSTRING(CNTK_COMPONENT_VERSION));\n    }\n\n    soName += \".so\";\n    void* handle = dlopen(soName.c_str(), RTLD_LAZY);\n    if (handle == NULL)\n        RuntimeError(\"Plugin not found: '%s' (error: %s)\", soName.c_str(), dlerror());\n    void* entryPoint = dlsym(handle, proc.c_str());\n    if (entryPoint == nullptr)\n        RuntimeError(\"Symbol '%s' not found in plugin '%s'\", proc.c_str(), soName.c_str());\n    return entryPoint;\n}\n#endif\n\n}}}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tutorials/SLUHandsOn/slu.forward.lookahead.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tutorials/SLUHandsOn/slu.forward.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tutorials/SLUHandsOn/slu.forward.backward.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tutorials/SLUHandsOn/slu.forward.nobn.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tutorials/ImageHandsOn/cifar10.ResNet.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tutorials/ImageHandsOn/cifar10.pretrained.cmf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/bindings/python/doc/images/nn_layers.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/bindings/python/doc/images/lstm_cell.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/bindings/csharp/CNTKLibraryManagedDll/CNTKLibraryManagedDll-CPUOnly-KeyPair.snk",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/bindings/csharp/CNTKLibraryManagedDll/CNTKLibraryManagedDll-GPU-KeyPair.snk",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tools/cntk-binary-drop/linux/gpu/license/CUDNN_License.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tools/cntk-binary-drop/linux/gpu/license/CUDA_EULA.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tools/cntk-binary-drop/linux/1bitsgd/license/CUDNN_License.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tools/cntk-binary-drop/linux/1bitsgd/license/CUDA_EULA.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/Documents/PerformanceChart.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures.vsdm",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/SimpleDemoOutputReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN+TrainingCriterion.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CNTKArch.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CNNComputation.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/SimpleDemoErrorRateReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-1HiddenNN.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-WithDelayNode.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-EfficientGradient.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-ShareWeight.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/SequenceBatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CNNComputation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/SpeechErrorRate.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-EfficientGradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-2Inputs.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/ConfusionData100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-1HiddenNN.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/simpleRNN.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN+TrainingCriterion.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-2Inputs.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/SimpleDemoDataReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-WithDelayNode.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/ConfusionData1.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-ShareWeight.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/SequenceBatch.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CNTKArch.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-NaiveGradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/figures/CN-NaiveGradient.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Documentation/CNTK-TechReport/lyx/CNTKBook-20160217..pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Speech/Miscellaneous/TIMIT/AdditionalFiles/ConfusionData25.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Speech/Miscellaneous/TIMIT/AdditionalFiles/SpeechErrorRate.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Speech/Miscellaneous/TIMIT/AdditionalFiles/ConfusionData100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Speech/Miscellaneous/TIMIT/AdditionalFiles/ConfusionData1.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Speech/AN4/Data/000000000.chunk",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Image/Detection/FastRCNN/fastRCNN/utils/cython_bbox.cpython-34m.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Image/Detection/FastRCNN/fastRCNN/utils/cython_bbox.cp35-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Image/Detection/FastRCNN/fastRCNN/utils/cython_nms.cp35-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Image/Detection/FastRCNN/fastRCNN/utils/cython_nms.cp34-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Image/Detection/FastRCNN/fastRCNN/utils/cython_nms.cpython-34m.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Image/Detection/FastRCNN/fastRCNN/utils/cython_bbox.cp34-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Image/Detection/utils/cython_modules/cython_bbox.cpython-34m.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Image/Detection/utils/cython_modules/cpu_nms.cpython-34m.so",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Image/Detection/utils/cython_modules/cython_bbox.cp35-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Image/Detection/utils/cython_modules/cpu_nms.cp35-win_amd64.pyd",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Image/Classification/ResNet/zebra.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/SequenceToSequence/CMUDict/Data/cmudict-0.7b",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/SequenceToSequence/PennTreebank/AdditionalFiles/perplexity.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Extensibility/BinaryConvolution/BinaryConvolutionLib/halide/halide_convolve.a",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Extensibility/BinaryConvolution/BinaryConvolutionLib/halide/halide_convolve_nofeatures.a",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Extensibility/BinaryConvolution/BinaryConvolutionLib/halide/halide_convolve_nofeatures.lib",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Examples/Extensibility/BinaryConvolution/BinaryConvolutionLib/halide/halide_convolve.lib",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/EndToEndTests/Speech/Data/glob_0000.ark",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/EndToEndTests/Speech/Data/Features/000000000.chunk",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/EndToEndTests/Simple2d/AdditionalFiles/SimpleDemoOutputReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/EndToEndTests/Simple2d/AdditionalFiles/SimpleDemoErrorRateReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/EndToEndTests/Simple2d/AdditionalFiles/SimpleDemoDataReference.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/EndToEndTests/ParallelTraining/AsynchronousSGD/ASGD_Resnet.model.1",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/images/simple.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/images/green.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/images/chunk0.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/images/multi.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/images/blue.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/images/chunk1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/images/grayscale.png",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/images/black.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/images/red.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/100x100x3_jagged_sequences_dense.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/50x20_jagged_sequences_dense.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/Simple_dense.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/10x10_dense.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/50x20_jagged_sequences_sparse.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/10x10_sparse.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/ReaderTests/Data/CNTKBinaryReader/MNIST_dense.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/NetworkTests/BatchNorm_NDL_config.cntk",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/NetworkTests/Models/01_OneHidden.dnn",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/NetworkTests/Models/ResNet20_CIFAR10_DataAug.dnn",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/V2LibraryTests/data/v2.0.beta1.0.dictionary.proto.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/V2LibraryTests/data/batch.norm.no.sample.count.v2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/V2LibraryTests/data/batch.norm.no.sample.count.v1.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/V2LibraryTests/data/future.dictionary.proto.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/V2LibraryTests/data/past.dictionary.proto.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/V2LibraryTests/data/learner.checkpoint.backcompat.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/BrainScriptTests/Data/ComputationNetwork/01_OneHidden.dnn",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/BrainScriptTests/Data/ComputationNetwork/LR_reg.dnn",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Tests/UnitTests/BrainScriptTests/Data/ComputationNetwork/MC.dnn",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Source/Readers/LMSequenceReader/SentenceTest.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Source/CNTK/BrainScript/Doc/BrainScript--extending the CNTK config language, Frank Seide August 2015.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-cntk-2.0-uvmm4sjxmcagtor443lt75dr4dsif7xw/spack-src/Source/Extensibility/EvalWrapper/EvalWrapperKeyPair.snk"
    ],
    "total_files": 2399
}