{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-ce3zl6legfwapvbkomd75ulkqofqvktl/spack-src/src/hio_component.c": "/* -*- Mode: C; c-basic-offset:2 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2014-2018 Los Alamos National Security, LLC.  All rights\n *                         reserved. \n * $COPYRIGHT$\n * \n * Additional copyrights may follow\n * \n * $HEADER$\n */\n\n#include \"hio_internal.h\"\n\n#if USE_DYNAMIC_COMPONENTS\n#include <dlfcn.h>\n#include <dirent.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\nextern hio_component_t builtin_posix_component;\n#if HIO_USE_DATAWARP\nextern hio_component_t builtin_datawarp_component;\n#endif\n\n#define MAX_COMPONENTS 128\n\nstatic hio_component_t *hio_builtin_components[] = {\n#if HIO_USE_DATAWARP\n                                                    &builtin_datawarp_component,\n#endif\n                                                    &builtin_posix_component,\n                                                    NULL};\n\nstatic int hio_component_init_count = 0;\n\n#if USE_DYNAMIC_COMPONENTS\ntypedef struct hio_dynamic_component_t {\n  void *dl_ctx;\n  hio_component_t *component;\n} hio_dynamic_component_t;\n\nstatic hio_dynamic_component_t hio_external_components[MAX_COMPONENTS];\nstatic int hio_external_component_count;\n\nstatic int hioi_dynamic_component_init (hio_context_t context) {\n  const char *module_dir = HIO_PREFIX \"/lib/hio_\" PACKAGE_VERSION \"/modules\";\n  char component_name[128], component_symbol[512];\n  hio_component_t *component_ptr;\n  int rc = HIO_SUCCESS;\n  struct dirent *entry;\n  void *dl_ctx;\n  char *path;\n  DIR *dir;\n\n  hioi_log(context, HIO_VERBOSE_DEBUG_LOW, \"Looking for plugins in %s ...\", module_dir);\n\n  dir = opendir (module_dir);\n  if (NULL != dir) {\n    hio_dynamic_component_t *external_component = hio_external_components;\n\n    while (NULL != (entry = readdir (dir))) {\n      if ('.' == entry->d_name[0]) {\n        continue;\n      }\n\n      hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"Checking file %s\", entry->d_name);\n      if (strncmp (entry->d_name, \"hio_plugin_\", 11)) {\n        hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"File %s does not match expected name pattern. Skipping...\", entry->d_name);\n        continue;\n      }\n      sscanf (entry->d_name, \"hio_plugin_%128s\", component_name);\n\n      rc = asprintf (&path, \"%s/%s\", module_dir, entry->d_name);\n      if (0 > rc) {\n        rc = HIO_ERR_OUT_OF_RESOURCE;\n        break;\n      }\n\n      dl_ctx = dlopen (path, RTLD_LAZY);\n      free (path);\n      if (NULL == dl_ctx) {\n        rc = hioi_err_errno (errno);\n        hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"Failed to dlopen() plugin. Reason: %s\", strerror (errno));\n        continue;\n      }\n\n      snprintf (component_symbol, 512, \"%s_component\", component_name);\n\n      component_ptr = (hio_component_t *) dlsym (dl_ctx, component_symbol);\n      if (NULL == component_ptr) {\n        hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"Could not find component symbol: %s\", component_symbol);\n        rc = hioi_err_errno (errno);\n        dlclose (dl_ctx);\n        continue;\n      }\n\n      if (NULL == component_ptr->init) {\n        hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"Component %s does not define the required init() function\", component_name);\n        dlclose (dl_ctx);\n        continue;\n      }\n\n      rc = component_ptr->init (context);\n      if (HIO_SUCCESS != rc) {\n        hioi_log (context, HIO_VERBOSE_DEBUG_LOW, \"Component %s initialize function failed\", component_name);\n        dlclose (dl_ctx);\n        continue;\n      }\n\n      external_component->dl_ctx = dl_ctx;\n      external_component->component = component_ptr;\n\n      ++external_component;\n      ++hio_external_component_count;\n\n      rc = HIO_SUCCESS;\n\n      if (MAX_COMPONENTS == hio_external_component_count) {\n        break;\n      }\n    }\n\n    closedir (dir);\n  }\n\n  return rc;\n}\n#endif\n\nint hioi_component_init (hio_context_t context) {\n  int rc = HIO_SUCCESS;\n\n  if (hio_component_init_count++ > 0) {\n    return HIO_SUCCESS;\n  }\n\n  for (int i = 0 ; hio_builtin_components[i] ; ++i) {\n    hio_component_t *component = hio_builtin_components[i];\n\n    rc = component->init (context);\n    if (HIO_SUCCESS != rc) {\n      return rc;\n    }\n  }\n\n  if (HIO_SUCCESS != rc) {\n    return rc;\n  }\n\n#if USE_DYNAMIC_COMPONENTS\n  return hioi_dynamic_component_init (context);\n#endif\n\n  return HIO_SUCCESS;\n}\n\nint hioi_component_fini (void) {\n  if (0 == hio_component_init_count || --hio_component_init_count) {\n    return HIO_SUCCESS;\n  }\n\n  for (int i = 0 ; hio_builtin_components[i] ; ++i) {\n    hio_component_t *component = hio_builtin_components[i];\n\n    (void) component->fini ();\n  }\n\n#if USE_DYNAMIC_COMPONENTS\n  for (int i = 0 ; i < hio_external_component_count ; ++i) {\n    hio_dynamic_component_t *component = hio_external_components + i;\n    (void) component->component->fini ();\n    dlclose (component->dl_ctx);\n  }\n\n  memset (hio_external_components, 0, sizeof (hio_external_components));\n#endif\n\n  return HIO_SUCCESS;\n}\n\nvoid hioi_module_retain (hio_module_t *module) {\n  (void) atomic_fetch_add (&module->ref_count, 1);\n}\n\nvoid hioi_module_release (hio_module_t *module) {\n  int ref_count = atomic_fetch_add (&module->ref_count, -1);\n  if (1 == ref_count) {\n    module->fini (module);\n  }\n}\n\nint hioi_component_query (hio_context_t context, const char *data_root, char * const *next_data_roots,\n                          hio_module_t **module) {\n  int rc;\n\n  for (int i = 0 ; hio_builtin_components[i] ; ++i) {\n    hio_component_t *component = hio_builtin_components[i];\n\n    rc = component->query (context, data_root, next_data_roots, module);\n    if (HIO_SUCCESS == rc) {\n      atomic_init (&(*module)->ref_count, 1);\n      return HIO_SUCCESS;\n    }\n  }\n\n#if USE_DYNAMIC_COMPONENTS\n  for (int i = 0 ; i < hio_external_component_count ; ++i) {\n    hio_dynamic_component_t *component = hio_external_components + i;\n\n    rc = component->component->query (context, data_root, next_data_roots, module);\n    if (HIO_SUCCESS == rc) {\n      atomic_init (&(*module)->ref_count, 1);\n      return HIO_SUCCESS;\n    }\n  }\n#endif\n\n  return HIO_ERR_NOT_FOUND;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-ce3zl6legfwapvbkomd75ulkqofqvktl/spack-src/test/xexec/xexec_base.c": "/* -*- Mode: C; c-basic-offset:2 ; indent-tabs-mode:nil -*- */\n/*\n * Copyright (c) 2014-2016 Los Alamos National Security, LLC.  All rights\n *                         reserved.\n * $COPYRIGHT$\n *\n * Additional copyrights may follow\n *\n * $HEADER$\n */\n\n#include \"xexec.h\"\n#include <unistd.h>\n#include <errno.h>\n#include <string.h>\n#include <signal.h>\n#include <math.h>\n#ifdef DLFCN\n  #include <dlfcn.h>\n#endif  // DLFCN\n\n//----------------------------------------------------------------------------\n// xexec base module - contains basic functions\n//----------------------------------------------------------------------------\n#define G (*gptr)\n#define MY_MSG_CTX (&G.xexec_msg_context)\n\nstatic char * help =\n  \"  v <level>     set verbosity level\\n\"\n  \"                0 = program start and end, failures\\n\"\n  \"                1 = 0 + summary performance messages\\n\"\n  \"                2 = 1 + detailed performance messages\\n\"\n  \"                3 = 2 + API result messages\\n\"\n  \"  d <level>     set debug message level\\n\"\n  \"                0 = no debug messages\\n\"\n  \"                1 = Action start messages\\n\"\n  \"                2 = 1 + API pre-call messages\\n\"\n  \"                3 = 2 + action parsing messages\\n\"\n  \"                4 = 3 + detailed action progress messages\\n\"\n  \"                5 = 4 + detailed repetitive action progress messages - if\\n\"\n  \"                enabled at compile time which will impact performance.\\n\"\n  \"  o <count>     write <count> lines to stdout\\n\"\n  \"  e <count>     write <count> lines to stderr\\n\"\n  \"  s <seconds>   sleep for <seconds>\\n\"\n  \"  srr <seed>    seed random rank - seed RNG with <seed> mixed with rank (if MPI)\\n\"\n  \"  va <bytes>    allocate <bytes> of memory with malloc\\n\"\n  \"  vt <stride>   touch latest allocation every <stride> bytes\\n\"\n  \"  vw            write data pattern to latest allocation\\n\" \n  \"  vr            read (and check) data pattern from latest allocation\\n\" \n  \"  vf            free latest allocation\\n\"\n  \"  hx <min> <max> <blocks> <limit> <count>\\n\"\n  \"                Perform <count> malloc/touch/free cycles on memory blocks ranging\\n\"\n  \"                in size from <min> to <max>.  Allocate no more than <limit> bytes\\n\"\n  \"                in <blocks> separate allocations.  Sequence and sizes of\\n\"\n  \"                allocations are randomized.\\n\"\n  \"  ni <size> <count>\\n\"\n  \"                Creates <count> blocks of <size> doubles each.  All\\n\"\n  \"                but one double in each block is populated with sequential\\n\"\n  \"                values starting with 1.0.\\n\"\n  \"  nr <rep> <stride>\\n\"\n  \"                The values in each block are added and written to the\\n\"\n  \"                remaining double in the block. The summing of the block is\\n\"\n  \"                repeated <rep> times.  All <count> blocks are processed in\\n\"\n  \"                sequence offset by <stride>. The sum of all blocks is\\n\"\n  \"                computed and compared with an expected value.\\n\"\n  \"                <size> must be 2 or greater, <count> must be 1 greater than\\n\"\n  \"                a multiple of <stride>.\\n\"\n  \"  nf            Free allocated blocks\\n\"\n  #ifdef DLFCN\n  \"  dlo <name>    Issue dlopen for specified file name\\n\"\n  \"  dls <symbol>  Issue dlsym for specified symbol in most recently opened library\\n\"\n  \"  dlc           Issue dlclose for most recently opened library\\n\"\n  #endif // DLFCN\n  \"  grep <regex>  <file>  Search <file> and print (verbose 1) matching lines [1]\\n\"\n  \"                <file> = \\\"@ENV\\\" searches environment\\n\"\n  #ifdef __linux__\n  \"  dca           Display CPU Affinity\\n\"\n  #endif\n  \"  k <signal>    raise <signal> (number)\\n\"\n  \"  x <status>    exit with <status>\\n\"\n  \"  segv          force SIGSEGV\\n\" \n;\n\nstruct memblk {            // memblk queue element\n  size_t size;\n  struct memblk * prev;\n};\n\nstatic struct base_state {\n  int memcount;            // Number of entries in memblk queue\n  struct memblk * memptr;  // memblk queue\n  double * fp_nums;\n  U64 flap_size;\n  U64 fp_count;\n\n  #ifdef DLFCN\n    int dl_num;\n    void * dl_handle[20];\n  #endif\n} base_state;\n\nMODULE_INIT(xexec_base_init) {\n  struct base_state * s = state;\n  #ifdef DLFCN\n    s->dl_num = -1;\n  #endif\n  return 0;\n}\n\nMODULE_HELP(xexec_base_help) {\n  fprintf(file, \"%s\", help);\n  return 0;\n}\n\n//----------------------------------------------------------------------------\n// v, d (verbose, debug) action handlers\n//----------------------------------------------------------------------------\n#define S (* ((struct base_state *)(actionp->state)) )\n\nACTION_CHECK(verbose_check) {\n  int verbose = V0.u;\n  if (verbose > MAX_VERBOSE) ERRX(\"%s: Verbosity level %d > maximum %d\", A.desc, verbose, MAX_VERBOSE);\n}\n\nACTION_RUN(verbose_run) {\n  int verbose = V0.u;\n  msg_context_set_verbose(MY_MSG_CTX, verbose);\n  VERB2(\"Verbosity level set to %d\", verbose);\n}\n\nACTION_CHECK(debug_check) {\n  int debug = V0.u;\n  if (debug > DBGMAXLEV) ERRX(\"%s: requested debug level %d > maximum %d.\"\n                              \" Rebuild with -DDBGMAXLEV=<n> to increase\"\n                              \" (see comments in source.)\", A.desc, debug, DBGMAXLEV);\n  if (A.actn == 0) {\n    msg_context_set_debug(MY_MSG_CTX, debug);\n    VERB2(\"Parse debug level set to %d\", debug);\n  }\n}\n\nACTION_RUN(debug_run) {\n  int debug = V0.u;\n  if (A.actn != 0) {\n    msg_context_set_debug(MY_MSG_CTX, debug);\n    VERB2(\"Run debug level set to %d\", debug);\n  }\n}\n\n//----------------------------------------------------------------------------\n// o, e (stdout, stderr) action handlers\n//----------------------------------------------------------------------------\nACTION_RUN(stdout_run) {\n  U64 line;\n  for (line = 1; line <= V0.u; line++) {\n    // Message padded to exactly 100 bytes long.\n    MSG(\"action %-4u stdout line %-8lu of %-8lu %*s\", A.actn + 1, line, V0.u, 34 - G.id_string_len, \"\");\n  }\n}\n\nACTION_RUN(stderr_run) {\n  U64 line;\n  for (line = 1; line <= V0.u; line++) {\n    // Message padded to exactly 100 bytes long.\n    MSGE(\"action %-4u stderr line %-8lu of %-8lu %*s\", A.actn + 1, line, V0.u, 34 - G.id_string_len, \"\");\n  }\n}\n\n//----------------------------------------------------------------------------\n// s (sleep) action handler\n//----------------------------------------------------------------------------\nACTION_CHECK(sleep_check) {\n  if (V0.d < 0) ERRX(\"%s; negative sleep seconds\", A.desc);\n}\n\nACTION_RUN(sleep_run) {\n  fsleep(V0.d);\n}\n\n//----------------------------------------------------------------------------\n// srr (seed random rank) action handler\n//----------------------------------------------------------------------------\nACTION_RUN(srr_run) {\n  I64 seed = V0.u;\n  #define PR231_100 (U64)2147481317              // Prime close to but < 2^31\n  #define PR231_200 (U64)2147479259              // Prime close to but < 2^31\n  unsigned short seed16v[3];\n\n  // Multiply by prime so seed48(rank+1, seed) != seed(48(rank, seed+1)\n  seed *= PR231_100;\n  #ifdef MPI\n    seed += (G.myrank * PR231_200);\n  #endif\n  seed16v[0] = seed & 0xFFFF;\n  seed16v[1] = seed >> 16;\n  seed16v[2] = 0;\n  DBG3(\"srr seed: %lld; calling seed48(0x%04hX 0x%04hX 0x%04hX)\", seed, seed16v[2], seed16v[1], seed16v[0]);\n  seed48(seed16v);\n}\n\n//----------------------------------------------------------------------------\n// va, vt, vf (memory allocate, touch, free) action handlers\n//----------------------------------------------------------------------------\n\nACTION_CHECK(va_check) {\n  S.memcount++;\n}\n\nACTION_CHECK(vtwr_check) {\n  if (S.memcount <= 0) ERRX(\"%s: %s without corresponding va allocation\", A.desc, A.action);\n}\n\nACTION_CHECK(vf_check) {\n  if (S.memcount-- <= 0) ERRX(\"%s: free without corresponding allocate\", A.desc);\n}\n\n\nACTION_RUN(va_run) {\n  S.memcount++;\n  size_t len = V0.u;\n  struct memblk * p;\n  DBG2(\"Calling malloc(%lld)\", len);\n  p = (struct memblk *)malloc(len);\n  VERB3(\"malloc returns %p\", p);\n  if (p) {\n    p->size = len;\n    p->prev = S.memptr;\n    S.memptr = p;\n  } else {\n    VERB0(\"mem_hand - Warning: malloc returned NULL\");\n    S.memcount--;\n  }\n}\n\nACTION_RUN(vt_run) {\n  U64 stride = V0.u;\n  char *p, *end_p1;\n  ETIMER tmr;\n  if (S.memcount > 0) {\n    p = (char*)S.memptr + sizeof(struct memblk);\n    end_p1 = p + S.memptr->size;\n    DBG4(\"Touching memory at %p, length 0x%llx, stride: %lld\", p, S.memptr->size, stride);\n    ETIMER_START(&tmr);\n    while (p < end_p1) {\n      DBG5(\"touch S.memptr: %p memlen: 0x%llx: end_p1: %p p: %p\", S.memptr, S.memptr->size, end_p1, p);\n      *p = 'x';\n      p += stride;\n    }\n    double delta_t = ETIMER_ELAPSED(&tmr);\n    U64 count = S.memptr->size / stride;\n    prt_mmmst(&G, (double)count/delta_t, \"vt rate\", \"TpS\");\n\n  } else {\n    VERB0(\"mem_hand - Warning: no memory allocation to touch\");\n  }\n}\n\nACTION_RUN(vw_run) {\n  if (S.memcount > 0) {\n    ETIMER tmr;\n    char * p = (char*)S.memptr + sizeof(struct memblk);\n    size_t len = S.memptr->size - sizeof(struct memblk);\n    if (! G.wbuf_ptr ) dbuf_init(&G,RAND22, 20 * 1024 * 1024); \n    DBG4(\"Writing memory at %p, length 0x%llx\", p, len);\n    void * expected = get_wbuf_ptr(&G, \"vw\", 0, (U64)p);\n    ETIMER_START(&tmr);\n    memcpy(p, expected, len);\n    double delta_t = ETIMER_ELAPSED(&tmr);\n    prt_mmmst(&G, (double)len/delta_t, \"vw rate\", \"B/S\");\n  } else {\n    VERB0(\"mem_hand - Warning: no memory allocation to write\");\n  }\n}\n\nACTION_RUN(vr_run) {\n  if (S.memcount > 0) {\n    ETIMER tmr;\n    char * p = (char*)S.memptr + sizeof(struct memblk);\n    size_t len = S.memptr->size - sizeof(struct memblk);\n    if (! G.wbuf_ptr ) dbuf_init(&G,RAND22, 20 * 1024 * 1024); \n    DBG4(\"Reading memory at %p, length 0x%llx\", p, len);\n    ETIMER_START(&tmr);\n    if (G.options & OPT_RCHK) {\n      int rc = check_read_data(&G, \"vr\", p, len, 0, (U64)p);\n      if (rc) { \n        G.local_fails++;\n      }\n    } else {\n      memcpy(G.rbuf_ptr, p, len);\n    }\n    double delta_t = ETIMER_ELAPSED(&tmr);\n    prt_mmmst(&G, (double)len/delta_t, \"vr rate\", \"B/S\");\n  } else {\n    VERB0(\"mem_hand - Warning: no memory allocation to read\");\n  }\n}\n\nACTION_RUN(vf_run) {\n  if (S.memcount > 0) {\n    struct memblk * p;\n    p = S.memptr->prev;\n    DBG2(\"Calling free(%p)\", S.memptr);\n    free(S.memptr);\n    S.memptr = p;\n    S.memcount--;\n  } else {\n    VERB0(\"mem_hand - Warning: no memory allocation to free\");\n  }\n}\n\n//----------------------------------------------------------------------------\n// hx (heap exerciser) action handler\n//----------------------------------------------------------------------------\nACTION_CHECK(hx_check) {\n  U64 min = V0.u;\n  U64 max = V1.u;\n  U64 limit = V3.u;\n\n  if (min < 1) ERRX(\"%s; min < 1\", A.desc);\n  if (min > max) ERRX(\"%s; min > max\", A.desc);\n  if (max > limit) ERRX(\"%s; max > limit\", A.desc);\n}\n\nACTION_RUN(hx_run) {\n  U64 min = V0.u;\n  U64 max = V1.u;\n  U64 blocks = V2.u;\n  U64 limit = V3.u;\n  U64 count = V4.u;\n\n  double min_l2 = log2(min), max_l2 = log2(max);\n  double range_l2 = max_l2 - min_l2;\n  U64 i, n, k, total = 0;\n  size_t b;\n  ETIMER tmr;\n\n  struct {\n    void * ptr;\n    size_t size;\n  } blk [ blocks ];\n\n  struct stat {\n    U64 count;\n    double atime;\n    double ftime;\n  } stat [ 1 + (int)log2(max) ];\n\n  // Set up\n  VERB1(\"heapx starting; min: %llu max: %llu blocks: %llu limit: %llu count: %llu\", min, max, blocks, limit, count);\n\n  for (n=0; n<blocks; ++n) {\n    blk[n].ptr = NULL;\n    blk[n].size = 0;\n  }\n\n  #ifdef __clang_analyzer__\n    memset(stat, 0, sizeof(stat));\n  #endif\n  for (b=0; b<sizeof(stat)/sizeof(struct stat); ++b) {\n    stat[b].count = 0;\n    stat[b].atime = 0.0;\n    stat[b].ftime = 0.0;\n  }\n\n  // Do allocations\n  for (i=0; i<count; ++i) {\n\n    n = random()%blocks;\n    if (blk[n].ptr) {\n      DBG4(\"heapx: total: %llu; free %td bytes\", total, blk[n].size);\n      b = (int) log2(blk[n].size);\n      ETIMER_START(&tmr);\n      free(blk[n].ptr);\n      stat[b].ftime += ETIMER_ELAPSED(&tmr);\n      total -= blk[n].size;\n      blk[n].size = 0;\n      blk[n].ptr = 0;\n    }\n\n    // blk[n].size = random()%(max - min + 1) + min;\n\n    blk[n].size = (size_t)exp2( ((double)random() / (double)RAND_MAX * range_l2 ) + min_l2 );\n\n    // Make sure limit will not be exceeded\n    while (blk[n].size + total > limit) {\n      k = random()%blocks;\n      if (blk[k].ptr) {\n        DBG4(\"heapx: total: %llu; free %td bytes\", total, blk[k].size);\n        b = (int) log2(blk[k].size);\n        ETIMER_START(&tmr);\n        free(blk[k].ptr);\n        stat[b].ftime += ETIMER_ELAPSED(&tmr);\n        total -= blk[k].size;\n        blk[k].size = 0;\n        blk[k].ptr = 0;\n      }\n    }\n\n    VERB2(\"heapx: total: %llu; malloc and touch %td bytes\", total, blk[n].size);\n    b = (int) log2(blk[n].size);\n    ETIMER_START(&tmr);\n    blk[n].ptr = malloc(blk[n].size);\n    stat[b].atime += ETIMER_ELAPSED(&tmr);\n    if (!blk[n].ptr) ERRX(\"%s: heapx: malloc %td bytes failed\", A.desc, blk[n].size);\n    total += blk[n].size;\n    stat[b].count++;\n    memset(blk[n].ptr, 0xA5, blk[n].size);\n  }\n\n   // Clean up remainder\n  for (n=0; n<blocks; ++n) {\n    if (blk[n].ptr) {\n      DBG4(\"heapx: total: %llu; free %td bytes\", total, blk[n].size);\n      b = (int) log2(blk[n].size);\n      ETIMER_START(&tmr);\n      free(blk[n].ptr);\n      stat[b].ftime += ETIMER_ELAPSED(&tmr);\n      total -= blk[n].size;\n      blk[n].size = 0;\n      blk[n].ptr = 0;\n    }\n  }\n\n  // Reporting\n  RANK_SERIALIZE_START\n  for (b=0; b<sizeof(stat)/sizeof(struct stat); ++b) {\n    if (stat[b].count > 0) {\n      VERB2(\"heapx: bucket start: %lld count: %lld alloc_time: %.3f uS free_time %.3f uS\", (long)exp2(b),\n      stat[b].count, stat[b].atime*1e6/(double)stat[b].count, stat[b].ftime*1e6/(double)stat[b].count);\n    }\n  }\n  RANK_SERIALIZE_END\n\n}\n\n//----------------------------------------------------------------------------\n// ni, nr, nf (floating point addition init, run, free) action handlers\n//----------------------------------------------------------------------------\nACTION_CHECK(ni_check) {\n  S.flap_size = V0.u;\n  S.fp_count = V1.u;\n  if (S.flap_size < 2) ERRX(\"%s; size must be at least 2\", A.desc);\n}\n\nACTION_CHECK(nr_check) {\n  U64 rep = V0.u;\n  U64 stride = V1.u;\n\n  if (!S.flap_size) ERRX(\"%s; nr without prior ni\", A.desc);\n  if ((S.fp_count-1)%stride != 0) ERRX(\"%s; S.fp_count-1 must equal a multiple of stride\", A.desc);\n  if (rep<1) ERRX(\"%s; rep must be at least 1\", A.desc);\n}\n\nACTION_CHECK(nf_check) {\n  if (!S.flap_size) ERRX(\"%s; nf without prior ni\", A.desc);\n  S.flap_size = 0;\n}\n\nACTION_RUN(ni_run) {\n  S.flap_size = V0.u;\n  S.fp_count = V1.u;\n  U64 N = S.flap_size * S.fp_count;\n\n  int rc = posix_memalign((void * *)&S.fp_nums, 4096, N * sizeof(double));\n  if (rc) ERRX(\"%s; posix_memalign %d doubles failed: %s\", A.desc, N, strerror(rc));\n\n  U64 iv = 0;\n  for (U64 i=0; i<N; ++i) {\n    if (i%S.flap_size != 0) {\n      S.fp_nums[i] = (double) ++iv;\n      DBG4(\"%s; S.fp_nums[%d] = %d\", A.desc, i, iv);\n    }\n  }\n}\n\nACTION_RUN(nr_run) {\n  double sum, delta_t, predicted;\n  U64 b, ba, r, d, fp_add_ct, max_val;\n  U64 N = S.flap_size * S.fp_count;\n  U64 rep = V0.u;\n  U64 stride = V1.u;\n  ETIMER tmr;\n\n  max_val = (S.flap_size-1) * S.fp_count;\n  predicted = (pow((double) max_val, 2.0) + (double) max_val ) / 2 * (double)rep;\n  DBG1(\"%s; v: %d predicted: %f\", A.desc, max_val, predicted);\n  fp_add_ct = (max_val * rep) + S.fp_count;\n\n  for (U64 i=0; i<N; i+=S.flap_size) {\n    S.fp_nums[i] = 0.0;\n      DBG3(\"%s; S.fp_nums[%d] = %d\", A.desc, i, 0);\n  }\n\n  DBG1(\"flapper starting; size: %llu S.fp_count: %llu rep: %llu stride: %llu\", S.flap_size, S.fp_count, rep, stride);\n  ETIMER_START(&tmr);\n\n  for (b=0; b<S.fp_count; ++b) {\n    ba = b * stride % S.fp_count;\n    U64 d_sum = ba*S.flap_size;\n    U64 d_first = d_sum + 1;\n    U64 d_lastp1 = (ba+1)*S.flap_size;\n    DBG3(\"b: %llu ba:%llu\", b, ba);\n    for (r=0; r<rep; ++r) {\n      sum = S.fp_nums[d_sum];\n      for (d=d_first; d<d_lastp1; ++d) {\n        sum += S.fp_nums[d];\n        DBG3(\"%s; val: %f sum: %f\", A.desc, S.fp_nums[d], sum)\n      }\n      S.fp_nums[d_sum] = sum;\n    }\n  }\n\n  sum = 0.0;\n  for (d=0; d<S.fp_count*S.flap_size; d+=S.flap_size) {\n    sum += S.fp_nums[d];\n  }\n\n  delta_t = ETIMER_ELAPSED(&tmr);\n\n  VERB2(\"flapper done; FP Adds %llu, predicted: %e sum: %e delta: %e\", fp_add_ct, predicted, sum, sum - predicted);\n  VERB2(\"FP Adds: %llu, time: %f Seconds, MFLAPS: %e\", fp_add_ct, delta_t, (double)fp_add_ct / delta_t / 1000000.0);\n  prt_mmmst(&G, delta_t, \" Add time\", \"S\");\n  prt_mmmst(&G, (double)fp_add_ct / delta_t, \"FLAP rate\", \"F/S\" );\n}\n\nACTION_RUN(nf_run) {\n  S.flap_size = 0;\n  FREEX(S.fp_nums);\n}\n\n//----------------------------------------------------------------------------\n// dlo, dls, dlc (dl open, sym, close) action handlers\n//----------------------------------------------------------------------------\n#ifdef DLFCN\nACTION_CHECK(dlo_check) {\n  if (++(S.dl_num) >= (int)DIM1(S.dl_handle)) ERRX(\"%s; too many dlo commands, limit is %d\", A.desc, DIM1(S.dl_handle));\n}\n\nACTION_CHECK(dls_check) {\n  if (S.dl_num < 0) ERRX(\"%s; o currently open dynamic library\", A.desc);\n}\n\nACTION_CHECK(dlc_check) {\n  if (S.dl_num-- < 0) ERRX(\"%s; no currently open dynamic library\", A.desc);\n}\n\nACTION_RUN(dlo_run) {\n  char * name = V0.s;\n  S.dl_handle[++S.dl_num] = dlopen(name, RTLD_NOW);\n  VERB3(\"%s; dlopen(%s) returns %p\", A.desc, name, S.dl_handle[S.dl_num]);\n  if (!S.dl_handle[S.dl_num]) {\n    VERB0(\"%s; dlopen failed: %s\", A.desc, dlerror());\n    S.dl_num--;\n  }\n}\n\nACTION_RUN(dls_run) {\n  char * symbol = V0.s;\n  char * error;\n  void * sym = dlsym(S.dl_handle[S.dl_num], symbol);\n  VERB3(\"%s; dlsym(%s) returns %p\", A.desc, symbol, sym);\n  error = dlerror();\n  if (error) VERB0(\"%s; dlsym error: %s\", A.desc, error);\n}\n\nACTION_RUN(dlc_run) {\n  int rc = dlclose(S.dl_handle[S.dl_num--]);\n  VERB3(\"%s; dlclose returns %d\", A.desc, rc);\n  if (rc) VERB0(\"%s; dlclose error: %s\", A.desc, dlerror());\n}\n#endif // DLFC\n\n//----------------------------------------------------------------------------\n// grep action handler\n//----------------------------------------------------------------------------\nextern char * * environ;\n\nACTION_RUN(grep_run) {\n  char * fname = V1.s;\n\n  if (0 == strcmp(fname, \"@ENV\")) {\n    for (char ** eptr = environ; *eptr; eptr++) {\n      if (!rx_run(&G, 0, actionp, *eptr)) {\n        VERB1(\"grep: %s\", *eptr);\n      }\n    }\n  } else {\n    char line[512];\n    FILE * f = fopen(fname, \"r\");\n    if (!f) ERRX(\"%s: error opening \\\"%s\\\" %s\", A.desc, fname, strerror(errno));\n    while (fgets(line, sizeof(line), f)) {\n      if (!rx_run(&G, 0, actionp, line)) {\n        char * last = line + strlen(line) - 1;\n        if ('\\n' == *last) *last = '\\0';\n        VERB1(\"grep: %s\", line);\n      }\n    }\n    fclose(f);\n  }\n}\n\n//----------------------------------------------------------------------------\n// dca action handlers\n//----------------------------------------------------------------------------\n#ifdef __linux__\nACTION_RUN(dca_run) {\n  I64 aff = GetCPUaffinity();\n  long np = sysconf(_SC_NPROCESSORS_CONF);\n  RANK_SERIALIZE_START\n  if (aff >= 0) {\n    VERB0(\"_SC_NPROCESSORS_CONF: %d  CPU Affinity: %ld\", np, aff);\n  } else if ( aff < -1 ) {\n    VERB0(\"_SC_NPROCESSORS_CONF: %d  CPU Affinity Mask: 0x%lX\", np, -aff);\n  } else {\n    VERB0(\"_SC_NPROCESSORS_CONF: %d  CPU Affinity: None\", np);\n  }\n  RANK_SERIALIZE_END\n}\n#endif // __linux__\n\n//----------------------------------------------------------------------------\n// k, x (signal, exit) action handlers\n//----------------------------------------------------------------------------\nACTION_RUN(raise_run) {\n  VERB0(\"Raising signal %d\", V0.u);\n  raise(V0.u);\n}\n\nACTION_RUN(exit_run) {\n  VERB0(\"Exiting with status %d\", V0.u);\n  exit(V0.u);\n}\n\nACTION_RUN(segv_run) {\n  VERB0(\"Forcing SIGSEGV\"); \n  #ifndef __clang_analyzer__\n    * (volatile char *) 0 = '\\0';\n  #endif\n}\n\n//----------------------------------------------------------------------------\n// xexec_base - init foundational commands\n//----------------------------------------------------------------------------\nMODULE_INSTALL(xexec_base_install) {\n  struct xexec_act_parse parse[] = {\n  // Command   V0    V1    V2    V3    V4     Check          Run\n    {\"v\",     {UINT, NONE, NONE, NONE, NONE}, verbose_check, verbose_run },\n    {\"d\",     {UINT, NONE, NONE, NONE, NONE}, debug_check,   debug_run   },\n    {\"o\",     {UINT, NONE, NONE, NONE, NONE}, NULL,          stdout_run  },\n    {\"e\",     {UINT, NONE, NONE, NONE, NONE}, NULL,          stderr_run  },\n    {\"s\",     {DOUB, NONE, NONE, NONE, NONE}, sleep_check,   sleep_run   },\n    {\"srr\",   {SINT, NONE, NONE, NONE, NONE}, NULL,          srr_run     },\n    {\"va\",    {UINT, NONE, NONE, NONE, NONE}, va_check,      va_run      },\n    {\"vt\",    {PINT, NONE, NONE, NONE, NONE}, vtwr_check,    vt_run      },\n    {\"vw\",    {NONE, NONE, NONE, NONE, NONE}, vtwr_check,    vw_run      },\n    {\"vr\",    {NONE, NONE, NONE, NONE, NONE}, vtwr_check,    vr_run      },\n    {\"vf\",    {NONE, NONE, NONE, NONE, NONE}, vf_check,      vf_run      },\n    {\"hx\",    {UINT, UINT, UINT, UINT, UINT}, hx_check,      hx_run      },\n    {\"ni\",    {UINT, PINT, NONE, NONE, NONE}, ni_check,      ni_run      },\n    {\"nr\",    {PINT, PINT, NONE, NONE, NONE}, nr_check,      nr_run      },\n    {\"nf\",    {NONE, NONE, NONE, NONE, NONE}, nf_check,      nf_run      },\n    #ifdef DLFCN\n    {\"dlo\",   {STR,  NONE, NONE, NONE, NONE}, dlo_check,     dlo_run     },\n    {\"dls\",   {STR,  NONE, NONE, NONE, NONE}, dls_check,     dls_run     },\n    {\"dlc\",   {NONE, NONE, NONE, NONE, NONE}, dlc_check,     dlc_run     },\n    #endif // DLFCN\n    {\"grep\",  {REGX, STR,  NONE, NONE, NONE}, NULL,          grep_run    },\n    #ifdef __linux__\n    {\"dca\",   {NONE, NONE, NONE, NONE, NONE}, NULL,          dca_run     },\n    #endif // __linux__\n    {\"k\",     {UINT, NONE, NONE, NONE, NONE}, NULL,          raise_run   },\n    {\"x\",     {UINT, NONE, NONE, NONE, NONE}, NULL,          exit_run    },\n    {\"segv\",  {NONE, NONE, NONE, NONE, NONE}, NULL,          segv_run    },\n  };\n\n  xexec_act_add(&G, parse, DIM1(parse), xexec_base_init, &base_state, xexec_base_help);\n\n  return 0;\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-ce3zl6legfwapvbkomd75ulkqofqvktl/spack-src/.git/objects/pack/pack-1282029af7958a9cbb5d271a21ddd8f576f079d0.idx",
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-ce3zl6legfwapvbkomd75ulkqofqvktl/spack-src/.git/objects/pack/pack-1282029af7958a9cbb5d271a21ddd8f576f079d0.pack",
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-ce3zl6legfwapvbkomd75ulkqofqvktl/spack-src/extra/bzip2-1.0.6-patched.tbz2",
        "/tmp/vanessa/spack-stage/spack-stage-libhio-master-ce3zl6legfwapvbkomd75ulkqofqvktl/spack-src/extra/json-c-0.12-nodoc-patched.tar.gz"
    ],
    "total_files": 118
}