{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/collectors/ebpf_process.plugin/ebpf_process.c": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include <sys/time.h>\n#include <sys/resource.h>\n\n#include \"ebpf_process.h\"\n\n// callback required by eval()\nint health_variable_lookup(const char *variable, uint32_t hash, struct rrdcalc *rc, calculated_number *result) {\n    (void)variable;\n    (void)hash;\n    (void)rc;\n    (void)result;\n    return 0;\n};\n\nvoid send_statistics( const char *action, const char *action_result, const char *action_data) {\n    (void) action;\n    (void) action_result;\n    (void) action_data;\n    return;\n}\n\n// callbacks required by popen()\nvoid signals_block(void) {};\nvoid signals_unblock(void) {};\nvoid signals_reset(void) {};\n\n// required by get_system_cpus()\nchar *netdata_configured_host_prefix = \"\";\n\n// callback required by fatal()\nvoid netdata_cleanup_and_exit(int ret) {\n    exit(ret);\n}\n\n// ----------------------------------------------------------------------\n//Netdata eBPF library\nvoid *libnetdata = NULL;\nint (*load_bpf_file)(char *, int) = NULL;\nint (*set_bpf_perf_event)(int, int);\nint (*perf_event_unmap)(struct perf_event_mmap_page *, size_t);\nint (*perf_event_mmap_header)(int, struct perf_event_mmap_page **, int);\nvoid (*netdata_perf_loop_multi)(int *, struct perf_event_mmap_page **, int, int *, int (*nsb)(void *, int), int);\nint *map_fd = NULL;\n\n//Perf event variables\nstatic int pmu_fd[NETDATA_MAX_PROCESSOR];\nstatic struct perf_event_mmap_page *headers[NETDATA_MAX_PROCESSOR];\nint page_cnt = 8;\n\n//Libbpf (It is necessary to have at least kernel 4.10)\nint (*bpf_map_lookup_elem)(int, const void *, void *);\n\nstatic char *plugin_dir = PLUGINS_DIR;\nstatic char *user_config_dir = CONFIG_DIR;\nstatic char *stock_config_dir = LIBCONFIG_DIR;\nstatic char *netdata_configured_log_dir = LOG_DIR;\n\nFILE *developer_log = NULL;\n\n//Global vectors\nnetdata_syscall_stat_t *aggregated_data = NULL;\nnetdata_publish_syscall_t *publish_aggregated = NULL;\n\nstatic int update_every = 1;\nstatic int thread_finished = 0;\nstatic int close_plugin = 0;\nstatic int mode = 2;\nstatic int debug_log = 0;\nstatic int use_stdout = 0;\nstruct config collector_config;\nstatic int mykernel = 0;\nstatic int nprocs;\nstatic int isrh;\nnetdata_idx_t *hash_values;\n\npthread_mutex_t lock;\n\nstatic char *dimension_names[NETDATA_MAX_MONITOR_VECTOR] = { \"open\", \"close\", \"delete\", \"read\", \"write\", \"process\", \"task\", \"process\", \"thread\" };\nstatic char *id_names[NETDATA_MAX_MONITOR_VECTOR] = { \"do_sys_open\", \"__close_fd\", \"vfs_unlink\", \"vfs_read\", \"vfs_write\", \"do_exit\", \"release_task\", \"_do_fork\", \"sys_clone\" };\nstatic char *status[] = { \"process\", \"zombie\" };\n\nint event_pid = 0;\nnetdata_ebpf_events_t collector_events[] = {\n        { .type = 'r', .name = \"vfs_write\" },\n        { .type = 'r', .name = \"vfs_writev\" },\n        { .type = 'r', .name = \"vfs_read\" },\n        { .type = 'r', .name = \"vfs_readv\" },\n        { .type = 'r', .name = \"do_sys_open\" },\n        { .type = 'r', .name = \"vfs_unlink\" },\n        { .type = 'p', .name = \"do_exit\" },\n        { .type = 'p', .name = \"release_task\" },\n        { .type = 'r', .name = \"_do_fork\" },\n        { .type = 'r', .name = \"__close_fd\" },\n        { .type = 'r', .name = \"__x64_sys_clone\" },\n        { .type = 0, .name = NULL }\n};\n\nvoid open_developer_log() {\n    char filename[FILENAME_MAX+1];\n    int tot = sprintf(filename, \"%s/%s\",  netdata_configured_log_dir, NETDATA_DEVELOPER_LOG_FILE);\n\n    if(tot > 0)\n        developer_log = fopen(filename, \"a\");\n}\n\nstatic int unmap_memory() {\n    int i;\n    int size = (int)sysconf(_SC_PAGESIZE)*(page_cnt + 1);\n    for ( i = 0 ; i < nprocs ; i++ ) {\n        if (perf_event_unmap(headers[i], size) < 0) {\n            fprintf(stderr,\"[EBPF PROCESS] CANNOT unmap headers.\\n\");\n            return -1;\n        }\n\n        close(pmu_fd[i]);\n    }\n\n    return 0;\n}\n\nstatic void int_exit(int sig)\n{\n    close_plugin = 1;\n\n    //When both threads were not finished case I try to go in front this address, the collector will crash\n    if (!thread_finished) {\n        return;\n    }\n\n    if (aggregated_data) {\n        free(aggregated_data);\n        aggregated_data = NULL;\n    }\n\n    if (publish_aggregated) {\n        free(publish_aggregated);\n        publish_aggregated = NULL;\n    }\n\n    if(mode == 1 && debug_log) {\n        unmap_memory();\n    }\n\n    if (libnetdata) {\n        dlclose(libnetdata);\n        libnetdata = NULL;\n    }\n\n    if (developer_log) {\n        fclose(developer_log);\n        developer_log = NULL;\n    }\n\n    if (hash_values) {\n        freez(hash_values);\n    }\n\n    if (event_pid) {\n        int ret = fork();\n        if (ret < 0) //error\n            error(\"[EBPF PROCESS] Cannot fork(), so I won't be able to clean %skprobe_events\", NETDATA_DEBUGFS);\n        else if (!ret) { //child\n            int i;\n            for ( i=getdtablesize(); i>=0; --i)\n                close(i);\n\n            int fd = open(\"/dev/null\",O_RDWR, 0);\n            if (fd != -1) {\n                dup2 (fd, STDIN_FILENO);\n                dup2 (fd, STDOUT_FILENO);\n                dup2 (fd, STDERR_FILENO);\n            }\n\n            if (fd > 2)\n                close (fd);\n\n            int sid = setsid();\n            if(sid >= 0) {\n                sleep(1);\n                if(debug_log) {\n                    open_developer_log();\n                }\n                debug(D_EXIT, \"Wait for father %d die\", event_pid);\n                clean_kprobe_events(developer_log, event_pid, collector_events);\n            } else {\n                error(\"Cannot become session id leader, so I won't try to clean kprobe_events.\\n\");\n            }\n        } else { //parent\n            exit(0);\n        }\n\n        if (developer_log) {\n            fclose(developer_log);\n            developer_log = NULL;\n        }\n    }\n\n    exit(sig);\n}\n\nstatic inline void netdata_write_chart_cmd(char *type\n                                    , char *id\n                                    , char *axis\n                                    , char *web\n                                    , int order)\n{\n    printf(\"CHART %s.%s '' '' '%s' '%s' '' line %d 1 ''\\n\"\n            , type\n            , id\n            , axis\n            , web\n            , order);\n}\n\nstatic void netdata_write_global_dimension(char *d, char *n)\n{\n    printf(\"DIMENSION %s %s absolute 1 1\\n\", d, n);\n}\n\nstatic void netdata_create_global_dimension(void *ptr, int end)\n{\n    netdata_publish_syscall_t *move = ptr;\n\n    int i = 0;\n    while (move && i < end) {\n        netdata_write_global_dimension(move->name, move->dimension);\n\n        move = move->next;\n        i++;\n    }\n}\nstatic inline void netdata_create_chart(char *family\n                                , char *name\n                                , char *axis\n                                , char *web\n                                , int order\n                                , void (*ncd)(void *, int)\n                                , void *move\n                                , int end)\n{\n    netdata_write_chart_cmd(family, name, axis, web, order);\n\n    ncd(move, end);\n}\n\nstatic void netdata_create_io_chart(char *family, char *name, char *axis, char *web, int order) {\n    printf(\"CHART %s.%s '' '' '%s' '%s' '' line %d 1 ''\\n\"\n            , family\n            , name\n            , axis\n            , web\n            , order);\n\n    printf(\"DIMENSION %s %s absolute 1 1\\n\", id_names[3], NETDATA_VFS_DIM_OUT_FILE_BYTES);\n    printf(\"DIMENSION %s %s absolute 1 1\\n\", id_names[4], NETDATA_VFS_DIM_IN_FILE_BYTES);\n}\n\nstatic void netdata_process_status_chart(char *family, char *name, char *axis, char *web, int order) {\n    printf(\"CHART %s.%s '' '' '%s' '%s' '' line %d 1 ''\\n\"\n            , family\n            , name\n            , axis\n            , web\n            , order);\n\n    printf(\"DIMENSION %s '' absolute 1 1\\n\", status[0]);\n    printf(\"DIMENSION %s '' absolute 1 1\\n\", status[1]);\n}\n\nstatic void netdata_global_charts_create() {\n    netdata_create_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_FILE_OPEN_CLOSE_COUNT\n            , \"Calls\"\n            , NETDATA_FILE_GROUP\n            , 970\n            , netdata_create_global_dimension\n            , publish_aggregated\n            , 2);\n\n    if(mode < 2) {\n        netdata_create_chart(NETDATA_EBPF_FAMILY\n                , NETDATA_FILE_OPEN_ERR_COUNT\n                , \"Calls\"\n                , NETDATA_FILE_GROUP\n                , 971\n                , netdata_create_global_dimension\n                , publish_aggregated\n                , 2);\n    }\n\n    netdata_create_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_VFS_FILE_CLEAN_COUNT\n            , \"Calls\"\n            , NETDATA_VFS_GROUP\n            , 972\n            , netdata_create_global_dimension\n            , &publish_aggregated[NETDATA_DEL_START]\n            , 1);\n\n    netdata_create_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_VFS_FILE_IO_COUNT\n            , \"Calls\"\n            , NETDATA_VFS_GROUP\n            , 973\n            , netdata_create_global_dimension\n            , &publish_aggregated[NETDATA_IN_START_BYTE]\n            , 2);\n\n    if(mode < 2) {\n        netdata_create_io_chart(NETDATA_EBPF_FAMILY\n                , NETDATA_VFS_IO_FILE_BYTES\n                , \"bytes/s\"\n                , NETDATA_VFS_GROUP\n                , 974);\n\n        netdata_create_chart(NETDATA_EBPF_FAMILY\n                , NETDATA_VFS_FILE_ERR_COUNT\n                , \"Calls\"\n                , NETDATA_VFS_GROUP\n                , 975\n                , netdata_create_global_dimension\n                , &publish_aggregated[2]\n                , NETDATA_VFS_ERRORS);\n\n    }\n\n    netdata_create_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_PROCESS_SYSCALL\n            , \"Calls\"\n            , NETDATA_PROCESS_GROUP\n            , 976\n            , netdata_create_global_dimension\n            , &publish_aggregated[NETDATA_PROCESS_START]\n            , 2);\n\n    netdata_create_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_EXIT_SYSCALL\n            , \"Calls\"\n            , NETDATA_PROCESS_GROUP\n            , 977\n            , netdata_create_global_dimension\n            , &publish_aggregated[NETDATA_EXIT_START]\n            , 2);\n\n    netdata_process_status_chart(NETDATA_EBPF_FAMILY\n            , NETDATA_PROCESS_STATUS_NAME\n            , \"Total\"\n            , NETDATA_PROCESS_GROUP\n            , 978);\n\n    if(mode < 2) {\n        netdata_create_chart(NETDATA_EBPF_FAMILY\n                , NETDATA_PROCESS_ERROR_NAME\n                , \"Calls\"\n                , NETDATA_PROCESS_GROUP\n                , 979\n                , netdata_create_global_dimension\n                , &publish_aggregated[NETDATA_PROCESS_START]\n                , 2);\n    }\n\n}\n\n\nstatic void netdata_create_charts() {\n    netdata_global_charts_create();\n}\n\nstatic void netdata_update_publish(netdata_publish_syscall_t *publish\n        , netdata_publish_vfs_common_t *pvc\n        , netdata_syscall_stat_t *input) {\n\n    netdata_publish_syscall_t *move = publish;\n    while(move) {\n        if(input->call != move->pcall) {\n            //This condition happens to avoid initial values with dimensions higher than normal values.\n            if(move->pcall) {\n                move->ncall = (input->call > move->pcall)?input->call - move->pcall: move->pcall - input->call;\n                move->nbyte = (input->bytes > move->pbyte)?input->bytes - move->pbyte: move->pbyte - input->bytes;\n                move->nerr = (input->ecall > move->nerr)?input->ecall - move->perr: move->perr - input->ecall;\n            } else {\n                move->ncall = 0;\n                move->nbyte = 0;\n                move->nerr = 0;\n            }\n\n            move->pcall = input->call;\n            move->pbyte = input->bytes;\n            move->perr = input->ecall;\n        } else {\n            move->ncall = 0;\n            move->nbyte = 0;\n            move->nerr = 0;\n        }\n\n        input = input->next;\n        move = move->next;\n    }\n\n    pvc->write = -((long)publish[2].nbyte);\n    pvc->read = (long)publish[3].nbyte;\n\n    pvc->running = (long)publish[7].ncall - (long)publish[8].ncall;\n    publish[6].ncall = -publish[6].ncall; // release\n    pvc->zombie = (long)publish[5].ncall + (long)publish[6].ncall;\n}\n\nstatic inline void write_begin_chart(char *family, char *name)\n{\n    int ret = printf( \"BEGIN %s.%s\\n\"\n            , family\n            , name);\n\n    (void)ret;\n}\n\nstatic inline void write_chart_dimension(char *dim, long long value)\n{\n    int ret = printf(\"SET %s = %lld\\n\", dim, value);\n    (void)ret;\n}\n\nstatic void write_global_count_chart(char *name, char *family, netdata_publish_syscall_t *move, int end) {\n    write_begin_chart(family, name);\n\n    int i = 0;\n    while (move && i < end) {\n        write_chart_dimension(move->name, move->ncall);\n\n        move = move->next;\n        i++;\n    }\n\n    printf(\"END\\n\");\n}\n\nstatic void write_global_err_chart(char *name, char *family, netdata_publish_syscall_t *move, int end) {\n    write_begin_chart(family, name);\n\n    int i = 0;\n    while (move && i < end) {\n        write_chart_dimension(move->name, move->nerr);\n\n        move = move->next;\n        i++;\n    }\n\n    printf(\"END\\n\");\n}\n\nstatic void write_io_chart(char *family, netdata_publish_vfs_common_t *pvc) {\n    write_begin_chart(family, NETDATA_VFS_IO_FILE_BYTES);\n\n    write_chart_dimension(id_names[3], (long long) pvc->write);\n    write_chart_dimension(id_names[4], (long long) pvc->read);\n\n    printf(\"END\\n\");\n}\n\nstatic void write_status_chart(char *family, netdata_publish_vfs_common_t *pvc) {\n    write_begin_chart(family, NETDATA_PROCESS_STATUS_NAME);\n\n    write_chart_dimension(status[0], (long long) pvc->running);\n    write_chart_dimension(status[1], (long long) pvc->zombie);\n\n    printf(\"END\\n\");\n}\n\nstatic void netdata_publish_data() {\n    netdata_publish_vfs_common_t pvc;\n    netdata_update_publish(publish_aggregated, &pvc, aggregated_data);\n\n    write_global_count_chart(NETDATA_FILE_OPEN_CLOSE_COUNT, NETDATA_EBPF_FAMILY, publish_aggregated, 2);\n    write_global_count_chart(NETDATA_VFS_FILE_CLEAN_COUNT, NETDATA_EBPF_FAMILY, &publish_aggregated[NETDATA_DEL_START], 1);\n    write_global_count_chart(NETDATA_VFS_FILE_IO_COUNT, NETDATA_EBPF_FAMILY, &publish_aggregated[NETDATA_IN_START_BYTE], 2);\n    write_global_count_chart(NETDATA_EXIT_SYSCALL, NETDATA_EBPF_FAMILY, &publish_aggregated[NETDATA_EXIT_START], 2);\n    write_global_count_chart(NETDATA_PROCESS_SYSCALL, NETDATA_EBPF_FAMILY, &publish_aggregated[NETDATA_PROCESS_START], 2);\n\n    write_status_chart(NETDATA_EBPF_FAMILY, &pvc);\n    if(mode < 2) {\n        write_global_err_chart(NETDATA_FILE_OPEN_ERR_COUNT, NETDATA_EBPF_FAMILY, publish_aggregated, 2);\n        write_global_err_chart(NETDATA_VFS_FILE_ERR_COUNT, NETDATA_EBPF_FAMILY, &publish_aggregated[2], NETDATA_VFS_ERRORS);\n        write_global_err_chart(NETDATA_PROCESS_ERROR_NAME, NETDATA_EBPF_FAMILY, &publish_aggregated[NETDATA_PROCESS_START], 2);\n\n        write_io_chart(NETDATA_EBPF_FAMILY, &pvc);\n    }\n}\n\nvoid *process_publisher(void *ptr)\n{\n    (void)ptr;\n    netdata_create_charts();\n\n    usec_t step = update_every * USEC_PER_SEC;\n    heartbeat_t hb;\n    heartbeat_init(&hb);\n    while(!close_plugin) {\n        usec_t dt = heartbeat_next(&hb, step);\n        (void)dt;\n\n        pthread_mutex_lock(&lock);\n        netdata_publish_data();\n        pthread_mutex_unlock(&lock);\n\n        fflush(stdout);\n    }\n\n    return NULL;\n}\n\nstatic void move_from_kernel2user_global() {\n    uint64_t idx;\n    netdata_idx_t res[NETDATA_GLOBAL_VECTOR];\n\n    netdata_idx_t *val = hash_values;\n    for (idx = 0; idx < NETDATA_GLOBAL_VECTOR; idx++) {\n        if(!bpf_map_lookup_elem(map_fd[1], &idx, val)) {\n            uint64_t total = 0;\n            int i;\n            int end = (mykernel < NETDATA_KERNEL_V4_15)?1:nprocs;\n            for (i = 0; i < end; i++)\n                total += val[i];\n\n            res[idx] = total;\n        } else {\n            res[idx] = 0;\n        }\n    }\n\n    aggregated_data[0].call = res[NETDATA_KEY_CALLS_DO_SYS_OPEN];\n    aggregated_data[1].call = res[NETDATA_KEY_CALLS_CLOSE_FD];\n    aggregated_data[2].call = res[NETDATA_KEY_CALLS_VFS_UNLINK];\n    aggregated_data[3].call = res[NETDATA_KEY_CALLS_VFS_READ] + res[NETDATA_KEY_CALLS_VFS_READV];\n    aggregated_data[4].call = res[NETDATA_KEY_CALLS_VFS_WRITE] + res[NETDATA_KEY_CALLS_VFS_WRITEV];\n    aggregated_data[5].call = res[NETDATA_KEY_CALLS_DO_EXIT];\n    aggregated_data[6].call = res[NETDATA_KEY_CALLS_RELEASE_TASK];\n    aggregated_data[7].call = res[NETDATA_KEY_CALLS_DO_FORK];\n    aggregated_data[8].call = res[NETDATA_KEY_CALLS_SYS_CLONE];\n\n    aggregated_data[0].ecall = res[NETDATA_KEY_ERROR_DO_SYS_OPEN];\n    aggregated_data[1].ecall = res[NETDATA_KEY_ERROR_CLOSE_FD];\n    aggregated_data[2].ecall = res[NETDATA_KEY_ERROR_VFS_UNLINK];\n    aggregated_data[3].ecall = res[NETDATA_KEY_ERROR_VFS_READ] + res[NETDATA_KEY_ERROR_VFS_READV];\n    aggregated_data[4].ecall = res[NETDATA_KEY_ERROR_VFS_WRITE] + res[NETDATA_KEY_ERROR_VFS_WRITEV];\n    aggregated_data[7].ecall = res[NETDATA_KEY_ERROR_DO_FORK];\n    aggregated_data[8].ecall = res[NETDATA_KEY_ERROR_SYS_CLONE];\n\n    aggregated_data[2].bytes = (uint64_t)res[NETDATA_KEY_BYTES_VFS_WRITE] + (uint64_t)res[NETDATA_KEY_BYTES_VFS_WRITEV];\n    aggregated_data[3].bytes = (uint64_t)res[NETDATA_KEY_BYTES_VFS_READ] + (uint64_t)res[NETDATA_KEY_BYTES_VFS_READV];\n}\n\nstatic void move_from_kernel2user()\n{\n    move_from_kernel2user_global();\n}\n\nvoid *process_collector(void *ptr)\n{\n    (void)ptr;\n\n    usec_t step = 778879ULL;\n    heartbeat_t hb;\n    heartbeat_init(&hb);\n    while(!close_plugin) {\n        usec_t dt = heartbeat_next(&hb, step);\n        (void)dt;\n\n        pthread_mutex_lock(&lock);\n        move_from_kernel2user();\n        pthread_mutex_unlock(&lock);\n    }\n\n    return NULL;\n}\n\nstatic int netdata_store_bpf(void *data, int size) {\n    (void)size;\n\n    if (close_plugin)\n        return 0;\n\n    if(!debug_log)\n        return -2; //LIBBPF_PERF_EVENT_CONT;\n\n    netdata_error_report_t *e = data;\n    fprintf(developer_log\n            ,\"%llu %s %u: %s, %d\\n\"\n            , now_realtime_usec() ,e->comm, e->pid, dimension_names[e->type], e->err);\n    fflush(developer_log);\n\n    return -2; //LIBBPF_PERF_EVENT_CONT;\n}\n\nvoid *process_log(void *ptr)\n{\n    (void) ptr;\n\n    if (mode == 1 && debug_log) {\n        netdata_perf_loop_multi(pmu_fd, headers, nprocs, &close_plugin, netdata_store_bpf, page_cnt);\n    }\n\n    return NULL;\n}\n\nvoid set_global_labels() {\n    int i;\n\n    netdata_syscall_stat_t *is = aggregated_data;\n    netdata_syscall_stat_t *prev = NULL;\n\n    netdata_publish_syscall_t *pio = publish_aggregated;\n    netdata_publish_syscall_t *publish_prev = NULL;\n    for (i = 0; i < NETDATA_MAX_MONITOR_VECTOR; i++) {\n        if(prev) {\n            prev->next = &is[i];\n        }\n        prev = &is[i];\n\n        pio[i].dimension = dimension_names[i];\n        pio[i].name = id_names[i];\n        if(publish_prev) {\n            publish_prev->next = &pio[i];\n        }\n        publish_prev = &pio[i];\n    }\n}\n\nint allocate_global_vectors() {\n    aggregated_data = callocz(NETDATA_MAX_MONITOR_VECTOR, sizeof(netdata_syscall_stat_t));\n    if(!aggregated_data) {\n        return -1;\n    }\n\n    publish_aggregated = callocz(NETDATA_MAX_MONITOR_VECTOR, sizeof(netdata_publish_syscall_t));\n    if(!publish_aggregated) {\n        return -1;\n    }\n\n    hash_values = callocz(nprocs, sizeof(netdata_idx_t));\n    if(!hash_values) {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void build_complete_path(char *out, size_t length,char *path, char *filename) {\n    if(path){\n        snprintf(out, length, \"%s/%s\", path, filename);\n    } else {\n        snprintf(out, length, \"%s\", filename);\n    }\n}\n\nstatic int map_memory() {\n    int i;\n    for (i = 0; i < nprocs; i++) {\n        pmu_fd[i] = set_bpf_perf_event(i, 2);\n\n        if (perf_event_mmap_header(pmu_fd[i], &headers[i], page_cnt) < 0) {\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic int ebpf_load_libraries()\n{\n    char *err = NULL;\n    char lpath[4096];\n\n    build_complete_path(lpath, 4096, plugin_dir, \"libnetdata_ebpf.so\");\n    libnetdata = dlopen(lpath, RTLD_LAZY);\n    if (!libnetdata) {\n        error(\"[EBPF_PROCESS] Cannot load %s.\", lpath);\n        return -1;\n    } else {\n        load_bpf_file = dlsym(libnetdata, \"load_bpf_file\");\n        if ((err = dlerror()) != NULL) {\n            error(\"[EBPF_PROCESS] Cannot find load_bpf_file: %s\", err);\n            return -1;\n        }\n\n        map_fd =  dlsym(libnetdata, \"map_fd\");\n        if ((err = dlerror()) != NULL) {\n            error(\"[EBPF_PROCESS] Cannot find map_fd: %s\", err);\n            return -1;\n        }\n\n        bpf_map_lookup_elem = dlsym(libnetdata, \"bpf_map_lookup_elem\");\n        if ((err = dlerror()) != NULL) {\n            error(\"[EBPF_PROCESS] Cannot find bpf_map_lookup_elem: %s\", err);\n            return -1;\n        }\n\n        if(mode == 1) {\n            set_bpf_perf_event = dlsym(libnetdata, \"set_bpf_perf_event\");\n            if ((err = dlerror()) != NULL) {\n                error(\"[EBPF_PROCESS] Cannot find set_bpf_perf_event: %s\", err);\n                return -1;\n            }\n\n            perf_event_unmap =  dlsym(libnetdata, \"perf_event_unmap\");\n            if ((err = dlerror()) != NULL) {\n                error(\"[EBPF_PROCESS] Cannot find perf_event_unmap: %s\", err);\n                return -1;\n            }\n\n            perf_event_mmap_header =  dlsym(libnetdata, \"perf_event_mmap_header\");\n            if ((err = dlerror()) != NULL) {\n                error(\"[EBPF_PROCESS] Cannot find perf_event_mmap_header: %s\", err);\n                return -1;\n            }\n\n            netdata_perf_loop_multi = dlsym(libnetdata, \"netdata_perf_loop_multi\");\n            if ((err = dlerror()) != NULL) {\n                error(\"[EBPF_PROCESS] Cannot find netdata_perf_loop_multi: %s\", err);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}\n\nchar *select_file() {\n    if(!mode)\n        return \"rnetdata_ebpf_process.o\";\n    if(mode == 1)\n        return \"dnetdata_ebpf_process.o\";\n\n    return \"pnetdata_ebpf_process.o\";\n}\n\nint process_load_ebpf()\n{\n    char lpath[4096];\n\n    char *name = select_file();\n\n    build_complete_path(lpath, 4096, plugin_dir,  name);\n    event_pid = getpid();\n    if (load_bpf_file(lpath, event_pid) ) {\n        error(\"[EBPF_PROCESS] Cannot load program: %s\", lpath);\n        return -1;\n    } else {\n        info(\"[EBPF PROCESS]: The eBPF program %s was loaded with success.\", name);\n    }\n\n    return 0;\n}\n\nvoid set_global_variables() {\n    //Get environment variables\n    plugin_dir = getenv(\"NETDATA_PLUGINS_DIR\");\n    if(!plugin_dir)\n        plugin_dir = PLUGINS_DIR;\n\n    user_config_dir = getenv(\"NETDATA_USER_CONFIG_DIR\");\n    if(!user_config_dir)\n        user_config_dir = CONFIG_DIR;\n\n    stock_config_dir = getenv(\"NETDATA_STOCK_CONFIG_DIR\");\n    if(!stock_config_dir)\n        stock_config_dir = LIBCONFIG_DIR;\n\n    netdata_configured_log_dir = getenv(\"NETDATA_LOG_DIR\");\n    if(!netdata_configured_log_dir)\n        netdata_configured_log_dir = LOG_DIR;\n\n    page_cnt *= (int)sysconf(_SC_NPROCESSORS_ONLN);\n\n    nprocs = (int)sysconf(_SC_NPROCESSORS_ONLN);\n    if (nprocs > NETDATA_MAX_PROCESSOR) {\n        nprocs = NETDATA_MAX_PROCESSOR;\n    }\n\n    isrh = get_redhat_release();\n}\n\nstatic void change_collector_event() {\n    int i;\n    if (mykernel < NETDATA_KERNEL_V5_3)\n        collector_events[10].name = NULL;\n\n    for (i = 0; collector_events[i].name ; i++ ) {\n        collector_events[i].type = 'p';\n    }\n}\n\nstatic void change_syscalls() {\n    static char *lfork = { \"do_fork\" };\n    id_names[7] = lfork;\n    collector_events[8].name = lfork;\n}\n\nstatic inline void what_to_load(char *ptr) {\n    if (!strcasecmp(ptr, \"return\"))\n        mode = 0;\n    /*\n    else if (!strcasecmp(ptr, \"dev\"))\n        mode = 1;\n        */\n    else\n        change_collector_event();\n\n    if (isrh >= NETDATA_MINIMUM_RH_VERSION && isrh < NETDATA_RH_8)\n        change_syscalls();\n}\n\nstatic inline void enable_debug(char *ptr) {\n    if (!strcasecmp(ptr, \"yes\"))\n        debug_log = 1;\n}\n\nstatic inline void set_log_file(char *ptr) {\n    if (!strcasecmp(ptr, \"yes\"))\n        use_stdout = 1;\n}\n\nstatic void set_global_values() {\n    struct section *sec = collector_config.first_section;\n    while(sec) {\n        if(!strcasecmp(sec->name, \"global\")) {\n            struct config_option *values = sec->values;\n            while(values) {\n                if(!strcasecmp(values->name, \"load\"))\n                    what_to_load(values->value);\n                else if(!strcasecmp(values->name, \"debug log\"))\n                    enable_debug(values->value);\n                else if(!strcasecmp(values->name, \"use stdout\"))\n                    set_log_file(values->value);\n\n                values = values->next;\n            }\n        }\n        sec = sec->next;\n    }\n}\n\nstatic int load_collector_file(char *path) {\n    char lpath[4096];\n\n    build_complete_path(lpath, 4096, path, \"ebpf_process.conf\" );\n\n    if (!appconfig_load(&collector_config, lpath, 0, NULL))\n        return 1;\n\n    set_global_values();\n\n    return 0;\n}\n\nint main(int argc, char **argv)\n{\n    (void)argc;\n    (void)argv;\n\n    mykernel =  get_kernel_version();\n    if(!has_condition_to_run(mykernel)) {\n        error(\"[EBPF PROCESS] The current collector cannot run on this kernel.\");\n        return 1;\n    }\n\n    //set name\n    program_name = \"ebpf_process.plugin\";\n\n    //disable syslog\n    error_log_syslog = 0;\n\n    // set errors flood protection to 100 logs per hour\n    error_log_errors_per_period = 100;\n    error_log_throttle_period = 3600;\n\n    if (argc > 1) {\n        update_every = (int)strtol(argv[1], NULL, 10);\n    }\n\n    struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY};\n    if (setrlimit(RLIMIT_MEMLOCK, &r)) {\n        error(\"[EBPF PROCESS] setrlimit(RLIMIT_MEMLOCK)\");\n        return 2;\n    }\n\n    set_global_variables();\n\n    if (load_collector_file(user_config_dir)) {\n        info(\"[EBPF PROCESS] does not have a configuration file. It is starting with default options.\");\n        change_collector_event();\n        if (isrh >= NETDATA_MINIMUM_RH_VERSION && isrh < NETDATA_RH_8)\n            change_syscalls();\n    }\n\n    if(ebpf_load_libraries()) {\n        error(\"[EBPF_PROCESS] Cannot load library.\");\n        thread_finished++;\n        int_exit(3);\n    }\n\n    signal(SIGINT, int_exit);\n    signal(SIGTERM, int_exit);\n\n    if (process_load_ebpf()) {\n        thread_finished++;\n        int_exit(4);\n    }\n\n    if(allocate_global_vectors()) {\n        thread_finished++;\n        error(\"[EBPF_PROCESS] Cannot allocate necessary vectors.\");\n        int_exit(5);\n    }\n\n    if(mode == 1 && debug_log) {\n        if(map_memory()) {\n            thread_finished++;\n            error(\"[EBPF_PROCESS] Cannot map memory used with perf events.\");\n            int_exit(6);\n        }\n    }\n\n    set_global_labels();\n\n    if(debug_log) {\n        open_developer_log();\n    }\n\n    if (pthread_mutex_init(&lock, NULL)) {\n        thread_finished++;\n        error(\"[EBPF PROCESS] Cannot start the mutex.\");\n        int_exit(7);\n    }\n\n    pthread_attr_t attr;\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    pthread_t thread[NETDATA_EBPF_PROCESS_THREADS];\n\n    int i;\n    int end = NETDATA_EBPF_PROCESS_THREADS;\n\n    void * (*function_pointer[])(void *) = {process_publisher, process_collector, process_log };\n\n    for ( i = 0; i < end ; i++ ) {\n        if ( ( pthread_create(&thread[i], &attr, function_pointer[i], NULL) ) ) {\n            error(\"[EBPF_PROCESS] Cannot create threads.\");\n            thread_finished++;\n            int_exit(8);\n        }\n    }\n\n    for ( i = 0; i < end ; i++ ) {\n        if ( (pthread_join(thread[i], NULL) ) ) {\n            error(\"[EBPF_PROCESS] Cannot join threads.\");\n            thread_finished++;\n            int_exit(9);\n        }\n    }\n\n    thread_finished++;\n    int_exit(0);\n\n    return 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-57x57.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/alert-128-red.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/alert-multi-size-red.ico",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-72x72.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-310x150.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon-128.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/check-mark-2-128-green.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/post.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-144x144.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-72x72.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-310x310.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-96x96.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon-32x32.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/seo-performance-128.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-120x120.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/alert-128-orange.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon-16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-36x36.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-180x180.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/banner-icon-144x144.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-192x192.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon-196x196.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-precomposed.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-60x60.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-150x150.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-114x114.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-144x144.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-152x152.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-70x70.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-36x36.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/android-icon-48x48.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/ms-icon-144x144.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/animated.gif",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/apple-icon-76x76.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/check-mark-2-multi-size-green.ico",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/favicon-96x96.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/images/alert-multi-size-orange.ico",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/fonts/glyphicons-halflings-regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/fonts/glyphicons-halflings-regular.eot",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/fonts/glyphicons-halflings-regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/web/gui/fonts/glyphicons-halflings-regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/.travis/gcs-credentials.json.enc",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/docs/generator/custom/img/geography-16.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/docs/generator/custom/img/netdata_docs.png",
        "/tmp/vanessa/spack-stage/spack-stage-netdata-1.22.1-6qgq5cbg3sifep4on6bij5ksw72ln6m4/spack-src/docs/generator/custom/img/favicon.ico"
    ],
    "total_files": 1590
}