{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/src/topology_gpu.c": "/*\n * =======================================================================================\n *\n *      Filename:  topology_gpu.c\n *\n *      Description:  Topology module for GPUs\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Author:   Thomas Gruber (tg), thomas.roehl@googlemail.com\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <float.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <ctype.h>\n#include <assert.h>\n\n#include <cupti.h>\n#include <dlfcn.h>\n#include <cuda.h>\n\n#include <error.h>\n#include <likwid.h>\n\n#define CU_CALL( call, handleerror )                                    \\\n    do {                                                                \\\n        CUresult _status = (call);                                      \\\n        if (_status != CUDA_SUCCESS) {                                  \\\n            fprintf(stderr, \"Error: function %s failed with error %d.\\n\", #call, _status); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define CUAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUFUNC(funcname, funcsig) CUresult CUAPIWEAK funcname funcsig;  CUresult( *funcname##Ptr ) funcsig;\n\n\n#define CUDA_CALL( call, handleerror )                                \\\n    do {                                                                \\\n        cudaError_t _status = (call);                                   \\\n        if (_status != cudaSuccess) {                                   \\\n            fprintf(stderr, \"Error: function %s failed with error %d.\\n\", #call, _status); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define CUDAAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUDAFUNC(funcname, funcsig) cudaError_t CUDAAPIWEAK funcname funcsig;  cudaError_t( *funcname##Ptr ) funcsig;\n\n/* Copy from PAPI's cuda component (BSD License)\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2017 to support CUDA metrics)\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2015 for multiple CUDA contexts/devices)\n * @author  Heike Jagode (First version, in collaboration with Robert Dietrich, TU Dresden) jagode@icl.utk.edu\n */\nvoid (*_dl_non_dynamic_init) (void) __attribute__ ((weak));\n\nstatic void *topo_dl_libcuda = NULL;\nstatic void *topo_dl_libcudart = NULL;\nstatic int topology_gpu_initialized = 0;\nGpuTopology gpuTopology = {0, NULL};\n\n#ifdef LIKWID_WITH_NVMON\n\nDECLARECUFUNC(cuDeviceGet, (CUdevice *, int));\nDECLARECUFUNC(cuDeviceGetCount, (int *));\nDECLARECUFUNC(cuDeviceGetName, (char *, int, CUdevice));\nDECLARECUFUNC(cuInit, (unsigned int));\nDECLARECUFUNC(cuDeviceComputeCapability, (int*, int*, CUdevice));\nDECLARECUFUNC(cuDeviceGetAttribute, (int*, CUdevice_attribute, CUdevice));\nDECLARECUFUNC(cuDeviceGetProperties, (CUdevprop* prop, CUdevice));\nDECLARECUFUNC(cuDeviceTotalMem, (size_t*, CUdevice));\nDECLARECUFUNC(cuDeviceTotalMem_v2, (size_t*, CUdevice));\n\nDECLARECUDAFUNC(cudaDriverGetVersion, (int*));\nDECLARECUDAFUNC(cudaRuntimeGetVersion, (int*))\n\nstatic int\ntopo_link_libraries(void)\n{\n#define DLSYM_AND_CHECK( dllib, name ) dlsym( dllib, name ); if ( dlerror() != NULL ) { return -1; }\n\n    /* Attempt to guess if we were statically linked to libc, if so bail */\n    if(_dl_non_dynamic_init != NULL) {\n        return -1;\n    }\n    /* Need to link in the cuda libraries, if not found disable the component */\n    topo_dl_libcuda = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!topo_dl_libcuda)\n    {\n        fprintf(stderr, \"CUDA library libcuda.so not found.\\n\");\n        return -1;\n    }\n    topo_dl_libcudart = dlopen(\"libcudart.so\", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);\n    if (!topo_dl_libcudart)\n    {\n        fprintf(stderr, \"CUDA runtime library libcudart.so not found.\");\n        return -1;\n    }\n    cuDeviceGetPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceGet\");\n    cuDeviceGetCountPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceGetCount\");\n    cuDeviceGetNamePtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceGetName\");\n    cuInitPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuInit\");\n    cuDeviceComputeCapabilityPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceComputeCapability\");\n    cuDeviceGetAttributePtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceGetAttribute\");\n    cuDeviceGetPropertiesPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceGetProperties\");\n    cuDeviceTotalMemPtr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceTotalMem\");\n    \n    cudaDriverGetVersionPtr = DLSYM_AND_CHECK(topo_dl_libcudart, \"cudaDriverGetVersion\");\n    cudaRuntimeGetVersionPtr = DLSYM_AND_CHECK(topo_dl_libcudart, \"cudaRuntimeGetVersion\");\n    \n#if __CUDA_API_VERSION >= 10000\n    cuDeviceTotalMem_v2Ptr = DLSYM_AND_CHECK(topo_dl_libcuda, \"cuDeviceTotalMem_v2\");\n#endif\n    \n    return 0;\n}\n\nstatic int\ntopo_init_cuda(void)\n{\n    CUresult cuErr = (*cuInitPtr)(0);\n    if (cuErr != CUDA_SUCCESS)\n    {\n        fprintf(stderr, \"CUDA cannot be found and initialized (cuInit failed).\\n\");\n        return -ENODEV;\n    }\n    return 0;\n}\n\nstatic int\ntopo_get_numDevices(void)\n{\n    CUresult cuErr;\n    int count = 0;\n    cuErr = (*cuDeviceGetCountPtr)(&count);\n    if(cuErr == CUDA_ERROR_NOT_INITIALIZED)\n    {\n        int ret = topo_init_cuda();\n        if (ret == 0)\n        {\n            cuErr = (*cuDeviceGetCountPtr)(&count);\n        }\n        else\n        {\n            return ret;\n        }\n    }\n    return count;\n}\n\nstatic int\ntopo_get_numNode(int pci_bus, int pci_dev, int pci_domain)\n{\n    char fname[1024];\n    char buff[100];\n    int ret = snprintf(fname, 1023, \"/sys/bus/pci/devices/0000:%02x:%02x.%1x/numa_node\", pci_bus, pci_dev, pci_domain);\n    if (ret > 0)\n    {\n        fname[ret] = '\\0';\n        FILE* fp = fopen(fname, \"r\");\n        if (fp)\n        {\n            ret = fread(buff, sizeof(char), 99, fp);\n            int numa_node = atoi(buff);\n            fclose(fp);\n            return numa_node;\n        }\n    }\n    return -1;\n}\n\nstatic int topology_gpu_cleanup(int idx, int err)\n{\n    for (int j = idx; j >= 0; j--)\n    {\n        free(gpuTopology.devices[j].name);\n    }\n    return err;\n}\n\nint\ntopology_gpu_init()\n{\n    int i = 0;\n    int ret = 0;\n    int cuda_version = 0;\n    int cudart_version = 0;\n    if (topology_gpu_initialized)\n    {\n        return EXIT_SUCCESS;\n    }\n    ret = topo_link_libraries();\n    if (ret != 0)\n    {\n        ERROR_PLAIN_PRINT(Cannot open CUDA library to fill GPU topology);\n        return EXIT_FAILURE;\n    }\n    int num_devs = topo_get_numDevices();\n    if (num_devs < 0)\n    {\n        ERROR_PLAIN_PRINT(Cannot get number of devices from CUDA library);\n        return EXIT_FAILURE;\n    }\n    CUDA_CALL((*cudaDriverGetVersionPtr)(&cuda_version), ret = -1; goto topology_gpu_init_error;);\n    CUDA_CALL((*cudaRuntimeGetVersionPtr)(&cudart_version), ret = -1; goto topology_gpu_init_error;);\n    if (num_devs > 0)\n    {\n        gpuTopology.devices = malloc(num_devs * sizeof(GpuDevice));\n        if (!gpuTopology.devices)\n        {\n            return -ENOMEM;\n        }\n        for (i = 0; i < num_devs; i++)\n        {\n            CUdevice dev;\n            CU_CALL((*cuDeviceGetPtr)(&dev, i), ret = -ENODEV; goto topology_gpu_init_error;);\n            size_t s = 0;\n#if __CUDA_API_VERSION >= 10000\n            if (cuda_version >= 10000 && cudart_version >= 10000)\n                CU_CALL((*cuDeviceTotalMem_v2Ptr)(&s, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n                if (s == 0)\n                {\n                    CU_CALL((*cuDeviceTotalMemPtr)(&s, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n                }\n            else\n            {\n                CU_CALL((*cuDeviceTotalMemPtr)(&s, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            }\n#else\n            CU_CALL((*cuDeviceTotalMemPtr)(&s, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n#endif\n            gpuTopology.devices[i].mem = (unsigned long long)s;\n            gpuTopology.devices[i].name = malloc(1024 * sizeof(char));\n            if (!gpuTopology.devices[i].name)\n            {\n                ERROR_PRINT(Cannot allocate space for name of GPU %d, i);\n                ret = -ENOMEM;\n                goto topology_gpu_init_error;\n            }\n            CU_CALL((*cuDeviceGetNamePtr)(gpuTopology.devices[i].name, 1023, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            gpuTopology.devices[i].name[1024] = '\\0';\n            gpuTopology.devices[i].devid = i;\n\n            CU_CALL((*cuDeviceComputeCapabilityPtr)(&gpuTopology.devices[i].ccapMajor, &gpuTopology.devices[i].ccapMinor, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CUdevprop props;\n            CU_CALL((*cuDeviceGetPropertiesPtr)(&props, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            gpuTopology.devices[i].maxThreadsPerBlock = props.maxThreadsPerBlock;\n            gpuTopology.devices[i].maxThreadsDim[0] = props.maxThreadsDim[0];\n            gpuTopology.devices[i].maxThreadsDim[1] = props.maxThreadsDim[1];\n            gpuTopology.devices[i].maxThreadsDim[2] = props.maxThreadsDim[2];\n            gpuTopology.devices[i].maxGridSize[0] = props.maxGridSize[0];\n            gpuTopology.devices[i].maxGridSize[1] = props.maxGridSize[1];\n            gpuTopology.devices[i].maxGridSize[2] = props.maxGridSize[2];\n            gpuTopology.devices[i].sharedMemPerBlock = props.sharedMemPerBlock;\n            gpuTopology.devices[i].totalConstantMemory = props.totalConstantMemory;\n            gpuTopology.devices[i].simdWidth = props.SIMDWidth;\n            gpuTopology.devices[i].memPitch = props.memPitch;\n            gpuTopology.devices[i].clockRatekHz = props.clockRate;\n            gpuTopology.devices[i].textureAlign = props.textureAlign;\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].l2Size, CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].memClockRatekHz, CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].memClockRatekHz, CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].pciBus, CU_DEVICE_ATTRIBUTE_PCI_BUS_ID, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].pciDev, CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].pciDom, CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].maxBlockRegs, CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].numMultiProcs, CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].maxThreadPerMultiProc, CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].memBusWidth, CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].unifiedAddrSpace, CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].ecc, CU_DEVICE_ATTRIBUTE_ECC_ENABLED, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].asyncEngines, CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].mapHostMem, CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].integrated, CU_DEVICE_ATTRIBUTE_INTEGRATED, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n            CU_CALL((*cuDeviceGetAttributePtr)(&gpuTopology.devices[i].surfaceAlign, CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT, dev), ret = -ENOMEM; goto topology_gpu_init_error;);\n\n            gpuTopology.devices[i].numaNode = topo_get_numNode(gpuTopology.devices[i].pciBus, gpuTopology.devices[i].pciDev, gpuTopology.devices[i].pciDom);\n        }\n        gpuTopology.numDevices = num_devs;\n    }\n    topology_gpu_initialized = 1;\n    return EXIT_SUCCESS;\ntopology_gpu_init_error:\n    for (int j = 0; j < i; j++)\n    {\n        topology_gpu_cleanup(i-1, 0);\n    }\n    return ret;\n}\n\n\nvoid\ntopology_gpu_finalize(void)\n{\n    if (topology_gpu_initialized)\n    {\n        int ret = topology_gpu_cleanup(gpuTopology.numDevices-1, 0);\n    }\n}\n\nGpuTopology_t\nget_gpuTopology(void)\n{\n    if (topology_gpu_initialized)\n    {\n        return &gpuTopology;\n    }\n}\n\n#endif /* LIKWID_WITH_NVMON */\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/src/includes/nvmon_cupti.h": "/*\n * =======================================================================================\n *\n *      Filename:  nvmon_cupti.h\n *\n *      Description:  Header File of nvmon module (CUPTI backend).\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Author:   Thomas Gruber (tg), thomas.gruber@googlemail.com\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n\n#ifndef LIKWID_NVMON_CUPTI_H\n#define LIKWID_NVMON_CUPTI_H\n\n\n#include <cuda.h>\n#include <cupti.h>\n\n/* Copy from PAPI's cuda component (BSD License)\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2017 to support CUDA metrics)\n * @author  Asim YarKhan yarkhan@icl.utk.edu (updated in 2015 for multiple CUDA contexts/devices)\n * @author  Heike Jagode (First version, in collaboration with Robert Dietrich, TU Dresden) jagode@icl.utk.edu\n */\nvoid (*_dl_non_dynamic_init) (void) __attribute__ ((weak));\n\n#define CU_CALL( call, handleerror )                                    \\\n    do {                                                                \\\n        CUresult _status = (call);                                      \\\n        if (_status != CUDA_SUCCESS) {                                  \\\n            fprintf(stderr, \"Error: function %s failed with error %d.\\n\", #call, _status); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define CUPTI_CALL(call, handleerror)                                 \\\n    do {                                                                \\\n        CUptiResult _status = (call);                                   \\\n        if (_status != CUPTI_SUCCESS) {                                 \\\n            const char *errstr;                                         \\\n            (*cuptiGetResultString)(_status, &errstr);               \\\n            fprintf(stderr, \"Error: function %s failed with error %s.\\n\", #call, errstr); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define CUDA_CALL( call, handleerror )                                \\\n    do {                                                                \\\n        cudaError_t _status = (call);                                   \\\n        if (_status != cudaSuccess) {                                   \\\n            fprintf(stderr, \"Error: function %s failed with error %d.\\n\", #call, _status); \\\n            handleerror;                                                \\\n        }                                                               \\\n    } while (0)\n\n#define CUAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUFUNC(funcname, funcsig) CUresult CUAPIWEAK funcname funcsig;  CUresult( *funcname##Ptr ) funcsig;\nDECLARECUFUNC(cuCtxGetCurrent, (CUcontext *));\nDECLARECUFUNC(cuCtxSetCurrent, (CUcontext));\nDECLARECUFUNC(cuCtxDestroy, (CUcontext));\nDECLARECUFUNC(cuDeviceGet, (CUdevice *, int));\nDECLARECUFUNC(cuDeviceGetCount, (int *));\nDECLARECUFUNC(cuDeviceGetName, (char *, int, CUdevice));\nDECLARECUFUNC(cuInit, (unsigned int));\nDECLARECUFUNC(cuCtxPopCurrent, (CUcontext * pctx));\nDECLARECUFUNC(cuCtxPushCurrent, (CUcontext pctx));\nDECLARECUFUNC(cuCtxSynchronize, ());\n\n#define CUDAAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUDAFUNC(funcname, funcsig) cudaError_t CUDAAPIWEAK funcname funcsig;  cudaError_t( *funcname##Ptr ) funcsig;\nDECLARECUDAFUNC(cudaGetDevice, (int *));\nDECLARECUDAFUNC(cudaSetDevice, (int));\nDECLARECUDAFUNC(cudaFree, (void *));\n\n#define CUPTIAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUPTIFUNC(funcname, funcsig) CUptiResult CUPTIAPIWEAK funcname funcsig;  CUptiResult( *funcname##Ptr ) funcsig;\nDECLARECUPTIFUNC(cuptiEventGroupGetAttribute, (CUpti_EventGroup eventGroup, CUpti_EventGroupAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiDeviceGetEventDomainAttribute, (CUdevice device, CUpti_EventDomainID eventDomain, CUpti_EventDomainAttribute attrib, size_t * valueSize, void *value));\nDECLARECUPTIFUNC(cuptiEventGroupReadEvent, (CUpti_EventGroup eventGroup, CUpti_ReadEventFlags flags, CUpti_EventID event, size_t * eventValueBufferSizeBytes, uint64_t *        eventValueBuffer));\nDECLARECUPTIFUNC(cuptiEventGroupSetAttribute, (CUpti_EventGroup eventGroup, CUpti_EventGroupAttribute attrib, size_t valueSize, void *value));\nDECLARECUPTIFUNC(cuptiEventGroupSetDisable, (CUpti_EventGroupSet * eventGroupSet));\nDECLARECUPTIFUNC(cuptiEventGroupSetEnable, (CUpti_EventGroupSet * eventGroupSet));\nDECLARECUPTIFUNC(cuptiEventGroupSetsCreate, (CUcontext context, size_t eventIdArraySizeBytes, CUpti_EventID * eventIdArray, CUpti_EventGroupSets ** eventGroupPasses));\nDECLARECUPTIFUNC(cuptiEventGroupSetsDestroy, (CUpti_EventGroupSets * eventGroupSets));\nDECLARECUPTIFUNC(cuptiGetTimestamp, (uint64_t * timestamp));\nDECLARECUPTIFUNC(cuptiSetEventCollectionMode, (CUcontext context, CUpti_EventCollectionMode mode));\nDECLARECUPTIFUNC(cuptiDeviceEnumEventDomains, (CUdevice, size_t *, CUpti_EventDomainID *));\nDECLARECUPTIFUNC(cuptiDeviceGetNumEventDomains, (CUdevice, uint32_t *));\nDECLARECUPTIFUNC(cuptiEventDomainEnumEvents, (CUpti_EventDomainID, size_t *, CUpti_EventID *));\nDECLARECUPTIFUNC(cuptiEventDomainGetNumEvents, (CUpti_EventDomainID, uint32_t *));\nDECLARECUPTIFUNC(cuptiEventGetAttribute, (CUpti_EventID, CUpti_EventAttribute, size_t *, void *));\nDECLARECUPTIFUNC(cuptiGetResultString, (CUptiResult result, const char **str));\n\n\nstatic void *dl_libcuda = NULL;\nstatic void *dl_libcudart = NULL;\nstatic void *dl_libcupti = NULL;\n\nstatic int\nlink_cputi_libraries(void)\n{\n#define DLSYM_AND_CHECK( dllib, name ) dlsym( dllib, name ); if ( dlerror() != NULL ) { return -1; }\n\n    /* Attempt to guess if we were statically linked to libc, if so bail */\n    if(_dl_non_dynamic_init != NULL) {\n        return -1;\n    }\n    /* Need to link in the cuda libraries, if not found disable the component */\n    dl_libcuda = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!dl_libcuda)\n    {\n        fprintf(stderr, \"CUDA library libcuda.so not found.\");\n        return -1;\n    }\n    cuCtxGetCurrentPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxGetCurrent\");\n    cuCtxSetCurrentPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxSetCurrent\");\n    cuDeviceGetPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuDeviceGet\");\n    cuDeviceGetCountPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuDeviceGetCount\");\n    cuDeviceGetNamePtr = DLSYM_AND_CHECK(dl_libcuda, \"cuDeviceGetName\");\n    cuInitPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuInit\");\n    cuCtxPopCurrentPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxPopCurrent\");\n    cuCtxPushCurrentPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxPushCurrent\");\n    cuCtxSynchronizePtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxSynchronize\");\n    cuCtxDestroyPtr = DLSYM_AND_CHECK(dl_libcuda, \"cuCtxDestroy\");\n\n    dl_libcudart = dlopen(\"libcudart.so\", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);\n    if (!dl_libcudart)\n    {\n        fprintf(stderr, \"CUDA runtime library libcudart.so not found.\");\n        return -1;\n    }\n    cudaGetDevicePtr = DLSYM_AND_CHECK(dl_libcudart, \"cudaGetDevice\");\n    cudaSetDevicePtr = DLSYM_AND_CHECK(dl_libcudart, \"cudaSetDevice\");\n    cudaFreePtr = DLSYM_AND_CHECK(dl_libcudart, \"cudaFree\");\n\n    dl_libcupti = dlopen(\"libcupti.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!dl_libcupti)\n    {\n        fprintf(stderr, \"CUDA runtime library libcupti.so not found.\");\n        return -1;\n    }\n    cuptiDeviceGetEventDomainAttributePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiDeviceGetEventDomainAttribute\");\n    cuptiEventGroupGetAttributePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupGetAttribute\");\n    cuptiEventGroupReadEventPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupReadEvent\");\n    cuptiEventGroupSetAttributePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupSetAttribute\");\n    cuptiEventGroupSetDisablePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupSetDisable\");\n    cuptiEventGroupSetEnablePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupSetEnable\");\n    cuptiEventGroupSetsCreatePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupSetsCreate\");\n    cuptiEventGroupSetsDestroyPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGroupSetsDestroy\");\n    cuptiGetTimestampPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiGetTimestamp\");\n    cuptiSetEventCollectionModePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiSetEventCollectionMode\");\n    cuptiDeviceEnumEventDomainsPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiDeviceEnumEventDomains\");\n    cuptiDeviceGetNumEventDomainsPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiDeviceGetNumEventDomains\");\n    cuptiEventDomainEnumEventsPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventDomainEnumEvents\");\n    cuptiEventDomainGetNumEventsPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventDomainGetNumEvents\");\n    cuptiEventGetAttributePtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiEventGetAttribute\");\n    cuptiGetResultStringPtr = DLSYM_AND_CHECK(dl_libcupti, \"cuptiGetResultString\");\n    return 0;\n}\n\n\nstatic int check_nv_context(NvmonDevice_t device, CUcontext currentContext)\n{\n    int j = 0;\n    int need_pop = 0;\n    GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Current context %ld DevContext %ld, currentContext, device->context);\n    if (!device->context)\n    {\n        int context_of_dev = -1;\n        for (j = 0; j < nvGroupSet->numberOfGPUs; j++)\n        {\n            NvmonDevice_t dev = &nvGroupSet->gpus[j];\n            if (dev->context == currentContext)\n            {\n                context_of_dev = j;\n                break;\n            }\n        }\n        if (context_of_dev < 0 && !device->context)\n        {\n            device->context = currentContext;\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Reuse context %ld for device %d, device->context, device->deviceId);\n        }\n        else\n        {\n            CUDA_CALL((*cudaSetDevicePtr)(device->deviceId), return -EFAULT);\n            CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);\n            CU_CALL((*cuCtxGetCurrentPtr)(&device->context), return -EFAULT);\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, New context %ld for device %d, device->context, device->deviceId);\n        }\n    }\n    else if (device->context != currentContext)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Use context %ld for device %d, device->context, device->deviceId);\n        CU_CALL((*cuCtxPushCurrentPtr)(device->context), return -EFAULT);\n        need_pop = 1;\n    }\n    else\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Context %ld fits for device %d, device->context, device->deviceId);\n    }\n    return need_pop;\n}\n\nstatic int\ninit_cuda(void)\n{\n    CUresult cuErr = (*cuInitPtr)(0);\n    if (cuErr != CUDA_SUCCESS)\n    {\n        fprintf(stderr, \"CUDA cannot be found and initialized (cuInit failed).\\n\");\n        return -ENODEV;\n    }\n    return 0;\n}\n\nstatic int\nget_numDevices(void)\n{\n    CUresult cuErr;\n    int count = 0;\n    cuErr = (*cuDeviceGetCountPtr)(&count);\n    if(cuErr == CUDA_ERROR_NOT_INITIALIZED)\n    {\n        int ret = init_cuda();\n        if (ret == 0)\n        {\n            cuErr = (*cuDeviceGetCountPtr)(&count);\n        }\n        else\n        {\n            return ret;\n        }\n    }\n    return count;\n}\n\nvoid nvmon_cupti_freeDevice(NvmonDevice_t dev)\n{\n    int j = 0;\n    GHashTableIter iter;\n    char* name = NULL;\n    uint32_t *id = NULL;\n    NvmonEvent_t event = NULL;\n    if (dev)\n    {\n        if (dev->context)\n        {\n            CU_CALL((*cuCtxDestroyPtr)(dev->context), j++);\n            dev->context = NULL;\n        }\n        if (dev->cuEventSets)\n        {\n            CUPTI_CALL((*cuptiEventGroupSetsDestroyPtr)(dev->cuEventSets), j++);\n            dev->cuEventSets = NULL;\n        }\n\n        // The event objects are freed here\n\n        if (dev->activeEvents)\n        {\n            free(dev->activeEvents);\n            dev->activeEvents = NULL;\n            dev->numActiveEvents = 0;\n        }\n\n        if (dev->nvEventSets)\n        {\n            for (j = 0; j < dev->numNvEventSets; j++)\n            {\n                free(dev->nvEventSets[j].results);\n            }\n            free(dev->nvEventSets);\n            dev->nvEventSets = NULL;\n            dev->numNvEventSets = 0;\n        }\n        if (dev->allevents)\n        {\n            for (j = 0; j < dev->numAllEvents; j++)\n            {\n                if (dev->allevents[j])\n                {\n                    free(dev->allevents[j]);\n                }\n            }\n        }\n        memset(dev, 0, sizeof(NvmonDevice));\n    }\n    return;\n}\n\nint\nnvmon_cupti_createDevice(int id, NvmonDevice *dev)\n{\n    int j = 0, k = 0, c = 0;\n    int numDomains = 0;\n    CUpti_EventDomainID* eventDomainIds = NULL;\n    int eventIdx = 0;\n    uint32_t totalEvents = 0;\n\n\n    dev->deviceId = id;\n    dev->cuEventSets = NULL;\n    dev->context = 0UL;\n    dev->activeEvents = NULL;\n    dev->numActiveEvents = 0;\n    dev->numNvEventSets = 0;\n    dev->nvEventSets = NULL;\n\n    if ((!dl_libcuda) || (!dl_libcudart) || (!dl_libcupti))\n    {\n        int err = link_cputi_libraries();\n        if (err < 0)\n        {\n            return -1;\n        }\n    }\n\n    // Assign device ID and get cuDevice from CUDA\n    CU_CALL((*cuDeviceGetPtr)(&dev->cuDevice, id), return -1);\n\n    // Get the number of event domains of the device\n    CUPTI_CALL((*cuptiDeviceGetNumEventDomainsPtr)(dev->cuDevice, &numDomains), return -1);\n    GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Nvmon: Dev %d Domains %d, id, numDomains);\n\n    // Get the domain IDs for the device\n    size_t domainarraysize = numDomains * sizeof(CUpti_EventDomainID);\n    eventDomainIds = malloc(domainarraysize);\n    if (!eventDomainIds) return -ENOMEM;\n    CUPTI_CALL((*cuptiDeviceEnumEventDomainsPtr)(dev->cuDevice, &domainarraysize, eventDomainIds), return -1);\n\n\n    // Count the events in all domains to allocate the event list\n    dev->numAllEvents = 0;\n    for (j = 0; j < numDomains; j++)\n    {\n        uint32_t domainNumEvents = 0;\n        CUpti_EventDomainID domainID = eventDomainIds[j];\n        CUPTI_CALL((*cuptiEventDomainGetNumEventsPtr)(domainID, &domainNumEvents), return -1);\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Nvmon: Dev %d Domain %d Events %d, id, j, domainNumEvents);\n        totalEvents += domainNumEvents;\n    }\n    // Now we now how many events are provided by the device, so allocate a big enough event list\n    dev->allevents = malloc(totalEvents * sizeof(NvmonEvent_t));\n    if (!dev->allevents)\n    {\n        free(eventDomainIds);\n        return -ENOMEM;\n    }\n\n    // We use hash tables for faster access\n    dev->eventHash = g_hash_table_new(g_str_hash, g_str_equal);\n    dev->evIdHash = g_hash_table_new(g_int64_hash, g_int64_equal);\n\n    for (j = 0; j < numDomains; j++)\n    {\n        uint32_t domainNumEvents = 0;\n        CUpti_EventDomainID domainID = eventDomainIds[j];\n        // How many events are provided by the domain\n        CUPTI_CALL((*cuptiEventDomainGetNumEventsPtr)(domainID, &domainNumEvents), return -1);\n        size_t tmpSize = domainNumEvents * sizeof(CUpti_EventID);\n        // Allocate space for all CUPTI event IDs in the domain\n        CUpti_EventID* cuEventIds = malloc(tmpSize);\n        // Get the CUPTI events\n        CUPTI_CALL((*cuptiEventDomainEnumEventsPtr)(domainID, &tmpSize, cuEventIds), return -1);\n        for (k = 0; k < domainNumEvents; k++)\n        {\n            CUpti_EventID eventId = cuEventIds[k];\n            // Name and description are limited in length\n            size_t tmpSizeBytesName = (NVMON_DEFAULT_STR_LEN-1) * sizeof(char);\n            size_t tmpSizeBytesDesc = (NVMON_DEFAULT_STR_LEN-1) * sizeof(char);\n\n            NvmonEvent_t event = malloc(sizeof(NvmonEvent));\n            if (!event)\n            {\n                free(cuEventIds);\n                free(dev->allevents);\n                free(eventDomainIds);\n                return -ENOMEM;\n            }\n\n            // Get event name and description\n            CUPTI_CALL((*cuptiEventGetAttributePtr)(eventId, CUPTI_EVENT_ATTR_NAME, &tmpSizeBytesName, event->name), return -1);\n            CUPTI_CALL((*cuptiEventGetAttributePtr)(eventId, CUPTI_EVENT_ATTR_LONG_DESCRIPTION, &tmpSizeBytesDesc, event->description), return -1);\n            event->name[tmpSizeBytesName/sizeof(char)] = '\\0';\n            event->description[tmpSizeBytesDesc/sizeof(char)] = '\\0';\n            // LIKWID events are all uppercase, so transform the event names\n            c = 0;\n            while (event->name[c] != '\\0')\n            {\n                event->name[c] = toupper(event->name[c]);\n                c++;\n            }\n            // Save all gathered information in a NvmonEvent object\n\n            event->cuEventId = eventId;\n            event->eventId = dev->numAllEvents;\n            event->cuDomainId = domainID;\n            event->domainId = j;\n            event->type = NVMON_CUPTI_EVENT;\n            event->active = 0;\n            //GPUDEBUG_PRINT(DEBUGLEV_DETAIL, New Event %d CuEvent %d Domain %d CuDomain %d Name %s, event->eventId, (int)event->cuEventId, event->domainId, (int)event->cuDomainId, event->name);\n            // Add the object to the event list\n            dev->allevents[dev->numAllEvents] = event;\n            dev->numAllEvents++;\n            // Add the object to the hash tables\n            char* nameKey = g_strdup(event->name);\n\n            CUpti_EventID* idKey = malloc(sizeof(CUpti_EventID));\n            if (idKey)\n            {\n                *idKey = event->cuEventId;\n                // Key is event name\n                g_hash_table_insert(dev->eventHash, (gpointer)nameKey, (gpointer)event);\n                // Key is CUPTI event ID\n                g_hash_table_insert(dev->evIdHash, (gpointer)idKey, (gpointer)event);\n            }\n        }\n    }\n\n/*    CUDA_CALL((*cudaSetDevicePtr)(dev->deviceId), return -EFAULT);*/\n/*    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);*/\n/*    CU_CALL((*cuCtxGetCurrentPtr)(&dev->context), return -EFAULT);*/\n    return 0;\n}\n\n\n\nint nvmon_cupti_getEventsOfGpu(int gpuId, NvmonEventList_t* list)\n{\n    int ret = 0;\n    NvmonDevice device;\n    int err = nvmon_cupti_createDevice(gpuId, &device);\n    if (!err)\n    {\n        NvmonEventList_t l = malloc(sizeof(NvmonEventList));\n        if (l)\n        {\n            l->events = malloc(sizeof(NvmonEventListEntry) * device.numAllEvents);\n            if (l->events)\n            {\n                for (int i = 0; i < device.numAllEvents; i++)\n                {\n                    NvmonEventListEntry* out = &l->events[i];\n                    NvmonEvent_t event = device.allevents[i];\n                    out->name = malloc(strlen(event->name)+2);\n                    if (out->name)\n                    {\n                        ret = snprintf(out->name, strlen(event->name)+1, \"%s\", event->name);\n                        if (ret > 0)\n                        {\n                            out->name[ret] = '\\0';\n                        }\n                    }\n                    out->desc = malloc(strlen(event->description)+2);\n                    if (out->desc)\n                    {\n                        ret = snprintf(out->desc, strlen(event->description)+1, \"%s\", event->description);\n                        if (ret > 0)\n                        {\n                            out->desc[ret] = '\\0';\n                        }\n                    }\n                    out->limit = malloc(10*sizeof(char));\n                    if (out->limit)\n                    {\n                        switch (event->type)\n                        {\n                            case NVMON_CUPTI_EVENT:\n                                ret = snprintf(out->limit, 9, \"GPU\");\n                                if (ret > 0) out->limit[ret] = '\\0';\n                                break;\n                        }\n                    }\n                }\n                l->numEvents = device.numAllEvents;\n                *list = l;\n            }\n            else\n            {\n                free(l);\n                nvmon_cupti_freeDevice(&device);\n                return -ENOMEM;\n            }\n        }\n    }\n    else\n    {\n        ERROR_PRINT(No such device %d, gpuId);\n    }\n    return 0;\n}\n\n\n\nint\nnvmon_cupti_addEventSets(NvmonDevice_t device, const char* eventString)\n{\n    int i = 0;\n    int err = 0;\n    int curDeviceId = -1;\n    CUcontext curContext;\n    struct bstrList* eventtokens = NULL;\n\n    CUDA_CALL((*cudaGetDevicePtr)(&curDeviceId), return -EFAULT);\n    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n\n    bstring eventBString = bfromcstr(eventString);\n    eventtokens = bsplit(eventBString, ',');\n    bdestroy(eventBString);\n\n    if (curDeviceId != device->deviceId)\n    {\n        CUDA_CALL((*cudaSetDevicePtr)(device->deviceId), return -EFAULT);\n    }\n\n    size_t sizeBytes = (eventtokens->qty) * sizeof(CUpti_EventID);\n\n    int popContext = 0;\n    CUpti_EventGroupSets * cuEventSets = NULL;\n\n    NvmonEventSet* tmpEventSet = realloc(device->nvEventSets, (device->numNvEventSets+1)*sizeof(NvmonEventSet));\n    if (!tmpEventSet)\n    {\n        ERROR_PRINT(Cannot enlarge GPU %d eventSet list, device->deviceId);\n        return -ENOMEM;\n    }\n    device->nvEventSets = tmpEventSet;\n    NvmonEventSet* devEventSet = &device->nvEventSets[device->numNvEventSets];\n\n    devEventSet->nvEvents = (NvmonEvent_t*) malloc(eventtokens->qty * sizeof(NvmonEvent_t));\n    if (devEventSet->nvEvents == NULL)\n    {\n        ERROR_PRINT(Cannot allocate event list for group %d\\n, groupSet->numberOfActiveGroups);\n        return -ENOMEM;\n    }\n    devEventSet->cuEventIDs = (CUpti_EventID*) malloc(eventtokens->qty * sizeof(CUpti_EventID));\n    if (devEventSet->cuEventIDs == NULL)\n    {\n        ERROR_PRINT(Cannot allocate event ID list for group %d\\n, groupSet->numberOfActiveGroups);\n        free(devEventSet->nvEvents);\n        return -ENOMEM;\n    }\n    devEventSet->results = malloc(eventtokens->qty * sizeof(NvmonEventResult));\n    if (devEventSet->cuEventIDs == NULL)\n    {\n        ERROR_PRINT(Cannot allocate result list for group %d\\n, groupSet->numberOfActiveGroups);\n        free(devEventSet->cuEventIDs);\n        free(devEventSet->nvEvents);\n        return -ENOMEM;\n    }\n    memset(devEventSet->results, 0, eventtokens->qty * sizeof(NvmonEventResult));\n    devEventSet->numberOfEvents = 0;\n\n    // If the device has no context, check whether the current context is\n    // used already by another device\n    popContext = check_nv_context(device, curContext);\n\n\n    CUPTI_CALL((*cuptiSetEventCollectionModePtr)(device->context, CUPTI_EVENT_COLLECTION_MODE_KERNEL), return -EFAULT);\n\n    for (i = 0; i < eventtokens->qty; i++)\n    {\n        struct bstrList* evset = bsplit(eventtokens->entry[i], ':');\n        if (evset->qty != 2)\n        {\n            ERROR_PRINT(NVMON: Event %s invalid: Format <event>:<gpucounter>, bdata(eventtokens->entry[i]));\n        }\n        if (blength(evset->entry[0]) == 0 || blength(evset->entry[1]) == 0)\n        {\n            ERROR_PRINT(NVMON: Event %s invalid: Format <event>:<gpucounter>, bdata(eventtokens->entry[i]));\n        }\n        NvmonEvent_t event = g_hash_table_lookup(device->eventHash, (gpointer)bdata(evset->entry[0]));\n        if (!event)\n        {\n            GPUDEBUG_PRINT(DEBUGLEV_INFO, NVMON: Event %s unknown. Skipping..., bdata(evset->entry[0]));\n            continue; //unknown event\n        }\n        else\n        {\n            devEventSet->cuEventIDs[devEventSet->numberOfEvents] = event->cuEventId;\n            devEventSet->nvEvents[devEventSet->numberOfEvents] = event;\n            devEventSet->numberOfEvents++;\n            size_t s = devEventSet->numberOfEvents*sizeof(CUpti_EventID);\n\n            CUPTI_CALL((*cuptiEventGroupSetsCreatePtr)(device->context, s, devEventSet->cuEventIDs, &cuEventSets), devEventSet->numberOfEvents--;);\n            if (cuEventSets->numSets > 1)\n            {\n                ERROR_PRINT(Error adding event %s. Multiple measurement runs are required. skipping event ..., bdata(evset->entry[i]));\n                continue;\n            }\n        }\n    }\n    devEventSet->id = nvGroupSet->numberOfActiveGroups;\n    // Create an eventset with the currently configured and current event\n    if(popContext)\n    {\n        CU_CALL((*cuCtxPopCurrentPtr)(&device->context), return -EFAULT);\n    }\n    device->numNvEventSets++;\n}\n\nint nvmon_cupti_setupCounters(NvmonDevice_t device, NvmonEventSet* eventSet)\n{\n    int err = 0;\n    int popContext = 0;\n    int oldDevId = -1;\n    CUpti_EventGroupSets * cuEventSets = NULL;\n    CUcontext curContext;\n\n    if (eventSet->numberOfEvents == 0)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DETAIL, Skipping GPU%d it has no events in group %d, device->deviceId, eventSet->id);\n        return -EINVAL;\n    }\n    // Currently we are on which device?\n    CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    // This is a workaround to (eventually create and) get the current context\n    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n\n    popContext = check_nv_context(device, curContext);\n\n\n    size_t grpEventIdsSize = eventSet->numberOfEvents * sizeof(CUpti_EventID);\n    CUPTI_CALL((*cuptiEventGroupSetsCreatePtr)(device->context, grpEventIdsSize, eventSet->cuEventIDs, &cuEventSets), err = -1;);\n    // Allocate temporary array to hold the group event IDs\n    CUpti_EventID *grpEventIds = malloc(grpEventIdsSize);\n    if (!grpEventIds)\n    {\n        return -ENOMEM;\n    }\n    // Delete current activeEvent list\n    if (device->activeEvents)\n    {\n        free(device->activeEvents);\n        device->activeEvents = NULL;\n        device->numActiveEvents = 0;\n    }\n    // Delete current activeCuGroups list\n    if (device->activeCuGroups)\n    {\n        free(device->activeCuGroups);\n        device->activeCuGroups = NULL;\n        device->numActiveCuGroups = 0;\n    }\n\n    // Create a new activeEvent list\n    device->activeEvents = malloc(eventSet->numberOfEvents * sizeof(NvmonActiveEvent));\n    if (!device->activeEvents)\n    {\n        free(grpEventIds);\n        grpEventIds = NULL;\n        return -ENOMEM;\n    }\n    // Create a new activeCuGroups list\n    device->activeCuGroups = malloc(cuEventSets->numSets * sizeof(CUpti_EventGroupSet**));\n    if (!device->activeCuGroups)\n    {\n        free(device->activeEvents);\n        device->activeEvents = NULL;\n        free(grpEventIds);\n        grpEventIds = NULL;\n        return -ENOMEM;\n    }\n\n\n    // Run over eventset and store all information we need for start/stop/reads in NvmonActiveEvent_t\n    CUpti_EventGroup curGroup;\n    uint32_t curNumInstances = 0, curNumTotalInstances = 0;\n    CUpti_EventGroupSet *curEventGroupSet;\n    for (int j = 0; j < cuEventSets->numSets; j++)\n    {\n        size_t sizeofuint32t = sizeof(uint32_t);\n        uint32_t numGEvents = 0, numGInstances = 0, numTotalGInstances = 0;\n        CUpti_EventGroupSet* groupset = &cuEventSets->sets[j];\n\n        for (int k = 0; k < groupset->numEventGroups; k++)\n        {\n            uint32_t one = 1;\n            CUpti_EventGroup group = groupset->eventGroups[k];\n            // Get the number of events in the group\n            CUPTI_CALL((*cuptiEventGroupGetAttributePtr)(group, CUPTI_EVENT_GROUP_ATTR_NUM_EVENTS, &sizeofuint32t, &numGEvents), return -EFAULT);\n            // Get the CUPTI event IDs in the group\n            CUPTI_CALL((*cuptiEventGroupGetAttributePtr)(group, CUPTI_EVENT_GROUP_ATTR_EVENTS, &grpEventIdsSize, grpEventIds), return -EFAULT);\n            // If we don't set this, each event has only a single instance but we want to measure all instances\n            CUPTI_CALL((*cuptiEventGroupSetAttributePtr)(group, CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES, sizeof(uint32_t), &one), return -EFAULT);\n            // Get instance count for a group\n            CUPTI_CALL((*cuptiEventGroupGetAttributePtr)(group, CUPTI_EVENT_GROUP_ATTR_INSTANCE_COUNT, &sizeofuint32t, &numGInstances), return -EFAULT);\n\n            for (int l = 0; l < numGEvents; l++)\n            {\n                for (int m = 0; m <  eventSet->numberOfEvents; m++)\n                {\n                    if (eventSet->cuEventIDs[m] == grpEventIds[l])\n                    {\n                        CUpti_EventDomainID did = eventSet->nvEvents[m]->cuDomainId;\n                        // Get total instance count for a group\n                        CUPTI_CALL((*cuptiDeviceGetEventDomainAttributePtr)(device->cuDevice, did, CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT, &sizeofuint32t, &numTotalGInstances), return -EFAULT);\n                        device->activeEvents[m].eventId = eventSet->nvEvents[m]->eventId;\n                        device->activeEvents[m].idxInSet = m;\n                        device->activeEvents[m].groupId = eventSet->id;\n                        device->activeEvents[m].cuEventId = eventSet->nvEvents[m]->cuEventId;\n                        device->activeEvents[m].cuDomainId = did;\n                        device->activeEvents[m].numTotalInstances = numTotalGInstances;\n                        device->activeEvents[m].cuGroup = group;\n                        device->activeEvents[m].cuGroupSet = groupset;\n                        device->activeEvents[m].numInstances = numGInstances;\n                        device->activeEvents[m].deviceId = device->deviceId;\n\n                        int found = 0;\n                        for (int i = 0; i < device->numActiveCuGroups; i++)\n                        {\n                            if (device->activeCuGroups[i] == groupset)\n                            {\n                                found = 1;\n                            }\n                        }\n                        if (!found)\n                        {\n                            device->activeCuGroups[device->numActiveCuGroups] = groupset;\n                            device->numActiveCuGroups++;\n                        }\n                        // Mark event as active. This is used to avoid measuring the same event on the same device twice\n                        eventSet->nvEvents[m]->active = 1;\n                        GPUDEBUG_PRINT(DEBUGLEV_INFO, Setup event %s (%d) for GPU %d, eventSet->nvEvents[m]->name, device->activeEvents[m].cuEventId, device->deviceId);\n                        device->numActiveEvents++;\n                    }\n                }\n            }\n        }\n    }\n    free(grpEventIds);\n    if(popContext)\n    {\n        CU_CALL((*cuCtxPopCurrentPtr)(&device->context), return -EFAULT);\n    }\n    return 0;\n}\n\nint nvmon_cupti_startCounters(NvmonDevice_t device)\n{\n    int j = 0;\n    CUcontext curContext;\n    int popContext = 0;\n    uint32_t one = 1;\n    uint64_t timestamp = 0;\n    int oldDevId = -1;\n\n    // Currently we are on which device?\n    CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    // Take the timestamp, we assign it later for all devices\n    CUPTI_CALL((*cuptiGetTimestampPtr)(&timestamp), return -EFAULT);\n    // This is a workaround to (eventually create and) get the current context\n    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n\n\n    //NvmonDevice_t device = &nvGroupSet->gpus[i];\n    if (device->numActiveCuGroups == 0)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DETAIL, Skipping GPU%d it has no events in group %d, device->deviceId, nvGroupSet->activeGroup);\n        return 0;\n    }\n    if (device->deviceId != oldDevId)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Change GPU device %d -> %d, oldDevId, device->deviceId);\n        CUDA_CALL((*cudaSetDevicePtr)(device->deviceId), return -EFAULT);\n        CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    }\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n    device->timeStart = timestamp;\n    device->timeRead = timestamp;\n\n    // Are we in the proper context?\n    popContext = check_nv_context(device, curContext);\n\n    NvmonEventSet* nvEventSet = &device->nvEventSets[nvGroupSet->activeGroup];\n    for (j = 0; j < nvEventSet->numberOfEvents; j++)\n    {\n        NvmonEventResult* res = &nvEventSet->results[j];\n        res->startValue = 0.0;\n        res->stopValue = 0.0;\n        res->currentValue = 0.0;\n        res->fullValue = 0.0;\n        res->overflows = 0;\n    }\n\n    for (j = 0; j < device->numActiveCuGroups; j++)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Enable group %ld on Dev %d, device->activeCuGroups[j], device->deviceId);\n        CUPTI_CALL((*cuptiEventGroupSetEnablePtr)(device->activeCuGroups[j]), return -EFAULT);\n    }\n\n    // If we added the device context to the stack, pop it again\n    if (popContext)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Pop Context %ld for device %d, device->context, device->deviceId);\n        CU_CALL((*cuCtxPopCurrentPtr)(&device->context), return -EFAULT);\n    }\n}\n\n\nint nvmon_cupti_stopCounters(NvmonDevice_t device)\n{\n    int i = 0, j = 0, k = 0;\n    int oldDevId = -1;\n    uint64_t timestamp = 0;\n    CUcontext curContext;\n\n\n    CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    // Take the timestamp, we assign it later for all devices\n    CUPTI_CALL((*cuptiGetTimestampPtr)(&timestamp), return -EFAULT);\n\n\n    for (i = 0; i < nvGroupSet->numberOfGPUs; i++)\n    {\n        int popContext = 0;\n        uint32_t one = 1;\n        int maxTotalInstances = 0;\n        size_t valuesSize = 0;\n        NvmonDevice_t device = &nvGroupSet->gpus[i];\n        if (device->deviceId != oldDevId)\n        {\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Change GPU device %d -> %d, oldDevId, device->deviceId);\n            CUDA_CALL((*cudaSetDevicePtr)(device->deviceId), return -EFAULT);\n            CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n        }\n        CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n        NvmonEventSet* nvEventSet = &device->nvEventSets[nvGroupSet->activeGroup];\n        if (device->numActiveCuGroups == 0)\n        {\n            GPUDEBUG_PRINT(DEBUGLEV_DETAIL, Skipping GPU%d it has no events in group %d, device->deviceId, nvGroupSet->activeGroup);\n            continue;\n        }\n        device->timeStop = timestamp;\n\n        // Are we in the proper context?\n        popContext = check_nv_context(device, curContext);\n\n        for (j = 0; j < device->numActiveEvents; j++)\n        {\n            maxTotalInstances = MAX(maxTotalInstances, device->activeEvents[j].numTotalInstances);\n        }\n        uint64_t *tmpValues = (uint64_t *) malloc(maxTotalInstances * sizeof(uint64_t));\n\n        for (j = 0; j < device->numActiveEvents; j++)\n        {\n            NvmonActiveEvent_t event = &device->activeEvents[j];\n            valuesSize = sizeof(uint64_t) * event->numTotalInstances;\n            memset(tmpValues, 0, valuesSize);\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Read Grp %ld Ev %ld for device %d, event->cuGroup, event->cuEventId, device->deviceId);\n            CUPTI_CALL((*cuptiEventGroupReadEventPtr)(event->cuGroup, CUPTI_EVENT_READ_FLAG_NONE, event->cuEventId, &valuesSize, tmpValues), free(tmpValues); return -EFAULT);\n            uint64_t valuesum = 0;\n            for (k = 0; k < event->numInstances; k++)\n            {\n                valuesum += tmpValues[k];\n            }\n            NvmonEventResult* res = &nvEventSet->results[event->idxInSet];\n            res->stopValue = (double)valuesum;\n            res->lastValue = res->currentValue;\n            res->fullValue += res->stopValue - res->startValue;\n            res->lastValue += res->stopValue - res->currentValue;\n            res->currentValue = (double)valuesum;\n        }\n        for (j = 0; j < device->numActiveCuGroups; j++)\n        {\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Disable group %ld, device->activeCuGroups[j]);\n            CUPTI_CALL((*cuptiEventGroupSetDisablePtr)(device->activeCuGroups[j]), return -EFAULT);\n        }\n        // If we added the device context to the stack, pop it again\n        if (popContext)\n        {\n            GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Pop Context %ld for device %d, device->context, device->deviceId);\n            CU_CALL((*cuCtxPopCurrentPtr)(&device->context), return -EFAULT);\n        }\n    }\n}\n\n\nint nvmon_cupti_readCounters(NvmonDevice_t device)\n{\n    int j = 0, k = 0;\n    int oldDevId = -1;\n    uint64_t timestamp = 0;\n    CUcontext curContext;\n    size_t sizeofuint32num = sizeof(uint32_t);\n    int maxTotalInstances = 0;\n\n\n    for (j = 0; j < device->numActiveEvents; j++)\n    {\n        maxTotalInstances = MAX(maxTotalInstances, device->activeEvents[j].numTotalInstances);\n    }\n\n\n    // In this array we collect the instance values of an events (summed up later)\n    size_t valuesSize = sizeof(uint64_t) * maxTotalInstances;\n    uint64_t *tmpValues = (uint64_t *) malloc(valuesSize);\n    if (!tmpValues)\n    {\n        ERROR_PRINT(Not enough memory to allocate space for instance values);\n        return -ENOMEM;\n    }\n\n    // Currently we are on which device?\n    CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    // Take the timestamp, we assign it later for all devices\n    CUPTI_CALL((*cuptiGetTimestampPtr)(&timestamp), return -EFAULT);\n/*    // This is a workaround to (eventually create and) get the current context*/\n/*    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);*/\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n\n\n    int popContext = 0;\n    if (device->numActiveEvents == 0)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DETAIL, Skipping GPU%d it has no events in group %d, device->deviceId, nvGroupSet->activeGroup);\n        return 0;\n    }\n    if (device->deviceId != oldDevId)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Change GPU device %d -> %d, oldDevId, device->deviceId);\n        CUDA_CALL((*cudaSetDevicePtr)(device->deviceId), return -EFAULT);\n        CUDA_CALL((*cudaGetDevicePtr)(&oldDevId), return -EFAULT);\n    }\n    CUDA_CALL((*cudaFreePtr)(NULL), return -EFAULT);\n    CU_CALL((*cuCtxGetCurrentPtr)(&curContext), return -EFAULT);\n    device->timeRead = timestamp;\n\n    // Are we in the proper context?\n    popContext = check_nv_context(device, curContext);\n    // Synchronize devices. I'm not sure whether this is required as each\n    // device measures it's own events\n    CU_CALL((*cuCtxSynchronizePtr)(), return -EFAULT);\n    NvmonEventSet* nvEventSet = &device->nvEventSets[nvGroupSet->activeGroup];\n\n    for (j = 0; j < device->numActiveEvents; j++)\n    {\n        NvmonActiveEvent_t event = &device->activeEvents[j];\n        // Empty space for instance values\n        valuesSize = sizeof(uint64_t) * event->numTotalInstances;\n        memset(tmpValues, 0, valuesSize);\n        // Read all instance values\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Read Grp %ld Ev %ld for device %d, event->cuGroup, event->cuEventId, device->deviceId);\n        CUPTI_CALL((*cuptiEventGroupReadEventPtr)(event->cuGroup, CUPTI_EVENT_READ_FLAG_NONE, event->cuEventId, &valuesSize, tmpValues), return -EFAULT);\n        // Sum all instance values\n        uint64_t valuesum = 0;\n        for (k = 0; k < event->numInstances; k++)\n        {\n            valuesum += tmpValues[k];\n        }\n\n        NvmonEventResult* res = &nvEventSet->results[event->idxInSet];\n        res->lastValue = res->currentValue;\n        res->currentValue = (double)valuesum;\n        res->fullValue += res->currentValue - res->startValue;\n        res->lastValue += res->currentValue - res->lastValue;\n    }\n    if (popContext)\n    {\n        GPUDEBUG_PRINT(DEBUGLEV_DEVELOP, Pop Context %ld for device %d, device->context, device->deviceId);\n        CU_CALL((*cuCtxPopCurrentPtr)(&device->context), return -EFAULT);\n    }\n    free(tmpValues);\n    return 0;\n}\n\n\nNvmonFunctions nvmon_cupti_functions = {\n    .freeDevice = nvmon_cupti_freeDevice,\n    .createDevice = nvmon_cupti_createDevice,\n    .getEventList = nvmon_cupti_getEventsOfGpu,\n    .addEvents = nvmon_cupti_addEventSets,\n    .setupCounters = nvmon_cupti_setupCounters,\n    .startCounters = nvmon_cupti_startCounters,\n    .readCounters = nvmon_cupti_readCounters,\n};\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/src/includes/nvmon_perfworks.h": "/*\n * =======================================================================================\n *\n *      Filename:  nvmon_perfworks.h\n *\n *      Description:  Header File of nvmon module (PerfWorks backend).\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Author:   Thomas Gruber (tg), thomas.gruber@googlemail.com\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n#ifndef LIKWID_NVMON_PERFWORKS_H\n#define LIKWID_NVMON_PERFWORKS_H\n\n#if __CUDA_API_VERSION >= 10000\n\nstatic void *perfw_dl_libnvperf = NULL;\nstatic void *perfw_dl_libnvperf_t = NULL;\nstatic void *perfw_dl_libcupti = NULL;\nstatic void *perfw_dl_libcuda = NULL;\n#include <cupti_target.h>\n#include <cupti_profiler_target.h>\n#include <cuda_runtime_api.h>\n\n\n#include <nvperf_host.h>\n#include <nvperf_cuda_host.h>\n#include<nvperf_target.h>\n\n#define CUPTI_API_CALL(apiFuncCall)                                            \\\ndo {                                                                           \\\n    CUptiResult _status = apiFuncCall;                                         \\\n    if (_status != CUPTI_SUCCESS) {                                            \\\n        fprintf(stderr, \"%s:%d: error: function %s failed with error %d.\\n\",   \\\n                __FILE__, __LINE__, #apiFuncCall, _status);                    \\\n        exit(-1);                                                              \\\n    }                                                                          \\\n} while (0)\n\n\n\n#define NVPERFAPIWEAK __attribute__( ( weak ) )\n\n#define DECLARENVPERFFUNC(funcname, funcsig) NVPA_Status NVPERFAPIWEAK funcname funcsig;  NVPA_Status( *funcname##Ptr ) funcsig;\n//DECLARENVPERFFUNC(NVPW_MetricsContext_GetMetricNames_Begin, (NVPW_GetSupportedChipNames_Params *));\n\nDECLARENVPERFFUNC(NVPW_CUDA_MetricsContext_Create, (NVPW_CUDA_MetricsContext_Create_Params *));\nDECLARENVPERFFUNC(NVPW_MetricsContext_Destroy, (NVPW_MetricsContext_Destroy_Params*));\nDECLARENVPERFFUNC(NVPW_MetricsContext_GetMetricNames_Begin, (NVPW_MetricsContext_GetMetricNames_Begin_Params*));\nDECLARENVPERFFUNC(NVPW_MetricsContext_GetMetricNames_End, (NVPW_MetricsContext_GetMetricNames_End_Params*));\nDECLARENVPERFFUNC(NVPW_GetSupportedChipNames, (NVPW_GetSupportedChipNames_Params*));\nDECLARENVPERFFUNC(NVPW_Device_GetNames, (NVPW_Device_GetNames_Params*))\n\n#ifndef DECLARECUPTIFUNC\n#define CUPTIAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUPTIFUNC(funcname, funcsig) CUptiResult CUPTIAPIWEAK funcname funcsig;  CUptiResult( *funcname##Ptr ) funcsig;\n#endif\n\nDECLARECUPTIFUNC(cuptiDeviceGetChipName, (CUpti_Device_GetChipName_Params*));\n\n#ifndef DECLARECUFUNC\n#define CUAPIWEAK __attribute__( ( weak ) )\n#define DECLARECUFUNC(funcname, funcsig) CUresult CUAPIWEAK funcname funcsig;  CUresult( *funcname##Ptr ) funcsig;\n#endif\n\nDECLARECUFUNC(cuInit, (unsigned int));\n\n#ifndef DLSYM_AND_CHECK\n#define DLSYM_AND_CHECK( dllib, name ) dlsym( dllib, name ); if ( dlerror() != NULL ) { return -1; }\n#endif\n\nstatic int\nlink_perfworks_libraries(void)\n{\n    if(_dl_non_dynamic_init != NULL) {\n        return -1;\n    }\n    perfw_dl_libcuda = dlopen(\"libcuda.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!perfw_dl_libcuda)\n    {\n        fprintf(stderr, \"CUDA library libcuda.so not found.\\n\");\n        return -1;\n    }\n    perfw_dl_libnvperf = dlopen(\"libnvperf_host.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!perfw_dl_libnvperf)\n    {\n        fprintf(stderr, \"CUDA library libnvperf_host.so not found.\\n\");\n        return -1;\n    }\n    perfw_dl_libnvperf_t = dlopen(\"libnvperf_target.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!perfw_dl_libnvperf_t)\n    {\n        fprintf(stderr, \"CUDA library libnvperf_target.so not found.\\n\");\n        return -1;\n    }\n    perfw_dl_libcupti = dlopen(\"libcupti.so\", RTLD_NOW | RTLD_GLOBAL);\n    if (!perfw_dl_libcupti)\n    {\n        fprintf(stderr, \"CUDA runtime library libcupti.so not found.\\n\");\n        return -1;\n    }\n    cuInitPtr = DLSYM_AND_CHECK(perfw_dl_libcuda, \"cuInit\");\n    cuptiDeviceGetChipNamePtr = DLSYM_AND_CHECK(perfw_dl_libcupti, \"cuptiDeviceGetChipName\");\n    NVPW_CUDA_MetricsContext_CreatePtr = DLSYM_AND_CHECK(perfw_dl_libnvperf, \"NVPW_CUDA_MetricsContext_Create\");\n    //NVPW_GetSupportedChipNamesPtr = DLSYM_AND_CHECK(perfw_dl_libnvperf, \"NVPW_GetSupportedChipNames\");\n    NVPW_Device_GetNamesPtr = DLSYM_AND_CHECK(perfw_dl_libnvperf_t, \"NVPW_Device_GetNames\");\n\n\n    CUresult cuErr = (*cuInitPtr)(0);\n    if (cuErr != CUDA_SUCCESS)\n    {\n        fprintf(stderr, \"CUDA cannot be found and initialized (cuInit failed).\\n\");\n        return -ENODEV;\n    }\n    return 0;\n}\n\nstatic void\nrelease_perfworks_libraries(void)\n{\n    if (perfw_dl_libnvperf)\n    {\n        dlclose(perfw_dl_libnvperf);\n        perfw_dl_libnvperf = NULL;\n    }\n    if (perfw_dl_libcupti)\n    {\n        dlclose(perfw_dl_libcupti);\n        perfw_dl_libcupti = NULL;\n    }\n}\n\nint nvmon_perfworks_getEventsOfGpu(int gpuId, NvmonEventList_t* list)\n{\n    NVPA_Status err = 0;\n    int ret = topology_gpu_init();\n    if (ret != EXIT_SUCCESS)\n    {\n        return -ENODEV;\n    }\n    GpuTopology_t gtopo = get_gpuTopology();\n    ret = link_perfworks_libraries();\n    if (ret < 0)\n    {\n        return ret;\n    }\n\n\n    NVPW_Device_GetNames_Params getNamesParams = {NVPW_Device_GetNames_Params_STRUCT_SIZE};\n    err = (*NVPW_Device_GetNamesPtr)(&getNamesParams);\n    if (err != NVPA_STATUS_SUCCESS)\n    {\n        fprintf(stderr, \"Cannot get name of GPU chip %d\\n\", err);\n        return -ENODEV;\n    }\n    printf(\"GPU name %s\\n\", getNamesParams.pChipName);\n    printf(\"GPU name %s\\n\", getNamesParams.pDeviceName);\n\n/*    */\n/*    CUpti_Device_GetChipName_Params getChipNameParams = { CUpti_Device_GetChipName_Params_STRUCT_SIZE };*/\n/*    getChipNameParams.pPriv = NULL;*/\n/*    getChipNameParams.deviceIndex = 0;*/\n/*    */\n/*    */\n/*    */\n/*    NVPW_CUDA_MetricsContext_Create_Params metricsContextCreateParams = { NVPW_CUDA_MetricsContext_Create_Params_STRUCT_SIZE };*/\n/*    metricsContextCreateParams.pChipName = getChipNameParams.pChipName;*/\n/*    err = (*NVPW_CUDA_MetricsContext_CreatePtr)(&metricsContextCreateParams);*/\n/*    printf(\"Here\\n\");*/\n/*    if (err != NVPA_STATUS_SUCCESS)*/\n/*    {*/\n/*        printf(\"Failed to get event list of device %d\\n\", gpuId);*/\n/*        return -ENODEV;*/\n/*    }*/\n/*    NVPW_MetricsContext_Destroy_Params metricsContextDestroyParams = { NVPW_MetricsContext_Destroy_Params_STRUCT_SIZE };*/\n/*    metricsContextDestroyParams.pMetricsContext = metricsContextCreateParams.pMetricsContext;*/\n/*    err = myNVPW_MetricsContext_Destroy((NVPW_MetricsContext_Destroy_Params *)&metricsContextDestroyParams);*/\n/*    */\n/*    NVPW_MetricsContext_GetMetricNames_Begin_Params getMetricNameBeginParams = { NVPW_MetricsContext_GetMetricNames_Begin_Params_STRUCT_SIZE };*/\n/*    getMetricNameBeginParams.pMetricsContext = metricsContextCreateParams.pMetricsContext;*/\n/*    getMetricNameBeginParams.hidePeakSubMetrics = 0;*/\n/*    getMetricNameBeginParams.hidePerCycleSubMetrics = 0;*/\n/*    getMetricNameBeginParams.hidePctOfPeakSubMetrics = 0;*/\n/*    err = myNVPW_MetricsContext_GetMetricNames_Begin(&getMetricNameBeginParams);*/\n/*    if (err != NVPA_STATUS_SUCCESS)*/\n/*    {*/\n/*        printf(\"Failed to get event list of device %d\\n\", gpuId);*/\n/*        return -ENODEV;*/\n/*    }*/\n/*    NVPW_MetricsContext_GetMetricNames_End_Params getMetricNameEndParams = { NVPW_MetricsContext_GetMetricNames_End_Params_STRUCT_SIZE };*/\n/*    getMetricNameEndParams.pMetricsContext = metricsContextCreateParams.pMetricsContext;*/\n/*    err = myNVPW_MetricsContext_GetMetricNames_End((NVPW_MetricsContext_GetMetricNames_End_Params *)&getMetricNameEndParams);*/\n/*    */\n/*    */\n/*    NvmonEventList_t l = malloc(sizeof(NvmonEventList));*/\n/*    if (l)*/\n/*    {*/\n/*        */\n/*        l->events = malloc(l->numEvents*sizeof(NvmonEventListEntry));*/\n/*        if (l->events)*/\n/*        {*/\n/*            for (int i = 0; i < getMetricNameBeginParams.numMetrics; i++)*/\n/*            {*/\n/*                NvmonEventListEntry* out = &l->events[i];*/\n/*                const char* mname = getMetricNameBeginParams.ppMetricNames[i];*/\n/*                out->name = malloc(strlen(mname)+2);*/\n/*                if (out->name)*/\n/*                {*/\n/*                    ret = snprintf(out->name, strlen(mname)+1, \"%s\", mname);*/\n/*                    if (ret > 0)*/\n/*                    {*/\n/*                        out->name[ret] = '\\0';*/\n/*                    }*/\n/*                }*/\n/*                out->limit = malloc(10*sizeof(char));*/\n/*                if (out->limit)*/\n/*                {*/\n/*                    ret = snprintf(out->limit, 9, \"GPU\");*/\n/*                    if (ret > 0) out->limit[ret] = '\\0';*/\n/*                }*/\n/*            }*/\n/*            l->numEvents = getMetricNameBeginParams.numMetrics;*/\n/*            *list = l;*/\n/*            return 0;*/\n/*        }*/\n/*        free(l);*/\n/*    }*/\n/*    return -ENOMEM;*/\n    return 0;\n}\n\n\n\nNvmonFunctions nvmon_perfworks_functions = {\n    .freeDevice = NULL,\n    .createDevice = NULL,\n    .getEventList = nvmon_perfworks_getEventsOfGpu,\n    .addEvents = NULL,\n    .setupCounters = NULL,\n    .startCounters = NULL,\n    .readCounters = NULL,\n};\n#else\nNvmonFunctions nvmon_perfworks_functions = {\n    .freeDevice = NULL,\n    .createDevice = NULL,\n    .getEventList = NULL,\n    .addEvents = NULL,\n    .setupCounters = NULL,\n    .startCounters = NULL,\n    .readCounters = NULL,\n};\n\n#endif\n\n#endif /* LIKWID_NVMON_PERFWORKS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/src/pthread-overload/pthread-overload.c": "/*\n * =======================================================================================\n *\n *      Filename:  pthread-overload.c\n *\n *      Description:  Overloaded library for pthread_create call. \n *                    Implements pinning of threads together with likwid-pin.\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Author:  Jan Treibig (jt), jan.treibig@gmail.com\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <dlfcn.h>\n#include <sched.h>\n#include <bits/pthreadtypes.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n\n#ifdef COLOR\n#include <textcolor.h>\n#endif\n\n#define STRINGIFY(x) #x\n#define TOSTRING(x) STRINGIFY(x)\n#define LLU_CAST  (unsigned long long)\n\n#define gettid() syscall(SYS_gettid)\n\nextern int pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *cpuset);\n\nstatic char * sosearchpaths[] = {\n#ifdef LIBPTHREAD\n    TOSTRING(LIBPTHREAD),\n#endif\n    \"/lib64/tls/libpthread.so.0\",/* sles9 x86_64 */\n    \"libpthread.so.0\",           /* Ubuntu */\n    NULL\n};\n\n\n#ifdef COLOR\n#define color_print(format,...) do { \\\n        color_on(BRIGHT, COLOR); \\\n        printf(format, ##__VA_ARGS__); \\\n        color_reset(); \\\n    } while(0)\n#else\n#define color_print(format,...) do { \\\n        printf(format, ##__VA_ARGS__); \\\n    } while(0)\n#endif\n\nstatic int *pin_ids = NULL;\nstatic int ncpus = 0;\nstatic uint64_t skipMask = 0x0;\nstatic int silent = 0;\nvoid __attribute__((constructor (103))) init_pthread_overload(void)\n{\n    char *str = NULL;\n    char *token = NULL, *saveptr = NULL;\n    char *delimiter = \",\";\n    int i = 0;\n    static long avail_cpus = 0;\n    avail_cpus = sysconf(_SC_NPROCESSORS_CONF);\n    pin_ids = malloc(avail_cpus * sizeof(int));\n    memset(pin_ids, 0, avail_cpus * sizeof(int));\n    str = getenv(\"LIKWID_PIN\");\n    if (str != NULL)\n    {\n        token = str;\n        while (token)\n        {\n            token = strtok_r(str,delimiter,&saveptr);\n            str = NULL;\n            if (token)\n            {\n                ncpus++;\n                pin_ids[i++] = strtoul(token, &token, 10);\n            }\n        }\n    }\n    str = getenv(\"LIKWID_SKIP\");\n    if (str != NULL)\n    {\n        skipMask = strtoul(str, &str, 16);\n    }\n\n    if (getenv(\"LIKWID_SILENT\") != NULL)\n    {\n        silent = 1;\n    }\n}\n\nint __attribute__ ((visibility (\"default\") ))\npthread_create(pthread_t* thread,\n        const pthread_attr_t* attr,\n        void* (*start_routine)(void *),\n        void * arg)\n{\n    void *handle;\n    char *error;\n    int (*rptc) (pthread_t *, const pthread_attr_t *, void* (*start_routine)(void *), void *);\n    int ret;\n    static int reallpthrindex = 0;\n    static int npinned = 0;\n    static int ncalled = 0;\n    static int overflow = 0;\n    static int overflowed = 0;\n    static long online_cpus = 0;\n    static int shepard = 0;\n    online_cpus = sysconf(_SC_NPROCESSORS_ONLN);\n\n    /* On first entry: Get Evironment Variable and initialize pin_ids */\n    if (ncalled == 0 && pin_ids != NULL)\n    {\n        char* str = NULL;\n        cpu_set_t cpuset;\n\n        if (!silent)\n        {\n            color_print(\"[pthread wrapper] \\n\");\n        }\n\n        str = getenv(\"LIKWID_PIN\");\n        if (str != NULL)\n        {\n            CPU_ZERO(&cpuset);\n            CPU_SET(pin_ids[ncpus-1], &cpuset);\n            ret = sched_setaffinity(getpid(), sizeof(cpu_set_t), &cpuset);\n            if (!silent)\n            {\n                color_print(\"[pthread wrapper] MAIN -> %d\\n\",pin_ids[ncpus-1]);\n            }\n            //ncpus--; /* last ID is the first (the process was pinned to) */\n        }\n        else\n        {\n            color_print(\"[pthread wrapper] ERROR: Environment Variabel LIKWID_PIN not set!\\n\");\n        }\n\n        if (!silent)\n        {\n            color_print(\"[pthread wrapper] PIN_MASK: \");\n\n            for (int i=0;i<ncpus-1;i++)\n            {\n                color_print(\"%d->%d  \",i,pin_ids[i]);\n            }\n            color_print(\"\\n[pthread wrapper] SKIP MASK: 0x%llX\\n\",LLU_CAST skipMask);\n        }\n\n        overflow = ncpus-1;\n    }\n    Dl_info info;\n    if (dladdr(start_routine, &info) > 0)\n    {\n        FILE* fpipe;\n        char cmd[512];\n        char buff[512];\n        char file[256];\n        unsigned int ptr = ((void*)start_routine) - info.dli_fbase;\n\n        buff[0] = '\\0';\n        snprintf(file, 255, \"/tmp/likwidpin.%d\", gettid());\n        snprintf(cmd, 511, \"rm -f %s; nm %s 2>/dev/null | grep %x > %s\",\n                 file, info.dli_fname, ptr, file);\n        ret = system(cmd);\n        if (!access(file, R_OK))\n        {\n            fpipe = fopen(file, \"r\");\n            if (!fpipe)\n            {\n                fprintf(stderr, \"Problems reading symbols for shepard thread detection\\n\");\n            }\n            else\n            {\n                char* t = fgets(buff, 512, fpipe);\n                char* tmp = strstr(buff, \"monitor\");\n                if (tmp != NULL)\n                {\n                    shepard = 1;\n                    skipMask |= 1ULL<<(ncalled);\n                }\n                fclose(fpipe);\n                snprintf(cmd, 511, \"rm -f %s 2>/dev/null\", file);\n                ret = system(cmd);\n            }\n        }\n        else\n        {\n            fprintf(stderr, \"Problems reading symbols for shepard thread detection\\n\");\n        }\n    }\n\n    /* Handle dll related stuff */\n    do\n    {\n        handle = dlopen(sosearchpaths[reallpthrindex], RTLD_LAZY);\n        if (handle)\n        {\n            break;\n        }\n        if (sosearchpaths[reallpthrindex] != NULL)\n        {\n            reallpthrindex++;\n        }\n    }\n\n    while (sosearchpaths[reallpthrindex] != NULL);\n\n    if (!handle)\n    {\n        color_print(\"%s\\n\", dlerror());\n        return -1;\n    }\n\n    dlerror();    /* Clear any existing error */\n    rptc = dlsym(handle, \"pthread_create\");\n\n    if ((error = dlerror()) != NULL)\n    {\n        color_print(\"%s\\n\", error);\n        return -2;\n    }\n\n    ret = (*rptc)(thread, attr, start_routine, arg);\n\n    /* After thread creation pin the thread */\n    if (ret == 0)\n    {\n        cpu_set_t cpuset;\n\n        if ((ncalled<64) && (skipMask&(1ULL<<(ncalled))))\n        {\n            CPU_ZERO(&cpuset);\n            for (int i=0; i<online_cpus; i++)\n                CPU_SET(i, &cpuset);\n            pthread_setaffinity_np(*thread, sizeof(cpu_set_t), &cpuset);\n            if (!silent)\n            {\n                if (shepard)\n                    color_print(\"\\tthreadid %lu -> SKIP SHEPHERD\\n\", *thread);\n                else\n                    color_print(\"\\tthreadid %lu -> SKIP \\n\", *thread);\n                shepard = 0;\n            }\n        }\n        else\n        {\n            CPU_ZERO(&cpuset);\n            CPU_SET(pin_ids[npinned%ncpus], &cpuset);\n            pthread_setaffinity_np(*thread, sizeof(cpu_set_t), &cpuset);\n            if ((npinned == overflow) && (!overflowed))\n            {\n                if (!silent)\n                {\n                    color_print(\"Roundrobin placement triggered\\n\\tthreadid %lu -> core %d - OK\", *thread, pin_ids[npinned%ncpus]);\n                }\n                overflowed = 1;\n                npinned = (npinned+1)%ncpus;\n            }\n            else\n            {\n                if (!silent)\n                {\n                    color_print(\"\\tthreadid %lu -> core %d - OK\", *thread, pin_ids[npinned%ncpus]);\n                }\n                npinned++;\n                if ((npinned >= ncpus) && (overflowed))\n                {\n                    npinned = 0;\n                }\n            }\n\n            if (!silent)\n            {\n                color_print(\"\\n\");\n            }\n        }\n    }\n\n    fflush(stdout);\n    ncalled++;\n    dlclose(handle);\n\n    return ret;\n}\n\nvoid __attribute__((destructor (103))) close_pthread_overload(void)\n{\n    free(pin_ids);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/ext/GOTCHA/src/gotcha_dl.h": "#ifndef GOTCHA_DL_H\n#define GOTCHA_DL_H\n\n#include \"hash.h\"\n#include \"tool.h\"\n\nvoid handle_libdl();\nextern void update_all_library_gots(hash_table_t *bindings);\nextern int prepare_symbol(struct internal_binding_t *binding);\n\nextern gotcha_wrappee_handle_t orig_dlopen_handle;\nextern gotcha_wrappee_handle_t orig_dlsym_handle;\n\nextern struct gotcha_binding_t dl_binds[];\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/ext/GOTCHA/src/gotcha_dl.c": "#define _GNU_SOURCE\n#include \"gotcha_dl.h\"\n#include \"tool.h\"\n#include \"libc_wrappers.h\"\n#include \"elf_ops.h\"\n#include <dlfcn.h>\n\nvoid* _dl_sym(void* handle, const char* name, void* where);\n\ngotcha_wrappee_handle_t orig_dlopen_handle;\ngotcha_wrappee_handle_t orig_dlsym_handle;\n\nstatic int per_binding(hash_key_t key, hash_data_t data, void *opaque KNOWN_UNUSED)\n{\n   int result;\n   struct internal_binding_t *binding = (struct internal_binding_t *) data;\n\n   debug_printf(3, \"Trying to re-bind %s from tool %s after dlopen\\n\",\n                binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   \n   while (binding->next_binding) {\n      binding = binding->next_binding;\n      debug_printf(3, \"Selecting new innermost version of binding %s from tool %s.\\n\",\n                   binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   }\n   \n   result = prepare_symbol(binding);\n   if (result == -1) {\n      debug_printf(3, \"Still could not prepare binding %s after dlopen\\n\", binding->user_binding->name);\n      return 0;\n   }\n\n   removefrom_hashtable(&notfound_binding_table, key);\n   return 0;\n}\n\nstatic void* dlopen_wrapper(const char* filename, int flags) {\n   typeof(&dlopen_wrapper) orig_dlopen = gotcha_get_wrappee(orig_dlopen_handle);\n   void *handle;\n   debug_printf(1, \"User called dlopen(%s, 0x%x)\\n\", filename, (unsigned int) flags);\n   handle = orig_dlopen(filename,flags);\n\n   debug_printf(2, \"Searching new dlopened libraries for previously-not-found exports\\n\");\n   foreach_hash_entry(&notfound_binding_table, NULL, per_binding);\n\n   debug_printf(2, \"Updating GOT entries for new dlopened libraries\\n\");\n   update_all_library_gots(&function_hash_table);\n  \n   return handle;\n}\n\nstatic void* dlsym_wrapper(void* handle, const char* symbol_name){\n  typeof(&dlsym_wrapper) orig_dlsym = gotcha_get_wrappee(orig_dlsym_handle);\n  struct internal_binding_t *binding;\n  int result;\n  \n  if(handle == RTLD_NEXT){\n    return _dl_sym(RTLD_NEXT, symbol_name ,__builtin_return_address(0));\n  }\n  \n  result = lookup_hashtable(&function_hash_table, (hash_key_t) symbol_name, (hash_data_t *) &binding);\n  if (result == -1)\n     return orig_dlsym(handle, symbol_name);\n  else\n     return binding->user_binding->wrapper_pointer;\n}\n\nstruct gotcha_binding_t dl_binds[] = {\n  {\"dlopen\", dlopen_wrapper, &orig_dlopen_handle},\n  {\"dlsym\", dlsym_wrapper, &orig_dlsym_handle}\n};     \nvoid handle_libdl(){\n  gotcha_wrap(dl_binds, 2, \"gotcha\");\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/ext/hwloc/include/hwloc/plugins.h": "/*\n * Copyright \u00a9 2013-2019 Inria.  All rights reserved.\n * Copyright \u00a9 2016 Cisco Systems, Inc.  All rights reserved.\n * See COPYING in top-level directory.\n */\n\n#ifndef HWLOC_PLUGINS_H\n#define HWLOC_PLUGINS_H\n\n/** \\file\n * \\brief Public interface for building hwloc plugins.\n */\n\nstruct hwloc_backend;\n\n#include \"hwloc.h\"\n\n#ifdef HWLOC_INSIDE_PLUGIN\n/* needed for hwloc_plugin_check_namespace() */\n#include <ltdl.h>\n#endif\n\n\n\n/** \\defgroup hwlocality_disc_components Components and Plugins: Discovery components\n * @{\n */\n\n/** \\brief Discovery component structure\n *\n * This is the major kind of components, taking care of the discovery.\n * They are registered by generic components, either statically-built or as plugins.\n */\nstruct hwloc_disc_component {\n  /** \\brief Name.\n   * If this component is built as a plugin, this name does not have to match the plugin filename.\n   */\n  const char *name;\n\n  /** \\brief Discovery phases performed by this component.\n   * OR'ed set of ::hwloc_disc_phase_t\n   */\n  unsigned phases;\n\n  /** \\brief Component phases to exclude, as an OR'ed set of ::hwloc_disc_phase_t.\n   *\n   * For a GLOBAL component, this usually includes all other phases (\\c ~UL).\n   *\n   * Other components only exclude types that may bring conflicting\n   * topology information. MISC components should likely not be excluded\n   * since they usually bring non-primary additional information.\n   */\n  unsigned excluded_phases;\n\n  /** \\brief Instantiate callback to create a backend from the component.\n   * Parameters data1, data2, data3 are NULL except for components\n   * that have special enabling routines such as hwloc_topology_set_xml(). */\n  struct hwloc_backend * (*instantiate)(struct hwloc_topology *topology, struct hwloc_disc_component *component, unsigned excluded_phases, const void *data1, const void *data2, const void *data3);\n\n  /** \\brief Component priority.\n   * Used to sort topology->components, higher priority first.\n   * Also used to decide between two components with the same name.\n   *\n   * Usual values are\n   * 50 for native OS (or platform) components,\n   * 45 for x86,\n   * 40 for no-OS fallback,\n   * 30 for global components (xml, synthetic),\n   * 20 for pci,\n   * 10 for other misc components (opencl etc.).\n   */\n  unsigned priority;\n\n  /** \\brief Enabled by default.\n   * If unset, if will be disabled unless explicitly requested.\n   */\n  unsigned enabled_by_default;\n\n  /** \\private Used internally to list components by priority on topology->components\n   * (the component structure is usually read-only,\n   *  the core copies it before using this field for queueing)\n   */\n  struct hwloc_disc_component * next;\n};\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_disc_backends Components and Plugins: Discovery backends\n * @{\n */\n\n/** \\brief Discovery phase */\ntypedef enum hwloc_disc_phase_e {\n  /** \\brief xml or synthetic, platform-specific components such as bgq.\n   * Discovers everything including CPU, memory, I/O and everything else.\n   * A component with a Global phase usually excludes all other phases.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_GLOBAL = (1U<<0),\n\n  /** \\brief CPU discovery.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_CPU = (1U<<1),\n\n  /** \\brief Attach memory to existing CPU objects.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_MEMORY = (1U<<2),\n\n  /** \\brief Attach PCI devices and bridges to existing CPU objects.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_PCI = (1U<<3),\n\n  /** \\brief I/O discovery that requires PCI devices (OS devices such as OpenCL, CUDA, etc.).\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_IO = (1U<<4),\n\n  /** \\brief Misc objects that gets added below anything else.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_MISC = (1U<<5),\n\n  /** \\brief Annotating existing objects, adding distances, etc.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_ANNOTATE = (1U<<6),\n\n  /** \\brief Final tweaks to a ready-to-use topology.\n   * This phase runs once the topology is loaded, before it is returned to the topology.\n   * Hence it may only use the main hwloc API for modifying the topology,\n   * for instance by restricting it, adding info attributes, etc.\n   * \\hideinitializer */\n  HWLOC_DISC_PHASE_TWEAK = (1U<<7)\n} hwloc_disc_phase_t;\n\n/** \\brief Discovery status flags */\nenum hwloc_disc_status_flag_e {\n  /** \\brief The sets of allowed resources were already retrieved \\hideinitializer */\n  HWLOC_DISC_STATUS_FLAG_GOT_ALLOWED_RESOURCES = (1UL<<1)\n};\n\n/** \\brief Discovery status structure\n *\n * Used by the core and backends to inform about what has been/is being done\n * during the discovery process.\n */\nstruct hwloc_disc_status {\n  /** \\brief The current discovery phase that is performed.\n   * Must match one of the phases in the component phases field.\n   */\n  hwloc_disc_phase_t phase;\n\n  /** \\brief Dynamically excluded phases.\n   * If a component decides during discovery that some phases are no longer needed.\n   */\n  unsigned excluded_phases;\n\n  /** \\brief OR'ed set of hwloc_disc_status_flag_e */\n  unsigned long flags;\n};\n\n/** \\brief Discovery backend structure\n *\n * A backend is the instantiation of a discovery component.\n * When a component gets enabled for a topology,\n * its instantiate() callback creates a backend.\n *\n * hwloc_backend_alloc() initializes all fields to default values\n * that the component may change (except \"component\" and \"next\")\n * before enabling the backend with hwloc_backend_enable().\n *\n * Most backends assume that the topology is_thissystem flag is\n * set because they talk to the underlying operating system.\n * However they may still be used in topologies without the\n * is_thissystem flag for debugging reasons.\n * In practice, they are usually auto-disabled in such cases\n * (excluded by xml or synthetic backends, or by environment\n *  variables when changing the Linux fsroot or the x86 cpuid path).\n */\nstruct hwloc_backend {\n  /** \\private Reserved for the core, set by hwloc_backend_alloc() */\n  struct hwloc_disc_component * component;\n  /** \\private Reserved for the core, set by hwloc_backend_enable() */\n  struct hwloc_topology * topology;\n  /** \\private Reserved for the core. Set to 1 if forced through envvar, 0 otherwise. */\n  int envvar_forced;\n  /** \\private Reserved for the core. Used internally to list backends topology->backends. */\n  struct hwloc_backend * next;\n\n  /** \\brief Discovery phases performed by this component, possibly without some of them if excluded by other components.\n   * OR'ed set of ::hwloc_disc_phase_t\n   */\n  unsigned phases;\n\n  /** \\brief Backend flags, currently always 0. */\n  unsigned long flags;\n\n  /** \\brief Backend-specific 'is_thissystem' property.\n   * Set to 0 if the backend disables the thissystem flag for this topology\n   * (e.g. loading from xml or synthetic string,\n   *  or using a different fsroot on Linux, or a x86 CPUID dump).\n   * Set to -1 if the backend doesn't care (default).\n   */\n  int is_thissystem;\n\n  /** \\brief Backend private data, or NULL if none. */\n  void * private_data;\n  /** \\brief Callback for freeing the private_data.\n   * May be NULL.\n   */\n  void (*disable)(struct hwloc_backend *backend);\n\n  /** \\brief Main discovery callback.\n   * returns -1 on error, either because it couldn't add its objects ot the existing topology,\n   * or because of an actual discovery/gathering failure.\n   * May be NULL.\n   */\n  int (*discover)(struct hwloc_backend *backend, struct hwloc_disc_status *status);\n\n  /** \\brief Callback to retrieve the locality of a PCI object.\n   * Called by the PCI core when attaching PCI hierarchy to CPU objects.\n   * May be NULL.\n   */\n  int (*get_pci_busid_cpuset)(struct hwloc_backend *backend, struct hwloc_pcidev_attr_s *busid, hwloc_bitmap_t cpuset);\n};\n\n/** \\brief Allocate a backend structure, set good default values, initialize backend->component and topology, etc.\n * The caller will then modify whatever needed, and call hwloc_backend_enable().\n */\nHWLOC_DECLSPEC struct hwloc_backend * hwloc_backend_alloc(struct hwloc_topology *topology, struct hwloc_disc_component *component);\n\n/** \\brief Enable a previously allocated and setup backend. */\nHWLOC_DECLSPEC int hwloc_backend_enable(struct hwloc_backend *backend);\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_generic_components Components and Plugins: Generic components\n * @{\n */\n\n/** \\brief Generic component type */\ntypedef enum hwloc_component_type_e {\n  /** \\brief The data field must point to a struct hwloc_disc_component. */\n  HWLOC_COMPONENT_TYPE_DISC,\n\n  /** \\brief The data field must point to a struct hwloc_xml_component. */\n  HWLOC_COMPONENT_TYPE_XML\n} hwloc_component_type_t;\n\n/** \\brief Generic component structure\n *\n * Generic components structure, either statically listed by configure in static-components.h\n * or dynamically loaded as a plugin.\n */\nstruct hwloc_component {\n  /** \\brief Component ABI version, set to ::HWLOC_COMPONENT_ABI */\n  unsigned abi;\n\n  /** \\brief Process-wide component initialization callback.\n   *\n   * This optional callback is called when the component is registered\n   * to the hwloc core (after loading the plugin).\n   *\n   * When the component is built as a plugin, this callback\n   * should call hwloc_check_plugin_namespace()\n   * and return an negative error code on error.\n   *\n   * \\p flags is always 0 for now.\n   *\n   * \\return 0 on success, or a negative code on error.\n   *\n   * \\note If the component uses ltdl for loading its own plugins,\n   * it should load/unload them only in init() and finalize(),\n   * to avoid race conditions with hwloc's use of ltdl.\n   */\n  int (*init)(unsigned long flags);\n\n  /** \\brief Process-wide component termination callback.\n   *\n   * This optional callback is called after unregistering the component\n   * from the hwloc core (before unloading the plugin).\n   *\n   * \\p flags is always 0 for now.\n   *\n   * \\note If the component uses ltdl for loading its own plugins,\n   * it should load/unload them only in init() and finalize(),\n   * to avoid race conditions with hwloc's use of ltdl.\n   */\n  void (*finalize)(unsigned long flags);\n\n  /** \\brief Component type */\n  hwloc_component_type_t type;\n\n  /** \\brief Component flags, unused for now */\n  unsigned long flags;\n\n  /** \\brief Component data, pointing to a struct hwloc_disc_component or struct hwloc_xml_component. */\n  void * data;\n};\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_core_funcs Components and Plugins: Core functions to be used by components\n * @{\n */\n\n/** \\brief Add an object to the topology.\n *\n * It is sorted along the tree of other objects according to the inclusion of\n * cpusets, to eventually be added as a child of the smallest object including\n * this object.\n *\n * If the cpuset is empty, the type of the object (and maybe some attributes)\n * must be enough to find where to insert the object. This is especially true\n * for NUMA nodes with memory and no CPUs.\n *\n * The given object should not have children.\n *\n * This shall only be called before levels are built.\n *\n * In case of error, hwloc_report_os_error() is called.\n *\n * The caller should check whether the object type is filtered-out before calling this function.\n *\n * The topology cpuset/nodesets will be enlarged to include the object sets.\n *\n * Returns the object on success.\n * Returns NULL and frees obj on error.\n * Returns another object and frees obj if it was merged with an identical pre-existing object.\n */\nHWLOC_DECLSPEC struct hwloc_obj *hwloc_insert_object_by_cpuset(struct hwloc_topology *topology, hwloc_obj_t obj);\n\n/** \\brief Type of error callbacks during object insertion */\ntypedef void (*hwloc_report_error_t)(const char * msg, int line);\n/** \\brief Report an insertion error from a backend */\nHWLOC_DECLSPEC void hwloc_report_os_error(const char * msg, int line);\n/** \\brief Check whether insertion errors are hidden */\nHWLOC_DECLSPEC int hwloc_hide_errors(void);\n\n/** \\brief Add an object to the topology and specify which error callback to use.\n *\n * This function is similar to hwloc_insert_object_by_cpuset() but it allows specifying\n * where to start insertion from (if \\p root is NULL, the topology root object is used),\n * and specifying the error callback.\n */\nHWLOC_DECLSPEC struct hwloc_obj *hwloc__insert_object_by_cpuset(struct hwloc_topology *topology, hwloc_obj_t root, hwloc_obj_t obj, hwloc_report_error_t report_error);\n\n/** \\brief Insert an object somewhere in the topology.\n *\n * It is added as the last child of the given parent.\n * The cpuset is completely ignored, so strange objects such as I/O devices should\n * preferably be inserted with this.\n *\n * When used for \"normal\" children with cpusets (when importing from XML\n * when duplicating a topology), the caller should make sure that:\n * - children are inserted in order,\n * - children cpusets do not intersect.\n *\n * The given object may have normal, I/O or Misc children, as long as they are in order as well.\n * These children must have valid parent and next_sibling pointers.\n *\n * The caller should check whether the object type is filtered-out before calling this function.\n */\nHWLOC_DECLSPEC void hwloc_insert_object_by_parent(struct hwloc_topology *topology, hwloc_obj_t parent, hwloc_obj_t obj);\n\n/** \\brief Allocate and initialize an object of the given type and physical index.\n *\n * If \\p os_index is unknown or irrelevant, use \\c HWLOC_UNKNOWN_INDEX.\n */\nHWLOC_DECLSPEC hwloc_obj_t hwloc_alloc_setup_object(hwloc_topology_t topology, hwloc_obj_type_t type, unsigned os_index);\n\n/** \\brief Setup object cpusets/nodesets by OR'ing its children.\n *\n * Used when adding an object late in the topology.\n * Will update the new object by OR'ing all its new children sets.\n *\n * Used when PCI backend adds a hostbridge parent, when distances\n * add a new Group, etc.\n */\nHWLOC_DECLSPEC int hwloc_obj_add_children_sets(hwloc_obj_t obj);\n\n/** \\brief Request a reconnection of children and levels in the topology.\n *\n * May be used by backends during discovery if they need arrays or lists\n * of object within levels or children to be fully connected.\n *\n * \\p flags is currently unused, must 0.\n */\nHWLOC_DECLSPEC int hwloc_topology_reconnect(hwloc_topology_t topology, unsigned long flags __hwloc_attribute_unused);\n\n/** \\brief Make sure that plugins can lookup core symbols.\n *\n * This is a sanity check to avoid lazy-lookup failures when libhwloc\n * is loaded within a plugin, and later tries to load its own plugins.\n * This may fail (and abort the program) if libhwloc symbols are in a\n * private namespace.\n *\n * \\return 0 on success.\n * \\return -1 if the plugin cannot be successfully loaded. The caller\n * plugin init() callback should return a negative error code as well.\n *\n * Plugins should call this function in their init() callback to avoid\n * later crashes if lazy symbol resolution is used by the upper layer that\n * loaded hwloc (e.g. OpenCL implementations using dlopen with RTLD_LAZY).\n *\n * \\note The build system must define HWLOC_INSIDE_PLUGIN if and only if\n * building the caller as a plugin.\n *\n * \\note This function should remain inline so plugins can call it even\n * when they cannot find libhwloc symbols.\n */\nstatic __hwloc_inline int\nhwloc_plugin_check_namespace(const char *pluginname __hwloc_attribute_unused, const char *symbol __hwloc_attribute_unused)\n{\n#ifdef HWLOC_INSIDE_PLUGIN\n  lt_dlhandle handle;\n  void *sym;\n  handle = lt_dlopen(NULL);\n  if (!handle)\n    /* cannot check, assume things will work */\n    return 0;\n  sym = lt_dlsym(handle, symbol);\n  lt_dlclose(handle);\n  if (!sym) {\n    static int verboseenv_checked = 0;\n    static int verboseenv_value = 0;\n    if (!verboseenv_checked) {\n      const char *verboseenv = getenv(\"HWLOC_PLUGINS_VERBOSE\");\n      verboseenv_value = verboseenv ? atoi(verboseenv) : 0;\n      verboseenv_checked = 1;\n    }\n    if (verboseenv_value)\n      fprintf(stderr, \"Plugin `%s' disabling itself because it cannot find the `%s' core symbol.\\n\",\n\t      pluginname, symbol);\n    return -1;\n  }\n#endif /* HWLOC_INSIDE_PLUGIN */\n  return 0;\n}\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_filtering Components and Plugins: Filtering objects\n * @{\n */\n\n/** \\brief Check whether the given PCI device classid is important.\n *\n * \\return 1 if important, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_pcidev_subtype_important(unsigned classid)\n{\n  unsigned baseclass = classid >> 8;\n  return (baseclass == 0x03 /* PCI_BASE_CLASS_DISPLAY */\n\t  || baseclass == 0x02 /* PCI_BASE_CLASS_NETWORK */\n\t  || baseclass == 0x01 /* PCI_BASE_CLASS_STORAGE */\n\t  || baseclass == 0x0b /* PCI_BASE_CLASS_PROCESSOR */\n\t  || classid == 0x0c04 /* PCI_CLASS_SERIAL_FIBER */\n\t  || classid == 0x0c06 /* PCI_CLASS_SERIAL_INFINIBAND */\n\t  || baseclass == 0x12 /* Processing Accelerators */);\n}\n\n/** \\brief Check whether the given OS device subtype is important.\n *\n * \\return 1 if important, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_osdev_subtype_important(hwloc_obj_osdev_type_t subtype)\n{\n  return (subtype != HWLOC_OBJ_OSDEV_DMA);\n}\n\n/** \\brief Check whether a non-I/O object type should be filtered-out.\n *\n * Cannot be used for I/O objects.\n *\n * \\return 1 if the object type should be kept, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_keep_object_type(hwloc_topology_t topology, hwloc_obj_type_t type)\n{\n  enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;\n  hwloc_topology_get_type_filter(topology, type, &filter);\n  assert(filter != HWLOC_TYPE_FILTER_KEEP_IMPORTANT); /* IMPORTANT only used for I/O */\n  return filter == HWLOC_TYPE_FILTER_KEEP_NONE ? 0 : 1;\n}\n\n/** \\brief Check whether the given object should be filtered-out.\n *\n * \\return 1 if the object type should be kept, 0 otherwise.\n */\nstatic __hwloc_inline int\nhwloc_filter_check_keep_object(hwloc_topology_t topology, hwloc_obj_t obj)\n{\n  hwloc_obj_type_t type = obj->type;\n  enum hwloc_type_filter_e filter = HWLOC_TYPE_FILTER_KEEP_NONE;\n  hwloc_topology_get_type_filter(topology, type, &filter);\n  if (filter == HWLOC_TYPE_FILTER_KEEP_NONE)\n    return 0;\n  if (filter == HWLOC_TYPE_FILTER_KEEP_IMPORTANT) {\n    if (type == HWLOC_OBJ_PCI_DEVICE)\n      return hwloc_filter_check_pcidev_subtype_important(obj->attr->pcidev.class_id);\n    if (type == HWLOC_OBJ_OS_DEVICE)\n      return hwloc_filter_check_osdev_subtype_important(obj->attr->osdev.type);\n  }\n  return 1;\n}\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_pcidisc Components and Plugins: helpers for PCI discovery\n * @{\n */\n\n/** \\brief Return the offset of the given capability in the PCI config space buffer\n *\n * This function requires a 256-bytes config space. Unknown/unavailable bytes should be set to 0xff.\n */\nHWLOC_DECLSPEC unsigned hwloc_pcidisc_find_cap(const unsigned char *config, unsigned cap);\n\n/** \\brief Fill linkspeed by reading the PCI config space where PCI_CAP_ID_EXP is at position offset.\n *\n * Needs 20 bytes of EXP capability block starting at offset in the config space\n * for registers up to link status.\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_find_linkspeed(const unsigned char *config, unsigned offset, float *linkspeed);\n\n/** \\brief Return the hwloc object type (PCI device or Bridge) for the given class and configuration space.\n *\n * This function requires 16 bytes of common configuration header at the beginning of config.\n */\nHWLOC_DECLSPEC hwloc_obj_type_t hwloc_pcidisc_check_bridge_type(unsigned device_class, const unsigned char *config);\n\n/** \\brief Fills the attributes of the given PCI bridge using the given PCI config space.\n *\n * This function requires 32 bytes of common configuration header at the beginning of config.\n *\n * Returns -1 and destroys /p obj if bridge fields are invalid.\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_find_bridge_buses(unsigned domain, unsigned bus, unsigned dev, unsigned func,\n\t\t\t\t\t\t   unsigned *secondary_busp, unsigned *subordinate_busp,\n\t\t\t\t\t\t   const unsigned char *config);\n\n/** \\brief Insert a PCI object in the given PCI tree by looking at PCI bus IDs.\n *\n * If \\p treep points to \\c NULL, the new object is inserted there.\n */\nHWLOC_DECLSPEC void hwloc_pcidisc_tree_insert_by_busid(struct hwloc_obj **treep, struct hwloc_obj *obj);\n\n/** \\brief Add some hostbridges on top of the given tree of PCI objects and attach them to the topology.\n *\n * Other backends may lookup PCI objects or localities (for instance to attach OS devices)\n * by using hwloc_pcidisc_find_by_busid() or hwloc_pcidisc_find_busid_parent().\n */\nHWLOC_DECLSPEC int hwloc_pcidisc_tree_attach(struct hwloc_topology *topology, struct hwloc_obj *tree);\n\n/** @} */\n\n\n\n\n/** \\defgroup hwlocality_components_pcifind Components and Plugins: finding PCI objects during other discoveries\n * @{\n */\n\n/** \\brief Find the normal parent of a PCI bus ID.\n *\n * Look at PCI affinity to find out where the given PCI bus ID should be attached.\n *\n * This function should be used to attach an I/O device under the corresponding\n * PCI object (if any), or under a normal (non-I/O) object with same locality.\n */\nHWLOC_DECLSPEC struct hwloc_obj * hwloc_pci_find_parent_by_busid(struct hwloc_topology *topology, unsigned domain, unsigned bus, unsigned dev, unsigned func);\n\n/** @} */\n\n\n\n\n#endif /* HWLOC_PLUGINS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/ext/hwloc/hwloc/components.c": "/*\n * Copyright \u00a9 2009-2019 Inria.  All rights reserved.\n * Copyright \u00a9 2012 Universit\u00e9 Bordeaux\n * See COPYING in top-level directory.\n */\n\n#include \"private/autogen/config.h\"\n#include \"hwloc.h\"\n#include \"private/private.h\"\n#include \"private/xml.h\"\n#include \"private/misc.h\"\n\n#define HWLOC_COMPONENT_STOP_NAME \"stop\"\n#define HWLOC_COMPONENT_EXCLUDE_CHAR '-'\n#define HWLOC_COMPONENT_SEPS \",\"\n#define HWLOC_COMPONENT_PHASESEP_CHAR ':'\n\n/* list of all registered discovery components, sorted by priority, higher priority first.\n * noos is last because its priority is 0.\n * others' priority is 10.\n */\nstatic struct hwloc_disc_component * hwloc_disc_components = NULL;\n\nstatic unsigned hwloc_components_users = 0; /* first one initializes, last ones destroys */\n\nstatic int hwloc_components_verbose = 0;\n#ifdef HWLOC_HAVE_PLUGINS\nstatic int hwloc_plugins_verbose = 0;\nstatic const char * hwloc_plugins_blacklist = NULL;\n#endif\n\n/* hwloc_components_mutex serializes:\n * - loading/unloading plugins, and modifications of the hwloc_plugins list\n * - calls to ltdl, including in hwloc_check_plugin_namespace()\n * - registration of components with hwloc_disc_component_register()\n *   and hwloc_xml_callbacks_register()\n */\n#ifdef HWLOC_WIN_SYS\n/* Basic mutex on top of InterlockedCompareExchange() on windows,\n * Far from perfect, but easy to maintain, and way enough given that this code will never be needed for real. */\n#include <windows.h>\nstatic LONG hwloc_components_mutex = 0;\n#define HWLOC_COMPONENTS_LOCK() do {\t\t\t\t\t\t\\\n  while (InterlockedCompareExchange(&hwloc_components_mutex, 1, 0) != 0)\t\\\n    SwitchToThread();\t\t\t\t\t\t\t\t\\\n} while (0)\n#define HWLOC_COMPONENTS_UNLOCK() do {\t\t\t\t\t\t\\\n  assert(hwloc_components_mutex == 1);\t\t\t\t\t\t\\\n  hwloc_components_mutex = 0;\t\t\t\t\t\t\t\\\n} while (0)\n\n#elif defined HWLOC_HAVE_PTHREAD_MUTEX\n/* pthread mutex if available (except on windows) */\n#include <pthread.h>\nstatic pthread_mutex_t hwloc_components_mutex = PTHREAD_MUTEX_INITIALIZER;\n#define HWLOC_COMPONENTS_LOCK() pthread_mutex_lock(&hwloc_components_mutex)\n#define HWLOC_COMPONENTS_UNLOCK() pthread_mutex_unlock(&hwloc_components_mutex)\n\n#else /* HWLOC_WIN_SYS || HWLOC_HAVE_PTHREAD_MUTEX */\n#error No mutex implementation available\n#endif\n\n\n#ifdef HWLOC_HAVE_PLUGINS\n\n#include <ltdl.h>\n\n/* array of pointers to dynamically loaded plugins */\nstatic struct hwloc__plugin_desc {\n  char *name;\n  struct hwloc_component *component;\n  char *filename;\n  lt_dlhandle handle;\n  struct hwloc__plugin_desc *next;\n} *hwloc_plugins = NULL;\n\nstatic int\nhwloc__dlforeach_cb(const char *filename, void *_data __hwloc_attribute_unused)\n{\n  const char *basename;\n  lt_dlhandle handle;\n  struct hwloc_component *component;\n  struct hwloc__plugin_desc *desc, **prevdesc;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin dlforeach found `%s'\\n\", filename);\n\n  basename = strrchr(filename, '/');\n  if (!basename)\n    basename = filename;\n  else\n    basename++;\n\n  if (hwloc_plugins_blacklist && strstr(hwloc_plugins_blacklist, basename)) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin `%s' is blacklisted in the environment\\n\", basename);\n    goto out;\n  }\n\n  /* dlopen and get the component structure */\n  handle = lt_dlopenext(filename);\n  if (!handle) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Failed to load plugin: %s\\n\", lt_dlerror());\n    goto out;\n  }\n\n{\n  char componentsymbolname[strlen(basename)+10+1];\n  sprintf(componentsymbolname, \"%s_component\", basename);\n  component = lt_dlsym(handle, componentsymbolname);\n  if (!component) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Failed to find component symbol `%s'\\n\",\n\t      componentsymbolname);\n    goto out_with_handle;\n  }\n  if (component->abi != HWLOC_COMPONENT_ABI) {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin symbol ABI %u instead of %d\\n\",\n\t      component->abi, HWLOC_COMPONENT_ABI);\n    goto out_with_handle;\n  }\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin contains expected symbol `%s'\\n\",\n\t    componentsymbolname);\n}\n\n  if (HWLOC_COMPONENT_TYPE_DISC == component->type) {\n    if (strncmp(basename, \"hwloc_\", 6)) {\n      if (hwloc_plugins_verbose)\n\tfprintf(stderr, \"Plugin name `%s' doesn't match its type DISCOVERY\\n\", basename);\n      goto out_with_handle;\n    }\n  } else if (HWLOC_COMPONENT_TYPE_XML == component->type) {\n    if (strncmp(basename, \"hwloc_xml_\", 10)) {\n      if (hwloc_plugins_verbose)\n\tfprintf(stderr, \"Plugin name `%s' doesn't match its type XML\\n\", basename);\n      goto out_with_handle;\n    }\n  } else {\n    if (hwloc_plugins_verbose)\n      fprintf(stderr, \"Plugin name `%s' has invalid type %u\\n\",\n\t      basename, (unsigned) component->type);\n    goto out_with_handle;\n  }\n\n  /* allocate a plugin_desc and queue it */\n  desc = malloc(sizeof(*desc));\n  if (!desc)\n    goto out_with_handle;\n  desc->name = strdup(basename);\n  desc->filename = strdup(filename);\n  desc->component = component;\n  desc->handle = handle;\n  desc->next = NULL;\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin descriptor `%s' ready\\n\", basename);\n\n  /* append to the list */\n  prevdesc = &hwloc_plugins;\n  while (*prevdesc)\n    prevdesc = &((*prevdesc)->next);\n  *prevdesc = desc;\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Plugin descriptor `%s' queued\\n\", basename);\n  return 0;\n\n out_with_handle:\n  lt_dlclose(handle);\n out:\n  return 0;\n}\n\nstatic void\nhwloc_plugins_exit(void)\n{\n  struct hwloc__plugin_desc *desc, *next;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Closing all plugins\\n\");\n\n  desc = hwloc_plugins;\n  while (desc) {\n    next = desc->next;\n    lt_dlclose(desc->handle);\n    free(desc->name);\n    free(desc->filename);\n    free(desc);\n    desc = next;\n  }\n  hwloc_plugins = NULL;\n\n  lt_dlexit();\n}\n\nstatic int\nhwloc_plugins_init(void)\n{\n  const char *verboseenv;\n  const char *path = HWLOC_PLUGINS_PATH;\n  const char *env;\n  int err;\n\n  verboseenv = getenv(\"HWLOC_PLUGINS_VERBOSE\");\n  hwloc_plugins_verbose = verboseenv ? atoi(verboseenv) : 0;\n\n  hwloc_plugins_blacklist = getenv(\"HWLOC_PLUGINS_BLACKLIST\");\n\n  err = lt_dlinit();\n  if (err)\n    goto out;\n\n  env = getenv(\"HWLOC_PLUGINS_PATH\");\n  if (env)\n    path = env;\n\n  hwloc_plugins = NULL;\n\n  if (hwloc_plugins_verbose)\n    fprintf(stderr, \"Starting plugin dlforeach in %s\\n\", path);\n  err = lt_dlforeachfile(path, hwloc__dlforeach_cb, NULL);\n  if (err)\n    goto out_with_init;\n\n  return 0;\n\n out_with_init:\n  hwloc_plugins_exit();\n out:\n  return -1;\n}\n\n#endif /* HWLOC_HAVE_PLUGINS */\n\nstatic int\nhwloc_disc_component_register(struct hwloc_disc_component *component,\n\t\t\t      const char *filename)\n{\n  struct hwloc_disc_component **prev;\n\n  /* check that the component name is valid */\n  if (!strcmp(component->name, HWLOC_COMPONENT_STOP_NAME)) {\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Cannot register discovery component with reserved name `\" HWLOC_COMPONENT_STOP_NAME \"'\\n\");\n    return -1;\n  }\n  if (strchr(component->name, HWLOC_COMPONENT_EXCLUDE_CHAR)\n      || strchr(component->name, HWLOC_COMPONENT_PHASESEP_CHAR)\n      || strcspn(component->name, HWLOC_COMPONENT_SEPS) != strlen(component->name)) {\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Cannot register discovery component with name `%s' containing reserved characters `%c\" HWLOC_COMPONENT_SEPS \"'\\n\",\n\t      component->name, HWLOC_COMPONENT_EXCLUDE_CHAR);\n    return -1;\n  }\n\n  /* check that the component phases are valid */\n  if (!component->phases\n      || (component->phases != HWLOC_DISC_PHASE_GLOBAL\n\t  && component->phases & ~(HWLOC_DISC_PHASE_CPU\n\t\t\t\t   |HWLOC_DISC_PHASE_MEMORY\n\t\t\t\t   |HWLOC_DISC_PHASE_PCI\n\t\t\t\t   |HWLOC_DISC_PHASE_IO\n\t\t\t\t   |HWLOC_DISC_PHASE_MISC\n\t\t\t\t   |HWLOC_DISC_PHASE_ANNOTATE\n\t\t\t\t   |HWLOC_DISC_PHASE_TWEAK))) {\n    fprintf(stderr, \"Cannot register discovery component `%s' with invalid phases 0x%x\\n\",\n\t    component->name, component->phases);\n    return -1;\n  }\n\n  prev = &hwloc_disc_components;\n  while (NULL != *prev) {\n    if (!strcmp((*prev)->name, component->name)) {\n      /* if two components have the same name, only keep the highest priority one */\n      if ((*prev)->priority < component->priority) {\n\t/* drop the existing component */\n\tif (hwloc_components_verbose)\n\t  fprintf(stderr, \"Dropping previously registered discovery component `%s', priority %u lower than new one %u\\n\",\n\t\t  (*prev)->name, (*prev)->priority, component->priority);\n\t*prev = (*prev)->next;\n      } else {\n\t/* drop the new one */\n\tif (hwloc_components_verbose)\n\t  fprintf(stderr, \"Ignoring new discovery component `%s', priority %u lower than previously registered one %u\\n\",\n\t\t  component->name, component->priority, (*prev)->priority);\n\treturn -1;\n      }\n    }\n    prev = &((*prev)->next);\n  }\n  if (hwloc_components_verbose)\n    fprintf(stderr, \"Registered discovery component `%s' phases 0x%x with priority %u (%s%s)\\n\",\n\t    component->name, component->phases, component->priority,\n\t    filename ? \"from plugin \" : \"statically build\", filename ? filename : \"\");\n\n  prev = &hwloc_disc_components;\n  while (NULL != *prev) {\n    if ((*prev)->priority < component->priority)\n      break;\n    prev = &((*prev)->next);\n  }\n  component->next = *prev;\n  *prev = component;\n  return 0;\n}\n\n#include \"static-components.h\"\n\nstatic void (**hwloc_component_finalize_cbs)(unsigned long);\nstatic unsigned hwloc_component_finalize_cb_count;\n\nvoid\nhwloc_components_init(void)\n{\n#ifdef HWLOC_HAVE_PLUGINS\n  struct hwloc__plugin_desc *desc;\n#endif\n  const char *verboseenv;\n  unsigned i;\n\n  HWLOC_COMPONENTS_LOCK();\n  assert((unsigned) -1 != hwloc_components_users);\n  if (0 != hwloc_components_users++) {\n    HWLOC_COMPONENTS_UNLOCK();\n    return;\n  }\n\n  verboseenv = getenv(\"HWLOC_COMPONENTS_VERBOSE\");\n  hwloc_components_verbose = verboseenv ? atoi(verboseenv) : 0;\n\n#ifdef HWLOC_HAVE_PLUGINS\n  hwloc_plugins_init();\n#endif\n\n  hwloc_component_finalize_cbs = NULL;\n  hwloc_component_finalize_cb_count = 0;\n  /* count the max number of finalize callbacks */\n  for(i=0; NULL != hwloc_static_components[i]; i++)\n    hwloc_component_finalize_cb_count++;\n#ifdef HWLOC_HAVE_PLUGINS\n  for(desc = hwloc_plugins; NULL != desc; desc = desc->next)\n    hwloc_component_finalize_cb_count++;\n#endif\n  if (hwloc_component_finalize_cb_count) {\n    hwloc_component_finalize_cbs = calloc(hwloc_component_finalize_cb_count,\n\t\t\t\t\t  sizeof(*hwloc_component_finalize_cbs));\n    assert(hwloc_component_finalize_cbs);\n    /* forget that max number and recompute the real one below */\n    hwloc_component_finalize_cb_count = 0;\n  }\n\n  /* hwloc_static_components is created by configure in static-components.h */\n  for(i=0; NULL != hwloc_static_components[i]; i++) {\n    if (hwloc_static_components[i]->flags) {\n      fprintf(stderr, \"Ignoring static component with invalid flags %lx\\n\",\n\t      hwloc_static_components[i]->flags);\n      continue;\n    }\n\n    /* initialize the component */\n    if (hwloc_static_components[i]->init && hwloc_static_components[i]->init(0) < 0) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Ignoring static component, failed to initialize\\n\");\n      continue;\n    }\n    /* queue ->finalize() callback if any */\n    if (hwloc_static_components[i]->finalize)\n      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = hwloc_static_components[i]->finalize;\n\n    /* register for real now */\n    if (HWLOC_COMPONENT_TYPE_DISC == hwloc_static_components[i]->type)\n      hwloc_disc_component_register(hwloc_static_components[i]->data, NULL);\n    else if (HWLOC_COMPONENT_TYPE_XML == hwloc_static_components[i]->type)\n      hwloc_xml_callbacks_register(hwloc_static_components[i]->data);\n    else\n      assert(0);\n  }\n\n  /* dynamic plugins */\n#ifdef HWLOC_HAVE_PLUGINS\n  for(desc = hwloc_plugins; NULL != desc; desc = desc->next) {\n    if (desc->component->flags) {\n      fprintf(stderr, \"Ignoring plugin `%s' component with invalid flags %lx\\n\",\n\t      desc->name, desc->component->flags);\n      continue;\n    }\n\n    /* initialize the component */\n    if (desc->component->init && desc->component->init(0) < 0) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Ignoring plugin `%s', failed to initialize\\n\", desc->name);\n      continue;\n    }\n    /* queue ->finalize() callback if any */\n    if (desc->component->finalize)\n      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = desc->component->finalize;\n\n    /* register for real now */\n    if (HWLOC_COMPONENT_TYPE_DISC == desc->component->type)\n      hwloc_disc_component_register(desc->component->data, desc->filename);\n    else if (HWLOC_COMPONENT_TYPE_XML == desc->component->type)\n      hwloc_xml_callbacks_register(desc->component->data);\n    else\n      assert(0);\n  }\n#endif\n\n  HWLOC_COMPONENTS_UNLOCK();\n}\n\nvoid\nhwloc_topology_components_init(struct hwloc_topology *topology)\n{\n  topology->nr_blacklisted_components = 0;\n  topology->blacklisted_components = NULL;\n\n  topology->backends = NULL;\n  topology->backend_phases = 0;\n  topology->backend_excluded_phases = 0;\n}\n\n/* look for name among components, ignoring things after `:' */\nstatic struct hwloc_disc_component *\nhwloc_disc_component_find(const char *name, const char **endp)\n{\n  struct hwloc_disc_component *comp;\n  size_t length;\n  const char *end = strchr(name, HWLOC_COMPONENT_PHASESEP_CHAR);\n  if (end) {\n    length = end-name;\n    if (endp)\n      *endp = end+1;\n  } else {\n    length = strlen(name);\n    if (endp)\n      *endp = NULL;\n  }\n\n  comp = hwloc_disc_components;\n  while (NULL != comp) {\n    if (!strncmp(name, comp->name, length))\n      return comp;\n    comp = comp->next;\n  }\n  return NULL;\n}\n\nstatic unsigned\nhwloc_phases_from_string(const char *s)\n{\n  if (!s)\n    return ~0U;\n  if (s[0]<'0' || s[0]>'9') {\n    if (!strcasecmp(s, \"global\"))\n      return HWLOC_DISC_PHASE_GLOBAL;\n    else if (!strcasecmp(s, \"cpu\"))\n      return HWLOC_DISC_PHASE_CPU;\n    if (!strcasecmp(s, \"memory\"))\n      return HWLOC_DISC_PHASE_MEMORY;\n    if (!strcasecmp(s, \"pci\"))\n      return HWLOC_DISC_PHASE_PCI;\n    if (!strcasecmp(s, \"io\"))\n      return HWLOC_DISC_PHASE_IO;\n    if (!strcasecmp(s, \"misc\"))\n      return HWLOC_DISC_PHASE_MISC;\n    if (!strcasecmp(s, \"annotate\"))\n      return HWLOC_DISC_PHASE_ANNOTATE;\n    if (!strcasecmp(s, \"tweak\"))\n      return HWLOC_DISC_PHASE_TWEAK;\n    return 0;\n  }\n  return (unsigned) strtoul(s, NULL, 0);\n}\n\nstatic int\nhwloc_disc_component_blacklist_one(struct hwloc_topology *topology,\n\t\t\t\t   const char *name)\n{\n  struct hwloc_topology_forced_component_s *blacklisted;\n  struct hwloc_disc_component *comp;\n  unsigned phases;\n  unsigned i;\n\n  if (!strcmp(name, \"linuxpci\") || !strcmp(name, \"linuxio\")) {\n    /* replace linuxpci and linuxio with linux (with IO phases)\n     * for backward compatibility with pre-v2.0 and v2.0 respectively */\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Replacing deprecated component `%s' with `linux' IO phases in blacklisting\\n\", name);\n    comp = hwloc_disc_component_find(\"linux\", NULL);\n    phases = HWLOC_DISC_PHASE_PCI | HWLOC_DISC_PHASE_IO | HWLOC_DISC_PHASE_MISC | HWLOC_DISC_PHASE_ANNOTATE;\n\n  } else {\n    /* normal lookup */\n    const char *end;\n    comp = hwloc_disc_component_find(name, &end);\n    phases = hwloc_phases_from_string(end);\n  }\n  if (!comp) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (hwloc_components_verbose)\n    fprintf(stderr, \"Blacklisting component `%s` phases 0x%x\\n\", comp->name, phases);\n\n  for(i=0; i<topology->nr_blacklisted_components; i++) {\n    if (topology->blacklisted_components[i].component == comp) {\n      topology->blacklisted_components[i].phases |= phases;\n      return 0;\n    }\n  }\n\n  blacklisted = realloc(topology->blacklisted_components, (topology->nr_blacklisted_components+1)*sizeof(*blacklisted));\n  if (!blacklisted)\n    return -1;\n\n  blacklisted[topology->nr_blacklisted_components].component = comp;\n  blacklisted[topology->nr_blacklisted_components].phases = phases;\n  topology->blacklisted_components = blacklisted;\n  topology->nr_blacklisted_components++;\n  return 0;\n}\n\nint\nhwloc_topology_set_components(struct hwloc_topology *topology,\n\t\t\t      unsigned long flags,\n\t\t\t      const char *name)\n{\n  if (topology->is_loaded) {\n    errno = EBUSY;\n    return -1;\n  }\n\n  if (flags & ~HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  /* this flag is strictly required for now */\n  if (flags != HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (!strncmp(name, \"all\", 3) && name[3] == HWLOC_COMPONENT_PHASESEP_CHAR) {\n    topology->backend_excluded_phases = hwloc_phases_from_string(name+4);\n    return 0;\n  }\n\n  return hwloc_disc_component_blacklist_one(topology, name);\n}\n\n/* used by set_xml(), set_synthetic(), ... environment variables, ... to force the first backend */\nint\nhwloc_disc_component_force_enable(struct hwloc_topology *topology,\n\t\t\t\t  int envvar_forced,\n\t\t\t\t  const char *name,\n\t\t\t\t  const void *data1, const void *data2, const void *data3)\n{\n  struct hwloc_disc_component *comp;\n  struct hwloc_backend *backend;\n\n  if (topology->is_loaded) {\n    errno = EBUSY;\n    return -1;\n  }\n\n  comp = hwloc_disc_component_find(name, NULL);\n  if (!comp) {\n    errno = ENOSYS;\n    return -1;\n  }\n\n  backend = comp->instantiate(topology, comp, 0U /* force-enabled don't get any phase blacklisting */,\n\t\t\t      data1, data2, data3);\n  if (backend) {\n    int err;\n    backend->envvar_forced = envvar_forced;\n    if (topology->backends)\n      hwloc_backends_disable_all(topology);\n    err = hwloc_backend_enable(backend);\n\n    if (comp->phases == HWLOC_DISC_PHASE_GLOBAL) {\n      char *env = getenv(\"HWLOC_ANNOTATE_GLOBAL_COMPONENTS\");\n      if (env && atoi(env))\n\ttopology->backend_excluded_phases &= ~HWLOC_DISC_PHASE_ANNOTATE;\n    }\n\n    return err;\n  } else\n    return -1;\n}\n\nstatic int\nhwloc_disc_component_try_enable(struct hwloc_topology *topology,\n\t\t\t\tstruct hwloc_disc_component *comp,\n\t\t\t\tint envvar_forced,\n\t\t\t\tunsigned blacklisted_phases)\n{\n  struct hwloc_backend *backend;\n\n  if (!(comp->phases & ~(topology->backend_excluded_phases | blacklisted_phases))) {\n    /* all this backend phases are already excluded, exclude the backend entirely */\n    if (hwloc_components_verbose)\n      /* do not warn if envvar_forced since system-wide HWLOC_COMPONENTS must be silently ignored after set_xml() etc.\n       */\n      fprintf(stderr, \"Excluding discovery component `%s' phases 0x%x, conflicts with excludes 0x%x\\n\",\n\t      comp->name, comp->phases, topology->backend_excluded_phases);\n    return -1;\n  }\n\n  backend = comp->instantiate(topology, comp, topology->backend_excluded_phases | blacklisted_phases,\n\t\t\t      NULL, NULL, NULL);\n  if (!backend) {\n    if (hwloc_components_verbose || envvar_forced)\n      fprintf(stderr, \"Failed to instantiate discovery component `%s'\\n\", comp->name);\n    return -1;\n  }\n\n  backend->phases &= ~blacklisted_phases;\n  backend->envvar_forced = envvar_forced;\n  return hwloc_backend_enable(backend);\n}\n\nvoid\nhwloc_disc_components_enable_others(struct hwloc_topology *topology)\n{\n  struct hwloc_disc_component *comp;\n  struct hwloc_backend *backend;\n  int tryall = 1;\n  const char *_env;\n  char *env; /* we'll to modify the env value, so duplicate it */\n  unsigned i;\n\n  _env = getenv(\"HWLOC_COMPONENTS\");\n  env = _env ? strdup(_env) : NULL;\n\n  /* blacklist disabled components */\n  if (env) {\n    char *curenv = env;\n    size_t s;\n\n    while (*curenv) {\n      s = strcspn(curenv, HWLOC_COMPONENT_SEPS);\n      if (s) {\n\tchar c;\n\n\tif (curenv[0] != HWLOC_COMPONENT_EXCLUDE_CHAR)\n\t  goto nextname;\n\n\t/* save the last char and replace with \\0 */\n\tc = curenv[s];\n\tcurenv[s] = '\\0';\n\n\t/* blacklist it, and just ignore failures to allocate */\n\thwloc_disc_component_blacklist_one(topology, curenv+1);\n\n\t/* remove that blacklisted name from the string */\n\tfor(i=0; i<s; i++)\n\t  curenv[i] = *HWLOC_COMPONENT_SEPS;\n\n\t/* restore chars (the second loop below needs env to be unmodified) */\n\tcurenv[s] = c;\n      }\n\n    nextname:\n      curenv += s;\n      if (*curenv)\n\t/* Skip comma */\n\tcurenv++;\n    }\n  }\n\n  /* enable explicitly listed components */\n  if (env) {\n    char *curenv = env;\n    size_t s;\n\n    while (*curenv) {\n      s = strcspn(curenv, HWLOC_COMPONENT_SEPS);\n      if (s) {\n\tchar c, *name;\n\n\tif (!strncmp(curenv, HWLOC_COMPONENT_STOP_NAME, s)) {\n\t  tryall = 0;\n\t  break;\n\t}\n\n\t/* save the last char and replace with \\0 */\n\tc = curenv[s];\n\tcurenv[s] = '\\0';\n\n\tname = curenv;\n\tif (!strcmp(name, \"linuxpci\") || !strcmp(name, \"linuxio\")) {\n\t  if (hwloc_components_verbose)\n\t    fprintf(stderr, \"Replacing deprecated component `%s' with `linux' in envvar forcing\\n\", name);\n\t  name = \"linux\";\n\t}\n\n\tcomp = hwloc_disc_component_find(name, NULL /* we enable the entire component, phases must be blacklisted separately */);\n\tif (comp) {\n\t  unsigned blacklisted_phases = 0U;\n\t  for(i=0; i<topology->nr_blacklisted_components; i++)\n\t    if (comp == topology->blacklisted_components[i].component) {\n\t      blacklisted_phases = topology->blacklisted_components[i].phases;\n\t      break;\n\t    }\n\t  if (comp->phases & ~blacklisted_phases)\n\t    hwloc_disc_component_try_enable(topology, comp, 1 /* envvar forced */, blacklisted_phases);\n\t} else {\n\t  fprintf(stderr, \"Cannot find discovery component `%s'\\n\", name);\n\t}\n\n\t/* restore chars (the second loop below needs env to be unmodified) */\n\tcurenv[s] = c;\n      }\n\n      curenv += s;\n      if (*curenv)\n\t/* Skip comma */\n\tcurenv++;\n    }\n  }\n\n  /* env is still the same, the above loop didn't modify it */\n\n  /* now enable remaining components (except the explicitly '-'-listed ones) */\n  if (tryall) {\n    comp = hwloc_disc_components;\n    while (NULL != comp) {\n      unsigned blacklisted_phases = 0U;\n      if (!comp->enabled_by_default)\n\tgoto nextcomp;\n      /* check if this component was blacklisted by the application */\n      for(i=0; i<topology->nr_blacklisted_components; i++)\n\tif (comp == topology->blacklisted_components[i].component) {\n\t  blacklisted_phases = topology->blacklisted_components[i].phases;\n\t  break;\n\t}\n\n      if (!(comp->phases & ~blacklisted_phases)) {\n\tif (hwloc_components_verbose)\n\t  fprintf(stderr, \"Excluding blacklisted discovery component `%s' phases 0x%x\\n\",\n\t\t  comp->name, comp->phases);\n\tgoto nextcomp;\n      }\n\n      hwloc_disc_component_try_enable(topology, comp, 0 /* defaults, not envvar forced */, blacklisted_phases);\nnextcomp:\n      comp = comp->next;\n    }\n  }\n\n  if (hwloc_components_verbose) {\n    /* print a summary */\n    int first = 1;\n    backend = topology->backends;\n    fprintf(stderr, \"Final list of enabled discovery components: \");\n    while (backend != NULL) {\n      fprintf(stderr, \"%s%s(0x%x)\", first ? \"\" : \",\", backend->component->name, backend->phases);\n      backend = backend->next;\n      first = 0;\n    }\n    fprintf(stderr, \"\\n\");\n  }\n\n  free(env);\n}\n\nvoid\nhwloc_components_fini(void)\n{\n  unsigned i;\n\n  HWLOC_COMPONENTS_LOCK();\n  assert(0 != hwloc_components_users);\n  if (0 != --hwloc_components_users) {\n    HWLOC_COMPONENTS_UNLOCK();\n    return;\n  }\n\n  for(i=0; i<hwloc_component_finalize_cb_count; i++)\n    hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count-i-1](0);\n  free(hwloc_component_finalize_cbs);\n  hwloc_component_finalize_cbs = NULL;\n  hwloc_component_finalize_cb_count = 0;\n\n  /* no need to unlink/free the list of components, they'll be unloaded below */\n\n  hwloc_disc_components = NULL;\n  hwloc_xml_callbacks_reset();\n\n#ifdef HWLOC_HAVE_PLUGINS\n  hwloc_plugins_exit();\n#endif\n\n  HWLOC_COMPONENTS_UNLOCK();\n}\n\nstruct hwloc_backend *\nhwloc_backend_alloc(struct hwloc_topology *topology,\n\t\t    struct hwloc_disc_component *component)\n{\n  struct hwloc_backend * backend = malloc(sizeof(*backend));\n  if (!backend) {\n    errno = ENOMEM;\n    return NULL;\n  }\n  backend->component = component;\n  backend->topology = topology;\n  /* filter-out component phases that are excluded */\n  backend->phases = component->phases & ~topology->backend_excluded_phases;\n  if (backend->phases != component->phases && hwloc_components_verbose)\n    fprintf(stderr, \"Trying discovery component `%s' with phases 0x%x instead of 0x%x\\n\",\n\t    component->name, backend->phases, component->phases);\n  backend->flags = 0;\n  backend->discover = NULL;\n  backend->get_pci_busid_cpuset = NULL;\n  backend->disable = NULL;\n  backend->is_thissystem = -1;\n  backend->next = NULL;\n  backend->envvar_forced = 0;\n  return backend;\n}\n\nstatic void\nhwloc_backend_disable(struct hwloc_backend *backend)\n{\n  if (backend->disable)\n    backend->disable(backend);\n  free(backend);\n}\n\nint\nhwloc_backend_enable(struct hwloc_backend *backend)\n{\n  struct hwloc_topology *topology = backend->topology;\n  struct hwloc_backend **pprev;\n\n  /* check backend flags */\n  if (backend->flags) {\n    fprintf(stderr, \"Cannot enable discovery component `%s' phases 0x%x with unknown flags %lx\\n\",\n\t    backend->component->name, backend->component->phases, backend->flags);\n    return -1;\n  }\n\n  /* make sure we didn't already enable this backend, we don't want duplicates */\n  pprev = &topology->backends;\n  while (NULL != *pprev) {\n    if ((*pprev)->component == backend->component) {\n      if (hwloc_components_verbose)\n\tfprintf(stderr, \"Cannot enable  discovery component `%s' phases 0x%x twice\\n\",\n\t\tbackend->component->name, backend->component->phases);\n      hwloc_backend_disable(backend);\n      errno = EBUSY;\n      return -1;\n    }\n    pprev = &((*pprev)->next);\n  }\n\n  if (hwloc_components_verbose)\n    fprintf(stderr, \"Enabling discovery component `%s' with phases 0x%x (among 0x%x)\\n\",\n\t    backend->component->name, backend->phases, backend->component->phases);\n\n  /* enqueue at the end */\n  pprev = &topology->backends;\n  while (NULL != *pprev)\n    pprev = &((*pprev)->next);\n  backend->next = *pprev;\n  *pprev = backend;\n\n  topology->backend_phases |= backend->component->phases;\n  topology->backend_excluded_phases |= backend->component->excluded_phases;\n  return 0;\n}\n\nvoid\nhwloc_backends_is_thissystem(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend;\n  const char *local_env;\n\n  /*\n   * If the application changed the backend with set_foo(),\n   * it may use set_flags() update the is_thissystem flag here.\n   * If it changes the backend with environment variables below,\n   * it may use HWLOC_THISSYSTEM envvar below as well.\n   */\n\n  topology->is_thissystem = 1;\n\n  /* apply thissystem from normally-given backends (envvar_forced=0, either set_foo() or defaults) */\n  backend = topology->backends;\n  while (backend != NULL) {\n    if (backend->envvar_forced == 0 && backend->is_thissystem != -1) {\n      assert(backend->is_thissystem == 0);\n      topology->is_thissystem = 0;\n    }\n    backend = backend->next;\n  }\n\n  /* override set_foo() with flags */\n  if (topology->flags & HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)\n    topology->is_thissystem = 1;\n\n  /* now apply envvar-forced backend (envvar_forced=1) */\n  backend = topology->backends;\n  while (backend != NULL) {\n    if (backend->envvar_forced == 1 && backend->is_thissystem != -1) {\n      assert(backend->is_thissystem == 0);\n      topology->is_thissystem = 0;\n    }\n    backend = backend->next;\n  }\n\n  /* override with envvar-given flag */\n  local_env = getenv(\"HWLOC_THISSYSTEM\");\n  if (local_env)\n    topology->is_thissystem = atoi(local_env);\n}\n\nvoid\nhwloc_backends_find_callbacks(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend = topology->backends;\n  /* use the first backend's get_pci_busid_cpuset callback */\n  topology->get_pci_busid_cpuset_backend = NULL;\n  while (backend != NULL) {\n    if (backend->get_pci_busid_cpuset) {\n      topology->get_pci_busid_cpuset_backend = backend;\n      return;\n    }\n    backend = backend->next;\n  }\n  return;\n}\n\nvoid\nhwloc_backends_disable_all(struct hwloc_topology *topology)\n{\n  struct hwloc_backend *backend;\n\n  while (NULL != (backend = topology->backends)) {\n    struct hwloc_backend *next = backend->next;\n    if (hwloc_components_verbose)\n      fprintf(stderr, \"Disabling discovery component `%s'\\n\",\n\t      backend->component->name);\n    hwloc_backend_disable(backend);\n    topology->backends = next;\n  }\n  topology->backends = NULL;\n  topology->backend_excluded_phases = 0;\n}\n\nvoid\nhwloc_topology_components_fini(struct hwloc_topology *topology)\n{\n  /* hwloc_backends_disable_all() must have been called earlier */\n  assert(!topology->backends);\n\n  free(topology->blacklisted_components);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/ext/lua/src/loadlib.c": "/*\n** $Id: loadlib.c,v 1.127 2015/11/23 11:30:45 roberto Exp $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Windows, and a stub for other\n** systems.\n*/\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/*\n** LUA_PATH_VAR and LUA_CPATH_VAR are the names of the environment\n** variables that Lua check to set its paths.\n*/\n#if !defined(LUA_PATH_VAR)\n#define LUA_PATH_VAR\t\"LUA_PATH\"\n#endif\n\n#if !defined(LUA_CPATH_VAR)\n#define LUA_CPATH_VAR\t\"LUA_CPATH\"\n#endif\n\n#define LUA_PATHSUFFIX\t\t\"_\" LUA_VERSION_MAJOR \"_\" LUA_VERSION_MINOR\n\n#define LUA_PATHVARVERSION\t\tLUA_PATH_VAR LUA_PATHSUFFIX\n#define LUA_CPATHVARVERSION\t\tLUA_CPATH_VAR LUA_PATHSUFFIX\n\n/*\n** LUA_PATH_SEP is the character that separates templates in a path.\n** LUA_PATH_MARK is the string that marks the substitution points in a\n** template.\n** LUA_EXEC_DIR in a Windows path is replaced by the executable's\n** directory.\n** LUA_IGMARK is a mark to ignore all before it when building the\n** luaopen_ function name.\n*/\n#if !defined (LUA_PATH_SEP)\n#define LUA_PATH_SEP\t\t\";\"\n#endif\n#if !defined (LUA_PATH_MARK)\n#define LUA_PATH_MARK\t\t\"?\"\n#endif\n#if !defined (LUA_EXEC_DIR)\n#define LUA_EXEC_DIR\t\t\"!\"\n#endif\n#if !defined (LUA_IGMARK)\n#define LUA_IGMARK\t\t\"-\"\n#endif\n\n\n/*\n** LUA_CSUBSEP is the character that replaces dots in submodule names\n** when searching for a C loader.\n** LUA_LSUBSEP is the character that replaces dots in submodule names\n** when searching for a Lua loader.\n*/\n#if !defined(LUA_CSUBSEP)\n#define LUA_CSUBSEP\t\tLUA_DIRSEP\n#endif\n\n#if !defined(LUA_LSUBSEP)\n#define LUA_LSUBSEP\t\tLUA_DIRSEP\n#endif\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF\t\t\"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP\t\"_\"\n\n\n/*\n** unique key for table in the registry that keeps handles\n** for all loaded C libraries\n*/\nstatic const int CLIBS = 0;\n\n#define LIB_FAIL\t\"open\"\n\n#define setprogdir(L)\t\t((void)0)\n\n\n/*\n** system-dependent functions\n*/\n\n/*\n** unload library 'lib'\n*/\nstatic void lsys_unloadlib (void *lib);\n\n/*\n** load C library in file 'path'. If 'seeglb', load with all names in\n** the library global.\n** Returns the library; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb);\n\n/*\n** Try to find a function named 'sym' in library 'lib'.\n** Returns the function; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n\n#if defined(LUA_USE_DLOPEN)\t/* { */\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface.\n** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least\n** as an emulation layer on top of native functions.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\n/*\n** Macro to convert pointer-to-void* to pointer-to-function. This cast\n** is undefined according to ISO C, but POSIX assumes that it works.\n** (The '__extension__' in gnu compilers is only to avoid warnings.)\n*/\n#if defined(__GNUC__)\n#define cast_func(p) (__extension__ (lua_CFunction)(p))\n#else\n#define cast_func(p) ((lua_CFunction)(p))\n#endif\n\n\nstatic void lsys_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = cast_func(dlsym(lib, sym));\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\t/* }{ */\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#include <windows.h>\n\n#undef setprogdir\n\n/*\n** optional flags for LoadLibraryEx\n*/\n#if !defined(LUA_LLE_FLAGS)\n#define LUA_LLE_FLAGS\t0\n#endif\n\n\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void lsys_unloadlib (void *lib) {\n  FreeLibrary((HMODULE)lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);\n  (void)(seeglb);  /* not used: symbols are 'global' by default */\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n#else\t\t\t\t/* }{ */\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL\t\"absent\"\n\n\n#define DLMSG\t\"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void lsys_unloadlib (void *lib) {\n  (void)(lib);  /* not used */\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  (void)(path); (void)(seeglb);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  (void)(lib); (void)(sym);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\t\t\t\t/* } */\n\n\n/*\n** return registry.CLIBS[path]\n*/\nstatic void *checkclib (lua_State *L, const char *path) {\n  void *plib;\n  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);\n  lua_getfield(L, -1, path);\n  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */\n  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */\n  return plib;\n}\n\n\n/*\n** registry.CLIBS[path] = plib        -- for queries\n** registry.CLIBS[#CLIBS + 1] = plib  -- also keep a list of all libraries\n*/\nstatic void addtoclib (lua_State *L, const char *path, void *plib) {\n  lua_rawgetp(L, LUA_REGISTRYINDEX, &CLIBS);\n  lua_pushlightuserdata(L, plib);\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */\n  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */\n  lua_pop(L, 1);  /* pop CLIBS table */\n}\n\n\n/*\n** __gc tag method for CLIBS table: calls 'lsys_unloadlib' for all lib\n** handles in list CLIBS\n*/\nstatic int gctm (lua_State *L) {\n  lua_Integer n = luaL_len(L, 1);\n  for (; n >= 1; n--) {  /* for each handle, in reverse order */\n    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */\n    lsys_unloadlib(lua_touserdata(L, -1));\n    lua_pop(L, 1);  /* pop handle */\n  }\n  return 0;\n}\n\n\n\n/* error codes for 'lookforfunc' */\n#define ERRLIB\t\t1\n#define ERRFUNC\t\t2\n\n/*\n** Look for a C function named 'sym' in a dynamically loaded library\n** 'path'.\n** First, check whether the library is already loaded; if not, try\n** to load it.\n** Then, if 'sym' is '*', return true (as library has been loaded).\n** Otherwise, look for symbol 'sym' in the library and push a\n** C function with that symbol.\n** Return 0 and 'true' or a function in the stack; in case of\n** errors, return an error code and an error message in the stack.\n*/\nstatic int lookforfunc (lua_State *L, const char *path, const char *sym) {\n  void *reg = checkclib(L, path);  /* check loaded C libraries */\n  if (reg == NULL) {  /* must load library? */\n    reg = lsys_load(L, path, *sym == '*');  /* global symbols if 'sym'=='*' */\n    if (reg == NULL) return ERRLIB;  /* unable to load library */\n    addtoclib(L, path, reg);\n  }\n  if (*sym == '*') {  /* loading only library (no function)? */\n    lua_pushboolean(L, 1);  /* return 'true' */\n    return 0;  /* no errors */\n  }\n  else {\n    lua_CFunction f = lsys_sym(L, reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);  /* else create new function */\n    return 0;  /* no errors */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = lookforfunc(L, path, init);\n  if (stat == 0)  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\nstatic const char *pushnexttemplate (lua_State *L, const char *path) {\n  const char *l;\n  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, l - path);  /* template */\n  return l;\n}\n\n\nstatic const char *searchpath (lua_State *L, const char *name,\n                                             const char *path,\n                                             const char *sep,\n                                             const char *dirsep) {\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  if (*sep != '\\0')  /* non-empty separator? */\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename = luaL_gsub(L, lua_tostring(L, -1),\n                                     LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file '%s'\", filename);\n    lua_remove(L, -2);  /* remove file name */\n    luaL_addvalue(&msg);  /* concatenate error msg. entry */\n  }\n  luaL_pushresult(&msg);  /* create error message */\n  return NULL;  /* not found */\n}\n\n\nstatic int ll_searchpath (lua_State *L) {\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n                                luaL_checkstring(L, 2),\n                                luaL_optstring(L, 3, \".\"),\n                                luaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) return 1;\n  else {  /* error message is on top of the stack */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    return 2;  /* return nil + error message */\n  }\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname,\n                                           const char *dirsep) {\n  const char *path;\n  lua_getfield(L, lua_upvalueindex(1), pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, \"'package.%s' must be a string\", pname);\n  return searchpath(L, name, path, \".\", dirsep);\n}\n\n\nstatic int checkload (lua_State *L, int stat, const char *filename) {\n  if (stat) {  /* module loaded successfully? */\n    lua_pushstring(L, filename);  /* will be 2nd argument to module */\n    return 2;  /* return open function and file name */\n  }\n  else\n    return luaL_error(L, \"error loading module '%s' from file '%s':\\n\\t%s\",\n                          lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int searcher_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\", LUA_LSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);\n}\n\n\n/*\n** Try to find a load function for module 'modname' at file 'filename'.\n** First, change '.' to '_' in 'modname'; then, if 'modname' has\n** the form X-Y (that is, it has an \"ignore mark\"), build a function\n** name \"luaopen_X\" and look for it. (For compatibility, if that\n** fails, it also tries \"luaopen_Y\".) If there is no ignore mark,\n** look for a function named \"luaopen_modname\".\n*/\nstatic int loadfunc (lua_State *L, const char *filename, const char *modname) {\n  const char *openfunc;\n  const char *mark;\n  modname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  mark = strchr(modname, *LUA_IGMARK);\n  if (mark) {\n    int stat;\n    openfunc = lua_pushlstring(L, modname, mark - modname);\n    openfunc = lua_pushfstring(L, LUA_POF\"%s\", openfunc);\n    stat = lookforfunc(L, filename, openfunc);\n    if (stat != ERRFUNC) return stat;\n    modname = mark + 1;  /* else go ahead and try old-style name */\n  }\n  openfunc = lua_pushfstring(L, LUA_POF\"%s\", modname);\n  return lookforfunc(L, filename, openfunc);\n}\n\n\nstatic int searcher_C (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (loadfunc(L, filename, name) == 0), filename);\n}\n\n\nstatic int searcher_Croot (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, p - name);\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* root not found */\n  if ((stat = loadfunc(L, filename, name)) != 0) {\n    if (stat != ERRFUNC)\n      return checkload(L, 0, filename);  /* real error */\n    else {  /* open function not found */\n      lua_pushfstring(L, \"\\n\\tno module '%s' in file '%s'\", name, filename);\n      return 1;\n    }\n  }\n  lua_pushstring(L, filename);  /* will be 2nd argument to module */\n  return 2;\n}\n\n\nstatic int searcher_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_PRELOAD\");\n  if (lua_getfield(L, -1, name) == LUA_TNIL)  /* not found? */\n    lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  return 1;\n}\n\n\nstatic void findloader (lua_State *L, const char *name) {\n  int i;\n  luaL_Buffer msg;  /* to build error message */\n  luaL_buffinit(L, &msg);\n  /* push 'package.searchers' to index 3 in the stack */\n  if (lua_getfield(L, lua_upvalueindex(1), \"searchers\") != LUA_TTABLE)\n    luaL_error(L, \"'package.searchers' must be a table\");\n  /*  iterate over available searchers to find a loader */\n  for (i = 1; ; i++) {\n    if (lua_rawgeti(L, 3, i) == LUA_TNIL) {  /* no more searchers? */\n      lua_pop(L, 1);  /* remove nil */\n      luaL_pushresult(&msg);  /* create error message */\n      luaL_error(L, \"module '%s' not found:%s\", name, lua_tostring(L, -1));\n    }\n    lua_pushstring(L, name);\n    lua_call(L, 1, 2);  /* call it */\n    if (lua_isfunction(L, -2))  /* did it find a loader? */\n      return;  /* module loader found */\n    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */\n      lua_pop(L, 1);  /* remove extra return */\n      luaL_addvalue(&msg);  /* concatenate error message */\n    }\n    else\n      lua_pop(L, 2);  /* remove both returns */\n  }\n}\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_settop(L, 1);  /* _LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, 2, name);  /* _LOADED[name] */\n  if (lua_toboolean(L, -1))  /* is it there? */\n    return 1;  /* package is already loaded */\n  /* else must load package */\n  lua_pop(L, 1);  /* remove 'getfield' result */\n  findloader(L, name);\n  lua_pushstring(L, name);  /* pass name as argument to module loader */\n  lua_insert(L, -2);  /* name is 1st argument (before search data) */\n  lua_call(L, 2, 1);  /* run loader to load module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */\n  if (lua_getfield(L, 2, name) == LUA_TNIL) {   /* module set no value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = true */\n  }\n  return 1;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** 'module' function\n** =======================================================\n*/\n#if defined(LUA_COMPAT_MODULE)\n\n/*\n** changes the environment variable of calling function\n*/\nstatic void set_env (lua_State *L) {\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, \"'module' not called from a Lua function\");\n  lua_pushvalue(L, -2);  /* copy new environment table to top */\n  lua_setupvalue(L, -2, 1);\n  lua_pop(L, 1);  /* remove function */\n}\n\n\nstatic void dooptions (lua_State *L, int n) {\n  int i;\n  for (i = 2; i <= n; i++) {\n    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */\n      lua_pushvalue(L, i);  /* get option (a function) */\n      lua_pushvalue(L, -2);  /* module */\n      lua_call(L, 1, 0);\n    }\n  }\n}\n\n\nstatic void modinit (lua_State *L, const char *modname) {\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname;\n  else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, dot - modname);\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\n\nstatic int ll_module (lua_State *L) {\n  const char *modname = luaL_checkstring(L, 1);\n  int lastarg = lua_gettop(L);  /* last parameter */\n  luaL_pushmodule(L, modname, 1);  /* get/create module table */\n  /* check whether table already has a _NAME field */\n  if (lua_getfield(L, -1, \"_NAME\") != LUA_TNIL)\n    lua_pop(L, 1);  /* table is an initialized module */\n  else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  set_env(L);\n  dooptions(L, lastarg);\n  return 1;\n}\n\n\nstatic int ll_seeall (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushglobaltable(L);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n#endif\n/* }====================================================== */\n\n\n\n/* auxiliary mark (for internal use) */\n#define AUXMARK\t\t\"\\1\"\n\n\n/*\n** return registry.LUA_NOENV as a boolean\n*/\nstatic int noenv (lua_State *L) {\n  int b;\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  b = lua_toboolean(L, -1);\n  lua_pop(L, 1);  /* remove value */\n  return b;\n}\n\n\nstatic void setpath (lua_State *L, const char *fieldname, const char *envname1,\n                                   const char *envname2, const char *def) {\n  const char *path = getenv(envname1);\n  if (path == NULL)  /* no environment variable? */\n    path = getenv(envname2);  /* try alternative name */\n  if (path == NULL || noenv(L))  /* no environment variable? */\n    lua_pushstring(L, def);  /* use default */\n  else {\n    /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,\n                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);\n    luaL_gsub(L, path, AUXMARK, def);\n    lua_remove(L, -2);\n  }\n  setprogdir(L);\n  lua_setfield(L, -2, fieldname);\n}\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"searchpath\", ll_searchpath},\n#if defined(LUA_COMPAT_MODULE)\n  {\"seeall\", ll_seeall},\n#endif\n  /* placeholders */\n  {\"preload\", NULL},\n  {\"cpath\", NULL},\n  {\"path\", NULL},\n  {\"searchers\", NULL},\n  {\"loaded\", NULL},\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n#if defined(LUA_COMPAT_MODULE)\n  {\"module\", ll_module},\n#endif\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic void createsearcherstable (lua_State *L) {\n  static const lua_CFunction searchers[] =\n    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};\n  int i;\n  /* create 'searchers' table */\n  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);\n  /* fill it with predefined searchers */\n  for (i=0; searchers[i] != NULL; i++) {\n    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */\n    lua_pushcclosure(L, searchers[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n#if defined(LUA_COMPAT_LOADERS)\n  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */\n  lua_setfield(L, -3, \"loaders\");  /* put it in field 'loaders' */\n#endif\n  lua_setfield(L, -2, \"searchers\");  /* put it in field 'searchers' */\n}\n\n\n/*\n** create table CLIBS to keep track of loaded C libraries,\n** setting a finalizer to close all libraries when closing state.\n*/\nstatic void createclibstable (lua_State *L) {\n  lua_newtable(L);  /* create CLIBS table */\n  lua_createtable(L, 0, 1);  /* create metatable for CLIBS */\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");  /* set finalizer for CLIBS table */\n  lua_setmetatable(L, -2);\n  lua_rawsetp(L, LUA_REGISTRYINDEX, &CLIBS);  /* set CLIBS table in registry */\n}\n\n\nLUAMOD_API int luaopen_package (lua_State *L) {\n  createclibstable(L);\n  luaL_newlib(L, pk_funcs);  /* create 'package' table */\n  createsearcherstable(L);\n  /* set field 'path' */\n  setpath(L, \"path\", LUA_PATHVARVERSION, LUA_PATH_VAR, LUA_PATH_DEFAULT);\n  /* set field 'cpath' */\n  setpath(L, \"cpath\", LUA_CPATHVARVERSION, LUA_CPATH_VAR, LUA_CPATH_DEFAULT);\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATH_SEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXEC_DIR \"\\n\" LUA_IGMARK \"\\n\");\n  lua_setfield(L, -2, \"config\");\n  /* set field 'loaded' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_setfield(L, -2, \"loaded\");\n  /* set field 'preload' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, \"_PRELOAD\");\n  lua_setfield(L, -2, \"preload\");\n  lua_pushglobaltable(L);\n  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */\n  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */\n  lua_pop(L, 1);  /* pop global table */\n  return 1;  /* return 'package' table */\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/bench/src/ptt2asm.c": "/*\n * =======================================================================================\n *      Filename:  ptt2asm.c\n *\n *      Description:  The interface to dynamically load ptt files\n *\n *      Version:   5.0\n *      Released:  10.11.2019\n *\n *      Author:   Thomas Gruber (tg), thomas.roehl@gmail.com\n *      Project:  likwid\n *\n *      Copyright (C) 2019 RRZE, University Erlangen-Nuremberg\n *\n *      This program is free software: you can redistribute it and/or modify it under\n *      the terms of the GNU General Public License as published by the Free Software\n *      Foundation, either version 3 of the License, or (at your option) any later\n *      version.\n *\n *      This program is distributed in the hope that it will be useful, but WITHOUT ANY\n *      WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n *      PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n *\n *      You should have received a copy of the GNU General Public License along with\n *      this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * =======================================================================================\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n#include <libgen.h>\n#include <dirent.h>\n#include <dlfcn.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <bstrlib.h>\n#include <bstrlib_helper.h>\n\n#include <test_types.h>\n\n\n#include <ptt2asm.h>\n\n#ifdef __x86_64\n#include <isa_x86-64.h>\n#endif\n#ifdef __i386__\n#include <isa_x86.h>\n#endif\n#ifdef __ARM_ARCH_7A__\n#include <isa_armv7.h>\n#endif\n#ifdef __ARM_ARCH_8A\n#include <isa_armv8.h>\n#endif\n#ifdef _ARCH_PPC\n#include <isa_ppc64.h>\n#endif\n\nstatic int registerMapLength(RegisterMap* map)\n{\n    int i = 0;\n    while (strlen(map[i].pattern) > 0)\n    {\n        i++;\n    }\n    return i;\n}\n\nstatic int registerMapMaxPattern(RegisterMap* map)\n{\n    int i = 0;\n    int max = 0;\n    while (strlen(map[i].pattern) > 0)\n    {\n        if (strlen(map[i].pattern) > max)\n            max = strlen(map[i].pattern);\n        i++;\n    }\n    return max;\n}\n\nstatic struct bstrList* read_ptt(bstring pttfile)\n{\n    int ret = 0;\n    FILE* fp = NULL;\n    char buf[BUFSIZ];\n    struct bstrList* l = NULL;\n\n    if (access(bdata(pttfile), R_OK))\n    {\n        return NULL;\n    }\n\n    bstring content = bfromcstr(\"\");\n    fp = fopen(bdata(pttfile), \"r\");\n    if (fp == NULL) {\n        fprintf(stderr, \"fopen(%s): errno=%d\\n\", pttfile, errno);\n        return NULL;\n    }\n    for (;;) {\n        /* Read another chunk */\n        ret = fread(buf, 1, sizeof(buf), fp);\n        if (ret < 0) {\n            fprintf(stderr, \"fread(%p, 1, %lu, %p): %d, errno=%d\\n\", buf, sizeof(buf), fp, ret, errno);\n            return NULL;\n        }\n        else if (ret == 0) {\n            break;\n        }\n        bcatblk(content, buf, ret);\n    }\n    btrimws(content);\n\n    l = bsplit(content, '\\n');\n    for (int i = 0; i < l->qty; i++)\n    {\n        btrimws(l->entry[i]);\n    }\n\n    bdestroy(content);\n    return l;\n}\n\nstatic int write_asm(bstring filename, struct bstrList* code)\n{\n    FILE* fp = NULL;\n    char newline = '\\n';\n    size_t (*ownfwrite)(const void *ptr, size_t size, size_t nmemb, FILE *stream) = &fwrite;\n    fp = fopen(bdata(filename), \"w\");\n    if (fp)\n    {\n        for (int i = 0; i < code->qty; i++)\n        {\n            ownfwrite(bdata(code->entry[i]), 1, blength(code->entry[i]), fp);\n            ownfwrite(&newline, 1, sizeof(char), fp);\n        }\n        fclose(fp);\n        return 0;\n    }\n    return 1;\n}\n\n#define ANALYSE_PTT_GET_INT(line, pattern, variable) \\\n    bstring tmp = bmidstr((line), blength((pattern))+1, blength((line))-blength((pattern))); \\\n    btrimws(tmp); \\\n    (variable) = ownatoi(bdata(tmp)); \\\n    bdestroy(tmp); \\\n\nstatic struct bstrList* analyse_ptt(bstring pttfile, TestCase** testcase)\n{\n    struct bstrList* ptt = NULL;\n    TestCase* test = NULL;\n    struct bstrList* code = NULL;\n    bstring bBYTES = bformat(\"BYTES\");\n    bstring bFLOPS = bformat(\"FLOPS\");\n    bstring bSTREAMS = bformat(\"STREAMS\");\n    bstring bTYPE = bformat(\"TYPE\");\n    bstring bTYPEDOUBLE = bformat(\"DOUBLE\");\n    bstring bTYPESINGLE = bformat(\"SINGLE\");\n    bstring bTYPEINT = bformat(\"INT\");\n    bstring bDESC = bformat(\"DESC\");\n    bstring bLOADS = bformat(\"LOADS\");\n    bstring bSTORES = bformat(\"STORES\");\n    bstring bLOADSTORES = bformat(\"LOADSTORES\");\n    bstring bINSTCONST = bformat(\"INSTR_CONST\");\n    bstring bINSTLOOP = bformat(\"INSTR_LOOP\");\n    bstring bUOPS = bformat(\"UOPS\");\n    bstring bBRANCHES = bformat(\"BRANCHES\");\n    bstring bLOOP = bformat(\"LOOP\");\n    int (*ownatoi)(const char*) = &atoi;\n\n    ptt = read_ptt(pttfile);\n\n    if (ptt && ptt->qty > 0)\n    {\n        test = malloc(sizeof(TestCase));\n        if (test)\n        {\n            test->loads = -1;\n            test->stores = -1;\n            test->loadstores = -1;\n            test->branches = -1;\n            test->instr_const = -1;\n            test->instr_loop = -1;\n            test->uops = -1;\n            code = bstrListCreate();\n            for (int i = 0; i < ptt->qty; i++)\n            {\n                if (bstrncmp(ptt->entry[i], bBYTES, blength(bBYTES)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bBYTES, test->bytes);\n                }\n                else if (bstrncmp(ptt->entry[i], bFLOPS, blength(bFLOPS)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bFLOPS, test->flops);\n                }\n                else if (bstrncmp(ptt->entry[i], bSTREAMS, blength(bSTREAMS)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bSTREAMS, test->streams);\n                }\n                else if (bstrncmp(ptt->entry[i], bLOADS, blength(bLOADS)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bLOADS, test->loads);\n                }\n                else if (bstrncmp(ptt->entry[i], bSTORES, blength(bSTORES)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bSTORES, test->stores);\n                }\n                else if (bstrncmp(ptt->entry[i], bLOADSTORES, blength(bLOADSTORES)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bLOADSTORES, test->loadstores);\n                }\n                else if (bstrncmp(ptt->entry[i], bINSTCONST, blength(bINSTCONST)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bINSTCONST, test->instr_const);\n                }\n                else if (bstrncmp(ptt->entry[i], bINSTLOOP, blength(bINSTLOOP)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bINSTLOOP, test->instr_loop);\n                }\n                else if (bstrncmp(ptt->entry[i], bUOPS, blength(bUOPS)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bUOPS, test->uops);\n                }\n                else if (bstrncmp(ptt->entry[i], bBRANCHES, blength(bBRANCHES)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bBRANCHES, test->branches);\n                }\n                else if (bstrncmp(ptt->entry[i], bLOOP, blength(bLOOP)) == BSTR_OK)\n                {\n                    ANALYSE_PTT_GET_INT(ptt->entry[i], bLOOP, test->stride);\n                    bstrListAdd(code, ptt->entry[i]);\n                }\n                else if (bstrncmp(ptt->entry[i], bDESC, blength(bDESC)) == BSTR_OK)\n                {\n                    test->desc = malloc((blength(ptt->entry[i])+2)*sizeof(char));\n                    if (test->desc)\n                    {\n                        int ret = snprintf(test->desc, blength(ptt->entry[i])+1, \"%s\", bdataofs(ptt->entry[i], blength(bDESC)+1));\n                        if (ret > 0)\n                        {\n                            test->desc[ret] = '\\0';\n                        }\n                    }\n                }\n                else if (bstrncmp(ptt->entry[i], bTYPE, blength(bTYPE)) == BSTR_OK)\n                {\n                    bstring btype = bmidstr(ptt->entry[i], blength(bTYPE)+1, blength(ptt->entry[i])-blength(bTYPE));\n                    btrimws(btype);\n                    if (bstrncmp(btype, bTYPEDOUBLE, blength(bTYPEDOUBLE)) == BSTR_OK)\n                    {\n                        test->type = DOUBLE;\n                    }\n                    else if (bstrncmp(btype, bTYPESINGLE, blength(bTYPESINGLE)) == BSTR_OK)\n                    {\n                        test->type = SINGLE;\n                    }\n                    else if (bstrncmp(btype, bTYPEINT, blength(bTYPEINT)) == BSTR_OK)\n                    {\n                        test->type = INT;\n                    }\n                    else\n                    {\n                        fprintf(stderr, \"Failed to determine type of benchmark\\n\");\n                        bdestroy(btype);\n                        bstrListDestroy(code);\n                        free(test);\n                        test = NULL;\n                        code = NULL;\n                        break;\n                    }\n                    bdestroy(btype);\n                }\n                else\n                {\n                    bstrListAdd(code, ptt->entry[i]);\n                }\n            }\n            *testcase = test;\n        }\n        bstrListDestroy(ptt);\n    }\n\n    bdestroy(bBYTES);\n    bdestroy(bFLOPS);\n    bdestroy(bSTREAMS);\n    bdestroy(bTYPE);\n    bdestroy(bTYPEDOUBLE);\n    bdestroy(bTYPESINGLE);\n    bdestroy(bTYPEINT);\n    bdestroy(bDESC);\n    bdestroy(bLOADS);\n    bdestroy(bSTORES);\n    bdestroy(bLOADSTORES);\n    bdestroy(bINSTCONST);\n    bdestroy(bINSTLOOP);\n    bdestroy(bUOPS);\n    bdestroy(bBRANCHES);\n    bdestroy(bLOOP);\n    return code;\n}\n\nstatic int set_testname(char *pttfile, TestCase* testcase)\n{\n    if ((!testcase)||(!pttfile))\n    {\n        return -EINVAL;\n    }\n    bstring ptt = bfromcstr(basename(pttfile));\n    int dot = bstrrchrp(ptt, '.', blength(ptt)-1);\n    btrunc(ptt, dot);\n    testcase->name = malloc((blength(ptt)+2) * sizeof(char));\n    int ret = snprintf(testcase->name, blength(ptt)+1, \"%s\", bdata(ptt));\n    if (ret > 0)\n    {\n        testcase->name[ret] = '\\0';\n    }\n    bdestroy(ptt);\n    return 0;\n}\n\n\nstatic struct bstrList* parse_asm(TestCase* testcase, struct bstrList* input)\n{\n    struct bstrList* output = NULL;\n    if (testcase && input)\n    {\n\n        struct bstrList* pre = bstrListCreate();\n        struct bstrList* loop = bstrListCreate();\n        int got_loop = 0;\n        bstring bLOOP = bformat(\"LOOP\");\n        int step = testcase->stride;\n\n        for (int i = 0; i < input->qty; i++)\n        {\n            if (bstrncmp(input->entry[i], bLOOP, blength(bLOOP)) == BSTR_OK)\n            {\n                got_loop = 1;\n                continue;\n            }\n            if (!got_loop)\n            {\n                bstrListAdd(pre, input->entry[i]);\n            }\n            else\n            {\n                bstrListAdd(loop, input->entry[i]);\n            }\n        }\n        bdestroy(bLOOP);\n\n        output = bstrListCreate();\n\n        header(output, testcase->name);\n\n        for (int i = 0; i < pre->qty; i++)\n        {\n            bstrListAdd(output, pre->entry[i]);\n        }\n        loopheader(output, \"1\", step);\n        for (int i = 0; i < loop->qty; i++)\n        {\n            bstrListAdd(output, loop->entry[i]);\n        }\n        loopfooter(output, \"1\", step);\n\n        footer(output, testcase->name);\n\n        bstrListDestroy(pre);\n        bstrListDestroy(loop);\n    }\n    return output;\n}\n\nstatic int searchreplace(bstring line, RegisterMap* map)\n{\n    int maxlen = registerMapMaxPattern(map);\n    int size = registerMapLength(map);\n    for (int s = maxlen; s>= 1; s--)\n    {\n        int c = 0;\n        for (int j = 0; j < size; j++)\n        {\n            if (strlen(map[j].pattern) == s)\n            {\n                bstring pat = bfromcstr(map[j].pattern);\n                bstring reg = bfromcstr(map[j].reg);\n                bfindreplace(line, pat, reg, 0);\n                bdestroy(pat);\n                bdestroy(reg);\n                c++;\n            }\n        }\n        if (c == 0)\n        {\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic int prepare_code(struct bstrList* code)\n{\n    if (code)\n    {\n        for (int i = 0; i < code->qty; i++)\n        {\n            searchreplace(code->entry[i], StreamPatterns);\n        }\n        for (int i = 0; i < code->qty; i++)\n        {\n            searchreplace(code->entry[i], Registers);\n        }\n        for (int i = 0; i < code->qty; i++)\n        {\n            searchreplace(code->entry[i], Arguments);\n        }\n        for (int i = 0; i < code->qty; i++)\n        {\n            bstring pat = bfromcstr(Sptr.pattern);\n            bstring reg = bfromcstr(Sptr.reg);\n            bfindreplace(code->entry[i], pat, reg, 0);\n            bdestroy(pat);\n            bdestroy(reg);\n        }\n        for (int i = 0; i < code->qty; i++)\n        {\n            bstring pat = bfromcstr(Bptr.pattern);\n            bstring reg = bfromcstr(Bptr.reg);\n            bfindreplace(code->entry[i], pat, reg, 0);\n            bdestroy(pat);\n            bdestroy(reg);\n        }\n    }\n    return 0;\n}\n\n\nstruct bstrList* dynbench_getall()\n{\n    int totalgroups = 0;\n    struct bstrList* list = NULL;\n    DIR *dp = NULL;\n    struct dirent *ep = NULL;\n    DIR * (*ownopendir)(const char* folder) = &opendir;\n    int (*ownaccess)(const char*, int) = &access;\n\n    bstring path = bformat(\"%s/.likwid/bench/%s\", getenv(\"HOME\"), ARCHNAME);\n\n    if (!ownaccess(bdata(path), R_OK|X_OK))\n    {\n        dp = ownopendir(bdata(path));\n        if (dp != NULL)\n        {\n            while ((ep = readdir(dp)))\n            {\n                if (strncmp(&(ep->d_name[strlen(ep->d_name)-4]), \".ptt\", 4) == 0)\n                {\n                    if (!list) list = bstrListCreate();\n                    totalgroups++;\n                    bstring dname = bfromcstr(ep->d_name);\n                    btrunc(dname, blength(dname)-4);\n                    bstrListAdd(list, dname);\n                    bdestroy(dname);\n                }\n            }\n            closedir(dp);\n        }\n        else\n        {\n            fprintf(stderr, \"Failed to enter folder %s\\n\", bdata(path));\n        }\n    }\n    bdestroy(path);\n    return list;\n}\n\n\nstatic bstring get_compiler(bstring candidates)\n{\n    bstring compiler = NULL;\n    bstring path = bfromcstr(getenv(\"PATH\"));\n    struct bstrList *plist = NULL;\n    struct bstrList *clist = NULL;\n    int (*ownaccess)(const char*, int) = access;\n\n    plist = bsplit(path, ':');\n    clist = bsplit(candidates, ',');\n\n    for (int i = 0; i < plist->qty && (!compiler); i++)\n    {\n        for (int j = 0; j < clist->qty && (!compiler); j++)\n        {\n            bstring tmp = bformat(\"%s/%s\", bdata(plist->entry[i]), bdata(clist->entry[j]));\n            if (!ownaccess(bdata(tmp), R_OK|X_OK))\n            {\n                compiler = bstrcpy(tmp);\n            }\n            bdestroy(tmp);\n        }\n    }\n    bdestroy(path);\n    bstrListDestroy(plist);\n    bstrListDestroy(clist);\n    return compiler;\n}\n\nstatic int compile_file(bstring compiler, bstring flags, bstring asmfile, bstring objfile)\n{\n    if (blength(compiler) == 0 || blength(asmfile) == 0)\n        return -1;\n    char buf[1024];\n    bstring bstdout = bfromcstr(\"\");\n\n\n    bstring cmd = bformat(\"%s %s %s -o %s\", bdata(compiler), bdata(flags), bdata(asmfile), bdata(objfile));\n\n    FILE * fp = popen(bdata(cmd), \"r\");\n    if (fp)\n    {\n        for (;;) {\n            /* Read another chunk */\n            int ret = fread(buf, 1, sizeof(buf), fp);\n            if (ret < 0) {\n                fprintf(stderr, \"fread(%p, 1, %lu, %p): %d, errno=%d\\n\", buf, sizeof(buf), fp, ret, errno);\n                bdestroy(cmd);\n                bdestroy(bstdout);\n                return -1;\n            }\n            else if (ret == 0) {\n                break;\n            }\n            bcatblk(bstdout, buf, ret);\n        }\n        if (blength(bstdout) > 0)\n        {\n            fprintf(stderr, \"%s\\n\", bdata(bstdout));\n        }\n        pclose(fp);\n    }\n    bdestroy(cmd);\n    bdestroy(bstdout);\n\n    return 0;\n}\n\n\nstatic int open_function(bstring location, TestCase *testcase)\n{\n    void* handle;\n    char *error;\n    void* (*owndlsym)(void*, const char*) = dlsym;\n\n    dlerror();\n    testcase->dlhandle = dlopen(bdata(location), RTLD_LAZY);\n    if (!testcase->dlhandle) {\n        fprintf(stderr, \"Error opening location %s: %s\\n\", bdata(location), dlerror());\n        return -1;\n    }\n    dlerror();\n    testcase->kernel = owndlsym(testcase->dlhandle, testcase->name);\n    if ((error = dlerror()) != NULL)  {\n        dlclose(testcase->dlhandle);\n        fprintf(stderr, \"Error opening function %s: %s\\n\", testcase->name, error);\n        return -1;\n    }\n    dlerror();\n\n    return 0;\n}\n\n\nint dynbench_test(bstring testname)\n{\n    int exist = 0;\n    char* home = getenv(\"HOME\");\n    if (!home)\n    {\n        fprintf(stderr, \"Failed to get $HOME from environment\\n\");\n        return exist;\n    }\n    bstring path = bformat(\"%s/.likwid/bench/%s/%s.ptt\", home, ARCHNAME, bdata(testname));\n    if (!access(bdata(path), R_OK))\n    {\n        exist = 1;\n    }\n    bdestroy(path);\n    return exist;\n}\n\nint dynbench_load(bstring testname, TestCase **testcase, char* tmpfolder, char *compilers, char* compileflags)\n{\n    int err = -1;\n    TestCase *test = NULL;\n    char* home = getenv(\"HOME\");\n    if (!home)\n    {\n        fprintf(stderr, \"Failed to get $HOME from environment\\n\");\n        return err;\n    }\n    bstring pttfile = bformat(\"%s/.likwid/bench/%s/%s.ptt\", home, ARCHNAME, bdata(testname));\n    if (!access(bdata(pttfile), R_OK))\n    {\n        struct bstrList* code = analyse_ptt(pttfile, &test);\n        if (code && test)\n        {\n            test->dlhandle = NULL;\n            test->kernel = NULL;\n            test->name = malloc((blength(testname)+2) * sizeof(char));\n            if (test->name)\n            {\n                int ret = snprintf(test->name, blength(testname)+1, \"%s\", bdata(testname));\n                if (ret > 0)\n                {\n                    test->name[ret] = '\\0';\n                }\n                if (tmpfolder && compilers)\n                {\n                    pid_t pid = getpid();\n                    bstring buildfolder = bformat(\"%s/%ld\", tmpfolder, pid);\n                    if (mkdir(bdata(buildfolder), 0700) == 0)\n                    {\n                        int asm_written = 0;\n                        bstring asmfile = bformat(\"%s/%ld/%s.S\", tmpfolder , pid, bdata(testname));\n\n                        struct bstrList* asmb = parse_asm(test, code);\n                        if (asmb)\n                        {\n                            prepare_code(asmb);\n                            if (write_asm(asmfile, asmb) != 0)\n                            {\n                                fprintf(stderr, \"Failed to write assembly to file %s\\n\", bdata(asmfile));\n                            }\n                            else\n                            {\n                                asm_written = 1;\n                            }\n                            bstrListDestroy(asmb);\n                        }\n                        else\n                        {\n                            fprintf(stderr, \"Cannot parse assembly\\n\");\n                        }\n\n                        bstring candidates = bfromcstr(compilers);\n                        bstring compiler = get_compiler(candidates);\n                        if (asm_written && compiler)\n                        {\n                            int cret = 0;\n                            bstring cflags;\n                            if (compileflags)\n                            {\n                                cflags = bfromcstr(compileflags);\n                            }\n                            else\n                            {\n                                cflags = bfromcstr(\"\");\n                            }\n                            bstring objfile = bformat(\"%s/%ld/%s.o\", tmpfolder , pid, bdata(testname));\n                            cret = compile_file(compiler, cflags, asmfile, objfile);\n                            if (cret == 0)\n                            {\n                                cret = open_function(objfile, test);\n                                if (cret == 0)\n                                {\n                                    err = 0;\n                                    *testcase = test;\n                                }\n                                else\n                                {\n                                    fprintf(stderr, \"Cannot load function %s from %s\\n\", bdata(testname), bdata(objfile));\n                                }\n                            }\n                            else\n                            {\n                                fprintf(stderr, \"Cannot compile file %s to %s\\n\", bdata(asmfile), bdata(objfile));\n                            }\n                            bdestroy(cflags);\n                            bdestroy(objfile);\n                        }\n                        else\n                        {\n                            fprintf(stderr, \"Cannot find any compiler %s\\n\", bdata(buildfolder));\n                        }\n                        bdestroy(candidates);\n                        bdestroy(compiler);\n                        bdestroy(asmfile);\n\n\n                    }\n                    else\n                    {\n                        fprintf(stderr, \"Cannot create temporary directory %s\\n\", bdata(buildfolder));\n                        err = errno;\n                    }\n                    bdestroy(buildfolder);\n                }\n                else\n                {\n                    err = 0;\n                    *testcase = test;\n                }\n            }\n            else\n            {\n                fprintf(stderr, \"Failed to allocate space for the testname\\n\");\n            }\n            bstrListDestroy(code);\n\n        }\n        else\n        {\n            fprintf(stderr, \"Cannot read ptt file %s\\n\", bdata(pttfile));\n        }\n\n    }\n    else\n    {\n        fprintf(stderr, \"Cannot open ptt file %s\\n\", bdata(pttfile));\n    }\n    bdestroy(pttfile);\n\n    return err;\n}\n\nint dynbench_close(TestCase* testcase, char* tmpfolder)\n{\n    if (testcase)\n    {\n        if (testcase->dlhandle)\n        {\n            dlclose(testcase->dlhandle);\n            testcase->dlhandle = NULL;\n            testcase->kernel = NULL;\n        }\n        if (tmpfolder)\n        {\n            pid_t pid = getpid();\n\n            bstring buildfolder = bformat(\"%s/%ld\", tmpfolder, pid);\n            bstring asmfile = bformat(\"%s/%s.S\", bdata(buildfolder), testcase->name);\n            bstring objfile = bformat(\"%s/%s.o\", bdata(buildfolder), testcase->name);\n\n            if (!access(bdata(asmfile), R_OK)) unlink(bdata(asmfile));\n            if (!access(bdata(objfile), R_OK)) unlink(bdata(objfile));\n            if (!access(bdata(buildfolder), R_OK)) rmdir(bdata(buildfolder));\n\n            bdestroy(asmfile);\n            bdestroy(objfile);\n            bdestroy(buildfolder);\n        }\n        free(testcase->name);\n        testcase->name = NULL;\n        free(testcase->desc);\n        testcase->desc = NULL;\n        free(testcase);\n        testcase = NULL;\n    }\n    return 0;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/doc/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/doc/likwid-logo-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-likwid-5.0.1-swzmmlsyxshomkuf3sytn5qudu6mazzg/spack-src/doc/likwid-logo.png"
    ],
    "total_files": 1403
}