{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-perfstubs-master-j4trizokldngjffj5xt7fwz4tmp7cvna/spack-src/perfstubs_api/README.md": "# Profiling Interface for ADIOS2\n\nCopyright (c) 2019-2020 University of Oregon\nDistributed under the BSD Software License\n(See accompanying file LICENSE.txt)\n\n_Note:_ This library was originally written as a stub library wrapper in ADIOS.\nThis is a generic design and implementation for other libraries and tools.\n\n## Todo Items\n- [x] Make the interface generic.\n    - [x] Replace ADIOST-specific symbols with generic versions that will be\n      implemented by interested measurement libraries (i.e. Score-P). \n    - ~~[ ] New environment variable specifying location of library containing\n      function implementations.~~\n    - [x] Remove dynamic-linking specific approach (checking ```LD_PRELOAD```)\n      If the symbol isn't loaded, don't search for it.  We have to support\n      static linking, too - and if we ```dlopen()``` a library with pthread in\n      it, the application will crash because of initialization of thread-local\n      static globals.\n\n- [x] Add a CMake option to disable the API entirely.\n\n- [x] Add CMake support for linking in measurement libraries when static\n  linking.\n\n- [x] Investigate API call to trigger writing of performance data to the ADIOS2\n  archive (performance data stored with the science data).\n\n## Overview\n\nThese files contain a thin stub interface for instrumenting library or\napplication code.  The interface can be compiled away entirely.  The function\ncalls are \"stubs\" in the form of function pointers, initialized to\n```nullptr```. The functions are optionally assigned at runtime using dlsym()\ncalls, as is typical with plugin implementations.  If static linking is used, a\n*weak symbol* technique is used instead.  If the function pointers have the\nvalue ```nullptr```, then this library is a few more instructions than a no-op.\nIf the function pointers are assigned, the measurement library functions are\ncalled to perform the timing measurement.  The symbols are made available to\nthe environment either through ```LD_PRELOAD``` settings or by linking in the\nmeasurement library.\n\nConvenience macros are provided for constructing descriptive timer names using\npre-processor definitions such as ```__FILE__```, ```__LINE__```, and\n```__func__```.  For C++ codes, there are also scoped timers to minimize\ninstrumentation text and ensure timers are stopped in functions with multiple\nreturn locations or exceptions that throw outside of scope.\n\n## Known Issues\n\nBecause the implementation uses ```libdl.so``` there will be linker warnings\nwhen linking static executables.  It is known that static executables that load\nshared-object measurement libraries with pthread support will crash, because of\na known issue with thread local storage at program startup.  However, both\ndynamic and static implementations and examples are provided.\n\n## How to instrument with the C API\n\nFor C code, you have the option of specifying the timer name or letting the API\ngenerate it based on source code location data.\n\n### Timers\n\nOption 1, explicit timer name:\n\n```C\n#include \"perfstubs_api/timer.h\"\n\nvoid function_to_time(void) {\n    PERFSTUBS_TIMER_START(\"interesting loop\");\n    ...\n    PERFSTUBS_TIMER_STOP(\"interesting loop\");\n}\n```\n\nOption 2, generated timer name:\n\n```C\n#include \"perfstubs_api/timer.h\"\n\nvoid function_to_time(void) {\n    /* Will generate something like:\n     * \"void function_to_time(void) [{filename.c} {123,0}]\"\n     */\n    PERFSTUBS_TIMER_START_FUNC();\n    ...\n    PERFSTUBS_TIMER_STOP_FUNC();\n}\n```\n\n### Counters\n\nThe interface can be used to capture interesting counter values, too:\n\n```C\nPERFSTUBS_SAMPLE_COUNTER(\"Bytes Written\", 1024);\n```\n\n### Metadata\n\nThe interface can be used to capture interesting metadata:\n\n```C\nPERFSTUBS_METADATA(\"ADIOS Method\", \"POSIX\");\n```\n\n## How to instrument with the C++ API\n\nThe C++ API adds additional scoped timers for convenience:\n\n```C++\n#include \"perfstubs_api/timer.h\"\n\nvoid function_to_time(void) {\n    /* Will generate something like:\n     * \"void function_to_time(void) [{filename.cpp} {123,0}]\"\n     */\n    PERFSTUBS_SCOPED_TIMER_FUNC();\n    ...\n}\n```\n\n```C++\ndo {\n    PERFSTUBS_SCOPED_TIMER(\"While Loop\");\n    ...\n} while (!done);\n```\n\n## How to use at runtime\n\nTo use the API with an application or library, the executable can be linked\ndynamically or statically.  Dynamic applications can be observed with an\nexternal tool such as TAU by using the ```tau_exec``` program wrapper:\n\n```bash\nmpirun -np 4 tau_exec -T mpi,papi,pthread ./executable\n```\n\nThe example above will use a TAU configuration with PAPI, MPI and Pthread\nsupport.\n\n## How to integrate into your project\n\n### Option 1: build/install perfstubs as a library\nJust like it sounds, you would build the library and link to it at link time.  This would be useful if multiple libraries in the executable are using instrumentation, so that there aren't multiple implementations (although that should work fine, there would just be code duplication).\n\n### Option 2: Add timer.c, tool.h and timer.h (and optionally timer_f.h for Fortran support) to your source code\nThis is probably the easiest solution.  Include header paths might have to be modified inside the source files if you don't want to have `perfstubs_api` in your include directory tree.  The line: `#include perfstubs_api/config.h` can be removed from `perfstubs_api/timer.h` unless you have a project need for it.\n",
        "/tmp/vanessa/spack-stage/spack-stage-perfstubs-master-j4trizokldngjffj5xt7fwz4tmp7cvna/spack-src/perfstubs_api/timer.c": "// Copyright (c) 2019-2020 University of Oregon\n// Distributed under the BSD Software License\n// (See accompanying file LICENSE.txt)\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE // needed to define RTLD_DEFAULT\n#endif\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <dlfcn.h>\n#include \"pthread.h\"\n#ifndef PERFSTUBS_USE_TIMERS\n#define PERFSTUBS_USE_TIMERS\n#endif\n#include \"perfstubs_api/timer.h\"\n\n#define MAX_TOOLS 1\n\n/* Make sure that the Timer singleton is constructed when the\n * library is loaded.  This will ensure (on linux, anyway) that\n * we can assert that we have m_Initialized on the main thread. */\n//static void __attribute__((constructor)) initialize_library(void);\n\n/* Globals for the plugin API */\n\nint perfstubs_initialized = PERFSTUBS_UNKNOWN;\nint num_tools_registered = 0;\n/* Keep track of whether the thread has been registered */\n/* __thread int thread_seen = 0; */\n/* Implemented with PGI-friendly implementation, they can't be bothered\n * to implement the thread_local standard like every other compiler... */\nstatic pthread_key_t key;\nstatic pthread_once_t key_once = PTHREAD_ONCE_INIT;\n\nstatic void make_key(void) {\n    (void) pthread_key_create(&key, NULL);\n}\n\n/* Function pointers */\n\nps_initialize_t initialize_functions[MAX_TOOLS];\nps_finalize_t finalize_functions[MAX_TOOLS];\nps_pause_measurement_t pause_measurement_functions[MAX_TOOLS];\nps_resume_measurement_t resume_measurement_functions[MAX_TOOLS];\nps_register_thread_t register_thread_functions[MAX_TOOLS];\nps_dump_data_t dump_data_functions[MAX_TOOLS];\nps_timer_create_t timer_create_functions[MAX_TOOLS];\nps_timer_start_t timer_start_functions[MAX_TOOLS];\nps_timer_stop_t timer_stop_functions[MAX_TOOLS];\nps_start_string_t start_string_functions[MAX_TOOLS];\nps_stop_string_t stop_string_functions[MAX_TOOLS];\nps_stop_current_t stop_current_functions[MAX_TOOLS];\nps_set_parameter_t set_parameter_functions[MAX_TOOLS];\nps_dynamic_phase_start_t dynamic_phase_start_functions[MAX_TOOLS];\nps_dynamic_phase_stop_t dynamic_phase_stop_functions[MAX_TOOLS];\nps_create_counter_t create_counter_functions[MAX_TOOLS];\nps_sample_counter_t sample_counter_functions[MAX_TOOLS];\nps_set_metadata_t set_metadata_functions[MAX_TOOLS];\nps_get_timer_data_t get_timer_data_functions[MAX_TOOLS];\nps_get_counter_data_t get_counter_data_functions[MAX_TOOLS];\nps_get_metadata_t get_metadata_functions[MAX_TOOLS];\nps_free_timer_data_t free_timer_data_functions[MAX_TOOLS];\nps_free_counter_data_t free_counter_data_functions[MAX_TOOLS];\nps_free_metadata_t free_metadata_functions[MAX_TOOLS];\n\n#ifdef PERFSTUBS_USE_STATIC\n\n#if defined(__clang__) && defined(__APPLE__)\n#define PS_WEAK_PRE\n#define PS_WEAK_POST __attribute__((weak_import))\n#define PS_WEAK_POST_NULL __attribute__((weak_import))\n#else\n#define PS_WEAK_PRE __attribute__((weak))\n#define PS_WEAK_POST\n#define PS_WEAK_POST_NULL\n#endif\n\nPS_WEAK_PRE void ps_tool_initialize(void) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_finalize(void) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_pause_measurement(void) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_resume_measurement(void) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_register_thread(void) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_dump_data(void) PS_WEAK_POST;\nPS_WEAK_PRE void* ps_tool_timer_create(const char *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_timer_start(void *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_timer_stop(void *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_start_string(const char *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_stop_string(const char *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_stop_current(void) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_set_parameter(const char *, int64_t) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_dynamic_phase_start(const char *, int) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_dynamic_phase_stop(const char *, int) PS_WEAK_POST;\nPS_WEAK_PRE void* ps_tool_create_counter(const char *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_sample_counter(void *, double) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_set_metadata(const char *, const char *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_get_timer_data(ps_tool_timer_data_t *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_get_counter_data(ps_tool_counter_data_t *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_get_metadata(ps_tool_metadata_t *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_free_timer_data(ps_tool_timer_data_t *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_free_counter_data(ps_tool_counter_data_t *) PS_WEAK_POST;\nPS_WEAK_PRE void ps_tool_free_metadata(ps_tool_metadata_t *) PS_WEAK_POST;\n#endif\n\nvoid initialize_library() {\n#ifdef PERFSTUBS_USE_STATIC\n    /* The initialization function is the only required one */\n    initialize_functions[0] = &ps_tool_initialize;\n    if (initialize_functions[0] == NULL) {\n        perfstubs_initialized = PERFSTUBS_FAILURE;\n        return;\n    }\n    printf(\"Found ps_tool_initialize(), registering tool\\n\");\n    finalize_functions[0] = &ps_tool_finalize;\n    pause_measurement_functions[0] = &ps_tool_pause_measurement;\n    resume_measurement_functions[0] = &ps_tool_resume_measurement;\n    register_thread_functions[0] = &ps_tool_register_thread;\n    dump_data_functions[0] = &ps_tool_dump_data;\n    timer_create_functions[0] = &ps_tool_timer_create;\n    timer_start_functions[0] = &ps_tool_timer_start;\n    timer_stop_functions[0] = &ps_tool_timer_stop;\n    start_string_functions[0] = &ps_tool_start_string;\n    stop_string_functions[0] = &ps_tool_stop_string;\n    stop_current_functions[0] = &ps_tool_stop_current;\n    set_parameter_functions[0] = &ps_tool_set_parameter;\n    dynamic_phase_start_functions[0] = &ps_tool_dynamic_phase_start;\n    dynamic_phase_stop_functions[0] = &ps_tool_dynamic_phase_stop;\n    create_counter_functions[0] = &ps_tool_create_counter;\n    sample_counter_functions[0] = &ps_tool_sample_counter;\n    set_metadata_functions[0] = &ps_tool_set_metadata;\n    get_timer_data_functions[0] = &ps_tool_get_timer_data;\n    get_counter_data_functions[0] = &ps_tool_get_counter_data;\n    get_metadata_functions[0] = &ps_tool_get_metadata;\n    free_timer_data_functions[0] = &ps_tool_free_timer_data;\n    free_counter_data_functions[0] = &ps_tool_free_counter_data;\n    free_metadata_functions[0] = &ps_tool_free_metadata;\n#else\n    initialize_functions[0] =\n        (ps_initialize_t)dlsym(RTLD_DEFAULT, \"ps_tool_initialize\");\n    if (initialize_functions[0] == NULL) {\n        perfstubs_initialized = PERFSTUBS_FAILURE;\n        return;\n    }\n    printf(\"Found ps_tool_initialize(), registering tool\\n\");\n    finalize_functions[0] =\n        (ps_finalize_t)dlsym(RTLD_DEFAULT, \"ps_tool_finalize\");\n    pause_measurement_functions[0] =\n        (ps_pause_measurement_t)dlsym(RTLD_DEFAULT, \"ps_tool_pause_measurement\");\n    resume_measurement_functions[0] =\n        (ps_resume_measurement_t)dlsym(RTLD_DEFAULT, \"ps_tool_resume_measurement\");\n    register_thread_functions[0] =\n        (ps_register_thread_t)dlsym(RTLD_DEFAULT, \"ps_tool_register_thread\");\n    dump_data_functions[0] =\n        (ps_dump_data_t)dlsym(RTLD_DEFAULT, \"ps_tool_dump_data\");\n    timer_create_functions[0] =\n        (ps_timer_create_t)dlsym(RTLD_DEFAULT,\n        \"ps_tool_timer_create\");\n    timer_start_functions[0] =\n        (ps_timer_start_t)dlsym(RTLD_DEFAULT, \"ps_tool_timer_start\");\n    timer_stop_functions[0] =\n        (ps_timer_stop_t)dlsym(RTLD_DEFAULT, \"ps_tool_timer_stop\");\n    start_string_functions[0] =\n        (ps_start_string_t)dlsym(RTLD_DEFAULT, \"ps_tool_start_string\");\n    stop_string_functions[0] =\n        (ps_stop_string_t)dlsym(RTLD_DEFAULT, \"ps_tool_stop_string\");\n    stop_current_functions[0] =\n        (ps_stop_current_t)dlsym(RTLD_DEFAULT, \"ps_tool_stop_current\");\n    set_parameter_functions[0] =\n        (ps_set_parameter_t)dlsym(RTLD_DEFAULT, \"ps_tool_set_parameter\");\n    dynamic_phase_start_functions[0] = (ps_dynamic_phase_start_t)dlsym(\n        RTLD_DEFAULT, \"ps_tool_dynamic_phase_start\");\n    dynamic_phase_stop_functions[0] = (ps_dynamic_phase_stop_t)dlsym(\n        RTLD_DEFAULT, \"ps_tool_dynamic_phase_stop\");\n    create_counter_functions[0] = (ps_create_counter_t)dlsym(\n        RTLD_DEFAULT, \"ps_tool_create_counter\");\n    sample_counter_functions[0] = (ps_sample_counter_t)dlsym(\n        RTLD_DEFAULT, \"ps_tool_sample_counter\");\n    set_metadata_functions[0] =\n        (ps_set_metadata_t)dlsym(RTLD_DEFAULT, \"ps_tool_set_metadata\");\n    get_timer_data_functions[0] = (ps_get_timer_data_t)dlsym(\n        RTLD_DEFAULT, \"ps_tool_get_timer_data\");\n    get_counter_data_functions[0] = (ps_get_counter_data_t)dlsym(\n        RTLD_DEFAULT, \"ps_tool_get_counter_data\");\n    get_metadata_functions[0] = (ps_get_metadata_t)dlsym(\n        RTLD_DEFAULT, \"ps_tool_get_metadata\");\n    free_timer_data_functions[0] = (ps_free_timer_data_t)dlsym(\n        RTLD_DEFAULT, \"ps_tool_free_timer_data\");\n    free_counter_data_functions[0] = (ps_free_counter_data_t)dlsym(\n        RTLD_DEFAULT, \"ps_tool_free_counter_data\");\n    free_metadata_functions[0] = (ps_free_metadata_t)dlsym(\n        RTLD_DEFAULT, \"ps_tool_free_metadata\");\n#endif\n    perfstubs_initialized = PERFSTUBS_SUCCESS;\n    /* Increment the number of tools */\n    num_tools_registered = 1;\n}\n\nchar * ps_make_timer_name_(const char * file,\n    const char * func, int line) {\n    /* The length of the line number as a string is floor(log10(abs(num))) */\n    int string_length = (strlen(file) + strlen(func) + floor(log10(abs(line))) + 12);\n    char * name = calloc(string_length, sizeof(char));\n    sprintf(name, \"%s [{%s} {%d,0}]\", func, file, line);\n    return (name);\n}\n\n// used internally to the class\nstatic inline void ps_register_thread_internal(void) {\n    //if (thread_seen == 0) {\n    if (pthread_getspecific(key) == NULL) {\n    \tint i;\n    \tfor (i = 0 ; i < num_tools_registered ; i++) {\n        \tregister_thread_functions[i]();\n    \t}\n    \t//thread_seen = 1;\n    \tpthread_setspecific(key, (void*)1UL);\n    }\n}\n\n/* Initialization */\nvoid ps_initialize_(void) {\n    int i;\n    /* Only do this once */\n    if (perfstubs_initialized != PERFSTUBS_UNKNOWN) {\n        return;\n    }\n    initialize_library();\n    for (i = 0 ; i < num_tools_registered ; i++) {\n        initialize_functions[i]();\n    }\n    /* No need to register the main thread */\n    //thread_seen = 1;\n    (void) pthread_once(&key_once, make_key);\n    if (pthread_getspecific(key) == NULL) {\n        // set the key to 1, indicating we have seen this thread\n        pthread_setspecific(key, (void*)1UL);\n    }\n}\n\nvoid ps_finalize_(void) {\n    int i;\n    for (i = 0 ; i < num_tools_registered ; i++) {\n        if (finalize_functions[i] != NULL)\n            finalize_functions[i]();\n    }\n}\n\nvoid ps_pause_measurement_(void) {\n    int i;\n    for (i = 0 ; i < num_tools_registered ; i++) {\n        if (pause_measurement_functions[i] != NULL)\n            pause_measurement_functions[i]();\n    }\n}\n\nvoid ps_resume_measurement_(void) {\n    int i;\n    for (i = 0 ; i < num_tools_registered ; i++) {\n        if (resume_measurement_functions[i] != NULL)\n            resume_measurement_functions[i]();\n    }\n}\n\nvoid ps_register_thread_(void) {\n    ps_register_thread_internal();\n}\n\nvoid* ps_timer_create_(const char *timer_name) {\n\tps_register_thread_internal();\n    void ** objects = (void **)calloc(num_tools_registered, sizeof(void*));\n    int i;\n    for (i = 0 ; i < num_tools_registered ; i++) {\n        if (timer_create_functions[i] != NULL)\n            objects[i] = (void *)timer_create_functions[i](timer_name);\n    }\n    return (void*)(objects);\n}\n\nvoid ps_timer_create_fortran_(void ** object, const char *timer_name) {\n    *object = ps_timer_create_(timer_name);\n}\n\nvoid ps_timer_start_(void *timer) {\n\tps_register_thread_internal();\n    void ** objects = (void **)timer;\n    int i;\n    for (i = 0; i < num_tools_registered ; i++) {\n        if (timer_start_functions[i] != NULL &&\n            objects[i] != NULL)\n            timer_start_functions[i](objects[i]);\n    }\n}\n\nvoid ps_timer_start_fortran_(void **timer) {\n    ps_timer_start_(*timer);\n}\n\nvoid ps_timer_stop_(void *timer) {\n    void ** objects = (void **)timer;\n    int i;\n    for (i = 0; i < num_tools_registered ; i++) {\n        if (timer_stop_functions[i] != NULL &&\n            objects[i] != NULL)\n            timer_stop_functions[i](objects[i]);\n    }\n}\n\nvoid ps_timer_stop_fortran_(void **timer) {\n    ps_timer_stop_(*timer);\n}\n\nvoid ps_start_string_(const char *timer_name) {\n\tps_register_thread_internal();\n    int i;\n    for (i = 0 ; i < num_tools_registered ; i++) {\n        if (start_string_functions[i] != NULL)\n            start_string_functions[i](timer_name);\n    }\n}\n\nvoid ps_stop_string_(const char *timer_name) {\n    int i;\n    for (i = 0 ; i < num_tools_registered ; i++) {\n        if (stop_string_functions[i] != NULL)\n            stop_string_functions[i](timer_name);\n    }\n}\n\nvoid ps_stop_current_(void) {\n    int i;\n    for (i = 0 ; i < num_tools_registered ; i++) {\n        if (stop_current_functions[i] != NULL)\n            stop_current_functions[i]();\n    }\n}\n\nvoid ps_set_parameter_(const char * parameter_name, int64_t parameter_value) {\n    int i;\n    for (i = 0; i < num_tools_registered ; i++) {\n        if (set_parameter_functions[i] != NULL)\n            set_parameter_functions[i](parameter_name, parameter_value);\n    }\n}\n\nvoid ps_dynamic_phase_start_(const char *phase_prefix, int iteration_index) {\n    int i;\n    for (i = 0; i < num_tools_registered ; i++) {\n        if (dynamic_phase_start_functions[i] != NULL)\n            dynamic_phase_start_functions[i](phase_prefix, iteration_index);\n    }\n}\n\nvoid ps_dynamic_phase_stop_(const char *phase_prefix, int iteration_index) {\n    int i;\n    for (i = 0; i < num_tools_registered ; i++) {\n        if (dynamic_phase_stop_functions[i] != NULL)\n            dynamic_phase_stop_functions[i](phase_prefix, iteration_index);\n    }\n}\n\nvoid* ps_create_counter_(const char *name) {\n\tps_register_thread_internal();\n    void ** objects = (void **)calloc(num_tools_registered, sizeof(void*));\n    int i;\n    for (i = 0 ; i < num_tools_registered ; i++) {\n        if (create_counter_functions[i] != NULL)\n            objects[i] = (void*)create_counter_functions[i](name);\n    }\n    return (void*)(objects);\n}\n\nvoid ps_create_counter_fortran_(void ** object, const char *name) {\n    *object = ps_create_counter_(name);\n}\n\nvoid ps_sample_counter_(void *counter, const double value) {\n    void ** objects = (void **)counter;\n    int i;\n    for (i = 0; i < num_tools_registered ; i++) {\n        if (sample_counter_functions[i] != NULL &&\n            objects[i] != NULL)\n            sample_counter_functions[i](objects[i], value);\n    }\n}\n\nvoid ps_sample_counter_fortran_(void **counter, const double value) {\n    ps_sample_counter_(*counter, value);\n}\n\nvoid ps_set_metadata_(const char *name, const char *value) {\n\tps_register_thread_internal();\n    int i;\n    for (i = 0; i < num_tools_registered ; i++) {\n        if (set_metadata_functions[i] != NULL)\n            set_metadata_functions[i](name, value);\n    }\n}\n\nvoid ps_dump_data_(void) {\n    int i;\n    for (i = 0; i < num_tools_registered ; i++) {\n        if (dump_data_functions[i] != NULL)\n            dump_data_functions[i]();\n    }\n}\n\nvoid ps_get_timer_data_(ps_tool_timer_data_t *timer_data, int tool_id) {\n    if (tool_id < num_tools_registered) {\n        if (get_timer_data_functions[tool_id] != NULL)\n            get_timer_data_functions[tool_id](timer_data);\n    }\n}\n\nvoid ps_get_counter_data_(ps_tool_counter_data_t *counter_data, int tool_id) {\n    if (tool_id < num_tools_registered) {\n        if (get_counter_data_functions[tool_id] != NULL)\n            get_counter_data_functions[tool_id](counter_data);\n    }\n}\n\nvoid ps_get_metadata_(ps_tool_metadata_t *metadata, int tool_id) {\n    if (tool_id < num_tools_registered) {\n        if (get_metadata_functions[tool_id] != NULL)\n            get_metadata_functions[tool_id](metadata);\n    }\n}\n\nvoid ps_free_timer_data_(ps_tool_timer_data_t *timer_data, int tool_id) {\n    if (tool_id < num_tools_registered) {\n        if (free_timer_data_functions[tool_id] != NULL)\n            free_timer_data_functions[tool_id](timer_data);\n    }\n}\n\nvoid ps_free_counter_data_(ps_tool_counter_data_t *counter_data, int tool_id) {\n    if (tool_id < num_tools_registered) {\n        if (free_counter_data_functions[tool_id] != NULL)\n            free_counter_data_functions[tool_id](counter_data);\n    }\n}\n\nvoid ps_free_metadata_(ps_tool_metadata_t *metadata, int tool_id) {\n    if (tool_id < num_tools_registered) {\n        if (free_metadata_functions[tool_id] != NULL)\n            free_metadata_functions[tool_id](metadata);\n    }\n}\n\n"
    },
    "skipped": [],
    "total_files": 48
}