{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-parsec-master-4n2wechuwbfvaz3xskandlsgbx5zt7bu/spack-src/parsec/mca/device/device.c": "/*\n *\n * Copyright (c) 2013-2020 The University of Tennessee and The University\n *                         of Tennessee Research Foundation.  All rights\n *                         reserved.\n */\n\n#include \"parsec/parsec_config.h\"\n#include \"parsec/mca/device/device.h\"\n#include \"parsec/utils/mca_param.h\"\n#include \"parsec/mca/mca_repository.h\"\n#include \"parsec/constants.h\"\n#include \"parsec/utils/debug.h\"\n#include \"parsec/execution_stream.h\"\n#include \"parsec/utils/argv.h\"\n#include \"parsec/parsec_internal.h\"\n\n#include <stdlib.h>\n#if defined(PARSEC_HAVE_ERRNO_H)\n#include <errno.h>\n#endif  /* PARSEC_HAVE_ERRNO_H */\n#if defined(PARSEC_HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif  /* PARSEC_HAVE_DLFCN_H */\n#include <sys/stat.h>\n#if defined(PARSEC_HAVE_STRING_H)\n#include <string.h>\n#endif  /* defined(PARSEC_HAVE_STRING_H) */\n#if defined(__WINDOWS__)\n#include <windows.h>\n#endif  /* defined(__WINDOWS__) */\nint parsec_device_output = 0;\nstatic int parsec_device_verbose = 0;\nuint32_t parsec_nb_devices = 0;\nstatic uint32_t parsec_nb_max_devices = 0;\nstatic uint32_t parsec_mca_device_are_freezed = 0;\nparsec_atomic_lock_t parsec_devices_mutex = PARSEC_ATOMIC_UNLOCKED;\nstatic parsec_device_module_t** parsec_devices = NULL;\n\nstatic parsec_device_module_t* parsec_device_cpus = NULL;\nstatic parsec_device_module_t* parsec_device_recursive = NULL;\n\nstatic int num_modules_activated = 0;\nstatic parsec_device_module_t **modules_activated = NULL;\n\nstatic mca_base_component_t **device_components = NULL;\n\n/**\n * Temporary solution: Use the following two arrays to taskpool the weight and\n * the load on different devices. These arrays are not available before the\n * call to parsec_mca_device_registration_complete(). This is just a first step,\n * a smarter approach should take this spot.\n */\nfloat *parsec_device_load = NULL;\nfloat *parsec_device_hweight = NULL;\nfloat *parsec_device_sweight = NULL;\nfloat *parsec_device_dweight = NULL;\nfloat *parsec_device_tweight = NULL;\n\nPARSEC_OBJ_CLASS_INSTANCE(parsec_device_module_t, parsec_object_t,\n                          NULL, NULL);\n\nint parsec_mca_device_init(void)\n{\n    char** parsec_device_list = NULL;\n    parsec_device_module_t **modules = NULL;\n#if defined(PARSEC_PROF_TRACE)\n    char modules_activated_str[1024] = \"\";\n#endif  /* defined(PARSEC_PROF_TRACE) */\n    int i, j, rc, priority;\n\n    PARSEC_OBJ_CONSTRUCT(&parsec_per_device_infos, parsec_info_t);\n    PARSEC_OBJ_CONSTRUCT(&parsec_per_stream_infos, parsec_info_t);\n\n    (void)parsec_mca_param_reg_int_name(\"device\", \"show_capabilities\",\n                                        \"Show the detailed devices capabilities\",\n                                        false, false, parsec_debug_verbose >= 4 || (parsec_debug_verbose >= 3 && parsec_debug_rank == 0), NULL);\n    (void)parsec_mca_param_reg_int_name(\"device\", \"show_statistics\",\n                                        \"Show the detailed devices statistics upon exit\",\n                                        false, false, 0, NULL);\n    if( 0 < (rc = parsec_mca_param_find(\"device\", NULL, \"verbose\")) ) {\n        parsec_mca_param_lookup_int(rc, &parsec_device_verbose);\n    }\n    if( 0 < parsec_device_verbose ) {\n        parsec_device_output = parsec_output_open(NULL);\n        parsec_output_set_verbosity(parsec_device_output, parsec_device_verbose);\n    }\n    parsec_device_list = mca_components_get_user_selection(\"device\");\n\n    device_components = mca_components_open_bytype(\"device\");\n    for(i = 0; NULL != device_components[i]; i++); /* nothing just counting */\n    if( 0 == i ) {  /* no devices */\n        parsec_debug_verbose(10, parsec_debug_output, \"No devices found on %s\\n\", parsec_hostname);\n        return PARSEC_ERR_NOT_FOUND;\n    }\n    modules_activated = (parsec_device_module_t**)malloc(sizeof(parsec_device_module_t*) * i);\n    modules_activated[0] = NULL;\n\n    for(i = j = 0; NULL != device_components[i]; i++) {\n        if( mca_components_belongs_to_user_list(parsec_device_list, device_components[i]->mca_component_name) ) {\n            if (device_components[i]->mca_query_component != NULL) {\n                rc = device_components[i]->mca_query_component((mca_base_module_t**)&modules, &priority);\n                if( MCA_SUCCESS != rc ) {\n                    parsec_debug_verbose(10, parsec_debug_output, \"query function for component %s return no module\",\n                                         device_components[i]->mca_component_name);\n                    device_components[i]->mca_close_component();\n                    device_components[i] = NULL;\n                    continue;\n                }\n                parsec_debug_verbose(10, parsec_debug_output, \"query function for component %s[%d] returns priority %d\",\n                                     device_components[i]->mca_component_name, i, priority);\n                if( (NULL == modules) || (NULL == modules[0]) ) {\n                    parsec_debug_verbose(10, parsec_debug_output, \"query function for component %s returns no modules. Remove.\",\n                                         device_components[i]->mca_component_name);\n                    device_components[i]->mca_close_component();\n                    device_components[i] = NULL;\n                    continue;\n                }\n                if( i != j ) {  /* compress the list of components */\n                    device_components[j] = device_components[i];\n                    device_components[i] = NULL;\n                    j++;\n                }\n                modules_activated[num_modules_activated++] = modules[0];\n\n#if defined(PARSEC_PROF_TRACE)\n                strncat(modules_activated_str, device_components[i]->mca_component_name, 1023);\n                strncat(modules_activated_str, \",\", 1023);\n#endif\n            }\n        }\n    }\n    mca_components_free_user_list(parsec_device_list);\n    parsec_debug_verbose(5, parsec_debug_output, \"Found %d components, activated %d\", i, num_modules_activated);\n\n#if defined(PARSEC_PROF_TRACE)\n    /* replace trailing comma with \\0 */\n    if ( strlen(modules_activated_str) > 1) {\n        if( modules_activated_str[ strlen(modules_activated_str) - 1 ] == ',' ) {\n            modules_activated_str[strlen(modules_activated_str) - 1] = '\\0';\n        }\n    }\n    parsec_profiling_add_information(\"DEVICE_MODULES\", modules_activated_str);\n#endif\n\n    return PARSEC_SUCCESS;\n}\n\nvoid parsec_compute_best_unit( uint64_t length, float* updated_value, char** best_unit )\n{\n    float measure = (float)length;\n\n    *best_unit = \"B\";\n    if( measure > 1024.0f ) { /* 1KB */\n        *best_unit = \"KB\";\n        measure = measure / 1024.0f;\n        if( measure > 1024.0f ) { /* 1MB */\n            *best_unit = \"MB\";\n            measure = measure / 1024.0f;\n            if( measure > 1024.0f ) {\n                *best_unit = \"GB\";\n                measure = measure / 1024.0f;\n            }\n        }\n    }\n    *updated_value = measure;\n    return;\n}\n\nvoid parsec_mca_device_dump_and_reset_statistics(parsec_context_t* parsec_context)\n{\n    int *device_counter, total = 0;\n    uint64_t total_data_in = 0,     total_data_out = 0;\n    uint64_t total_required_in = 0, total_required_out = 0;\n    uint64_t *transferred_in, *transferred_out;\n    uint64_t *required_in,    *required_out;\n    float gtotal = 0.0;\n    float best_data_in, best_data_out;\n    float best_required_in, best_required_out;\n    char *data_in_unit, *data_out_unit;\n    char *required_in_unit, *required_out_unit;\n    char percent1[64], percent2[64];\n    parsec_device_module_t *device;\n    uint32_t i;\n\n    /* GPU counter for GEMM / each */\n    device_counter  = (int*)     calloc(parsec_nb_devices, sizeof(int)     );\n    transferred_in  = (uint64_t*)calloc(parsec_nb_devices, sizeof(uint64_t));\n    transferred_out = (uint64_t*)calloc(parsec_nb_devices, sizeof(uint64_t));\n    required_in     = (uint64_t*)calloc(parsec_nb_devices, sizeof(uint64_t));\n    required_out    = (uint64_t*)calloc(parsec_nb_devices, sizeof(uint64_t));\n\n    /**\n     * Save the statistics locally.\n     */\n    for(i = 0; i < parsec_nb_devices; i++) {\n        if( NULL == (device = parsec_devices[i]) ) continue;\n        assert( i == device->device_index );\n        /* Save the statistics */\n        device_counter[device->device_index]  += device->executed_tasks;\n        transferred_in[device->device_index]  += device->transferred_data_in;\n        transferred_out[device->device_index] += device->transferred_data_out;\n        required_in[device->device_index]     += device->required_data_in;\n        required_out[device->device_index]    += device->required_data_out;\n        /* Update the context-level statistics */\n        total              += device->executed_tasks;\n        total_data_in      += device->transferred_data_in;\n        total_data_out     += device->transferred_data_out;\n        total_required_in  += device->required_data_in;\n        total_required_out += device->required_data_out;\n\n        device->executed_tasks       = 0;\n        device->transferred_data_in  = 0;\n        device->transferred_data_out = 0;\n        device->required_data_in     = 0;\n        device->required_data_out    = 0;\n    }\n\n    /* Print statistics */\n    if( 0 == total_data_in )  total_data_in  = 1;\n    if( 0 == total_data_out ) total_data_out = 1;\n    gtotal = (float)total;\n\n    printf(\"--------------------------------------------------------------------------------------------------\\n\");\n    printf(\"|         |                    |         Data In                |         Data Out               |\\n\");\n    printf(\"|Rank %3d |  # KERNEL |    %%   |  Required  |   Transfered(%%)   |  Required  |   Transfered(%%)   |\\n\",\n           (NULL == parsec_context ? -1 : parsec_context->my_rank));\n    printf(\"|---------|-----------|--------|------------|-------------------|------------|-------------------|\\n\");\n    for( i = 0; i < parsec_nb_devices; i++ ) {\n        if( NULL == (device = parsec_devices[i]) ) continue;\n\n        parsec_compute_best_unit( required_in[i],     &best_required_in,  &required_in_unit  );\n        parsec_compute_best_unit( required_out[i],    &best_required_out, &required_out_unit );\n        parsec_compute_best_unit( transferred_in[i],  &best_data_in,      &data_in_unit      );\n        parsec_compute_best_unit( transferred_out[i], &best_data_out,     &data_out_unit     );\n\n        printf(\"|  Dev %2d |%10d | %6.2f | %8.2f%2s | %8.2f%2s(%5.2f) | %8.2f%2s | %8.2f%2s(%5.2f) | %s\\n\",\n               device->device_index, device_counter[i], (device_counter[i]/gtotal)*100.00,\n               best_required_in,  required_in_unit,  best_data_in,  data_in_unit,\n               (((double)transferred_in[i])  / (double)required_in[i] ) * 100.0,\n               best_required_out, required_out_unit, best_data_out, data_out_unit,\n               (((double)transferred_out[i]) / (double)required_out[i]) * 100.0, device->name );\n    }\n\n    printf(\"|---------|-----------|--------|------------|-------------------|------------|-------------------|\\n\");\n\n    parsec_compute_best_unit( total_required_in,  &best_required_in,  &required_in_unit  );\n    parsec_compute_best_unit( total_required_out, &best_required_out, &required_out_unit );\n    parsec_compute_best_unit( total_data_in,      &best_data_in,      &data_in_unit      );\n    parsec_compute_best_unit( total_data_out,     &best_data_out,     &data_out_unit     );\n\n    if( 0 == total_required_in ) {\n        snprintf(percent1, 64, \"nan\");\n    } else {\n        snprintf(percent1, 64, \"%5.2f\",  ((double)total_data_in  / (double)total_required_in ) * 100.0);\n    }\n    if( 0 == total_required_out ) {\n        snprintf(percent2, 64, \"nan\");\n    } else {\n        snprintf(percent2, 64, \"%5.2f\", ((double)total_data_out / (double)total_required_out) * 100.0);\n    }\n    printf(\"|All Devs |%10d | %5.2f | %8.2f%2s | %8.2f%2s(%s) | %8.2f%2s | %8.2f%2s(%s) |\\n\",\n           total, (total/gtotal)*100.00,\n           best_required_in,  required_in_unit,  best_data_in,  data_in_unit,\n           percent1,\n           best_required_out, required_out_unit, best_data_out, data_out_unit,\n           percent2);\n    printf(\"-------------------------------------------------------------------------------------------------\\n\");\n\n    free(device_counter);\n    free(transferred_in);\n    free(transferred_out);\n    free(required_in);\n    free(required_out);\n}\n\nint parsec_mca_device_fini(void)\n{\n    int show_stats_index, show_stats = 0;\n\n    /* If no statistics are required */\n    show_stats_index = parsec_mca_param_find(\"device\", NULL, \"show_statistics\");\n    if( 0 < show_stats_index )\n        parsec_mca_param_lookup_int(show_stats_index, &show_stats);\n    if( show_stats ) {\n        parsec_mca_device_dump_and_reset_statistics(NULL);\n    }\n\n    /* Free the local memory */\n    if(NULL != parsec_device_load) free(parsec_device_load);\n    parsec_device_load = NULL;\n    if(NULL != parsec_device_hweight) free(parsec_device_hweight);\n    parsec_device_hweight = NULL;\n    if(NULL != parsec_device_sweight) free(parsec_device_sweight);\n    parsec_device_sweight = NULL;\n    if(NULL != parsec_device_dweight) free(parsec_device_dweight);\n    parsec_device_dweight = NULL;\n    if(NULL != parsec_device_tweight) free(parsec_device_tweight);\n    parsec_device_tweight = NULL;\n\n    parsec_device_module_t *module;\n    mca_base_component_t *component;\n    for(int i = 0; i < num_modules_activated; i++ ) {\n        module = modules_activated[i];\n        \n        component = (mca_base_component_t*)module->component;\n        component->mca_close_component();\n        modules_activated[i] = NULL;\n    }\n    num_modules_activated = 0;\n    free(modules_activated); modules_activated = NULL;\n\n    if( NULL != parsec_device_recursive ) {  /* Release recursive device */\n        parsec_mca_device_remove(parsec_device_recursive);\n        free(parsec_device_recursive); parsec_device_recursive = NULL;\n    }\n    if( NULL != parsec_device_cpus ) {  /* Release the main CPU device */\n        parsec_mca_device_remove(parsec_device_cpus);\n        free(parsec_device_cpus); parsec_device_cpus = NULL;\n    }\n\n    free(parsec_devices); parsec_devices = NULL;\n\n    if( 0 < parsec_device_verbose ) {\n        parsec_output_close(parsec_device_output);\n        parsec_device_output = parsec_debug_output;\n    }\n\n    PARSEC_OBJ_DESTRUCT(&parsec_per_device_infos);\n    PARSEC_OBJ_DESTRUCT(&parsec_per_stream_infos);\n\n    return PARSEC_SUCCESS;\n}\n\nvoid*\nparsec_device_find_function(const char* function_name,\n                            const char* libname,\n                            const char* paths[])\n{\n    char library_name[FILENAME_MAX];\n    const char **target;\n    void *fn = NULL;\n\n    for( target = paths; (NULL != target) && (NULL != *target); target++ ) {\n        struct stat status;\n        if( 0 != stat(*target, &status) ) {\n            parsec_debug_verbose(10, parsec_device_output,\n                                 \"Could not stat the %s path (%s)\", *target, strerror(errno));\n            continue;\n        }\n        if( S_ISDIR(status.st_mode) ) {\n            if( NULL == libname )\n                continue;\n            snprintf(library_name,  FILENAME_MAX, \"%s/%s\", *target, libname);\n        } else {\n            snprintf(library_name,  FILENAME_MAX, \"%s\", *target);\n        }\n#if defined(__WINDOWS__)\n        wchar_t wlibrary_name[FILENAME_MAX];\n        MultiByteToWideChar(CP_ACP, MB_COMPOSITE, library_name, strlen(library_name),\n                            wlibrary_name, FILENAME_MAX);\n        HMODULE dlh = LoadLibraryW(wlibrary_name);\n        if(NULL == dlh) {\n            parsec_debug_verbose(10, parsec_device_output,\n                                 \"Could not find %s dynamic library (%s)\", library_name, GetLastError());\n            continue;\n        }\n        fn = GetProcAddress(dlh, function_name);\n        FreeLibrary(dlh);\n#elif defined(PARSEC_HAVE_DLFCN_H)\n        void* dlh = dlopen(library_name, RTLD_NOW | RTLD_NODELETE );\n        if(NULL == dlh) {\n            parsec_debug_verbose(10, parsec_device_output,\n                                 \"Could not find %s dynamic library (%s)\", library_name, dlerror());\n            continue;\n        }\n        fn = dlsym(dlh, function_name);\n        dlclose(dlh);\n#else\n#error Lacking dynamic loading capabilities.\n#endif\n        if( NULL != fn ) {\n            parsec_debug_verbose(4, parsec_device_output,\n                                 \"Function %s found in shared library %s\",\n                                 function_name, library_name);\n            break;  /* we got one, stop here */\n        }\n    }\n    /* Couldn't load from named dynamic libs, try linked/static */\n    if(NULL == fn) {\n        parsec_output_verbose(10, parsec_device_output,\n                              \"No dynamic function %s found, trying from compile time linked in\\n\",\n                              function_name);\n#if defined(__WINDOWS__)\n        HMODULE dlh = GetModuleHandleA(NULL);\n        if(NULL != dlh) {\n            fn = GetProcAddress(dlh, function_name);\n            FreeLibrary(dlh);\n        }\n#elif defined(PARSEC_HAVE_DLFCN_H)\n        void* dlh = dlopen(NULL, RTLD_NOW | RTLD_NODELETE);\n        if(NULL != dlh) {\n            fn = dlsym(dlh, function_name);\n            dlclose(dlh);\n        }\n#else\n#error Lacking dynamic loading capabilities.\n#endif\n            if(NULL != fn) {\n                parsec_debug_verbose(4, parsec_device_output,\n                                     \"Function %s found in the application symbols\",\n                                     function_name);\n            }\n    }\n    if(NULL == fn) {\n        parsec_debug_verbose(10, parsec_device_output,\n                             \"No function %s found\", function_name);\n    }\n    return fn;\n}\n\nint parsec_mca_device_registration_complete(parsec_context_t* context)\n{\n    float total_hperf = 0.0, total_sperf = 0.0, total_dperf = 0.0, total_tperf = 0.0;\n    (void)context;\n\n    if(parsec_mca_device_are_freezed)\n        return -1;\n\n    if(NULL != parsec_device_load) free(parsec_device_load);\n    parsec_device_load = (float*)calloc(parsec_nb_devices, sizeof(float));\n    if(NULL != parsec_device_hweight) free(parsec_device_hweight);\n    parsec_device_hweight = (float*)calloc(parsec_nb_devices, sizeof(float));\n    if(NULL != parsec_device_sweight) free(parsec_device_sweight);\n    parsec_device_sweight = (float*)calloc(parsec_nb_devices, sizeof(float));\n    if(NULL != parsec_device_dweight) free(parsec_device_dweight);\n    parsec_device_dweight = (float*)calloc(parsec_nb_devices, sizeof(float));\n    if(NULL != parsec_device_tweight) free(parsec_device_tweight);\n    parsec_device_tweight = (float*)calloc(parsec_nb_devices, sizeof(float));\n    for( uint32_t i = 0; i < parsec_nb_devices; i++ ) {\n        parsec_device_module_t* device = parsec_devices[i];\n        if( NULL == device ) continue;\n        parsec_device_hweight[i] = device->device_hweight;\n        parsec_device_sweight[i] = device->device_sweight;\n        parsec_device_dweight[i] = device->device_dweight;\n        parsec_device_tweight[i] = device->device_tweight;\n        if( PARSEC_DEV_RECURSIVE == device->type ) continue;\n        total_hperf += device->device_hweight;\n        total_tperf += device->device_tweight;\n        total_sperf += device->device_sweight;\n        total_dperf += device->device_dweight;\n    }\n\n    /* Compute the weight of each device including the cores */\n    parsec_debug_verbose(6, parsec_device_output, \"Global Theoretical performance: double %2.4f single %2.4f tensor %2.4f half %2.4f\", total_dperf, total_sperf, total_tperf, total_hperf);\n    for( uint32_t i = 0; i < parsec_nb_devices; i++ ) {\n        parsec_debug_verbose(6, parsec_device_output, \"  Dev[%d]             ->flops double %2.4f single %2.4f tensor %2.4f half %2.4f\",\n                             i, parsec_device_dweight[i], parsec_device_sweight[i], parsec_device_tweight[i], parsec_device_hweight[i]);\n\n        parsec_device_hweight[i] = (total_hperf / parsec_device_hweight[i]);\n        parsec_device_tweight[i] = (total_tperf / parsec_device_tweight[i]);\n        parsec_device_sweight[i] = (total_sperf / parsec_device_sweight[i]);\n        parsec_device_dweight[i] = (total_dperf / parsec_device_dweight[i]);\n        /* after the weighting */\n        parsec_debug_verbose(6, parsec_device_output, \"  Dev[%d]             ->ratio double %2.4e single %2.4e tensor %2.4e half %2.4e\",\n                             i, parsec_device_dweight[i], parsec_device_sweight[i], parsec_device_tweight[i], parsec_device_hweight[i]);\n    }\n\n    parsec_mca_device_are_freezed = 1;\n    return 0;\n}\n\nint parsec_mca_device_registration_completed(parsec_context_t* context)\n{\n    (void)context;\n    return parsec_mca_device_are_freezed;\n}\n\n#if defined(__APPLE__)\n#include <sys/sysctl.h>\n#endif\n\nstatic int cpu_weights(parsec_device_module_t* device, int nstreams)\n{\n    /* This is default value when it cannot be computed */\n    /* Crude estimate that holds for Nehalem era Xeon processors */\n    float freq = 2.5f;\n    float fp_ipc = 8.f;\n    float dp_ipc = 4.f;\n    char cpu_model[256]=\"Unkown\";\n    char *cpu_flags = NULL;\n\n#if defined(__linux__)\n    FILE* procinfo = fopen(\"/proc/cpuinfo\", \"r\");\n    if( NULL == procinfo ) {\n        parsec_warning(\"CPU Features cannot be autodetected on this machine: %s\", strerror(errno));\n        goto notfound;\n    }\n    cpu_flags = calloc(4096, sizeof(char));\n    char str[4096];\n    while( NULL != fgets(str, 4096, procinfo) ) {\n        /* Intel/AMD */\n        sscanf(str, \"model name : %255[^\\n]%*c\", cpu_model);\n        if( 0 != sscanf(str, \"cpu MHz : %f\", &freq) )\n            freq *= 1e-3;\n        if( 0 != sscanf(str, \"flags : %4095[^\\n]%*c\", cpu_flags) )\n            break; /* done reading for an x86 type CPU */\n        /* IBM: Power */\n        sscanf(str, \"cpu : %255[^\\n]%*c\", cpu_model);\n        if( 0 != sscanf(str, \"clock : %fMHz\", &freq) ) {\n            freq *= 1e-3;\n            break; /* done reading for a Power type CPU */\n        }\n    }\n    fclose(procinfo);\n#elif defined(__APPLE__)\n    size_t len = sizeof(cpu_model);\n    int rc = sysctlbyname(\"machdep.cpu.brand_string\", cpu_model, &len, NULL, 0);\n    if( rc ) {\n        parsec_warning(\"CPU Features cannot be autodetected on this machine (Detected OSX): %s\", strerror(errno));\n        goto notfound;\n    }\n    len = 0;\n    rc = sysctlbyname(\"machdep.cpu.features\", NULL, &len, NULL, 0);\n    cpu_flags = malloc(len);\n    rc = sysctlbyname(\"machdep.cpu.features\", cpu_flags, &len, NULL, 0);\n    if( rc ) {\n        parsec_warning(\"CPU Features cannot be autodetected on this machine (Detected OSX): %s\", strerror(errno));\n        goto notfound;\n    }\n#else\n    goto notfound;\n#endif\n    /* prefer base frequency from model name when available (avoids power\n     * saving modes and dynamic frequency scaling issues) */\n    sscanf(cpu_model, \"%*[^@] @ %fGHz\", &freq);\n\n#if defined(PARSEC_HAVE_BUILTIN_CPU)\n    __builtin_cpu_init();\n#if defined(PARSEC_HAVE_BUILTIN_CPU512)\n    if(__builtin_cpu_supports(\"avx512f\")) {\n        fp_ipc = 64;\n        dp_ipc = 32;\n    } else\n#endif /* PARSEC_HAVE_BUILTIN_CPU512; */\n         if(__builtin_cpu_supports(\"avx2\")) {\n        fp_ipc = 32;\n        dp_ipc = 16;\n    }\n    else if(__builtin_cpu_supports(\"avx\")) {\n        fp_ipc = 16;\n        dp_ipc = 8;\n    }\n    else {\n        fp_ipc = 8;\n        dp_ipc = 4;\n    }\n#else\n    if( strstr(cpu_flags, \" avx512f\") ) {\n        fp_ipc = 64;\n        dp_ipc = 32;\n    }\n    else if( strstr(cpu_flags, \" avx2\") ) {\n        fp_ipc = 32;\n        dp_ipc = 16;\n    }\n    else if( strstr(cpu_flags, \" avx\") ) {\n        fp_ipc = 16;\n        dp_ipc = 8;\n    }\n    else {\n        fp_ipc = 8;\n        dp_ipc = 4;\n    }\n#endif\n    free(cpu_flags);\n\n    {\n      int show_caps = 0;\n      int show_caps_index = parsec_mca_param_find(\"device\", NULL, \"show_capabilities\");\n      if(0 < show_caps_index) {\n          parsec_mca_param_lookup_int(show_caps_index, &show_caps);\n      }\n      if( show_caps ) {\n          parsec_inform(\"CPU Device: %s\\n\"\n                        \"\\tParsec Streams     : %d\\n\"\n                        \"\\tclockRate (GHz)    : %2.2f\\n\"\n                        \"\\tpeak Gflops        : double %2.4f, single %2.4f\",\n                        cpu_model,\n                        nstreams,\n                        freq, nstreams*freq*dp_ipc, nstreams*freq*fp_ipc);\n       }\n    }\n notfound:\n\n    device->device_hweight = nstreams * fp_ipc * freq; /* No processor have half precision for now */\n    device->device_tweight = nstreams * fp_ipc * freq; /* No processor support tensor operations for now */\n    device->device_sweight = nstreams * fp_ipc * freq;\n    device->device_dweight = nstreams * dp_ipc * freq;\n\n    return PARSEC_SUCCESS;\n}\n\nstatic int\ndevice_taskpool_register_static(parsec_device_module_t* device, parsec_taskpool_t* tp)\n{\n    int32_t rc = PARSEC_ERR_NOT_FOUND;\n    uint32_t i, j;\n\n    /**\n     * Detect if a particular chore has a dynamic load dependency and if yes\n     * load the corresponding module and find the function.\n     */\n    assert(tp->devices_index_mask & (1 << device->device_index));\n\n    for( i = 0; i < tp->nb_task_classes; i++ ) {\n        const parsec_task_class_t* tc = tp->task_classes_array[i];\n        __parsec_chore_t* chores = (__parsec_chore_t*)tc->incarnations;\n        for( j = 0; NULL != chores[j].hook; j++ ) {\n            if( chores[j].type != device->type )\n                continue;\n            if(  NULL != chores[j].dyld_fn ) {\n                continue;  /* the function has been set for another device of the same type */\n            }\n            if ( NULL == chores[j].dyld ) {\n                assert( NULL == chores[j].dyld_fn );  /* No dynamic support required for this kernel */\n                rc = PARSEC_SUCCESS;\n            } else {\n                void* devf = parsec_device_find_function(chores[j].dyld, NULL, NULL);\n                if( NULL != devf ) {\n                    chores[j].dyld_fn = devf;\n                    rc = PARSEC_SUCCESS;\n                }\n            }\n        }\n    }\n    if( PARSEC_SUCCESS != rc ) {\n        tp->devices_index_mask &= ~(1 << device->device_index);  /* discard this type */\n        parsec_debug_verbose(10, parsec_device_output,\n                             \"Device %d (%s) disabled for taskpool %p\", device->device_index, device->name, tp);\n    }\n\n    return rc;\n}\n\nint parsec_mca_device_attach(parsec_context_t* context)\n{\n    parsec_device_base_component_t *component;\n    parsec_device_module_t *module;\n    int nb_total_comp_threads = 0, rc;\n\n    for(int p = 0; p < context->nb_vp; p++) {\n        nb_total_comp_threads += context->virtual_processes[p]->nb_cores;\n    }\n\n    /* By now let's add one device for the CPUs */\n    {\n        parsec_device_cpus = (parsec_device_module_t*)calloc(1, sizeof(parsec_device_module_t));\n        parsec_device_cpus->name = \"default\";\n        parsec_device_cpus->type = PARSEC_DEV_CPU;\n        cpu_weights(parsec_device_cpus, nb_total_comp_threads);\n        parsec_device_cpus->taskpool_register = device_taskpool_register_static;\n        parsec_mca_device_add(context, parsec_device_cpus);\n   }\n\n    /* By now let's add one device for the recursive kernels */\n    {\n        parsec_device_recursive = (parsec_device_module_t*)calloc(1, sizeof(parsec_device_module_t));\n        parsec_device_recursive->name = \"recursive\";\n        parsec_device_recursive->type = PARSEC_DEV_RECURSIVE;\n        parsec_device_recursive->device_hweight = parsec_device_cpus->device_hweight;\n        parsec_device_recursive->device_tweight = parsec_device_cpus->device_tweight;\n        parsec_device_recursive->device_sweight = parsec_device_cpus->device_sweight;\n        parsec_device_recursive->device_dweight = parsec_device_cpus->device_dweight;\n        parsec_device_recursive->taskpool_register = device_taskpool_register_static;\n        parsec_mca_device_add(context, parsec_device_recursive);\n    }\n\n    for( int i = 0; NULL != (component = (parsec_device_base_component_t*)device_components[i]); i++ ) {\n        for( int j = 0; NULL != (module = component->modules[j]); j++ ) {\n            if (NULL == module->attach) {\n                parsec_debug_verbose(10, parsec_debug_output, \"A device module MUST contain an attach function. Disqualifying %s:%s module\",\n                                     component->base_version.mca_component_name, module->name);\n                continue;\n            }\n            rc = module->attach(module, context);\n            if( 0 > rc ) {\n                parsec_debug_verbose(10, parsec_debug_output, \"Attach failed for device %s:%s on context %p.\",\n                                     component->base_version.mca_component_name, module->name, context);\n                continue;\n            }\n            parsec_debug_verbose(5, parsec_debug_output, \"Activated DEVICE module %s:%s on context %p.\",\n                                 component->base_version.mca_component_name, module->name, context);\n        }\n    }\n    return PARSEC_SUCCESS;\n}\n\nint parsec_mca_device_add(parsec_context_t* context, parsec_device_module_t* device)\n{\n    if( parsec_mca_device_are_freezed ) {\n        return PARSEC_ERROR;\n    }\n    if( NULL != device->context ) {\n        /* This device already belong to a PaRSEC context */\n        return PARSEC_ERR_BAD_PARAM;\n    }\n    parsec_atomic_lock(&parsec_devices_mutex);  /* CRITICAL SECTION: BEGIN */\n    if( (parsec_nb_devices+1) > parsec_nb_max_devices ) {\n        if( NULL == parsec_devices ) /* first time */\n            parsec_nb_max_devices = 4;\n        else\n            parsec_nb_max_devices *= 2; /* every other time */\n        parsec_devices = realloc(parsec_devices, parsec_nb_max_devices * sizeof(parsec_device_module_t*));\n    }\n    parsec_devices[parsec_nb_devices] = device;\n    device->device_index = parsec_nb_devices;\n    parsec_nb_devices++;\n    device->context = context;\n    parsec_atomic_unlock(&parsec_devices_mutex);  /* CRITICAL SECTION: END */\n    PARSEC_OBJ_CONSTRUCT(&device->infos, parsec_info_object_array_t);\n    parsec_info_object_array_init(&device->infos, &parsec_per_device_infos, device);\n    return device->device_index;\n}\n\nparsec_device_module_t* parsec_mca_device_get(uint32_t device_index)\n{\n    if( device_index >= parsec_nb_devices )\n        return NULL;\n    return parsec_devices[device_index];\n}\n\nint parsec_mca_device_remove(parsec_device_module_t* device)\n{\n    int rc = PARSEC_SUCCESS;\n\n    PARSEC_OBJ_DESTRUCT(&device->infos);\n    parsec_atomic_lock(&parsec_devices_mutex);  /* CRITICAL SECTION: BEGIN */\n    if( NULL == device->context ) {\n        rc = PARSEC_ERR_BAD_PARAM;\n        goto unlock_and_return_rc;\n    }\n    if(device != parsec_devices[device->device_index]) {\n        rc = PARSEC_ERR_NOT_FOUND;\n        goto unlock_and_return_rc;\n    }\n    parsec_devices[device->device_index] = NULL;\n    device->context = NULL;\n    device->device_index = -1;\n  unlock_and_return_rc:\n    parsec_atomic_unlock(&parsec_devices_mutex);  /* CRITICAL SECTION: END */\n    return rc;\n}\n\n\nvoid parsec_mca_device_taskpool_restrict(parsec_taskpool_t *tp,\n                                         uint8_t            device_type)\n{\n    parsec_device_module_t *device;\n    uint32_t i;\n\n    for (i = 0; i < parsec_nb_devices; i++) {\n        device = parsec_mca_device_get(i);\n        if ((NULL == device) || (device->type & device_type))\n            continue;\n\n        /* Force unregistration for this type of device. This is not correct, as some of\n         * the memory related to the taskpoool might still be registered with the\n         * devices we drop support. */\n        tp->devices_index_mask &= ~(1 << device->device_index);\n    }\n    return;\n}\n\nint parsec_advise_data_on_device(parsec_data_t *data, int device, int advice)\n{\n    parsec_device_module_t *dev = parsec_mca_device_get(device);\n\n    if( NULL == dev )\n        return PARSEC_ERR_NOT_FOUND;\n    if( NULL == dev->data_advise )\n        return PARSEC_SUCCESS;\n    return dev->data_advise(dev, data, advice);\n}\n\nvoid parsec_devices_reset_load(parsec_context_t *context)\n{\n    if( NULL == parsec_device_load )\n        return;\n    for(int i = 0; i < (int)parsec_nb_devices; i++) {\n        parsec_device_load[i] = 0;\n    }\n    (void)context;\n}\n\nint parsec_devices_release_memory(void)\n{\n    parsec_device_module_t *dev;\n    for(int i = 1; i < (int)parsec_nb_devices; i++) {\n        dev = parsec_mca_device_get(i);\n        if((NULL != dev) && (NULL != dev->memory_release)) {\n            dev->memory_release(dev);\n        }\n    }\n    return PARSEC_SUCCESS;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-parsec-master-4n2wechuwbfvaz3xskandlsgbx5zt7bu/spack-src/.git/objects/pack/pack-332b6b86dc4515a5e546ebbbd2417f30c463b033.idx",
        "/tmp/vanessa/spack-stage/spack-stage-parsec-master-4n2wechuwbfvaz3xskandlsgbx5zt7bu/spack-src/.git/objects/pack/pack-332b6b86dc4515a5e546ebbbd2417f30c463b033.pack"
    ],
    "total_files": 633
}