{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-c-client-3.0.9-5x5r7t2wfli2nvkxgtyu44kb5fljezxr/spack-src/CMakeLists.txt": "# CMakeLists.txt\n\n# This is the LGPL libmariadb project.\n\nCMAKE_MINIMUM_REQUIRED(VERSION 2.8 FATAL_ERROR)\nINCLUDE(CheckFunctionExists)\nIF(COMMAND CMAKE_POLICY)\n  SET(NEW_POLICIES CMP0003 CMP0022 CMP0023)\n  FOREACH(TYPE OLD NEW)\n    FOREACH(P ${${TYPE}_POLICIES})\n      IF(POLICY ${P})\n        CMAKE_POLICY(SET ${P} ${TYPE})\n      ENDIF()\n    ENDFOREACH()\n  ENDFOREACH()\nENDIF()\n\n\nPROJECT(mariadb-connector-c C)\n\n# Is C/C built as subproject?\nget_directory_property(IS_SUBPROJECT PARENT_DIRECTORY)\n\n# do not inherit include directories from the parent project\nSET_PROPERTY(DIRECTORY PROPERTY INCLUDE_DIRECTORIES)\nFOREACH(V WITH_MYSQLCOMPAT WITH_MSI WITH_SIGNCODE WITH_RTC WITH_UNIT_TESTS\n    WITH_DYNCOL WITH_EXTERNAL_ZLIB WITH_CURL WITH_SQLITE WITH_SSL\n    INSTALL_LAYOUT WITH_TEST_SRCPKG)\n  SET(${V} ${${OPT}${V}})\nENDFOREACH()\n\n#SET(PACKAGE_STATUS_SUFFIX \"beta\")\n\nSET(CC_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})\nSET(CC_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR})\n\nSET(CPACK_PACKAGE_VERSION_MAJOR 3)\nSET(CPACK_PACKAGE_VERSION_MINOR 0)\nSET(CPACK_PACKAGE_VERSION_PATCH 9)\nSET(CPACK_PACKAGE_VERSION \"${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}\")\nMATH(EXPR MARIADB_PACKAGE_VERSION_ID \"${CPACK_PACKAGE_VERSION_MAJOR} * 10000 +\n                            ${CPACK_PACKAGE_VERSION_MINOR} * 100   +\n                            ${CPACK_PACKAGE_VERSION_PATCH}\")\n\nMACRO(ADD_OPTION _name _text _default)\n  IF(NOT DEFINED ${_name})\n    OPTION(${OPT}${_name} \"${_text}\" \"${_default}\")\n  ELSE()\n    OPTION(${OPT}${_name} \"${_text}\" \"${${_name}}\")\n  ENDIF()\nENDMACRO()\n\n### Options ###\nIF(NOT WIN32)\n  ADD_OPTION(WITH_MYSQLCOMPAT \"creates libmysql* symbolic links\" OFF)\nELSE()\n  ADD_OPTION(WITH_MSI \"Build MSI installation package\" OFF)\n  ADD_OPTION(WITH_SIGNCODE \"digitally sign files\" OFF)\n  ADD_OPTION(WITH_RTC \"enables run time checks for debug builds\" OFF)\nENDIF()\n\nADD_OPTION(WITH_UNIT_TESTS \"build test suite\" ON)\nADD_OPTION(WITH_DYNCOL \"Enables support of dynamic coluumns\" ON)\nADD_OPTION(WITH_EXTERNAL_ZLIB \"Enables use of external zlib\" OFF)\nADD_OPTION(WITH_CURL \"Enables use of curl\" ON)\nADD_OPTION(WITH_SSL \"Enables use of TLS/SSL library\" ON)\n###############\n\nINCLUDE(${CC_SOURCE_DIR}/cmake/misc.cmake)\n\nIF(WITH_SIGNCODE)\n  IF(WIN32 AND NOT SIGN_OPTIONS)\n    SET(SIGN_OPTIONS /a /t http://timestamp.verisign.com/scripts/timstamp.dll)\n  ELSE()\n    SEPARATE_ARGUMENTS(SIGN_OPTIONS)\n  ENDIF()\n  MARK_AS_ADVANCED(SIGN_OPTIONS)\nENDIF()\n\nSET(MARIADB_CONNECTOR_C_COPYRIGHT \"2013-2017 MariaDB Corporation Ab\")\n\nIF(WITH_RTC)\n  SET(RTC_OPTIONS \"/RTC1 /RTCc\")\nENDIF()\n\nIF(NOT WIN32)\n  INCLUDE(${CC_SOURCE_DIR}/cmake/FindGSSAPI.cmake)\n  IF(GSSAPI_FOUND)\n    INCLUDE_DIRECTORIES(${GSSAPI_INCS})\n  ENDIF()\nENDIF()\n\nINCLUDE(${CC_SOURCE_DIR}/cmake/plugins.cmake)\n\nIF(AUTH_GSSAPI_PLUGIN_TYPE MATCHES \"STATIC\")\n  SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${GSSAPI_LIBS})\nENDIF()\n\n\nIF(WIN32)\n  FILE(REMOVE ${CC_BINARY_DIR}/win/packaging/plugin.conf)\n  INCLUDE(${CC_SOURCE_DIR}/cmake/version_info.cmake)\nENDIF()\n\nIF(NOT IS_SUBPROJECT)\nIF(MSVC)\n  # Speedup system tests\n  INCLUDE(${CC_SOURCE_DIR}/cmake/WindowsCache.cmake)\n  IF (MSVC)\n    SET(CONFIG_TYPES \"DEBUG\" \"RELEASE\" \"RELWITHDEBINFO\")\n    FOREACH(BUILD_TYPE ${CONFIG_TYPES})\n      FOREACH(COMPILER CXX C)\n        SET(COMPILER_FLAGS \"${CMAKE_${COMPILER}_FLAGS_${BUILD_TYPE}}\")\n        IF (NOT COMPILER_FLAGS STREQUAL \"\")\n          STRING(REPLACE \"/MD\" \"/MT\" COMPILER_FLAGS ${COMPILER_FLAGS})\n          IF (CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n            SET(COMPILER_FLAGS \"${COMPILER_FLAGS} ${RTC_OPTIONS}\")\n            STRING(REPLACE \"/Zi\" \"/ZI\" COMPILER_FLAGS ${COMPILER_FLAGS})\n          ELSE()\n            STRING(REPLACE \"/Zi\" \"/Z7\" COMPILER_FLAGS ${COMPILER_FLAGS})\n          ENDIF()\n          MESSAGE (STATUS \"CMAKE_${COMPILER}_FLAGS_${BUILD_TYPE}= ${COMPILER_FLAGS}\")\n          SET(CMAKE_${COMPILER}_FLAGS_${BUILD_TYPE} ${COMPILER_FLAGS})\n        ENDIF()\n      ENDFOREACH()\n    ENDFOREACH()\n  ENDIF()\nENDIF()\nENDIF(NOT IS_SUBPROJECT)\n\n# Disable dbug information for release builds\nSET(CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE} -DDBUG_OFF\")\nSET(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -DDBUG_OFF\")\nSET(CMAKE_C_FLAGS_RELWITHDEBINFO \"${CMAKE_C_FLAGS_RELWITHDEBINFO} -DDBUG_OFF\")\nSET(CMAKE_CXX_FLAGS_RELWITHDEBINFO \"${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -DDBUG_OFF\")\n\nIF(CMAKE_COMPILER_IS_GNUCC)\n  INCLUDE(CheckCCompilerFlag)\n  SET(GCC_FLAGS -Wunused -Wlogical-op -Wno-uninitialized  -Wall -Wextra -Wformat-security -Wno-init-self -Wwrite-strings -Wshift-count-overflow -Wdeclaration-after-statement -Wno-undef -Wno-unknown-pragmas)\n  FOREACH(GCC_FLAG ${GCC_FLAGS})\n    CHECK_C_COMPILER_FLAG(\"${GCC_FLAG}\" HAS_${GCC_FLAG}_FLAG)\n    IF(${HAS_${GCC_FLAG}_FLAG})\n      SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${GCC_FLAG}\")\n    ENDIF()\n  ENDFOREACH()\nENDIF()\n\n# If the build type isn't specified, set to Relwithdebinfo as default.\nIF(NOT CMAKE_BUILD_TYPE)\n  SET(CMAKE_BUILD_TYPE \"RelWithDebInfo\")\nENDIF()\n\n# various defines for generating include/mysql_version.h\nINCLUDE(FindGit)\nIF(GIT_EXECUTABLE AND EXISTS ${CC_SOURCE_DIR}/.git)\n  EXECUTE_PROCESS(\n    COMMAND ${GIT_EXECUTABLE} rev-parse HEAD\n      WORKING_DIRECTORY ${CC_SOURCE_DIR}\n       OUTPUT_VARIABLE OUT RESULT_VARIABLE RES)\n   IF(RES EQUAL 0)\n    STRING(REGEX REPLACE \"\\n$\" \"\" CC_SOURCE_REVISION \"${OUT}\")\n  ENDIF()\nENDIF()\nSET(PROTOCOL_VERSION 10) # we adapted new password option from PHP's mysqlnd !\n\n# if C/C is build as subproject inside MariaDB server tree we will\n# use the version defined by server\nIF(MAJOR_VERSION)\n  SET(MARIADB_CLIENT_VERSION_MAJOR ${MAJOR_VERSION})\n  SET(MARIADB_CLIENT_VERSION_MINOR ${MINOR_VERSION})\n  SET(MARIADB_CLIENT_VERSION_PATCH ${PATCH_VERSION})\nELSE()\n  SET(MARIADB_CLIENT_VERSION_MAJOR \"10\")\n  SET(MARIADB_CLIENT_VERSION_MINOR \"3\")\n  SET(MARIADB_CLIENT_VERSION_PATCH \"6\")\nENDIF()\nSET(MARIADB_CLIENT_VERSION \"${MARIADB_CLIENT_VERSION_MAJOR}.${MARIADB_CLIENT_VERSION_MINOR}.${MARIADB_CLIENT_VERSION_PATCH}\")\nSET(MARIADB_BASE_VERSION \"mariadb-${MARIADB_CLIENT_VERSION_MAJOR}.${MARIADB_CLIENT_VERSION_MINOR}\")\nMATH(EXPR MARIADB_VERSION_ID \"${MARIADB_CLIENT_VERSION_MAJOR} * 10000 +\n                              ${MARIADB_CLIENT_VERSION_MINOR} * 100   +\n                              ${MARIADB_CLIENT_VERSION_PATCH}\")\n\nIF (NOT MARIADB_PORT)\n  SET(MARIADB_PORT 3306)\nENDIF ()\nIF(NOT MARIADB_UNIX_ADDR)\n  SET(MARIADB_UNIX_ADDR \"/tmp/mysql.sock\")\nENDIF()\n\nINCLUDE(\"${CC_SOURCE_DIR}/cmake/install.cmake\")\nIF(NOT PLUGINDIR)\n  SET(PLUGINDIR \"${INSTALL_PLUGINDIR}\")\nENDIF()\n\n# todo: we don't character sets in share - all is compiled in\nSET(SHAREDIR \"share\")\nSET(DEFAULT_CHARSET_HOME \"${CMAKE_INSTALL_PREFIX}\")\n\nINCLUDE(${CC_SOURCE_DIR}/cmake/SearchLibrary.cmake)\n\nIF(WITH_EXTERNAL_ZLIB)\n  IF(NOT ZLIB_FOUND)\n    FIND_PACKAGE(ZLIB)\n  ENDIF()\n  IF(ZLIB_FOUND)\n    INCLUDE_DIRECTORIES(${ZLIB_INCLUDE_DIR})\n    SET(LIBZ ${ZLIB_LIBRARY})\n  ENDIF()\nENDIF()\n\nIF(NOT WIN32)\n  INCLUDE(TestBigEndian)\n  TEST_BIG_ENDIAN(HAVE_BIGENDIAN)\nENDIF()\n\n# check for various include files\nINCLUDE(${CC_SOURCE_DIR}/cmake/CheckIncludeFiles.cmake)\n# check for various functions\nINCLUDE(${CC_SOURCE_DIR}/cmake/CheckFunctions.cmake)\n# check for various types\nINCLUDE(${CC_SOURCE_DIR}/cmake/CheckTypes.cmake)\n\nIF(UNIX)\n  SEARCH_LIBRARY(LIBDL dlopen \"dl\")\n  IF(NOT ${LIBDL})\n    SEARCH_LIBRARY(LIBDL dlsym \"dl\")\n  ENDIF()\n  SEARCH_LIBRARY(LIBM floor m)\n  SEARCH_LIBRARY(LIBPTHREAD pthread_getspecific \"pthread;pthreads\")\n  SEARCH_LIBRARY(LIBNSL gethostbyname_r \"nsl_r;nsl\")\n  SEARCH_LIBRARY(LIBSOCKET setsockopt socket)\n  FIND_PACKAGE(Threads)\n  SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${LIBNSL} ${LIBBIND} ${LIBICONV} ${LIBZ}\n    ${LIBSOCKET} ${LIBDL} ${LIBM} ${LIBPTHREAD})\n  SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${LIBNSL} ${LIBBIND} ${LIBICONV} ${LIBZ}\n    ${LIBSOCKET} ${LIBDL} ${LIBM} ${LIBPTHREAD})\n  #remove possible dups from required libraries\n  LIST(LENGTH CMAKE_REQUIRED_LIBRARIES rllength)\n  IF(${rllength} GREATER 0)\n    LIST(REMOVE_DUPLICATES CMAKE_REQUIRED_LIBRARIES)\n  ENDIF()\nENDIF()\n\n\nIF(CMAKE_HAVE_PTHREAD_H)\n  SET(CMAKE_REQUIRED_INCLUDES pthread.h)\nENDIF()\n\nIF(DBUG_OFF)\n  ADD_DEFINITIONS(-DDBUG_OFF=1)\nENDIF()\n\nADD_DEFINITIONS(-DMARIADB_SYSTEM_TYPE=\"${CMAKE_SYSTEM_NAME}\")\nADD_DEFINITIONS(-DMARIADB_MACHINE_TYPE=\"${CMAKE_SYSTEM_PROCESSOR}\")\n\nIF(WIN32)\n  SET(HAVE_THREADS 1)\n  ADD_DEFINITIONS(-DHAVE_DLOPEN)\n  ADD_DEFINITIONS(-D_CRT_SECURE_NO_WARNINGS)\n  IF(MSVC)\n     SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} /wd4996\" )\n  ENDIF()\nELSEIF()\n  SET(HAVE_THREADS ${CMAKE_USE_PTHREADS})\nENDIF()\n\nIF(NOT DEFAULT_CHARSET)\n  SET(DEFAULT_CHARSET \"latin1\")\nENDIF()\n\n\n# convert SSL options to uppercase\nIF(WITH_SSL)\n  STRING(TOUPPER ${WITH_SSL} WITH_SSL)\nENDIF()\nIF(WITH_SSL STREQUAL \"ON\")\n  IF(WIN32)\n    SET(WITH_SSL \"SCHANNEL\")\n  ELSE()\n    SET(WITH_SSL \"OPENSSL\")\n  ENDIF()\nENDIF()\n\nIF(NOT WITH_SSL STREQUAL \"OFF\")\n  IF(WITH_SSL STREQUAL \"OPENSSL\")\n    IF (NOT OPENSSL_FOUND)\n      FIND_PACKAGE(OpenSSL)\n    ENDIF()\n    IF(OPENSSL_FOUND)\n      ADD_DEFINITIONS(-DHAVE_OPENSSL -DHAVE_TLS)\n      SET(SSL_SOURCES \"${CC_SOURCE_DIR}/libmariadb/secure/openssl.c\")\n      SET(SSL_LIBRARIES ${OPENSSL_SSL_LIBRARY} ${OPENSSL_CRYPTO_LIBRARY})\n      INCLUDE_DIRECTORIES(BEFORE ${OPENSSL_INCLUDE_DIR})\n\n      TRY_RUN(LIBRESSL_RESULT HAVE_LIBRESSL\n              ${CMAKE_BINARY_DIR}\n              ${CC_SOURCE_DIR}/cmake/libressl_version.c\n              COMPILE_DEFINITIONS \"-I${OPENSSL_INCLUDE_DIR}\"\n              RUN_OUTPUT_VARIABLE LIBRESSL_VERSION)\n      IF(HAVE_LIBRESSL)\n        ADD_DEFINITIONS(-DHAVE_LIBRESSL)\n        SET(TLS_LIBRARY_VERSION ${LIBRESSL_VERSION})\n      ELSE()\n        SET(TLS_LIBRARY_VERSION \"OpenSSL ${OPENSSL_VERSION}\")\n      ENDIF()\n    ELSE()\n      MESSAGE1(TLS_LIBRARY_VERSION \"OpenSSL/LibreSSL not found\")\n    ENDIF()\n  ENDIF()\n  IF(WITH_SSL STREQUAL \"GNUTLS\")\n    FIND_PACKAGE(GnuTLS \"3.3.24\" REQUIRED)\n    IF(GNUTLS_FOUND)\n      ADD_DEFINITIONS(-DHAVE_GNUTLS -DHAVE_TLS)\n      SET(SSL_SOURCES \"${CC_SOURCE_DIR}/libmariadb/secure/gnutls.c\")\n      SET(SSL_LIBRARIES ${GNUTLS_LIBRARY})\n      SET(TLS_LIBRARY_VERSION \"GnuTLS ${GNUTLS_VERSION_STRING}\")\n      INCLUDE_DIRECTORIES(${GNUTLS_INCLUDE_DIR})\n    ELSE()\n      MESSAGE(FATAL_ERROR \"GnuTLS not found\")\n    ENDIF()\n  ENDIF()\n  IF(WIN32)\n    IF(WITH_SSL STREQUAL \"SCHANNEL\")\n      ADD_DEFINITIONS(-DHAVE_SCHANNEL -DHAVE_TLS)\n      SET(SSL_SOURCES \"${CC_SOURCE_DIR}/libmariadb/secure/schannel.c\"\n                      \"${CC_SOURCE_DIR}/libmariadb/secure/ma_schannel.c\")\n      INCLUDE_DIRECTORIES(\"${CC_SOURCE_DIR}/plugins/pvio/\")\n      SET(SSL_LIBRARIES secur32)\n      SET(TLS_LIBRARY_VERSION \"Schannel ${CMAKE_SYSTEM_VERSION}\")\n    ENDIF()\n  ENDIF()\n  MESSAGE1(TLS_LIBRARY_VERSION \"TLS library/version: ${TLS_LIBRARY_VERSION}\")\n\n  MARK_AS_ADVANCED(SSL_SOURCES)\nENDIF()\n\nSET(ENABLED_LOCAL_INFILE \"AUTO\" CACHE STRING \"If we should should enable LOAD DATA LOCAL by default (OFF/ON/AUTO)\")\nMARK_AS_ADVANCED(ENABLED_LOCAL_INFILE)\nIF (ENABLED_LOCAL_INFILE MATCHES \"^(0|FALSE)$\")\n  SET(ENABLED_LOCAL_INFILE OFF)\nELSEIF(ENABLED_LOCAL_INFILE MATCHES \"^(1|TRUE)$\")\n  SET(ENABLED_LOCAL_INFILE ON)\nELSEIF (NOT ENABLED_LOCAL_INFILE MATCHES \"^(ON|OFF|AUTO)$\")\n  MESSAGE(FATAL_ERROR \"ENABLED_LOCAL_INFILE must be one of OFF, ON, AUTO\")\nENDIF()\n\nIF(NOT WIN32)\n  INCLUDE(${CC_SOURCE_DIR}/cmake/FindIconv.cmake)\nENDIF()\n\nCONFIGURE_FILE(${CC_SOURCE_DIR}/include/ma_config.h.in\n               ${CC_BINARY_DIR}/include/ma_config.h)\nCONFIGURE_FILE(${CC_SOURCE_DIR}/include/ma_config.h.in\n               ${CC_BINARY_DIR}/include/config.h)\nCONFIGURE_FILE(${CC_SOURCE_DIR}/include/mariadb_version.h.in\n               ${CC_BINARY_DIR}/include/mariadb_version.h)\n\nINCLUDE_DIRECTORIES(${CC_BINARY_DIR}/include)\n\nIF(WIN32)\n  SET(SYSTEM_LIBS ws2_32 advapi32 kernel32 shlwapi crypt32 ${LIBZ})\nELSE()\n  SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${LIBPTHREAD} ${LIBDL} ${LIBM})\n  IF(ICONV_EXTERNAL)\n    SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${ICONV_LIBRARIES})\n  ENDIF()\nENDIF()\nIF(WITH_SSL)\n  SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${SSL_LIBRARIES})\nENDIF()\nMESSAGE1(SYSTEM_LIBS \"SYSTEM_LIBS ${SYSTEM_LIBS}\")\nMARK_AS_ADVANCED(SYSTEM_LIBS)\n\nIF(NOT REMOTEIO_PLUGIN_TYPE MATCHES \"OFF\")\n  IF(CURL_FOUND)\n    INCLUDE_DIRECTORIES(${CURL_INCLUDE_DIRS})\n    IF(REMOTEIO_PLUGIN_TYPE MATCHES \"STATIC\")\n      SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${CURL_LIBRARIES})\n    ENDIF()\n    ADD_DEFINITIONS(\"-DHAVE_REMOTEIO=1\")\n  ENDIF()\nENDIF()\nIF(NOT WIN32)\n  IF(NOT AUTH_GSSAPI_PLUGIN_TYPE MATCHES \"OFF\")\n    INCLUDE(${CC_SOURCE_DIR}/cmake/FindGSSAPI.cmake)\n    IF(GSSAPI_FOUND)\n      INCLUDE_DIRECTORIES(${GSSAPI_INCS})\n      IF(AUTH_GSSAPI_PLUGIN_TYPE MATCHES \"STATIC\")\n        SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${GSSAPI_LIBS})\n      ENDIF()\n    ENDIF()\n  ENDIF()\nENDIF()\nINCLUDE(${CC_SOURCE_DIR}/plugins/CMakeLists.txt)\nADD_SUBDIRECTORY(include)\nADD_SUBDIRECTORY(libmariadb)\nIF(NOT WIN32)\n  ADD_SUBDIRECTORY(mariadb_config)\nENDIF()\n\nIF(IS_DIRECTORY ${CC_SOURCE_DIR}/unittest)\n  IF(WITH_UNIT_TESTS)\n    ADD_SUBDIRECTORY(unittest/mytap)\n    ADD_SUBDIRECTORY(unittest/libmariadb)\n  ENDIF()\nENDIF()\n\nIF(CLIENT_DOCS)\n  INSTALL(DIRECTORY ${CLIENT_DOCS}\n          DESTINATION ${DOCS_INSTALL_DIR_${INSTALL_LAYOUT}}\n          COMPONENT SharedLibraries)\nENDIF()\n\n\nIF(WIN32 AND WITH_MSI AND CMAKE_BUILD_TYPE STREQUAL \"RelWithDebInfo\")\n  ADD_SUBDIRECTORY(win/packaging)\nENDIF()\nMESSAGE1(SYSTEM_PROCESSOR \"SYSTEM processor: ${CMAKE_SYSTEM_PROCESSOR}\")\nSET(CPACK_PACKAGE_VENDOR \"MariaDB Corporation Ab\")\nSET(CPACK_PACKAGE_DESCRIPTION \"MariaDB Connector/C. A library for connecting to MariaDB and MySQL servers\")\nSET(CPACK_PACKAGE_NAME \"mariadb_connector_c\")\nSTRING(TOLOWER ${CMAKE_SYSTEM_NAME} system_name)\nSET(CPACK_RESOURCE_FILE_LICENSE \"${CC_SOURCE_DIR}/COPYING.LIB\")\nSET(CPACK_PACKAGE_DESCRIPTION_FILE \"${CC_SOURCE_DIR}/README\")\nINCLUDE(cmake/ConnectorName.cmake)\nIF(NOT PACKAGE_STATUS_SUFFIX)\n  SET(CPACK_SOURCE_PACKAGE_FILE_NAME \"mariadb-connector-c-${CPACK_PACKAGE_VERSION}-src\")\n  SET(CPACK_PACKAGE_FILE_NAME \"mariadb-connector-c-${CPACK_PACKAGE_VERSION}-${system_name}-${CMAKE_SYSTEM_PROCESSOR}\")\nELSE()\n  SET(CPACK_SOURCE_PACKAGE_FILE_NAME \"mariadb-connector-c-${CPACK_PACKAGE_VERSION}-${PACKAGE_STATUS_SUFFIX}-src\")\n  SET(CPACK_PACKAGE_FILE_NAME \"mariadb-connector-c-${CPACK_PACKAGE_VERSION}-${PACKAGE_STATUS_SUFFIX}-${system_name}-${CMAKE_SYSTEM_PROCESSOR}\")\nENDIF()\n# Build source packages\nIF(GIT_BUILD_SRCPKG)\n  # get branch name\n  EXECUTE_PROCESS(COMMAND ${GIT_EXECUTABLE} show-branch OUTPUT_VARIABLE git_branch)\n  STRING(REGEX MATCH \"\\\\[([^]]+)\\\\]\" git_branch ${git_branch})\n  STRING(REGEX REPLACE \"\\\\[|\\\\]\" \"\" GIT_BRANCH ${git_branch})\n  MESSAGE1(GIT_BRANCH \"${GIT_BRANCH}\")\n  IF(WIN32)\n    EXECUTE_PROCESS(COMMAND ${GIT_EXECUTABLE} archive ${GIT_BRANCH} --format=zip --prefix=${CPACK_SOURCE_PACKAGE_FILE_NAME}/ --output=${CPACK_SOURCE_PACKAGE_FILE_NAME}.zip)\n  ELSE()\n    EXECUTE_PROCESS(COMMAND ${GIT_EXECUTABLE} archive ${GIT_BRANCH} --format=zip --prefix=${CPACK_SOURCE_PACKAGE_FILE_NAME}/ --output=${CPACK_SOURCE_PACKAGE_FILE_NAME}.zip)\n    EXECUTE_PROCESS(COMMAND ${GIT_EXECUTABLE} archive ${GIT_BRANCH} --format=tar --prefix=${CPACK_SOURCE_PACKAGE_FILE_NAME}/ --output=${CPACK_SOURCE_PACKAGE_FILE_NAME}.tar)\n    EXECUTE_PROCESS(COMMAND gzip -9 -f ${CPACK_SOURCE_PACKAGE_FILE_NAME}.tar)\n  ENDIF()\nENDIF()\n\nSET(CPACK_SOURCE_IGNORE_FILES\n\\\\\\\\.git/\n\\\\\\\\.gitignore\n\\\\\\\\.gitattributes\nCMakeCache\\\\\\\\.txt\ncmake_dist\\\\\\\\.cmake\nCPackConfig\\\\\\\\.cmake\nmariadb_config\\\\\\\\.c$\n\\\\\\\\.build/\nhtml/\nunittest\n/cmake_install.cmake\n/CTestTestfile.cmake\n/CPackSourceConfig.cmake\n/CMakeFiles/\n/version_resources/\n/_CPack_Packages/\n\\\\\\\\.gz$\n\\\\\\\\.zip$\nmariadb_config/mariadb_config$\n/CMakeFiles/\n/version_resources/\n/_CPack_Packages/\nMakefile$\ninclude/my_config\\\\\\\\.h$\n)\n\nIF(WITH_TEST_SRCPKG)\n  SET(PACKAGE_FILE ${CC_SOURCE_DIR}/package.name)\n  FILE(REMOVE ${PACKAGE_FILE})\n  FILE(WRITE ${PACKAGE_FILE} ${CPACK_SOURCE_PACKAGE_FILE_NAME})\nENDIF()\n\nIF(WIN32)\n  SET(CPACK_GENERATOR \"ZIP\")\n  SET(CPACK_SOURCE_GENERATOR \"ZIP\")\nELSE()\n  SET(CPACK_GENERATOR \"TGZ\")\n  SET(CPACK_SOURCE_GENERATOR \"TGZ\")\nENDIF()\nINCLUDE(CPack)\n\nIF(WITH_EXTERNAL_ZLIB)\n  SET(zlib_status ${WITH_EXTERNAL_ZLIB})\nELSE()\n  SET(zlib_status \"yes (using bundled zlib)\")\nENDIF()\n\nMESSAGE1(STATUS \"MariaDB Connector/c configuration:\n-- Static PLUGINS ${PLUGINS_STATIC}\n-- Dynamic PLUGINS ${PLUGINS_DYNAMIC}\n-- CPack generation: ${CPACK_GENERATOR}\n-- SSL support: ${WITH_SSL} Libs: ${SSL_LIBRARIES}\n-- Zlib support: ${zlib_status}\n-- Installation layout: ${INSTALL_LAYOUT}\n-- Include files will be installed in ${INSTALL_INCLUDEDIR}\n-- Libraries will be installed in ${INSTALL_LIBDIR}\n-- Binaries will be installed in ${INSTALL_BINDIR}\n-- Documentation included from ${CLIENT_DOCS}\n-- Required: ${CMAKE_REQUIRED_LIBRARIES}\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-c-client-3.0.9-5x5r7t2wfli2nvkxgtyu44kb5fljezxr/spack-src/include/ma_global.h": "/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB\n   \n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n   \n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not, write to the Free\n   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n   MA 02111-1301, USA */\n\n/* This is the main include file that should included 'first' in every\n   C file. */\n\n#ifndef _global_h\n#define _global_h\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <stdlib.h>\n#define strcasecmp _stricmp\n#define sleep(x) Sleep(1000*(x))\n#ifdef _MSC_VER\n#define inline __inline\n#if _MSC_VER < 1900\n#define snprintf _snprintf\n#endif\n#endif\n#define STDCALL __stdcall \n#endif\n\n#include <ma_config.h>\n#include <assert.h>\n#ifndef __GNUC__\n#define  __attribute(A)\n#endif\n\n/* Fix problem with S_ISLNK() on Linux */\n#if defined(HAVE_LINUXTHREADS)\n#undef  _GNU_SOURCE\n#define _GNU_SOURCE 1\n#endif\n\n/* The client defines this to avoid all thread code */\n#if defined(UNDEF_THREADS_HACK)\n#undef THREAD\n#undef HAVE_mit_thread\n#undef HAVE_LINUXTHREADS\n#undef HAVE_UNIXWARE7_THREADS\n#endif\n\n#ifdef HAVE_THREADS_WITHOUT_SOCKETS\n/* MIT pthreads does not work with unix sockets */\n#undef HAVE_SYS_UN_H\n#endif\n\n#define __EXTENSIONS__ 1\t/* We want some extension */\n#ifndef __STDC_EXT__\n#define __STDC_EXT__ 1          /* To get large file support on hpux */\n#endif\n\n#if defined(THREAD) && !defined(_WIN32)\n#ifndef _POSIX_PTHREAD_SEMANTICS\n#define _POSIX_PTHREAD_SEMANTICS /* We want posix threads */\n#endif\n/* was #if defined(HAVE_LINUXTHREADS) || defined(HAVE_DEC_THREADS) || defined(HPUX) */\n#if !defined(SCO)\n#define _REENTRANT\t1\t/* Some thread libraries require this */\n#endif\n#if !defined(_THREAD_SAFE) && !defined(_AIX)\n#define _THREAD_SAFE            /* Required for OSF1 */\n#endif\n#ifndef HAVE_mit_thread\n#ifdef HAVE_UNIXWARE7_THREADS\n#include <thread.h>\n#else\n#include <pthread.h>\t\t/* AIX must have this included first */\n#endif /* HAVE_UNIXWARE7_THREADS */\n#endif /* HAVE_mit_thread */\n#if !defined(SCO) && !defined(_REENTRANT)\n#define _REENTRANT\t1\t/* Threads requires reentrant code */\n#endif\n#endif /* THREAD */\n\n/* Go around some bugs in different OS and compilers */\n#ifdef _AIX\t\t\t/* By soren@t.dk */\n#define _H_STRINGS\n#define _SYS_STREAM_H\n#define _AIX32_CURSES\n#define ulonglong2double(A) my_ulonglong2double(A)\n#define my_off_t2double(A)  my_ulonglong2double(A)\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\ndouble my_ulonglong2double(unsigned long long A);\n#ifdef\t__cplusplus\n}\n#endif\n#endif /* _AIX */\n\n#ifdef HAVE_BROKEN_SNPRINTF\t/* HPUX 10.20 don't have this defined */\n#undef HAVE_SNPRINTF\n#endif\n#if defined(HAVE_BROKEN_INLINE) && !defined(__cplusplus)\n#undef inline\n#define inline\n#endif\n\n#ifdef UNDEF_HAVE_GETHOSTBYNAME_R\t\t/* For OSF4.x */\n#undef HAVE_GETHOSTBYNAME_R\n#endif\n#ifdef UNDEF_HAVE_INITGROUPS\t\t\t/* For AIX 4.3 */\n#undef HAVE_INITGROUPS\n#endif\n\n/* Fix a bug in gcc 2.8.0 on IRIX 6.2 */\n#if SIZEOF_LONG == 4 && defined(__LONG_MAX__)\n#undef __LONG_MAX__             /* Is a longlong value in gcc 2.8.0 ??? */\n#define __LONG_MAX__ 2147483647\n#endif\n\n/* Fix problem when linking c++ programs with gcc 3.x */\n#ifdef DEFINE_CXA_PURE_VIRTUAL\n#define FIX_GCC_LINKING_PROBLEM extern \"C\" { int __cxa_pure_virtual() {return 0;} }\n#else\n#define FIX_GCC_LINKING_PROBLEM\n#endif\n\n/* egcs 1.1.2 has a problem with memcpy on Alpha */\n#if defined(__GNUC__) && defined(__alpha__) && ! (__GNUC__ > 2 || (__GNUC__ == 2 &&  __GNUC_MINOR__ >= 95))\n#define BAD_MEMCPY\n#endif\n\n/* In Linux-alpha we have atomic.h if we are using gcc */\n#if defined(HAVE_LINUXTHREADS) && defined(__GNUC__) && defined(__alpha__) && (__GNUC__ > 2 || ( __GNUC__ == 2 &&  __GNUC_MINOR__ >= 95)) && !defined(HAVE_ATOMIC_ADD)\n#define HAVE_ATOMIC_ADD\n#define HAVE_ATOMIC_SUB\n#endif\n\n/* In Linux-ia64 including atomic.h will give us an error */\n#if (defined(HAVE_LINUXTHREADS) && defined(__GNUC__) && (defined(__ia64__) || defined(__powerpc64__))) || !defined(THREAD)\n#undef HAVE_ATOMIC_ADD\n#undef HAVE_ATOMIC_SUB\n#endif\n\n#if defined(_lint) && !defined(lint)\n#define lint\n#endif\n#if SIZEOF_LONG_LONG > 4 && !defined(_LONG_LONG)\n#define _LONG_LONG 1\t\t/* For AIX string library */\n#endif\n\n#ifndef stdin\n#include <stdio.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STDDEF_H\n#include <stddef.h>\n#endif\n\n#include <math.h>\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#ifdef HAVE_FLOAT_H\n#include <float.h>\n#endif\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#if defined(TIME_WITH_SYS_TIME)\n# include <sys/time.h>\n# include <time.h>\n#else\n# if defined(HAVE_SYS_TIME_H)\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif /* TIME_WITH_SYS_TIME */\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if defined(__cplusplus) && defined(NO_CPLUSPLUS_ALLOCA)\n#undef HAVE_ALLOCA\n#undef HAVE_ALLOCA_H\n#endif\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n#ifdef HAVE_ATOMIC_ADD\n#define __SMP__\n#define CONFIG_SMP\n#include <asm/atomic.h>\n#endif\n#include <errno.h>\t\t\t\t/* Recommended by debian */\n#include <assert.h>\n\n/* Go around some bugs in different OS and compilers */\n#if defined(_HPUX_SOURCE) && defined(HAVE_SYS_STREAM_H)\n#include <sys/stream.h>\t\t/* HPUX 10.20 defines ulong here. UGLY !!! */\n#define HAVE_ULONG\n#endif\n#ifdef DONT_USE_FINITE\t\t/* HPUX 11.x has is_finite() */\n#undef HAVE_FINITE\n#endif\n#if defined(HPUX) && defined(_LARGEFILE64_SOURCE) && defined(THREAD)\n/* Fix bug in setrlimit */\n#undef setrlimit\n#define setrlimit cma_setrlimit64\n#endif\n\n/* We can not live without these */\n\n#define USE_MYFUNC 1\t\t/* Must use syscall indirection */\n#define MASTER 1\t\t/* Compile without unireg */\n#define ENGLISH 1\t\t/* Messages in English */\n#define POSIX_MISTAKE 1\t\t/* regexp: Fix stupid spec error */\n#define USE_REGEX 1\t\t/* We want the use the regex library */\n/* Do not define for ultra sparcs */\n#define USE_BMOVE512 1\t\t/* Use this unless the system bmove is faster */\n\n/* Paranoid settings. Define I_AM_PARANOID if you are paranoid */\n#ifdef I_AM_PARANOID\n#define DONT_ALLOW_USER_CHANGE 1\n#define DONT_USE_MYSQL_PWD 1\n#endif\n\n/* #define USE_some_charset 1 was deprecated by changes to configure */\n/* my_ctype my_to_upper, my_to_lower, my_sort_order gain theit right value */\n/* automagically during configuration */\n\n/* Does the system remember a signal handler after a signal ? */\n#ifndef HAVE_BSD_SIGNALS\n#define DONT_REMEMBER_SIGNAL\n#endif\n\n\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS)\n#define LINT_INIT(var)\tvar=0\t\t\t/* No uninitialize-warning */\n#define LINT_INIT_STRUCT(var) memset(&var, 0, sizeof(var)) /* No uninitialize-warning */\n#else\n#define LINT_INIT(var)\n#define LINT_INIT_STRUCT(var)\n#endif\n\n/* Define some useful general macros */\n#if defined(__cplusplus) && defined(__GNUC__)\n#define max(a, b)\t((a) >? (b))\n#define min(a, b)\t((a) <? (b))\n#elif !defined(max)\n#define max(a, b)\t((a) > (b) ? (a) : (b))\n#define min(a, b)\t((a) < (b) ? (a) : (b))\n#endif\n\n#if defined(__EMX__) || !defined(HAVE_UINT)\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\n#endif\n\n#define sgn(a)\t\t(((a) < 0) ? -1 : ((a) > 0) ? 1 : 0)\n#define swap(t,a,b)\t{ register t dummy; dummy = a; a = b; b = dummy; }\n#define test(a)\t\t((a) ? 1 : 0)\n#define set_if_bigger(a,b)  { if ((a) < (b)) (a)=(b); }\n#define set_if_smaller(a,b) { if ((a) > (b)) (a)=(b); }\n#define test_all_bits(a,b) (((a) & (b)) == (b))\n#define set_bits(type, bit_count) (sizeof(type)*8 <= (bit_count) ? ~(type) 0 : ((((type) 1) << (bit_count)) - (type) 1))\n#define array_elements(A) ((uint) (sizeof(A)/sizeof(A[0])))\n#ifndef HAVE_RINT\n#define rint(A) floor((A)+0.5)\n#endif\n\n/* Define some general constants */\n#ifndef TRUE\n#define TRUE\t\t(1)\t/* Logical true */\n#define FALSE\t\t(0)\t/* Logical false */\n#endif\n\n#if defined(__GNUC__)\n#define function_volatile\tvolatile\n#ifndef my_reinterpret_cast\n#define my_reinterpret_cast(A) reinterpret_cast<A>\n#endif\n#define my_const_cast(A) const_cast<A>\n#elif !defined(my_reinterpret_cast)\n#define my_reinterpret_cast(A) (A)\n#define my_const_cast(A) (A)\n#endif\n#if !defined(__GNUC__) && !defined(__clang__)\n#define __attribute__(A)\n#endif\n\n/* From old s-system.h */\n\n/*\n  Support macros for non ansi & other old compilers. Since such\n  things are no longer supported we do nothing. We keep then since\n  some of our code may still be needed to upgrade old customers.\n*/\n#define _VARARGS(X) X\n#define _STATIC_VARARGS(X) X\n\n#if defined(DBUG_ON) && defined(DBUG_OFF)\n#undef DBUG_OFF\n#endif\n\n#if defined(_lint) && !defined(DBUG_OFF)\n#define DBUG_OFF\n#endif\n\n#define MIN_ARRAY_SIZE\t0\t/* Zero or One. Gcc allows zero*/\n#define ASCII_BITS_USED 8\t/* Bit char used */\n#define NEAR_F\t\t\t/* No near function handling */\n\n/* Some types that is different between systems */\n\ntypedef int\tFile;\t\t/* File descriptor */\n#ifndef my_socket_defined\n#define my_socket_defined\n#if defined(_WIN64)\n#define my_socket unsigned long long\n#elif defined(_WIN32)\n#define my_socket unsigned int\n#else\ntypedef int my_socket;\n#endif\n#define my_socket_defined\n#endif\n#ifndef INVALID_SOCKET\n#define INVALID_SOCKET -1\n#endif\n\n#if defined(__GNUC__) && !defined(_lint)\ntypedef char\tpchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpuchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpbool;\t\t/* Mixed prototypes can take char */\ntypedef short\tpshort;\t\t/* Mixed prototypes can take short int */\ntypedef float\tpfloat;\t\t/* Mixed prototypes can take float */\n#else\ntypedef int\tpchar;\t\t/* Mixed prototypes can't take char */\ntypedef uint\tpuchar;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpbool;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpshort;\t\t/* Mixed prototypes can't take short int */\ntypedef double\tpfloat;\t\t/* Mixed prototypes can't take float */\n#endif\ntypedef int\t(*qsort_cmp)(const void *,const void *);\n#ifdef HAVE_mit_thread\n#define qsort_t void\n#undef QSORT_TYPE_IS_VOID\n#define QSORT_TYPE_IS_VOID\n#else\n#define qsort_t RETQSORTTYPE\t/* Broken GCC can't handle typedef !!!! */\n#endif\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\ntypedef SOCKET_SIZE_TYPE size_socket;\n\n#ifndef SOCKOPT_OPTLEN_TYPE\n#define SOCKOPT_OPTLEN_TYPE size_socket\n#endif\n\n/* file create flags */\n\n#ifndef O_SHARE\n#define O_SHARE\t\t0\t/* Flag to my_open for shared files */\n#ifndef O_BINARY\n#define O_BINARY\t0\t/* Flag to my_open for binary files */\n#endif\n#define FILE_BINARY\t0\t/* Flag to my_fopen for binary streams */\n#ifdef HAVE_FCNTL\n#define HAVE_FCNTL_LOCK\n#define F_TO_EOF\t0L\t/* Param to lockf() to lock rest of file */\n#endif\n#endif /* O_SHARE */\n#ifndef O_TEMPORARY\n#define O_TEMPORARY\t0\n#endif\n#ifndef O_SHORT_LIVED\n#define O_SHORT_LIVED\t0\n#endif\n\n/* #define USE_RECORD_LOCK\t*/\n\n\t/* Unsigned types supported by the compiler */\n#define UNSINT8\t\t\t/* unsigned int8 (char) */\n#define UNSINT16\t\t/* unsigned int16 */\n#define UNSINT32\t\t/* unsigned int32 */\n\n\t/* General constants */\n#define SC_MAXWIDTH\t256\t/* Max width of screen (for error messages) */\n#define FN_LEN\t\t256\t/* Max file name len */\n#define FN_HEADLEN\t253\t/* Max length of filepart of file name */\n#define FN_EXTLEN\t20\t/* Max length of extension (part of FN_LEN) */\n#define FN_REFLEN\t512\t/* Max length of full path-name */\n#define FN_EXTCHAR\t'.'\n#define FN_HOMELIB\t'~'\t/* ~/ is used as abbrev for home dir */\n#define FN_CURLIB\t'.'\t/* ./ is used as abbrev for current dir */\n#define FN_PARENTDIR\t\"..\"\t/* Parentdirectory; Must be a string */\n#define FN_DEVCHAR\t':'\n\n#ifndef FN_LIBCHAR\n#ifdef _WIN32\n#define FN_LIBCHAR\t'\\\\'\n#define FN_ROOTDIR\t\"\\\\\"\n#else\n#define FN_LIBCHAR\t'/'\n#define FN_ROOTDIR\t\"/\"\n#endif\n#define MY_NFILE\t1024\t/* This is only used to save filenames */\n#endif\n\n/* #define EXT_IN_LIBNAME     */\n/* #define FN_NO_CASE_SENCE   */\n/* #define FN_UPPER_CASE TRUE */\n\n/*\n  Io buffer size; Must be a power of 2 and a multiple of 512. May be\n  smaller what the disk page size. This influences the speed of the\n  isam btree library. eg to big to slow.\n*/\n#define IO_SIZE\t\t\t4096\n/*\n  How much overhead does malloc have. The code often allocates\n  something like 1024-MALLOC_OVERHEAD bytes\n*/\n#define MALLOC_OVERHEAD 8\n\t/* get memory in huncs */\n#define ONCE_ALLOC_INIT\t\t(uint) (4096-MALLOC_OVERHEAD)\n\t/* Typical record cash */\n#define RECORD_CACHE_SIZE\t(uint) (64*1024-MALLOC_OVERHEAD)\n\t/* Typical key cash */\n#define KEY_CACHE_SIZE\t\t(uint) (8*1024*1024-MALLOC_OVERHEAD)\n\n\t/* Some things that this system doesn't have */\n\n#define ONLY_OWN_DATABASES\t/* We are using only databases by monty */\n#define NO_PISAM\t\t/* Not needed anymore */\n#define NO_MISAM\t\t/* Not needed anymore */\n#define NO_HASH\t\t\t/* Not needed anymore */\n#ifdef _WIN32\n#define NO_DIR_LIBRARY\t\t/* Not standard dir-library */\n#define USE_MY_STAT_STRUCT\t/* For my_lib */\n#ifdef _MSC_VER\ntypedef SSIZE_T ssize_t;\n#endif\n#endif\n\n/* Some things that this system does have */\n\n#ifndef HAVE_ITOA\n#define USE_MY_ITOA\t\t/* There is no itoa */\n#endif\n\n/* Some defines of functions for portability */\n\n#ifndef HAVE_ATOD\n#define atod\t\tatof\n#endif\n#ifdef USE_MY_ATOF\n#define atof\t\tmy_atof\nextern void\t\tinit_my_atof(void);\nextern double\t\tmy_atof(const char*);\n#endif\n#undef remove\t\t/* Crashes MySQL on SCO 5.0.0 */\n#ifndef _WIN32\n#define closesocket(A)\tclose(A)\n#endif\n#ifndef ulonglong2double\n#define ulonglong2double(A) ((double) (A))\n#define my_off_t2double(A)  ((double) (A))\n#endif\n\n\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#endif\n#define ulong_to_double(X) ((double) (ulong) (X))\n#define SET_STACK_SIZE(X)\t/* Not needed on real machines */\n\n\n#ifdef HAVE_LINUXTHREADS\n/* #define pthread_sigmask(A,B,C) sigprocmask((A),(B),(C)) */\n/* #define sigset(A,B) signal((A),(B)) */\n#endif\n\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS) || \\\n    defined(__cplusplus) || !defined(__GNUC__)\n#define UNINIT_VAR(x) x= 0\n#else\n/* GCC specific self-initialization which inhibits the warning. */\n#define UNINIT_VAR(x) x= x\n#endif\n\n\n/* This is from the old m-machine.h file */\n\n#if SIZEOF_LONG_LONG > 4\n#define HAVE_LONG_LONG 1\n#endif\n\n#if defined(HAVE_LONG_LONG) && !defined(LONGLONG_MIN)\n#define LONGLONG_MIN\t((long long) 0x8000000000000000LL)\n#define LONGLONG_MAX\t((long long) 0x7FFFFFFFFFFFFFFFLL)\n#endif\n\n\n#define INT_MIN64       (~0x7FFFFFFFFFFFFFFFLL)\n#define INT_MAX64       0x7FFFFFFFFFFFFFFFLL\n#define INT_MIN32       (~0x7FFFFFFFL)\n#define INT_MAX32       0x7FFFFFFFL\n#define UINT_MAX32      0xFFFFFFFFL\n#define INT_MIN24       (~0x007FFFFF)\n#define INT_MAX24       0x007FFFFF\n#define UINT_MAX24      0x00FFFFFF\n#define INT_MIN16       (~0x7FFF)\n#define INT_MAX16       0x7FFF\n#define UINT_MAX16      0xFFFF\n#define INT_MIN8        (~0x7F)\n#define INT_MAX8        0x7F\n#define UINT_MAX8       0xFF\n\n#ifndef ULL\n#ifdef HAVE_LONG_LONG\n#define ULL(A) A ## ULL\n#else\n#define ULL(A) A ## UL\n#endif\n#endif\n\n#if defined(HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)\n/* First check for ANSI C99 definition: */\n#ifdef ULLONG_MAX\n#define ULONGLONG_MAX  ULLONG_MAX\n#else\n#define ULONGLONG_MAX ((unsigned long long)(~0ULL))\n#endif\n#endif /* defined (HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)*/\n\n/* From limits.h instead */\n#ifndef DBL_MIN\n#define DBL_MIN\t\t4.94065645841246544e-324\n#define FLT_MIN\t\t((float)1.40129846432481707e-45)\n#endif\n#ifndef DBL_MAX\n#define DBL_MAX\t\t1.79769313486231470e+308\n#define FLT_MAX\t\t((float)3.40282346638528860e+38)\n#endif\n\n/*\n  Max size that must be added to a so that we know Size to make\n  addressable obj.\n*/\ntypedef long my_ptrdiff_t;\n#define MY_ALIGN(A,L)\t(((A) + (L) - 1) & ~((L) - 1))\n#define ALIGN_SIZE(A)\tMY_ALIGN((A),sizeof(double))\n/* Size to make addressable obj. */\n#define ALIGN_PTR(A, t) ((t*) MY_ALIGN((A),sizeof(t)))\n\t\t\t /* Offset of filed f in structure t */\n#define OFFSET(t, f)\t((size_t)(char *)&((t *)0)->f)\n#define ADD_TO_PTR(ptr,size,type) (type) ((unsigned char*) (ptr)+size)\n#define PTR_BYTE_DIFF(A,B) (my_ptrdiff_t) ((unsigned char*) (A) - (unsigned char*) (B))\n\n#define NullS\t\t(char *) 0\n/* Nowadays we do not support MessyDos */\n#ifndef NEAR\n#define NEAR\t\t\t\t/* Who needs segments ? */\n#define FAR\t\t\t\t/* On a good machine */\n#ifndef HUGE_PTR\n#define HUGE_PTR\n#endif\n#endif\n#if defined(__IBMC__) || defined(__IBMCPP__)\n#define STDCALL _System _Export\n#elif !defined( STDCALL)\n#define STDCALL\n#endif\n\n/* Typdefs for easyier portability */\n\n#if defined(VOIDTYPE)\ntypedef void\t*gptr;\t\t/* Generic pointer */\n#else\ntypedef char\t*gptr;\t\t/* Generic pointer */\n#endif\n#ifndef HAVE_INT_8_16_32\ntypedef char\tint8;\t\t/* Signed integer >= 8\tbits */\ntypedef short\tint16;\t\t/* Signed integer >= 16 bits */\n#endif\n#ifndef HAVE_UCHAR\ntypedef unsigned char\tuchar;\t/* Short for unsigned char */\n#endif\ntypedef unsigned char\tuint8;\t/* Short for unsigned integer >= 8  bits */\ntypedef unsigned short\tuint16; /* Short for unsigned integer >= 16 bits */\n\n#if SIZEOF_INT == 4\n#ifndef HAVE_INT_8_16_32\ntypedef int\t\tint32;\n#endif\ntypedef unsigned int\tuint32; /* Short for unsigned integer >= 32 bits */\n#elif SIZEOF_LONG == 4\n#ifndef HAVE_INT_8_16_32\ntypedef long\t\tint32;\n#endif\ntypedef unsigned long\tuint32; /* Short for unsigned integer >= 32 bits */\n#else\n#error \"Neither int or long is of 4 bytes width\"\n#endif\n\n#if !defined(HAVE_ULONG) && !defined(HAVE_LINUXTHREADS) && !defined(__USE_MISC)\ntypedef unsigned long\tulong;\t/* Short for unsigned long */\n#endif\n#ifndef longlong_defined\n#if defined(HAVE_LONG_LONG) && SIZEOF_LONG != 8\ntypedef unsigned long long int ulonglong; /* ulong or unsigned long long */\ntypedef long long int longlong;\n#else\ntypedef unsigned long\tulonglong;\t/* ulong or unsigned long long */\ntypedef long\t\tlonglong;\n#endif\n#define longlong_defined\n#endif\n\n#ifndef HAVE_INT64\ntypedef longlong int64;\n#endif\n#ifndef HAVE_UINT64\ntypedef ulonglong uint64;\n#endif\n\n#ifndef MIN\n#define MIN(a,b) (((a) < (b)) ? (a) : (b))\n#endif\n#ifndef MAX\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\n#endif\n#define CMP_NUM(a,b)    (((a) < (b)) ? -1 : ((a) == (b)) ? 0 : 1)\n#ifdef USE_RAID\n/*\n  The following is done with a if to not get problems with pre-processors\n  with late define evaluation\n*/\n#if defined(SIZEOF_OFF_T) && SIZEOF_OFF_T == 4\n#define SYSTEM_SIZEOF_OFF_T 4\n#else\n#define SYSTEM_SIZEOF_OFF_T 8\n#endif\n#undef  SIZEOF_OFF_T\n#define SIZEOF_OFF_T\t    8\n#else\n#define SYSTEM_SIZEOF_OFF_T SIZEOF_OFF_T\n#endif /* USE_RAID */\n\n#if defined(SIZEOF_OFF_T) && SIZEOF_OFF_T > 4\ntypedef ulonglong my_off_t;\n#else\ntypedef unsigned long my_off_t;\n#endif\n#define MY_FILEPOS_ERROR\t(~(my_off_t) 0)\n#ifndef _WIN32\ntypedef off_t os_off_t;\n#endif\n\n#if defined(_WIN32)\n#define socket_errno\tWSAGetLastError()\n#define SOCKET_EINTR\tWSAEINTR \n#define SOCKET_EAGAIN\tWSAEWOULDBLOCK\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK\n#else /* Unix */\n#define socket_errno\terrno\n#define closesocket(A)\tclose(A)\n#define SOCKET_EINTR\tEINTR\n#define SOCKET_EAGAIN\tEAGAIN\n#define SOCKET_EWOULDBLOCK EWOULDBLOCK\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#endif\n\ntypedef uint8\t\tint7;\t/* Most effective integer 0 <= x <= 127 */\ntypedef short\t\tint15;\t/* Most effective integer 0 <= x <= 32767 */\ntypedef char\t\t*my_string; /* String of characters */\ntypedef unsigned long\tsize_s; /* Size of strings (In string-funcs) */\ntypedef int\t\tmyf;\t/* Type of MyFlags in my_funcs */\ntypedef char\t\tmy_bool; /* Small bool */\ntypedef unsigned long long my_ulonglong;\n#if !defined(bool) && !defined(bool_defined) && (!defined(HAVE_BOOL) || !defined(__cplusplus))\ntypedef char\t\tbool;\t/* Ordinary boolean values 0 1 */\n#endif\n\t/* Macros for converting *constants* to the right type */\n#define INT8(v)\t\t(int8) (v)\n#define INT16(v)\t(int16) (v)\n#define INT32(v)\t(int32) (v)\n#define MYF(v)\t\t(myf) (v)\n\n/*\n  Defines to make it possible to prioritize register assignments. No\n  longer that important with modern compilers.\n*/\n#ifndef USING_X\n#define reg1 register\n#define reg2 register\n#define reg3 register\n#define reg4 register\n#define reg5 register\n#define reg6 register\n#define reg7 register\n#define reg8 register\n#define reg9 register\n#define reg10 register\n#define reg11 register\n#define reg12 register\n#define reg13 register\n#define reg14 register\n#define reg15 register\n#define reg16 register\n#endif\n\n/* Defines for time function */\n#define SCALE_SEC\t100\n#define SCALE_USEC\t10000\n#define MY_HOW_OFTEN_TO_ALARM\t2\t/* How often we want info on screen */\n#define MY_HOW_OFTEN_TO_WRITE\t1000\t/* How often we want info on screen */\n\n#define NOT_FIXED_DEC 31\n\n#if defined(_WIN32) && defined(_MSVC)\n#define MYSQLND_LLU_SPEC \"%I64u\"\n#define MYSQLND_LL_SPEC \"%I64d\"\n#ifndef L64\n#define L64(x) x##i64\n#endif\n#else\n#define MYSQLND_LLU_SPEC \"%llu\"\n#define MYSQLND_LL_SPEC \"%lld\"\n#ifndef L64\n#define L64(x) x##LL\n#endif /* L64 */\n#endif /* _WIN32 */\n/*\n** Define-funktions for reading and storing in machine independent format\n**  (low byte first)\n*/\n\n/* Optimized store functions for Intel x86 */\n#define int1store(T,A) *((int8*) (T)) = (A)\n#define uint1korr(A)   (*(((uint8*)(A))))\n#if defined(__i386__) || defined(_WIN32)\n#define sint2korr(A)\t(*((int16 *) (A)))\n#define sint3korr(A)\t((int32) ((((uchar) (A)[2]) & 128) ? \\\n\t\t\t\t  (((uint32) 255L << 24) | \\\n\t\t\t\t   (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t   (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t   ((uint32) (uchar) (A)[0])) : \\\n\t\t\t\t  (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t  (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t  ((uint32) (uchar) (A)[0])))\n#define sint4korr(A)\t(*((long *) (A)))\n#define uint2korr(A)\t(*((uint16 *) (A)))\n#if defined(HAVE_purify) && !defined(_WIN32)\n#define uint3korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16))\n#else\n/*\n   ATTENTION !\n   \n    Please, note, uint3korr reads 4 bytes (not 3) !\n    It means, that you have to provide enough allocated space !\n*/\n#define uint3korr(A)\t(long) (*((unsigned int *) (A)) & 0xFFFFFF)\n#endif /* HAVE_purify && !_WIN32 */\n#define uint4korr(A)\t(*((uint32 *) (A)))\n#define uint5korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t\t    (((ulonglong) ((uchar) (A)[4])) << 32))\n#define uint6korr(A)\t((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \\\n                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \\\n                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \\\n                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \\\n                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \\\n                         (((ulonglong) ((uchar) (A)[5])) << 40))\n#define uint8korr(A)\t(*((ulonglong *) (A)))\n#define sint8korr(A)\t(*((longlong *) (A)))\n#define int2store(T,A)\t*((uint16*) (T))= (uint16) (A)\n#define int3store(T,A)  do { *(T)=  (uchar) ((A));\\\n                            *(T+1)=(uchar) (((uint) (A) >> 8));\\\n                            *(T+2)=(uchar) (((A) >> 16)); } while (0)\n#define int4store(T,A)\t*((long *) (T))= (long) (A)\n#define int5store(T,A)  do { *(T)= (uchar)((A));\\\n                             *((T)+1)=(uchar) (((A) >> 8));\\\n                             *((T)+2)=(uchar) (((A) >> 16));\\\n                             *((T)+3)=(uchar) (((A) >> 24)); \\\n                             *((T)+4)=(uchar) (((A) >> 32)); } while(0)\n#define int6store(T,A)  do { *(T)=    (uchar)((A));          \\\n                             *((T)+1)=(uchar) (((A) >> 8));  \\\n                             *((T)+2)=(uchar) (((A) >> 16)); \\\n                             *((T)+3)=(uchar) (((A) >> 24)); \\\n                             *((T)+4)=(uchar) (((A) >> 32)); \\\n                             *((T)+5)=(uchar) (((A) >> 40)); } while(0)\n#define int8store(T,A)\t*((ulonglong *) (T))= (ulonglong) (A)\n\ntypedef union {\n  double v;\n  long m[2];\n} doubleget_union;\n#define doubleget(V,M)\t\\\ndo { doubleget_union _tmp; \\\n     _tmp.m[0] = *((long*)(M)); \\\n     _tmp.m[1] = *(((long*) (M))+1); \\\n     (V) = _tmp.v; } while(0)\n#define doublestore(T,V) do { *((long *) T) = ((doubleget_union *)&V)->m[0]; \\\n\t\t\t     *(((long *) T)+1) = ((doubleget_union *)&V)->m[1]; \\\n                         } while (0)\n#define float4get(V,M)   do { *((float *) &(V)) = *((float*) (M)); } while(0)\n#define float8get(V,M)   doubleget((V),(M))\n#define float4store(V,M) memcpy((uchar*) V,(uchar*) (&M),sizeof(float))\n#define floatstore(T,V)  memcpy((uchar*)(T), (uchar*)(&V),sizeof(float))\n#define floatget(V,M)    memcpy((uchar*) &V,(uchar*) (M),sizeof(float))\n#define float8store(V,M) doublestore((V),(M))\n#else\n\n/*\n  We're here if it's not a IA-32 architecture (Win32 and UNIX IA-32 defines\n  were done before)\n*/\n#define sint2korr(A)\t(int16) (((int16) ((uchar) (A)[0])) +\\\n\t\t\t\t ((int16) ((int16) (A)[1]) << 8))\n#define sint3korr(A)\t((int32) ((((uchar) (A)[2]) & 128) ? \\\n\t\t\t\t  (((uint32) 255L << 24) | \\\n\t\t\t\t   (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t   (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t   ((uint32) (uchar) (A)[0])) : \\\n\t\t\t\t  (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t  (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t  ((uint32) (uchar) (A)[0])))\n#define sint4korr(A)\t(int32) (((int32) ((uchar) (A)[0])) +\\\n\t\t\t\t(((int32) ((uchar) (A)[1]) << 8)) +\\\n\t\t\t\t(((int32) ((uchar) (A)[2]) << 16)) +\\\n\t\t\t\t(((int32) ((int16) (A)[3]) << 24)))\n#define sint8korr(A)\t(longlong) uint8korr(A)\n#define uint2korr(A)\t(uint16) (((uint16) ((uchar) (A)[0])) +\\\n\t\t\t\t  ((uint16) ((uchar) (A)[1]) << 8))\n#define uint3korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16))\n#define uint4korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[3])) << 24))\n#define uint5korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t\t    (((ulonglong) ((uchar) (A)[4])) << 32))\n#define uint6korr(A)\t((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \\\n                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \\\n                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \\\n                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \\\n                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \\\n                         (((ulonglong) ((uchar) (A)[5])) << 40))\n#define uint8korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t(((ulonglong) (((uint32) ((uchar) (A)[4])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[5])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[6])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[7])) << 24))) <<\\\n\t\t\t\t    32))\n#define int2store(T,A)       do { uint def_temp= (uint) (A) ;\\\n                                  *((uchar*) (T))=  (uchar)(def_temp); \\\n                                   *((uchar*) (T)+1)=(uchar)((def_temp >> 8)); \\\n                             } while(0)\n#define int3store(T,A)       do { /*lint -save -e734 */\\\n                                  *((uchar*)(T))=(uchar) ((A));\\\n                                  *((uchar*) (T)+1)=(uchar) (((A) >> 8));\\\n                                  *((uchar*)(T)+2)=(uchar) (((A) >> 16)); \\\n                                  /*lint -restore */} while(0)\n#define int4store(T,A)       do { *((char *)(T))=(char) ((A));\\\n                                  *(((char *)(T))+1)=(char) (((A) >> 8));\\\n                                  *(((char *)(T))+2)=(char) (((A) >> 16));\\\n                                  *(((char *)(T))+3)=(char) (((A) >> 24)); } while(0)\n#define int5store(T,A)       do { *((char *)(T))=     (char)((A));  \\\n                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \\\n                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \\\n                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \\\n                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \\\n\t\t                } while(0)\n#define int6store(T,A)       do { *((char *)(T))=     (char)((A)); \\\n                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \\\n                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \\\n                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \\\n                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \\\n                                  *(((char *)(T))+5)= (char)(((A) >> 40)); \\\n                                } while(0)\n#define int8store(T,A)       do { uint def_temp= (uint) (A), def_temp2= (uint) ((A) >> 32); \\\n                                  int4store((T),def_temp); \\\n                                  int4store((T+4),def_temp2); } while(0)\n#ifdef HAVE_BIGENDIAN\n#define float4store(T,A) do { *(T)= ((uchar *) &A)[3];\\\n                              *((T)+1)=(char) ((uchar *) &A)[2];\\\n                              *((T)+2)=(char) ((uchar *) &A)[1];\\\n                              *((T)+3)=(char) ((uchar *) &A)[0]; } while(0)\n\n#define float4get(V,M)   do { float def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[3];\\\n                              ((uchar*) &def_temp)[1]=(M)[2];\\\n                              ((uchar*) &def_temp)[2]=(M)[1];\\\n                              ((uchar*) &def_temp)[3]=(M)[0];\\\n                              (V)=def_temp; } while(0)\n#define float8store(T,V) do { *(T)= ((uchar *) &V)[7];\\\n                              *((T)+1)=(char) ((uchar *) &V)[6];\\\n                              *((T)+2)=(char) ((uchar *) &V)[5];\\\n                              *((T)+3)=(char) ((uchar *) &V)[4];\\\n                              *((T)+4)=(char) ((uchar *) &V)[3];\\\n                              *((T)+5)=(char) ((uchar *) &V)[2];\\\n                              *((T)+6)=(char) ((uchar *) &V)[1];\\\n                              *((T)+7)=(char) ((uchar *) &V)[0]; } while(0)\n\n#define float8get(V,M)   do { double def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[7];\\\n                              ((uchar*) &def_temp)[1]=(M)[6];\\\n                              ((uchar*) &def_temp)[2]=(M)[5];\\\n                              ((uchar*) &def_temp)[3]=(M)[4];\\\n                              ((uchar*) &def_temp)[4]=(M)[3];\\\n                              ((uchar*) &def_temp)[5]=(M)[2];\\\n                              ((uchar*) &def_temp)[6]=(M)[1];\\\n                              ((uchar*) &def_temp)[7]=(M)[0];\\\n                              (V) = def_temp; } while(0)\n#else\n#define float4get(V,M)   memcpy(&V, (M), sizeof(float))\n#define float4store(V,M) memcpy(V, (&M), sizeof(float))\n\n#if defined(__FLOAT_WORD_ORDER) && (__FLOAT_WORD_ORDER == __BIG_ENDIAN)\n#define doublestore(T,V) do { *(((char*)T)+0)=(char) ((uchar *) &V)[4];\\\n                              *(((char*)T)+1)=(char) ((uchar *) &V)[5];\\\n                              *(((char*)T)+2)=(char) ((uchar *) &V)[6];\\\n                              *(((char*)T)+3)=(char) ((uchar *) &V)[7];\\\n                              *(((char*)T)+4)=(char) ((uchar *) &V)[0];\\\n                              *(((char*)T)+5)=(char) ((uchar *) &V)[1];\\\n                              *(((char*)T)+6)=(char) ((uchar *) &V)[2];\\\n                              *(((char*)T)+7)=(char) ((uchar *) &V)[3]; }\\\n                         while(0)\n#define doubleget(V,M)   do { double def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[4];\\\n                              ((uchar*) &def_temp)[1]=(M)[5];\\\n                              ((uchar*) &def_temp)[2]=(M)[6];\\\n                              ((uchar*) &def_temp)[3]=(M)[7];\\\n                              ((uchar*) &def_temp)[4]=(M)[0];\\\n                              ((uchar*) &def_temp)[5]=(M)[1];\\\n                              ((uchar*) &def_temp)[6]=(M)[2];\\\n                              ((uchar*) &def_temp)[7]=(M)[3];\\\n                              (V) = def_temp; } while(0)\n#endif /* __FLOAT_WORD_ORDER */\n\n#define float8get(V,M)   doubleget((V),(M))\n#define float8store(V,M) doublestore((V),(M))\n#endif /* WORDS_BIGENDIAN */\n\n#endif /* __i386__ OR _WIN32 */\n\n/*\n  Macro for reading 32-bit integer from network byte order (big-endian)\n  from unaligned memory location.\n*/\n#define int4net(A)        (int32) (((uint32) ((uchar) (A)[3]))        |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 8)  |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 16) |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[0])) << 24))\n/*\n  Define-funktions for reading and storing in machine format from/to\n  short/long to/from some place in memory V should be a (not\n  register) variable, M is a pointer to byte\n*/\n\n#ifdef HAVE_BIGENDIAN\n\n#define ushortget(V,M)  do { V = (uint16) (((uint16) ((uchar) (M)[1]))+\\\n                                 ((uint16) ((uint16) (M)[0]) << 8)); } while(0)\n#define shortget(V,M)   do { V = (short) (((short) ((uchar) (M)[1]))+\\\n                                 ((short) ((short) (M)[0]) << 8)); } while(0)\n#define longget(V,M)    do { int32 def_temp;\\\n                             ((uchar*) &def_temp)[0]=(M)[0];\\\n                             ((uchar*) &def_temp)[1]=(M)[1];\\\n                             ((uchar*) &def_temp)[2]=(M)[2];\\\n                             ((uchar*) &def_temp)[3]=(M)[3];\\\n                             (V)=def_temp; } while(0)\n#define ulongget(V,M)   do { uint32 def_temp;\\\n                            ((uchar*) &def_temp)[0]=(M)[0];\\\n                            ((uchar*) &def_temp)[1]=(M)[1];\\\n                            ((uchar*) &def_temp)[2]=(M)[2];\\\n                            ((uchar*) &def_temp)[3]=(M)[3];\\\n                            (V)=def_temp; } while(0)\n#define shortstore(T,A) do { uint def_temp=(uint) (A) ;\\\n                             *(((char*)T)+1)=(char)(def_temp); \\\n                             *(((char*)T)+0)=(char)(def_temp >> 8); } while(0)\n#define longstore(T,A)  do { *(((char*)T)+3)=((A));\\\n                             *(((char*)T)+2)=(((A) >> 8));\\\n                             *(((char*)T)+1)=(((A) >> 16));\\\n                             *(((char*)T)+0)=(((A) >> 24)); } while(0)\n\n#define floatget(V,M)    memcpy(&V, (M), sizeof(float))\n#define floatstore(T,V)  memcpy((T), (void*) (&V), sizeof(float))\n#define doubleget(V,M)\t memcpy(&V, (M), sizeof(double))\n#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))\n#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))\n#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))\n\n#else\n\n#define ushortget(V,M)\tdo { V = uint2korr(M); } while(0)\n#define shortget(V,M)\tdo { V = sint2korr(M); } while(0)\n#define longget(V,M)\tdo { V = sint4korr(M); } while(0)\n#define ulongget(V,M)   do { V = uint4korr(M); } while(0)\n#define shortstore(T,V) int2store(T,V)\n#define longstore(T,V)\tint4store(T,V)\n#ifndef floatstore\n#define floatstore(T,V)  memcpy((T), (void *) (&V), sizeof(float))\n#define floatget(V,M)    memcpy(&V, (M), sizeof(float))\n#endif\n#ifndef doubleget\n#define doubleget(V,M)\t memcpy(&V, (M), sizeof(double))\n#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))\n#endif /* doubleget */\n#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))\n#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))\n\n#endif /* WORDS_BIGENDIAN */\n\n#ifndef THREAD\n#define thread_safe_increment(V,L) (V)++\n#define thread_safe_add(V,C,L)     (V)+=(C)\n#define thread_safe_sub(V,C,L)     (V)-=(C)\n#define statistic_increment(V,L)   (V)++\n#define statistic_add(V,C,L)       (V)+=(C)\n#endif\n\n#ifdef _WIN32\n#define SO_EXT \".dll\"\n#else\n#define SO_EXT \".so\"\n#endif\n\n#ifndef DBUG_OFF\n#define dbug_assert(A) assert(A)\n#define DBUG_ASSERT(A) assert(A)\n#else\n#define dbug_assert(A)\n#define DBUG_ASSERT(A)\n#endif\n\n#ifdef HAVE_DLOPEN\n#ifdef _WIN32\n#define dlsym(lib, name) GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\n#elif defined(HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n#ifndef HAVE_DLERROR\n#define dlerror() \"\"\n#endif\n#endif\n\n#if SIZEOF_CHARP == SIZEOF_INT\ntypedef unsigned int intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG\ntypedef unsigned long intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG_LONG\ntypedef unsigned long long intptr;\n#else\n#error sizeof(void *) is not sizeof(int, long or long long)\n#endif\n\n#ifdef _WIN32\n#define IF_WIN(A,B) A \n#else\n#define IF_WIN(A,B) B \n#endif\n\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n\n#endif /* _global_h */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-c-client-3.0.9-5x5r7t2wfli2nvkxgtyu44kb5fljezxr/spack-src/plugins/auth/dialog.c": "/************************************************************************************\n   Copyright (C) 2014-2018 MariaDB Corporation AB\n   \n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n   \n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not see <http://www.gnu.org/licenses>\n   or write to the Free Software Foundation, Inc., \n   51 Franklin St., Fifth Floor, Boston, MA 02110, USA\n*************************************************************************************/\n#ifndef _WIN32\n#define _GNU_SOURCE 1\n#endif\n\n#include <ma_global.h>\n#include <mysql.h>\n#include <mysql/client_plugin.h>\n#include <string.h>\n#include <memory.h>\n\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n\n\n/* function prototypes */\nextern char *get_tty_password(char *opt_message, char *buff, int bufflen);\nstatic int auth_dialog_open(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql);\nstatic int auth_dialog_init(char *unused1,\n                            size_t unused2,\n                            int unused3,\n                            va_list);\n\nmysql_authentication_dialog_ask_t auth_dialog_func;\n\n#ifndef PLUGIN_DYNAMIC\nstruct st_mysql_client_plugin_AUTHENTICATION dialog_client_plugin=\n#else\nstruct st_mysql_client_plugin_AUTHENTICATION _mysql_client_plugin_declaration_ =\n#endif\n{\n  MYSQL_CLIENT_AUTHENTICATION_PLUGIN,\n  MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION,\n  \"dialog\",\n  \"Sergei Golubchik, Georg Richter\",\n  \"Dialog Client Authentication Plugin\",\n  {0,1,0},\n  \"LGPL\",\n  NULL,\n  auth_dialog_init,\n  NULL,\n  NULL,\n  auth_dialog_open\n};\n\n\n/* {{{ static char *auth_dialog_native_prompt */\n/*\n   Native dialog prompt via stdin\n\n   SYNOPSIS\n     auth_dialog_native_prompt\n     mysql            connection handle\n     type             input type\n     prompt           prompt\n     buffer           Input buffer\n     buffer_len       Input buffer length\n\n  DESCRIPTION\n    \n  RETURNS\n    Input buffer\n*/\nstatic char *auth_dialog_native_prompt(MYSQL *mysql __attribute__((unused)),\n                                       int type,\n                                       const char *prompt,\n                                       char *buffer,\n                                       int buffer_len)\n{\n  /* display prompt */\n  fprintf(stdout, \"%s\", prompt);\n\n  memset(buffer, 0, buffer_len);\n\n  /* for type 2 (password) don't display input */\n  if (type != 2)\n  {\n    if (fgets(buffer, buffer_len - 1, stdin))\n    {\n      /* remove trailing line break */\n      size_t length= strlen(buffer);\n      if (length && buffer[length - 1] == '\\n')\n        buffer[length - 1]= 0;\n    }\n  }\n  else\n  {\n    get_tty_password((char *)\"\", buffer, buffer_len - 1);\n  }\n  return buffer;\n}\n/* }}} */\n\n/* {{{ static int auth_dialog_open */\n/*\n   opens dialog\n\n   SYNOPSIS\n     vio           Vio\n     mysql         connection handle\n\n   DESCRIPTION\n     reads prompt from server, waits for input and sends\n     input to server.\n     Note that first byte of prompt indicates if we have a \n     password which should not be echoed to stdout.\n\n   RETURN\n     CR_ERROR      if an error occurs\n     CR_OK\n     CR_OK_HANDSHAKE_COMPLETE\n*/\nstatic int auth_dialog_open(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql)\n{\n  uchar *packet;\n  uchar type= 0;\n  char dialog_buffer[1024];\n  char *response;\n  int packet_length;\n  my_bool first_loop= TRUE;\n\n  do {\n    if ((packet_length= vio->read_packet(vio, &packet)) == -1)\n      /* read error */\n      return CR_ERROR;\n\n    if (packet_length > 0)\n    {\n      type= *packet;\n      packet++;\n\n      /* check for protocol packet */\n      if (!type || type == 254)\n        return CR_OK_HANDSHAKE_COMPLETE;\n\n      if ((type >> 1) == 2 &&\n          first_loop &&\n          mysql->passwd && mysql->passwd[0])\n        response= mysql->passwd;\n      else\n        response= auth_dialog_func(mysql, type >> 1,\n                                  (const char *)packet,\n                                  dialog_buffer, 1024);\n    }\n    else\n    {\n      /* in case mysql_change_user was called the client needs\n         to send packet first */\n      response= mysql->passwd;\n    }\n    if (!response ||\n        vio->write_packet(vio, (uchar *)response, (int)strlen(response) + 1))\n      return CR_ERROR;\n\n    first_loop= FALSE;\n\n  } while((type & 1) != 1);\n  return CR_OK;\n}\n/* }}} */\n\n/* {{{ static int auth_dialog_init */\n/* \n  Initialization routine\n\n  SYNOPSIS\n    auth_dialog_init\n      unused1\n      unused2\n      unused3\n      unused4\n\n  DESCRIPTION\n    Init function checks if the caller provides own dialog function.\n    The function name must be mariadb_auth_dialog or\n    mysql_authentication_dialog_ask. If the function cannot be found,\n    we will use owr own simple command line input.\n\n  RETURN\n    0           success\n*/\nstatic int auth_dialog_init(char *unused1 __attribute__((unused)), \n                            size_t unused2  __attribute__((unused)), \n                            int unused3     __attribute__((unused)), \n                            va_list unused4 __attribute__((unused)))\n{\n  void *func;\n#ifdef WIN32\n  if (!(func= GetProcAddress(GetModuleHandle(NULL), \"mariadb_auth_dialog\")))\n    /* for MySQL users */\n    func= GetProcAddress(GetModuleHandle(NULL), \"mysql_authentication_dialog_ask\");\n#else\n  if (!(func= dlsym(RTLD_DEFAULT, \"mariadb_auth_dialog\")))\n    /* for MySQL users */\n    func= dlsym(RTLD_DEFAULT, \"mysql_authentication_dialog_ask\");\n#endif\n  if (func)\n    auth_dialog_func= (mysql_authentication_dialog_ask_t)func;\n  else\n    auth_dialog_func= auth_dialog_native_prompt;\n\n  return 0;\n}\n/* }}} */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-c-client-3.0.9-5x5r7t2wfli2nvkxgtyu44kb5fljezxr/spack-src/plugins/trace/trace_example.c": "/************************************************************************************\n   Copyright (C) 2015 MariaDB Corporation AB\n   \n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n   \n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not see <http://www.gnu.org/licenses>\n   or write to the Free Software Foundation, Inc., \n   51 Franklin St., Fifth Floor, Boston, MA 02110, USA\n*************************************************************************************/\n#ifndef _WIN32\n#define _GNU_SOURCE 1\n#endif\n\n#include <ma_global.h>\n#include <mysql.h>\n#include <mysql/client_plugin.h>\n#include <string.h>\n#include <memory.h>\n\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n\n#define READ  0\n#define WRITE 1\n\n/* function prototypes */\nstatic int trace_init(char *errormsg, \n                      size_t errormsg_size,\n                      int unused      __attribute__((unused)), \n                      va_list unused1 __attribute__((unused)));\nstatic int trace_deinit(void);\n\nint (*register_callback)(my_bool register_callback, \n                         void (*callback_function)(int mode, MYSQL *mysql, const uchar *buffer, size_t length));\nvoid trace_callback(int mode, MYSQL *mysql, const uchar *buffer, size_t length);\n\n#ifndef HAVE_TRACE_EXAMPLE_PLUGIN_DYNAMIC\nstruct st_mysql_client_plugin trace_example_plugin=\n#else\nstruct st_mysql_client_plugin _mysql_client_plugin_declaration_ =\n#endif\n{\n  MARIADB_CLIENT_TRACE_PLUGIN,\n  MARIADB_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION,\n  \"trace_example\",\n  \"Georg Richter\",\n  \"Trace example plugin\",\n  {1,0,0},\n  \"LGPL\",\n  NULL,\n  &trace_init,\n  &trace_deinit,\n  NULL\n};\n\nstatic const char *commands[]= {\n  \"COM_SLEEP\",\n  \"COM_QUIT\",\n  \"COM_INIT_DB\",\n  \"COM_QUERY\",\n  \"COM_FIELD_LIST\",\n  \"COM_CREATE_DB\",\n  \"COM_DROP_DB\",\n  \"COM_REFRESH\",\n  \"COM_SHUTDOWN\",\n  \"COM_STATISTICS\",\n  \"COM_PROCESS_INFO\",\n  \"COM_CONNECT\",\n  \"COM_PROCESS_KILL\",\n  \"COM_DEBUG\",\n  \"COM_PING\",\n  \"COM_TIME\",\n  \"COM_DELAYED_INSERT\",\n  \"COM_CHANGE_USER\",\n  \"COM_BINLOG_DUMP\",\n  \"COM_TABLE_DUMP\",\n  \"COM_CONNECT_OUT\",\n  \"COM_REGISTER_SLAVE\",\n  \"COM_STMT_PREPARE\",\n  \"COM_STMT_EXECUTE\",\n  \"COM_STMT_SEND_LONG_DATA\",\n  \"COM_STMT_CLOSE\",\n  \"COM_STMT_RESET\",\n  \"COM_SET_OPTION\",\n  \"COM_STMT_FETCH\",\n  \"COM_DAEMON\",\n  \"COM_MULTI\",\n  \"COM_END\"\n};\n\ntypedef struct {\n  unsigned long thread_id;\n  int last_command; /* COM_* values, -1 for handshake */\n  unsigned int max_packet_size;\n  unsigned int num_commands;\n  size_t total_size[2];\n  unsigned int client_flags;\n  char *username;\n  char *db;\n  char *command;\n  char *filename;\n  unsigned long refid; /* stmt_id, thread_id for kill */\n  uchar charset;\n  void *next;\n  int local_infile;\n  unsigned long pkt_length;\n} TRACE_INFO;\n\n#define TRACE_STATUS(a) (!a) ? \"ok\" : \"error\"\n\nTRACE_INFO *trace_info= NULL;\n\nstatic TRACE_INFO *get_trace_info(unsigned long thread_id)\n{\n  TRACE_INFO *info= trace_info;\n\n  /* search connection */\n  while (info)\n  {\n    if (info->thread_id == thread_id)\n      return info;\n    else\n      info= (TRACE_INFO *)info->next;\n  }\n\n  if (!(info= (TRACE_INFO *)calloc(sizeof(TRACE_INFO), 1)))\n    return NULL;\n  info->thread_id= thread_id;\n  info->next= trace_info;\n  trace_info= info;\n  return info;\n}\n\nstatic void delete_trace_info(unsigned long thread_id)\n{\n  TRACE_INFO *last= NULL, *current;\n  current= trace_info;\n\n  while (current)\n  {\n    if (current->thread_id == thread_id)\n    {\n      printf(\"deleting thread %lu\\n\", thread_id);\n\n      if (last)\n        last->next= current->next;\n      else\n        trace_info= (TRACE_INFO *)current->next;\n      if (current->command)\n        free(current->command);\n      if (current->db)\n        free(current->db);\n      if (current->username)\n        free(current->username);\n      if (current->filename)\n        free(current->filename);\n      free(current);\n    }\n    last= current;\n    current= (TRACE_INFO *)current->next;\n  }\n\n}\n\n\n/* {{{ static int trace_init */\n/* \n  Initialization routine\n\n  SYNOPSIS\n    trace_init\n      unused1\n      unused2\n      unused3\n      unused4\n\n  DESCRIPTION\n    Init function registers a callback handler for PVIO interface.\n\n  RETURN\n    0           success\n*/\nstatic int trace_init(char *errormsg, \n                      size_t errormsg_size,\n                      int unused1 __attribute__((unused)), \n                      va_list unused2 __attribute__((unused)))\n{\n  void *func;\n\n#ifdef WIN32\n  if (!(func= GetProcAddress(GetModuleHandle(NULL), \"ma_pvio_register_callback\")))\n#else\n  if (!(func= dlsym(RTLD_DEFAULT, \"ma_pvio_register_callback\")))\n#endif\n  {\n    strncpy(errormsg, \"Can't find ma_pvio_register_callback function\", errormsg_size);\n    return 1;\n  }\n  register_callback= func;\n  register_callback(TRUE, trace_callback);\n\n  return 0;\n}\n/* }}} */\n\nstatic int trace_deinit()\n{\n  /* unregister plugin */\n  while(trace_info)\n  {\n    printf(\"Warning: Connection for thread %lu not properly closed\\n\", trace_info->thread_id);\n    trace_info= (TRACE_INFO *)trace_info->next;\n  }\n  register_callback(FALSE, trace_callback);\n  return 0;\n}\n\nstatic void trace_set_command(TRACE_INFO *info, char *buffer, size_t size)\n{\n  if (info->command)\n    free(info->command);\n\n  info->command= calloc(1, size + 1);\n  memcpy(info->command, buffer, size);\n}\n\nvoid dump_buffer(uchar *buffer, size_t len)\n{\n  uchar *p= buffer;\n  while (p < buffer + len)\n  {\n    printf(\"%02x \", *p);\n    p++;\n  }\n  printf(\"\\n\");\n}\n\nstatic void dump_simple(TRACE_INFO *info, my_bool is_error)\n{\n  printf(\"%8lu: %s %s\\n\", info->thread_id, commands[info->last_command], TRACE_STATUS(is_error));\n}\n\nstatic void dump_reference(TRACE_INFO *info, my_bool is_error)\n{\n  printf(\"%8lu: %s(%lu) %s\\n\", info->thread_id, commands[info->last_command], (long)info->refid, TRACE_STATUS(is_error));\n}\n\nstatic void dump_command(TRACE_INFO *info, my_bool is_error)\n{\n  size_t i;\n  printf(\"%8lu: %s(\",  info->thread_id, commands[info->last_command]);\n  for (i= 0; info->command && i < strlen(info->command); i++)\n    if (info->command[i] == '\\n')\n      printf(\"\\\\n\");\n    else if (info->command[i] == '\\r')\n      printf(\"\\\\r\");\n    else if (info->command[i] == '\\t')\n      printf(\"\\\\t\");\n    else\n      printf(\"%c\", info->command[i]);\n  printf(\") %s\\n\", TRACE_STATUS(is_error));\n}\n\nvoid trace_callback(int mode, MYSQL *mysql, const uchar *buffer, size_t length)\n{\n  unsigned long thread_id= mysql->thread_id;\n  TRACE_INFO *info;\n\n  /* check if package is server greeting package,\n   * and set thread_id */\n  if (!thread_id && mode == READ)\n  {\n    char *p= (char *)buffer;\n    p+= 4; /* packet length */\n    if ((uchar)*p != 0xFF) /* protocol version 0xFF indicates error */\n    {\n      p+= strlen(p + 1) + 2;\n      thread_id= uint4korr(p);\n    }\n    info= get_trace_info(thread_id);\n    info->last_command= -1;\n  }\n  else\n  {\n    char *p= (char *)buffer;\n    info= get_trace_info(thread_id);\n\n    if (info->last_command == -1)\n    {\n      if (mode == WRITE)\n      {\n        /* client authentication reply packet:\n         * \n         *  ofs description        length\n         *  ------------------------\n         *  0   length             3\n         *  3   packet_no          1\n         *  4   client capab.      4\n         *  8   max_packet_size    4\n         *  12  character set      1\n         *  13  reserved          23\n         *  ------------------------\n         *  36  username (zero terminated)\n         *      len (1 byte) + password or\n         */\n\n        p+= 4;\n        info->client_flags= uint4korr(p);\n        p+= 4;\n        info->max_packet_size= uint4korr(p);\n        p+= 4;\n        info->charset= *p;\n        p+= 24;\n        info->username= strdup(p);\n        p+= strlen(p) + 1;\n        if (*p) /* we are not interested in authentication data */\n          p+= *p;\n        p++;\n        if (info->client_flags & CLIENT_CONNECT_WITH_DB)\n          info->db= strdup(p);\n      }\n      else\n      {\n        p++;\n        if ((uchar)*p == 0xFF)\n          printf(\"%8lu: CONNECT_ERROR(%d)\\n\", info->thread_id, uint4korr(p+1));\n        else\n          printf(\"%8lu: CONNECT_SUCCESS(host=%s,user=%s,db=%s)\\n\", info->thread_id, \n                 mysql->host, info->username, info->db ? info->db : \"'none'\");\n        info->last_command= COM_SLEEP;\n      }\n    }\n    else {\n      char *p= (char *)buffer;\n      int len;\n\n      if (mode == WRITE)\n      {\n        if (info->pkt_length > 0)\n        {\n          info->pkt_length-= length;\n          return;\n        }\n        len= uint3korr(p);\n        info->pkt_length= len + 4 - length;\n        p+= 4;\n        info->last_command= *p;\n        p++;\n\n        switch (info->last_command) {\n        case COM_INIT_DB:\n        case COM_DROP_DB:\n        case COM_CREATE_DB:\n        case COM_DEBUG:\n        case COM_QUERY:\n        case COM_STMT_PREPARE:\n          trace_set_command(info, p, len - 1);\n          break;\n        case COM_PROCESS_KILL:\n          info->refid= uint4korr(p);\n          break;\n        case COM_QUIT:\n          printf(\"%8lu: COM_QUIT\\n\", info->thread_id);\n          delete_trace_info(info->thread_id);\n          break;\n        case COM_PING:\n          printf(\"%8lu: COM_PING\\n\", info->thread_id);\n          break;\n        case COM_STMT_EXECUTE:\n        case COM_STMT_RESET:\n        case COM_STMT_CLOSE:\n          info->refid= uint4korr(p);\n          break;\n        case COM_CHANGE_USER:\n          break;\n        default:\n          if (info->local_infile == 1)\n          {\n            printf(\"%8lu: SEND_LOCAL_INFILE(%s) \", info->thread_id, info->filename);\n            if (len)\n              printf(\"sent %d bytes\\n\", len);\n            else\n              printf(\"- error\\n\");\n            info->local_infile= 2;\n          }\n          else\n            printf(\"%8lu: UNKNOWN_COMMAND: %d\\n\", info->thread_id, info->last_command);\n          break;\n        }\n      }\n      else\n      {\n        my_bool is_error;\n\n        len= uint3korr(p);\n        p+= 4;\n\n        is_error= (len == -1);\n\n        switch(info->last_command) {\n        case COM_STMT_EXECUTE:\n        case COM_STMT_RESET:\n        case COM_STMT_CLOSE:\n        case COM_PROCESS_KILL:\n          dump_reference(info, is_error);\n          info->refid= 0;\n          info->last_command= 0;\n          break;\n        case COM_QUIT:\n          dump_simple(info, is_error);\n          break;\n        case COM_QUERY:\n        case COM_INIT_DB:\n        case COM_DROP_DB:\n        case COM_CREATE_DB:\n        case COM_DEBUG:\n        case COM_CHANGE_USER:\n          if (info->last_command == COM_QUERY && (uchar)*p == 251)\n          {\n            info->local_infile= 1;\n            p++;\n            info->filename= (char *)malloc(len);\n            strncpy(info->filename, (char *)p, len);\n            dump_command(info, is_error);\n            break;\n          }\n          dump_command(info, is_error);\n          if (info->local_infile != 1)\n          {\n            free(info->command);\n            info->command= NULL;\n          }\n          break;\n        case COM_STMT_PREPARE:\n          printf(\"%8lu: COM_STMT_PREPARE(%s) \", info->thread_id, info->command);\n          if (!*p)\n          {\n            unsigned long stmt_id= uint4korr(p+1);\n            printf(\"-> stmt_id(%lu)\\n\", stmt_id);\n          }\n          else\n            printf(\"error\\n\");\n          break;\n        }\n      }\n    }\n  }\n  info->total_size[mode]+= length;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-c-client-3.0.9-5x5r7t2wfli2nvkxgtyu44kb5fljezxr/spack-src/libmariadb/ma_client_plugin.c.in": "/* Copyright (C) 2010 - 2012 Sergei Golubchik and Monty Program Ab\n                 2015-2016 MariaDB Corporation AB\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n   \n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not see <http://www.gnu.org/licenses>\n   or write to the Free Software Foundation, Inc., \n   51 Franklin St., Fifth Floor, Boston, MA 02110, USA */\n\n/**\n  @file\n  \n  Support code for the client side (libmariadb) plugins\n\n  Client plugins are somewhat different from server plugins, they are simpler.\n\n  They do not need to be installed or in any way explicitly loaded on the\n  client, they are loaded automatically on demand.\n  One client plugin per shared object, soname *must* match the plugin name.\n\n  There is no reference counting and no unloading either.\n*/\n\n#if _MSC_VER\n/* Silence warnings about variable 'unused' being used. */\n#define FORCE_INIT_OF_VARS 1\n#endif\n\n#include <ma_global.h>\n#include <ma_sys.h>\n#include <ma_common.h> \n#include <ma_string.h>\n#include <ma_pthread.h>\n\n#include \"errmsg.h\"\n#include <mysql/client_plugin.h>\n\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n\nstruct st_client_plugin_int {\n  struct st_client_plugin_int *next;\n  void   *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n};\n\nstatic my_bool initialized= 0;\nstatic MA_MEM_ROOT mem_root;\n\nstatic uint valid_plugins[][2]= {\n  {MYSQL_CLIENT_AUTHENTICATION_PLUGIN, MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_PVIO_PLUGIN, MARIADB_CLIENT_PVIO_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_TRACE_PLUGIN, MARIADB_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_REMOTEIO_PLUGIN, MARIADB_CLIENT_REMOTEIO_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_CONNECTION_PLUGIN, MARIADB_CLIENT_CONNECTION_PLUGIN_INTERFACE_VERSION},\n  {0, 0}\n};\n\n/*\n  Loaded plugins are stored in a linked list.\n  The list is append-only, the elements are added to the head (like in a stack).\n  The elements are added under a mutex, but the list can be read and traversed\n  without any mutex because once an element is added to the list, it stays\n  there. The main purpose of a mutex is to prevent two threads from\n  loading the same plugin twice in parallel.\n*/\n\n\nstruct st_client_plugin_int *plugin_list[MYSQL_CLIENT_MAX_PLUGINS + MARIADB_CLIENT_MAX_PLUGINS];\n#ifdef THREAD\nstatic pthread_mutex_t LOCK_load_client_plugin;\n#endif\n\n@EXTERNAL_PLUGINS@\n\nstruct st_mysql_client_plugin *mysql_client_builtins[]=\n{\n  @BUILTIN_PLUGINS@\n  0\n};\n\n\nstatic int is_not_initialized(MYSQL *mysql, const char *name)\n{\n  if (initialized)\n    return 0;\n\n  my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n               SQLSTATE_UNKNOWN, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n               name, \"not initialized\");\n  return 1;\n}\n\nstatic int get_plugin_nr(uint type)\n{\n  uint i= 0;\n  for(; valid_plugins[i][1]; i++)\n    if (valid_plugins[i][0] == type)\n      return i;\n  return -1;\n}\n\nstatic const char *check_plugin_version(struct st_mysql_client_plugin *plugin, unsigned int version)\n{\n  if (plugin->interface_version < version ||\n      (plugin->interface_version >> 8) > (version >> 8))\n    return \"Incompatible client plugin interface\";\n  return 0;\n}\n\n/**\n  finds a plugin in the list\n\n  @param name   plugin name to search for\n  @param type   plugin type\n\n  @note this does NOT necessarily need a mutex, take care!\n  \n  @retval a pointer to a found plugin or 0\n*/\nstatic struct st_mysql_client_plugin *find_plugin(const char *name, int type)\n{\n  struct st_client_plugin_int *p;\n  int plugin_nr= get_plugin_nr(type);\n\n  DBUG_ASSERT(initialized);\n  if (plugin_nr == -1)\n    return 0;\n\n  if (!name)\n    return plugin_list[plugin_nr]->plugin;\n\n  for (p= plugin_list[plugin_nr]; p; p= p->next)\n  {\n    if (strcmp(p->plugin->name, name) == 0)\n      return p->plugin;\n  }\n  return NULL;\n}\n\n\n/**\n  verifies the plugin and adds it to the list\n\n  @param mysql          MYSQL structure (for error reporting)\n  @param plugin         plugin to install\n  @param dlhandle       a handle to the shared object (returned by dlopen)\n                        or 0 if the plugin was not dynamically loaded\n  @param argc           number of arguments in the 'va_list args'\n  @param args           arguments passed to the plugin initialization function\n\n  @retval a pointer to an installed plugin or 0\n*/\n\nstatic struct st_mysql_client_plugin *\nadd_plugin(MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n           int argc, va_list args)\n{\n  const char *errmsg;\n  struct st_client_plugin_int plugin_int, *p;\n  char errbuf[1024];\n  int plugin_nr;\n\n  DBUG_ASSERT(initialized);\n\n  plugin_int.plugin= plugin;\n  plugin_int.dlhandle= dlhandle;\n\n  if ((plugin_nr= get_plugin_nr(plugin->type)) == -1)\n  {\n    errmsg= \"Unknown client plugin type\";\n    goto err1;\n  }\n  if ((errmsg= check_plugin_version(plugin, valid_plugins[plugin_nr][1])))\n    goto err1;\n\n  /* Call the plugin initialization function, if any */\n  if (plugin->init && plugin->init(errbuf, sizeof(errbuf), argc, args))\n  {\n    errmsg= errbuf;\n    goto err1;\n  }\n\n  p= (struct st_client_plugin_int *)\n    ma_memdup_root(&mem_root, (char *)&plugin_int, sizeof(plugin_int));\n\n  if (!p)\n  {\n    errmsg= \"Out of memory\";\n    goto err2;\n  }\n\n\n  p->next= plugin_list[plugin_nr];\n  plugin_list[plugin_nr]= p;\n\n  return plugin;\n\nerr2:\n  if (plugin->deinit)\n    plugin->deinit();\nerr1:\n  my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, SQLSTATE_UNKNOWN,\n               ER(CR_AUTH_PLUGIN_CANNOT_LOAD), plugin->name, errmsg);\n  if (dlhandle)\n    (void)dlclose(dlhandle);\n  return NULL;\n}\n\n\n/**\n  Loads plugins which are specified in the environment variable\n  LIBMYSQL_PLUGINS.\n  \n  Multiple plugins must be separated by semicolon. This function doesn't\n  return or log an error.\n\n  The function is be called by mysql_client_plugin_init\n\n  @todo\n  Support extended syntax, passing parameters to plugins, for example\n  LIBMYSQL_PLUGINS=\"plugin1(param1,param2);plugin2;...\"\n  or\n  LIBMYSQL_PLUGINS=\"plugin1=int:param1,str:param2;plugin2;...\"\n*/\n\nstatic void load_env_plugins(MYSQL *mysql)\n{\n  char *plugs, *free_env, *s= getenv(\"LIBMYSQL_PLUGINS\");\n\n  if (ma_check_env_str(s))\n    return;\n\n  free_env= strdup(s);\n  plugs= s= free_env;\n\n  do {\n    if ((s= strchr(plugs, ';')))\n      *s= '\\0';\n    mysql_load_plugin(mysql, plugs, -1, 0);\n    plugs= s + 1;\n  } while (s);\n\n  free(free_env);\n}\n\n/********** extern functions to be used by libmariadb *********************/\n\n/**\n  Initializes the client plugin layer.\n\n  This function must be called before any other client plugin function.\n\n  @retval 0    successful\n  @retval != 0 error occurred\n*/\n\nint mysql_client_plugin_init()\n{\n  MYSQL mysql;\n  struct st_mysql_client_plugin **builtin;\n  va_list unused;\n  LINT_INIT_STRUCT(unused);\n\n  if (initialized)\n    return 0;\n\n  memset(&mysql, 0, sizeof(mysql)); /* dummy mysql for set_mysql_extended_error */\n\n  pthread_mutex_init(&LOCK_load_client_plugin, NULL);\n  ma_init_alloc_root(&mem_root, 128, 128);\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n\n  initialized= 1;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n  for (builtin= mysql_client_builtins; *builtin; builtin++)\n    add_plugin(&mysql, *builtin, 0, 0, unused);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n\n  load_env_plugins(&mysql);\n\n  return 0;\n}\n\n\n/**\n  Deinitializes the client plugin layer.\n\n  Unloades all client plugins and frees any associated resources.\n*/\n\nvoid mysql_client_plugin_deinit()\n{\n  int i;\n  struct st_client_plugin_int *p;\n\n  if (!initialized)\n    return;\n\n  for (i=0; i < MYSQL_CLIENT_MAX_PLUGINS; i++)\n    for (p= plugin_list[i]; p; p= p->next)\n    {\n      if (p->plugin->deinit)\n        p->plugin->deinit();\n      if (p->dlhandle)\n        (void)dlclose(p->dlhandle);\n    }\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n  initialized= 0;\n  ma_free_root(&mem_root, MYF(0));\n  pthread_mutex_destroy(&LOCK_load_client_plugin);\n}\n\n/************* public facing functions, for client consumption *********/\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_client_register_plugin(MYSQL *mysql,\n                             struct st_mysql_client_plugin *plugin)\n{\n  va_list unused;\n  LINT_INIT_STRUCT(unused);\n\n  if (is_not_initialized(mysql, plugin->name))\n    return NULL;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (find_plugin(plugin->name, plugin->type))\n  {\n    my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                 SQLSTATE_UNKNOWN, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                 plugin->name, \"it is already loaded\");\n    plugin= NULL;\n  }\n  else\n    plugin= add_plugin(mysql, plugin, 0, 0, unused);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n  return plugin;\n}\n\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_load_plugin_v(MYSQL *mysql, const char *name, int type,\n                    int argc, va_list args)\n{\n  const char *errmsg;\n#ifdef _WIN32\n  char errbuf[1024];\n#endif\n  char dlpath[FN_REFLEN+1];\n  void *sym, *dlhandle = NULL;\n  struct st_mysql_client_plugin *plugin;\n  char *env_plugin_dir= getenv(\"MARIADB_PLUGIN_DIR\");\n\n  CLEAR_CLIENT_ERROR(mysql);\n  if (is_not_initialized(mysql, name))\n    return NULL;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (type >= 0 && find_plugin(name, type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  /* Compile dll path */\n  snprintf(dlpath, sizeof(dlpath) - 1, \"%s/%s%s\",\n           mysql->options.extension && mysql->options.extension->plugin_dir ?\n           mysql->options.extension->plugin_dir : (env_plugin_dir) ? env_plugin_dir :\n           MARIADB_PLUGINDIR, name, SO_EXT);\n\n  /* Open new dll handle */\n  if (!(dlhandle= dlopen((const char *)dlpath, RTLD_NOW)))\n  {\n#ifdef _WIN32\n   char winmsg[255];\n   size_t len;\n   winmsg[0] = 0;\n   FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,\n                 NULL,\n                 GetLastError(),\n                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                 winmsg, 255, NULL);\n   len= strlen(winmsg);\n   while (len > 0 && (winmsg[len - 1] == '\\n' || winmsg[len - 1] == '\\r'))\n     len--;\n   if (len)\n     winmsg[len] = 0;\n   snprintf(errbuf, sizeof(errbuf), \"%s Library path is '%s'\", winmsg, dlpath);\n   errmsg= errbuf;\n#else\n    errmsg= dlerror();\n#endif\n    goto err;\n  }\n\n\n  if (!(sym= dlsym(dlhandle, plugin_declarations_sym)))\n  {\n    errmsg= \"not a plugin\";\n    (void)dlclose(dlhandle);\n    goto err;\n  }\n\n  plugin= (struct st_mysql_client_plugin*)sym;\n\n  if (type >=0 && type != plugin->type)\n  {\n    errmsg= \"type mismatch\";\n    goto err;\n  }\n\n  if (strcmp(name, plugin->name))\n  {\n    errmsg= \"name mismatch\";\n    goto err;\n  }\n\n  if (type < 0 && find_plugin(name, plugin->type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  plugin= add_plugin(mysql, plugin, dlhandle, argc, args);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n\n  return plugin;\n\nerr:\n  if (dlhandle)\n    dlclose(dlhandle);\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n  my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, SQLSTATE_UNKNOWN,\n               ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name, errmsg);\n  return NULL;\n}\n\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_load_plugin(MYSQL *mysql, const char *name, int type, int argc, ...)\n{\n  struct st_mysql_client_plugin *p;\n  va_list args;\n  va_start(args, argc);\n  p= mysql_load_plugin_v(mysql, name, type, argc, args);\n  va_end(args);\n  return p;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_client_find_plugin(MYSQL *mysql, const char *name, int type)\n{\n  struct st_mysql_client_plugin *p;\n  int plugin_nr= get_plugin_nr(type);\n\n  if (is_not_initialized(mysql, name))\n    return NULL;\n\n  if (plugin_nr == -1)\n  {\n    my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, SQLSTATE_UNKNOWN,\n                 ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name, \"invalid type\");\n  }\n\n  if ((p= find_plugin(name, type)))\n    return p;\n\n  /* not found, load it */\n  return mysql_load_plugin(mysql, name, type, 0);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-c-client-3.0.9-5x5r7t2wfli2nvkxgtyu44kb5fljezxr/spack-src/client/ma_plugin_info.c": "\n#include <my_global.h>\n#include <my_sys.h>\n#include <mysql.h>\n#include <mysql/client_plugin.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <my_dir.h>\n#include <ma_string.h>\n\n#define CLIENT_PLUGIN_INFO_VERSION \"1.0.0\"\n\nstatic struct option long_options[]=\n{\n  {\"all\", no_argument, 0, 'a'},\n  {\"builtin\", no_argument, 0, 'b'},\n  {\"dynamic\", no_argument, 0, 'd'},\n  {\"directory\", 1, 0, 'p'},\n  {\"plugin_name\", 1, 0, 'n'},\n  {\"version\", no_argument, 0, 'v'},\n  {\"help\", no_argument, 0, '?'},\n  {NULL, 0, 0, 0}\n};\n\nstatic char *values[] =\n{\n  \"show information for all plugins\",\n  \"show information for builtin plugins\",\n  \"show information for dynamic plugins\",\n  \"show information for dynamic plugins in specified directory\",\n  \"show information for specified plugin\",\n  \"show version information\",\n  \"display this help and exit\",\n  NULL\n};\n\nstruct st_plugin_type\n{\n  int type;\n  char *typename;\n};\n\n#ifndef _WIN32\nint my_errno=0;\n#endif\n\nstatic struct st_plugin_type plugin_types[]=\n{\n  {MYSQL_CLIENT_AUTHENTICATION_PLUGIN, \"authentication\"},\n  {MARIADB_CLIENT_PVIO_PLUGIN, \"virtual IO\"},\n  {MARIADB_CLIENT_TRACE_PLUGIN, \"trace\"},\n  {MARIADB_CLIENT_REMOTEIO_PLUGIN, \"remote file access\"},\n  {MARIADB_CLIENT_CONNECTION_PLUGIN, \"connection handler\"},\n  {0, \"unknown\"}\n};\n\nstatic void version()\n{\n  printf(\"%s Version %s\\n\", ma_progname, CLIENT_PLUGIN_INFO_VERSION);\n}\n\nstatic void usage(void)\n{\n  int i=0;\n  printf(\"%s Version %s\\n\", ma_progname, CLIENT_PLUGIN_INFO_VERSION);\n  puts(\"Copyright 2015 MariaDB Corporation AB\");\n  puts(\"Show client plugin information for MariaDB Connector/C.\");\n  printf(\"Usage: %s [OPTIONS] [plugin_name]\\n\", ma_progname);\n  while (long_options[i].name)\n  {\n    printf(\"  --%-12s -%s\\n\", long_options[i].name, values[i]);\n    i++;\n  }\n}\n\nstatic char *ma_get_type_name(int type)\n{\n  int i=0;\n  while (plugin_types[i].type)\n  {\n    if (type== plugin_types[i].type)\n      return plugin_types[i].typename;\n    i++;\n  }\n  return plugin_types[i].typename;\n}\n\nstatic void show_plugin_info(struct st_mysql_client_plugin *plugin, my_bool builtin)\n{\n  printf(\"Name: %s\\n\", plugin->name);\n  printf(\"Type: %s\\n\", ma_get_type_name(plugin->type));\n  printf(\"Desc: %s\\n\", plugin->desc);\n  printf(\"Author: %s\\n\", plugin->author);\n  printf(\"License: %s\\n\", plugin->license);\n  printf(\"Version: %d.%d.%d\\n\", plugin->version[0], plugin->version[1], plugin->version[2]);\n  printf(\"API Version: 0x%04X\\n\", plugin->interface_version);\n  printf(\"Build type: %s\\n\", builtin ? \"builtin\" : \"dynamic\");\n  printf(\"\\n\");\n}\n\nstatic void show_builtin()\n{\n  struct st_mysql_client_plugin **builtin;\n\n  for (builtin= mysql_client_builtins; *builtin; builtin++)\n    show_plugin_info(*builtin, TRUE);\n}\n\nstatic void show_file(char *filename)\n{\n  char dlpath[FN_REFLEN+1];\n  void *sym, *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n  char *env_plugin_dir= getenv(\"MARIADB_PLUGIN_DIR\");\n  char *has_so_ext= strstr(filename, SO_EXT);\n\n  if (!strchr(filename, FN_LIBCHAR))\n    snprintf(dlpath, sizeof(dlpath) - 1, \"%s/%s%s\",\n             (env_plugin_dir) ? env_plugin_dir : PLUGINDIR, \n             filename, \n             has_so_ext ? \"\" : SO_EXT);\n  else\n    strcpy(dlpath, filename);\n  if ((dlhandle= dlopen((const char *)dlpath, RTLD_NOW)))\n  {\n    if (sym= dlsym(dlhandle, plugin_declarations_sym))\n    {\n      plugin= (struct st_mysql_client_plugin *)sym;\n      show_plugin_info(plugin, 0);\n    }\n    dlclose(dlhandle);\n  }\n}\n\nstatic void show_dynamic(const char *directory)\n{\n  MY_DIR *dir= NULL;\n  unsigned int i;\n  char *plugin_dir= directory ? (char *)directory : getenv(\"MARIADB_PLUGIN_DIR\");\n\n  if (!plugin_dir)\n    plugin_dir= PLUGINDIR;\n\n  printf(\"plugin_dir %s\\n\", plugin_dir);\n\n  dir= my_dir(plugin_dir, 0);\n\n  if (!dir || !dir->number_off_files)\n  {\n    printf(\"No plugins found in %s\\n\", plugin_dir);\n    goto end;\n  }\n\n  for (i=0; i < dir->number_off_files; i++)\n  {\n    char *p= strstr(dir->dir_entry[i].name, SO_EXT);\n    if (p)\n      show_file(dir->dir_entry[i].name);\n  }\nend:\n  if (dir)\n    my_dirend(dir);\n}\n\nint main(int argc, char *argv[])\n{\n  int option_index= 0;\n  int c;\n  ma_progname= argv[0];\n\n  mysql_server_init(0, NULL, NULL);\n\n  if (argc <= 1)\n  {\n    usage();\n    exit(1);\n  }\n\n  c= getopt_long(argc, argv, \"bdapnvh?\", long_options, &option_index);\n\n  switch(c) {\n  case 'a': /* all */\n    show_builtin();\n    show_dynamic(NULL);\n    break;\n  case 'b': /* builtin */\n    show_builtin();\n    break;\n  case 'd': /* dynamic */\n    show_dynamic(NULL);\n    break;\n  case 'v':\n    version();\n    break;\n  case 'n':\n    if (argc > 2)\n      show_file(argv[2]);\n    break;\n  case 'p':\n    if (argc > 2)\n      show_dynamic(argv[2]);\n    break;\n  case '?':\n    usage();\n    break;\n  default:\n    printf(\"unrecocognized option: %s\", argv[1]);\n    exit(1);\n  }\n  exit(0);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-c-client-3.0.9-5x5r7t2wfli2nvkxgtyu44kb5fljezxr/spack-src/zlib/zlib.3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-c-client-3.0.9-5x5r7t2wfli2nvkxgtyu44kb5fljezxr/spack-src/win/packaging/WixUIDialogBmp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-c-client-3.0.9-5x5r7t2wfli2nvkxgtyu44kb5fljezxr/spack-src/win/packaging/WixUIBannerBmp.jpg"
    ],
    "total_files": 214
}