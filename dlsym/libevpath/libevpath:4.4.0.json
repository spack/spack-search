{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/cm.c": "#include \"config.h\"\n#if !NO_DYNAMIC_LINKING\n#include \"dlloader.h\"\n#endif\n#include <stdio.h>\n#include <string.h>\n#undef NDEBUG\n#include <assert.h>\n#include <ctype.h>\n#include <math.h>\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <stdlib.h>\n#include <limits.h>\n#ifdef HAVE_WINDOWS_H\n#include <winsock.h>\n#define __ANSI_CPP__\n#else\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#endif\n#include <sys/time.h>\n#include <ffs.h>\n#include <atl.h>\n#include \"evpath.h\"\n#include \"chr_time.h\"\n#include \"cm_internal.h\"\n#include \"cm_transport.h\"\n\n#if NO_DYNAMIC_LINKING\nstruct select_data;\nextern void libcmselect_LTX_add_select(CMtrans_services svc, struct select_data *sdp, int fd, \n\t\t\t\t       select_list_func func, void *arg1, void *arg2);\nextern void libcmselect_LTX_write_select(CMtrans_services svc, struct select_data *sdp, int fd, \n\t\t\t     select_list_func func, void *arg1, void *arg2);\nextern periodic_task_handle libcmselect_LTX_add_periodic(CMtrans_services svc, struct select_data *sdp, int interval_sec, int interval_usec, select_list_func func, void *arg1, void *arg2);\nextern periodic_task_handle libcmselect_LTX_add_delayed_task(CMtrans_services svc, \nstruct select_data *sdp, int delay_sec, int delay_usec, select_list_func func,void *arg1, \nvoid *arg2);\nextern void libcmselect_LTX_remove_periodic(CMtrans_services svc, struct select_data *sdp, periodic_task_handle handle);\nextern void libcmselect_LTX_remove_select(CMtrans_services svc, struct select_data *sdp, int fd);\nextern void libcmselect_LTX_wake_function(CMtrans_services svc, struct select_data *sdp);\nextern void libcmselect_LTX_blocking_function(CMtrans_services svc, void *client_data);\nextern void libcmselect_LTX_polling_function(CMtrans_services svc,void *client_data);\nextern void libcmselect_LTX_select_initialize(CMtrans_services svc,CManager cm,void *client_data);\nextern void libcmselect_LTX_select_shutdown(CMtrans_services svc,CManager cm,void *client_data);\nextern void libcmselect_LTX_select_free(CMtrans_services svc,CManager cm,void *client_data);\nextern void libcmselect_LTX_select_stop(CMtrans_services svc,void *client_data);\n#endif\n\n\nstatic void CMinitialize (CManager cm);\n\nstatic atom_t CM_TRANSPORT = -1;\nstatic atom_t CM_NETWORK_POSTFIX = -1;\nstatic atom_t CM_CONN_BLOCKING = -1;\natom_t CM_REBWM_RLEN = -1;\natom_t CM_REBWM_REPT = -1;\natom_t CM_BW_MEASURE_INTERVAL = -1;\natom_t CM_BW_MEASURE_TASK = -1;\natom_t CM_BW_MEASURED_VALUE = -1;\natom_t CM_BW_MEASURED_COF = -1;\natom_t CM_BW_MEASURE_SIZE = -1;\natom_t CM_BW_MEASURE_SIZEINC = -1;\nstatic atom_t CM_EVENT_SIZE = -1;\nstatic atom_t CM_INCOMING_CONNECTION = -1;\nstatic atom_t CM_TRANSPORT_RELIABLE = -1;\n\nvoid wait_for_pending_write(CMConnection conn);\nstatic void cm_wake_any_pending_write(CMConnection conn);\nstatic void transport_wake_any_pending_write(CMConnection conn);\nstatic void cm_set_pending_write(CMConnection conn);\nstatic int drop_CM_lock(CManager cm, char *file, int line);\nstatic int acquire_CM_lock(CManager cm, char *file, int line);\nstatic int return_CM_lock_status(CManager cm, char *file, int line);\nstatic void add_buffer_to_pending_queue(CManager cm, CMConnection conn, CMbuffer buf, long length);\nstatic void cond_wait_CM_lock(CManager cm, void *cond, char *file, int line);\n\nstruct CMtrans_services_s CMstatic_trans_svcs = {INT_CMmalloc, INT_CMrealloc, INT_CMfree, \n\t\t\t\t\t\t INT_CM_fd_add_select, \n\t\t\t\t\t\t CM_fd_write_select, \n\t\t\t\t\t\t CM_fd_remove_select, \n\t\t\t\t\t\t CMtransport_trace,\n\t\t\t\t\t\t CMConnection_create,\n\t\t\t\t\t\t INT_CMadd_shutdown_task,\n\t\t\t\t\t\t INT_CMadd_periodic_task,\n\t\t\t\t\t\t INT_CMadd_poll,\n\t\t\t\t\t\t cm_get_data_buf,\n\t\t\t\t\t\t cm_return_data_buf,\n\t\t\t\t\t\t internal_connection_close,\n\t\t\t\t\t\t cm_create_transport_buffer,\n\t\t\t\t\t\t cm_create_transport_and_link_buffer,\n\t\t\t\t\t\t INT_CMget_transport_data,\n\t\t\t\t\t\t cm_set_pending_write,\n\t\t\t\t\t\t transport_wake_any_pending_write,\n\t\t\t\t\t\t drop_CM_lock,\n\t\t\t\t\t\t acquire_CM_lock,\n\t\t\t\t\t\t return_CM_lock_status,\n\t\t\t\t\t\t cond_wait_CM_lock,\n\t\t\t\t\t\t add_buffer_to_pending_queue,\n\t\t\t\t\t\t INT_CMConnection_dereference,\n\t\t\t\t\t\t INT_CMConnection_add_reference,\n\t\t\t\t\t\t INT_CMConnection_failed,\n\t\t\t\t\t\t CMwake_server_thread\n};\nstatic void INT_CMControlList_close(CMControlList cl, CManager cm);\nstatic int CMcontrol_list_poll(CMControlList cl);\nint CMdo_non_CM_handler(CMConnection conn, int header,\n\t\t\t      char *buffer, int length);\nvoid CMdo_performance_response(CMConnection conn, long length,\n\t\t\t\t\t    int func, int byte_swap,\n\t\t\t\t\t    char *buffer);\n\nvoid CMhttp_handler(CMConnection conn, char* buffer, int length);\nstatic void CM_init_select(CMControlList cl, CManager cm);\n\nstatic void cond_wait_CM_lock(CManager cm, void *vcond, char *file, int line)\n{\n    pthread_cond_t *cond = vcond;\n    CMtrace_out(cm, CMLowLevelVerbose, \"CManager Condition wait at \\\"%s\\\" line %d\\n\",\n\t\tfile, line);\n    cm->locked--;\n    pthread_cond_wait(cond, &cm->exchange_lock);\n    CMtrace_out(cm, CMLowLevelVerbose, \"CManager Condition wake at \\\"%s\\\" line %d\\n\",\n\t\tfile, line);\n    cm->locked++;\n}\n\nstatic int drop_CM_lock(CManager cm, char *file, int line)\n{\n    int ret = cm->locked;\n    IntCManager_unlock(cm, file, line);\n    return ret;\n}\n\nstatic int acquire_CM_lock(CManager cm, char *file, int line)\n{\n    IntCManager_lock(cm, file, line);\n    return cm->locked;\n}\n\nstatic int return_CM_lock_status(CManager cm, char *file, int line)\n{\n    (void) file;\n    (void) line;\n    return cm->locked;\n}\n\nstatic void\nCMpoll_forever(CManager cm)\n{\n    CMControlList cl = cm->control_list;\n    int should_exit = 0;\n    CManager_lock(cm);\n    if (!cm->control_list->select_initialized) {\n\tCM_init_select(cm->control_list, cm);\n    }\n    if (cl->has_thread > 0 && cl->server_thread == thr_thread_self()) {\n\t/* \n\t * if we're actually the server thread here, do a thread exit when\n\t * we're done\n\t */\n\tshould_exit++;\n    }\n    while(!cl->closed) {\n\tCMtrace_out(cm, CMLowLevelVerbose, \"CM Poll Forever - thread %lx doing wait\\n\", (long)thr_thread_self());\n\tif (CMcontrol_list_wait(cl) == -1) {\n\t    CMtrace_out(cm, CMLowLevelVerbose, \"CM Poll Forever - doing close and exit\\n\");\n\t    /* \n\t     * error.  others will free the CM too, add to the ref count \n\t     * here so we can close.\n\t     */\n\t    cm->reference_count++;\n\t    CManager_unlock(cm);\n\t    CManager_close(cm);\n\t    exit(1);\n\t}\n    }\n    CMtrace_out(cm, CMLowLevelVerbose, \"CM Poll Forever - doing close\\n\");\n    CManager_unlock(cm);\n    CManager_close(cm);\n    if (should_exit != 0) thr_thread_exit(NULL);\n}\n\nstatic void CManager_free(CManager cm);\n\nstatic void\nserver_thread_func(CManager cm)\n{\n    CMpoll_forever(cm);\n    CManager_free(cm);\n}\n\nextern void\nINT_CMrun_network(CManager cm)\n{\n    if (!cm->control_list->select_initialized) {\n\tCM_init_select(cm->control_list, cm);\n    }\n    if ((cm->control_list->server_thread != 0) &&\n\t(cm->control_list->server_thread != thr_thread_self())) {\n\t/* What?  We're polling, but we're not the server thread? */\n\tfprintf(stderr, \"Warning:  CMrun_network() called when another thread may already be handling the network\\n\");\n\tfprintf(stderr, \"          This situation may result in unexpected I/O blocking.\\n\");\n\tfprintf(stderr, \"          Server thread set to %lx.\\n\", (long) thr_thread_self());\n    }\n    cm->control_list->server_thread = thr_thread_self();\n    cm->control_list->has_thread = 1;\n    CManager_unlock(cm);\n    CMpoll_forever(cm);\n}\n\nstatic int\nCM_test_thread_func()\n{\n    return 1;\n}\n\nstatic thr_thread_t \nthr_fork(func, arg)\nvoid*(*func)(void*);\nvoid *arg;\n{\n    pthread_t new_thread = 0;\n    int err = pthread_create(&new_thread, NULL, (void*(*)(void*))func, arg);\n    if (err != 0) {\n\treturn (thr_thread_t) NULL;\n    } else {\n\treturn (thr_thread_t) new_thread;\n    }\n}\n\nint\nINT_CMfork_comm_thread(CManager cm)\n{\n    /* if we're on a kernel-level-threads package, for the thread and \n       return 1, else return 0; */\n    if (!cm->control_list->select_initialized) {\n\tCM_init_select(cm->control_list, cm);\n    }\n    if (cm->control_list->has_thread == 0) {\n\tif (cm->control_list->network_blocking_function.func) {\n\t    thr_thread_t server_thread = \n\t\tthr_fork((void*(*)(void*))server_thread_func, \n\t\t\t (void*)cm);\n\t    CMtrace_out(cm, CMLowLevelVerbose,\n\t\t\t\"CM - Forked comm thread %lx\\n\", (long)server_thread);\n\t    if (server_thread ==  (thr_thread_t) NULL) {\n\t\treturn 0;\n\t    }\n\t    cm->control_list->server_thread = server_thread;\n\t    cm->control_list->has_thread = 1;\n\t    cm->reference_count++;\n\t    CMtrace_out(cm, CMFreeVerbose, \"Forked - CManager %lx ref count now %d\\n\", \n\t\t\t(long) cm, cm->reference_count);\n\t    cm->control_list->cl_reference_count++;\n\t    cm->control_list->free_reference_count++;\n\t} else {\n\t    /*\n\t     *  Can't start a server thread yet, but lets see \n\t     *  if we can fork anything successfully.\n\t     */\n\t    thr_thread_t test_thread = \n\t\tthr_fork((void*(*)(void*))CM_test_thread_func, \n\t\t\t (void*)cm);\n\t    if (test_thread ==  (thr_thread_t) NULL) {\n\t\t/* No.  Say we can't. */\n\t\tCMtrace_out(cm, CMLowLevelVerbose,\n\t\t\t    \"CM - Test fork failed, no comm thread\\n\");\n\t\treturn 0;\n\t    }\n\t    /* OK, we'll fork it later. */\n\t    CMtrace_out(cm, CMLowLevelVerbose,\n\t\t\t\"CM - Will fork comm thread later\\n\");\n\t    cm->control_list->has_thread = -1; /* should fork one */\n\t}\n    }\n    return 1;\n}\n\nextern\nvoid\nCMControlList_set_blocking_func(CMControlList cl, CManager cm, \n\t\t\t\tCMPollFunc bfunc, CMPollFunc pfunc,\n\t\t\t\tvoid *client_data)\n{\n    assert(cl->network_blocking_function.func == NULL);\n    cl->network_blocking_function.func = bfunc;\n    cl->network_blocking_function.client_data = client_data;\n    cl->network_blocking_function.cm = NULL;\n    cl->network_polling_function.func = pfunc;\n    cl->network_polling_function.client_data = client_data;\n    cl->network_polling_function.cm = NULL;\n    if (cl->has_thread == -1) {\n\tthr_thread_t server_thread = \n\t    thr_fork((void*(*)(void*))server_thread_func, \n\t\t     (void*)cm);\n\tif (server_thread ==  (thr_thread_t) NULL) {\n\t    return;\n\t}\n\tCMtrace_out(cm, CMLowLevelVerbose,\n\t\t    \"CM - Forked comm thread %lx\\n\", (long)server_thread);\n\tcm->control_list->server_thread = server_thread;\n\tcm->control_list->cl_reference_count++;\n\tcm->control_list->free_reference_count++;\n\tcl->has_thread = 1;\n\tcm->reference_count++;\n\tCMtrace_out(cm, CMFreeVerbose, \"Forked - CManager %lx ref count now %d\\n\", \n\t\t    (long) cm, cm->reference_count);\n    }\n}\n\nextern void\nINT_CMpoll_network(CManager cm)\n{\n    CMControlList cl = cm->control_list;\n    CMtrace_out(cm, CMLowLevelVerbose, \"CM Poll Network\\n\");\n    cl->network_polling_function.func((void*)&CMstatic_trans_svcs,\n\t\t\t\t      cl->network_polling_function.client_data);\n    CMcontrol_list_poll(cl);\n}\n\nstatic void\nadd_contact_list(CManager cm, attr_list attrs)\n{\n    int list_size = 0;\n    if (cm->contact_lists == NULL) {\n\tcm->contact_lists = INT_CMmalloc(sizeof(attr_list) *2);\n\tlist_size = 0;\n    } else {\n\twhile(cm->contact_lists[list_size] != NULL) list_size++;\n\tcm->contact_lists = INT_CMrealloc(cm->contact_lists, \n\t\t\t\t      sizeof(attr_list) * (list_size + 2));\n    }\n    cm->contact_lists[list_size] = attrs;\n    cm->contact_lists[list_size+1] = NULL;\n}\n\nvoid\nINT_CM_insert_contact_info(CManager cm, attr_list attrs)\n{\n    attr_merge_lists(cm->contact_lists[0], attrs);\n}\n\nattr_list\nINT_CMget_contact_list(CManager cm)\n{\n    if (cm->contact_lists == NULL) return NULL;\n    CMadd_ref_attr_list(cm, cm->contact_lists[0]);\n    return (cm->contact_lists[0]);\n}\n\nextern attr_list\nINT_CMget_specific_contact_list(CManager cm, attr_list attrs)\n{\n    char *chosen_transport = NULL, *chosen_net = NULL;\n    char *freeable_transport = NULL;\n    int i = 0;\n\n    if (attrs != NULL) {\n\tget_string_attr(attrs, CM_TRANSPORT, &chosen_transport);\n    }\n    if (chosen_transport && (strchr(chosen_transport, ':') != NULL)) {\n\tfreeable_transport = strdup(chosen_transport);\n\t*(strchr(freeable_transport, ':')) = 0;\n\tchosen_transport = freeable_transport;\n    }\n    if (attrs != NULL) {\n\tget_string_attr(attrs, CM_NETWORK_POSTFIX, &chosen_net);\n    }\n    if ((chosen_transport == NULL) && (chosen_net == NULL)) {\n\tCMadd_ref_attr_list(cm, cm->contact_lists[0]);\n\treturn cm->contact_lists[0];\n    }\n    /* specific transport chosen */\n    i = 0;\n    while (cm->contact_lists && (cm->contact_lists[i] != NULL)) {\n\tchar *this_transport = NULL, *this_postfix = NULL;\n\n\tget_string_attr(cm->contact_lists[i], CM_TRANSPORT, &this_transport);\n\tget_string_attr(cm->contact_lists[i], CM_NETWORK_POSTFIX, &this_postfix);\n\tif (this_transport == NULL) {\n\t    this_transport = \"sockets\";\n\t}\n\tif (strcmp(this_transport, chosen_transport) == 0) {\n\t    if ((chosen_net != NULL) || (this_postfix != NULL)) {\n\t\t/* one is not null */\n\t\tif (chosen_net && this_postfix) {\n\t\t    if (strcmp(chosen_net, this_postfix) != 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t    }\n\t\t} else {\n\t\t    i++;\n\t\t    continue;\n\t\t}\n\t    }\n\t    CMadd_ref_attr_list(cm, cm->contact_lists[i]);\n\t    if (freeable_transport) free(freeable_transport);\n\t    return cm->contact_lists[i];\n\t}\n\ti++;\n    }\n    /* chosen transport not listened? */\n    CMinternal_listen(cm, attrs, /* try others*/ 0);\n    /* try again */\n    i = 0;\n    while (cm->contact_lists && (cm->contact_lists[i] != NULL)) {\n\tchar *this_transport = NULL, *this_postfix = NULL;\n\n\tget_string_attr(cm->contact_lists[i], CM_TRANSPORT, &this_transport);\n\tget_string_attr(cm->contact_lists[i], CM_NETWORK_POSTFIX, \n\t\t\t&this_postfix);\n\tif (this_transport == NULL) {\n\t    this_transport = \"sockets\";\n\t}\n\tif (strcmp(this_transport, chosen_transport) == 0) {\n\t    if ((chosen_net != NULL) || (this_postfix != NULL)) {\n\t\t/* one is not null */\n\t\tif (chosen_net && this_postfix) {\n\t\t    if (strcmp(chosen_net, this_postfix) != 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t    }\n\t\t} else {\n\t\t    i++;\n\t\t    continue;\n\t\t}\n\t    }\n\t    CMadd_ref_attr_list(cm, cm->contact_lists[i]);\n\t    if (freeable_transport) free(freeable_transport);\n\t    return cm->contact_lists[i];\n\t}\n\ti++;\n    }\n    /* maybe it failed to load */\n    if (freeable_transport) free(freeable_transport);\n    return NULL;\n}\n\nint\nINT_CMlisten(CManager cm)\n{\n  return INT_CMlisten_specific (cm, NULL);\n}\n\nstatic attr_list\nsplit_transport_attributes(attr_list list)\n{\n    char *chosen_transport = NULL;\n    if (list) {\n\tget_string_attr(list, CM_TRANSPORT, &chosen_transport);\n    }\n    if (chosen_transport && (strchr(chosen_transport, ':') != NULL)) {\n\tattr_list new_list = attr_copy_list(list);\n\tatom_t atom;\n\tchar *old_transport, *params;\n\tchar *next_param;\n\tget_string_attr(new_list, CM_TRANSPORT, &old_transport);\n\tparams = strchr(old_transport, ':');\n\t*(params++) = 0;\n\tset_string_attr(new_list, CM_TRANSPORT, strdup(old_transport));\n\twhile (params != NULL) {\n\t    char *equal, *end;\n\t    next_param = strchr(params, ',');\n\t    if (next_param) *(next_param++) = 0;  /* kill comma */\n\t    if ((equal = strchr(params, '=')) != NULL) {\n\t\t/* there's an equal sign */\n\t\t*(equal++) = 0;\n\t\t/* we'll deal with this later */\n\t    }\n\t    while (isspace(*params)) params++;  /* skip white */\n\t    end = params + strlen(params) - 1;\n\t    while(end > params && isspace(*end)) end--;\n\t    // Write new null terminator\n\t    *(end+1) = 0;\n\t    atom = attr_atom_from_string(params);\n\t    if (equal == NULL) {\n\t\tset_int_attr(new_list, atom, 1);\n\t    } else {\n\t\tchar *tail;\n\t\tlong value;\n\t\twhile (isspace(*equal)) equal++;  /* skip white */\n\t\tend = equal + strlen(equal) - 1;\n\t\twhile(end > equal && isspace(*end)) end--;\n\t\t// Write new null terminator\n\t\t*(end+1) = 0;\n\t\tvalue = strtol(equal, &tail, 10);\n\t\tif (strlen(tail) == 0) {\n\t\t    /* valid integer! */\n\t\t    if ((value < INT_MAX) && (value > INT_MIN)) {\n\t\t\tset_int_attr(new_list, atom, (int)value);\n\t\t    } else {\n\t\t\tset_long_attr(new_list, atom, value);\n\t\t    }\n\t\t} else {\n\t\t    /* string... */\n\t\t    set_string_attr(new_list, atom, strdup(equal));\n\t\t}\n\t    }\n\t    params = next_param;\n\t}\n\tfree(old_transport);  /* not free'd by replace */\n\tfree_attr_list(list);\n\tlist = new_list;\n    }\n    return list;\n}\nextern int\nCMinternal_listen(CManager cm, attr_list listen_info, int try_others)\n{\n    int success = 0;\n    transport_entry *trans_list;\n    char *chosen_transport = NULL;\n\n    if (listen_info) {\n        listen_info = split_transport_attributes(attr_copy_list(listen_info));\n\tget_string_attr(listen_info, CM_TRANSPORT, &chosen_transport);\n    }\n    if (chosen_transport != NULL) {\n        CMtrace_out(cm, CMConnectionVerbose,\n\t\t    \"CM - Listening only on transport \\\"%s\\\"\\n\",\n\t\t    chosen_transport);\n\tif (load_transport(cm, chosen_transport, 1) == 0) {\n\t    CMtrace_out(cm, CMConnectionVerbose,\n\t\t\t\"Failed to load transport \\\"%s\\\".  Revert to default.\\n\",\n\t\t\tchosen_transport);\n\t    CMtrace_out(cm, CMTransportVerbose,\n\t\t\t\"Failed to load transport \\\"%s\\\".  Revert to default.\\n\",\n\t\t\tchosen_transport);\n\t    if (!try_others) {\n\t\tif (listen_info) free_attr_list(listen_info);\n\t\treturn success;\n\t    }\n\t    chosen_transport = NULL;\n\t}\n    }\n    trans_list = cm->transports;\n    while ((trans_list != NULL) && (*trans_list != NULL)) {\n\tattr_list attrs;\n\tif ((chosen_transport == NULL) || \n\t    (strcmp((*trans_list)->trans_name, chosen_transport) == 0)) {\n\t    attrs = (*trans_list)->listen(cm, &CMstatic_trans_svcs,\n\t\t\t\t\t  *trans_list,\n\t\t\t\t\t  listen_info);\n\t    add_contact_list(cm, attrs);\n\t    if (CMtrace_on(cm, CMConnectionVerbose)) {\n\t\tfprintf(cm->CMTrace_file, \"Adding contact list -> \");\n\t\tfdump_attr_list(cm->CMTrace_file, attrs);\n\t    }\n\t    if (attrs != NULL) {\n\t\tsuccess++;\n\t    }\n\t}\n\ttrans_list++;\n    }\n    if (listen_info) free_attr_list(listen_info);\n    return success;\n}\n\nint\nINT_CMlisten_specific(CManager cm, attr_list listen_info)\n{\n    int success = 0;\n    if (!cm->initialized) CMinitialize(cm);\n    success = CMinternal_listen(cm, listen_info, /* try others*/ 1);\n    return (success != 0);\n}\n\n#ifdef CM_DEFAULT_TRANSPORT\nstatic char *CMglobal_default_transport = CM_DEFAULT_TRANSPORT;\n#else \nstatic char *CMglobal_default_transport = NULL;\n#endif\n\nstatic char *CMglobal_alternate_transports[] = {NULL};\n\nstatic void \nCMinitialize(CManager cm)\n{\n    char **transport_names = CMglobal_alternate_transports;\n    char *def = getenv(\"CMDefaultTransport\");\n    if (def != NULL) CMglobal_default_transport = def;\n    if (CMglobal_default_transport) {\n\tif (load_transport(cm, CMglobal_default_transport, 0) == 0) {\n\t    fprintf(stderr, \"Failed to initialize default transport.  Exiting.\\n\");\n\t    exit(1);\n\t}\n    }\n    while ((transport_names != NULL) && (transport_names[0] != NULL)) {\n\tload_transport(cm, transport_names[0], 1);\n\ttransport_names++;\n    }\n    cm->initialized++;\n}\n\nstatic int\nCMcontrol_list_poll(CMControlList cl)\n{\n    func_entry *poll_list = cl->polling_function_list;\n    while ((poll_list != NULL) && (poll_list->func != NULL)){\n\tint consistency_number = cl->cl_consistency_number;\n\n\tCManager_unlock(poll_list->cm);\n\tpoll_list->func(poll_list->cm, poll_list->client_data);\n\tCManager_lock(poll_list->cm);\n\t/* do function */\n\tif (consistency_number != cl->cl_consistency_number) {\n\t    return 1;\n\t}\n\tpoll_list++;\n    }\n    return 1;\n}\n\nstatic \nvoid\nCMControlList_add_poll(CMControlList cl, CManager cm, CMPollFunc func,\n\t\t       void *client_data)\n{\n    func_entry *poll_list;\n    int count = 0;\n    poll_list = cl->polling_function_list;\n    while ((poll_list != NULL) && (poll_list[count].func != NULL)) {\n\tcount++;\n    }\n    /*\n     *  We're going to navigate the poll list without locks.  This is\n     *  somewhat dangerous, but safe enough if we only have a couple of\n     *  functions so we never realloc.  If we ever hit the realloc() below,\n     *  there's a chance of some bad data references.  At this point, using\n     *  that many poll functions seems unlikely, but later, maybe not...\n     */\n    if (poll_list != NULL) {\n\tif (cl->pflist_size < count - 2) {\n\t    cl->pflist_size *= 2;\n\t    poll_list = INT_CMrealloc(poll_list, sizeof(func_entry) * (cl->pflist_size));\n\t}\n    } else {\n\tpoll_list = INT_CMmalloc(sizeof(func_entry)*10);\n\tcl->pflist_size = 10;\n    }\n    poll_list[count].cm = cm;\n    poll_list[count].func = func;\n    poll_list[count].client_data = client_data;\n    poll_list[count+1].func = NULL;\n    cl->polling_function_list = poll_list;\n}\n    \nextern\nvoid\nINT_CMadd_poll(CManager cm, CMPollFunc func, void *client_data)\n{\n    CMControlList_add_poll(cm->control_list, cm, func, client_data);\n}\n\nextern\nint\nCMcontrol_list_wait(CMControlList cl)\n{\n    /* associated CM should be locked */\n    if ((cl->server_thread != 0) &&\n\t(cl->server_thread != thr_thread_self())) {\n\t/* What?  We're polling, but we're not the server thread? */\n\tfprintf(stderr, \"Warning:  Multiple threads calling CMnetwork_wait\\n\");\n\tfprintf(stderr, \"          This situation may result in unexpected I/O blocking.\\n\");\n\tfprintf(stderr, \"          Server thread set to %lx.\\n\", (long) thr_thread_self());\n    }\n    cl->server_thread = thr_thread_self();\n    if (cl->network_blocking_function.func != NULL) {\n\tcl->network_blocking_function.func((void*)&CMstatic_trans_svcs,\n\t\t\t\t\t   cl->network_blocking_function.client_data);\n    }\n    CMcontrol_list_poll(cl);\n    return 1;\n}\n\nstatic CMControlList CMControlList_create();\n\nstatic thr_mutex_t atl_mutex;\nstatic int atl_mutex_initialized = 0;\nstatic void process_pending_queue(CManager cm, void *junk);\n\nextern\nCManager\nINT_CManager_create()\n{\n    CManager cm = (CManager) INT_CMmalloc(sizeof(CManager_s));\n    int atom_init = 0;\n\n    if (!atl_mutex_initialized) {\n\tatl_mutex_initialized++;\n\tthr_mutex_init(atl_mutex);\n\tatl_install_mutex_funcs((atl_lock_func)pthread_mutex_lock, (atl_lock_func)pthread_mutex_unlock, \n\t\t\t\t&atl_mutex);\n    }\n    if (cm == NULL)\n\treturn NULL;\n    memset(cm, 0, sizeof(CManager_s));\n\n    if (atom_init == 0) {\n\tCM_TRANSPORT = attr_atom_from_string(\"CM_TRANSPORT\");\n\tCM_NETWORK_POSTFIX = attr_atom_from_string(\"CM_NETWORK_POSTFIX\");\n\tCM_CONN_BLOCKING = attr_atom_from_string(\"CM_CONN_BLOCKING\");\n\tCM_REBWM_RLEN = attr_atom_from_string(\"CM_REG_BW_RUN_LEN\");\n\tCM_REBWM_REPT = attr_atom_from_string(\"CM_REG_BW_REPEAT_CNT\");\n\tCM_BW_MEASURE_INTERVAL = attr_atom_from_string(\"CM_BW_MEASURE_INTERVAL\");\n\tCM_BW_MEASURE_TASK = attr_atom_from_string(\"CM_BW_MEASURE_TASK\");\n\tCM_BW_MEASURED_VALUE = attr_atom_from_string(\"CM_BW_MEASURED_VALUE\");\n\tCM_BW_MEASURED_COF = attr_atom_from_string(\"CM_BW_MEASURED_COF\");\n\tCM_BW_MEASURE_SIZE = attr_atom_from_string(\"CM_BW_MEASURE_SIZE\");\n\tCM_BW_MEASURE_SIZEINC = attr_atom_from_string(\"CM_BW_MEASURE_SIZEINC\");\n\tCM_EVENT_SIZE = attr_atom_from_string(\"CM_EVENT_SIZE\");\n\tCM_INCOMING_CONNECTION = attr_atom_from_string(\"CM_INCOMING_CONNECTION\");\n\tCM_TRANSPORT_RELIABLE = attr_atom_from_string(\"CM_TRANSPORT_RELIABLE\");\n    }\n\n    /* initialize data structs */\n    cm->transports = NULL;\n    cm->initialized = 0;\n    cm->reference_count = 1;\n\n    cm->control_list = CMControlList_create();\n    thr_mutex_init(cm->exchange_lock);\n\n    cm->locked = 0;\n    cm->closed = 0;\n    cm->abort_read_ahead = 0;\n    cm->CMTrace_file = NULL;\n    CMtrace_init(cm, EVerbose);\n    CMinit_local_formats(cm);\n    thr_mutex_init(cm->context_lock);\n\n    cm->in_format_count = 0;\n    cm->in_formats = INT_CMmalloc(1);\n\n    cm->reg_format_count = 0;\n    cm->reg_formats = INT_CMmalloc(1);\n\n    cm->pending_request_max = 1;\n    cm->pbio_requests = INT_CMmalloc(sizeof(struct _pending_format_requests));\n    cm->pbio_requests[0].server_id = NULL;\n    cm->pbio_requests[0].id_length = 0;\n    cm->pbio_requests[0].condition = 0;\n    cm->pbio_requests[0].top_request = 0;\n\n    cm->connection_count = 0;\n    cm->connections = INT_CMmalloc(1);\n    cm->reg_user_format_count = 0;\n    cm->reg_user_formats = INT_CMmalloc(1);\n    cm->cm_buffer_list = NULL;\n    cm->pending_data_queue = NULL;\n\n    cm->contact_lists = NULL;\n    cm->shutdown_functions = NULL;\n    cm->perf_upcall = NULL;\n    INT_CMadd_poll(cm, process_pending_queue, NULL);\n#ifdef EV_INTERNAL_H\n    CManager_lock(cm);\n    EVPinit(cm);\n    CManager_unlock(cm);\n#endif\n    return cm;\n}\n\nstatic void CMControlList_free(CManager cm, CMControlList cl);\nstatic void remove_conn_from_CM(CManager cm, CMConnection conn);\n\nstatic void\nCManager_free(CManager cm)\n{\n    int i;\n    CMbuffer list = NULL;\n\n    INT_CMfree(cm->transports);\n    cm->transports = NULL;\n/*    free_FFSContext(cm->FFScontext);*/\n    cm->FFScontext = NULL;\n    INT_CMfree(cm->in_formats);\n\n    for (i=0 ; i < cm->reg_format_count; i++) {\n\tINT_CMfree(cm->reg_formats[i]->format_name);\n\tINT_CMfree(cm->reg_formats[i]);\n    }\n    INT_CMfree(cm->reg_formats);\n\n    /*\n     *  Applications are expected to free the user contexts that \n     *  they request.  If they do this, there will be no user formats to\n     *  free at this point.  (Doing so might result in double freeing.)\n     */\n    INT_CMfree(cm->reg_user_formats);\n\n    INT_CMfree(cm->pbio_requests);\n\n    INT_CMfree(cm->connections);\n\n    thr_mutex_free(cm->exchange_lock);\n\n    thr_mutex_free(cm->context_lock);\n\n    if (cm->contact_lists != NULL) {\n\ti = 0;\n\twhile(cm->contact_lists[i] != NULL) {\n\t    INT_CMfree_attr_list(cm, cm->contact_lists[i]);\n\t    i++;\n\t}\n\tINT_CMfree(cm->contact_lists);\n    }\n    list = cm->cm_buffer_list;\n    i=0;\n    while (list != NULL) {\n\tCMbuffer next = list->next;\n\tCMtrace_out(cm, CMBufferVerbose, \"Final buffer disposition buf %d, %p, size %ld, ref_count %d\\n\", i++, list, list->size, list->ref_count);\n\tINT_CMfree(list->buffer);\n\tINT_CMfree(list);\n\tlist = next;\n    }\n    cm->cm_buffer_list = NULL;\n    if (cm->shutdown_functions) INT_CMfree(cm->shutdown_functions);\n    INT_CMfree(cm->avail);\n     INT_CMfree(cm);\n }\n\n extern void\n INT_CMinstall_perf_upcall(CManager cm, CMperf_upcall upcall)\n {\n     cm->perf_upcall = upcall;\n }\n\n extern void\n INT_CManager_close(CManager cm)\n {\n     CMControlList cl = cm->control_list;\n\n     CMtrace_out(cm, CMFreeVerbose, \"CManager %p closing, ref count %d\\n\", cm,\n\t\t cm->reference_count);\n\n     CMtrace_out(cm, CMFreeVerbose, \"CMControlList close CL=%lx current reference count will be %d, sdp = %p\\n\", \n\t\t (long) cl, cl->cl_reference_count - 1, cl->select_data);\n     INT_CMControlList_close(cl, cm);\n     CMtrace_out(cm, CMFreeVerbose, \"CMControlList CL=%lx is closed\\n\", (long) cl);\n\n     while (cm->connection_count != 0) {\n\t /* connections are moved down as they are closed... */\n\t CMtrace_out(cm, CMFreeVerbose, \"CManager in close, closing connection %p , ref count %d\\n\", cm->connections[0],\n\t\t     cm->connections[0]->conn_ref_count);\n\t internal_connection_close(cm->connections[0]);\n\t INT_CMConnection_failed(cm->connections[0]);\n     }\n\n     if (cm->shutdown_functions != NULL) {\n\t func_entry *shutdown_functions = cm->shutdown_functions;\n\t int i = 0;\n\n\t while (shutdown_functions[i].func != NULL) {\n\t     if (shutdown_functions[i].task_type == SHUTDOWN_TASK) {\n\t\t CMtrace_out(cm, CMFreeVerbose, \"CManager calling shutdown function SHUTDOWN %d, %lx\\n\", i, (long)shutdown_functions[i].func);\n\t\t shutdown_functions[i].func(cm, shutdown_functions[i].client_data);\n\t\t shutdown_functions[i].task_type = NO_TASK;\n\t     }\n\t     i++;\n\t }\n     }\n     cm->reference_count--;\n     CMtrace_out(cm, CMFreeVerbose, \"CManager %p ref count now %d\\n\", \n\t\t cm, cm->reference_count);\n     if (cm->reference_count == 0) {\n\t if (cm->shutdown_functions != NULL) {\n\t     int i = 0;\n\t     func_entry *shutdown_functions = cm->shutdown_functions;\n\t     cm->shutdown_functions = NULL;\n\n\t     while (shutdown_functions[i].func != NULL) {\n\t\t i++;\n\t     }\n\t     i--;\n\t     for ( ; i >= 0; i--) {\n\t\t if (shutdown_functions[i].task_type == FREE_TASK) {\n\t\t     CMtrace_out(cm, CMFreeVerbose, \"CManager calling shutdown function FREE %d, %lx\\n\", i, (long)shutdown_functions[i].func);\n\t\t     shutdown_functions[i].func(cm, shutdown_functions[i].client_data);\n\t\t     shutdown_functions[i].func = NULL;\n\t\t }\n\t     }\n\t     INT_CMfree(shutdown_functions);\n\t }\n\t CMtrace_out(cm, CMFreeVerbose, \"Freeing CManager %p\\n\", cm);\n\t cl->free_reference_count = 1;\n\t CMControlList_free(cm, cl);\n\t CManager_unlock(cm);\n\t CManager_free(cm);\n     } else {\n\t CManager_unlock(cm);\n     }\n }\n\n extern void\n internal_add_shutdown_task(CManager cm, CMPollFunc func, void *client_data, int task_type)\n {\n     int func_count = 0;\n     if (!cm->control_list->select_initialized) {\n\t CM_init_select(cm->control_list, cm);\n     }\n     if (cm->shutdown_functions == NULL) {\n\t cm->shutdown_functions = \n\t     INT_CMmalloc(sizeof(cm->shutdown_functions[0]) * 2);\n     } else {\n\t while (cm->shutdown_functions[func_count].func != NULL) {\n\t     func_count++;\n\t }\n\t cm->shutdown_functions = \n\t     INT_CMrealloc(cm->shutdown_functions,\n\t\t       sizeof(cm->shutdown_functions[0]) * (func_count +2));\n     }\n     cm->shutdown_functions[func_count].func = func;\n     cm->shutdown_functions[func_count].task_type = task_type;\n     cm->shutdown_functions[func_count].client_data = client_data;\n     func_count++;\n     cm->shutdown_functions[func_count].func = NULL;\n }\n\n extern void\n INT_CMadd_shutdown_task(CManager cm, CMPollFunc func, void *client_data, int task_type)\n {\n     internal_add_shutdown_task(cm, func, client_data, task_type);\n }\n\n static void\n add_conn_to_CM(CManager cm, CMConnection conn)\n {\n     cm->connections = \n\t INT_CMrealloc(cm->connections, \n\t\t   (cm->connection_count + 1) * sizeof(cm->connections[0]));\n     cm->connections[cm->connection_count] = conn;\n     INT_CMConnection_add_reference(conn);\n     cm->connection_count++;\n }\n\n static void\n remove_conn_from_CM(CManager cm, CMConnection conn)\n {\n     int i;\n     int found = 0;\n     for (i=0; i < cm->connection_count; i++) {\n\t if (cm->connections[i] == conn) {\n\t     found++;\n\t     INT_CMConnection_dereference(conn);\n\t } else if (found) {\n\t     /* copy down */\n\t     cm->connections[i-1] = cm->connections[i];\n\t }\n     }\n     if (found == 0) {\n\t fprintf(stderr, \"Internal error, remove_conn_from_CM.  Not found\\n\");\n     } else {\n\t cm->connection_count--;\n\t cm->abort_read_ahead = 1;\n     }\n }\n\n static CMControlList\n CMControlList_create()\n {\n     CMControlList new_list = (CMControlList) INT_CMmalloc(sizeof(CMControlList_s));\n     new_list->select_initialized = 0;\n     new_list->select_data = NULL;\n     new_list->add_select = NULL;\n     new_list->remove_select = NULL;\n     new_list->server_thread =  (thr_thread_t) NULL;\n     new_list->network_blocking_function.func = NULL;\n     new_list->network_polling_function.func = NULL;\n     new_list->polling_function_list = NULL;\n     new_list->cl_consistency_number = 1;\n     new_list->cl_reference_count = 1;\n     new_list->free_reference_count = 1;\n     thr_mutex_init(new_list->list_mutex);\n     new_list->condition_list = NULL;\n     new_list->next_condition_num = 1;\n     new_list->closed = 0;\n     new_list->locked = 0;\n     new_list->has_thread = 0;\n     new_list->cond_polling = 0;\n     return new_list;\n }\n\n CMConnection\n CMConnection_create(transport_entry trans, void *transport_data, \n\t\t     attr_list conn_attrs)\n {\n     static int first = 1;\n     static int non_block_default = 0;\n     static int read_thread_default = 0;\n     int blocking_on_conn;\n     CMConnection conn = INT_CMmalloc(sizeof(struct _CMConnection));\n     if (first) {\n\t char *value = getenv(\"CMNonBlockWrite\");\n\t first = 0;\n\t if (value != NULL) {\n\t     sscanf(value, \"%d\", &non_block_default);\n\t     CMtrace_out(trans->cm, CMConnectionVerbose, \"CM default blocking %d\\n\",\n\t\t\t non_block_default);\n\t }\n\t value = getenv(\"CMReadThread\");\n\t if (value != NULL) {\n\t     sscanf(value, \"%d\", &read_thread_default);\n\t     CMtrace_out(trans->cm, CMConnectionVerbose, \"CM default read thread %d\\n\",\n\t\t\t read_thread_default);\n\t }\n     }\n     conn->cm = trans->cm;\n     conn->trans = trans;\n     conn->transport_data = transport_data;\n     conn->conn_ref_count = 1;\n     conn->closed = 0;\n     conn->failed = 0;\n     conn->preloaded_formats = NULL;\n     conn->remote_format_server_ID = 0;\n     conn->remote_CManager_ID = 0;\n     conn->handshake_condition = -1;\n     conn->io_out_buffer = create_FFSBuffer();\n     conn->close_list = NULL;\n     conn->write_callback_len = 0;\n     conn->write_callbacks = NULL;\n     if (conn_attrs) {\n\t CMadd_ref_attr_list(conn->cm, conn_attrs);\n     }\n     conn->attrs = conn_attrs;\n     conn->attr_encode_buffer = create_AttrBuffer();\n\n     conn->message_buffer = NULL;\n     conn->buffer_full_point = 0;\n     conn->buffer_data_end = 0;\n\n     conn->characteristics = NULL;\n     conn->write_pending = 0;\n     conn->do_non_blocking_write = non_block_default;\n     conn->XML_output = 0;\n     conn->use_read_thread = read_thread_default; \n\n     if (get_int_attr(conn_attrs, CM_CONN_BLOCKING, &blocking_on_conn)) {\n\t conn->do_non_blocking_write = !blocking_on_conn;\n     }\n     add_conn_to_CM(trans->cm, conn);\n     CMtrace_out(trans->cm, CMFreeVerbose, \"CMConnection_create %lx \\n\",\n\t\t (long) conn);\n     return conn;\n }\n\n extern attr_list\n INT_CMConnection_get_attrs(CMConnection conn)\n {\n     return conn->attrs;\n }\n\n typedef struct {\n     int size; /*stream length to probe bw. */\n     int size_inc;/*size=size+size_inc if previous size is not adequate*/\n     int successful_run; /*if we have at least 5 successful runs, \n\t\t\t   size is set properly*/\n     int failed_run;/*After parameters are set properly, if we have 3\n\t\t      contineous runs failed, we need to set the size again \n\t\t      for the changed network condition*/\n     CMConnection conn;\n     attr_list attrs;\n } *bw_measure_data;\n\n static void\n do_bw_measure(CManager cm, void *client_data)\n {\n     double bw;\n     (void)cm;\n     bw_measure_data data = (bw_measure_data) client_data;\n     CManager_lock(cm);\n     bw=INT_CMregressive_probe_bandwidth(data->conn, data->size, data->attrs);\n     CManager_unlock(cm);\n\n     /*Initialization phase*/\n     if(bw<0 && data->successful_run<5){\n\t data->size+=data->size_inc;\n\t data->successful_run=0;\n     }\n     if(bw>=0 && data->successful_run<5) data->successful_run++; /*if measured correctly in several back-to-back measurements, increase data->successful_run up to 5. 5 indicates parameters are well tuned now*/\n\n     /*After initialization, if network condition changed, and previously tuned parameters come to not adequate:*/\n     if(bw<0 && data->successful_run>=5 && data->failed_run<5)\n\t data->failed_run++;\n     if(bw>=0)  data->failed_run=0; /*guard for contineous failures. */\n     if(data->failed_run>=5){ /*need to tune parameters again now. */\n\t data->successful_run=0;\n\t data->failed_run=0;\n     }\n\n     CMtrace_out(data->conn->cm, CMLowLevelVerbose,\"successful run: %d, failed run: %d, size: %d, bw: %f\\n\", data->successful_run, data->failed_run, data->size, bw);\n     return;\n }    \n\n extern int\n INT_CMConnection_set_character(CMConnection conn, attr_list attrs)\n {\n     long interval_value;\n     if (attrs == NULL) return 0;\n     if (get_long_attr(attrs, CM_BW_MEASURE_INTERVAL, &interval_value)) {\n\t bw_measure_data data;\n\t int previous_interval;\n\t CMTaskHandle task = NULL;\n\t if ((interval_value <= 1) || (interval_value > 60*60*8)) {\n\t     printf(\"Bad CM_BW_MEASURE_INTERVAL, %ld seconds\\n\",\n\t\t    interval_value);\n\t     return 0;\n\t }\n\n\t CMtrace_out(conn->cm, CMLowLevelVerbose,\"CM_BW_MEASURE_INTERVAL set, interval is %ld\\n\", interval_value);\n\t if (conn->characteristics && \n\t     (get_int_attr(conn->characteristics, CM_BW_MEASURE_INTERVAL,\n\t\t\t   &previous_interval) != 0)) {\n\t     CMTaskHandle prior_task = NULL;\n\t     if (interval_value >= previous_interval) {\n\t\t CMtrace_out(conn->cm, CMLowLevelVerbose,\"CM_BW_MEASURE_INTERVAL prior interval is %d, no action.\\n\", previous_interval);\n\t\t return 1;\n\t     }\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose,\"CM_BW_MEASURE_INTERVAL prior interval is %d, killing prior task.\\n\", previous_interval);\n\t     get_long_attr(conn->characteristics, CM_BW_MEASURE_TASK,\n\t\t\t   (long*)(long)&prior_task);\n\t     if (prior_task) {\n\t\t INT_CMremove_task(prior_task);\n\t\t set_long_attr(conn->characteristics, CM_BW_MEASURE_TASK, (long)0);\n\t     }\n\t }\n\t data = malloc(sizeof(*data));\n\t data->size=data->size_inc=-1;\n\n\t /*Get attr about size, size_inc from attributes. */\n\t get_int_attr(attrs, CM_BW_MEASURE_SIZE, &(data->size));\n\t if(data->size<1024)\n\t     data->size=1024;\n\t get_int_attr(attrs, CM_BW_MEASURE_SIZEINC, &(data->size_inc));\n\t if(data->size_inc<1024)\n\t     data->size_inc=1024;\n\n\t data->successful_run=0;\n\t data->failed_run=0;\n\n\t /*app set attr about N and repeat time. store in data->attrs automically and pass to regressive_probe_bandwidth. \n\t  */\n\t data->conn = conn;\n\t data->attrs = CMattr_copy_list(conn->cm, attrs);\n\t /* do one task almost immediately */\n\t task = INT_CMadd_delayed_task(conn->cm, 0, 1000, do_bw_measure, \n\t\t\t\t   (void*)data);\n\t free(task);\n\t /* schedule tasks periodically */\n\t task = INT_CMadd_periodic_task(conn->cm, interval_value, 0, \n\t\t\t\t    do_bw_measure, (void*)data);\n\t if (conn->characteristics == NULL) {\n\t     conn->characteristics = CMcreate_attr_list(conn->cm);\n\t }\n\t set_int_attr(conn->characteristics, CM_BW_MEASURE_INTERVAL,\n\t\t      interval_value);\n\t set_long_attr(conn->characteristics, CM_BW_MEASURE_TASK, (long)task);\n\n\t return 1;\n     }\n     return 0;\n }\n\n extern CMConnection \n INT_CMget_indexed_conn(CManager cm, int i)\n {\n     if (i>=0 && i<cm->connection_count) {\n\t if (cm->connections[i] != NULL) {\n\t     return cm->connections[i];\n\t } else {\n\t     CMtrace_out(cm, CMConnectionVerbose,\n\t\t\t \"cm->connection[%d] is NULL. INT_CMget_indexed_conn\\n\", i);\n\t     return NULL;\n\t }\n     } else {\n\t CMtrace_out(cm, CMConnectionVerbose,\n\t\t     \"Invalid index. i=%d. INT_CMget_indexed_conn\\n\", i);\n\t return NULL;\n     }\n }\n\n void\n INT_CMConnection_dereference(CMConnection conn)\n {\n     conn->conn_ref_count--;\n     if (conn->conn_ref_count > 0) {\n\t CMtrace_out(conn->cm, CMFreeVerbose, \"CM - Dereference connection %p, ref count now %d\\n\",\n\t\t     (void*)conn, conn->conn_ref_count);\n\t return;\n     }\n     if (conn->conn_ref_count < 0) {\n\t CMtrace_out(conn->cm, CMFreeVerbose, \"CM - connection reference count less than 0, conn %p\\n\", conn);\n\t return;   /*  BAD! */\n     }\n     CMtrace_out(conn->cm, CMFreeVerbose, \"CM - Shut down connection %p\\n\",\n\t\t (void*)conn);\n     if (conn->write_pending) {\n\t wait_for_pending_write(conn);\n     }\n     conn->closed = 1;\n     if (conn->failed == 0) {\n\t CMtrace_out(conn->cm, CMFreeVerbose, \"Calling connection failed with no dereference %p\\n\", conn);\n\t INT_CMConnection_failed(conn);\n     }\n     CMtrace_out(conn->cm, CMFreeVerbose, \"CM - Dereference connection %p FREEING\\n\", (void*)conn);\n     if (conn->write_callbacks) INT_CMfree(conn->write_callbacks);\n     INT_CMfree(conn->preloaded_formats);\n     INT_CMfree_attr_list(conn->cm, conn->attrs);\n     free_FFSBuffer(conn->io_out_buffer);\n     free_AttrBuffer(conn->attr_encode_buffer);\n #ifdef EV_INTERNAL_H\n     INT_EVforget_connection(conn->cm, conn);\n #endif\n     INT_CMfree(conn);\n }\n\nvoid\nINT_CMConnection_failed(CMConnection conn)\n{\n    CMTaskHandle prior_task = NULL;\n    if (conn->failed) return;\n    conn->failed = 1;\n    transport_wake_any_pending_write(conn);\n\n    assert(CManager_locked(conn->cm));\n    CMtrace_out(conn->cm, CMFreeVerbose, \"CMConnection failed conn=%lx\\n\", \n\t\t(long) conn);\n    CMconn_fail_conditions(conn);\n    conn->trans->shutdown_conn(&CMstatic_trans_svcs, conn->transport_data);\n    get_long_attr(conn->characteristics, CM_BW_MEASURE_TASK, \n\t\t  (long*)(long)&prior_task);\n    if (prior_task) {\n\tINT_CMremove_task(prior_task);\n\tset_long_attr(conn->characteristics, CM_BW_MEASURE_TASK, (long)0);\n    }\n    if (conn->close_list) {\n\tCMCloseHandlerList list = conn->close_list;\n\tconn->close_list = NULL;\n\twhile (list != NULL) {\n\t    CMCloseHandlerList next = list->next;\n\t    if (! conn->closed ) {\n\t\tCMtrace_out(conn->cm, CMConnectionVerbose, \n\t\t\t    \"CM - Calling close handler %p for connection %p\\n\",\n\t\t\t    (void*) list->close_handler, (void*)conn);\n\t\tCManager_unlock(conn->cm);\n\t\tlist->close_handler(conn->cm, conn, list->close_client_data);\n\t\tCManager_lock(conn->cm);\n\t    }\n\t    INT_CMfree(list);\n\t    list = next;\n\t}\n    }\n    conn->closed = 1;\n    remove_conn_from_CM(conn->cm, conn);\n}\n\n void\n internal_connection_close(CMConnection conn)\n {\n     CMtrace_out(conn->cm, CMFreeVerbose, \"internal_connection_close conn=%lx ref count is %d\\n\", \n\t\t (long) conn, conn->conn_ref_count);\n     conn->closed = 1;\n }\n\n void\n INT_CMConnection_close(CMConnection conn)\n {\n     internal_connection_close(conn);\n     CMtrace_out(conn->cm, CMFreeVerbose, \"User CMConnection close conn=%lx ref count will be %d\\n\", \n\t\t (long) conn, conn->conn_ref_count - 1);\n     INT_CMConnection_dereference(conn);\n }\n\n void\n INT_CMconn_register_close_handler(CMConnection conn, CMCloseHandlerFunc func, \n\t\t\t\t   void *client_data)\n {\n     CMCloseHandlerList *lastp = &conn->close_list;\n     CMCloseHandlerList entry = INT_CMmalloc(sizeof(*entry));\n     while (*lastp != NULL) lastp = &((*lastp)->next);\n     entry->close_handler = func;\n     entry->close_client_data = client_data;\n     entry->next = NULL;\n     *lastp = entry;\n }\n\n static void\n INT_CMControlList_close(CMControlList cl, CManager cm)\n {\n     void *status;\n     cl->cl_reference_count--;\n     cl->closed = 1;\n\n     (cl->stop_select)((void*)&CMstatic_trans_svcs, &cl->select_data);\n     if ((cl->has_thread > 0) && (cl->server_thread != thr_thread_self())){\n\t     (cl->wake_select)((void*)&CMstatic_trans_svcs,\n\t\t\t       &cl->select_data);\n     }\t\n     if ((cl->has_thread > 0) && (cl->server_thread != thr_thread_self())){\n\t (cl->stop_select)((void*)&CMstatic_trans_svcs,\n\t\t\t   &cl->select_data);\n\n\t (cl->wake_select)((void*)&CMstatic_trans_svcs,\n\t\t\t   &cl->select_data);\n\t CManager_unlock(cm);\n\t thr_thread_join(cl->server_thread, &status);\n\t CManager_lock(cm);\n\t cl->has_thread = 0;\n     }\n }\n\n\n void\n CMwake_server_thread(CManager cm)\n {\n     CMControlList cl = cm->control_list;\n     (cl->wake_select)((void*)&CMstatic_trans_svcs, &cl->select_data);\n }\n\n extern void\n internal_condition_free(CMControlList cl);\n\n static void\n CMControlList_free(CManager cm, CMControlList cl)\n {\n     cl->free_reference_count--;\n     if (CMtrace_val[CMFreeVerbose]) {\n\t fprintf(cm->CMTrace_file, \"CMControlList_free, %lx, ref count now %d\\n\", (long)cl,\n\t\tcl->free_reference_count);\n     }\n     if(cl->free_reference_count == 0) {\n\t if (CMtrace_val[CMFreeVerbose]) {\n\t     fprintf(cm->CMTrace_file, \"CMControlList_free freeing %lx\\n\", (long)cl);\n\t }\n\t if (cl->polling_function_list != NULL) {\n\t     INT_CMfree(cl->polling_function_list);\n\t }\n\t thr_mutex_free(cl->list_mutex);\n\t internal_condition_free(cl);\n\t INT_CMfree(cl);\n     }\n }\n\n extern void\n CMget_qual_hostname(CManager cm, char *buf, int len)\n {\n     get_IP_config(buf, len, NULL, NULL, NULL, NULL, NULL,\n\t\t   CMstatic_trans_svcs.trace_out, cm);\n }\n\n extern void\n CMget_port_range(CManager cm, int *high_bound, int *low_bound)\n {\n     get_IP_config(NULL, 0, NULL, low_bound, high_bound, NULL, NULL,\n\t\t   CMstatic_trans_svcs.trace_out, cm);\n }\n\n extern int\n INT_CMget_self_ip_addr(CManager cm)\n {\n     int IP;\n     get_IP_config(NULL, 0, &IP, NULL, NULL, NULL, NULL,\n\t\t   CMstatic_trans_svcs.trace_out, cm);\n     return IP;\n }\n\n #define CURRENT_HANDSHAKE_VERSION 1\n\n static \n int\n transport_is_reliable(CMConnection conn)\n {\n     attr_list list;\n     int ret;\n     if (conn->trans->get_transport_characteristics == NULL) {\n\t return 0; /* don't know */\n     }\n     list = conn->trans->get_transport_characteristics(conn->trans, &CMstatic_trans_svcs, \n\t\t\t\t\t\t       conn->trans->trans_data);\n     if (!get_int_attr(list, CM_TRANSPORT_RELIABLE, &ret)) {\n\t return 0; /* don't know */\n     }\n     return ret;\n }\n\n static\n void\n send_and_maybe_wait_for_handshake(CManager cm, CMConnection conn)\n {\n     struct FFSEncodeVec tmp_vec[1];\n     int reliable = transport_is_reliable(conn);\n     int msg[5], actual;\n     if (!cm->FFSserver_identifier) cm->FFSserver_identifier = -1;\n     msg[0] = 0x434d4800;  /* CMH\\0 */\n     msg[1] = (CURRENT_HANDSHAKE_VERSION << 24) + sizeof(msg);\n     msg[2] = cm->FFSserver_identifier;\n     msg[3] = 5;  /* not implemented yet */\n     msg[4] = 0;  /* not implemented yet */\n     if (conn->remote_format_server_ID != 0) {\n\t /* set high bit if we already have his ID */\n\t msg[3] |= 0x80000000;\n     }\n     tmp_vec[0].iov_base = &msg;\n     tmp_vec[0].iov_len = sizeof(msg);\n     CMtrace_out(conn->cm, CMLowLevelVerbose, \"CM - sending handshake\\n\");\n     if ((conn->remote_format_server_ID == 0) && reliable) {\n\t /* we will await his respone */\n\t conn->handshake_condition = INT_CMCondition_get(cm, conn);\n     }\n     actual = conn->trans->writev_func(&CMstatic_trans_svcs, \n\t\t\t\t       conn->transport_data, \n\t\t\t\t       &tmp_vec[0], 1, NULL);\n\n     CMtrace_out(conn->cm, CMLowLevelVerbose, \"CM - after handshake, pending is %d\\n\", conn->write_pending);\n     if (conn->write_pending) {\n\t wait_for_pending_write(conn);\n     }\n     if (actual != 1) {\n\t printf(\"handshake write failed\\n\");\n     }\n     if ((conn->remote_format_server_ID == 0) && reliable) {\n\t CMtrace_out(conn->cm, CMLowLevelVerbose, \"CM - waiting for handshake response\\n\");\n\t INT_CMCondition_wait(cm, conn->handshake_condition);\n     }\n }\n\n static\n CMConnection\n try_conn_init(CManager cm, transport_entry trans, attr_list attrs)\n {\n     CMConnection conn;\n     conn = trans->initiate_conn(cm, &CMstatic_trans_svcs,\n\t\t\t\t trans, attrs);\n     if (conn != NULL) {\n\t if (CMtrace_on(conn->cm, CMConnectionVerbose)) {\n\t     char *attr_str = attr_list_to_string(attrs);\n\t     CMtrace_out(conn->cm, CMConnectionVerbose, \n\t\t\t \"CM - Establish connection %p - %s\\n\", (void*)conn,\n\t\t\t attr_str);\n\t     INT_CMfree(attr_str);\n\t }\n\t if (conn->use_read_thread) {\n\t     INT_CMstart_read_thread(conn);\n\t }\n\t send_and_maybe_wait_for_handshake(cm, conn);\n     }\n     return conn;\n }\n\n CMConnection\n CMinternal_initiate_conn(CManager cm, attr_list attrs)\n {\n     transport_entry *trans_list;\n     char *chosen_transport = NULL;\n\n     assert(CManager_locked(cm));\n\n     if (attrs) {\n\t attrs = split_transport_attributes(attr_copy_list(attrs));\n\t get_string_attr(attrs, CM_TRANSPORT, &chosen_transport);\n     }\n     if (chosen_transport != NULL) {\n\t if (load_transport(cm, chosen_transport, 1) == 0) {\n\t     CMtrace_out(cm, CMConnectionVerbose,\n\t\t\t \"Failed to load transport \\\"%s\\\".  Revert to default.\\n\",\n\t\t\t chosen_transport);\n\t     chosen_transport = NULL;\n\t }\n     }\n     trans_list = cm->transports;\n     if (chosen_transport == NULL) {\n\t CMtrace_out(cm, CMConnectionVerbose,\n\t\t     \"INT_CMinitiate_conn no transport attr found\\n\");\n\n\t while ((trans_list != NULL) && (*trans_list != NULL)) {\n\t     CMConnection conn;\n\t     conn = try_conn_init(cm, *trans_list, attrs);\n\t     if (conn != NULL) {\n\t\t if (attrs) free_attr_list(attrs);\n\t\t return conn;\n\t     }\n\t     trans_list++;\n\t }\n     } else {\n\t CMtrace_out(cm, CMConnectionVerbose,\n\t\t     \"INT_CMinitiate_conn looking for transport \\\"%s\\\"\\n\", \n\t\t     chosen_transport);\n\t while ((trans_list != NULL) && (*trans_list != NULL)) {\n\t     if (strcmp((*trans_list)->trans_name, chosen_transport) == 0) {\n\t\t CMConnection conn = try_conn_init(cm, *trans_list, attrs);\n\t\t if (attrs) free_attr_list(attrs);\n\t\t return conn;\n\t     }\n\t     trans_list++;\n\t }\n\t CMtrace_out(cm, CMConnectionVerbose,\n\t\t     \"INT_CMinitiate_conn transport \\\"%s\\\" not found - no connection\\n\", \n\t\t     chosen_transport);\n\t if (attrs) free_attr_list(attrs);\n\t return NULL;\n     }\n\n     if (attrs) free_attr_list(attrs);\n     return NULL;\n }\n\n static void\n fdump_CMConnection(FILE *out, CMConnection conn)\n {\n     if (conn == NULL) {\n\t fprintf(out, \"CMConnection NULL\\n\");\n\t return;\n     }\n     fprintf(out, \"CMConnection %lx, reference count %d, closed %d\\n\\tattrs : \", \n\t    (long) conn, conn->conn_ref_count, conn->closed);\n     fdump_attr_list(out, conn->attrs);\n     fprintf(out, \"\\tbuffer_full_point %ld, current buffer_end %ld\\n\", \n\t     conn->buffer_full_point, conn->buffer_data_end);\n     fprintf(out, \"\\twrite_pending %d\\n\", conn->write_pending);\n }\n\n /*static void\n dump_CMConnection(CMConnection conn)\n {\n     fdump_CMConnection(stdout, conn);\n     }*/\n\n CMConnection\n INT_CMinitiate_conn(CManager cm, attr_list attrs)\n {\n     CMConnection conn;\n     if (!cm->initialized) CMinitialize(cm);\n     if (CMtrace_on(cm, CMConnectionVerbose)) {\n\t fprintf(cm->CMTrace_file,\"Doing CMinitiate_conn\\n\");\n     }\n     conn = CMinternal_initiate_conn(cm, attrs);\n     if (CMtrace_on(cm, CMConnectionVerbose)) {\n\t if (conn != NULL) {\n\t     fdump_CMConnection(cm->CMTrace_file, conn);\n\t } else {\n\t     fprintf(cm->CMTrace_file, \"NULL\\n\");\n\t }\n     }\n     return conn;\n }\n\n void\n INT_CMConnection_add_reference(CMConnection conn)\n {\n     conn->conn_ref_count++;\n     CMtrace_out(conn->cm, CMFreeVerbose, \"Add reference to connection %p, value is now %d\\n\", conn, conn->conn_ref_count);\n }\n\n CMConnection\n CMinternal_get_conn(CManager cm, attr_list attrs)\n {\n     int i;\n     CMConnection conn = NULL;\n     assert(CManager_locked(cm));\n     if (CMtrace_on(cm, CMConnectionVerbose)) {\n\t fprintf(cm->CMTrace_file, \"In CMinternal_get_conn, attrs \");\n\t if (attrs) fdump_attr_list(cm->CMTrace_file, attrs); else fprintf(cm->CMTrace_file, \"\\n\");\n     }\n     for (i=0; i<cm->connection_count; i++) {\n\t CMConnection tmp = cm->connections[i];\n\t if (tmp->closed || tmp->failed) continue;\n\t if (tmp->trans->connection_eq(cm, &CMstatic_trans_svcs,\n\t\t\t\t\ttmp->trans, attrs,\n\t\t\t\t\ttmp->transport_data)) {\n\n\t     CMtrace_out(tmp->cm, CMFreeVerbose, \"internal_get_conn found conn=%p ref count will be %d\\n\", \n\t\t\t tmp, tmp->conn_ref_count +1);\n\t     CMtrace_out(tmp->cm, CMConnectionVerbose, \"internal_get_conn found conn=%p ref count will be %d\\n\", \n\t\t\t tmp, tmp->conn_ref_count +1);\n\t     tmp->conn_ref_count++;\n\t     conn = tmp;\n\t     break;\n\t }\n     }\n     if (conn == NULL) {\n\t if (CMtrace_on(cm, CMConnectionVerbose)) {\n\t     fprintf(cm->CMTrace_file, \"In CMinternal_get_conn, no existing connection found, initiating\\n\");\n\t }\n\t conn = CMinternal_initiate_conn(cm, attrs);\n\t if (conn) {\n\t     CMtrace_out(conn->cm, CMFreeVerbose, \"internal_get_conn initiated connection %p ref count now %d\\n\", \n\t\t\t conn, conn->conn_ref_count);\n\t }\n     }\n     if (conn != NULL) {\n\t CMtrace_out(conn->cm, CMFreeVerbose, \"internal_get_conn returning conn=%p ref count %d\\n\", \n\t\t     conn, conn->conn_ref_count);\n     }\n     if (CMtrace_on(cm, CMConnectionVerbose)) {\n\t fprintf(cm->CMTrace_file, \"CMinternal_get_conn returning \");\n\t if (conn != NULL) {\n\t     fdump_CMConnection(cm->CMTrace_file, conn);\n\t } else {\n\t     fprintf(cm->CMTrace_file, \"NULL\\n\");\n\t }\n     }\n     return conn;\n }\n\n CMConnection\n INT_CMget_conn(CManager cm, attr_list attrs)\n {\n     CMConnection conn;\n     if (!cm->initialized) CMinitialize(cm);\n     conn = CMinternal_get_conn(cm, attrs);\n     return conn;\n }\n\n int\n INT_CMcontact_self_check(CManager cm, attr_list attrs)\n {\n     transport_entry *trans_list;\n     if (!cm->initialized) CMinitialize(cm);\n     trans_list = cm->transports;\n     while ((trans_list != NULL) && (*trans_list != NULL)) {\n\t int result = 0;\n\t result = (*trans_list)->self_check(cm, &CMstatic_trans_svcs, \n\t\t\t\t\t    *trans_list, attrs);\n\t if (result) return result;\n\t trans_list++;\n     }\n     return 0;\n }\n\n extern CMbuffer\n cm_create_transport_buffer(CManager cm, void *buffer, int length)\n {\n     CMbuffer tmp;\n     (void)cm;\n     tmp = INT_CMmalloc(sizeof(*tmp));\n     memset(tmp, 0, sizeof(*tmp));\n     tmp->buffer = buffer;\n     tmp->size = length;\n     tmp->ref_count = 1;\n     CMtrace_out(cm, CMBufferVerbose, \"Creating buffer %p, ref_count is %d\\n\", tmp, tmp->ref_count);\n //   This should just return the buffer... not update the link list.  That's handled in the calling routine.\n //    tmp->next = cm->cm_buffer_list;\n //    cm->cm_buffer_list = tmp;\n     return tmp;\n }\n\n extern CMbuffer\n cm_create_transport_and_link_buffer(CManager cm, void *buffer, int length)\n {\n     CMbuffer tmp;\n     tmp = INT_CMmalloc(sizeof(*tmp));\n     memset(tmp, 0, sizeof(*tmp));\n     tmp->buffer = buffer;\n     tmp->size = length;\n     tmp->ref_count = 1;\n     CMtrace_out(cm, CMBufferVerbose, \"Create and link buffer %p, ref_count is %d\\n\", tmp, tmp->ref_count);\n     tmp->next = cm->cm_buffer_list;\n     cm->cm_buffer_list = tmp;\n     return tmp;\n }\n\n /* alloc temporary buffer for CM use */\n extern CMbuffer\n cm_get_data_buf(CManager cm, int length)  \n {\n     int buffer_count = 0;\n     CMbuffer tmp = cm->cm_buffer_list;\n\n     CMtrace_out(cm, CMBufferVerbose, \"cm_get_data_buf called with len %d\\n\",\n\t\t length);\n     while (tmp != NULL) {\n\t CMtrace_out(cm, CMBufferVerbose, \"  buffer %d %p, size is %ld, data %p, ref_count %d\\n\",\n\t\t     buffer_count, tmp, tmp->size, tmp->buffer, tmp->ref_count);\n\t buffer_count++;\n\t tmp = tmp->next;\n     }\n\n     tmp = cm->cm_buffer_list;\n     buffer_count = 0;\n     /* first baseline consistency check */\n     while (tmp != NULL) {\n\t if (tmp->ref_count < 0) {\n\t     CMtrace_out(cm, CMBufferVerbose, \"cm_get_data_buf buffer %p, ref_count is %d, should not be negative\\n\", tmp, tmp->ref_count);\n\t }\n\t buffer_count++;\n\t tmp = tmp->next;\n     }\n     /* first look for a buffer big enough, but not too big */\n     tmp = cm->cm_buffer_list;\n     while (tmp != NULL) {\n\t if (tmp->ref_count <= 0) {\n\t     if ((tmp->size >= length) && ((tmp->size/10) < length)) {\n\t\t CMtrace_out(cm, CMBufferVerbose, \"cm_get_data_buf called len %d, return existing %p, next %p, count %d\\n\",\n\t\t\t     length, tmp, tmp->next, buffer_count);\n\t\t tmp->ref_count = 1;\n\t\t return tmp;\n\t     }\n\t }\n\t tmp = tmp->next;\n     }\t\t\n     /* ok, we'll settle for way too big, but realloc it down */\n     tmp = cm->cm_buffer_list;\n     while (tmp != NULL) {\n\t if (tmp->ref_count <= 0) {\n\t     if ((tmp->size >= length)) {\n\t\t char *t = INT_CMrealloc(tmp->buffer, length);\n\t\t if (t == NULL) {\n\t\t     return NULL;\n\t\t }\n\t\t tmp->buffer = t;\n\t\t tmp->size = length;\n\t\t tmp->ref_count = 1;\n\t\t CMtrace_out(cm, CMBufferVerbose, \"      cm_get_data_buf resizing down!  return is %p\\n\", tmp);\n\t\t return tmp;\n\t     }\n\t }\n\t tmp = tmp->next;\n     }\t\t\n     tmp = cm->cm_buffer_list;\n     /* well, look for a small one to realloc up */\n     while (tmp != NULL) {\n\t if (tmp->ref_count <= 0) {\n\t     if (tmp->size <= length) {\n\t\t char *t = INT_CMrealloc(tmp->buffer, length);\n\t\t if (t == NULL) {\n\t\t     return NULL;\n\t\t }\n\t\t tmp->buffer = t;\n\t\t tmp->size = length;\n\t\t tmp->ref_count = 1;\n\t\t CMtrace_out(cm, CMBufferVerbose, \"      cm_get_data_buf resizingup!  return is %p\\n\", tmp);\n\t\t return tmp;\n\t     }\n\t }\n\t tmp = tmp->next;\n     }\n     tmp = cm_create_transport_buffer(cm, INT_CMmalloc(length), length);\n     tmp->ref_count = 1;\n     tmp->next = cm->cm_buffer_list;\n     cm->cm_buffer_list = tmp;\n     CMtrace_out(cm, CMBufferVerbose, \"cm_get_data_buf create new len %d, return %p, count %d\\n\",\n\t\t length, tmp, buffer_count);\n     return tmp;\n }\n\n /* realloc temporary buffer for CM use */\n extern CMbuffer\n cm_extend_data_buf(CManager cm, CMbuffer tmp, int length)  \n {\n     (void)cm;\n     if (tmp->size < length) {\n\t char *t = INT_CMrealloc(tmp->buffer, length);\n\t if (t == NULL) {\n\t     return NULL;\n\t }\n\t tmp->buffer = t;\n\t tmp->size = length;\n     }\n     return tmp;\n }\n\n /* CM says that it is done with temporary buffer */\n extern void\n cm_return_data_buf(CManager cm, CMbuffer cmb)\n {\n     cmb->ref_count--;\n     CMtrace_out(cm, CMBufferVerbose, \"cm_return_data_buf buffer %p, callback %p, ref_count is now %d\\n\", cmb, cmb->return_callback, cmb->ref_count);\n     if ((cmb->ref_count == 0) && (cmb->return_callback != NULL)) {\n\t CMbuffer last = NULL, tmp = cm->cm_buffer_list;\n\t /* UNLINK */\n\t CMtrace_out(cm, CMBufferVerbose, \"cm_return_data_buf --- Unlinking %p cmb\\n\", cmb);\n\t while (tmp != NULL) {\n\t     if (tmp != cmb) {\n\t\t last = tmp;\n\t\t tmp = tmp->next;\n\t\t continue;\n\t     }\n\t     /* remove the buffer from CM's list */\n\t     if (last == NULL) {\n\t\t cm->cm_buffer_list = tmp->next;\n\t     } else {\n\t\t last->next = tmp->next;\n\t     }\n\t     tmp = tmp->next;\n\t     (cmb->return_callback)(cmb->return_callback_data);\n\t     free(cmb);\n\t     break;\n\t }\n     }\n }\n\n static CMbuffer\n cm_buffer_lookup(CManager cm, void *buffer)\n {\n     CMbuffer tmp = cm->cm_buffer_list;\n     while (tmp != NULL) {\n\t if ((tmp->buffer <= buffer) && \n\t     ((char*)buffer < ((char*)tmp->buffer + tmp->size))){\n\t     return tmp;\n\t }\n\t tmp = tmp->next;\n     }\n     return NULL;\n }\n\n static CMbuffer\n cm_buffer_dump_list(CManager cm)\n {\n     CMbuffer tmp = cm->cm_buffer_list;\n     printf(\"Known CM buffers are:\\n\");\n     while (tmp != NULL) {\n\t printf(\"Buffer begin %p, size %ld, end %p\\n\",\n\t\ttmp->buffer, tmp->size, (char*)tmp->buffer + tmp->size);\n\t tmp = tmp->next;\n     }\n     return NULL;\n }\n\n int (*cm_write_hook)(int) = (int (*)(int)) NULL;\n int (*cm_preread_hook)(int,char*) = (int (*)(int, char*)) NULL;\n void (*cm_postread_hook)(int,char*) = (void (*)(int, char*)) NULL;\n void (*cm_last_postread_hook)() = (void (*)()) NULL;\n static int CMact_on_data(CMConnection conn, CMbuffer cm_buffer, char *buffer, long length);\n\n static void process_pending_queue(CManager cm, void *junk)\n {\n     /* shortcircuit if no data, no lock */\n     if (!cm->pending_data_queue) return;\n\n     CManager_lock(cm);\n     while (cm->pending_data_queue) {\n\t pending_queue entry = cm->pending_data_queue;\n\t int result;\n\t cm->pending_data_queue = entry->next;\n\t result = CMact_on_data(entry->conn, entry->buffer, entry->buffer->buffer, entry->length);\n\t if (result != 0) {\n\t     printf(\"in process pending, CMact_on_data returned %d\\n\", result);\n\t }\n\t cm_return_data_buf(cm, entry->buffer);\n\t free(entry);\n     }\n     CManager_unlock(cm);\n }\n\n static void add_buffer_to_pending_queue(CManager cm, CMConnection conn, CMbuffer buf, long length)\n {\n     assert(CManager_locked(cm));\n     pending_queue entry = malloc(sizeof(struct pending_queue_entry));\n     entry->next = NULL;\n     entry->conn = conn;\n     entry->buffer = buf;\n     entry->length = length;\n     if (!cm->pending_data_queue) {\n\t cm->pending_data_queue = entry;\n     } else {\n\t pending_queue last = cm->pending_data_queue;\n\t pending_queue tmp = last->next;\n\t while (tmp) {\n\t     last = tmp;\n\t     tmp = tmp->next;\n\t }\n\t last->next = entry;\n     }\n     CMwake_server_thread(cm);\n }\n\n static\n CMbuffer\n fill_cmbuffer(CManager cm, char *buf, long length)\n {\n     CMbuffer ret = cm_get_data_buf(cm, length);\n     memcpy(ret->buffer, buf, length);\n     return ret;\n }\n\n extern void CMDataAvailable(transport_entry trans, CMConnection conn)\n {\n     CManager cm = conn->cm;\n     int do_read = 1;\n     int read_msg_count = 0;\n     long read_byte_count = 0;\n     int result;\n     static int first = 1;\n     static int read_ahead_msg_limit = 50;\n     static long read_ahead_byte_limit = 1024*1024*1024;\n     static int use_blocking_reads = 1;\n     int first_four = 0;\n     char *tmp_message_buffer = NULL;\n     int data_length;\n     CMbuffer message_buffer;\n     long buffer_full_point, buffer_data_end;\n\n     /* called from the transport, grab the locks */\n     if (first) {\n\t char *tmp;\n\t first = 0;\n\t tmp = getenv(\"CMReadAheadMsgLimit\");\n\t if (tmp != NULL) {\n\t     if (sscanf(tmp, \"%d\", &read_ahead_msg_limit) != 1) {\n\t\t printf(\"Read ahead msg limit \\\"%s\\\" not parsed\\n\", tmp);\n\t     }\n\t }\n\t tmp = getenv(\"CMReadAheadByteLimit\");\n\t if (tmp != NULL) {\n\t     if (sscanf(tmp, \"%ld\", &read_ahead_byte_limit) != 1) {\n\t\t printf(\"Read ahead byte limit \\\"%s\\\" not parsed\\n\", tmp);\n\t     }\n\t }\n\t tmp = getenv(\"CMBlockingReads\");\n\t if (tmp != NULL) {\n\t     use_blocking_reads = atoi(tmp);\n\t }\n     }\n\n     if (conn->buffer_full_point == 0) {\n\t /* nothing saved from last invocation */\n\t message_buffer = NULL;\n\t buffer_full_point = 0;\n\t buffer_data_end = 0;\n     } else {\n\t /* message_buffer, buffer_full_point and buffer_data_end cached from last call to CMDataAvailable */\n\t message_buffer = conn->message_buffer;\n\t conn->message_buffer = NULL;\n\t buffer_full_point = conn->buffer_full_point;\n\t conn->buffer_full_point = 0;\n\t buffer_data_end = conn->buffer_data_end;\n\t conn->buffer_data_end = 0;\n     }\n  start_read:\n     if (conn->failed) {\n\t return;\n     }\n     if (buffer_full_point == 0) {\n\t buffer_full_point = 4; /* read first 4 bytes first thing */\n\t buffer_data_end = 0; /* no bytes read yet */\n\t first_four = 1;\n     }\n     if (trans->read_to_buffer_func) {\n\t CMtrace_out(cm, CMLowLevelVerbose, \"CMdata continuing read, already have %ld bytes, trying to read total %ld\\n\", buffer_data_end, buffer_full_point);\n     } else {\n\t CMtrace_out(cm, CMLowLevelVerbose, \"CMdata block read beginning\\n\");\n     }\t\n     if (buffer_full_point < HEADER_BUFFER_SIZE) {\n\t tmp_message_buffer = &conn->header_buffer[0];\n     } else {\n\t if (message_buffer == NULL) {\n\t     /* we had data in the header buffer, but need more space */\n\t     message_buffer = cm_get_data_buf(cm, buffer_full_point);\n\t     memcpy(message_buffer->buffer, &conn->header_buffer[0],\n\t\t    buffer_data_end);\n\t     tmp_message_buffer = message_buffer->buffer;\n\t } else {\n\t     /* make sure buffer is big enough */\n\t     cm_extend_data_buf(cm, message_buffer, buffer_full_point);\n\t     tmp_message_buffer = message_buffer->buffer;\n\t }\n     }\n     if (cm_preread_hook) {\n\t do_read = cm_preread_hook(buffer_full_point - buffer_data_end, tmp_message_buffer);\n     }\n     if (do_read) {\n\t if (trans->read_to_buffer_func) {\n\t /* \n\t  * read_to_buffer functionality present means we can read the transport directly to any memory area\n\t  * This gives us the most flexibility in managing our data.  \n\t  *   At this point, tmp_message_buffer is the char* buffer to which we want to read\n\t  *   If non-NULL, message_buffer is the CMBuffer that holds this memory\n\t  *   buffer_data_end is how much data is already in the buffer\n\t  *   buffer_full_point is how much data we think we need for the message to be complete\n\t  */\n\t     int read_len = buffer_full_point - buffer_data_end;\n\t     char *read_target_buf = tmp_message_buffer + buffer_data_end;\n\t     /* \n\t      * non blocking is True only if :\n\t      *    - we're reading the first four bytes (first_four is true) and use_read_thread is false\n\t      *    - or use_blocking_reads is false and use_read_thread is false\n\t      */\n\t     int non_blocking = first_four || !use_blocking_reads;\n\t     int actual;\n\t     if (conn->use_read_thread) {\n\t\t non_blocking = 0;\n\t\t CManager_unlock(cm);\n\t     }\n\t     if (read_len == 0) {\n\t\t /* should never happen that we are here but don't need more data */\n\t\t printf(\"Seriously bad shit\\n\");\n\t     }\n\t     actual = trans->read_to_buffer_func(&CMstatic_trans_svcs, \n\t\t\t\t\t\t conn->transport_data, \n\t\t\t\t\t\t read_target_buf, read_len, non_blocking);\n\t     if (conn->use_read_thread) {\n\t\t CManager_lock(cm);\n\t     }\n\t     if (actual == -1) {\n\t\t CMtrace_out(cm, CMLowLevelVerbose, \n\t\t\t     \"CMdata read failed, actual %d, failing connection %p\\n\", actual, conn);\n\t\t CMtrace_out(conn->cm, CMFreeVerbose, \"Calling connection failed read_len with dereference %p\\n\", conn);\n\t\t INT_CMConnection_failed(conn);\n\t\t return;\n\t     }\n\t     buffer_data_end += actual;\n\t     if (actual < read_len) {\n\t\t /* partial read, we know we don't have enough data now, roll on */\n\t\t CMtrace_out(cm, CMLowLevelVerbose, \n\t\t\t     \"CMdata read partial, got %d\\n\", actual);\n\t\t /* save state and return */\n\t\t conn->message_buffer = message_buffer;\n\t\t conn->buffer_full_point = buffer_full_point;\n\t\t conn->buffer_data_end = buffer_data_end;\n\t\t return;\n\t     }\n\t     data_length = buffer_data_end;\n\t } else {\n\t     int offset;\n\t     message_buffer = trans->read_block_func(&CMstatic_trans_svcs, \n\t\t\t\t\t\t     conn->transport_data,\n\t\t\t\t\t\t     &data_length, &offset);\n\t     if (message_buffer == NULL) {\n\t\t CMtrace_out(cm, CMLowLevelVerbose, \n\t\t\t     \"CMdata NULL return from read_block_func\");\n\t\t return;\n\t     }\n\t     message_buffer->ref_count++;\n\t     CMtrace_out(cm, CMBufferVerbose, \"Received buffer %p from transport read_block_func, increment ref count, now is %d\\n\", message_buffer, message_buffer->ref_count);\n\t     tmp_message_buffer = message_buffer->buffer + offset;\n\t     buffer_data_end = data_length;\n\t     cm->abort_read_ahead = 1;\n\n\t     if (data_length == -1) {\n\t\t CMtrace_out(cm, CMLowLevelVerbose, \n\t\t\t     \"CMdata read failed, actual %d, failing connection %p\\n\", data_length, conn);\n\t\t CMtrace_out(conn->cm, CMFreeVerbose, \"Calling connection failed with dereference, data length %p\\n\", conn);\n\t\t INT_CMConnection_failed(conn);\n\t\t return;\n\t     }\n\t     if (data_length == 0) {\n\t\t return;\n\t     }\n\t     if (tmp_message_buffer == NULL) {\n\t\t CMtrace_out(cm, CMLowLevelVerbose, \"CMdata read_block failed, failing connection %p\\n\", conn);\n\t\t CMtrace_out(conn->cm, CMFreeVerbose, \"Calling connection failed read_block withdereference %p\\n\", conn);\n\t\t INT_CMConnection_failed(conn);\n\t\t return;\n\t     }\n\t     CMtrace_out(cm, CMLowLevelVerbose, \"CMdata read_block returned %d bytes of data\\n\", data_length);\n\t }\n\t if (cm_postread_hook) {\n\t     cm_postread_hook(data_length, tmp_message_buffer);\n\t }\n     }\n     result = CMact_on_data(conn, message_buffer, tmp_message_buffer, data_length);\n     if (result != 0) {\n\t /* whoops, reevaluate.  We need more data */\n\t buffer_full_point += result;\n\t goto start_read;\n     }\n     /* OK, we consumed all data */\n     buffer_full_point = 0;\n     buffer_data_end = 0;\n     if (message_buffer) {\n\t cm_return_data_buf(cm, message_buffer);\n\t message_buffer = NULL;\n     }\n     read_msg_count++;\n     read_byte_count += data_length;\n\n     /* try read-ahead */\n     if (cm->abort_read_ahead == 1) {\n\t cm->abort_read_ahead = 0;\n\t CMtrace_out(cm, CMDataVerbose, \n\t\t     \"CM - readahead not tried, aborted for condition signal\\n\");\n\t return;\n     }\t\n     if ((read_msg_count > read_ahead_msg_limit) || \n\t (read_byte_count > read_ahead_byte_limit)) {\n\t CMtrace_out(cm, CMDataVerbose, \n\t\t     \"CM - readahead not tried, fairness, read %d msgs, %ld bytes\\n\",\n\t\t     read_msg_count, read_byte_count);\n\t return;\n     } else {\n\t goto start_read;\n     }\n }\n\n static void\n CMdo_handshake(CMConnection conn, int handshake_version, int byte_swap, char *base)\n {\n     int do_send = 1;\n     int remote_format_server_ID;\n     int remote_CManager_ID;\n     if (byte_swap) {\n\t ((char*)&remote_format_server_ID)[0] = base[3];\n\t ((char*)&remote_format_server_ID)[1] = base[2];\n\t ((char*)&remote_format_server_ID)[2] = base[1];\n\t ((char*)&remote_format_server_ID)[3] = base[0];\n\t ((char*)&remote_CManager_ID)[0] = base[7];\n\t ((char*)&remote_CManager_ID)[1] = base[6];\n\t ((char*)&remote_CManager_ID)[2] = base[5];\n\t ((char*)&remote_CManager_ID)[3] = base[4];\n     } else {\n\t remote_format_server_ID = ((int *) base)[0];\n\t remote_CManager_ID = ((int *) base)[1];\n     }\n\n     CMtrace_out(conn->cm, CMLowLevelVerbose, \"CM - Received CONN handshake message\\n\");\n     if ((remote_CManager_ID & 0x80000000) == 0x80000000) {\n\t /* the other fellow already has our ID */\n\t do_send = 0;\n\t remote_CManager_ID ^= 0x80000000;  /* kill high bit */\n     }\n     if (conn->remote_format_server_ID != 0) {\n\t if (conn->remote_format_server_ID != remote_format_server_ID) {\n\t     printf(\"Gaak.  Got a second handshake on connection 0x%p, with a different format server ID %x vs. %x\\n\",\n\t\t    conn, conn->remote_format_server_ID, remote_format_server_ID);\n\t } else {\n\t     printf(\"Less Gaak.  Got a second handshake on connection 0x%p, remote id %x\\n\",\n\t\t    conn, conn->remote_format_server_ID);\n\t }\n     } else {\n\t conn->remote_format_server_ID = remote_format_server_ID;\n\t conn->remote_CManager_ID = remote_CManager_ID;\n\t CMtrace_out(conn->cm, CMLowLevelVerbose, \"CM - CONN handshake condition %d\\n\", conn->handshake_condition);\n\t if (conn->handshake_condition != -1) {\n\t     INT_CMCondition_signal(conn->cm, conn->handshake_condition);\n\t     conn->handshake_condition = -1;\n\t }\n     }\n     if (do_send) {\n\t CMtrace_out(conn->cm, CMLowLevelVerbose, \"CM - Sending CONN handshake message\\n\");\n\t send_and_maybe_wait_for_handshake(conn->cm, conn);\n     } else {\n\t CMtrace_out(conn->cm, CMLowLevelVerbose, \"CM - *NOT* Sending CONN handshake message\\n\");\n     }\n }\n\n static int\n CMact_on_data(CMConnection conn, CMbuffer cm_buffer, char *buffer, long length)\n {\n     char *base = buffer;\n     char *check_sum_base = buffer;\n     int byte_swap = 0;\n     int get_attrs = 0;\n     int skip = 0;\n     int performance_msg = 0, event_msg = 0, evcontrol_msg = 0, handshake = 0;\n     int performance_func = 0, handshake_version = 0;\n     CMbuffer cm_decode_buf = NULL;\n     attr_list attrs = NULL;\n     int64_t data_length, decoded_length;\n     int attr_length = 0, i;\n     int header_len;\n     int stone_id;\n     char *decode_buffer = NULL, *data_buffer;\n     FFSTypeHandle local_format, original_format;\n     CManager cm = conn->cm;\n     CMincoming_format_list cm_format = NULL;\n     int message_key;\n     unsigned char checksum;\n     int short_length = 1;\n\n     if (length < 4) {\n\t return 4 - length;\n     }\n     message_key = 0x00ffff00 & *((int*)buffer);\n     switch (message_key) {  /* assume 4-byte int */\n     case 0x00444d00: /* \\0DMC reversed byte order */\n\t byte_swap = 1;\n     case 0x004d4400:  /* CMD\\0 */\n\t break;\n     case 0x00414d00: /* \\0AMC reversed byte order */\n\t byte_swap = 1;\n     case 0x004d4100:  /* CMA\\0 */\n\t get_attrs = 1;\n\t break;\n     case 0x00005645: /* \\0CVE reversed byte order */\n\t byte_swap = 1;\n     case 0x45560000: /* EVC\\0 */\n\t evcontrol_msg = 1;\n\t break;\n     case 0x00504d00: /* \\0PMC reversed byte order */\n\t byte_swap = 1;\n     case 0x004d5000:  /* CMP\\0 */\n\t performance_msg = 1;\n\t short_length = 0;\n\t break;\n     case 0x004c4d00: /* \\0LMC reversed byte order */\n\t byte_swap = 1;\n     case 0x004d4c00:  /* CML\\0 */\n\t event_msg = 1;\n\t get_attrs = 1;\n\t break;\n     case 0x00484d00: /* \\0HMC reversed byte order - handshake */\n\t byte_swap = 1;\n     case 0x004d4800:  /* CMH\\0 - handshake */\n\t handshake = 1;\n\t get_attrs = 0;\n\t break;\n     default:\n\t /*  non CM message */\n\t /*  lookup registered message prefixes and try to find handler */\n\t /*  otherwise give up */\n       {\n\t   int ret;\n\t   CMbuffer local = NULL;\n #ifdef EVER_HAVE_HANDLERS_OTHER_THAN_PBIO\n\t   if (cm_buffer == NULL) {\n\t       local = fill_cmbuffer(cm, buffer, length);\n\t       buffer = local->buffer;\n\t   }\n #endif\n\t   CManager_unlock(cm);\n\t   ret = CMdo_non_CM_handler(conn, *(int*)buffer, buffer, length);\n\t   CManager_lock(cm);\n\t   if (local) cm_return_data_buf(cm, local);\n\t   if (ret == -1) {\n\t       printf(\"Unknown message on connection %lx, failed %d, closed %d, %x\\n\", (long) conn, conn->failed, conn->closed, *(int*)buffer);\n\t       CMtrace_out(conn->cm, CMFreeVerbose, \"Calling connection unknown message failed with dereference %p\\n\", conn);\n\t       INT_CMConnection_failed(conn);\n\t   }\n\t   return 0;\n       }\n     }\n\n     if (get_attrs == 1) {\n\t if (!event_msg) {\n\t     header_len = 16;/* magic plus two 4-byte sizes (attrs + data) */\n\t     skip = 4;\n\t } else {\n\t     header_len = 16;\n\t }\n     } else {\n\t if (short_length) {\n\t     header_len = 8; /* magic plus 4-byte size */\n\t } else {\n\t     header_len = 12; /* magic plus 8-byte size */\n\t }\n     }\n\n     if (length < header_len) {\n\t return header_len - length;\n     }\n     base = buffer + 4 + skip; /* skip used data */\n     if (short_length) {\n\t if (byte_swap) {\n\t     int tmp;\n #ifdef WORDS_BIGENDIAN\t    \n\t     checksum = (unsigned char) check_sum_base[0];\n #else\n\t     checksum = (unsigned char) check_sum_base[3];\n #endif\n\t     ((char*)&tmp)[0] = base[3];\n\t     ((char*)&tmp)[1] = base[2];\n\t     ((char*)&tmp)[2] = base[1];\n\t     ((char*)&tmp)[3] = base[0];\n\t     data_length = tmp;\n\t     if (header_len != 8) {\n\t\t ((char*)&attr_length)[0] = base[7];\n\t\t ((char*)&attr_length)[1] = base[6];\n\t\t ((char*)&attr_length)[2] = base[5];\n\t\t ((char*)&attr_length)[3] = base[4];\n\t     }\n\t } else {\n #ifdef WORDS_BIGENDIAN\t    \n\t     checksum = (unsigned char) check_sum_base[3];\n #else\n\t     checksum = (unsigned char) check_sum_base[0];\n #endif\n\t     data_length = ((int *) base)[0];\n\t     if (header_len != 8) {\n\t\t attr_length = ((int *) base)[1];\n\t     }\n\t }\n     } else {\n\t if (byte_swap) {\n #ifdef WORDS_BIGENDIAN\t    \n\t     checksum = (unsigned char) check_sum_base[0];\n #else\n\t     checksum = (unsigned char) check_sum_base[3];\n #endif\n\t     int tmp;\n\t     ((char*)&tmp)[0] = base[3];\n\t     ((char*)&tmp)[1] = base[2];\n\t     ((char*)&tmp)[2] = base[1];\n\t     ((char*)&tmp)[3] = base[0];\n\t     data_length = ((int64_t)tmp) << 32;\n\t     ((char*)&tmp)[0] = base[7];\n\t     ((char*)&tmp)[1] = base[6];\n\t     ((char*)&tmp)[2] = base[5];\n\t     ((char*)&tmp)[3] = base[4];\n\t     if (header_len != 12) {\n\t\t ((char*)&attr_length)[0] = base[11];\n\t\t ((char*)&attr_length)[1] = base[10];\n\t\t ((char*)&attr_length)[2] = base[9];\n\t\t ((char*)&attr_length)[3] = base[8];\n\t     }\n\t } else {\n #ifdef WORDS_BIGENDIAN\t    \n\t     checksum = (unsigned char) check_sum_base[3];\n #else\n\t     checksum = (unsigned char) check_sum_base[0];\n #endif\n\t     data_length = ((int64_t)(((int *) base)[0])) << 32;\n\t     data_length += ((int *) base)[1];\n\t     if (header_len != 12) {\n\t\t attr_length = ((int *) base)[1];\n\t     }\n\t }\n     }\n     if (performance_msg || evcontrol_msg) {\n\t performance_func = 0xff & (data_length >> 56);\n\t data_length &= 0xffffffffffffff;\n\t data_length -= 12;  /* subtract off header size */\n     }\n     if (handshake) {\n\t handshake_version = 0xff & (data_length >> 24);\n\t data_length &= 0xffffff;\n\t data_length -= 8;  /* subtract off header size */\n     }\n     if (event_msg) {\n\t if (byte_swap) {\n\t     ((char*)&stone_id)[0] = base[11];\n\t     ((char*)&stone_id)[1] = base[10];\n\t     ((char*)&stone_id)[2] = base[9];\n\t     ((char*)&stone_id)[3] = base[8];\n\t } else {\n\t     stone_id = ((int *) base)[2];\n\t }\n     }\n\n     if (length < header_len + data_length + attr_length) {\n\t return header_len + data_length + attr_length - \n\t     length;\n     }\n     /* At this point, the message is accepted.  Determine processing */\n     base = buffer + header_len;\n     if (handshake) {\n\t CMdo_handshake(conn, handshake_version, byte_swap, base);\n\t return 0;\n     }\n     if (checksum != 0) {\n\t unsigned char calculated_checksum = 0;\n\t for (i=4; i < length; i++) {\n\t     calculated_checksum += ((unsigned char *)buffer)[i];\n\t }\n\t if (calculated_checksum != checksum) {\n\t     printf(\"Discarding incoming message because of corruption.  Checksum mismatch got %x, expected %x\\n\",\n\t\t    calculated_checksum, checksum);\n\t     printf(\"Message was : \");\n\t     for (i=0 ; i < length; i++) {\n\t\t printf(\" %02x\",  ((unsigned char *)buffer)[i]);\n\t     }\n\t     printf(\"\\n\");\n\t     return 0;\n\t }\n     }\n     if (performance_msg) {\n\t CMdo_performance_response(conn, data_length, performance_func, byte_swap,\n\t\t\t\t   base);\n\t return 0;\n     } else if (evcontrol_msg) {\n\t int arg;\n\t if (byte_swap) {\n\t     ((char*)&arg)[0] = base[3];\n\t     ((char*)&arg)[1] = base[2];\n\t     ((char*)&arg)[2] = base[1];\n\t     ((char*)&arg)[3] = base[0];\n\t } else {\n\t     arg = ((int *) base)[0];\n\t }\n #ifdef EV_INTERNAL_H\n\t INT_EVhandle_control_message(conn->cm, conn, (unsigned char) performance_func, arg);\n #endif\n\t return 0;\n     }\n     data_buffer = base + attr_length;\n     if (attr_length != 0) {\n\t attrs = CMdecode_attr_from_xmit(conn->cm, base);\n\t if (CMtrace_on(conn->cm, CMDataVerbose)) {\n\t     fprintf(cm->CMTrace_file, \"CM - Incoming read attributes -> \");\n\t     fdump_attr_list(cm->CMTrace_file, attrs);\n\t }\n     }\n     if (event_msg) {\n\t CMbuffer local = NULL;\n\t CMtrace_out(cm, CMDataVerbose, \"CM - Receiving event message data len %ld, attr len %d, stone_id %x\\n\",\n\t\t     (long)data_length, attr_length, stone_id);\n\t if (attrs == NULL){\n\t     attrs = CMcreate_attr_list(cm);\n\t }\n\t set_int_attr(attrs, CM_EVENT_SIZE, data_length);\n\t set_long_attr(attrs, CM_INCOMING_CONNECTION, (long)conn);\n\n\t if (cm_buffer == NULL) {\n\t     local = fill_cmbuffer(cm, buffer, length);\n\t     data_buffer = (data_buffer - buffer) + local->buffer;\n\t     buffer = local->buffer;\n\t     cm_buffer = local;\n\t }\n #ifdef EV_INTERNAL_H\t\n\t internal_cm_network_submit(cm, cm_buffer, attrs, conn, data_buffer,\n\t\t\t\t    data_length, stone_id);\n #endif\n\t if (local) cm_return_data_buf(cm, local);\n\t free_attr_list(attrs);\n\t return 0;\n     }\n     {\n\t FMFormat format = FMformat_from_ID(FMContext_from_FFS(cm->FFScontext), data_buffer);\n\t char *incoming_name;\n\t if (format == NULL) {\n\t     printf(\"BAD INCOMING DATA\\n\");\n\t     return 0;\n\t }\n\t incoming_name = name_of_FMformat(format);\n\n\t for (i = 0; i < cm->reg_format_count; i++) {\n\t     if ((cm->reg_formats[i]->registration_pending) && \n\t\t (strcmp(incoming_name, cm->reg_formats[i]->format_name) == 0)) {\n\t\t CMcomplete_format_registration(cm->reg_formats[i], 0);\n\t     }\n\t }\n     }\n     local_format = FFS_target_from_encode(conn->cm->FFScontext, data_buffer);\n     original_format = FFSTypeHandle_from_encode(conn->cm->FFScontext, data_buffer);\n     if (local_format == NULL) {\n\t fprintf(stderr, \"invalid format in incoming buffer\\n\");\n\t return 0;\n     }\n     CMtrace_out(cm, CMDataVerbose, \"CM - Receiving record of type %s, FFSformat %p\\n\", \n\t\t name_of_FMformat(FMFormat_of_original(original_format)), original_format);\n     for (i=0; i< cm->in_format_count; i++) {\n\t if (cm->in_formats[i].format == local_format) {\n\t     cm_format = &cm->in_formats[i];\n\t     CMtrace_out(cm, CMDataVerbose, \"CM - Found incoming cm_format %p, matching FFSformat %p\\n\", \n\t\t\t cm_format, local_format);\n\t }\n     }\n     if (cm_format == NULL) {\n\t cm_format = CMidentify_rollbackCMformat(cm, data_buffer);\n\t CMtrace_out(cm, CMDataVerbose, \"CM - Created cm_format %p, matching FFSformat %p\\n\", \n\t\t     cm_format, original_format);\n\t if(cm_format) {\n\t     CMtrace_out(cm, CMDataVerbose, \"CM - Calling CMcreate_conversion type %s, format %p\\n\", \n\t\t\t name_of_FMformat(FMFormat_of_original(original_format)), original_format);\n\t     CMcreate_conversion(cm, cm_format);\n\t     CMtrace_out(cm, CMDataVerbose, \"CM - after CMcreate_conversion format %p, has_conversion is %d\\n\", \n\t\t\t original_format, FFShas_conversion(original_format));\n\t }\n     }\n\n     if ((cm_format == NULL) || (cm_format->handler == NULL)) {\n\t fprintf(stderr, \"CM - No handler for incoming data of this version of format \\\"%s\\\"\\n\",\n\t\t name_of_FMformat(FMFormat_of_original(original_format)));\n\t return 0;\n     } else if (!FFShas_conversion(original_format)) {\n\t CMcreate_conversion(cm, cm_format);\n     }\n     assert(FFShas_conversion(original_format));\n\n     if (FFSdecode_in_place_possible(original_format)) {\n\t if (!FFSdecode_in_place(cm->FFScontext, data_buffer, \n\t\t\t\t\t(void**) (long) &decode_buffer)) {\n\t     printf(\"Decode failed\\n\");\n\t     return 0;\n\t }\n     } else {\n\t decoded_length = FFS_est_decode_length(cm->FFScontext, data_buffer, data_length);\n\t cm_decode_buf = cm_get_data_buf(cm, decoded_length);\n\t decode_buffer = cm_decode_buf->buffer;\n\t FFSdecode_to_buffer(cm->FFScontext, data_buffer, decode_buffer);\n     }\n     if(cm_format->older_format) {\n #ifdef EVOL\n\t if(!process_old_format_data(cm, cm_format, &decode_buffer, &cm_decode_buf)){\n\t     return 0;\n\t }\n #endif\n     }\n     if (CMtrace_on(conn->cm, CMDataVerbose)) {\n\t static int dump_char_limit = 256;\n\t static int warned = 0;\n\t static int size_set = 0;\n\t int r;\n\t if (size_set == 0) {\n\t     char *size_str = getenv(\"CMDumpSize\");\n\t     size_set++;\n\t     if (size_str != NULL) {\n\t\t dump_char_limit = atoi(size_str);\n\t     }\n\t }\n\t fprintf(cm->CMTrace_file, \"CM - record type %s, contents are:\\n  \", name_of_FMformat(FMFormat_of_original(cm_format->format)));\n\t r = FMfdump_data(cm->CMTrace_file, FMFormat_of_original(cm_format->format), decode_buffer, dump_char_limit);\n\t if (r && !warned) {\n\t     printf(\"\\n\\n  ****  Warning **** CM record dump truncated\\n\");\n\t     printf(\"  To change size limits, set CMDumpSize environment variable.\\n\\n\\n\");\n\t     warned++;\n\t }\n     }\n     if (attrs == NULL) {\n\t attrs = CMcreate_attr_list(cm);\n\t CMattr_merge_lists(cm, attrs, conn->attrs);\n     } else {\n\t CMattr_merge_lists(cm, attrs, conn->attrs);\n     }\n\n     /* \n      *  Handler may recurse, so clear these structures first\n      */\n     CMtrace_out(cm, CMFreeVerbose, \"CM - add reference connection %p - handler\\n\", conn);\n     INT_CMConnection_add_reference(conn);\n     {\n         CMHandlerFunc handler = cm_format->handler;\n\t void *client_data = cm_format->client_data;\n\t CMbuffer local = NULL;\n\t if ((cm_buffer == NULL) && (decode_buffer == NULL)) {\n\t     local = fill_cmbuffer(cm, buffer, length);\n\t     buffer = local->buffer;\n\t }\n\t CManager_unlock(cm);\n\t handler(cm, conn, decode_buffer, client_data, attrs);\n\t CManager_lock(cm);\n\t if (local) cm_return_data_buf(cm, local);\n\t CMtrace_out(cm, CMFreeVerbose, \"CM - delete reference connection %p - handler\\n\", conn);\n\t INT_CMConnection_dereference(conn);\n     }\n     if (cm_decode_buf) {\n\t cm_return_data_buf(cm, cm_decode_buf);\n\t cm_decode_buf = NULL;\n     }\n     if (attrs) {\n\t INT_CMfree_attr_list(cm, attrs);\n\t attrs = NULL;\n     }\n     CMtrace_out(cm, CMDataVerbose, \"CM - Finish processing - record of type %s\\n\", \n\t\t name_of_FMformat(FMFormat_of_original(original_format)));\n     return 0;\n }\n\n void *\n INT_CMtake_buffer(CManager cm, void *data)\n {\n     CMbuffer buf = cm_buffer_lookup(cm, data);\n     if (buf == NULL) {\n\t fprintf(stderr, \"Error: INT_CMtake_buffer called with record %p not associated with cm\\n\", data);\n\t cm_buffer_dump_list(cm);\n\t return NULL;\n     } else {\n\t buf->ref_count++;\n\t CMtrace_out(cm, CMBufferVerbose, \"CMtake_buffer, data %p found buffer %p, ref_count incremented, now %d\\n\", data, buf, buf->ref_count);\n\t return data;\n     }\n }\n\n extern void\n INT_CMreturn_buffer(CManager cm, void *data)\n {\n     CMbuffer buf = cm_buffer_lookup(cm, data);\n     if (buf == NULL) {\n\t fprintf(stderr, \"Error: INT_CMreturn_buffer called with record %p not associated with cm\\n\", data);\n\t cm_buffer_dump_list(cm);\n\t return;\n     }\n     CMtrace_out(cm, CMBufferVerbose, \"CMreturn_buffer, data %p found buffer %p, ref_count now %d, calling cm_return_data_buf\\n\", data, buf, buf->ref_count);\n     cm_return_data_buf(cm, buf);\n }\n\n void\n INT_CMregister_handler(CMFormat format, CMHandlerFunc handler,\n\t\t\tvoid *client_data)\n {\n     CManager cm = format->cm;\n     int i;\n     format->handler = handler;\n     format->client_data = client_data;\n\n     for (i=0; i< cm->in_format_count; i++) {\n\t if (cm->in_formats[i].format == format->ffsformat) {\n\t     if (!cm->in_formats[i].handler) {\n\t\t cm->in_formats[i].handler = handler;\n\t\t cm->in_formats[i].client_data = client_data;\n\t     } else if ((cm->in_formats[i].handler != handler) ||\n\t\t\t(cm->in_formats[i].client_data != client_data)) {\n\t\t fprintf(stderr, \"Warning, CMregister_handler() called multiple times for the same format with different handler or client_data\\n\");\n\t\t fprintf(stderr, \"Repeated calls will be ignored\\n\");\n\t     }\n\t }\n     }\n }\n\n extern int\n INT_CMwrite(CMConnection conn, CMFormat format, void *data)\n {\n     return INT_CMwrite_attr(conn, format, data, NULL);\n }\n\n extern void CMWriteQueuedData(transport_entry trans, CMConnection conn)\n {\n     attr_list attrs = NULL;  /* GSE fix */\n     CMtrace_out(conn->cm, CMLowLevelVerbose, \"CMWriteQueuedData, conn %lx, header %d, attr %d\\n\", \n\t\t (long)conn, conn->queued_data.rem_header_len, \n\t\t conn->queued_data.rem_attr_len);\n     if (conn->queued_data.rem_header_len != 0) {\n\t struct FFSEncodeVec tmp_vec[1];\n\t int actual;\n\t tmp_vec[0].iov_base = conn->queued_data.rem_header;\n\t tmp_vec[0].iov_len = conn->queued_data.rem_header_len;\n\t actual = trans->NBwritev_func(&CMstatic_trans_svcs,\n\t\t\t\t\t    conn->transport_data,\n\t\t\t\t\t    &tmp_vec[0], 1,\n\t\t\t\t\t    attrs);\n\t if (actual == -1) {\n\t     goto failed;\n\t }\n\t if (actual < conn->queued_data.rem_header_len) {\n\t     conn->queued_data.rem_header_len -= actual;\n\t     memmove(&conn->queued_data.rem_header[0],\n\t\t     &conn->queued_data.rem_header[actual],\n\t\t     conn->queued_data.rem_header_len);\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \"CMWriteQueuedData, conn %p, remaining header %d\\n\", \n\t\t\t conn, conn->queued_data.rem_header_len);\n\t     return;\n\t }\n     }\n     if (conn->queued_data.rem_attr_len != 0) {\n\t struct FFSEncodeVec tmp_vec[1];\n\t int actual;\n\t tmp_vec[0].iov_base = conn->queued_data.rem_attr_base;\n\t tmp_vec[0].iov_len = conn->queued_data.rem_attr_len;\n\t actual = trans->NBwritev_func(&CMstatic_trans_svcs,\n\t\t\t\t\t    conn->transport_data,\n\t\t\t\t\t    &tmp_vec[0], 1,\n\t\t\t\t\t    attrs);\n\t if (actual == -1) {\n\t     goto failed;\n\t }\n\t if (actual < conn->queued_data.rem_attr_len) {\n\t     conn->queued_data.rem_attr_len -= actual;\n\t     conn->queued_data.rem_attr_base += actual;\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \"CMWriteQueuedData, conn %p, remaining attr %d\\n\", \n\t\t\t conn, conn->queued_data.rem_attr_len);\n\t     return;\n\t }\n     }\n     if (conn->queued_data.vector_data) {\n\t int vec_count = 0;\n\t int length = 0;\n\t FFSEncodeVector vec = conn->queued_data.vector_data;\n\t int actual = 0;\n\n\t while(vec[vec_count].iov_base != NULL) {\n\t     length += vec[vec_count].iov_len;\n\t     vec_count++;\n\t }\n\t actual = trans->NBwritev_func(&CMstatic_trans_svcs,\n\t\t\t\t\t    conn->transport_data,\n\t\t\t\t\t    vec, vec_count,\n\t\t\t\t\t    attrs);\n\t if (actual == -1) {\n\t     goto failed;\n\t }\n\t if (actual < length) {\n\t     int i = 0;\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \"Continued partial pending write, %d bytes sent\\n\", actual);\n\t     while (actual > vec[i].iov_len) {\n\t\t actual -= vec[i].iov_len;\n\t\t i++;\n\t\t vec_count--;\n\t     }\n\t     vec[i].iov_len -= actual;\n\t     vec[i].iov_base = (char*)vec[i].iov_base + actual;\n\t     conn->queued_data.vector_data = &vec[i];\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \"CMWriteQueuedData, conn %lx, %d remaining data vectors\\n\", \n\t\t\t (long)conn, vec_count);\n\t     return;\n\t }\n     }\n     if (conn->queued_data.buffer_to_free) {\n\t cm_return_data_buf(conn->cm, conn->queued_data.buffer_to_free);\n     }\n     conn->write_pending = 0;\n     conn->trans->set_write_notify(conn->trans, &CMstatic_trans_svcs, \n\t\t\t\t   conn->transport_data, 0);\n\n     if(!CManager_locked(conn->cm)) {\n\t printf(\"Not LOCKED in write queued data!\\n\");\n     }\n     cm_wake_any_pending_write(conn);\n     return;\n  failed:\n     CMtrace_out(conn->cm, CMFreeVerbose, \"Calling write failed connection failed with dereference %p\\n\", conn);\n     INT_CMConnection_failed(conn);\n     if (conn->queued_data.buffer_to_free) {\n\t cm_return_data_buf(conn->cm, conn->queued_data.buffer_to_free);\n\t conn->queued_data.buffer_to_free = NULL;\n     }\n     conn->write_pending = 0;\n     conn->trans->set_write_notify(conn->trans, &CMstatic_trans_svcs, \n\t\t\t\t   conn->transport_data, 0);\n     cm_wake_any_pending_write(conn);\n     return;\n }\n\n static void\n transport_wake_any_pending_write(CMConnection conn)\n {\n\n     conn->write_pending = 0;\n     CMtrace_out(conn->cm, CMTransportVerbose, \"UNSet Pending write for conn %p\\n\", conn);\n     cm_wake_any_pending_write(conn);\n }\n\n static void\n cm_wake_any_pending_write(CMConnection conn)\n {\n     if (conn->write_callbacks) {\n\t int i = 0;\n\t CMConnHandlerListEntry callbacks[16];\n\t int callback_len = conn->write_callback_len;\n\t assert(conn->write_callback_len <= 16);\n\t memcpy(callbacks, conn->write_callbacks, sizeof(callbacks[0]) * conn->write_callback_len);\n\t for (i = 0; i < callback_len; ++i) {\n\t     if (callbacks[i].func) {\n\t\t (callbacks[i].func)(conn->cm, conn, callbacks[i].client_data);\n\t     }\n\t }\n\t CMtrace_out(conn->cm, CMTransportVerbose, \"Completed pending write, did %d notifications\\n\", i);\n     } else {\n\t CMtrace_out(conn->cm, CMTransportVerbose, \"Completed pending write, No notifications\\n\");\n     }\n     CMwake_server_thread(conn->cm);\n }\n\n static void\n cm_set_pending_write(CMConnection conn)\n {\n     assert(CManager_locked(conn->cm));\n     CMtrace_out(conn->cm, CMTransportVerbose, \"Set Pending write for conn %p\\n\", conn);\n     conn->write_pending = 1;\n }\n\n static void\n queue_remaining_write(CMConnection conn, FFSEncodeVector tmp_vec, \n\t\t       FFSEncodeVector pbio_vec, int vec_count,\n\t\t       attr_list attrs, int actual_bytes_written,\n\t\t       int attrs_present)\n {\n     int i = 0, j = 0;\n     int total_bytes = 0;\n     int remaining_bytes = 0;\n\n     for (i=0; i < vec_count; i++) {\n\t total_bytes += tmp_vec[i].iov_len;\n     }\n     remaining_bytes = total_bytes - actual_bytes_written;\n     i = 0;\n     while (actual_bytes_written > tmp_vec[i].iov_len) {\n\t actual_bytes_written -= tmp_vec[i].iov_len;\n\t i++;\n     }\n     tmp_vec[i].iov_len -= actual_bytes_written;\n     tmp_vec[i].iov_base = (char*)tmp_vec[i].iov_base + actual_bytes_written;\n     if (pbio_vec) {\n\t if (attrs_present) {\n\t     pbio_vec[i-2] = tmp_vec[i];\n\t } else {\n\t     pbio_vec[i-1] = tmp_vec[i];\n\t }\n     }\n     actual_bytes_written = 0;\n /*\n  *    Data is either:\n  *    vec 0 = header\n  *    vec 1 = ffs\n  *    vec 2 = ffs\n\n  *    vec 0 = header\n  *    vec 1 = attrs\n  *    vec 2 = ffs\n  *    vec 2 = ffs\n\n  *    vec 0 = header\n  *    vec 1 = notffs\n  *    vec 2 = notffs\n\n  *    vec 0 = header\n  *    vec 1 = attrs\n  *    vec 2 = notffs\n  *    vec 2 = notffs\n  */\n\n     conn->queued_data.buffer_to_free = NULL;\n\n     if (i == 0) {\n\t /* didn't even write the 8 or 12 or 16 or 24 byte header */\n\t assert(sizeof(conn->queued_data.rem_header) >= tmp_vec[0].iov_len);\n\t memcpy(&conn->queued_data.rem_header, tmp_vec[0].iov_base, \n\t\ttmp_vec[0].iov_len);\n\t conn->queued_data.rem_header_len = tmp_vec[0].iov_len;\n     } else {\n\t conn->queued_data.rem_header_len = 0;\n     }\n     if (attrs_present && (i <= 1)) {\n\t /* got stuck in encoded attributes */\n\t conn->queued_data.rem_attr_base = tmp_vec[1].iov_base;\n\t conn->queued_data.rem_attr_len = tmp_vec[1].iov_len;\n\t i++;\n     } else {\n\t conn->queued_data.rem_attr_len = 0;\n     }\n\n\n     /* fixup pbio_vec */\n     j = i - 1;  /* how far into the pbio vector are we? */\n     if (attrs_present) j--;\n     if (j == -1) {\n\t /* no PBIO data */\n\t conn->queued_data.vector_data = NULL;\n\t return;\n     }\n     if (pbio_vec == NULL) {\n\t /* DATA NOT FFS, don't do optimized copying */\n\t /* Errr, something smarter here */\n\t int data_length = remaining_bytes - conn->queued_data.rem_attr_len - conn->queued_data.rem_header_len;\n\t int length = data_length + (sizeof(tmp_vec[0])*2);\n\t char *ptr;\n\t CMbuffer buf = cm_get_data_buf(conn->cm, length);\n\t FFSEncodeVector vec = buf->buffer;\n\t vec[0].iov_len = data_length;\n\t vec[0].iov_base = buf->buffer + (sizeof(tmp_vec[0])*2);\n\t vec[1].iov_len = 0;\n\t vec[1].iov_base = NULL;\n\t conn->queued_data.buffer_to_free = buf;\n\t conn->queued_data.vector_data = vec;\n\t if (i == 0) i=1;\n\t if (attrs_present && i <= 1) i=2;\n\t ptr = vec[0].iov_base;\n\t while (i < vec_count) {\n\t     memcpy(ptr, tmp_vec[i].iov_base, tmp_vec[i].iov_len);\n\t     ptr += tmp_vec[i].iov_len;\n\t     data_length -= tmp_vec[i].iov_len;\n\t     i++;\n\t }\n\t return;\n     } else {\n\t conn->queued_data.buffer_to_free = NULL;\n     }\n     if (j >= 0) {\n\t CMtrace_out(conn->cm, CMLowLevelVerbose, \"Removing from pbio_vec at offset %d\\n\", (int) j);\n\t pbio_vec[j].iov_len -= actual_bytes_written;\n\t pbio_vec[j].iov_base = (char*)pbio_vec[j].iov_base + \n\t     actual_bytes_written;\n     } else {\n\t j = 0;  /* nothing written */\n     }\n\n     /* \n      * copy application data (which had been left in place) into temporary\n      * PBIO buffer as well.\n      */\n     conn->queued_data.vector_data = \n\t copy_all_to_FFSBuffer(conn->io_out_buffer, &pbio_vec[j]);\n     tmp_vec = conn->queued_data.vector_data;\n     i = 0; \n }\n\n static void\n remove_pending_write_callback_by_id(CMConnection conn, int id) {\n     assert(id < conn->write_callback_len && id >= 0);\n     conn->write_callbacks[id].func = NULL;\n }\n\n static void\n remove_pending_write_callback(CMConnection conn, CMWriteCallbackFunc handler,\n\t\t\t       void *client_data)\n {\n     int i = 0;\n     while (conn->write_callbacks[i].func != handler\n\t      && conn->write_callbacks[i].client_data != client_data) i++;\n     conn->write_callbacks[i].func = NULL;\n }\n\n static int\n add_pending_write_callback(CMConnection conn, CMWriteCallbackFunc handler, \n\t\t\t    void* client_data)\n {\n     int count = 0;\n     while (conn->write_callbacks && count < conn->write_callback_len &&\n\t    (conn->write_callbacks[count].func != NULL)) count++;\n     if (count + 1 > conn->write_callback_len) {\n\t if (conn->write_callbacks == NULL) {\n\t     conn->write_callbacks = malloc(sizeof(conn->write_callbacks[0]));\n\t     conn->write_callback_len = 1;\n\t } else {\n\t     conn->write_callbacks = \n\t\t realloc(conn->write_callbacks,\n\t\t\t sizeof(conn->write_callbacks[0])*(count+1));\n\t     conn->write_callback_len = count+1;\n\t }\n     }\n     conn->write_callbacks[count].func = handler;\n     conn->write_callbacks[count].client_data = client_data;\n     return count;\n }\n\n\n static void\n wake_pending_write(CManager cm, CMConnection conn, void *param)\n {\n     int cond = (long)param;\n     remove_pending_write_callback(conn, wake_pending_write, param);\n     INT_CMCondition_signal(cm, cond);\n }\n\n void\n wait_for_pending_write(CMConnection conn)\n {\n     CMControlList cl = conn->cm->control_list;\n     assert(CManager_locked(conn->cm));\n     CMtrace_out(conn->cm, CMLowLevelVerbose, \"Wait for pending write for conn %p\\n\", conn);\n\n     if ((!cl->has_thread) || (thr_thread_self() == cl->server_thread)) {\n\t /* single thread working, just poll network */\n\t while(conn->write_pending && !conn->closed) {\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \"Control list wait for conn %p\\n\", conn);\n\t     CMcontrol_list_wait(cl);\n\t }\n     } else {\n\t /* other thread is handling the network wait for it to wake us up */\n\t while (conn->write_pending && !conn->closed) {\n\t     int cond = INT_CMCondition_get(conn->cm, conn);\n\t     add_pending_write_callback(conn, wake_pending_write, \n\t\t\t\t\t(void*) (long)cond);\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \"Condition wait for conn %p\\n\", conn);\n\t     if (INT_CMCondition_wait(conn->cm, cond) == 0) {\n\t\t /* condition wait failed, connection is dead */\n\t\t conn->write_pending = 0;\n\t     }\n\t }\n     }\t    \n     CMtrace_out(conn->cm, CMLowLevelVerbose, \"Done waiting for pending write for conn %p\\n\", conn);\n }\n\n void\n INT_CMConnection_wait_for_pending_write(CMConnection conn)\n {\n     wait_for_pending_write(conn);\n }\n\n int\n INT_CMwrite_raw(CMConnection conn, FFSEncodeVector full_vec, FFSEncodeVector data_vec,\n\t\t long vec_count, long byte_count, attr_list attrs, int data_vec_stack)\n {\n     return INT_CMwrite_raw_notify(conn, full_vec, data_vec, vec_count, byte_count, attrs, data_vec_stack,\n\t\t\t\t   NULL, NULL);\n }\n\n /* Returns 1 if successful, -1 if deferred, 0 on error */\n int\n INT_CMwrite_raw_notify(CMConnection conn, FFSEncodeVector full_vec, FFSEncodeVector data_vec,\n\t\t\tlong vec_count, long byte_count, attr_list attrs, int data_vec_stack,\n\t\t\tCMcompletion_notify_func notify_func, void *notify_client_data)\n {\n     int actual = 0;\n     unsigned char checksum = 0;\n     int i, j, start;\n     long count = 0;\n     long length = 0;\n     if (conn->closed || conn->failed) return 0;\n\n     if (conn->write_pending) {\n\t wait_for_pending_write(conn);\n     }\n     for (i=0; i < vec_count; i++) {\n\t length += full_vec[i].iov_len;\n     }\n     start = 4;\n     if (length < 10240) {\n\t /* do checksum for small messages */\n\t for (i=0; i < vec_count; i++) {\n\t     count += full_vec[i].iov_len - start;\n\t     for (j=start; j< full_vec[i].iov_len; j++) {\n\t\t checksum += ((unsigned char*)full_vec[i].iov_base)[j];\n\t     }\n\t     start = 0;\n\t }\n     }\n     ((int*)full_vec[0].iov_base)[0] = \n\t (((int*)full_vec[0].iov_base)[0] & 0xffffff00) | (unsigned char) checksum;\n     if ((conn->do_non_blocking_write == 1) && (conn->trans->NBwritev_func)) {\n\t int actual_bytes;\n\t actual_bytes = \n\t     conn->trans->NBwritev_func(&CMstatic_trans_svcs, \n\t\t\t\t\t     conn->transport_data, \n\t\t\t\t\t     full_vec, vec_count, attrs);\n\t if (actual_bytes < 0) {\n\t     CMtrace_out(conn->cm, CMFreeVerbose, \"Calling write failed connection failed with dereference %p\\n\", conn);\n\t     INT_CMConnection_failed(conn);\n\t     if (conn->queued_data.buffer_to_free) {\n\t\t cm_return_data_buf(conn->cm, conn->queued_data.buffer_to_free);\n\t\t conn->queued_data.buffer_to_free = NULL;\n\t     }\n\t     conn->write_pending = 0;\n\t     conn->trans->set_write_notify(conn->trans, &CMstatic_trans_svcs, \n\t\t\t\t\t   conn->transport_data, 0);\n\t     cm_wake_any_pending_write(conn);\n\t }\n\t if (actual_bytes < length) {\n\t     /* copy remaining and send it later */\n\t     if (actual_bytes < 0 ) actual_bytes = 0;\n\t     if (data_vec_stack) {\n\t\t data_vec = copy_vector_to_FFSBuffer(conn->io_out_buffer, data_vec);\n\t     }\n\t     queue_remaining_write(conn, full_vec, data_vec, vec_count, \n\t\t\t\t   attrs, actual_bytes, attrs != NULL);\n\t     conn->trans->set_write_notify(conn->trans, &CMstatic_trans_svcs, conn->transport_data, 1);\n\t     conn->write_pending = 1;\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \n\t\t\t \"Partial write, queued %ld bytes\\n\",\n\t\t\t length - actual_bytes);\n\t     return 1;\n\t }\n\t actual = vec_count;  /* set actual for success */\n     } else if (conn->trans->writev_complete_notify_func && notify_func) {\n\t actual = conn->trans->writev_complete_notify_func(&CMstatic_trans_svcs, \n\t\t\t\t\t\t\t   conn->transport_data, \n\t\t\t\t\t\t\t   full_vec, vec_count, \n\t\t\t\t\t\t\t   attrs, notify_func, notify_client_data);\n     } else {\n\t actual = conn->trans->writev_func(&CMstatic_trans_svcs, \n\t\t\t\t\t   conn->transport_data, \n\t\t\t\t\t   full_vec, vec_count, attrs);\n\t if (actual <= 0) {\n\t     CMtrace_out(conn->cm, CMFreeVerbose, \"Calling write failed connection failed with dereference %p\\n\", conn);\n\t     INT_CMConnection_failed(conn);\n\t }\n\t if (notify_func) {\n\t     (notify_func)(notify_client_data);\n\t }\n     }\n     return actual == vec_count ? 1 : 0;\n }\n\n extern int\n INT_CMwrite_evcontrol(CMConnection conn, unsigned char type, int argument) {\n     int evcontrol_header[2] = {0x45564300, 0};\n     struct FFSEncodeVec static_vec[3];\n     int success;\n     FFSEncodeVector vec = &static_vec[0];\n     assert(sizeof(int) == 4);\n     vec[0].iov_base = evcontrol_header;\n     vec[0].iov_len = sizeof(evcontrol_header);\n     vec[1].iov_base = &argument; /* XXX int size */\n     vec[1].iov_len = sizeof(int);\n     vec[2].iov_base = NULL;\n     vec[2].iov_len = 0;\n     evcontrol_header[1] = type << 24 | (sizeof(evcontrol_header) + sizeof(int));\n     success = INT_CMwrite_raw(conn, vec, vec + 1, 2, evcontrol_header[1] & 0xffffff, NULL, 1) != 0;\n     return success;\n }\n\n extern int\n INT_CMwrite_attr(CMConnection conn, CMFormat format, void *data, \n\t\t  attr_list attrs)\n {\n     /* GSE MUST FIX for LONG */\n     int no_attr_header[2] = {0x434d4400, 0};  /* CMD\\0 in first entry */\n     int attr_header[4] = {0x434d4100, 0x434d4100, 0, 0};  /* CMA\\0 in first entry */\n     FFSEncodeVector vec;\n     int length = 0, vec_count = 0, actual;\n     int do_write = 1;\n     void *encoded_attrs = NULL;\n     int attrs_present = 0;\n     CManager cm = conn->cm;\n\n     /* ensure conn is open */\n     if (conn->closed != 0) {\n\t CMtrace_out(conn->cm, CMDataVerbose, \"Not writing data to closed connection\\n\");\n\t return 0;\n     }\n     if (conn->failed != 0) {\n\t CMtrace_out(conn->cm, CMDataVerbose, \"Not writing data to failed connection\\n\");\n\t return 0;\n     }\n     if (conn->write_pending) {\n\t wait_for_pending_write(conn);\n     }\n     if (conn->closed != 0) {\n\t CMtrace_out(conn->cm, CMDataVerbose, \"Not writing data to closed connection\\n\");\n\t return 0;\n     }\n     if (format->registration_pending) {\n\t CMcomplete_format_registration(format, 1);\n     }\n     if (format->fmformat == NULL) {\n\t printf(\"Format registration has failed for format \\\"%s\\\" - write aborted\\n\",\n\t\tformat->format_name);\n\t return 0;\n     }\n     if (conn->closed != 0) {\n\t CMtrace_out(conn->cm, CMDataVerbose, \"Not writing data to closed connection\\n\");\n\t return 0;\n     }\n     CMformat_preload(conn, format);\n\n     if (conn->closed != 0) {\n\t return 0;\n     }\n     if (CMtrace_on(conn->cm, CMDataVerbose)) {\n\t static int dump_char_limit = 256;\n\t static int warned = 0;\n\t static int size_set = 0;\n\t int r;\n\t if (size_set == 0) {\n\t     char *size_str = getenv(\"CMDumpSize\");\n\t     size_set++;\n\t     if (size_str != NULL) {\n\t\t dump_char_limit = atoi(size_str);\n\t     }\n\t }\n\t fprintf(cm->CMTrace_file, \"CM - Writing record of type %s\\n\",\n\t\tname_of_FMformat(format->fmformat));\n\t if (attrs != NULL) {\n\t     fprintf(cm->CMTrace_file, \"CM - write attributes are:\");\n\t     fdump_attr_list(cm->CMTrace_file, attrs);\n\t }\n\t fprintf(cm->CMTrace_file, \"CM - record type %s, contents are:\\n  \", name_of_FMformat(format->fmformat));\n\t r = FMfdump_data(cm->CMTrace_file, format->fmformat, data, dump_char_limit);\n\t if (r && !warned) {\n\t     fprintf(cm->CMTrace_file, \"\\n\\n  ****  Warning **** CM record dump truncated\\n\");\n\t     fprintf(cm->CMTrace_file, \"  To change size limits, set CMDumpSize environment variable.\\n\\n\\n\");\n\t     warned++;\n\t }\n     }\n\n     /* encode data with CM context */\n     vec = FFSencode_vector(conn->io_out_buffer, format->fmformat, data);\n     while(vec[vec_count].iov_base != NULL) {\n\t length += vec[vec_count].iov_len;\n\t vec_count++;\n     }\n     no_attr_header[1] = length;\n     attr_header[2] = length;\n     if (attrs != NULL) {\n\t attrs_present++;\n\t encoded_attrs = encode_attr_for_xmit(attrs, conn->attr_encode_buffer,\n\t\t\t\t\t      &attr_header[3]);\n\t attr_header[3] = (attr_header[3] +7) & -8;  /* round up to even 8 */\n     }\n     CMtrace_out(conn->cm, CMDataVerbose, \"CM - Total write size is %d bytes data + %d bytes attrs\\n\", length, attr_header[3]);\n     if (cm_write_hook != NULL) {\n\t do_write = cm_write_hook(length);\n     }\n     if (do_write) {\n\t struct FFSEncodeVec static_vec[100];\n\t FFSEncodeVector tmp_vec = &static_vec[0];\n\t int byte_count = length;/* sum lengths */\n\t if (vec_count >= sizeof(static_vec)/ sizeof(static_vec[0])) {\n\t     tmp_vec = INT_CMmalloc((vec_count+1) * sizeof(*tmp_vec));\n\t }\n\t if (attrs == NULL) {\n\t     tmp_vec[0].iov_base = &no_attr_header;\n\t     tmp_vec[0].iov_len = sizeof(no_attr_header);\n\t     memcpy(&tmp_vec[1], vec, sizeof(*tmp_vec) * vec_count);\n\t     vec_count++;\n\t     byte_count += sizeof(no_attr_header);\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \n\t\t\t \"Writing %d vectors, total %d bytes in writev\\n\", \n\t\t\t vec_count, byte_count);\n\t } else {\n\t     tmp_vec[0].iov_base = &attr_header;\n\t     tmp_vec[0].iov_len = sizeof(attr_header);\n\t     tmp_vec[1].iov_base = encoded_attrs;\n\t     tmp_vec[1].iov_len = attr_header[3];\n\t     memcpy(&tmp_vec[2], vec, sizeof(*tmp_vec) * vec_count);\n\t     byte_count += sizeof(attr_header) + attr_header[3];\n\t     vec_count += 2;\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \n\t\t\t \"Writing %d vectors, total %d bytes (including attrs) in writev\\n\", \n\t\t\t vec_count, byte_count);\n\t }\n\n\t actual = INT_CMwrite_raw(conn, tmp_vec, vec, vec_count, byte_count, attrs, 0);\n\t if (tmp_vec != &static_vec[0]) {\n\t     INT_CMfree(tmp_vec);\n\t }\n\t if (actual == 0) {\n\t     /* fail */\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \n\t\t\t \"Writev failed\\n\");\n\t     return 0;\n\t }\n     }\n     CMtrace_out(conn->cm, CMLowLevelVerbose, \"Writev success\\n\");\n     return 1;\n }\n\n #ifdef EV_INTERNAL_H\n extern int\n internal_write_event(CMConnection conn, CMFormat format, void *remote_path_id,\n\t\t      int path_len, event_item *event, attr_list attrs, long *event_len_p)\n {\n     FFSEncodeVector vec;\n     struct FFSEncodeVec preencoded_vec[2];\n     long data_length = 0, actual;\n     int vec_count = 0, attr_len = 0;\n     int do_write = 1;\n     void *encoded_attrs = NULL;\n     int attrs_present = 0;\n     CManager cm = conn->cm;\n\n     /* ensure conn is open */\n     if (conn->closed != 0) {\n\t CMtrace_out(conn->cm, CMDataVerbose, \"Not writing data to closed connection\\n\");\n\t return 0;\n     }\n     if (conn->failed != 0) {\n\t CMtrace_out(conn->cm, CMDataVerbose, \"Not writing data to failed connection\\n\");\n\t return 0;\n     }\n     if (conn->write_pending) {\n\t wait_for_pending_write(conn);\n     }\n     if (format->registration_pending) {\n\t CMcomplete_format_registration(format, 1);\n     }\n     if (format->fmformat == NULL) {\n\t printf(\"Format registration has failed for format \\\"%s\\\" - write aborted\\n\",\n\t\tformat->format_name);\n\t return 0;\n     }\n     CMformat_preload(conn, format);\n\n     if (CMtrace_on(conn->cm, CMDataVerbose)) {\n\t static int dump_char_limit = 256;\n\t static int warned = 0;\n\t static int size_set = 0;\n\t int r;\n\t if (size_set == 0) {\n\t     char *size_str = getenv(\"CMDumpSize\");\n\t     size_set++;\n\t     if (size_str != NULL) {\n\t\t dump_char_limit = atoi(size_str);\n\t     }\n\t }\n\t fprintf(cm->CMTrace_file, \"CM - Writing EVENT record %lx of type %s\\n\", (long)event,\n\t\tname_of_FMformat(format->fmformat));\n\t if (attrs != NULL) {\n\t     fprintf(cm->CMTrace_file, \"CM - write attributes are:\");\n\t     fdump_attr_list(cm->CMTrace_file, attrs);\n\t } else {\n\t     fprintf(cm->CMTrace_file, \"CM - write attrs NULL\\n\");\n\t }\n\t fprintf(cm->CMTrace_file, \"CM - record type %s, contents \", name_of_FMformat(format->fmformat));\n\t if (event->decoded_event) {\n\t     fprintf(cm->CMTrace_file, \"DECODED are:\\n  \");\n\t     r = FMfdump_data(cm->CMTrace_file, format->fmformat, event->decoded_event,\n\t\t\t      dump_char_limit);\n\t } else {\n\t     fprintf(cm->CMTrace_file, \"ENCODED are:\\n  \");\n\t     r = FMfdump_encoded_data(cm->CMTrace_file, format->fmformat,\n\t\t\t\t      event->encoded_event, dump_char_limit);\n\t }\t    \n\t if (r && !warned) {\n\t     fprintf(cm->CMTrace_file, \"\\n\\n  ****  Warning **** CM record dump truncated\\n\");\n\t     fprintf(cm->CMTrace_file, \"  To change size limits, set CMDumpSize environment variable.\\n\\n\\n\");\n\t     warned++;\n\t }\n     }\n\n     if (!event->encoded_event) {\n\t /* encode data with CM context */\n\t vec = FFSencode_vector(conn->io_out_buffer,\n\t\t\t\tformat->fmformat, event->decoded_event);\n\t while(vec[vec_count].iov_base != NULL) {\n\t     data_length += vec[vec_count].iov_len;\n\t     vec_count++;\n\t }\n     } else {\n\t vec = &preencoded_vec[0];\n\t preencoded_vec[0].iov_base = event->encoded_event;\n\t preencoded_vec[0].iov_len = event->event_len;\n\t preencoded_vec[1].iov_base = NULL;\n\t preencoded_vec[1].iov_len = 0;\n\t vec_count = 1;\n\t data_length = event->event_len;\n     }\n     if (attrs != NULL) {\n\t attrs_present++;\n\t encoded_attrs = encode_attr_for_xmit(attrs, conn->attr_encode_buffer,\n\t\t\t\t\t      &attr_len);\n\t attr_len = (attr_len +7) & -8;  /* round up to even 8 */\n     }\n     CMtrace_out(conn->cm, CMDataVerbose, \"CM - Total write size is %ld bytes data + %d bytes attrs\\n\", data_length, attr_len);\n     if (cm_write_hook != NULL) {\n\t do_write = cm_write_hook(data_length);\n     }\n     if (do_write) {\n\t struct FFSEncodeVec static_vec[100];\n\t FFSEncodeVector tmp_vec = &static_vec[0];\n\t int byte_count = data_length;/* sum lengths */\n\t int header[4] = {0x434d4C00, 0, 0, 0};  /* CML\\0 in first entry */\n\t if (vec_count >= sizeof(static_vec)/ sizeof(static_vec[0])) {\n\t     tmp_vec = INT_CMmalloc((vec_count+3) * sizeof(*tmp_vec));\n\t }\n\t header[1] = data_length;\n\t if (path_len != 4) {\n\t     header[0] = 0x434d4700;\n\t     header[3] = (path_len + 7) & -8;\n\t } else {\n\t     header[0] = 0x434d4C00;  /* 4 byte chan ID */\n\t     header[3] = *((int*)remote_path_id);\n\t }\n\t if (attrs == NULL) {\n\t     FFSEncodeVector assign_vec = tmp_vec;\n\t     header[2] = 0;\n\t     if (path_len != 4) {\n\t\t tmp_vec[1].iov_base = remote_path_id;\n\t\t tmp_vec[1].iov_len = (path_len + 7) & -8;\n\t\t byte_count += tmp_vec[1].iov_len;\n\t\t assign_vec++;\n\t     }\n\t     tmp_vec[0].iov_base = &header;\n\t     tmp_vec[0].iov_len = sizeof(header);\n\t     memcpy(&assign_vec[1], vec, sizeof(*tmp_vec) * vec_count);\n\t     vec_count++;\n\t     byte_count += sizeof(header);\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \n\t\t\t \"Writing %d vectors, total %d bytes in writev\\n\", \n\t\t\t vec_count, byte_count);\n\t } else {\n\t     tmp_vec[0].iov_base = &header;\n\t     tmp_vec[0].iov_len = sizeof(header);\n\t     tmp_vec[1].iov_base = encoded_attrs;\n\t     header[2] = attr_len;\n\t     tmp_vec[1].iov_len = attr_len;\n\t     memcpy(&tmp_vec[2], vec, sizeof(*tmp_vec) * vec_count);\n\t     byte_count += sizeof(header) + header[2];\n\t     vec_count += 2;\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \n\t\t\t \"Writing %d vectors, total %d bytes (including attrs) in writev\\n\", \n\t\t\t vec_count, byte_count);\n\t }\n\t actual = INT_CMwrite_raw(conn, tmp_vec, vec, vec_count, byte_count, attrs,\n\t\t\t\t     vec == &preencoded_vec[0]);\n\t if (tmp_vec != &static_vec[0]) {\n\t     INT_CMfree(tmp_vec);\n\t }\n\t if (actual <= 0) {\n\t     /* fail */\n\t     CMtrace_out(conn->cm, CMFreeVerbose, \"Calling connection (write failed) failed with dereference %p\\n\", conn);\n\t     INT_CMConnection_failed(conn);\n\t     CMtrace_out(conn->cm, CMLowLevelVerbose, \n\t\t\t \"Writev failed\\n\");\n\t     return 0;\n\t }\n     }\n     if (event_len_p) *event_len_p = data_length;\n     CMtrace_out(conn->cm, CMLowLevelVerbose, \"Writev success\\n\");\n     return 1;\n }\n #endif\n\n static void\n init_non_blocking_conn(CMConnection conn)\n {\n     /* default */\n     conn->do_non_blocking_write = 0;\n\n     if (conn->trans->NBwritev_func == NULL) return;\n     if (conn->trans->set_write_notify == NULL) return;\n\n     /* only if we make it this far should we try non blocking writes */\n     conn->do_non_blocking_write = 1;\n }\n\n extern int\n INT_CMConnection_write_would_block(CMConnection conn)\n {\n     if (conn->do_non_blocking_write == -1) {\n\t init_non_blocking_conn(conn);\n     }\n     return conn->write_pending;\n }\n\n extern int \n INT_CMregister_write_callback(CMConnection conn, CMWriteCallbackFunc handler,\n\t\t\t       void *client_data)\n {\n     if (conn->do_non_blocking_write == -1) {\n\t init_non_blocking_conn(conn);\n     }\n     return add_pending_write_callback(conn, handler, client_data);\n }\n\n extern void\n INT_CMunregister_write_callback(CMConnection conn, int id)\n {\n     remove_pending_write_callback_by_id(conn, id);\n }\n\n extern void\n INT_CM_fd_add_select(CManager cm, int fd, select_list_func handler_func,\n\t\t      void *param1, void *param2)\n {\n     if (!handler_func) {\n\t CMtrace_out(cm, EVWarning, \"INT_CM_fd_add_select called with bogus notification function; ignored\\n\");\n\t return;\n     }\n     if (!cm->control_list->select_initialized) {\n\t CM_init_select(cm->control_list, cm);\n     }\n     cm->control_list->add_select(&CMstatic_trans_svcs,\n\t\t\t\t  &cm->control_list->select_data, fd,\n\t\t\t\t  handler_func, param1, param2);\n }\n\n extern void\n CM_fd_write_select(CManager cm, int fd, select_list_func handler_func,\n\t\t    void *param1, void *param2)\n {\n     if (!cm->control_list->select_initialized) {\n\t CM_init_select(cm->control_list, cm);\n     }\n     cm->control_list->write_select(&CMstatic_trans_svcs,\n\t\t\t\t    &cm->control_list->select_data, fd,\n\t\t\t\t    handler_func, param1, param2);\n }\n\n extern void\n CM_fd_remove_select(CManager cm, int fd)\n {\n     if (!cm->control_list->select_initialized) {\n\t CM_init_select(cm->control_list, cm);\n     }\n     cm->control_list->remove_select(&CMstatic_trans_svcs,\n\t\t\t\t     &cm->control_list->select_data, fd);\n }\n\n extern CMTaskHandle\n INT_CMadd_periodic(CManager cm, long period, CMPollFunc func,\n\t\t    void *client_data)\n {\n     CMTaskHandle handle = INT_CMmalloc(sizeof(*handle));\n     if (!cm->control_list->select_initialized) {\n\t CM_init_select(cm->control_list, cm);\n     }\n     handle->cm = cm;\n     handle->task = \n\t cm->control_list->add_periodic(&CMstatic_trans_svcs,\n\t\t\t\t\t&cm->control_list->select_data,\n\t\t\t\t\t0, period, (select_list_func)func, \n\t\t\t\t\t(void*)cm, client_data);\n     if (handle->task == NULL) {\n\t free(handle);\n\t return NULL;\n     }\n     return handle;\n }\n\n extern CMTaskHandle\n INT_CMadd_periodic_task(CManager cm, int period_sec, int period_usec,\n\t\t\t CMPollFunc func, void *client_data)\n {\n     CMTaskHandle handle = INT_CMmalloc(sizeof(*handle));\n     if (!cm->control_list->select_initialized) {\n\t CM_init_select(cm->control_list, cm);\n     }\n     handle->cm = cm;\n     handle->task = \n\t cm->control_list->add_periodic(&CMstatic_trans_svcs,\n\t\t\t\t\t&cm->control_list->select_data,\n\t\t\t\t\tperiod_sec, period_usec, \n\t\t\t\t\t(select_list_func)func, \n\t\t\t\t\t(void*)cm, client_data);\n     if (handle->task == NULL) {\n\t free(handle);\n\t return NULL;\n     }\n     return handle;\n }\n\n extern void\n INT_CMremove_periodic(CMTaskHandle handle)\n {\n     CManager cm = handle->cm;\n     cm->control_list->remove_periodic(&CMstatic_trans_svcs,\n\t\t\t\t       &cm->control_list->select_data, \n\t\t\t\t       handle->task);\n     free(handle);\n }\n\n extern void\n INT_CMremove_task(CMTaskHandle handle)\n {\n     CManager cm = handle->cm;\n     cm->control_list->remove_periodic(&CMstatic_trans_svcs,\n\t\t\t\t       &cm->control_list->select_data, \n\t\t\t\t       handle->task);\n     free(handle);\n }\n\n extern CMTaskHandle\n INT_CMadd_delayed_task(CManager cm, int delay_sec, int delay_usec, \n\t\t\tCMPollFunc func, void *client_data)\n {\n     CMTaskHandle handle = INT_CMmalloc(sizeof(*handle));\n     if (!cm->control_list->select_initialized) {\n\t CM_init_select(cm->control_list, cm);\n     }\n     handle->cm = cm;\n     handle->task = \n\t cm->control_list->add_delayed_task(&CMstatic_trans_svcs,\n\t\t\t\t\t    &cm->control_list->select_data,\n\t\t\t\t\t    delay_sec, delay_usec,\n\t\t\t\t\t    (select_list_func)func, \n\t\t\t\t\t    (void*)cm, client_data);\n     if (handle->task == NULL) {\n\t free(handle);\n\t return NULL;\n     }\n     return handle;\n }\n\n typedef void (*SelectInitFunc)(CMtrans_services svc, CManager cm, void *client_data);\n\n static void\n select_shutdown(CManager cm, void *shutdown_funcv)\n {\n     SelectInitFunc shutdown_function = (SelectInitFunc)shutdown_funcv;\n     CMtrace_out(cm, CMFreeVerbose, \"calling select shutdown function sdp%p\\n\", cm->control_list->select_data);\n     shutdown_function(&CMstatic_trans_svcs, cm, &cm->control_list->select_data);\n }\n\n static void\n select_free(CManager cm, void *task_datav)\n {\n     void **task_data = (void**)task_datav;\n     SelectInitFunc select_free_function = (SelectInitFunc)task_data[0];\n     CMtrace_out(cm, CMFreeVerbose, \"calling select FREE function, %p\\n\", task_data[1]);\n     select_free_function(&CMstatic_trans_svcs, cm, &task_data[1]);\n     free(task_data);\n }\n\n\n static void\n CM_init_select(CMControlList cl, CManager cm)\n {\n     CMPollFunc blocking_function, polling_function;\n     SelectInitFunc init_function;\n     SelectInitFunc shutdown_function;\n     SelectInitFunc select_free_function;\n #if !NO_DYNAMIC_LINKING\n     char *libname;\n     lt_dlhandle handle;\t\n     lt_dladdsearchdir(EVPATH_LIBRARY_BUILD_DIR);\n     lt_dladdsearchdir(EVPATH_LIBRARY_INSTALL_DIR);\n     libname = malloc(strlen(\"lib\" CM_LIBRARY_PREFIX \"cmselect\") + strlen(MODULE_EXT) + 1);\n     strcpy(libname, \"lib\" CM_LIBRARY_PREFIX \"cmselect\");\n     strcat(libname, MODULE_EXT);\n     handle = CMdlopen(cm->CMTrace_file, libname, 0);\n     free(libname);\n     if (!handle) {\n\t fprintf(stderr, \"Failed to load required select dll.\\n\");\n\t fprintf(stderr, \"Search path includes '.', '%s', '%s' and any default search paths supported by ld.so\\n\", EVPATH_LIBRARY_BUILD_DIR, \n\t\t EVPATH_LIBRARY_INSTALL_DIR);\n\t exit(1);\n     }\n     cl->add_select = (CMAddSelectFunc)lt_dlsym(handle, \"add_select\");  \n     cl->remove_select = (CMRemoveSelectFunc)lt_dlsym(handle, \"remove_select\");  \n     cl->write_select = (CMAddSelectFunc)lt_dlsym(handle, \"write_select\");  \n     cl->add_periodic = (CMAddPeriodicFunc)lt_dlsym(handle, \"add_periodic\");  \n     cl->add_delayed_task = \n\t (CMAddPeriodicFunc)lt_dlsym(handle, \"add_delayed_task\");  \n     cl->remove_periodic = (CMRemovePeriodicFunc)lt_dlsym(handle, \"remove_periodic\");  \n     cl->wake_select = (CMWakeSelectFunc)lt_dlsym(handle, \"wake_function\");\n     blocking_function = (CMPollFunc)lt_dlsym(handle, \"blocking_function\");\n     polling_function = (CMPollFunc)lt_dlsym(handle, \"polling_function\");\n     init_function = (SelectInitFunc)lt_dlsym(handle, \"select_initialize\");\n     shutdown_function = (SelectInitFunc)lt_dlsym(handle, \"select_shutdown\");\n     select_free_function = (SelectInitFunc)lt_dlsym(handle, \"select_free\");\n     cl->stop_select = (CMWakeSelectFunc)lt_dlsym(handle, \"select_stop\");\n #else\n     cl->add_select = (CMAddSelectFunc)libcmselect_LTX_add_select;\n     cl->remove_select = (CMRemoveSelectFunc)libcmselect_LTX_remove_select;\n     cl->write_select = (CMAddSelectFunc) libcmselect_LTX_write_select;\n     cl->add_periodic = (CMAddPeriodicFunc)libcmselect_LTX_add_periodic;\n     cl->add_delayed_task = \n\t (CMAddPeriodicFunc)libcmselect_LTX_add_delayed_task;\n     cl->remove_periodic = (CMRemovePeriodicFunc)libcmselect_LTX_remove_periodic;\n     cl->wake_select = (CMWakeSelectFunc)libcmselect_LTX_wake_function;\n     blocking_function = (CMPollFunc)libcmselect_LTX_blocking_function;\n     polling_function = (CMPollFunc)libcmselect_LTX_polling_function;\n     init_function = (SelectInitFunc)libcmselect_LTX_select_initialize;\n     shutdown_function = (SelectInitFunc) libcmselect_LTX_select_shutdown;\n     select_free_function = (SelectInitFunc) libcmselect_LTX_select_free;\n     cl->stop_select = (CMWakeSelectFunc) libcmselect_LTX_select_stop;\n\n\n #endif\n     if ((cl->add_select == NULL) || (cl->remove_select == NULL) || \n\t (blocking_function == NULL) || (cl->add_periodic == NULL) ||\n\t (cl->remove_periodic == NULL)) {\n\t printf(\"Select failed to load properly\\n\");\n\t exit(1);\n     }\n     init_function(&CMstatic_trans_svcs, cm, &cm->control_list->select_data);\n     CMControlList_set_blocking_func(cl, cm, blocking_function, \n\t\t\t\t     polling_function,\n\t\t\t\t     (void*)&(cl->select_data));\n     cl->select_initialized = 1;\n     CMtrace_out(cm, CMFreeVerbose, \"CManager adding select shutdown function, %lx\\n\",(long)shutdown_function);\n     internal_add_shutdown_task(cm, select_shutdown, (void*)shutdown_function, SHUTDOWN_TASK);\n     {\n\t void ** data = malloc(2 * sizeof(void*));\n\t data[0] = select_free_function;\n\t data[1] = cm->control_list->select_data;\n\t internal_add_shutdown_task(cm, select_free, (void*)data, FREE_TASK);\n     }\n }\n\n static void\n wake_function(CManager cm, void *cond)\n {\n     CManager_lock(cm);\n     INT_CMCondition_signal(cm, (int)(long)cond);\n     CManager_unlock(cm);\n }\n\n extern void\n INT_CMsleep(CManager cm, int sec)\n {\n     int cond = INT_CMCondition_get(cm, NULL);\n     CMTaskHandle handle = \n\t INT_CMadd_delayed_task(cm, sec, 0, wake_function, (void*)(long)cond);\n     INT_CMfree(handle);\n     INT_CMCondition_wait(cm, cond);\n }\n\n extern void\n INT_CMusleep(CManager cm, int usec)\n {\n     int cond = INT_CMCondition_get(cm, NULL);\n     CMTaskHandle handle = \n\t INT_CMadd_delayed_task(cm, 0, usec, wake_function, (void*)(long)cond);\n     INT_CMfree(handle);\n     INT_CMCondition_wait(cm, cond);\n }\n\n typedef struct foreign_handler_struct {\n     int header;\n     CMNonCMHandler handler;\n } *handler_list;\n\n static handler_list foreign_handler_list;\n static int foreign_handler_count = 0;\n\n extern void\n INT_CMregister_non_CM_message_handler(int header, CMNonCMHandler handler)\n {\n     if (foreign_handler_count > 0) {\n\t foreign_handler_list = INT_CMrealloc(foreign_handler_list, \n\t\t\t\t\t  sizeof(foreign_handler_list[0]) * \n\t\t\t\t\t  (foreign_handler_count + 1));\n     } else {\n\t foreign_handler_list = INT_CMmalloc(sizeof(foreign_handler_list[0]));\n     }\n     foreign_handler_list[foreign_handler_count].header = header;\n     foreign_handler_list[foreign_handler_count].handler = handler;\n     foreign_handler_count++;\n }\n\n int\n CMdo_non_CM_handler(CMConnection conn, int header, char *buffer, int length)\n {\n     int i = 0;\n     while (i < foreign_handler_count) {\n\t if (foreign_handler_list[i].header == header) {\n\t     return foreign_handler_list[i].handler(conn, conn->trans, buffer, \n\t\t\t\t\t     length);\n\t }\n\t i++;\n     }\n     return -1;\n }\n\n extern CMtrans_services\n INT_CMget_static_trans_services()\n {\n   return &CMstatic_trans_svcs;\n }\n\n extern void*\n INT_CMget_transport_data (CMConnection conn)\n {\n   return conn->transport_data;\n }\n\nstatic \nint offset_compare(const void* lhsv, const void* rhsv)\n {\n     CMavail_period_ptr lhs = (CMavail_period_ptr) lhsv;\n     CMavail_period_ptr rhs = (CMavail_period_ptr) rhsv;\n     if (lhs->offset.tv_sec < rhs->offset.tv_sec)\n\t return -1;\n     if (lhs->offset.tv_sec > rhs->offset.tv_sec)\n\t return 1;\n     return lhs->offset.tv_usec - rhs->offset.tv_usec;\n }\n\nextern int\nINT_CMinstall_pull_schedule(CManager cm, struct timeval *base_time, \n\t\t\t    struct timeval *period, CMavail_period_ptr avail)\n{\n    int i = 0, count = 0;\n    struct timeval zero = {0,0}, last_end = {0,0};\n    CMavail_period_ptr sorted;\n    while (timercmp(&avail[count].offset, &zero, !=) ||\n\t   timercmp(&avail[count].duration, &zero, !=)) {\n\tif (avail[count].offset.tv_sec < 0) {\n\t    fprintf(stderr, \"CMinstall_pull_schedule(), avail sec offset is negative.  Rejected\\n\");\n\t    return 0;\n\t}\n\tif (avail[count].offset.tv_usec < 0) {\n\t    fprintf(stderr, \"CMinstall_pull_schedule(), avail usec offset is negative.  Rejected\\n\");\n\t    return 0;\n\t}\n\tif (avail[count].duration.tv_sec < 0) {\n\t    fprintf(stderr, \"CMinstall_pull_schedule(), avail sec duration is negative.  Rejected\\n\");\n\t    return 0;\n\t}\n\tif (avail[count].duration.tv_usec < 0) {\n\t    fprintf(stderr, \"CMinstall_pull_schedule(), avail usec duration is negative.  Rejected\\n\");\n\t    return 0;\n\t}\n\tcount++;\n    }\n    sorted = malloc(sizeof(avail[0]) * (count+1));\n    memcpy(sorted, avail, sizeof(avail[0]) * count);\n    qsort(sorted, count, sizeof(avail[0]), offset_compare);\n    for (i = 0; i < count; i++) {\n\tstruct timeval end;\n\ttimeradd(&avail[i].offset, &avail[i].duration, &end);\n\tif (timercmp(&end, period, >)) {\n\t    fprintf(stderr, \"CMinstall_pull_schedule(), avail region %d rejected, extends beyond period\\n\", i);\n\t    free(sorted);\n\t    return -1;\n\t}\n\tif (timercmp(&avail[i].offset, &last_end, <)) {\n\t    fprintf(stderr, \"CMinstall_pull_schedule(), avail regions overlap. Rejected\\n\");\n\t    free(sorted);\n\t    return -1;\n\t}\n\tlast_end = end;\n    }\n\n    cm->base_time = *base_time;\n    cm->period = *period;\n    cm->avail = sorted;\n    transport_entry *trans_list;\n    trans_list = cm->transports;\n    CMtrace_out(cm, CMTransportVerbose, \"CM installed pull schedule with period %ld secs, %ld usecs\\n\", period->tv_sec, (long) period->tv_usec);\n    while ((trans_list != NULL) && (*trans_list != NULL)) {\n\tif ((*trans_list)->install_pull_schedule_func) {\n\t    (*trans_list)->install_pull_schedule_func(&CMstatic_trans_svcs,\n\t\t\t\t\t\t      *trans_list,\n\t\t\t\t\t\t      base_time, period,\n\t\t\t\t\t\t      cm->avail);\n\t    CMtrace_out(cm, CMTransportVerbose, \"CM installed pull schedule to transport %s\\n\", (*trans_list)->trans_name);\n\t}\n\ttrans_list++;\n    }\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/gen_interface.pl": "#! /usr/bin/env - perl\nuse File::Basename;\nmy $dirname = dirname(__FILE__);\n\nsub gen_type\n{\n    my($subr, $arg_str) = @_;\n    my(@args);\n    print REVP \"\\ntypedef struct _${subr}_request {\\n\";\n    print REVP \"    int condition_var;\\n\";\n    @args = split( \", \",  $arg_str,2);\n    foreach $arg (split (\", \", $args[1])) {\n\t$_ = $arg;\n\tif (/^\\s*(.*\\W+)(\\w+)$\\s*/) {\n\t    $argtype = $1;\n\t    $argname = $2;\n\t    $argtype =~ s/\\s+$//;\n\t    $argtype =~ s/(?!\\w)\\s+(?=\\W)//;  #remove unnecessary white space\n\t    $argtype =~ s/(?!\\W)\\s+(?=\\w)//;  #remove unnecessary white space\n\t    $iotype = $argtype;\n\t    $sizetype = $argtype;\n\t  switch:for ($argtype) {\n\t      /attr_list/ && do {$iotype = \"string\"; $argtype=\"char*\"; last;};\n\t      /char*/ && do {$iotype = \"string\"; $argtype=\"char*\"; last;};\n\t      /EVstone$/ && do {$iotype = \"integer\"; $argtype=\"EVstone\"; last;};\n\t      /EVstone\\*/ && do {print REVP \"    int ${argname}_len;\\n\";\n$iotype = \"integer[${argname}_len]\"; $argtype=\"int *\"; last;};\n\t      /EVSimpleHandlerFunc$/ && do {$iotype = \"string\"; $argtype=\"char*\"; last;};\n\t      /FMStructDescList/ && do {$iotype = \"string\"; $argtype=\"char*\"; last;};\n\t  }\n\t}\n\tprint REVP \"    $argtype $argname;\\n\";\n    }\n    print REVP \"} ${subr}_request;\\n\";\n    $ret_type = $return_type{$subr};\n  switch:  for ($ret_type) {\n      /attr_list/ && do {$retiotype = \"string\"; $ret_type=\"char*\"; last;};\n      /char*/ && do {$retiotype = \"string\"; $ret_type=\"char*\"; last;};\n      /EVstone/ && do {$retiotype = \"integer\"; $ret_type=\"EVstone\"; last;};\n    }\n    print REVP \"\\ntypedef struct _${subr}_response {\\n\";\n    print REVP \"    int condition_var;\\n\";\n    print REVP \"    $ret_type ret;\\n\" unless ($return_type{$subr} eq \"void\");\n    print REVP \"} ${subr}_response;\\n\";\n}\n\nsub gen_field_list\n{\n    my($subr, $arg_str) = @_;\n    my(@args);\n    print REVP \"\\nFMField  ${subr}_req_flds[] = {\\n\";\n    print REVP \"    {\\\"condition_var\\\", \\\"integer\\\", sizeof(int), FMOffset(${subr}_request*, condition_var)},\\n\";\n    @args = split( \", \",  $arg_str,2);\n    foreach $arg (split (\", \", $args[1])) {\n\t$_ = $arg;\n\tif (/^\\s*(.*\\W+)(\\w+)$\\s*/) {\n\t    $argtype = $1;\n\t    $argname = $2;\n\t    $argtype =~ s/\\s+$//;\n\t    $argtype =~ s/(?!\\w)\\s+(?=\\W)//;  #remove unnecessary white space\n\t    $argtype =~ s/(?!\\W)\\s+(?=\\w)//;  #remove unnecessary white space\n\t    $iotype = $argtype;\n\t    $sizetype = $argtype;\n\t  switch:for ($argtype) {\n\t      /attr_list/ && do {$iotype = \"string\"; $argtype=\"char*\"; last;};\n\t      /char*/ && do {$iotype = \"string\"; $argtype=\"char*\"; last;};\n\t      /void*/ && do {$iotype = \"char[${argname}_len\"; $argtype=\"void*\"; last;};\n\t      /int/ && do {$iotype = \"integer\"; $argtype=\"int\"; last;};\n\t      /EVstone/ && do {$iotype = \"integer\"; $argtype=\"EVstone\"; last;};\n\t      /EVaction/ && do {$iotype = \"integer\"; $argtype=\"EVaction\"; last;};\n\t      /EVSimpleHandlerFunc/ && do {$iotype = \"string\"; $argtype=\"EVSimpleHandlerFunc\"; last;};\n\t      /FMStructDescList/ && do {$iotype = \"string\"; $argtype=\"EVSimpleHandlerFunc\"; last;};\n\t  }\n\t}\n\tprint REVP \"    {\\\"$argname\\\", \\\"$iotype\\\", sizeof($sizetype), FMOffset(${subr}_request*,$argname)},\\n\";\n    }\n    print REVP \"    {NULL, NULL, 0, 0}\\n};\\n\";\n    print REVP \"\\nFMStructDescRec  ${subr}_req_formats[] = {\\n\";\n    print REVP \"    {\\\"EV_${subr}_request\\\", ${subr}_req_flds, sizeof(${subr}_request), NULL},\\n\";\n    print REVP \"    {NULL, NULL, 0, NULL}\\n};\\n\";\n}\n\nsub gen_stub {\n    my($subr, $arg_str) = @_;\n    my(@args);\n    @args = split( \", \",  $arg_str,2);\n    print REVP \"\\nextern $return_type{$subr}\\n\";\n    print REVPHI \"\\nextern $return_type{$subr}\\n\";\n    if ($#args > 0) {\n\tprint REVP \"INT_R$subr(CMConnection conn, $args[1])\\n\";\n\tprint REVPHI \"INT_R$subr(CMConnection conn, $args[1]);\\n\";\n    } else {\n\tprint REVP \"INT_R$subr(CMConnection conn)\\n\";\n\tprint REVPHI \"INT_R$subr(CMConnection conn);\\n\";\n    }\n    print REVP \"{\\n\";\n    \n    $_ = $return_type{$subr};\n    if (/^\\s*void\\s*$/) {\n\t$return_type{$subr} = \"void\";\n    }\n    $retsubtype = $return_type{$subr};\n  switch:  for ($ret_type) {\n      /attr_list/ && do {$retsubtype = \"string\"; $ret_type=\"char*\"; last;};\n      /char*/ && do {$retsubtype = \"string\"; $ret_type=\"char*\"; last;};\n      /EVstone/ && do {$retsubtype = \"int\"; $ret_type=\"EVstone\"; last;};\n      /EVaction/ && do {$retsubtype = \"int\"; $ret_type=\"EVaction\"; last;};\n    }\n    print REVP \"    int cond;\\n\";\n    print REVP \"    CMFormat f;\\n\";\n    print REVP \"    EV_${retsubtype}_response response;\\n\" unless ($return_type{$subr} eq \"void\");\n    print REVP \"    ${subr}_request request;\\n\";\n    print REVP \"    memset(&request, 0, sizeof(request));\\n\";\n    print REVP \"    cond = INT_CMCondition_get(conn->cm, conn);\\n\";\n    print REVP \"    f = INT_CMlookup_format(conn->cm, ${subr}_req_formats);\\n\";\n    $free_list = \"\";\n    foreach $arg (split (\", \", $args[1])) {\n\t$_ = $arg;\n\tif (/^\\s*(.*\\W+)(\\w+)$\\s*/) {\n\t    $argtype = $1;\n\t    $argname = $2;\n\t    $argtype =~ s/\\s+$//;\n\t    $argtype =~ s/(?!\\w)\\s+(?=\\W)//;  #remove unnecessary white space\n\t    $argtype =~ s/(?!\\W)\\s+(?=\\w)//;  #remove unnecessary white space\n\t    $argright = $argname;\n\t  switch:for ($argtype) {\n\t      /attr_list/ && do {$argright = \"attr_list_to_string($argname)\"; $free_list .= \"    free(request.$argname);\\n\"; last;};\n\t      /FMStructDescList/ && do {$argright = \"get_format_name(conn->cm, $argname)\"; last;};\n\t  }\n\t}\n\tprint REVP \"    request.$argname = $argright;\\n\";\n    }\n    print REVP \"    request.condition_var = cond;\\n\";\n    print REVP \"    if (f == NULL) {\\n\";\n    print REVP \"        f = INT_CMregister_format(conn->cm, ${subr}_req_formats);\\n\";\n    print REVP \"    }\\n\";\n    if ($return_type{$subr} eq \"void\") {\n\tprint REVP \"    INT_CMCondition_set_client_data(conn->cm, cond, NULL);\\n\";\n    } else {\n\tprint REVP \"    INT_CMCondition_set_client_data(conn->cm, cond, &response);\\n\";\n    }\n    print REVP \"    INT_CMwrite(conn, f, &request);\\n\";\n    if (\"$free_list\" ne \"\") {\n\tprint REVP \"$free_list\";\n    }\n    print REVP \"    INT_CMCondition_wait(conn->cm, cond);\\n\";\n  switch:for ($return_type{$subr}) {\n      /attr_list/ && do {print REVP \"    return attr_list_from_string(response.ret);\\n\"; last;};\n      /void/ && do {last;};\n      /EVstone/ && do {print REVP \"    return (EVstone) response.ret;\\n\"; last;};\n      /EVaction/ && do {print REVP \"    return (EVaction) response.ret;\\n\"; last;};\n      /int/ && do {print REVP \"    return response.ret;\\n\"; last;};\n      /EVevent_list/ && do {print REVP \"    return response.ret;\\n\"; last;};\n  }\n    print REVP \"}\\n\";\n}\n\nsub gen_wrapper {\n    my($subr, $arg_str, $has_client_data) = @_;\n    my(@args);\n    @args = split( \", \",  $arg_str,2);\n    print REVP \"\\nextern $return_type{$subr}\\n\";\n    if ($#args > 0) {\n      print REVP \"R$subr(CMConnection conn, $args[1])\\n\";\n    } else {\n      print REVP \"R$subr(CMConnection conn)\\n\";\n    }\n    #  This break stuff.  GSE\n    # $handler_register_string = \"$handler_register_string\\\n    # tmp_format = INT_CMregister_format(cm, ${subr}_req_formats);\\\n    # INT_CMregister_handler(tmp_format, R${subr}_handler, cm->evp);\\n\";\n\n    print REVP \"{\\n\";\n    $_ = $return_type{$subr};\n    if (/^\\s*void\\s*$/) {\n\t$return_type{$subr} = \"void\";\n    }\n    $retsubtype = $return_type{$subr};\n    switch:  for ($ret_type) {\n      /attr_list/ && do {$retsubtype = \"string\"; $ret_type=\"char*\"; last;};\n      /char*/ && do {$retsubtype = \"string\"; $ret_type=\"char*\"; last;};\n      /EVstone/ && do {$retsubtype = \"int\"; $ret_type=\"EVstone\"; last;};\n      /EVaction/ && do {$retsubtype = \"int\"; $ret_type=\"EVaction\"; last;};\n    }\n    print REVP \"    $return_type{$subr} ret;\\n\" unless ($return_type{$subr} eq \"void\");\n    print REVP \"    CManager_lock(conn->cm);\\n\";\n    if ($return_type{$subr} eq \"void\") {\n        print REVP \"    INT_R${subr}(conn\";\n    } else {\n        print REVP \"    ret = INT_R${subr}(conn\";\n    }\n    foreach $arg (split (\", \", $args[1])) {\n\t$_ = $arg;\n\tif (/^\\s*(.*\\W+)(\\w+)$\\s*/) {\n\t    $argtype = $1;\n\t    $argname = $2;\n\t    $argtype =~ s/\\s+$//;\n\t    $argtype =~ s/(?!\\w)\\s+(?=\\W)//;  #remove unnecessary white space\n\t    $argtype =~ s/(?!\\W)\\s+(?=\\w)//;  #remove unnecessary white space\n\t    $argright = \"$argname\";\n\t  switch:for ($argtype) {\n\t      /attr_list/ && do {$argright = \"$argname\"; last;};\n\t      /EVSimpleHandlerFunc/ && do {$argright = \"$argname\"; last;};\n\t      /FMStructDescList/ && do {$argright = \"$argname\"; last;};\n\t  }\n\t}\n\tprint REVP \", $argright\";\n    }\n    print REVP \");\\n\";\n    print REVP \"    CManager_unlock(conn->cm);\\n\";\n    if ($return_type{$subr} eq \"void\") {\n        print REVP \"    return;\\n\";\n    } else {\n        print REVP \"    return ret;\\n\";\n    }\n    print REVP \"}\\n\";\n}\n\nsub gen_handler {\n    my($subr, $arg_str, $has_client_data) = @_;\n    my(@args);\n    @args = split( \", \",  $arg_str,2);\n    print REVP \"\\nstatic void\\n\";\n    print REVP \"R${subr}_handler(CManager cm, CMConnection conn, void *data,void *client_data,attr_list message_attrs)\\n\";\n    $handler_register_string = \"$handler_register_string\\\n    tmp_format = INT_CMregister_format(cm, ${subr}_req_formats);\\\n    INT_CMregister_handler(tmp_format, R${subr}_handler, cm->evp);\\n\";\n\n    print REVP \"{\\n\";\n    $_ = $return_type{$subr};\n    if (/^\\s*void\\s*$/) {\n\t$return_type{$subr} = \"void\";\n    }\n    $retsubtype = $return_type{$subr};\n  switch:  for ($ret_type) {\n      /attr_list/ && do {$retsubtype = \"string\"; $ret_type=\"char*\"; last;};\n      /char*/ && do {$retsubtype = \"string\"; $ret_type=\"char*\"; last;};\n      /EVstone/ && do {$retsubtype = \"int\"; $ret_type=\"EVstone\"; last;};\n      /EVaction/ && do {$retsubtype = \"int\"; $ret_type=\"EVaction\"; last;};\n    }\n    print REVP \"    EV_${retsubtype}_response response;\\n\";\n    print REVP \"    ${subr}_request *request = (${subr}_request *) data;\\n\";\n    print REVP \"    $return_type{$subr} ret;\\n\" unless ($return_type{$subr} eq \"void\");\n    print REVP \"    CMFormat f = CMlookup_format(conn->cm, EV_${retsubtype}_response_formats);\\n\";\n    print REVP \"    (void) message_attrs;\\n\";\n    print REVP \"    (void) client_data;\\n\";\n    print REVP \"    if (f == NULL) {\\n\";\n    print REVP \"        f = INT_CMregister_format(conn->cm, EV_${retsubtype}_response_formats);\\n\";\n    print REVP \"    }\\n\";\n    foreach $arg (split (\", \", $args[1])) {\n\t$_ = $arg;\n\tif (/^\\s*(.*\\W+)(\\w+)$\\s*/) {\n\t    $argtype = $1;\n\t    $argname = $2;\n\t    $argtype =~ s/\\s+$//;\n\t    $argtype =~ s/(?!\\w)\\s+(?=\\W)//;  #remove unnecessary white space\n\t    $argtype =~ s/(?!\\W)\\s+(?=\\w)//;  #remove unnecessary white space\n\t    $argright = $argname;\n\t  switch:for ($argtype) {\n\t      /attr_list/ && do {print REVP \"    attr_list $argname = attr_list_from_string(request->$argname);\\n\"; last;};\n\t      /EVSimpleHandlerFunc/ && do {print REVP \"    EVSimpleHandlerFunc $argname = REVPlookup_handler(request->$argname);\\n\"; last;};\n\t      /FMStructDescList/ && do {print REVP \"    FMStructDescList $argname = REVPlookup_format_structs(conn->cm, request->$argname);\\n\"; last;};\n\t  }\n\t}\n    }\n    if ($return_type{$subr} eq \"void\") {\n\tprint REVP \"    $subr(cm\";\n    } else {\n\tprint REVP \"    ret = $subr(cm\";\n    }\n    $after = \"\";\n    foreach $arg (split (\", \", $args[1])) {\n\t$_ = $arg;\n\tif (/^\\s*(.*\\W+)(\\w+)$\\s*/) {\n\t    $argtype = $1;\n\t    $argname = $2;\n\t    $argtype =~ s/\\s+$//;\n\t    $argtype =~ s/(?!\\w)\\s+(?=\\W)//;  #remove unnecessary white space\n\t    $argtype =~ s/(?!\\W)\\s+(?=\\w)//;  #remove unnecessary white space\n\t    $argright = \"request->$argname\";\n\t  switch:for ($argtype) {\n\t      /attr_list/ && do {$argright = \"$argname\"; $after .= \"free_attr_list($argname);\\n\"; last;};\n\t      /EVSimpleHandlerFunc/ && do {$argright = \"$argname\"; last;};\n\t      /FMStructDescList/ && do {$argright = \"$argname\"; last;};\n\t  }\n\t}\n\tprint REVP \", $argright\";\n    }\n    if ($has_client_data == 1) {print REVP \", NULL\";}\n    print REVP \");\\n\";\n    print REVP \"$after\";\n  switch:for ($return_type{$subr}) {\n      /attr_list/ && do {print REVP \"    response.ret = attr_list_to_string(ret);\\n\"; last;};\n      /void/ && do {last;};\n      /EVstone/ && do {print REVP \"    response.ret = (int)ret;\\n\"; last;};\n      /EVaction/ && do {print REVP \"    response.ret = (int) ret;\\n\"; last;};\n      /int/ && do {print REVP \"    response.ret = ret;;\\n\"; last;};\n      /EVevent_list/ && do {print REVP \"     response.ret_len = count_EVevent_list(ret);\\n    response.ret = ret;\\n\"; last;};\n  }\n    print REVP \"    response.condition_var = request->condition_var;\\n\";\n    print REVP \"    CMwrite(conn, f, &response);\\n\";\n  switch:for ($return_type{$subr}) {\n      /attr_list/ && do {print REVP \"    free(response.ret);\\n\"; last;};\n  }\n    print REVP \"}\\n\";\n}\n\nsub strip_client_data {\n    my($arg_str) = @_;\n    local(@args);\n    @args = split( \", \",  $arguments{$subr});\n    $_ = pop(@args);\n    if (!/.*client_data\\W*$/) {\n\tpush(@args, $_);\n    }\n    $arg_str = join(\", \", @args);\n}\n\nsub mod_EVhandler {\n    my($arg_str) = @_;\n    local(@args);\n    @args = split( \", \",  $arg_str);\n    for( my $i=0; $i < scalar(@args); $i++) {\n\t$_ = $args[$i];\n\tif (/\\W*EVSimpleHandlerFunc.*$/) {\n\t    $args[$i] = \"char *handler\";\n\t}\n    }\n    $arg_str = join(\", \", @args);\n    return $arg_str;\n}\n\n{\n    local ($/, *INPUT);\n\t\n    $cat_args = \"\";\n    $has_ev_dfg = 0;\n    $cm_only = 0;\n    foreach my $a(@ARGV) {\n\tif ($a =~ \"-CM_ONLY\") {\n\t    $cm_only = 1;\n\t    next;\n\t}\n\t$a=~s/ /\\\\ /g;\n\t$cat_args .= \"$a \";\n\tif ($a =~ /ev_dfg/) {\n\t    $has_evdfg = 1;\n\t}\n    }\n    unless (open(INPUT, \"cat $cat_args |\")) {\n\tdie \"sudden flaming death, no file: $cat_args\\n\";\n    }\n\n    $_ = <INPUT>;\n    s[/\\*NOLOCK\\*/][NOLOCK]g;\n    s[/\\*REMOTE\\*/][REMOTE]g;\n    s{/\\*.+\\*/}{}g;\n    @f = split(/\\n/);\n    close INPUT;\n}\nLINE:\nfor (@f) {\n    if (/NOLOCK/) {\n\t$nolock = 1;\n    }\n    if (/REMOTE/) {\n\t$remote = 1;\n    }\n    if (/^extern/) {\n\tnext LINE if (/\\\"C\\\"/);\n\t$decl = \"\";\n\tif ($nolock == 1) {$decl = \"NOLOCK\";}\n\tif ($remote == 1) {$decl = \"REMOTE\";}\n\t$nolock = 0;\n\t$remote = 0;\n\t$pending = 1;\n    }\n    if (($pending) && /;/) {\n\t$decl = $decl . \" \" . $_;\n\tpush (@DECLS, $decl);\n\t$pending = 0;\n    }\n    if ($pending) {\n\t$decl = $decl . \" \" . $_;\n    }\n}\nfor (@DECLS) {\n    $nolock = 0;\n    $remote = 0;\n    if (/NOLOCK/) {\n\ts/NOLOCK//g;\n\t$nolock = 1;\n    }\n    if (/REMOTE/) {\n\ts/REMOTE//g;\n\t$remote = 1;\n    }\n    if (/extern\\W+(\\w+\\W+)(\\w+)\\W*\\((.*)\\)/) {\n\t$return = $1;\n\t$name = $2;\n\t$_ = $3;\n\ts/\\)//g;\n\ts/\\s+/ /g;\n\t$return =~ s/(?!\\w)\\s+(?=\\W)//;  #remove unnecessary white space\n\t$return =~ s/(?!\\W)\\s+(?=\\w)//;  #remove unnecessary white space\n\t$return =~ s/\\s*$//;  #remove unnecessary white space\n\t$return =~ s/^\\s*//;  #remove unnecessary white space\n\t$return_type{$name} = $return;\n\t$args = $_;\n\t$arguments{$name} = \"$args\";\n    } else {\n      if (/extern\\W+(\\w+\\W+\\w+\\W+)(\\w+).*\\((.*)\\)/) {\n\t$return = $1;\n\t$name = $2;\n\t$_ = $3;\n\ts/\\)//g;\n\ts/\\s+/ /g;\n\t$return =~ s/(?!\\w)\\s+(?=\\W)//;  #remove unnecessary white space\n\t$return =~ s/(?!\\W)\\s+(?=\\w)//;  #remove unnecessary white space\n\t$return =~ s/\\s*$//;  #remove unnecessary white space\n\t$return =~ s/^\\s*//;  #remove unnecessary white space\n\t$return_type{$name} = $return;\n\t$args = $_;\n\t$arguments{$name} = \"$args\";\n      } else {\n\tprint \"Failed to match function2 on $_\\n\"\n      }\n    }\n    if ($nolock == 1) {\n\t$nolocking{$name} = 1;\n    }\n    if ($remote == 1) {\n\t$remote_enabled{$name} = 1;\n    }\n}\n\nunless (open (INT, \">cm_interface.c\")) { die \"Failed to open cm_interface.c\";}\nprint INT<<EOF;\n/*\n *  This file is automatically generated by gen_interface.pl from evpath.h.\n *\n *  DO NOT EDIT\n *\n */\n#include \"config.h\"\n#include \"stdio.h\"\n#include \"string.h\"\n#include \"stdlib.h\"\n#include \"ffs.h\"\n#include \"cod.h\"\n#include \"atl.h\"\n#include \"evpath.h\"\n#include \"cm_internal.h\"\nEOF\nif ($has_evdfg) {\n    print INT \"#include \\\"ev_dfg.h\\\"\\n\";\n    print INT \"#include \\\"ev_dfg_internal.h\\\"\\n\";\n}\nprint INT<<EOF;\n#ifdef\t__cplusplus\nextern \"C\" \\{\n#endif\nEOF\n    foreach $subr (sort (keys %return_type)) {\n\tif ($cm_only && (($subr =~ /^EV/) || ($subr =~ /^create/))) {\n\t    next;\n\t}\n\tprint INT \"\\nextern $return_type{$subr}\\n\";\n\tprint INT \"$subr ( $arguments{$subr} )\\n\";\n\tprint INT \"{\\n\";\n\tundef $cmanager;\n\tundef $cmconnection;\n\tundef $evsource;\n\tundef $cmtaskhandle;\n\tundef $cmformat;\n\tundef $evdfg;\n\tundef $evdfg_stone;\n\tforeach $arg (split ( \",\", $arguments{$subr})) {\n\t    $_ = $arg;\n\t    if (/\\W+(\\w+)\\W*$/) {\n\t\t$name = $1;\n\t    }\n\t    if (/CManager/) {\n\t\t$cmanager = $name;\n\t    }\n\t    if (/CMConnection/) {\n\t\t$cmconnection = $name;\n\t    }\n\t    if (/EVsource/) {\n\t\t$evsource = $name;\n\t    }\n\t    if (/CMTaskHandle/) {\n\t\t$cmtaskhandle = $name;\n\t    }\n\t    if (/CMFormat\\W/) {\n\t\t$cmformat = $name;\n\t    }\n\t    if (/EVdfg\\W/) {\n\t\t$evdfg = $name;\n\t    }\n\t    if (/EVclient\\W/) {\n\t\t$cmanager = $name. \"->cm\";\n\t    }\n\t    if (/EVmaster\\W/) {\n\t\t$cmanager = $name. \"->cm\";\n\t    }\n\t    if (/EVdfg_stone\\W/) {\n\t\t$evdfg_stone = $name;\n\t    }\n\t}\n\n\t$_ = $return_type{$subr};\n\tif (/^\\s*void\\s*$/) {\n\t    $return_type{$subr} = \"void\";\n\t}\n\tif ($return_type{$subr} ne \"void\") {\n\t    print INT \"\\t$return_type{$subr} ret;\\n\";\n\t}\n\tif (!defined($nolocking{$subr})) {\n\t    if (defined($cmanager)) {\n\t\tprint INT \"\\tCManager_lock($cmanager);\\n\";\n\t    } else {\n\t\tif (defined($cmconnection)) {\n\t\t    print INT \"\\tCManager cm = $cmconnection->cm;\\n\";\n\t\t} elsif (defined($evsource)) {\n\t\t    print INT \"\\tCManager cm = $evsource->cm;\\n\";\n\t\t} elsif (defined($cmtaskhandle)) {\n\t\t    print INT \"\\tCManager cm = $cmtaskhandle->cm;\\n\";\n\t\t} elsif (defined($cmformat)) {\n\t\t    print INT \"\\tCManager cm = $cmformat->cm;\\n\";\n\t\t} elsif (defined($evdfg)) {\n\t\t    print INT \"\\tCManager cm = $evdfg->master->cm;\\n\";\n\t\t} elsif (defined($evdfg_stone)) {\n\t\t    print INT \"\\tCManager cm = $evdfg_stone->dfg->master->cm;\\n\";\n\t\t} else {\n#\t\t    print INT \"\\tCManager cm = duh;\\n\";\n\t\t}\n\t\tprint INT \"\\tCManager_lock(cm);\\n\";\n\t    }\n\t}\n\tif ($return_type{$subr} eq \"void\") {\n\t    print INT \"\\t\";\n\t} else {\n\t    print INT \"\\tret = \";\n\t}\n\n\tprint INT \"INT_$subr(\";\n\t$first = 1;\n\tforeach $arg (split ( \",\", $arguments{$subr})) {\n\t    if ($first != 1) {\n\t\tprint INT \", \";\n\t    } else {\n\t\t$first = 0;\n\t    }\n\t    $_ = $arg;\n\t    if (/\\W+(\\w+)\\W*$/) {\n\t\tprint INT \"$1\";\n\t    }\n\t}\n\tprint INT \");\\n\";\n\tif ((!defined($nolocking{$subr})) && ($subr ne \"CManager_close\")) {\n\t    if (defined($cmanager)) {\n\t\tprint INT \"\\tCManager_unlock($cmanager);\\n\";\n\t    } else {\n\t\tprint INT \"\\tCManager_unlock(cm);\\n\";\n\t    }\n\t}\n\tprint INT \"\\treturn ret;\\n\" unless ($return_type{$subr} eq \"void\");\n\tprint INT \"}\\n\";\n    }\nprint \"done\\n\";\n\nprint INT<<EOF;\n#ifdef\t__cplusplus\n\\}\n#endif\nEOF\nclose INT;\nif ($cm_only) { exit(0); }\nunless (open (REVPH, \">revpath.h\")) { die \"Failed to open revpath.h\";}\nprint REVPH<<EOF;\n/*\n *  This file is automatically generated by gen_interface.pl from evpath.h.\n *\n *  DO NOT EDIT\n *\n */\n\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\nEOF\n\nunless (open (REVPHI, \">revp_internal.h\")) { die \"Failed to open revpath.h\";}\nprint REVPHI<<EOF;\n/*\n *  This file is automatically generated by gen_interface.pl from evpath.h.\n *\n *  DO NOT EDIT\n *\n */\n\nEOF\n\nunless (open (REVP, \">revp.c\")) { die \"Failed to open revp.c\";}\nprint REVP<<EOF;\n/*\n *  This file is automatically generated by gen_interface.pl from evpath.h.\n *\n *  DO NOT EDIT\n *\n */\n#include \"config.h\"\n#include \"ffs.h\"\n#include \"atl.h\"\n#include \"evpath.h\"\n#include \"stdio.h\"\n#include \"cm_internal.h\"\n#ifdef LT_LIBPREFIX\n#include \"ltdl.h\"\n#else\n#include <dlfcn.h>\n#define lt_dlopen(x) dlopen(x, 0)\n#define lt_dlsym(x, y) dlsym(x, y)\n#define lt_dlhandle void*\n#define lt_dlinit() 0\n#define lt_dlerror()  \"\"\n#endif\n#include \"stdio.h\"\n#include \"string.h\"\n#include \"stdlib.h\"\n#include <dlfcn.h>\n#ifdef\t__cplusplus\nextern \"C\" \\{\n#endif\n#if defined (__INTEL_COMPILER)\n//  Allow unused\n#  pragma warning (disable: 869)\n#endif\n\ntypedef struct _EV_void_response {\n    int condition_var;\n} EV_void_response;\n\nFMField  EV_void_response_flds[] = {\n    {\"condition_var\", \"integer\", sizeof(int), FMOffset(EV_void_response*, condition_var)},\n    {NULL, NULL, 0, 0}\n};\n\nFMStructDescRec  EV_void_response_formats[] = {\n    {\"EV_void_response\", EV_void_response_flds, sizeof(EV_void_response), NULL},\n    {NULL, NULL, 0, NULL}\n};\n\ntypedef struct _EV_int_response {\n    int condition_var;\n    int  ret;\n} EV_int_response;\n\nFMField  EV_int_response_flds[] = {\n    {\"condition_var\", \"integer\", sizeof(int), FMOffset(EV_int_response*, condition_var)},\n    {\"ret\", \"integer\", sizeof(EVstone), FMOffset(EV_int_response*,ret)},\n    {NULL, NULL, 0, 0}\n};\n\nFMStructDescRec  EV_int_response_formats[] = {\n    {\"EV_int_response\", EV_int_response_flds, sizeof(EV_int_response), NULL},\n    {NULL, NULL, 0, NULL}\n};\n\ntypedef struct _EV_string_response {\n    int condition_var;\n    char *ret;\n} EV_string_response;\n\nFMField  EV_string_response_flds[] = {\n    {\"condition_var\", \"integer\", sizeof(int), FMOffset(EV_string_response*, condition_var)},\n    {\"ret\", \"string\", sizeof(char*), FMOffset(EV_string_response*,ret)},\n    {NULL, NULL, 0, 0}\n};\n\nFMStructDescRec  EV_string_response_formats[] = {\n    {\"EV_string_response\", EV_string_response_flds, sizeof(EV_string_response), NULL},\n    {NULL, NULL, 0, NULL}\n};\n\ntypedef struct _EV_EVevent_list_response {\n    int condition_var;\n    int ret_len;\n    EVevent_list ret;\n} EV_EVevent_list_response;\n\nFMField  EV_EVevent_list_response_flds[] = {\n    {\"condition_var\", \"integer\", sizeof(int), FMOffset(EV_EVevent_list_response*, condition_var)},\n    {\"ret_len\", \"integer\", sizeof(int), FMOffset(EV_EVevent_list_response*,ret_len)},\n    {\"ret\", \"EVevent_list[ret_len]\", sizeof(struct buf_entry), FMOffset(EV_EVevent_list_response*,ret)},\n    {NULL, NULL, 0, 0}\n};\n\nFMField  EVevent_list_flds[] = {\n    {\"length\", \"integer\", sizeof(int), FMOffset(EVevent_list,length)},\n    {\"event_buffer\", \"char[length]\", sizeof(char), FMOffset(EVevent_list, buffer)},\n    {NULL, NULL, 0, 0}\n};\n\nFMStructDescRec  EV_EVevent_list_response_formats[] = {\n    {\"EV_EVevent_response\", EV_EVevent_list_response_flds, sizeof(EV_EVevent_list_response), NULL},\n    {\"EVevent_list\", EVevent_list_flds, sizeof(struct buf_entry), NULL},\n    {NULL, NULL, 0, NULL}\n};\n\nint\ncount_EVevent_list(EVevent_list list)\n{\n    int count = 0;\n    while (list && list[count].buffer != NULL) {\n\tcount++;\n    }\n    count++;\n    return count;\n}\n\nEVevent_list\ncopy_EVevent_list(EVevent_list list)\n{\n    EVevent_list ret;\n    int i, size = count_EVevent_list(list);\n    ret = (EVevent_list) malloc(sizeof(ret[0]) * size);\n    for (i=0; i < size-1; i++) {\n\tret[i].length = list[i].length;\n\tret[i].buffer = malloc(list[i].length);\n\tmemcpy(ret[i].buffer, list[i].buffer, list[i].length);\n    }\n    ret[i].length = 0;\n    ret[i].buffer = NULL;\n    return ret;\n}\n\nEVSimpleHandlerFunc\nREVPlookup_handler(char *name)\n{\n    EVSimpleHandlerFunc f = NULL;\n    if (strncmp(\"0x\", name, 2) == 0) {\n\t/* hex constant */\n\tvoid *p;\n\tsscanf(name, \"0x%p\", &p);\n\tf = (EVSimpleHandlerFunc)p;\n\treturn f;\n    } \n#if !NO_DYNAMIC_LINKING\n    static lt_dlhandle h = NULL;\n    static void *dh = NULL;\n    if (h == NULL) {\n\t(void) lt_dlinit();\n\th = lt_dlopen(NULL);\n    }\n    f = (EVSimpleHandlerFunc) lt_dlsym(h, name);\n    if (f == NULL) {\n\tif (dh == NULL) {\n\t    dh = dlopen(NULL, 0);\n\t}\n\tprintf(\"Querying dlopen()\\\\n\");\n\tf = (EVSimpleHandlerFunc)dlsym(dh, name);\n    }\n    if (f == NULL) {\n\tif (dh == NULL) {\n\t    dh = dlopen(NULL, RTLD_GLOBAL|RTLD_LAZY);\n\t}\n\tf = (EVSimpleHandlerFunc)dlsym(dh, name);\n    }\n#endif\n    if (f == NULL) {\n\tprintf(\"Dynamic symbol lookup for \\\\\"%s\\\\\" failed.\\\\n\\\\tEither the symbol is invalid, or symbol lookup is not enabled.\\\\n\", name);\n\tprintf(\"Make sure that the symbol is declared \\\\\"extern\\\\\" (not \\\\\"static\\\\\")\\\\n\");\n\tprintf(\"Try linking the program with either \\\\\"-rdynamic\\\\\" (GCC) or \\\\\"-dlopen self\\\\\" (libtool)\\\\n\");\n    }\n    return f;\n}\n\nstatic char *\nget_format_name(CManager cm, FMStructDescList structs)\n{\n    int id_len, i;\n    FMFormat format = EVregister_format_set(cm, structs);\n    char *tmp = get_server_ID_FMformat(format, &id_len);\n    char *str_tmp = malloc(id_len * 2 + 1);\n    for (i=0; i < id_len; i++) {\n\tsprintf(&str_tmp[i*2], \"%02x\", ((unsigned char*)tmp)[i]);\n    }\n    return str_tmp;\n}\n\nextern FMStructDescList\nREVPlookup_format_structs(CManager cm, char *format_name)\n{\n    FMFormat format;\n    int slen = strlen(format_name);\n    int i;\n    unsigned char *id = malloc(slen/2);\n    for (i=0; i < slen/2; i++) {\n\tint x;\n\tchar tmp[3] = {0, 0, 0};\n\ttmp[0] = format_name[2*i];\n\ttmp[1] = format_name[2*i + 1];\n\tsscanf(tmp, \"%x\", &x);\n\tid[i] = (unsigned char) x;\n    }\n    format = FMformat_from_ID(cm->evp->fmc, (char*)id);\n    free(id);\n    return format_list_of_FMFormat(format);\n}\n\nEOF\n    foreach $subr (sort (keys %return_type)) {\n\tdefined($remote_enabled{$subr}) || next;\n\n\tprint REVPH \"\\nextern $return_type{$subr}\\n\";\n\t$no_client_data = strip_client_data($arguments{$subr});\n\t$no_handler = mod_EVhandler($no_client_data);\n\t$_ = $arguments{$subr};\n\t$has_client_data = 0;\n\tif (/.*client_data\\W*$/) {\n\t    $has_client_data = 1;\n\t}\n\t@args = split( \", \",  $no_handler, 2);\n\tif ($#args > 0) {\n\t    print REVPH \"R$subr(CMConnection conn, $args[1]);\\n\";\n\t} else {\n\t    print REVPH \"R$subr(CMConnection conn);\\n\";\n\t}\n\tgen_type(${subr}, $no_handler);\n\tgen_field_list(${subr}, $no_handler);\n\tgen_stub(${subr}, $no_handler);\n\tgen_wrapper(${subr},  $no_handler, $has_client_data);\n\tgen_handler(${subr}, $no_client_data, $has_client_data);\n    }\n\nprint REVP<<EOF;\nstatic void\nREV_response_handler(CManager cm, CMConnection conn, void *data,void *client_data,attr_list attrs)\n{\n    EV_void_response *response = (EV_void_response*) data;\n    void **response_ptr = CMCondition_get_client_data(cm, response->condition_var);\n    if (NULL != response_ptr) {\n\t*response_ptr = data;\n    }\n    CMCondition_signal(cm, response->condition_var);\n}\n\nstatic void\nREV_int_response_handler(CManager cm, CMConnection conn, void *data,void *client_data,attr_list attrs)\n{\n    EV_void_response *response = (EV_void_response*) data;\n    void **response_ptr = CMCondition_get_client_data(cm, response->condition_var);\n    if (NULL != response_ptr) {\n\tmemcpy(response_ptr, data, sizeof(EV_int_response));\n    }\n    CMCondition_signal(cm, response->condition_var);\n}\n\nstatic void\nREV_string_response_handler(CManager cm, CMConnection conn, void *data,void *client_data,attr_list attrs)\n{\n    EV_string_response *response = (EV_string_response*) data;\n    EV_string_response *stub_ptr = CMCondition_get_client_data(cm, response->condition_var);\n    if (NULL != stub_ptr) {\n\tmemcpy(stub_ptr, data, sizeof(EV_string_response));\n\tstub_ptr->ret = strdup(response->ret);\n    }\n    CMCondition_signal(cm, response->condition_var);\n}\n\nstatic void\nREV_EVevent_list_response_handler(CManager cm, CMConnection conn, void *data,void *client_data,attr_list attrs)\n{\n    EV_EVevent_list_response *response = (EV_EVevent_list_response*) data;\n    EV_EVevent_list_response *stub_ptr = CMCondition_get_client_data(cm, response->condition_var);\n    if (NULL != stub_ptr) {\n\tmemcpy(stub_ptr, data, sizeof(EV_EVevent_list_response));\n\tstub_ptr->ret = copy_EVevent_list(response->ret);\n    }\n    CMCondition_signal(cm, response->condition_var);\n}\n\nextern void\nREVPinit(CManager cm)\n{\n    CMFormat tmp_format;\n$handler_register_string\n    tmp_format = INT_CMregister_format(cm, EV_int_response_formats);\n    INT_CMregister_handler(tmp_format, REV_int_response_handler, cm->evp);\n\n    tmp_format = INT_CMregister_format(cm, EV_void_response_formats);\n    INT_CMregister_handler(tmp_format, REV_response_handler, cm->evp);\n\n    tmp_format = INT_CMregister_format(cm, EV_string_response_formats);\n    INT_CMregister_handler(tmp_format, REV_string_response_handler, cm->evp);\n\n    tmp_format = INT_CMregister_format(cm, EV_EVevent_list_response_formats);\n    INT_CMregister_handler(tmp_format, REV_EVevent_list_response_handler, cm->evp);\n}\nEOF\nprint REVPH<<EOF;\n\n#ifdef\t__cplusplus\n\\}\n#endif\nEOF\n",
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/cm_transport.c": "#include \"config.h\"\n\n#ifndef MODULE\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#else\n#include \"kernel/kcm.h\"\n#include \"kernel/cm_kernel.h\"\n#include \"kernel/library.h\"\n/* don't pull in sys/types if MODULE is defined */\n#define _SYS_TYPES_H\n#endif\n#include <atl.h>\n#include <evpath.h>\n#include \"chr_time.h\"\n#include <cm_internal.h>\n#include <cm_transport.h>\n#if !NO_DYNAMIC_LINKING\n#include \"dlloader.h\"\n#endif\n#undef NDEBUG\n#include \"assert.h\"\n\nextern struct CMtrans_services_s CMstatic_trans_svcs;\n/*const lt_dlsymlist lt_preloaded_symbols[1] = { { 0, 0 } };*/\n\nstatic transport_entry *global_transports = NULL;\n\nint\nfind_transport_in_cm(CManager cm, const char *trans_name)\n{\n    int i = 0;\n    if (cm->transports == NULL) return 0;\n    while(cm->transports[i] != NULL) {\n\tif (strcmp(cm->transports[i]->trans_name, trans_name) == 0) return 1;\n\ti++;\n    }\n    return 0;\n}\n\ntransport_entry\nadd_transport_to_cm(CManager cm, transport_entry transport)\n{\n    int num_trans;\n    if (cm->transports == NULL) {\n\tcm->transports = INT_CMmalloc(sizeof(transport_entry) * 2);\n\tnum_trans = 0;\n    } else {\n\tnum_trans = 0;\n\twhile(cm->transports[num_trans] != NULL) num_trans++;\n\tcm->transports = INT_CMrealloc(cm->transports,\n\t\t\t\t   sizeof(transport_entry) * (num_trans +2));\n    }\n    cm->transports[num_trans] = INT_CMmalloc(sizeof(struct _transport_item));\n    *(cm->transports[num_trans]) = *transport;\n    cm->transports[num_trans + 1] = NULL;\n    transport = cm->transports[num_trans];\n    transport->cm = cm;\n    return transport;\n}\n\nint\nload_transport(CManager cm, const char *trans_name, int quiet)\n{\n    transport_entry *trans_list = global_transports;\n    transport_entry transport = NULL;\n    int i = 0;\n#if !NO_DYNAMIC_LINKING\n    char *libname;\n    lt_dlhandle handle;\t\n#endif\n\n\n    if (find_transport_in_cm(cm, trans_name)) return 1;\n\n    while ((trans_list != NULL) && (*trans_list != NULL)) {\n\tif (strcmp((*trans_list)->trans_name, trans_name) == 0) {\n\t    transport_entry trans = add_transport_to_cm(cm, *trans_list);\n\t    if (trans->transport_init) {\n\t\ttrans->trans_data = \n\t\t    trans->transport_init(cm, &CMstatic_trans_svcs, trans);\n\t    }\n\t    return 1;\n\t}\n\ttrans_list++;\n\ti++;\n    }\n#if !NO_DYNAMIC_LINKING \n    libname = INT_CMmalloc(strlen(trans_name)+strlen(\"lib\" CM_LIBRARY_PREFIX \"cm\")+strlen(MODULE_EXT) \n\t\t       + 1);\n    \n    strcpy(libname, \"lib\" CM_LIBRARY_PREFIX \"cm\");\n    strcat(libname, trans_name);\n    strcat(libname, MODULE_EXT);\n\n    lt_dladdsearchdir(EVPATH_LIBRARY_BUILD_DIR);\n    lt_dladdsearchdir(EVPATH_LIBRARY_INSTALL_DIR);\n    handle = CMdlopen(cm->CMTrace_file, libname, 0);\n    if (!handle) {\n\tif (!quiet) fprintf(stderr, \"Failed to load required '%s' dll.\\n\", trans_name);\n\tif (!quiet) fprintf(stderr, \"Search path includes '.', '%s', '%s' and any default search paths supported by ld.so\\n\", \n\t\t\t    EVPATH_LIBRARY_BUILD_DIR, \n\t\t\t    EVPATH_LIBRARY_INSTALL_DIR);\n    }\n    if (!handle) {\n\treturn 0;\n    }\n    INT_CMfree(libname);\n    transport = INT_CMmalloc(sizeof(struct _transport_item));\n    transport->trans_name = strdup(trans_name);\n    transport->cm = cm;\n    transport->data_available = CMDataAvailable;  /* callback pointer */\n    transport->write_possible = CMWriteQueuedData;  /* callback pointer */\n    transport->transport_init = (CMTransport_func)\n\tlt_dlsym(handle, \"initialize\");  \n    transport->listen = (CMTransport_listen_func)\n\tlt_dlsym(handle, \"non_blocking_listen\");  \n    transport->initiate_conn = (CMConnection(*)())\n\tlt_dlsym(handle, \"initiate_conn\");  \n    transport->self_check = (int(*)())lt_dlsym(handle, \"self_check\");\n    transport->connection_eq = (int(*)())lt_dlsym(handle, \"connection_eq\");\n    transport->shutdown_conn = (CMTransport_shutdown_conn_func)\n\tlt_dlsym(handle, \"shutdown_conn\");  \n    transport->read_to_buffer_func = (CMTransport_read_to_buffer_func)\n\tlt_dlsym(handle, \"read_to_buffer_func\");  \n    transport->read_block_func = (CMTransport_read_block_func)\n\tlt_dlsym(handle, \"read_block_func\");  \n    transport->writev_func = (CMTransport_writev_func)\n\tlt_dlsym(handle, \"writev_func\");  \n    transport->writev_complete_notify_func = (CMTransport_writev_complete_notify_func)\n\tlt_dlsym(handle, \"writev_complete_notify_func\");  \n    transport->install_pull_schedule_func = (CMTransport_install_pull_schedule)\n\tlt_dlsym(handle, \"install_pull_schedule\");  \n    transport->NBwritev_func = (CMTransport_writev_func)\n\tlt_dlsym(handle, \"NBwritev_func\");  \n    transport->set_write_notify = (CMTransport_set_write_notify_func)\n\tlt_dlsym(handle, \"set_write_notify\");\n    transport->get_transport_characteristics = (CMTransport_get_transport_characteristics)\n\tlt_dlsym(handle, \"get_transport_characteristics\");\n    if (transport->transport_init) {\n\ttransport->trans_data = \n\t    transport->transport_init(cm, &CMstatic_trans_svcs, transport);\n    }\n    transport = add_transport_to_cm(cm, transport);\n#else\n    if (strcmp(trans_name, \"sockets\") == 0) {\n\textern transport_entry cmsockets_add_static_transport(CManager cm, CMtrans_services svc);\n\ttransport = cmsockets_add_static_transport(cm, &CMstatic_trans_svcs);\n\ttransport->data_available = CMDataAvailable;  /* callback pointer */\n\ttransport->write_possible = CMWriteQueuedData;  /* callback pointer */\n\t(void) add_transport_to_cm(cm, transport);\n    }\n    if (strcmp(trans_name, \"udp\") == 0) {\n\textern transport_entry cmudp_add_static_transport(CManager cm, CMtrans_services svc);\n\ttransport = cmudp_add_static_transport(cm, &CMstatic_trans_svcs);\n\ttransport->data_available = CMDataAvailable;  /* callback pointer */\n\ttransport->write_possible = CMWriteQueuedData;  /* callback pointer */\n\t(void) add_transport_to_cm(cm, transport);\n    }\n#ifdef NNTI_FOUND\n    if (strcmp(trans_name, \"nnti\") == 0) {\n\textern transport_entry cmnnti_add_static_transport(CManager cm, CMtrans_services svc);\n\ttransport = cmnnti_add_static_transport(cm, &CMstatic_trans_svcs);\n\ttransport->data_available = CMDataAvailable;  /* callback pointer */\n\ttransport->write_possible = CMWriteQueuedData;  /* callback pointer */\n\t(void) add_transport_to_cm(cm, transport);\n    }\n#endif\n#ifdef LIBFABRIC_FOUND\n    if (strcmp(trans_name, \"fabric\") == 0) {\n\textern transport_entry cmfabric_add_static_transport(CManager cm, CMtrans_services svc);\n\ttransport = cmfabric_add_static_transport(cm, &CMstatic_trans_svcs);\n\ttransport->data_available = CMDataAvailable;  /* callback pointer */\n\ttransport->write_possible = CMWriteQueuedData;  /* callback pointer */\n\t(void) add_transport_to_cm(cm, transport);\n    }\n#endif\n#ifdef IB_FOUND\n    if (strcmp(trans_name, \"ib\") == 0) {\n\textern transport_entry cmib_add_static_transport(CManager cm, CMtrans_services svc);\n\ttransport = cmib_add_static_transport(cm, &CMstatic_trans_svcs);\n\ttransport->data_available = CMDataAvailable;  /* callback pointer */\n\ttransport->write_possible = CMWriteQueuedData;  /* callback pointer */\n\t(void) add_transport_to_cm(cm, transport);\n    }\n#endif\n#ifdef ENET_FOUND\n    if (strcmp(trans_name, \"enet\") == 0) {\n\textern transport_entry cmenet_add_static_transport(CManager cm, CMtrans_services svc);\n\ttransport = cmenet_add_static_transport(cm, &CMstatic_trans_svcs);\n\ttransport->data_available = CMDataAvailable;  /* callback pointer */\n\ttransport->write_possible = CMWriteQueuedData;  /* callback pointer */\n\t(void) add_transport_to_cm(cm, transport);\n    }\n#endif\n    if (!transport) return 0;\n#endif\n    CMtrace_out(cm, CMTransportVerbose, \"Loaded transport %s.\\n\", trans_name);\n    CMtrace_out(cm, CMTransportVerbose, \"Listen is %p\\n\", transport->listen);\n    if (global_transports != NULL) {\n      global_transports = INT_CMrealloc(global_transports, \n\t\t\t\t    sizeof(global_transports) * (i + 2));\n    } else {\n        global_transports = INT_CMmalloc(sizeof(global_transports) * (i+2));\n    }\n    global_transports[i] = transport;\n    global_transports[i+1] = NULL;\n    if (transport->install_pull_schedule_func && cm->avail) {\n\ttransport->install_pull_schedule_func(&CMstatic_trans_svcs,\n\t\t\t\t\t      transport, &cm->base_time, \n\t\t\t\t\t      &cm->period, cm->avail);\n\tCMtrace_out(cm, CMTransportVerbose, \"CM installed pull schedule to transport %s\\n\", transport->trans_name);\n    }\n\n    return 1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/dlloader.c": "#include \"config.h\"\n#include <dlfcn.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"dlloader.h\"\n\nstatic char **search_list = NULL;\n\nvoid\nCMdladdsearchdir(char *string)\n{\n    int count = 0;\n    if (search_list == NULL) {\n\tsearch_list = malloc(2*sizeof(char*));\n    } else {\n\twhile(search_list[count] != NULL) count++;\n\tsearch_list = realloc(search_list, (count+2)*sizeof(char*));\n    }\n    search_list[count] = strdup(string);\n    search_list[count+1] = NULL;\n}\n\ntypedef struct {\n    void *dlopen_handle;\n    char *lib_prefix;\n} *dlhandle;\n\nstatic int dlopen_verbose = -1;\n\nvoid\nCMset_dlopen_verbose(int verbose)\n{\n    dlopen_verbose = verbose;\n}\n\nvoid *\nCMdlopen(void *CMTrace_filev, char *in_lib, int mode)\n{\n#if NO_DYNAMIC_LINKING\n    return NULL;\n#else\n    dlhandle dlh;\n    void *handle = NULL;\n    char *tmp;\n    char *lib;\n    FILE *CMTrace_file = (FILE*)CMTrace_filev;\n    if (dlopen_verbose == -1) {\n\tdlopen_verbose = (getenv(\"CMTransportVerbose\") != NULL);\n    }\n    tmp = rindex(in_lib, '.');\n    if (dlopen_verbose) fprintf(CMTrace_file, \"Trying to dlopen %s\\n\", in_lib);\n    if (tmp && (strcmp(tmp, \".la\") == 0)) {\n\t/* can't open .la files */\n\tlib = malloc(strlen(in_lib) + strlen(MODULE_EXT) + 8);\n\tstrcpy(lib, in_lib);\n\tstrcpy(rindex(lib, '.'), MODULE_EXT);\n\tif (dlopen_verbose) fprintf(CMTrace_file, \"Dlopen module name replaced, now %s\\n\", lib);\n    } else {\n\tlib = strdup(in_lib);\n    }\n    char **list = search_list;\n    while(list && (list[0] != NULL)) {\n        char *tmp = malloc(strlen(list[0]) + strlen(lib) + 2);\n\tsprintf(tmp, \"%s/%s\", list[0], lib);\n\thandle = dlopen(tmp, RTLD_LAZY);\n\tchar *err = dlerror();\n\tif (dlopen_verbose) {\n\t    if (err) {\n\t\tfprintf(CMTrace_file, \"Failed to dlopen %s, error is %s\\n\", tmp, err);\n\t    } else {\n\t\tfprintf(CMTrace_file, \"DLopen of %s succeeded\\n\", tmp);\n\t    }\n\t}\n \tlist++;\n\tif (handle) list = NULL; // fall out\n    }\n    if (!handle) {\n        handle = dlopen(lib, RTLD_LAZY);\n\tchar *err = dlerror();\n\tif (dlopen_verbose) {\n\t    if (err) {\n\t\tfprintf(CMTrace_file, \"Failed to dlopen %s, error is %s\\n\", tmp, err);\n\t    } else {\n\t\tfprintf(CMTrace_file, \"DLopen of %s succeeded\\n\", tmp);\n\t    }\n\t}\n    }\n    if (!handle) return NULL;\n    dlh = malloc(sizeof(*dlh));\n    tmp = rindex(lib, '/'); /* find name start */\n    if (!tmp) tmp = lib;\n\n    char *cm_lib_prefix;\n    if(strlen(CM_LIBRARY_PREFIX) > 0 &&\n      (cm_lib_prefix = strstr(tmp, CM_LIBRARY_PREFIX))) {\n      dlh->lib_prefix = malloc(strlen(tmp) - strlen(CM_LIBRARY_PREFIX) + 4);\n      strncpy(dlh->lib_prefix, tmp, cm_lib_prefix-tmp);\n      strcpy(dlh->lib_prefix + (cm_lib_prefix - tmp),\n          cm_lib_prefix + strlen(CM_LIBRARY_PREFIX));\n    }\n    else {\n      dlh->lib_prefix = malloc(strlen(tmp) + 4);\n      strcpy(dlh->lib_prefix, tmp);\n    }\n    tmp = rindex(dlh->lib_prefix, '.');\n    strcpy(tmp, \"_LTX_\");  /* kill postfix, add _LTX_ */\n    dlh->dlopen_handle = handle;\n    free(lib);\n    return (void*)dlh;\n#endif\n}\n\nvoid*\nCMdlsym(void *vdlh, char *sym)\n{\n#if NO_DYNAMIC_LINKING\n    return NULL;\n#else\n    dlhandle dlh = (dlhandle)vdlh;\n    char *tmp = malloc(strlen(sym) + strlen(dlh->lib_prefix) + 1);\n    void *sym_val;\n    strcpy(tmp, dlh->lib_prefix);\n    strcat(tmp, sym);\n    sym_val = dlsym(dlh->dlopen_handle, tmp);\n    free(tmp);\n    if (!sym_val) \n\tsym_val = dlsym(dlh->dlopen_handle, sym);\n    return sym_val;\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/dlloader.h": "#include <dlfcn.h>\n#define lt_dlopen(x) CMdlopen(cm, x, 0)\n#define lt_dladdsearchdir(x) CMdladdsearchdir(x)\n#define lt_dlsym(x, y) CMdlsym(x, y)\n#define lt_dlhandle void*\n#define MODULE_EXT CMAKE_SHARED_MODULE_SUFFIX\nextern void CMdladdsearchdir(char *dir);\nextern void* CMdlopen(void *CMTrace_file, char *library, int mode);\nextern void* CMdlsym(void *handle, char *symbol);\nextern void CMset_dlopen_verbose(int verbose);\n",
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/response.c": "#include \"config.h\"\n#undef NDEBUG\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <strings.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"evpath.h\"\n#include \"cod.h\"\n#include \"cm_internal.h\"\n#include \"dlloader.h\"\n\ntypedef enum {Response_Filter, Response_Transform, Response_Router, Response_Multityped} response_types;\n\nstruct terminal_spec {\n    FMStructDescList format_list;\n    void *handler;\n    void *client_data;\n};\n\nstruct filter_spec {\n    FMStructDescList format_list;\n    char *function;\n    void *client_data;\n    FMFormat reference_format;\n};\n\nstruct transform_spec {\n    FMStructDescList in_format_list;\n    FMStructDescList out_format_list;\n    char *function;\n    void *client_data;\n    FMFormat reference_input_format;\n    FMFormat reference_output_format;\n    EVsource source_handle;\n    int output_base_struct_size;\n};\n\nstruct multityped_spec {\n    FMStructDescList *struct_list;\n    char *function;\n    void *client_data;\n    int accept_anonymous;\n    FMFormat *reference_input_format_list;\n};\n\ntypedef struct response_spec {\n    response_types response_type;\n    union {\n\tstruct terminal_spec term;\n\tstruct filter_spec filter;\n\tstruct transform_spec transform;\n\tstruct multityped_spec multityped;\n    }u;\n} *handler_list;\n\nstruct filter_instance {\n    int (*func_ptr)(void *, attr_list);\n    cod_code code;\n    cod_exec_context ec;\n    void *client_data;\n};\n\nstruct transform_instance {\n    int (*func_ptr)(void *, void*, attr_list, attr_list);\n    cod_code code;\n    cod_exec_context ec;\n    int out_size;\n    void *client_data;\n    FMFormat out_format;\n};\n\nstruct queued_instance {\n    int ref_count;\n    cod_code code;\n    cod_exec_context ec;\n    void *client_data;\n    FMFormat *formats;\n};\n\ntypedef struct response_instance {\n    response_types response_type;\n    int stone;\n    int proto_action_id;\n    union {\n\tstruct filter_instance filter;\n\tstruct transform_instance transform;\n\tstruct queued_instance queued;\n    }u;\n} *response_instance;\n\n\nstatic char *\nadd_FMfieldlist_to_string(char *str, FMStructDescRec *f)\n{\n    int index, field_count = 0;\n    FMFieldList list = f->field_list;\n    int len = strlen(str);\n    char *tmp_str;\n    len += strlen(f->format_name) + 5 + 35 + 20;\n    str = realloc(str, len);\n    while(list && (list[field_count].field_name != NULL)) field_count++;\n    tmp_str = str + strlen(str);\n    sprintf(tmp_str, \"FMFormat \\\"%s\\\" StructSize %d FieldCount %d\\n\",\n\t    f->format_name, f->struct_size, field_count);\n    for (index = 0; index < field_count; index++) {\n\tlen += strlen(list[index].field_name) +strlen(list[index].field_type) + 50;\n\tstr = realloc(str, len);\n\ttmp_str = str + strlen(str);\n\tsprintf(tmp_str, \"    FMField \\\"%s\\\" \\\"%s\\\" %d %d\\n\",\n\t\tlist[index].field_name, list[index].field_type,\n\t\tlist[index].field_size, list[index].field_offset);\n    }\n    return str;\n}\n\n/*static char *\nadd_IOformat_to_string(char *str, IOFormat ioformat)\n{\n    return add_IOfieldlist_to_string(str, name_of_IOformat(ioformat),\n\t\t\t\t     field_list_of_IOformat(ioformat));\n}*/\n\nstatic char *\nget_str(char *str, const char **name_p)\n{\n    int name_len = 0;\n    char *name = malloc(1);\n    while (*str != '\"') {\n\tname = realloc(name, (name_len + 2));\n\tname[name_len++] = *(str++);\n    }\n    name[name_len] = 0;\n    str++;\n    *name_p = name;\n    return str;\n}\n\nstatic char *\nparse_FMformat_from_string(char *str, FMStructDescRec *f)\n{\n    char *name;\n    FMFieldList list;\n    int struct_size;\n    f->format_name = NULL;\n    f->field_list = NULL;\n    f->struct_size = 0;\n    f->opt_info = NULL;\n    if (strncmp(str, \"FMFormat \\\"\", 10) == 0) {\n\tint field_count;\n\tint index = 0;\n\tstr += 10;\n\tstr = get_str(str, (const char **)&name);\n\tstr += strlen(\" StructSize \");\n\tif (sscanf(str, \"%d\", &struct_size) == 1) {\n\t    while(isdigit((int)*str)) str++;\n\t}\n\tstr += strlen(\" FieldCount \");\n\tif (sscanf(str, \"%d\", &field_count) == 1) {\n\t    while(isdigit((int)*str)) str++;\n\t}\n\tstr++;\n\tlist = malloc(sizeof(*list) * (field_count + 1));\n\tfor (index = 0; index < field_count; index++) {\n\t    str += strlen(\"    FMField \\\"\");\n\t    str = get_str(str, &(list[index].field_name));\n\t    str += 2;\n\t    str = get_str(str, &(list[index].field_type));\n\t    str++;\n\t    if (sscanf(str, \"%d\", &list[index].field_size) == 1) {\n\t\twhile(isdigit((int)*str)) str++;\n\t    }\n\t    str++;\n\t    if (sscanf(str, \"%d\", &list[index].field_offset) == 1) {\n\t\twhile(isdigit((int)*str)) str++;\n\t    }\n\t    str = strchr(str, '\\n') + 1;\n\t}\n\tlist[field_count].field_name = NULL;\n\tlist[field_count].field_type = NULL;\n\tlist[field_count].field_size = 0;\n\tlist[field_count].field_offset = 0;\n\tif (field_count == 0) {\n\t    free(list);\n\t    list = NULL;\n\t}\n\tf->format_name = name;\n\tf->field_list = list;\n\tf->struct_size = struct_size;\n    }\n    return str;\n}\n\nvoid *\ninstall_response_handler(CManager cm, int stone_id, char *response_spec,\n\t\t\t void *local_data, FMFormat **ref_ptr)\n{\n    char *str = response_spec;\n    (void)stone_id;\n    if (strncmp(\"Terminal Action\", str, strlen(\"Terminal Action\")) == 0) {\n\tint format_count, i;\n\tFMStructDescList list;\n\tstr += strlen(\"Terminal Action\") + 1;\n\tsscanf(str, \"  Format Count %d\\n\", &format_count);\n\tstr = strchr(str, '\\n') + 1;\n\tlist = malloc(sizeof(list[0]) * (format_count + 1));\n\tfor (i=0; i < format_count; i++) {\n\t    str = parse_FMformat_from_string(str, &list[i]);\n\t}\n\tlist[format_count].format_name = NULL;\n/*\tINT_EVassoc_terminal_action(cm, stone_id, list, local_data, NULL);*/\n    }\n    if (strncmp(\"Filter Action\", str, strlen(\"Filter Action\")) == 0) {\n\tstruct response_spec *response = malloc(sizeof(struct response_spec));\n\tint format_count, i;\n\tchar *function;\n\tFMStructDescList list;\n\tstr += strlen(\"Filter Action\") + 1;\n\tsscanf(str, \"  Format Count %d\\n\", &format_count);\n\tstr = strchr(str, '\\n') + 1;\n\tlist = malloc(sizeof(list[0]) * (format_count + 1));\n\tfor (i=0; i < format_count; i++) {\n\t    str = parse_FMformat_from_string(str, &list[i]);\n\t}\n\tlist[format_count].format_name = NULL;\n\tfunction = malloc(strlen(str) + 1);\n\tstrcpy(function, str);\n\tresponse->response_type = Response_Filter;\n\tresponse->u.filter.format_list = list;\n\tresponse->u.filter.function = function;\n\tresponse->u.filter.client_data = local_data;\n\tresponse->u.filter.reference_format =\n\t    EVregister_format_set(cm, list);\n\tif (ref_ptr) {\n\t    FMFormat *formats = malloc(2*sizeof(FMFormat));\n\t    formats[1] = NULL;\n\t    formats[0] = response->u.filter.reference_format;\n\n\t    *ref_ptr = formats;\n\t}\n\treturn (void*)response;\n    }\n    if (strncmp(\"Router Action\", str, strlen(\"Router Action\")) == 0) {\n\tstruct response_spec *response = malloc(sizeof(struct response_spec));\n\tint format_count, i;\n\tchar *function;\n\tFMStructDescList list;\n\tstr += strlen(\"Router Action\") + 1;\n\tsscanf(str, \"  Format Count %d\\n\", &format_count);\n\tstr = strchr(str, '\\n') + 1;\n\tlist = malloc(sizeof(list[0]) * (format_count + 1));\n\tfor (i=0; i < format_count; i++) {\n\t    str = parse_FMformat_from_string(str, &list[i]);\n\t}\n\tlist[format_count].format_name = NULL;\n\tfunction = malloc(strlen(str) + 1);\n\tstrcpy(function, str);\n\tresponse->response_type = Response_Router;\n\tresponse->u.filter.format_list = list;\n\tresponse->u.filter.function = function;\n\tresponse->u.filter.client_data = local_data;\n\tresponse->u.filter.reference_format =\n\t    EVregister_format_set(cm, list);\n\tif (ref_ptr) {\n\t    FMFormat *formats = malloc(2*sizeof(FMFormat));\n\t    formats[1] = NULL;\n\t    formats[0] = response->u.filter.reference_format;\n\n\t    *ref_ptr = formats;\n\t}\n\treturn (void*)response;\n    }\n    if (strncmp(\"Transform Action\", str, strlen(\"Transform Action\")) == 0) {\n\tstruct response_spec *response = malloc(sizeof(struct response_spec));\n\tint format_count, i;\n\tchar *function;\n\tFMStructDescList in_list, out_list;\n\tstr += strlen(\"Transform Action\") + 1;\n\tsscanf(str, \"  Input Format Count %d\\n\", &format_count);\n\tstr = strchr(str, '\\n') + 1;\n\tin_list = malloc(sizeof(in_list[0]) * (format_count + 1));\n\tfor (i=0; i < format_count; i++) {\n\t    str = parse_FMformat_from_string(str, &in_list[i]);\n\t}\n\tin_list[format_count].format_name = NULL;\n\tin_list[format_count].field_list = NULL;\n\tif (sscanf(str, \"  Output Format Count %d\\n\", &format_count) != 1) {\n\t    printf(\"output format parse failed\\n\");\n\t    return 0;\n\t}\n\tstr = strchr(str, '\\n') + 1;\n\tout_list = malloc(sizeof(out_list[0]) * (format_count + 1));\n\tfor (i=0; i < format_count; i++) {\n\t    str = parse_FMformat_from_string(str, &out_list[i]);\n\t}\n\tout_list[format_count].format_name = NULL;\n\tout_list[format_count].field_list = NULL;\n\tfunction = malloc(strlen(str) + 1);\n\tstrcpy(function, str);\n\tresponse->response_type = Response_Transform;\n\tresponse->u.transform.in_format_list = in_list;\n\tresponse->u.transform.out_format_list = out_list;\n\tresponse->u.transform.function = function;\n\tresponse->u.transform.client_data = local_data;\n\tresponse->u.transform.reference_input_format = NULL;\n\tif (in_list[0].format_name != NULL)\n\t    response->u.transform.reference_input_format =\n\t\tEVregister_format_set(cm, in_list);\n\tif (ref_ptr) {\n\t    FMFormat *formats = malloc(2*sizeof(FMFormat));\n\t    formats[1] = NULL;\n\t    formats[0] = response->u.transform.reference_input_format;\n\t    *ref_ptr = formats;\n\t}\n\tif (out_list[0].format_name != NULL)\n\t    response->u.transform.reference_output_format =\n\t\tEVregister_format_set(cm, out_list);\n\tresponse->u.transform.output_base_struct_size = out_list[0].struct_size;\n\treturn (void*)response;\n    }\n    if (strncmp(\"Multityped Action\", str, strlen(\"Multityped Action\")) == 0) {\n\tstruct response_spec *response = malloc(sizeof(struct response_spec));\n\tint list_count, j;\n\tchar *function;\n\tFMStructDescList *struct_list;\n\tint accept_anonymous = 0;\n\n\tstr += strlen(\"Multityped Action\") + 1;\n\tsscanf(str, \"  List Count %d\\n\", &list_count);\n\tstr = strchr(str, '\\n') + 1;\n\tstruct_list = malloc(sizeof(struct_list[0]) * (list_count + 1));\n\tfor (j = 0; j < list_count; j++) {\n\t    int format_count2, k;\n\t    FMStructDescList in_list;\n\t    sscanf(str, \"Next format   Subformat Count %d\\n\", &format_count2);\n\t    str = strchr(str, '\\n') + 1;\n\n\t    in_list = malloc(sizeof(in_list[0]) * (format_count2 + 1));\n\t    for (k=0; k < format_count2; k++) {\n\t\tstr = parse_FMformat_from_string(str, &in_list[k]);\n\t    }\n\t    in_list[format_count2].format_name = NULL;\n\t    in_list[format_count2].field_list = NULL;\n\t    struct_list[j] = in_list;\n\t    if (struct_list[j]->field_list == NULL) {  /* anonymous */\n\t\tfree(struct_list[j]->format_name);\n\t\tfree(in_list);\n\t\tstruct_list[j] = NULL;\n\t\tlist_count--;\n\t\tj--;\n\t\taccept_anonymous++;\n\t    }\n\t}\n\tstruct_list[list_count] = NULL;\n\tfunction = malloc(strlen(str) + 1);\n\tstrcpy(function, str);\n\tresponse->response_type = Response_Multityped;\n\tresponse->u.multityped.struct_list = struct_list;\n\tresponse->u.multityped.function = function;\n\tresponse->u.multityped.client_data = local_data;\n\tresponse->u.multityped.accept_anonymous = accept_anonymous;\n\tresponse->u.multityped.reference_input_format_list =\n\t    malloc((list_count +1) * sizeof(FMFormat));\n\tfor (j = 0; j < list_count; j++) {\n\t    if ((struct_list[j])[0].format_name != NULL) {\n\t\tresponse->u.multityped.reference_input_format_list[j] =\n\t\t    EVregister_format_set(cm, struct_list[j]);\n\t    }\n\t}\n\tif (ref_ptr) {\n\t    FMFormat *formats = malloc((list_count + 1)*sizeof(FMFormat));\n\t    int k = 0;\n\t    for (k=0; k < list_count; k++) {\n\t\tformats[k] = response->u.multityped.reference_input_format_list[k];\n\t    }\n\t    formats[list_count] = NULL;\n\t    *ref_ptr = formats;\n\t}\n\treturn (void*)response;\n    }\n    printf(\"Unparsed action : %s\\n\", str);\n    return NULL;\n}\n\n\nchar *\ncreate_terminal_action_spec(FMStructDescList format_list)\n{\n    int format_count = 0;\n    int i;\n    char *str;\n    while(format_list[format_count].format_name != NULL) format_count++;\n    str = malloc(50);\n    sprintf(str, \"Terminal Action   Format Count %d\\n\", format_count);\n\n    for (i = 0 ; i < format_count; i++) {\n\tstr = add_FMfieldlist_to_string(str, &format_list[i]);\n    }\n    return str;\n}\n\nchar *\nINT_create_bridge_action_spec(int stone_id, char *contact)\n{\n    int size = strlen(contact);\n    char *output;\n    size += strlen(\"Bridge Action\") + 20;\n    output = malloc(size);\n    sprintf(output, \"Bridge Action %d %s\", stone_id, contact);\n    return output;\n}\n\nvoid\nparse_bridge_action_spec(char *action_spec, int *target, char **contact)\n{\n    action_spec += strlen(\"Bridge Action \");\n    sscanf(action_spec, \"%d\", target);\n    while(*action_spec != ' ') action_spec++;\n    action_spec++;\n    *contact = action_spec;\n}\n\naction_value\naction_type(char *action_spec)\n{\n    if (action_spec == NULL)\n\treturn Action_Split;\n    if (strncmp(action_spec, \"Bridge Action\", 13) == 0)\n\treturn Action_Bridge;\n    if (strncmp(action_spec, \"Filter Action\", 13) == 0)\n\treturn Action_Immediate;\n    if (strncmp(action_spec, \"Router Action\", 13) == 0)\n\treturn Action_Immediate;\n    if (strncmp(action_spec, \"Transform Action\", 16) == 0)\n\treturn Action_Immediate;\n    if (strncmp(action_spec, \"Multityped Action\", 17) == 0)\n\treturn Action_Multi;\n    if (strncmp(action_spec, \"sink:\", 5) == 0)\n\treturn Action_Terminal;\n    if (strncmp(action_spec, \"source:\", 7) == 0)\n\treturn Action_Source;\n    if (strncmp(action_spec, \"Split Action\", 7) == 0)\n\treturn Action_Split;\n    return Action_NoAction;\n}\n\nchar *\nINT_create_filter_action_spec(FMStructDescList format_list, char *function)\n{\n    int format_count = 0;\n    int i;\n    char *str;\n    while(format_list && (format_list[format_count].format_name != NULL)) format_count++;\n    str = malloc(50);\n    sprintf(str, \"Filter Action   Format Count %d\\n\", format_count);\n\n    for (i = 0 ; i < format_count; i++) {\n\tstr = add_FMfieldlist_to_string(str, &format_list[i]);\n    }\n    str = realloc(str, strlen(str) + strlen(function) + 1);\n    strcpy(&str[strlen(str)], function);\n    return str;\n}\n\nchar *\nINT_create_router_action_spec(FMStructDescList format_list, char *function)\n{\n    int format_count = 0;\n    int i;\n    char *str;\n    while(format_list && (format_list[format_count].format_name != NULL)) format_count++;\n    str = malloc(50);\n    sprintf(str, \"Router Action   Format Count %d\\n\", format_count);\n\n    for (i = 0 ; i < format_count; i++) {\n\tstr = add_FMfieldlist_to_string(str, &format_list[i]);\n    }\n    str = realloc(str, strlen(str) + strlen(function) + 1);\n    strcpy(&str[strlen(str)], function);\n    return str;\n}\n\nchar *\nINT_create_transform_action_spec(FMStructDescList format_list, FMStructDescList out_format_list, char *function)\n{\n    int format_count = 0;\n    int i;\n    char *str;\n    while(format_list && format_list[format_count].format_name != NULL)\n\tformat_count++;\n    str = malloc(50);\n    sprintf(str, \"Transform Action   Input Format Count %d\\n\", format_count);\n\n    for (i = 0 ; i < format_count; i++) {\n\tstr = add_FMfieldlist_to_string(str, &format_list[i]);\n    }\n\n    format_count = 0;\n    while(out_format_list[format_count].format_name != NULL) format_count++;\n    str = realloc(str, strlen(str) + 30);\n    sprintf(str + strlen(str), \"  Output Format Count %d\\n\", format_count);\n\n    for (i = 0 ; i < format_count; i++) {\n\tstr = add_FMfieldlist_to_string(str, &out_format_list[i]);\n    }\n    str = realloc(str, strlen(str) + strlen(function) + 1);\n    strcpy(&str[strlen(str)], function);\n    return str;\n}\n\nextern char *\nINT_create_multityped_action_spec(FMStructDescList *input_format_lists, char *function)\n{\n    int list_count = 0;\n    int l, i;\n    char *str;\n    while(input_format_lists && input_format_lists[list_count] != NULL)\n\tlist_count++;\n\n    str = malloc(50);\n    sprintf(str, \"Multityped Action   List Count %d\\n\", list_count);\n\n    for (l = 0; l < list_count; l++) {\n\tint format_count = 0;\n\tFMStructDescList format_list = input_format_lists[l];\n\twhile(format_list && format_list[format_count].format_name != NULL)\n\t    format_count++;\n\tstr = realloc(str, strlen(str) + 50);\n\tsprintf(str + strlen(str), \"Next format   Subformat Count %d\\n\",\n\t\tformat_count);\n\tfor (i = 0 ; i < format_count; i++) {\n\t    str = add_FMfieldlist_to_string(str, &format_list[i]);\n\t}\n    }\n\n    str = realloc(str, strlen(str) + strlen(function) + 1);\n    strcpy(&str[strlen(str)], function);\n    return str;\n}\n\nstruct ev_state_data {\n    CManager cm;\n    struct _event_item *cur_event;\n    int stone;\n    int proto_action_id;\n    int out_count;\n    int *out_stones;\n    queue_item *item;\n    struct _queue *queue;\n    response_instance instance;\n    int did_output;\n};\n\nextern CManager\nget_cm_from_ev_state(void *vevstate)\n{\n    struct ev_state_data *evstate = (struct ev_state_data *)vevstate;\n    return evstate->cm;\n}\n\nstatic int\nfilter_wrapper(CManager cm, struct _event_item *event, void *client_data,\n\t       attr_list attrs, int out_count, int *out_stones)\n{\n    response_instance instance = (response_instance)client_data;\n    int ret;\n    cod_exec_context ec = instance->u.filter.ec;\n    struct ev_state_data ev_state;\n\n    ev_state.cm = cm;\n    ev_state.cur_event = event;\n    ev_state.out_count = out_count;\n    ev_state.out_stones = out_stones;\n    if (ec != NULL) {\n\tcod_assoc_client_data(ec, 0x34567890, (long)&ev_state);\n\n\tret = ((int(*)(cod_exec_context, void *, attr_list))instance->u.filter.code->func)(ec, event->decoded_event, attrs);\n    } else {\n\t/* DLL-based handler */\n\tret = ((int(*)(void *, attr_list))instance->u.filter.func_ptr)(event->decoded_event, attrs);\n    }\n    if (ret) {\n\tCMtrace_out(cm, EVerbose, \"Filter function returned %d, submitting further to stone %d\\n\", ret, out_stones[0]);\n\tinternal_path_submit(cm, out_stones[0], event);\n    } else {\n\tCMtrace_out(cm, EVerbose, \"Filter function returned %d, NOT submitting\\n\", ret);\n    }\n    return ret;\n}\nstatic int\nrouter_wrapper(CManager cm, struct _event_item *event, void *client_data,\n\t       attr_list attrs, int out_count, int *out_stones)\n{\n    response_instance instance = (response_instance)client_data;\n    int ret;\n    if (instance->u.filter.func_ptr) {\n\tret = ((int(*)(void *, attr_list))instance->u.filter.func_ptr)(event->decoded_event, attrs);\n    } else {\n\tint (*func)(cod_exec_context, void *, attr_list) =\n\t    (int(*)(cod_exec_context, void *, attr_list))instance->u.filter.code->func;\n\tcod_exec_context ec = instance->u.filter.ec;\n\tstruct ev_state_data ev_state;\n\n\tev_state.cm = cm;\n\tev_state.cur_event = event;\n\tev_state.out_count = out_count;\n\tev_state.out_stones = out_stones;\n\tcod_assoc_client_data(ec, 0x34567890, (long)&ev_state);\n\tret = (func)(ec, event->decoded_event, attrs);\n    }\n    if (ret >= 0) {\n\tif (ret >= out_count) {\n\t    CMtrace_out(cm, EVerbose, \"Router function returned %d, larger than the number of associated outputs\\n\", ret);\n\t} else if (out_stones[ret] == -1) {\n\t    CMtrace_out(cm, EVerbose, \"Router function returned %d, which has not been set with EVaction_set_output()\\n\", ret);\n\t} else {\n\t    CMtrace_out(cm, EVerbose, \"Router function returned %d, submitting further to stone %d\\n\", ret, out_stones[ret]);\n\t    internal_path_submit(cm, out_stones[ret], event);\n\t}\n    } else {\n\tCMtrace_out(cm, EVerbose, \"Router function returned %d, NOT submitting\\n\", ret);\n    }\n    return ret;\n}\n\nstatic void\ntransform_free_wrapper(void *data, void *free_data)\n{\n    FMFormat out_format = (FMFormat)free_data;\n    FMfree_var_rec_elements(out_format, data);\n    free(data);\n}\n\nstatic int\ntransform_wrapper(CManager cm, struct _event_item *event, void *client_data,\n\t\t  attr_list attrs, int out_count, int *out_stones)\n{\n    response_instance instance = (response_instance)client_data;\n    int ret;\n    void *out_event = malloc(instance->u.transform.out_size);\n    int(*func)(cod_exec_context, void *, void*, attr_list, attr_list) = NULL;\n    cod_exec_context ec = instance->u.transform.ec;\n    struct ev_state_data ev_state;\n    attr_list output_attrs = create_attr_list();\n\n    ev_state.cm = cm;\n    ev_state.cur_event = event;\n    ev_state.stone = instance->stone;\n    ev_state.proto_action_id = instance->proto_action_id;\n    ev_state.out_count = out_count;\n    ev_state.out_stones = out_stones;\n\n    if (CMtrace_on(cm, EVerbose)) {\n\tfprintf(cm->CMTrace_file, \"Input Transform Event is :\\n\");\n\tif (event->reference_format) {\n\t    FMfdump_data(cm->CMTrace_file, event->reference_format, event->decoded_event, 10240);\n\t} else {\n\t    fprintf(cm->CMTrace_file, \"       ****  UNFORMATTED  ****\\n\");\n\t}\n    }\n    memset(out_event, 0, instance->u.transform.out_size);\n    if (ec != NULL) {\n\tfunc = (int(*)(cod_exec_context, void *, void*, attr_list, attr_list))instance->u.transform.code->func;\n\tcod_assoc_client_data(ec, 0x34567890, (long)&ev_state);\n\tret = func(ec, event->decoded_event, out_event, attrs, output_attrs);\n    } else {\n\t/* DLL-based handler */\n\tret = ((int(*)(void *, void *, attr_list, attr_list))instance->u.transform.func_ptr)(event->decoded_event, out_event, attrs, output_attrs);\n    }\n\n    if (ret && (out_stones[0] == -1)) {\n\tprintf(\"Transform output stone ID not set, event discarded\\n\");\n\tret = 0;\n    }\n    if (ret) {\n\tstruct _EVSource s;\n\tif (CMtrace_on(cm, EVerbose)) {\n\t    FMFormat f = instance->u.transform.out_format;\n\t    fprintf(cm->CMTrace_file, \" Transform function returned %d, submitting further\\n\", ret);\n\t    FMfdump_data(cm->CMTrace_file, f, out_event, 10240);\n\t}\n\ts.local_stone_id = out_stones[0];\n\ts.cm = cm;\n\ts.format = NULL;\n\ts.reference_format = instance->u.transform.out_format;\n\ts.free_func = transform_free_wrapper;\n\ts.free_data = instance->u.transform.out_format;\n\ts.preencoded = 0;\n\tINT_EVsubmit(&s, out_event, output_attrs);\n    } else {\n\tCMtrace_out(cm, EVerbose, \"Transform function returned %d, NOT submitting\\n\", ret);\n\ttransform_free_wrapper(out_event, instance->u.transform.out_format);\n    }\n    free_attr_list(output_attrs);\n    return ret;\n}\n\n/* {{{ cod_find_index */\nstatic queue_item *queue_find_index(queue_item *item, int i, FMFormat format) {\n    for (;;) {\n        if (!item) {\n            return NULL;\n        }\n        if (!format || (item->item->reference_format == format)) {\n            if (i == 0)\n                return item;\n            --i;\n        }\n        item = item->next;\n    }\n}\n\nstatic queue_item *queue_find_anonymous(queue_item *item, int i, FMFormat *formats) {\n    for (;;) {\n\tint known = 0;\n\tint j = 0;\n        if (!item) {\n            return NULL;\n        }\n\twhile(formats[j]) {\n\t    if (item->item->reference_format == formats[j]) known++;\n\t    j++;\n\t}\n        if (known == 0) {\n            if (i == 0)\n                return item;\n            --i;\n        }\n        item = item->next;\n    }\n}\n\nstatic queue_item *cod_find_index_rel(struct ev_state_data *ev_state, int queue, int index)\n{\n    if (queue != -2) {\n\treturn queue_find_index(\n\t    ev_state->queue->queue_head, index,\n\t    queue < 0 ?  NULL : ev_state->instance->u.queued.formats[queue]);\n    } else {\n\treturn queue_find_anonymous(\n\t    ev_state->queue->queue_head, index, ev_state->instance->u.queued.formats);\n    }\n}\n\nstatic queue_item *cod_find_index_abs(struct ev_state_data *ev_state, int queue, int index) {\n    queue_item *ret;\n    ret = queue_find_index(ev_state->queue->queue_head, index, NULL);\n    if (!ret)\n        return NULL;\n    if (queue < 0 || ret->item->reference_format ==\n            ev_state->instance->u.queued.formats[queue])\n        return ret;\n    else\n        return NULL;\n}\n\nstatic queue_item *cod_find_index(int absp, struct ev_state_data *ev_state, int queue, int index) {\n    if (absp)\n        return cod_find_index_abs(ev_state, queue, index);\n    else\n        return cod_find_index_rel(ev_state, queue, index);\n}\n\n/* }}} */\n\nstatic void cod_ev_discard(cod_exec_context ec, int absp, int queue, int index) \n{\n    struct ev_state_data *ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n    CManager cm = ev_state->cm;\n    queue_item *item;\n\n    item = cod_find_index(absp, ev_state, queue, index);\n\n    assert(item);\n\n    EVdiscard_queue_item(cm, ev_state->stone, item);\n}\n\nstatic void cod_ev_discard_rel(cod_exec_context ec, int queue, int index) {\n    cod_ev_discard(ec, 0, queue, index);\n}\n\n#ifdef NOT_DEF\nstatic void cod_ev_discard_abs(cod_exec_context ec, int queue, int index) {\n    cod_ev_discard(ec, 1, queue, index);\n}\n#endif\n\nstatic EVstone\nport_to_stone(struct ev_state_data *evstate, int port)\n{\n    if (port >= evstate->out_count) {\n\tfprintf(stderr, \"Stone has %d outbound ports, port %d invalid\\n\",\n\t\tevstate->out_count, port);\n\treturn -1;\n    }\n    if (evstate->out_stones[port] == -1) {\n\tfprintf(stderr, \"Stone port %d target has not been set\\n\",\n\t\tport);\n    }\n    return evstate->out_stones[port];\n}\n\nstatic void cod_ev_discard_and_submit(cod_exec_context ec,\n        int absp, int port, int queue, int index) \n{\n    struct ev_state_data *ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n    CManager cm = ev_state->cm;\n    queue_item *item;\n    EVstone target_stone = port_to_stone(ev_state, port);\n\n    if (target_stone == -1) {\n        printf(\"Port %d on stone %d invalid\\n\", port, ev_state->stone);\n\treturn;\n    }\n\n    item = cod_find_index(absp, ev_state, queue, index);\n\n    if (item == NULL) {\n        printf(\"Item %x not found on queue %d, stone %d\\n\", index, queue, ev_state->stone);\n\treturn;\n    }\n\n    item->handled = 0;\n\n    internal_path_submit(cm, target_stone, item->item);\n\n    ev_state->did_output++;\n    EVdiscard_queue_item(cm, ev_state->stone, item);\n}\n\nstatic void cod_ev_submit(cod_exec_context ec,\n        int absp, int port, int queue, int index) \n{\n    struct ev_state_data *ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n    CManager cm = ev_state->cm;\n    queue_item *item;\n    EVstone target_stone = port_to_stone(ev_state, port);\n\n    if (target_stone == -1) {\n        printf(\"Port %d on stone %d invalid\\n\", port, ev_state->stone);\n\treturn;\n    }\n\n    item = cod_find_index(absp, ev_state, queue, index);\n\n    if (item == NULL) {\n        printf(\"Item %x not found on queue %d, stone %d\\n\", index, queue, ev_state->stone);\n\treturn;\n    }\n\n    item->handled = 0;\n\n    internal_path_submit(cm, target_stone, item->item);\n\n    ev_state->did_output++;\n}\n\nstatic void cod_ev_submit_rel(cod_exec_context ec,int port, int queue, int index) \n{\n    cod_ev_submit(ec, 0, port, queue, index);\n}\n\n#ifdef NOT_DEF\nstatic void cod_ev_submit_abs(cod_exec_context ec,int port, int queue, int index) \n{\n    cod_ev_submit(ec, 1, port, queue, index);\n}\n#endif\n\nstatic int cod_ev_get_port(cod_exec_context ec, int queue)\n{\n    struct ev_state_data *ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n    int port = (ev_state->out_stones[queue]);\n    \n    return  port;\n}\n\nstatic int cod_ev_target_size(cod_exec_context ec, int stone_num)\n{\n    struct ev_state_data *ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n\n    CManager cm = ev_state->cm;\n    stone_type stone = stone_struct(cm->evp, stone_num);\n    if (!stone) return -1;\n    return stone->queue_size;\n}\n\n\n\nstatic void cod_ev_discard_and_submit_rel(cod_exec_context ec, int port, int queue,\n        int index) {\n    struct ev_state_data *ev_state = (void*) cod_get_client_data(ec, 0x34567890);\n    EVstone target_stone = port_to_stone(ev_state, port);\n    if (target_stone == -1) {\n        printf(\"Port %d on stone %d invalid\\n\", port, ev_state->stone);\n\treturn;\n    }\n\n    cod_ev_discard_and_submit(ec, 0, port, queue, index);\n}\n\n#ifdef NOT_DEF\nstatic void cod_ev_discard_and_submit_abs(cod_exec_context ec, int port, int queue,\n        int index) {\n    struct ev_state_data *ev_state = (void*) cod_get_client_data(ec, 0x34567890);\n    EVstone target_stone = port_to_stone(ev_state, port);\n    if (target_stone == -1) {\n        printf(\"Port %d on stone %d invalid\\n\", port, ev_state->stone);\n\treturn;\n    }\n\n    cod_ev_discard_and_submit(ec, 1, port, queue, index);\n}\n#endif\n\nstatic void *cod_ev_get_data(cod_exec_context ec, int absp, int queue, int index)\n{\n    struct ev_state_data *ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n    queue_item *item;\n    item = cod_find_index(absp, ev_state, queue, index);\n\n    if (!item) {\n\treturn NULL;\n    }\n    assert(item->item);\n\n    if (!item->item->decoded_event) {\n        item->item = cod_decode_event(ev_state->cm, ev_state->stone,\n\t\t\t\t      ev_state->proto_action_id, item->item);\n    }\n    assert(item->item->decoded_event);\n\n    return item->item->decoded_event;\n}\n\nstatic void *cod_ev_get_data_rel(cod_exec_context ec, int queue, int index) {\n    return cod_ev_get_data(ec, 0, queue, index);\n}\n\nstatic void *cod_ev_get_data_abs(cod_exec_context ec, int queue, int index) {\n    return cod_ev_get_data(ec, 1, queue, index);\n}\n\nstatic int cod_ev_conforms(cod_exec_context ec, int queue, int index) {\n    struct ev_state_data *ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n    return cod_find_index_abs(ev_state, queue, index) != NULL;\n}\n\nstatic int cod_ev_present(cod_exec_context ec, int queue, int index) {\n    struct ev_state_data *ev_state = (void*) cod_get_client_data(ec, 0x34567890);\n    return cod_find_index_rel(ev_state, queue, index) != NULL;\n}\n\nstatic int cod_ev_count(cod_exec_context ec, int queue) {\n    struct ev_state_data *ev_state;\n    FMFormat type;\n    queue_item *item;\n    int count = 0;\n\n    /*    queue == -1 RETURNS total event count */\n    /*    queue == -2 returns anonymous event count (I.E. count of events not in the queued format list) */\n\n    int format_count = 0;\n\n    ev_state = (void*) cod_get_client_data(ec, 0x34567890);\n    while(ev_state->instance->u.queued.formats[format_count]) format_count++;\n\n    if (format_count <= queue) {\n\tprintf(\"Error, queue parameter(%d) to EVCount is larger than queue count (%d)\\n\",\n\t       queue, format_count);\n\treturn -1;\n    }\n    if (queue == -2) {\n\titem = ev_state->queue->queue_head;\n\twhile (item) {\n\t    int i;\n\t    for (i =0; i < format_count; i++) {\n\t\t/* on match break out of loop */\n\t\tif (item->item->reference_format == ev_state->instance->u.queued.formats[i]) break;\n\t    }\n\t    /* if we got to format_count without matching anything, increment count */\n\t    if (i == format_count) ++count;\n\t    item = item->next;\n\t}\n\treturn count;\n    }\n    type = queue < 0 ? NULL :\n        ev_state->instance->u.queued.formats[queue];\n    item = ev_state->queue->queue_head;\n    while (item) {\n        if (!type || item->item->reference_format == type)\n            ++count;\n        item = item->next;\n    }\n\n    return count;\n}\n\nstatic attr_list cod_ev_get_attrs(cod_exec_context ec, int queue, int index) {\n    struct ev_state_data *ev_state = (void*) cod_get_client_data(ec, 0x34567890);\n    queue_item *item = cod_find_index_rel(ev_state, queue, index);\n    attr_list *pattr;\n\n    if (NULL == item) {\n\tprintf(\"No item at index %d on queue %d\\n\", index, queue);\n\n\treturn NULL;\n    }\n    pattr = &item->item->attrs;\n    if (!*pattr) {\n        *pattr = CMcreate_attr_list(ev_state->cm);\n    }\n    return *pattr;\n}\n\nstatic attr_list cod_ev_get_stone_attrs(cod_exec_context ec, char *stone_name) {\n    struct ev_state_data *ev_state = (void*) cod_get_client_data(ec, 0x34567890);\n    CManager cm = ev_state->cm;\n    event_path_data evp = cm->evp;\n    attr_list ret_list = NULL;\n    int cur_stone;\n    static atom_t STONE_NAME_ATOM = -1;\n    if (STONE_NAME_ATOM == -1) {\n\tSTONE_NAME_ATOM = attr_atom_from_string(\"EVP_STONE_NAME\");\n    }\n    for (cur_stone = evp->stone_base_num; cur_stone < evp->stone_count + evp->stone_base_num; ++cur_stone) {\n\tstone_type stone = stone_struct(evp, cur_stone);\n\tif (stone && (stone->stone_attrs != NULL)) {\n\t    char *this_stone_name = NULL;\n\t    if (get_string_attr(stone->stone_attrs, STONE_NAME_ATOM, &this_stone_name)) {\n\t\tif (stone_name && (strcmp(this_stone_name, stone_name) == 0)) {\n\t\t    if (ret_list) printf(\"Warning, duplicate stone name \\\"%s\\\" found during attr query\\n\", stone_name);\n\t\t    ret_list = stone->stone_attrs;\n\t\t}\n\t    }\n\t}\n    }\n    return ret_list;\n}\n\nstatic int\nqueued_wrapper(CManager cm, struct _queue *queue, queue_item *item,\n                void *client_data, int out_count, int *out_stones)\n{\n    response_instance instance = (response_instance)client_data;\n    int(*func)(cod_exec_context) =  /* XXX wrong type */\n\t(int(*)(cod_exec_context))instance->u.queued.code->func;\n    cod_exec_context ec = instance->u.queued.ec;\n    struct ev_state_data ev_state;\n\n    ev_state.cm = cm;\n    ev_state.cur_event = NULL;\n    ev_state.stone = instance->stone;\n    ev_state.proto_action_id = instance->proto_action_id;\n    ev_state.out_count = out_count;\n    ev_state.out_stones = out_stones;\n    ev_state.queue = queue;\n    ev_state.item = item;\n    ev_state.instance = instance;\n    ev_state.did_output = 0;\n    cod_assoc_client_data(ec, 0x34567890, (long)&ev_state);\n\n    func(ec);\n\n    return ev_state.did_output;\n}\n\nstatic response_instance\ngenerate_filter_code(CManager cm, struct response_spec *mrd, stone_type stone,\n\t\t     FMFormat format);\nstatic response_instance\ngenerate_multityped_code(CManager cm, struct response_spec *mrd, stone_type stone,\n\t\t\t  FMFormat *formats);\n\nextern\nvoid\nfree_struct_list(list)\nFMStructDescList list;\n{\n    int format_count = 0;\n    int format;\n\n    while(list[format_count].format_name != NULL) format_count++;\n\n    for (format = 0; format < format_count; format++) {\n\tfree(list[format].format_name);\n\tfree_FMfield_list(list[format].field_list);\n    }\n    free(list);\n}\n\nstatic FMFormat\nlocalize_format(CManager cm, FMFormat format)\n{\n    FMFormat ret;\n    FMStructDescList local_formats = get_localized_formats(format);\n    ret = EVregister_format_set(cm, local_formats);\n    free_struct_list(local_formats);\n    return ret;\n}\n\nvoid\ndump_mrd(void *mrdv)\n{\n    struct response_spec *mrd = (struct response_spec *) mrdv;\n    switch (mrd->response_type) {\n    case Response_Filter:\n\tprintf(\"Response Filter, code is %s\\n\",\n\t       mrd->u.filter.function);\n\tbreak;\n    case Response_Router:\n\tprintf(\"Response Router, code is %s\\n\",\n\t       mrd->u.filter.function);\n\tbreak;\n    case Response_Transform:\n\tprintf(\"Response Transform, code is %s\\n\",\n\t       mrd->u.transform.function);\n\tbreak;\n    case Response_Multityped:\n\tprintf(\"Multityped Action, code is %s\\n\",\n\t       mrd->u.transform.function);\n\tbreak;\n    }\n}\n\nstatic int\nproto_action_in_stage(proto_action *act, action_class stage) {\n    switch (stage) {\n    case Immediate_and_Multi:\n        if (act->action_type == Action_Multi) return 1;\n        /* fallthrough */\n    case Immediate:\n        switch (act->action_type) {\n        case Action_Terminal:\n        case Action_Filter:\n        case Action_Split:\n        case Action_Immediate:\n        case Action_Store:\n            return 1;\n        default:\n            return 0;\n        }\n    case Bridge:\n        return act->action_type == Action_Bridge;\n    case Congestion:\n        return act->action_type == Action_Congestion;\n    default:\n        assert(0);\n    }\n    return 0;\n}\n\nextern int\nFMformat_compat_cmp2(FMFormat format, FMFormat *formatList,\n\t\t     int listSize, FMcompat_formats * older_format);\n\nstatic void\nfree_multi_response(void *client_data)\n{\n    response_instance resp = (response_instance) client_data;\n    resp->u.queued.ref_count--;\n    if (resp->u.queued.ref_count != 0) return;\n    if (resp->u.queued.code) cod_code_free(resp->u.queued.code);\n    if (resp->u.queued.ec) cod_exec_context_free(resp->u.queued.ec);\n    free(resp);\n}\n\nstatic void\nfree_imm_response(void *client_data)\n{\n    response_instance resp = (response_instance) client_data;\n    switch (resp->response_type) {\n    case Response_Filter:\n    case Response_Router:\n\tif (resp->u.filter.code) cod_code_free(resp->u.filter.code);\n\tif (resp->u.filter.ec) cod_exec_context_free(resp->u.filter.ec);\n\tbreak;\n    case Response_Transform:\n\tif (resp->u.transform.code) cod_code_free(resp->u.transform.code);\n\tif (resp->u.transform.ec) cod_exec_context_free(resp->u.transform.ec);\n\tbreak;\n    default:\n\tbreak;\n    }\n    free(resp);\n}\n\nint\nresponse_determination(CManager cm, stone_type stone, action_class stage, event_item *event)\n{\n    int nearest_proto_action = -1;\n    int return_value = 0;\n    FMFormat conversion_target_format = NULL;\n    FMFormat matching_format = NULL;\n    int i, format_count = 0;\n    FMFormat * formatList;\n    int *format_map;\n    FMcompat_formats older_format = NULL;\n\n    formatList =\n\t(FMFormat *) malloc((stone->proto_action_count + 1) * sizeof(FMFormat));\n    format_map = (int *) malloc((stone->proto_action_count + 1) * sizeof(int));\n    for (i = 0; i < stone->proto_action_count; i++) {\n\tint j = 0;\n        if (!proto_action_in_stage(&stone->proto_actions[i], stage)) {\n            continue;\n        }\n\twhile (stone->proto_actions[i].matching_reference_formats &&\n\t       (stone->proto_actions[i].matching_reference_formats[j] != NULL)) {\n\t    if (strcmp(name_of_FMformat(event->reference_format), name_of_FMformat(stone->proto_actions[i].matching_reference_formats[j])) == 0 ) {\n\t\tformatList = (FMFormat *) realloc(formatList, (format_count + 2) * sizeof(FMFormat));\n\t\tformat_map = realloc(format_map, (format_count + 2) * sizeof(int));\n\t\tformatList[format_count] = stone->proto_actions[i].matching_reference_formats[j];\n\t\tformat_map[format_count] = i;\n\t\tformat_count++;\n\t    }\n\t    j++;\n\t}\n    }\n    formatList[format_count] = NULL;\n    if (event->reference_format == NULL) {\n\t/* special case for unformatted input */\n\tfor (i=0 ; i < stone->proto_action_count ; i++) {\n            if (!proto_action_in_stage(&stone->proto_actions[i], stage))\n\t\tcontinue;\n\t    if ((stone->proto_actions[i].matching_reference_formats == NULL) ||\n\t\t(stone->proto_actions[i].matching_reference_formats[0] == NULL))\n\t\tnearest_proto_action = i;\n\t}\n    } else {\n\tint map_entry = FMformat_compat_cmp2(event->reference_format,\n\t\t\t\t\t\t    formatList,\n\t\t\t\t\t\t    format_count,\n\t\t\t\t\t\t    &older_format);\n\tif (map_entry != -1) {\n            nearest_proto_action = format_map[map_entry];\n            matching_format = formatList[map_entry];\n        }\n    }\n    if (nearest_proto_action == -1) {\n        /* special case for accepting anything */\n        for (i=0; i < stone->proto_action_count; i++) {\n            if (!proto_action_in_stage(&stone->proto_actions[i], stage)) continue;\n            if (((stone->proto_actions[i].matching_reference_formats == NULL) ||\n\t\t (stone->proto_actions[i].matching_reference_formats[0] == NULL))\n                && stone->proto_actions[i].data_state != Requires_Decoded) {\n                nearest_proto_action = i;\n            }\n            if (stone->proto_actions[i].action_type == Action_Multi) {\n\t\tstruct response_spec *mrd;\n\n\t\tmrd =\n\t\t    stone->proto_actions[i].o.imm.mutable_response_data;\n\t\tif (mrd->u.multityped.accept_anonymous) {\n\t\t    nearest_proto_action = i;\n\t\t}\n            }\n        }\n    }\n    free(formatList);\n    free(format_map);\n    if (nearest_proto_action != -1) {\n\tint action_generated = 0;\n\tproto_action *proto = &stone->proto_actions[nearest_proto_action];\n\tif (proto->action_type == Action_Immediate) {\n\t    /* must be immediate action */\n\t    response_instance instance;\n\t    struct response_spec *mrd;\n\t    mrd =\n\t\tproto->o.imm.mutable_response_data;\n\t    switch(mrd->response_type) {\n\t    case Response_Filter:\n\t    case Response_Router:\n\t\tif (event->event_encoded) {\n\t\t    conversion_target_format =\n\t\t\tlocalize_format(cm, event->reference_format);\n\t\t} else {\n\t\t    conversion_target_format = event->reference_format;\n\t\t}\n\t\tbreak;\n\t    case Response_Transform:\n\t\tconversion_target_format = mrd->u.transform.reference_input_format;\n\t\tbreak;\n\t    case Response_Multityped:\n\t\tassert(FALSE);\n                break;\n\t    }\n\n\t    instance = generate_filter_code(cm, mrd, stone, conversion_target_format);\n\t    if (instance == NULL) return 0;\n\t    instance->stone = stone->local_id;\n\t    instance->proto_action_id = nearest_proto_action;\n\t    action_generated++;\n\t    switch(mrd->response_type) {\n\t    case Response_Filter:\n\t\tINT_EVassoc_mutated_imm_action(cm, stone->local_id, nearest_proto_action,\n\t\t\t\t\t       filter_wrapper, instance,\n\t\t\t\t\t       conversion_target_format, free_imm_response);\n\t\tbreak;\n\t    case Response_Router:\n\t\tINT_EVassoc_mutated_imm_action(cm, stone->local_id, nearest_proto_action,\n\t\t\t\t\t       router_wrapper, instance,\n\t\t\t\t\t       conversion_target_format, free_imm_response);\n\t\tbreak;\n\t    case Response_Transform:\n\t\tINT_EVassoc_mutated_imm_action(cm, stone->local_id, nearest_proto_action,\n\t\t\t\t\t       transform_wrapper, instance,\n\t\t\t\t\t       conversion_target_format, free_imm_response);\n\t\tbreak;\n            default:\n\t\tassert(FALSE);\n\t\tbreak;\n\t    }\n\t    return_value = 1;\n\t} else \tif (proto->action_type == Action_Multi || proto->action_type == Action_Congestion) {\n\t    response_instance instance;\n\t    struct response_spec *mrd;\n\n\t    mrd =\n\t\tproto->o.imm.mutable_response_data;\n\t    instance = generate_multityped_code(cm, mrd, stone,\n\t\t\t\t\t\t proto->matching_reference_formats);\n\t    if (instance == 0) {\n                return 0;\n            }\n\t    instance->stone = stone->local_id;\n\t    instance->proto_action_id = nearest_proto_action;\n\t    action_generated++;\n\t    INT_EVassoc_mutated_multi_action(cm, stone->local_id, nearest_proto_action,\n\t\t\t\t\t     queued_wrapper, instance,\n\t\t\t\t\t     proto->matching_reference_formats, free_multi_response);\n\t    if (mrd->u.multityped.accept_anonymous && (matching_format == NULL)) {\n\t\t/* we're accepting this as an anonymous target */\n\t\tINT_EVassoc_anon_multi_action(cm, stone->local_id, nearest_proto_action, queued_wrapper, instance,\n\t\t\t\t\t      event->reference_format);\n\t    }\n            if (event->event_encoded) {\n                conversion_target_format = matching_format;\n            }\n            return_value = 1;\n\t} else {\n\t    response_cache_element *resp;\n\n\t    conversion_target_format = NULL;\n\t    if (proto->matching_reference_formats) {\n\t\tconversion_target_format = proto->matching_reference_formats[0];\n\t    }\n\n\t    /* we'll install the conversion later, first map the response */\n\t    if (stone->response_cache_count == 0) {\n\t\tif (stone->response_cache != NULL) free(stone->response_cache);\n\t\tstone->response_cache = malloc(sizeof(stone->response_cache[0]));\n\t    } else {\n\t\tstone->response_cache =\n\t\t    realloc(stone->response_cache,\n\t\t\t    (stone->response_cache_count + 1) * sizeof(stone->response_cache[0]));\n\t    }\n\t    resp = &stone->response_cache[stone->response_cache_count++];\n\t    proto_action *proto2 = &stone->proto_actions[nearest_proto_action];\n\t    if (conversion_target_format) {\n\t\tresp->reference_format = conversion_target_format;\n\t    } else {\n\t\tresp->reference_format = event->reference_format;\n\t    }\n\t    resp->proto_action_id = nearest_proto_action;\n\t    resp->action_type = proto2->action_type;\n\t    resp->requires_decoded = (proto2->data_state == Requires_Decoded);\n            resp->stage = stage;\n\t}\n\tif (conversion_target_format != NULL) {\n\t    if (event->event_encoded) {\n\t\t/* create a decode action */\n\t\tINT_EVassoc_conversion_action(cm, stone->local_id, stage,\n\t\t\t\t\t      conversion_target_format,\n\t\t\t\t\t      event->reference_format);\n\t\treturn_value = 1;\n\t    } else {\n\t\tif (event->reference_format != conversion_target_format) {\n\t\t    /* \n\t\t     * create a decode action anyway, the event will be\n\t\t     * encoded to a buffer and then decoded into the target\n\t\t     * format.  Doing this more efficiently is difficult. \n\t\t     */\n\t\t    INT_EVassoc_conversion_action(cm, stone->local_id, stage,\n\t\t\t\t\t\t  conversion_target_format,\n\t\t\t\t\t\t  event->reference_format);\n\t\t    return_value = 1;\n\t\t} else {\n\t\t    return_value = 1;\n\t\t}\n\t    }\n\t} else {\n            return_value = 1;\n        }\n    }\n    fix_response_cache(stone);\n    return return_value;\n}\n\nvoid\nresponse_data_free(CManager cm, void *resp_void)\n{\n    struct response_spec *resp = (struct response_spec*)resp_void;\n    switch(resp->response_type) {\n    case Response_Filter:\n    case Response_Router:\n\tfree_struct_list(resp->u.filter.format_list);\n        free(resp->u.filter.function);\n\tbreak;\n    case Response_Transform:\n\tfree_struct_list(resp->u.transform.in_format_list);\n\tfree_struct_list(resp->u.transform.out_format_list);\n        free(resp->u.transform.function);\n\tbreak;\n    case Response_Multityped:\n      {\n\t  int i = 0;\n\t  while(resp->u.multityped.struct_list[i] != NULL) {\n\t      FMStructDescList list = resp->u.multityped.struct_list[i];\n\t      int j = 0;\n\t      while (list[j].format_name != NULL) {\n\t\t  free(list[j].format_name);\n\t\t  free_FMfield_list(list[j].field_list);\n\t\t  j++;\n\t      }\n\t      free(list);\n\t      i++;\n\t  }\n      }\n      free(resp->u.multityped.struct_list);\n      free(resp->u.multityped.reference_input_format_list);\n      free(resp->u.multityped.function);\n      break;\n    default:\n\tbreak;\n    }\n    free(resp);\n}\n\n#ifdef NOT_DEF\nstatic void\ncod_free_wrapper(void *data, void *free_data)\n{\n    event_item *event = (event_item *)free_data;\n    FMfree_var_rec_elements(event->reference_format,\n\t\t\t    data);\n}\n#endif\n\nextern void \nINT_EVadd_standard_routines(CManager cm, char *extern_string,\n\t\t\t    cod_extern_entry *externs)\n{\n    event_path_data evp = cm->evp;\n    int count = 0;\n    if (evp->externs == NULL) {\n\tevp->externs = malloc(sizeof(evp->externs[0]) * 2);\n    } else {\n\twhile(evp->externs[count].extern_decl != NULL) count++;\n\tevp->externs = realloc(evp->externs, \n\t\t\t       sizeof(evp->externs[0]) * (count + 2));\n    }\n    evp->externs[count].extern_decl = extern_string;\n    evp->externs[count].externs = externs;\n    evp->externs[count + 1].extern_decl = NULL;\n    evp->externs[count + 1].externs = NULL;\n}\n\nextern void \nINT_EVadd_standard_structs(CManager cm, FMStructDescList *lists)\n{\n    event_path_data evp = cm->evp;\n    int count = 0, new = 0, i;\n    \n    while (lists[new] != NULL) new++;\n\n    if (evp->extern_structs == NULL) {\n\tevp->extern_structs = malloc(sizeof(evp->extern_structs[0]) * (new+1));\n    } else {\n\twhile(evp->extern_structs[count] != NULL) count++;\n\tevp->extern_structs = realloc(evp->extern_structs, \n\t\t\t       sizeof(evp->extern_structs[0]) * (count + new + 1));\n    }\n    for (i=0; i<= new; i++) {\n\tevp->extern_structs[count + i] = lists[i];\n    }\n}\n\nstatic void\ncod_ffs_write(cod_exec_context ec, FFSFile fname,  int queue, int index)\n{\n    FMFormat ref_format, file_format;\n    struct ev_state_data * ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n    queue_item * my_item = cod_find_index(0, ev_state, queue, index);\n    FMContext fmc;\n    attr_list *temp_attr;\n    FMStructDescList format_list;\n\n    if(!my_item) {\n\tfprintf(stderr, \"No corresponding item in the queue\\n\");\n\treturn;\n    }\n\n    ref_format = my_item->item->reference_format;\n    fmc = FMContext_of_file(fname);\n\n    format_list = format_list_of_FMFormat(ref_format);\n    file_format = FMregister_data_format(fmc, format_list);\n    \n    temp_attr = &my_item->item->attrs;\n    if(!*temp_attr) {\n\tprintf(\"There is no attr for: %s\\n\", format_list->format_name);\n    }\n    \n    if(my_item->item->event_encoded) {\n\tfprintf(stderr, \"Event is encoded, have not handled this case.  Can not write to file\\n\");\n\treturn;\n    } else {\n\tvoid * temp_data = my_item->item->decoded_event;\n\tif(!write_FFSfile_attrs(fname, file_format, temp_data, *temp_attr))\n\t    fprintf(stderr, \"Error in writing FFS_file!\\n\");\n    }\n    return;\n}\n\nstatic void\ncod_ffs_read(cod_exec_context ec, FFSFile fname, void * data, attr_list * temp, int queue)\n{\n    FMFormat ref_format;\n    struct ev_state_data * ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n    FFSTypeHandle temp_type;\n    FFSContext fmc = FFSContext_of_file(fname);\n    FMStructDescList format_list;\n\n    ref_format = ev_state->instance->u.queued.formats[queue];\n    format_list = format_list_of_FMFormat(ref_format);\n    temp_type = FFSset_fixed_target(fmc, format_list);\n    (void)temp_type;\n    FFSread_attr(fname, data, temp);\n\n    return;\n}\n\n\nstatic\nint\ncod_max_output(cod_exec_context ec)\n{\n    struct ev_state_data *ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n    return ev_state->out_count;\n}\n\nstatic int\ncod_target_stone_on_port(cod_exec_context ec, int port, void *data, void *type_info, attr_list attrs)\n{\n    struct ev_state_data *ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n    EVstone target_stone = port_to_stone(ev_state, port);\n\n    if (target_stone == -1) {\n        printf(\"Port %d on stone %d invalid\\n\", port, ev_state->stone);\n\treturn -1;\n    }\n    return target_stone;\n}\n\nstruct delayed_event {\n    EVstone to_stone;\n    event_item *event;\n};\n\nextern void do_local_actions(CManager cm);\n\nstatic void\nEVdelayed_submit_func(CManager cm, void* vdelayed)\n{\n    struct delayed_event *delayed = (struct delayed_event *)vdelayed;\n    int stone_num = delayed->to_stone;\n    event_item *event = delayed->event;\n    free(delayed);\n    CManager_lock(cm);\n    internal_path_submit(cm, stone_num, event);\n    do_local_actions(cm);\n    return_event(cm->evp, event);\n    CManager_unlock(cm);\n}\n\nstatic void\ninternal_cod_submit_general(cod_exec_context ec, int port, void *data, void *type_info, attr_list attrs, struct timeval *tp)\n{\n    struct ev_state_data *ev_state = (void*)cod_get_client_data(ec, 0x34567890);\n    CManager cm = ev_state->cm;\n    event_path_data evp = ev_state->cm->evp;\n    event_item *event;\n    EVstone target_stone = port_to_stone(ev_state, port);\n\n    if (target_stone == -1) {\n        printf(\"Port %d on stone %d invalid\\n\", port, ev_state->stone);\n\treturn;\n    }\n\n    assert(CManager_locked(cm));\n    ev_state->did_output++;\n    if (ev_state->cur_event && data == ev_state->cur_event->decoded_event) {\n\tCMtrace_out(cm, EVerbose,\n\t\t    \"Internal COD submit, resubmission of current input event to stone %d\\n\",\n\t\t    target_stone);\n\tif (tp) {\n\t    /* delayed event */\n\t    struct delayed_event *ev = malloc(sizeof(struct delayed_event));\n\t    ev->to_stone = target_stone;\n\t    ev->event = ev_state->cur_event;\n\t    ev_state->cur_event->ref_count++;\n\t    INT_CMadd_delayed_task(cm, tp->tv_sec, tp->tv_usec, EVdelayed_submit_func, (void*)ev);\n\t} else {\n\t    internal_path_submit(ev_state->cm, target_stone, ev_state->cur_event);\n\t}\n    } else {\n\tFMFormat event_format = NULL;\n\tCMtrace_out(cm, EVerbose,\n\t\t    \"Internal COD submit, submission of new data to stone %d\\n\",\n\t\t    target_stone);\n\tif (event_format == NULL) {\n\t    event_format = EVregister_format_set(cm, (FMStructDescList) type_info);\n\t    if (event_format == NULL) {\n\t\tprintf(\"Bad format information on submit\\n\");\n\t\treturn;\n\t    }\n\t}\n\tevent = get_free_event(evp);\n\tevent->event_encoded = 0;\n\tevent->decoded_event = data;\n\tevent->reference_format = event_format;\n\tevent->format = NULL;\n/*\tevent->free_func = cod_free_wrapper;*/\n\tevent->free_func = NULL;\n\tevent->free_arg = event;\n\tevent->attrs = add_ref_attr_list(attrs);\n\tevent->cm = cm;\n\tcod_encode_event(cm, event);  /* map to memory we trust */\n\tevent->event_encoded = 1;\n\tevent->decoded_event = NULL;  /* lose old data */\n\tif (tp) {\n\t    /* delayed event */\n\t    struct delayed_event {\n\t\tEVstone to_stone;\n\t\tevent_item *event;\n\t    };\n\t    CMTaskHandle handle;\n\t    struct delayed_event *ev = malloc(sizeof(struct delayed_event));\n\t    ev->to_stone = target_stone;\n\t    ev->event = event;\n\t    handle = INT_CMadd_delayed_task(cm, tp->tv_sec, tp->tv_usec, EVdelayed_submit_func, (void*)ev);\n\t    free(handle);\n\t} else {\n\t    internal_path_submit(cm, target_stone, event);\n\t    return_event(cm->evp, event);\n\t}\n    }\n}\n\nstatic void\ninternal_cod_submit_attr(cod_exec_context ec, int port, void *data, void *type_info, attr_list attrs)\n{\n    internal_cod_submit_general(ec, port, data, type_info, attrs, NULL);\n}\n\nstatic void\ninternal_cod_submit(cod_exec_context ec, int port, void *data, void *type_info)\n{\n    internal_cod_submit_general(ec, port, data, type_info, NULL, NULL);\n}\n\nstatic void\nadd_standard_routines(stone_type stone, cod_parse_context context)\n{\n    static char extern_string[] = \"\\\n\t\tint printf(string format, ...);\\n\\\n\t\tvoid *malloc(int size);\\n\\\n\t\tvoid sleep(int seconds);\\n\\\n\t\tvoid free(void *pointer);\\n\\\n\t\tlong lrand48();\\n\\\n\t\tdouble drand48();\\n\\\n\t\tint EVmax_output(cod_exec_context ec);\\n\\\n\t\tint EVtarget_stone_on_port(cod_exec_context ec, int port);\\n\\\n\t\tvoid EVsubmit(cod_exec_context ec, int port, void* d, cod_type_spec dt);\\n\\\n\t\tvoid EVsubmit_attr(cod_exec_context ec, int port, void* d, cod_type_spec dt, attr_list list);\\n\\\n\t\tvoid EVsubmit_delayed(cod_exec_context ec, int port, void* d, cod_type_spec dt, attr_list list, timeval *tp);\\n\\\n        \tattr_list EVget_stone_attrs(cod_exec_context ec, char *stone_name);\\n \\\n\t\tattr_list stone_attrs;\\n\";\n\t\t//time_t time(time_t *timer);\\n\";\n\n    static cod_extern_entry externs[] = {\n\t{\"printf\", (void *) 0},\n\t{\"malloc\", (void*) 0},\n\t{\"free\", (void*) 0},\n\t{\"lrand48\", (void *) 0},\n\t{\"drand48\", (void *) 0},\n\t{\"stone_attrs\", (void *) 0},\n\t{\"EVsubmit\", (void *) 0},\n\t{\"EVsubmit_attr\", (void *) 0},\n\t{\"EVsubmit_delayed\", (void *) 0},\n\t{\"sleep\", (void*) 0},\n\t{\"EVmax_output\", (void*)0},\n\t{\"EVtarget_stone_on_port\", (void*)0},\n        {\"EVget_stone_attrs\",  (void *)0},\n\t{(void *) 0, (void *) 0}\n    };\n\n    //{\"time\", (void*) 0},\n\n    /*\n     * some compilers think it isn't a static initialization to put this\n     * in the structure above, so do it explicitly.\n     */\n    externs[0].extern_value = (void *) (long) printf;\n    externs[1].extern_value = (void *) (long) malloc;\n    externs[2].extern_value = (void *) (long) free;\n    externs[3].extern_value = (void *) (long) lrand48;\n    externs[4].extern_value = (void *) (long) drand48;\n    externs[5].extern_value = (void *) (long) &stone->stone_attrs;\n    externs[6].extern_value = (void *) (long) &internal_cod_submit;\n    externs[7].extern_value = (void *) (long) &internal_cod_submit_attr;\n    externs[8].extern_value = (void *) (long) &internal_cod_submit_general;\n    externs[9].extern_value = (void *) (long) &sleep;\n    externs[10].extern_value = (void *) (long) &cod_max_output;\n    externs[11].extern_value = (void *) (long) &cod_target_stone_on_port;\n    externs[12].extern_value = (void *) (long) &cod_ev_get_stone_attrs;\n\n    cod_assoc_externs(context, externs);\n    cod_parse_for_context(extern_string, context);\n}\n\nstatic void\nadd_typed_queued_routines(cod_parse_context context, int index, const char *fmt_name)\n{\n    char *extern_string;\n    char *data_extern_string;\n    static char *extern_string_fmt =\n        \"void EVdiscard_%s(cod_exec_context ec, cod_closure_context type, int index);\\n\"\n        \"int EVcount_%s(cod_exec_context ec, cod_closure_context type);\\n\"\n        \"int EVpresent_%s(cod_exec_context ec, cod_closure_context queue, int index);\\n\"\n        \"void EVdiscard_and_submit_%s(cod_exec_context ec, int target, cod_closure_context queue, int index);\\n\"\n        \"void EVsubmit_%s(cod_exec_context ec, int target, cod_closure_context queue, int index);\\n\"\n        \"attr_list EVget_attrs_%s(cod_exec_context ec, cod_closure_context queue, int index);\\n\"\n\t\"void write_%s(cod_exec_context ec, ffs_file fname, cod_closure_context type, int index);\\n\"\n\t\"void read_%s(cod_exec_context ec, ffs_file fname, void * data, attr_list * attr_data, cod_closure_context queue);\\n\";\n    static char *data_extern_string_fmt =\n        \"%s *EVdata_%s(cod_exec_context ec, cod_closure_context type, int index);\\n\"\n        \"%s *EVdata_full_%s(cod_exec_context ec, cod_closure_context type, int index);\\n\";\n    static cod_extern_entry externs_fmt[] = {\n        {\"EVdiscard_%s\", (void *) 0},\n        {\"EVcount_%s\", (void *) 0},\n        {\"EVpresent_%s\", (void *) 0},\n        {\"EVdiscard_and_submit_%s\", (void *) 0},\n        {\"EVget_attrs_%s\", (void *) 0},\n        {\"EVsubmit_%s\", (void *) 0},\n\t{\"write_%s\", (void *) 0},\n\t{\"read_%s\", (void *) 0},\n        {NULL, (void *) 0}\n    };\n    static cod_extern_entry data_externs_fmt[] = {\n        {\"EVdata_%s\", (void *) 0},\n        {\"EVdata_full_%s\", (void *) 0},\n        {NULL, (void *) 0}\n    };\n    cod_extern_entry *cur;\n    cod_extern_entry *externs;\n    cod_extern_entry *data_externs;\n\n    extern_string = malloc(strlen(fmt_name) * 9 + strlen(extern_string_fmt));\n    assert(extern_string);\n    data_extern_string = malloc(strlen(fmt_name) * 9 + strlen(data_extern_string_fmt));\n\n    sprintf(extern_string, extern_string_fmt,\n\t    fmt_name, fmt_name, fmt_name, fmt_name,\n\t    fmt_name, fmt_name, fmt_name, fmt_name);\n    sprintf(data_extern_string, data_extern_string_fmt,\n\t    fmt_name, fmt_name, fmt_name, fmt_name);\n    externs = malloc(sizeof(externs_fmt));\n    assert(externs);\n    memcpy(externs, externs_fmt, sizeof(externs_fmt));\n    externs[0].extern_value = (void*) cod_ev_discard_rel;\n    externs[1].extern_value = (void*) cod_ev_count;\n    externs[2].extern_value = (void*) cod_ev_present;\n    externs[3].extern_value = (void*) cod_ev_discard_and_submit_rel;\n    externs[4].extern_value = (void*) cod_ev_get_attrs;\n    externs[5].extern_value = (void*) cod_ev_submit_rel;\n    externs[6].extern_value = (void*) cod_ffs_write;\n    externs[7].extern_value = (void*) cod_ffs_read;\n\n    data_externs = malloc(sizeof(externs_fmt));\n    assert(data_externs);\n    memcpy(data_externs, data_externs_fmt, sizeof(data_externs_fmt));\n    data_externs[0].extern_value = (void*) cod_ev_get_data_rel;\n    data_externs[1].extern_value = (void*) cod_ev_get_data_abs;\n\n    for (cur = externs; cur->extern_name; ++cur) {\n        char *real_name = malloc(strlen(cur->extern_name) + strlen(fmt_name));\n        assert(real_name);\n        sprintf(real_name, cur->extern_name, fmt_name);\n        cur->extern_name = real_name;\n    }\n\n    cod_assoc_externs(context, externs);\n    cod_parse_for_context(extern_string, context);\n    for (cur = externs; cur->extern_name; ++cur) {\n\t/* \n\t * the index here is the index of the queue itself, \n\t * while the index in the calls above is the index of the referenced queue item \n\t */\n\tcod_set_closure(cur->extern_name, (void*)(long)index, context);\n        free(cur->extern_name);\n    }\n    free(externs);\n    free(extern_string);\n\n    if (index >= 0) {\n\tfor (cur = data_externs; cur->extern_name; ++cur) {\n\t    char *real_name = malloc(strlen(cur->extern_name) + strlen(fmt_name));\n\t    assert(real_name);\n\t    sprintf(real_name, cur->extern_name, fmt_name);\n\t    cur->extern_name = real_name;\n\t}\n\tcod_assoc_externs(context, data_externs);\n\tcod_parse_for_context(data_extern_string, context);\n\tfor (cur = data_externs; cur->extern_name; ++cur) {\n\t    /* \n\t     * the index here is the index of the queue itself, \n\t     * while the index in the calls above is the index of the referenced queue item \n\t     */\n\t    cod_set_closure(cur->extern_name, (void*)(long)index, context);\n\t    free(cur->extern_name);\n\t}\n    }\n    free(data_externs);\n    free(data_extern_string);\n}\n\nstatic void\nadd_queued_routines(cod_parse_context context, FMFormat *formats)\n{\n    static char extern_string[] = \"\\\n        int EVconforms(cod_exec_context ec, int queue, int index);\\n\\\n        void EVdiscard(cod_exec_context ec, int queue, int index);\\n\\\n        void EVdiscard_full(cod_exec_context ec, cod_closure_context queue, int index);\\n\\\n        void EVdiscard_and_submit(cod_exec_context ec, int target,\\\n                    int queue, int index);\\n\\\n        void EVdiscard_and_submit_full(cod_exec_context ec, int target,\\\n                    cod_closure_context queue, int index);\\n\t\t\t       \\\n        void *EVdata(cod_exec_context ec, int queue, int index);\\n\\\n        void *EVdata_full(cod_exec_context ec, cod_closure_context queue, int index);\\n\\\n        int EVcount(cod_exec_context ec, int queue);\\n\\\n        int EVcount_full(cod_exec_context ec, cod_closure_context type);\\n\\\n        int EVpresent(cod_exec_context ec, int queue, int index);\\n\\\n\tint EVget_port(cod_exec_context ec, int queue);\\n\\\n    \tint EVtarget_size(cod_exec_context ec, int outstone);\\n\\\n        attr_list EVget_attrs(cod_exec_context ec, int queue, int index);\\n\t\\\n        attr_list EVget_attrs_full(cod_exec_context ec, cod_closure_context queue, int index);\\n\\\n\";\n\n    static cod_extern_entry externs[] = {\n        {\"EVconforms\", (void *)0},  //0 \n        {\"EVdiscard\", (void *)0},  //1 \n        {\"EVdiscard_full\",  (void *)0},  //2 \n        {\"EVdiscard_and_submit\", (void *)0},  //3 \n        {\"EVdiscard_and_submit_full\", (void *)0},  //4 \n        {\"EVdata\", (void *)0},  //5 \n        {\"EVdata_full\", (void *)0},  //6 \n        {\"EVcount\", (void *)0},  //7 \n        {\"EVcount_full\", (void *)0},  //8 \n        {\"EVpresent\", (void *)0},  //9 \n        {\"EVget_port\", (void *)0},  //10 \n        {\"EVtarget_size\", (void *)0},  //11 \n        {\"EVget_attrs\", (void *)0},  //12 \n        {\"EVget_attrs_full\",  (void *)0},  //13 \n        {(void *)0, (void *)0}\n    };\n    int i;\n    FMFormat *cur;\n\n    externs[0].extern_value = (void*)cod_ev_conforms;\n    externs[1].extern_value = (void*)cod_ev_discard_rel;\n    externs[2].extern_value = (void*)cod_ev_discard_rel;\n    externs[3].extern_value = (void*)cod_ev_discard_and_submit_rel;\n    externs[4].extern_value = (void*)cod_ev_discard_and_submit_rel;\n    externs[5].extern_value = (void*)cod_ev_get_data_rel;\n    externs[6].extern_value = (void*)cod_ev_get_data_rel;\n    externs[7].extern_value = (void*)cod_ev_count;\n    externs[8].extern_value = (void*)cod_ev_count;\n    externs[9].extern_value = (void*)cod_ev_present;\n    externs[10].extern_value = (void*)cod_ev_get_port;\n    externs[11].extern_value = (void*)cod_ev_target_size;\n    externs[12].extern_value = (void*)cod_ev_get_attrs;\n    externs[13].extern_value = (void*)cod_ev_get_attrs;\n\n    cod_assoc_externs(context, externs);\n    cod_parse_for_context(extern_string, context);\n    cod_set_closure(\"EVdiscard_full\", (void*)(long)-1, context);\n    cod_set_closure(\"EVdiscard_and_submit_full\", (void*)(long)-1, context);\n    cod_set_closure(\"EVget_attrs_full\", (void*)(long)-1, context);\n    cod_set_closure(\"EVdata_full\", (void*)(long)-1, context);\n    cod_set_closure(\"EVcount_full\", (void*)(long)-1, context);\n\n    for (cur = formats, i = 0; *cur; ++cur, ++i) {\n        add_typed_queued_routines(context, i, name_of_FMformat(*cur));\n    }\n    add_typed_queued_routines(context, -2, \"anonymous\");\n}\n\nstatic void\nadd_queued_constants(cod_parse_context context, FMFormat *formats)\n{\n    FMFormat *cur_format;\n    int i = 0;\n    for (cur_format = formats; *cur_format; ++cur_format, ++i) {\n        const char *fmt_name = name_of_FMformat(*cur_format);\n        char *name = malloc(4 + strlen(fmt_name));\n        sprintf(name, \"%s_ID\", fmt_name);\n        cod_add_int_constant_to_parse_context(name, i, context);\n\tfree(name);\n    }\n}\n\n\nextern sm_ref\ncod_build_type_node(const char *name, FMFieldList field_list);\nextern sm_ref\ncod_build_param_node(const char *id, sm_ref typ, int param_num);\nextern void\ncod_add_decl_to_parse_context(const char *name, sm_ref item, cod_parse_context context);\nextern void\ncod_add_param(const char *id, const char *typ, int param_num,\n\t      cod_parse_context context);\n\nstatic void\nadd_param(cod_parse_context parse_context, char *name, int param_num,\n\t  FMFormat format)\n{\n    FMStructDescList list = format_list_of_FMFormat(format);\n    int i = 1;\n    sm_ref type, param;\n    while (list[i].format_name != NULL) {\n\tFMFieldList fl = list[i].field_list;\n\t/* step through input formats */\n\tcod_add_simple_struct_type(list[i].format_name, fl, parse_context);\n\ti++;\n    }\n    type = cod_build_type_node(list[0].format_name, list[0].field_list);\n    cod_add_decl_to_parse_context(list[0].format_name, type, parse_context);\n\n    param = cod_build_param_node(name, type, param_num);\n\n    cod_add_decl_to_parse_context(name, param, parse_context);\n}\n\nstatic void\nadd_type(cod_parse_context parse_context, FMFormat format)\n{\n    FMStructDescList list = format_list_of_FMFormat(format);\n    for (; list->format_name; ++list) {\n\tcod_add_simple_struct_type(list->format_name, list->field_list, parse_context);\n    }\n}\n\n#if 0\nstatic void\nadd_param_list(cod_parse_context parse_context, char *name, int param_num,\n\t  FMStructDescList list)\n{\n    char *tname = malloc(strlen(name) + strlen(\"_type\") +1);\n    sm_ref type, param;\n    int i = 0;\n    while (list[i].format_name != NULL) {\n\tsm_ref typ;\n\t/* step through input formats */\n\ttyp = cod_build_type_node(list[i].format_name,\n\t\t\t\t  list[i].field_list);\n\tcod_add_decl_to_parse_context(list[i].format_name, typ,\n\t\t\t\t      parse_context);\n\ti++;\n    }\n    sprintf(tname, \"%s_type\", name);\n    type = cod_build_type_node(tname, list[i-1].field_list);\n    cod_add_decl_to_parse_context(tname, type, parse_context);\n\n    param = cod_build_param_node(name, type, 0);\n\n    cod_add_decl_to_parse_context(name, param, parse_context);\n}\n#endif\n\nstatic int\ndll_prefix_present(char *filter)\n{\n\n    if (filter[0] == 'd' && filter[1] == 'l' && filter[2] == 'l' && filter[3] == ':') {\n\treturn 1;\n    }\n    return 0;\n}\n\nstatic char *\nextract_dll_path(char *filter)\n{\n    char *copy = strdup(filter);\n    char *temp;\n    char *path;\n\n\n    temp = strtok(copy, \":\");\n    if (strcmp(temp, \"dll\")) {\n\tfree(copy);\n\treturn NULL;\n    }\n    temp = strtok(NULL, \":\");\n\n    if (temp == NULL) {\n\tfree(copy);\n\treturn NULL;\n    }\n\n    path = strdup(temp);\n    free(copy);\n\n    return path;\n}\n\nstatic char *\nextract_symbol_name(char *filter)\n{\n\n    char *copy = strdup(filter);\n    char *temp;\n    char *symbol;\n\n    temp = strtok(copy, \":\");\n    if (strcmp(temp, \"dll\")) {\n\tfree(copy);\n\treturn NULL;\n    }\n    temp = strtok(NULL, \":\");\n    temp = strtok(NULL, \":\");\n\n    if (temp == NULL) {\n\tfree(copy);\n\treturn NULL;\n    }\n\n    symbol = strdup(temp);\n    free(copy);\n\n    return symbol;\n}\n\nstatic void*\nload_dll_symbol(CManager cm, char *path, char *symbol_name)\n{\n    lt_dlhandle handle;\n\n    handle = CMdlopen(cm->CMTrace_file, path, 0);\n    if (!handle) {\n    \tfprintf(stderr, \"failed opening %s\\n\", path);\n\t    return NULL;\n    }\n    return lt_dlsym(handle, symbol_name);\n}\n\nextern void\nadd_metrics_routines(stone_type stone, cod_parse_context context);\n\nstatic response_instance\ngenerate_filter_code(CManager cm, struct response_spec *mrd, stone_type stone,\n\t\t     FMFormat format)\n{\n    response_instance instance = malloc(sizeof(*instance));\n\n    cod_code code;\n    cod_parse_context parse_context = new_cod_parse_context();\n    /*    sm_ref conn_info_data_type, conn_info_param;*/\n\n    memset(instance, 0, sizeof(*instance));\n    add_standard_routines(stone, parse_context);\n    add_metrics_routines(stone, parse_context);\n    if (cm->evp->extern_structs) {\n\tint count = -1;\n\twhile(cm->evp->extern_structs[++count] != NULL) {\n\t    cod_add_struct_type(cm->evp->extern_structs[count], parse_context);\n\t}\n    }\n\t\n    if (cm->evp->externs) {\n\tint count = -1;\n\twhile (cm->evp->externs[++count].extern_decl != NULL) {\n\t    cod_assoc_externs(parse_context, cm->evp->externs[count].externs);\n\t    cod_parse_for_context(cm->evp->externs[count].extern_decl, \n\t\t\t\t  parse_context);\n\t}\n    }\n\n    switch (mrd->response_type) {\n    case Response_Filter:\n    case Response_Router:\n    case Response_Transform:\n\tcod_add_param(\"ec\", \"cod_exec_context\", 0, parse_context);\n\tif (format) {\n\t    add_param(parse_context, \"input\", 1, format);\n\t} else {\n\t    cod_add_param(\"input\", \"int\", 1, parse_context);\n\t}\n\tif (mrd->response_type == Response_Transform) {\n\t    add_param(parse_context, \"output\", 2,\n\t\t      mrd->u.transform.reference_output_format);\n\t    cod_add_param(\"event_attrs\", \"attr_list\", 3, parse_context);\n\t    cod_add_param(\"output_attrs\", \"attr_list\", 4, parse_context);\n\t} else {\n\t    cod_add_param(\"event_attrs\", \"attr_list\", 2, parse_context);\n\t}\n\tbreak;\n    case Response_Multityped:\n        /* this should call generate_multityped_code() */\n        assert(FALSE);\n\tbreak;\n    }\n\n/*    conn_info_data_type = cod_build_type_node(\"output_conn_info_type\",\n\t\t\t\t\t      output_conn_field_list);\n    cod_add_decl_to_parse_context(\"output_conn_info_type\",\n\t\t\t\t  conn_info_data_type, parse_context);\n    conn_info_param = cod_build_param_node(\"output_conn_info\",\n\t\t\t\t\t   conn_info_data_type, 3);\n    cod_add_decl_to_parse_context(\"output_conn_info\", conn_info_param,\n\t\t\t\t  parse_context);\n*/\n    switch(mrd->response_type) {\n    case Response_Filter:\n    case Response_Router:\n\tif (dll_prefix_present(mrd->u.filter.function)) {\n\t    /* it is a dll */\n\t    char *path = NULL;\n\t    char *symbol_name = NULL;\n\n\t    path = extract_dll_path(mrd->u.filter.function);\n\t    symbol_name = extract_symbol_name(mrd->u.filter.function);\n\t    if (!path || !symbol_name) {\n\t\tfprintf(stderr, \"could not parse string \\\"%s\\\" for dll path and symbol information\\n\", mrd->u.filter.function);\n\t\tfree(instance);\n\t\treturn NULL;\n\t    }\n\t    instance->u.filter.func_ptr = (int(*)(void*,attr_list)) load_dll_symbol(cm, path, symbol_name);\n\t    if (instance->u.filter.func_ptr == NULL) {\n\t\tfprintf(stderr, \"Failed to load symbol \\\"%s\\\" from file \\\"%s\\\"\\n\",\n\t\t\tsymbol_name, path);\n\t\tfree(instance);\n\t\tfree(path);\n\t\tfree(symbol_name);\n\t\treturn NULL;\n\t    }\n\t    free(symbol_name);\n\t    free(path);\n\t    instance->u.filter.code = NULL;\n\t} else {\n\t    code = cod_code_gen(mrd->u.filter.function, parse_context);\n\t    instance->response_type = mrd->response_type;\n\t    instance->u.filter.code = code;\n\t    if (code)\n\t\tinstance->u.filter.ec = cod_create_exec_context(code);\n\n\t    instance->u.filter.func_ptr = NULL;\n\t}\n\tbreak;\n    case Response_Transform:\n\tif (dll_prefix_present(mrd->u.transform.function)) {\n\t    /* it is a dll */\n\t    char *path = NULL;\n\t    char *symbol_name = NULL;\n\n\t    path = extract_dll_path(mrd->u.transform.function);\n\t    symbol_name = extract_symbol_name(mrd->u.transform.function);\n\t    if (!path || !symbol_name) {\n\t\tfprintf(stderr, \"could not parse string \\\"%s\\\" for dll path and symbol information\\n\", mrd->u.transform.function);\n\t\tfree(instance);\n\t\treturn NULL;\n\t    }\n\t    instance->u.transform.func_ptr =\n\t\t(int(*)(void*,void*,attr_list,attr_list)) load_dll_symbol(cm, path, symbol_name);\n\t    if (instance->u.transform.func_ptr == NULL) {\n\t\tfprintf(stderr, \"Failed to load symbol \\\"%s\\\" from file \\\"%s\\\"\\n\",\n\t\t\tsymbol_name, path);\n\t\tfree(instance);\n\t\tfree(path);\n\t\tfree(symbol_name);\n\t\treturn NULL;\n\t    }\n\t    instance->u.transform.code = NULL;\n\t    free(path);\n\t    free(symbol_name);\n\t} else {\n\t    code = cod_code_gen(mrd->u.transform.function, parse_context);\n\t    instance->response_type = Response_Transform;\n\t    instance->u.transform.code = code;\n\t    if (code)\n\t\tinstance->u.transform.ec = cod_create_exec_context(code);\n\t}\n\tinstance->u.transform.out_size =\n\t    mrd->u.transform.output_base_struct_size;\n\tinstance->u.transform.out_format =\n\t    mrd->u.transform.reference_output_format;\n\tbreak;\n    case Response_Multityped:\n\tbreak;\n    }\n    cod_free_parse_context(parse_context);\n\n    return instance;\n}\n\n#ifdef NOT_DEF\nstatic int\nverify_multityped_code(CManager cm, struct response_spec *mrd, stone_type stone,\n\t\t\t FMFormat *formats)\n{\n    FMFormat *cur_format;\n    int ret;\n\n/*    cod_code code;*/\n    cod_parse_context parse_context = new_cod_parse_context();\n    /*    sm_ref conn_info_data_type, conn_info_param;*/\n\n    for (cur_format = formats; *cur_format; ++cur_format) {\n        add_type(parse_context, *cur_format);\n    }\n\n    add_standard_routines(stone, parse_context);\n    add_metrics_routines(stone, parse_context);\n    add_queued_routines(parse_context, formats);\n    add_queued_constants(parse_context, formats);\n    if (cm->evp->extern_structs) {\n\tint count = -1;\n\twhile(cm->evp->extern_structs[++count] != NULL) {\n\t    cod_add_struct_type(cm->evp->extern_structs[count], parse_context);\n\t}\n    }\n\t\n    if (cm->evp->externs) {\n\tint count = -1;\n\twhile (cm->evp->externs[++count].extern_decl != NULL) {\n\t    cod_assoc_externs(parse_context, cm->evp->externs[count].externs);\n\t    cod_parse_for_context(cm->evp->externs[count].extern_decl, \n\t\t\t\t  parse_context);\n\t}\n    }\n\n\n\n    assert(mrd->response_type == Response_Multityped);\n    cod_add_param(\"ec\", \"cod_exec_context\", 0, parse_context);\n    ret = cod_code_verify(mrd->u.multityped.function, parse_context);\n    return ret;\n}\n#endif\n\nstatic response_instance\ngenerate_multityped_code(CManager cm, struct response_spec *mrd, stone_type stone,\n\t\t\t FMFormat *formats)\n{\n    response_instance instance = malloc(sizeof(*instance));\n    FMFormat *cur_format;\n    int format_count = 0;\n\n    cod_code code;\n    cod_parse_context parse_context = new_cod_parse_context();\n    /*    sm_ref conn_info_data_type, conn_info_param;*/\n\n    memset(instance, 0, sizeof(*instance));\n\n    for (cur_format = formats; *cur_format; ++cur_format) {\n\tadd_type(parse_context, *cur_format);\n\tformat_count++;\n    }\n\n    add_standard_routines(stone, parse_context);\n    add_metrics_routines(stone, parse_context);\n    add_queued_routines(parse_context, formats);\n    add_queued_constants(parse_context, formats);\n    if (cm->evp->extern_structs) {\n\tint count = -1;\n\twhile(cm->evp->extern_structs[++count] != NULL) {\n\t    cod_add_struct_type(cm->evp->extern_structs[count], parse_context);\n\t}\n    }\n\t\n    if (cm->evp->externs) {\n\tint count = -1;\n\twhile (cm->evp->externs[++count].extern_decl != NULL) {\n\t    cod_assoc_externs(parse_context, cm->evp->externs[count].externs);\n\t    cod_parse_for_context(cm->evp->externs[count].extern_decl, \n\t\t\t\t  parse_context);\n\t}\n    }\n\n\n\n    assert(mrd->response_type == Response_Multityped);\n    cod_add_param(\"ec\", \"cod_exec_context\", 0, parse_context);\n/*    if (format) {\n\tadd_param(parse_context, \"input\", 1, format);\n    } else {\n\tcod_add_param(\"input\", \"int\", 1, parse_context);\n\t}*/\n    cod_set_return_type(\"void\", parse_context);\n    code = cod_code_gen(mrd->u.multityped.function, parse_context);\n    instance->response_type = mrd->response_type;\n    instance->u.queued.ref_count = format_count;\n    instance->u.queued.formats = formats;\n    instance->u.queued.code = code;\n    if (code)\n\tinstance->u.queued.ec = cod_create_exec_context(code);\n\n    cod_free_parse_context(parse_context);\n\n    if (!instance->u.queued.ec) {\n        free(instance);\n        return NULL;\n    }\n\n    return instance;\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/doc/cm.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/doc/struct.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/doc/func1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/doc/net.gif",
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/doc/overlay.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-libevpath-4.4.0-vby4sozyqzactpymx5kqydqskjbd4qe4/spack-src/doc/overlay.jpg"
    ],
    "total_files": 190
}