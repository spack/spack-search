{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libkcapi-1.1.5-hc23ghslhekkflmo3fdusx7cdwctulnc/spack-src/apps/kcapi-hasher.c": "/*\n * Copyright (C) 2015 - 2019, Stephan Mueller <smueller@chronox.de>\n * Copyright (C) 2019, Red Hat, Inc. All rights reserved.\n *\n * License: see LICENSE file in root directory\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF\n * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT\n * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n */\n\n/*\n * Program implements a drop-in replacement (i.e. mostly the same output,\n * behavior and command line switches) for:\n *\t* sha1sum\n *\t* sha224sum\n *\t* sha256sum\n *\t* sha384sum\n *\t* sha512sum\n *\t* md5sum\n *\t* fipscheck with hard coded key from libfipscheck\n *\t* fipshmac with hard coded key from libfipscheck\n *\t* sha1hmac\n *\t* sha224hmac\n *\t* sha256hmac\n *\t* sha384hmac\n *\t* sha512hmac\n *\n * Once the application is compiled, a symlink or hardlink to the\n * aforementioned application would turn the binary into behaving like the\n * respective application.\n */\n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <errno.h>\n#include <ctype.h>\n#include <dlfcn.h>\n#include <libgen.h>\n#include <limits.h>\n\n#include <kcapi.h>\n\n#include \"app-internal.h\"\n\n#define GCC_VERSION (__GNUC__ * 10000 \\\n\t\t\t+ __GNUC_MINOR__ * 100 \\\n\t\t\t+ __GNUC_PATCHLEVEL__)\n\nstruct hash_name {\n\tconst char *kcapiname;\n\tconst char *bsdname;\n};\n\nstruct hash_key {\n\tconst char *checkdir;\n\tconst uint8_t *data;\n\tuint32_t len;\n};\n\nstruct hash_params {\n\tstruct hash_name name;\n\tstruct hash_key key;\n\tuint32_t hashlen;\n\tint bsd_style;\n};\n\nstatic const struct hash_name NAMES_MD5[2] = {\n\t{ \"md5\", \"MD5\" }, { \"hmac(md5)\", \"HMAC(MD5)\" }\n};\nstatic const struct hash_name NAMES_SHA1[2] = {\n\t{ \"sha1\", \"SHA1\" }, { \"hmac(sha1)\", \"HMAC(SHA1)\" }\n};\nstatic const struct hash_name NAMES_SHA224[2] = {\n\t{ \"sha224\", \"SHA224\" }, { \"hmac(sha224)\", \"HMAC(SHA224)\" }\n};\nstatic const struct hash_name NAMES_SHA256[2] = {\n\t{ \"sha256\", \"SHA256\" }, { \"hmac(sha256)\", \"HMAC(SHA256)\" }\n};\nstatic const struct hash_name NAMES_SHA384[2] = {\n\t{ \"sha384\", \"SHA384\" }, { \"hmac(sha384)\", \"HMAC(SHA384)\" }\n};\nstatic const struct hash_name NAMES_SHA512[2] = {\n\t{ \"sha512\", \"SHA512\" }, { \"hmac(sha512)\", \"HMAC(SHA512)\" }\n};\n\nstatic const char fipscheck_hmackey[] = \"orboDeJITITejsirpADONivirpUkvarP\";\nstatic const char hmaccalc_hmackey[] = \"FIPS-FTW-RHT2009\";\n\nstatic const struct hash_key KEY_FIPSCHECK = {\n\t.data = (const uint8_t *)fipscheck_hmackey,\n\t.len = sizeof(fipscheck_hmackey) - 1,\n#ifdef CHECK_DIR\n\t.checkdir = CHECK_DIR\"/fipscheck\",\n#else\n\t.checkdir = NULL,\n#endif\n};\nstatic const struct hash_key KEY_HMACCALC = {\n\t.data = (const uint8_t *)hmaccalc_hmackey,\n\t.len = sizeof(hmaccalc_hmackey) - 1,\n#ifdef CHECK_DIR\n\t.checkdir = CHECK_DIR\"/hmaccalc\",\n#else\n\t.checkdir = NULL,\n#endif\n};\n\nstatic void usage(char *name, int fipscheck)\n{\n\tconst char *base = basename(name);\n\tfprintf(stderr, \"\\n%s - calculation of hash sum (Using Linux Kernel Crypto API)\\n\", basename(name));\n\tfprintf(stderr, \"\\nUsage:\\n\");\n\tfprintf(stderr, \"\\t%s [-n BASENAME] [OPTION]... -S|-L\\n\", base);\n\tif (fipscheck)\n\t\tfprintf(stderr, \"\\t%s [-n BASENAME] [OPTION]... FILE\\n\", base);\n\telse {\n\t\tfprintf(stderr, \"\\t%s [-n BASENAME] [OPTION]... -c FILE\\n\", base);\n\t\tfprintf(stderr, \"\\t%s [-n BASENAME] [OPTION]... FILE...\\n\", base);\n\t}\n\tfprintf(stderr, \"\\nOptions:\\n\");\n\tfprintf(stderr, \"\\t-n --name\\t\\tForce given application name (sha512hmac/...)\\n\");\n\tfprintf(stderr, \"\\t-S --self-sum\\t\\tPrint checksum of this binary and exit\\n\");\n\tfprintf(stderr, \"\\t-L --self-sum-lib\\tPrint checksum of the libkcapi library and exit\\n\");\n\tif (!fipscheck)\n\t\tfprintf(stderr, \"\\t-c --check FILE\\t\\tVerify hash sums from file\\n\");\n\tfprintf(stderr, \"\\t-u --unkeyed\\t\\tForce unkeyed hash\\n\");\n\tfprintf(stderr, \"\\t-h --hash HASH\\t\\tUse given hash algorithm\\n\");\n\tfprintf(stderr, \"\\t-t --truncate N\\t\\tUse hash truncated to N bits\\n\");\n\tfprintf(stderr, \"\\t-q --status\\t\\tSuppress verification output\\n\");\n\tfprintf(stderr, \"\\t   --quiet\\t\\tSuppress only success messages\\n\");\n\tfprintf(stderr, \"\\t-k --key-file FILE\\tUse HMAC key from given file\\n\");\n\tfprintf(stderr, \"\\t-K --key KEY\\t\\tUse KEY as the HMAC key\\n\");\n\tfprintf(stderr, \"\\t   --tag\\t\\tCreate a BSD-style checksum\\n\");\n\tfprintf(stderr, \"\\t-d\\t\\t\\tCheck directory for fipshmac; otherwise ignored\\n\");\n\tfprintf(stderr, \"\\t-b, -P\\t\\t\\tCompatibility hmaccalc options; ignored\\n\");\n\tfprintf(stderr, \"\\t   --help\\t\\tPrint this help text\\n\");\n\tfprintf(stderr, \"\\t-v --version\\t\\tShow version\\n\");\n}\n\nstatic void version(char *name)\n{\n\tchar version[20];\n\n\tmemset(version, 0, 20);\n\tkcapi_versionstring(version, 20);\n\t\n\tfprintf(stderr, \"%s: %s\\n\", basename(name), version);\n}\n\nstatic int mmap_file(const char *filename, uint8_t **memory, uint32_t *size)\n{\n\tint fd = -1;\n\tint ret = 0;\n\tstruct stat sb;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Cannot open file %s: %s\\n\", filename,\n\t\t        strerror(errno));\n\t\treturn -EIO;\n\t}\n\n\tret = check_filetype(fd, &sb, filename);\n\tif (ret)\n\t\tgoto out;\n\n\t*memory = NULL;\n\t*size = sb.st_size;\n\n\tif (sb.st_size) {\n\t\t*memory = mmap(NULL, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);\n\t\tif (*memory == MAP_FAILED)\n\t\t{\n\t\t\t*memory = NULL;\n\t\t\tfprintf(stderr, \"Use of mmap failed\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tclose(fd);\n\treturn ret;\n}\n\nstatic int load_file(const char *filename, uint8_t **memory, uint32_t *size)\n{\n\tint fd = -1;\n\tint ret = 0;\n\tuint8_t *buffer = NULL;\n\tuint32_t buffer_size = 4096;\n\tsize_t offset = 0;\n\tssize_t rdbytes;\n\n\tfd = open(filename, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Cannot open file %s: %s\\n\", filename,\n\t\t        strerror(errno));\n\t\treturn -EIO;\n\t}\n\n\tbuffer = malloc(TMPBUFLEN);\n\tif (buffer == NULL) {\n\t\tfprintf(stderr, \"Key memory allocation failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twhile ((rdbytes = read(fd, buffer + offset, buffer_size - offset)) != 0) {\n\t\tif (rdbytes < 0) {\n\t\t\tfprintf(stderr, \"Error reading file %s: %s\\n\", filename,\n\t\t\t        strerror(errno));\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += (size_t)rdbytes;\n\t\tif (offset == buffer_size) {\n\t\t\tuint8_t *new_buffer;\n\n\t\t\tif (buffer_size == UINT32_MAX) {\n\t\t\t\tfprintf(stderr, \"Key longer than UINT32_MAX\\n\");\n\t\t\t\tret = -ERANGE;\n\t\t\t\tgoto out;\n\t\t\t} else if (buffer_size * 2 < buffer_size)\n\t\t\t\tbuffer_size = UINT32_MAX;\n\t\t\telse\n\t\t\t\tbuffer_size *= 2;\n\n\t\t\tnew_buffer = realloc(buffer, buffer_size);\n\t\t\tif (new_buffer == NULL) {\n\t\t\t\tfprintf(stderr, \"Key memory allocation failed\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbuffer = new_buffer;\n\t\t}\n\t}\n\n\t*memory = buffer;\n\t*size = (uint32_t)offset;\n\n\tclose(fd);\n\treturn 0;\n\nout:\n\tif (buffer)\n\t\tfree(buffer);\n\tclose(fd);\n\treturn ret;\n}\n\nstatic int hasher(struct kcapi_handle *handle, const struct hash_params *params,\n\t\t  const char *filename, const char *comphash, uint32_t comphashlen,\n\t\t  FILE *outfile)\n{\t\n\tint ret = 0;\n\tuint8_t *memblock = NULL;\n\tuint8_t *memblock_p;\n\tuint32_t size, left, hashlen = params->hashlen;\n\tuint8_t md[64];\n\n\tif (filename) {\n\t\tret = mmap_file(filename, &memblock, &size);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/* Compute hash */\n\t\tmemblock_p = memblock;\n\t\tleft = size;\n\t\twhile (left) {\n\t\t\tuint32_t todo = (left > INT_MAX) ? INT_MAX : left;\n\n\t\t\tret = kcapi_md_update(handle, memblock_p, todo);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tleft -= todo;\n\t\t\tmemblock_p += todo;\n\t\t}\n\t} else {\n\t\tuint8_t tmpbuf[TMPBUFLEN] __aligned(KCAPI_APP_ALIGN);\n\t\tsize_t bufsize;\n\n\t\twhile ((bufsize =\n\t\t\tfread(tmpbuf, sizeof(uint8_t), TMPBUFLEN, stdin))) {\n\n\t\t\tret = kcapi_md_update(handle, tmpbuf, bufsize);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tkcapi_memset_secure(tmpbuf, 0, sizeof(tmpbuf));\n\t}\n\n\tret = kcapi_md_final(handle, md, sizeof(md));\n\n\tif (ret > 0) {\n\t\tif (hashlen > (uint32_t)ret) {\n\t\t\tfprintf(stderr, \"Invalid truncated hash size: %lu > %i\\n\",\n\t\t\t        (unsigned long)hashlen, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!hashlen)\n\t\t\thashlen = (uint32_t)ret;\n\n\t\tif (comphash && comphashlen) {\n\t\t\tuint8_t compmd[64];\n\n\t\t\tmemset(compmd, 0, sizeof(compmd));\n\t\t\thex2bin(comphash, comphashlen, compmd, sizeof(compmd));\n\t\t\tif ((comphashlen != hashlen * 2) ||\n\t\t\t    memcmp(compmd, md, hashlen))\n\t\t\t\tret = 1;\n\t\t\telse\n\t\t\t\tret = 0;\n\t\t} else {\n\t\t\tif (outfile == NULL) { /* only print hash (hmaccalc -S) */\n\t\t\t\tbin2print(md, hashlen, NULL, stdout, 1);\n\t\t\t} else if (params->bsd_style) {\n\t\t\t\tfprintf(outfile, \"%s (%s) = \", params->name.bsdname,\n\t\t\t\t\tfilename ? filename : \"-\");\n\t\t\t\tbin2print(md, hashlen, NULL, outfile, 1);\n\t\t\t} else {\n\t\t\t\tbin2print(md, hashlen, filename ? filename : \"-\",\n\t\t\t\t\t  outfile, 1);\n\t\t\t}\n\t\t\tret = 0;\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Generation of hash for file %s failed (%d)\\n\",\n\t\t\tfilename ? filename : \"stdin\", ret);\n\t}\n\nout:\n\tif (memblock)\n\t\tmunmap(memblock, size);\n\n\treturn ret;\n}\n\n/*\n * GCC v8.1.0 introduced -Wstringop-truncation and GCC v8.2.0 introduced\n * -Wstringop-overflow but it is not smart enough to find that cursor string\n * will be NULL-terminated after all paste() calls and warns with:\n * error: 'strncpy' destination unchanged after copying no bytes [-Werror=stringop-truncation]\n * error: 'strncpy' output truncated before terminating nul copying 5 bytes from a string of the same length [-Werror=stringop-truncation]\n * error: 'strncpy' specified bound depends on the length of the source argument [-Werror=stringop-overflow=]\n */\n#pragma GCC diagnostic push\n#if GCC_VERSION >= 80100\n#pragma GCC diagnostic ignored \"-Wstringop-truncation\"\n#endif\n#if GCC_VERSION >= 80200\n#pragma GCC diagnostic ignored \"-Wstringop-overflow\"\n#endif\nstatic char *paste(char *dst, const char *src, size_t size)\n{\n\tstrncpy(dst, src, size);\n\treturn dst + size;\n}\n\n/*\n * Convert a given file name into its respective HMAC file name\n *\n * return: NULL when malloc failed, a pointer that the caller must free\n * otherwise.\n */\nstatic char *get_hmac_file(const char *filename, const char *checkdir)\n{\n\tsize_t i, filelen, pathlen, namelen, basenamestart = 0;\n\tsize_t prefixlen = strlen(CHECK_PREFIX);\n\tsize_t suffixlen = strlen(CHECK_SUFFIX);\n\tchar *cursor, *checkfile = NULL;\n\n\tfilelen = strlen(filename);\n\tif (filelen > 4096) {\n\t\tfprintf(stderr, \"File too long\\n\");\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < filelen; i++) {\n\t\tif (!strncmp(filename + i, \"/\", 1))\n\t\t\tbasenamestart = i + 1;\n\t}\n\n\tnamelen = filelen - basenamestart;\n\tpathlen = checkdir ? strlen(checkdir) + 1 : basenamestart;\n\n\tcheckfile = malloc(pathlen + namelen + prefixlen + 1 /* \".\" */ +\n\t\tsuffixlen + 1 /* null character */);\n\tif (!checkfile)\n\t\treturn NULL;\n\n\tcursor = checkfile;\n\tif (checkdir) {\n\t\tcursor = paste(cursor, checkdir, strlen(checkdir));\n\t\tcursor = paste(cursor, \"/\", 1);\n\t} else if (pathlen > 0)\n\t\tcursor = paste(cursor, filename, pathlen);\n\n\tcursor = paste(cursor, CHECK_PREFIX, prefixlen);\n\tcursor = paste(cursor, filename + basenamestart, namelen);\n\tcursor = paste(cursor, \".\"CHECK_SUFFIX, 1 + suffixlen);\n\tstrncpy(cursor, \"\\0\", 1);\n\treturn checkfile;\n}\n#pragma GCC diagnostic pop /* -Wstringop-truncation -Wstringop-overflow */\n\nstatic int hash_files(const struct hash_params *params,\n\t\t      char *filenames[], uint32_t files,\n\t\t      int fipshmac, const char *checkdir, int just_print)\n{\n\tstruct kcapi_handle *handle;\n\tconst char *hashname = params->name.kcapiname;\n\tuint32_t i = 0;\n\tint ret = 0;\n\t\n\tret = kcapi_md_init(&handle, hashname, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"Allocation of %s cipher failed (ret=%d)\\n\",\n\t\t\thashname, ret);\n\t\treturn -EFAULT;\n\t}\n\tif (params->key.data) {\n\t\tret = kcapi_md_setkey(handle, params->key.data, params->key.len);\n\t\tif (ret) {\n\t\t\tfprintf(stderr, \"Setting HMAC key for %s failed (%d)\\n\",\n\t\t\t\thashname, ret);\n\t\t\tkcapi_md_destroy(handle);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t\n\tif (files) {\n\t\tfor (i = 0; i < files; i++) {\n\t\t\tFILE *out = just_print ? NULL : stdout;\n\t\t\tconst char *filename = filenames[i];\n\n\t\t\tif (fipshmac) {\n\t\t\t\tchar *outfile = get_hmac_file(filenames[i], checkdir);\n\t\t\t\tif (!outfile) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"Cannot create HMAC file name\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tout = fopen(outfile, \"w\");\n\t\t\t\tif (!out) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"Cannot open HMAC file %s\\n\",\n\t\t\t\t\t\toutfile);\n\t\t\t\t\tfree(outfile);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfree(outfile);\n\t\t\t} else if (strcmp(filename, \"-\") == 0) {\n\t\t\t\tfilename = NULL;\n\t\t\t}\n\t\t\tret = hasher(handle, params, filename, NULL, 0, out);\n\t\t\tif (fipshmac)\n\t\t\t\tfclose(out);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = hasher(handle, params, NULL, NULL, 0, stdout);\n\t}\n\n\tkcapi_md_destroy(handle);\n\treturn ret;\n}\n\n#define CHK_QUIET (1)\n#define CHK_STATUS (2)\n\nstatic int process_checkfile(const struct hash_params *params,\n\t\t\t     const char *checkfile, const char *targetfile, int log)\n{\n\tFILE *file = NULL;\n\tint ret = 0;\n\tint checked_any = 0;\n\tstruct kcapi_handle *handle;\n\tconst char *hashname = params->name.kcapiname;\n\n\t/*\n\t * A file can have up to 4096 characters, so a complete line has at most\n\t * 4096 bytes (file name) + 128 bytes (SHA512 hex value) + 2 spaces +\n\t * one byte for the CR.\n\t */\n\tchar buf[(4096 + 128 + 2 + 1)];\n\n\tret = kcapi_md_init(&handle, hashname, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"Allocation of %s cipher failed (%d)\\n\",\n\t\t\thashname, ret);\n\t\treturn -EFAULT;\n\t}\n\tif (params->key.data) {\n\t\tret = kcapi_md_setkey(handle, params->key.data, params->key.len);\n\t\tif (ret) {\n\t\t\tfprintf(stderr, \"Setting HMAC key for %s failed (%d)\\n\",\n\t\t\t\thashname, ret);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfile = strcmp(checkfile, \"-\") ? fopen(checkfile, \"r\") : stdin;\n\tif (!file) {\n\t\tfprintf(stderr, \"Cannot open file %s\\n\", checkfile);\n\t\tret = 253;\n\t\tgoto out;\n\t}\n\n\twhile (fgets(buf, sizeof(buf), file)) {\n\t\tchar *filename = NULL;   // parsed file name\n\t\tchar *hexhash = NULL;    // parsed hex value of hash\n\t\tuint32_t hexhashlen = 0; // length of hash hex value\n\t\tuint32_t linelen = strlen(buf);\n\t\tuint32_t i;\n\t\tuint32_t bsd_style = 0; // >0 if --tag formatted style\n\n\t\tif (linelen == 0)\n\t\t\tbreak;\n\n\t\t/* remove trailing CR and reduce buffer length */\n\t\tfor (i = linelen - 1; i > 0; i--) {\n\t\t\tif (!isprint(buf[i])) {\n\t\t\t\tbuf[i] = '\\0';\n\t\t\t\tlinelen--;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 1; i < linelen; i++) {\n\t\t\t/*\n\t\t\t * Check for BSD-style separator between file name and\n\t\t\t * hash value.\n\t\t\t */\n\t\t\tif (((linelen - i) >= 3) &&\n\t\t\t    isblank(buf[i]) &&\n\t\t\t    buf[i+1] == '=' &&\n\t\t\t    isblank(buf[i+2])) {\n\t\t\t\t/* Start of hash value */\n\t\t\t\tbsd_style = i + 3;\n\t\t\t\thexhash = buf + bsd_style;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < linelen; i++) {\n\t\t\t/* file name / hash separator for regular case */\n\t\t\tif (!bsd_style && isblank(buf[i])) {\n\t\t\t\tfilename = buf + i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Count hash bytes */\n\t\t\tif (!bsd_style && !filename)\n\t\t\t\thexhashlen++;\n\n\t\t\t/* Find file name start value of BSD-style. */\n\t\t\tif (bsd_style &&\n\t\t\t    (linelen - i) >= 2 &&\n\t\t\t     isblank(buf[i]) &&\n\t\t\t     buf[i + 1] == '(') {\n\t\t\t\tfilename = buf + i + 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* In regular case, hash starts at the beginning of buffer. */\n\t\tif (!bsd_style)\n\t\t\thexhash = buf;\n\n\t\tif (bsd_style) {\n\t\t\t/* Hash starts after separator */\n\t\t\thexhashlen = linelen - bsd_style + 1;\n\n\t\t\t/* remove closing parenthesis behind filename */\n\t\t\tif (buf[(bsd_style - 4)] == ')')\n\t\t\t\tbuf[(bsd_style - 4)] = '\\0';\n\t\t}\n\n\t\tif (!hexhash || !hexhashlen) {\n\t\t\tfprintf(stderr, \"Invalid checkfile format\\n\");\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* fipscheck does not have the filename in the check file */\n\t\tif (targetfile) {\n\t\t\tret = hasher(handle, params, targetfile,\n\t\t\t             hexhash, hexhashlen, stdout);\n\t\t\tchecked_any = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (filename) {\n\t\t\tint r;\n\n\t\t\tif (!bsd_style) {\n\t\t\t\tif (!isblank(filename[0]) ||\n\t\t\t\t    (!isblank(filename[1]) && filename[1] != '*')) {\n\t\t\t\t\tfprintf(stderr, \"Invalid checkfile format\\n\");\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tfilename += 2;\n\t\t\t}\n\n\t\t\tr = hasher(handle, params, filename, hexhash, hexhashlen, stdout);\n\n\t\t\tif (r == 0) {\n\t\t\t\tif (log < CHK_QUIET)\n\t\t\t\t\tprintf(\"%s: OK\\n\", filename);\n\t\t\t} else {\n\t\t\t\tif (log < CHK_STATUS)\n\t\t\t\t\tprintf(\"%s: Not OK\\n\",\n\t\t\t\t\t\tfilename);\n\t\t\t\tif (ret >= 0)\n\t\t\t\t\tret++;\n\t\t\t}\n\t\t\tchecked_any = 1;\n\t\t}\n\t}\n\nout:\n\tif (file)\n\t\tfclose(file);\n\tkcapi_md_destroy(handle);\n\n\t/*\n\t * If we found no lines to check, return an error.\n\t * (See https://pagure.io/hmaccalc/c/1afb99549816192eb8e6bc8101bc417c2ffa764c)\n\t */\n\treturn ret != 0 ? ret : !checked_any;\n\n}\n\n/* self-check modes: */\n#define SELFCHECK_CHECK\t\t0\n#define SELFCHECK_PRINT_SELF\t1\n#define SELFCHECK_PRINT_LIB\t2\n\nstatic int fipscheck_self(const struct hash_params *params_bin,\n                          const struct hash_params *params_lib, int mode)\n{\n\tchar *checkfile = NULL;\n\tuint32_t n = 0;\n\tint ret = -EINVAL;\n\tchar fipsflag[1];\n#define BUFSIZE 4096\n\tchar selfname[BUFSIZE];\n\tchar *names[] = { selfname };\n\tint32_t selfnamesize = 0;\n\tDl_info info;\n\tvoid *dl = NULL, *sym;\n\n#ifdef HAVE_SECURE_GETENV\n\tif (secure_getenv(\"KCAPI_HASHER_FORCE_FIPS\") || mode != SELFCHECK_CHECK) {\n#else\n\tif (getenv(\"KCAPI_HASHER_FORCE_FIPS\") || mode != SELFCHECK_CHECK) {\n#endif\n\t\tfipsflag[0] = 1;\n\t} else {\n\t\tFILE *fipsfile = NULL;\n\n\t\tfipsfile = fopen(\"/proc/sys/crypto/fips_enabled\", \"r\");\n\t\tif (!fipsfile) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\t/* FIPS support not enabled in kernel */\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"Cannot open fips_enabled file: %s\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\tn = fread((void *)fipsflag, 1, 1, fipsfile);\n\t\tfclose(fipsfile);\n\t\tif (n != 1) {\n\t\t\tfprintf(stderr, \"Cannot read FIPS flag\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (fipsflag[0] == '0') {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Integrity check of our application. */\n\tif (mode == SELFCHECK_CHECK || mode == SELFCHECK_PRINT_SELF) {\n\t\tmemset(selfname, 0, sizeof(selfname));\n\t\tselfnamesize = readlink(\"/proc/self/exe\", selfname, BUFSIZE);\n\t\tif (selfnamesize >= BUFSIZE || selfnamesize < 0) {\n\t\t\tfprintf(stderr, \"Cannot obtain my filename\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mode == SELFCHECK_PRINT_SELF) {\n\t\t\tret = hash_files(params_bin, names, 1, 0, NULL, 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcheckfile = get_hmac_file(selfname, params_bin->key.checkdir);\n\t\tif (!checkfile) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = process_checkfile(params_bin, checkfile, selfname, CHK_STATUS);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* Integrity check of shared libkcapi.so file. */\n\tif (mode == SELFCHECK_CHECK || mode == SELFCHECK_PRINT_LIB) {\n\t\tmemset(selfname, 0, sizeof(selfname));\n\t\tsnprintf(selfname, (sizeof(selfname) - 1), \"libkcapi.so.%u\",\n\t\t         KCAPI_MAJVERSION);\n\t\tdl = dlopen(selfname, RTLD_NODELETE|RTLD_NOLOAD|RTLD_LAZY);\n\t\tif (dl == NULL) {\n\t\t\tfprintf(stderr, \"dlopen of file %s failed\\n\", selfname);\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemset(selfname, 0, sizeof(selfname));\n\t\tsym = dlsym(dl, \"kcapi_md_init\");\n\t\tif (sym == NULL || !dladdr(sym, &info)) {\n\t\t\tfprintf(stderr, \"finding symbol kcapi_md_init failed\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstrncpy(selfname, info.dli_fname, (sizeof(selfname) - 1));\n\n\t\tif (mode == SELFCHECK_PRINT_LIB) {\n\t\t\tret = hash_files(params_lib, names, 1, 0, NULL, 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (checkfile)\n\t\t\tfree(checkfile);\n\t\tcheckfile = get_hmac_file(selfname, params_lib->key.checkdir);\n\t\tif (!checkfile) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = process_checkfile(params_lib, checkfile, selfname, CHK_STATUS);\n\t}\n\nout:\n\tif (checkfile)\n\t\tfree(checkfile);\n\tif (dl)\n\t\tdlclose(dl);\n\treturn ret;\n}\n\nint strtou32(const char *str, uint32_t *out)\n{\n\tchar *end;\n\tunsigned long value = strtoul(str, &end, 10);\n\tif (*str == '\\0' || *end != '\\0' || value > UINT32_MAX)\n\t\treturn -EINVAL;\n\t*out = (uint32_t)value;\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tconst struct hash_name *names;\n\tstruct hash_params params = {\n\t\t.name = { NULL, NULL },\n\t\t.key = { NULL, NULL, 0 },\n\t\t.hashlen = 0,\n\t\t.bsd_style = 0,\n\t};\n\tconst struct hash_params *params_self;\n\tchar *basec = NULL;\n\tconst char *basen = NULL;\n\tint ret = -EFAULT;\n\n\tchar *checkfile = NULL;\n\tconst char *targetfile = NULL;\n\tconst char *checkdir = NULL;\n\tuint8_t *hmackey_alloc = NULL;\n\tuint8_t *hmackey_mmap = NULL;\n\tint opt_index = 0;\n\tint loglevel = 0;\n\tint hmac = 0;\n\tint fipscheck = 0;\n\tint fipshmac = 0;\n\tint selfcheck_mode = SELFCHECK_CHECK;\n\n\tstatic const char *opts_name_short = \"n:\";\n\tstatic const struct option opts_name[] = {\n\t\t{\"name\", 1, 0, 'n'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\tstatic const char *opts_short = \"c:uh:t:SLqk:K:vbd:P\";\n\tstatic const struct option opts[] = {\n\t\t{\"help\", 0, 0, 0},\n\t\t{\"tag\", 0, 0, 0},\n\t\t{\"quiet\", 0, 0, 0},\n\t\t{\"check\", 1, 0, 'c'},\n\t\t{\"unkeyed\", 0, 0, 'u'},\n\t\t{\"hash\", 1, 0, 'h'},\n\t\t{\"truncate\", 1, 0, 't'},\n\t\t{\"self-sum\", 0, 0, 'S'},\n\t\t{\"self-sum-lib\", 0, 0, 'L'},\n\t\t{\"status\", 0, 0, 'q'},\n\t\t{\"key-file\", 1, 0, 'k'},\n\t\t{\"key\", 1, 0, 'K'},\n\t\t{\"version\", 0, 0, 'v'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\t/*\n\t * Self-integrity check:\n\t *\t* fipscheck/fipshmac and sha*sum equivalents are using the\n\t *\t  fipscheck key and hmac(sha256)\n\t *\t* hmaccalc applications are using the hmaccalc key and\n\t *\t  hmac(sha512)\n\t */\n\tconst struct hash_params PARAMS_SELF_FIPSCHECK = {\n\t\t.name = NAMES_SHA256[1],\n\t\t.bsd_style = 0,\n\t\t.hashlen = 0,\n\t\t.key = KEY_FIPSCHECK,\n\t};\n\tconst struct hash_params PARAMS_SELF_HMACCALC = {\n\t\t.name = NAMES_SHA512[1],\n\t\t.bsd_style = 0,\n\t\t.hashlen = 0,\n\t\t.key = KEY_HMACCALC,\n\t};\n\n\tbasec = strdup(argv[0]);\n\tif (!basec) {\n\t\tfprintf(stderr, \"Error copying file name: %s\\n\",\n\t\t\tstrerror(errno));\n\t\treturn 255;\n\t}\n\tbasen = basename(basec);\n\n\topterr = 0;\n\tif (getopt_long(argc, argv, opts_name_short, opts_name, &opt_index) == 'n')\n\t\tbasen = optarg;\n\telse\n\t\toptind = 1;\n\topterr = 1;\n\n\tparams_self = &PARAMS_SELF_FIPSCHECK;\n\tif (0 == strncmp(basen, \"sha256sum\", 9)) {\n\t\tnames = NAMES_SHA256;\n\t} else if (0 == strncmp(basen, \"sha512sum\", 9)) {\n\t\tnames = NAMES_SHA512;\n\t} else if (0 == strncmp(basen, \"sha1sum\", 7)) {\n\t\tnames = NAMES_SHA1;\n\t} else if (0 == strncmp(basen, \"sha224sum\", 9)) {\n\t\tnames = NAMES_SHA224;\n\t} else if (0 == strncmp(basen, \"sha384sum\", 9)) {\n\t\tnames = NAMES_SHA384;\n\t} else if (0 == strncmp(basen, \"md5sum\", 6)) {\n\t\tnames = NAMES_MD5;\n\t} else if (0 == strncmp(basen, \"fipshmac\", 8)) {\n\t\tnames = NAMES_SHA256;\n\t\thmac = 1;\n\t\tparams.key = KEY_FIPSCHECK;\n\t\tfipshmac = 1;\n\t} else if (0 == strncmp(basen, \"fipscheck\", 9)) {\n\t\tnames = NAMES_SHA256;\n\t\thmac = 1;\n\t\tparams.key = KEY_FIPSCHECK;\n\t\tfipscheck = 1;\n\t} else if (0 == strncmp(basen, \"sha1hmac\", 8)) {\n\t\tnames = NAMES_SHA1;\n\t\thmac = 1;\n\t\tparams.key = KEY_HMACCALC;\n\t\tparams_self = &PARAMS_SELF_HMACCALC;\n\t} else if (0 == strncmp(basen, \"sha224hmac\", 10)) {\n\t\tnames = NAMES_SHA224;\n\t\thmac = 1;\n\t\tparams.key = KEY_HMACCALC;\n\t\tparams_self = &PARAMS_SELF_HMACCALC;\n\t} else if (0 == strncmp(basen, \"sha256hmac\", 10)) {\n\t\tnames = NAMES_SHA256;\n\t\thmac = 1;\n\t\tparams.key = KEY_HMACCALC;\n\t\tparams_self = &PARAMS_SELF_HMACCALC;\n\t} else if (0 == strncmp(basen, \"sha384hmac\", 10)) {\n\t\tnames = NAMES_SHA384;\n\t\thmac = 1;\n\t\tparams.key = KEY_HMACCALC;\n\t\tparams_self = &PARAMS_SELF_HMACCALC;\n\t} else if (0 == strncmp(basen, \"sha512hmac\", 10)) {\n\t\tnames = NAMES_SHA512;\n\t\thmac = 1;\n\t\tparams.key = KEY_HMACCALC;\n\t\tparams_self = &PARAMS_SELF_HMACCALC;\n\t} else {\n\t\tfprintf(stderr, \"Unknown invocation name: %s\\n\", basen);\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tint c = getopt_long(argc, argv, opts_short, opts, &opt_index);\n\t\t\n\t\tif (-1 == c)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\t\tcase 0:\n\t\t\t\tswitch (opt_index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tusage(argv[0], fipscheck);\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\tcase 1:\n\t\t\t\t\tparams.bsd_style = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tloglevel = CHK_QUIET;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tif (checkfile)\n\t\t\t\t\tfree(checkfile);\n\t\t\t\tcheckfile = strdup(optarg);\n\t\t\t\tif (!checkfile) {\n\t\t\t\t\tfprintf(stderr, \"Error copying file name: %s\\n\",\n\t\t\t\t\t        strerror(errno));\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tif (hmackey_alloc) {\n\t\t\t\t\tkcapi_memset_secure(hmackey_alloc, 0,\n\t\t\t\t\t                    params.key.len);\n\t\t\t\t\tfree(hmackey_alloc);\n\t\t\t\t\thmackey_alloc = NULL;\n\t\t\t\t} else if (hmackey_mmap) {\n\t\t\t\t\tmunmap(hmackey_mmap, params.key.len);\n\t\t\t\t\thmackey_mmap = NULL;\n\t\t\t\t}\n\t\t\t\tparams.key.data = NULL;\n\t\t\t\tparams.key.len = 0;\n\t\t\t\thmac = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tif (0 == strcmp(optarg, \"sha1\"))\n\t\t\t\t\tnames = NAMES_SHA1;\n\t\t\t\telse if (0 == strcmp(optarg, \"sha224\"))\n\t\t\t\t\tnames = NAMES_SHA224;\n\t\t\t\telse if (0 == strcmp(optarg, \"sha256\"))\n\t\t\t\t\tnames = NAMES_SHA256;\n\t\t\t\telse if (0 == strcmp(optarg, \"sha384\"))\n\t\t\t\t\tnames = NAMES_SHA384;\n\t\t\t\telse if (0 == strcmp(optarg, \"sha512\"))\n\t\t\t\t\tnames = NAMES_SHA512;\n\t\t\t\telse {\n\t\t\t\t\tfprintf(stderr, \"Invalid hash: %s\\n\", optarg);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tif (strtou32(optarg, &params.hashlen)) {\n\t\t\t\t\tfprintf(stderr, \"Invalid number: %s\\n\", optarg);\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (params.hashlen % 8 != 0) {\n\t\t\t\t\tfprintf(stderr, \"Truncated hash size must be \"\n\t\t\t\t\t                \"a multiple of 8 bits!\\n\");\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tparams.hashlen /= 8;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tselfcheck_mode = SELFCHECK_PRINT_SELF;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tselfcheck_mode = SELFCHECK_PRINT_LIB;\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tloglevel = CHK_STATUS;\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\tif (hmackey_alloc) {\n\t\t\t\t\tkcapi_memset_secure(hmackey_alloc, 0,\n\t\t\t\t\t                    params.key.len);\n\t\t\t\t\tfree(hmackey_alloc);\n\t\t\t\t\thmackey_alloc = NULL;\n\t\t\t\t} else if (hmackey_mmap) {\n\t\t\t\t\tmunmap(hmackey_mmap, params.key.len);\n\t\t\t\t\thmackey_mmap = NULL;\n\t\t\t\t}\n\t\t\t\tret = mmap_file(optarg, &hmackey_mmap, &params.key.len);\n\t\t\t\tif (!ret) {\n\t\t\t\t\tparams.key.data = hmackey_mmap;\n\t\t\t\t\thmac = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* fallback to normal file I/O: */\n\t\t\t\tret = load_file(optarg, &hmackey_alloc, &params.key.len);\n\t\t\t\tif (ret) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tparams.key.data = hmackey_alloc;\n\t\t\t\thmac = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'K':\n\t\t\t\tif (hmackey_alloc) {\n\t\t\t\t\tkcapi_memset_secure(hmackey_alloc, 0,\n\t\t\t\t\t                    params.key.len);\n\t\t\t\t\tfree(hmackey_alloc);\n\t\t\t\t\thmackey_alloc = NULL;\n\t\t\t\t} else if (hmackey_mmap) {\n\t\t\t\t\tmunmap(hmackey_mmap, params.key.len);\n\t\t\t\t\thmackey_mmap = NULL;\n\t\t\t\t}\n\t\t\t\thmackey_alloc = (uint8_t *)strdup(optarg);\n\t\t\t\tif (!hmackey_alloc) {\n\t\t\t\t\tfprintf(stderr, \"Cannot allocate memory for HMAC key\\n\");\n\t\t\t\t\tret = 1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tparams.key.data = hmackey_alloc;\n\t\t\t\tparams.key.len = strlen(optarg);\n\t\t\t\thmac = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tversion(argv[0]);\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\tcase 'd':\n\t\t\t\tcheckdir = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\tcase 'P':\n\t\t\t\t/* Compatibility options, just ignore */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tusage(argv[0], fipscheck);\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (selfcheck_mode != SELFCHECK_CHECK) {\n\t\tif (checkfile) {\n\t\t\tfprintf(stderr, \"-S/-L and -c cannot be combined\\n\");\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (optind != argc) {\n\t\t\tfprintf(stderr, \"-S/-L cannot be used with input files\\n\");\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* library self-check must be consistent across apps: */\n\tif (fipscheck_self(params_self, &PARAMS_SELF_FIPSCHECK, selfcheck_mode)) {\n\t\tfprintf(stderr, \"Integrity check of application %s failed\\n\",\n\t\t\tbasen);\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tif (selfcheck_mode != SELFCHECK_CHECK) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tparams.name = names[hmac];\n\n\tif (fipscheck) {\n\t\tif (optind >= argc) {\n\t\t\tfprintf(stderr, \"No file to check given for fipscheck\\n\");\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (checkfile) {\n\t\t\tfprintf(stderr, \"-c is not valid for fipscheck\\n\");\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttargetfile = argv[optind];\n\t\tif (checkfile)\n\t\t\tfree(checkfile);\n\t\tcheckfile = get_hmac_file(targetfile, params.key.checkdir);\n\t\tif (!checkfile) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\toptind++;\n\t}\n\n\tif (!checkfile)\n\t\tret = hash_files(&params, argv + optind, (argc - optind),\n\t\t                 fipshmac, checkdir, 0);\n\telse if (optind == argc)\n\t\tret = process_checkfile(&params, checkfile, targetfile, loglevel);\n\telse {\n\t\tfprintf(stderr, \"-c cannot be used with input files\\n\");\n\t\tret = 1;\n\t}\n\n\nout:\n\tif (basec)\n\t\tfree(basec);\n\tif (checkfile)\n\t\tfree(checkfile);\n\tif (hmackey_alloc) {\n\t\tkcapi_memset_secure(hmackey_alloc, 0, params.key.len);\n\t\tfree(hmackey_alloc);\n\t} else if (hmackey_mmap) {\n\t\tmunmap(hmackey_mmap, params.key.len);\n\t}\n\n\treturn ret;\n}\n"
    },
    "skipped": [],
    "total_files": 105
}