{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-zsh-5.6.2-in6fa74mnlid6t7rhhv7rn7bvrxkfdak/spack-src/config.h.in": "/* config.h.in.  Generated from configure.ac by autoheader.  */\n\n/***** begin user configuration section *****/\n\n/* Define this to be the location of your password file */\n#define PASSWD_FILE \"/etc/passwd\"\n\n/* Define this to be the name of your NIS/YP password *\n * map (if applicable)                                */\n#define PASSWD_MAP \"passwd.byname\"\n\n/* Define to 1 if you want user names to be cached */\n#define CACHE_USERNAMES 1\n\n/* Define to 1 if system supports job control */\n#define JOB_CONTROL 1\n\n/* Define this if you use \"suspended\" instead of \"stopped\" */\n#define USE_SUSPENDED 1\n \n/* The default history buffer size in lines */\n#define DEFAULT_HISTSIZE 30\n\n/* The default editor for the fc builtin */\n#define DEFAULT_FCEDIT \"vi\"\n\n/* The default prefix for temporary files */\n#define DEFAULT_TMPPREFIX \"/tmp/zsh\"\n\n/***** end of user configuration section            *****/\n/***** shouldn't have to change anything below here *****/\n\n\n\n/* Define to 1 if you want to use dynamically loaded modules on AIX. */\n#undef AIXDYNAMIC\n\n/* Define to 1 if the isprint() function is broken under UTF-8 locale. */\n#undef BROKEN_ISPRINT\n\n/* Define to 1 if kill(pid, 0) doesn't return ESRCH, ie BeOS R4.51. */\n#undef BROKEN_KILL_ESRCH\n\n/* Define to 1 if sigsuspend() is broken */\n#undef BROKEN_POSIX_SIGSUSPEND\n\n/* Define to 1 if compiler incorrectly cast signed to unsigned. */\n#undef BROKEN_SIGNED_TO_UNSIGNED_CASTING\n\n/* Define to 1 if tcsetpgrp() doesn't work, ie BeOS R4.51. */\n#undef BROKEN_TCSETPGRP\n\n/* Define to 1 if you use BSD style signal handling (and can block signals).\n   */\n#undef BSD_SIGNALS\n\n/* Undefine if you don't want local features. By default this is defined. */\n#undef CONFIG_LOCALE\n\n/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP\n   systems. This function is required for `alloca.c' support on those systems.\n   */\n#undef CRAY_STACKSEG_END\n\n/* Define to a custom value for the ZSH_PATCHLEVEL parameter */\n#undef CUSTOM_PATCHLEVEL\n\n/* Define to 1 if using `alloca.c'. */\n#undef C_ALLOCA\n\n/* Define to 1 if you want to debug zsh. */\n#undef DEBUG\n\n/* The default path; used when running commands with command -p */\n#undef DEFAULT_PATH\n\n/* Define default pager used by readnullcmd */\n#undef DEFAULT_READNULLCMD\n\n/* Define to 1 if you want to avoid calling functions that will require\n   dynamic NSS modules. */\n#undef DISABLE_DYNAMIC_NSS\n\n/* Define to 1 if an underscore has to be prepended to dlsym() argument. */\n#undef DLSYM_NEEDS_UNDERSCORE\n\n/* The extension used for dynamically loaded modules. */\n#undef DL_EXT\n\n/* Define to 1 if you want to use dynamically loaded modules. */\n#undef DYNAMIC\n\n/* Define to 1 if multiple modules defining the same symbol are OK. */\n#undef DYNAMIC_NAME_CLASH_OK\n\n/* Define to 1 if you want use unicode9 character widths. */\n#undef ENABLE_UNICODE9\n\n/* Define to 1 if getcwd() calls malloc to allocate memory. */\n#undef GETCWD_CALLS_MALLOC\n\n/* Define to 1 if the `getpgrp' function requires zero arguments. */\n#undef GETPGRP_VOID\n\n/* Define to 1 if getpwnam() is faked, ie BeOS R4.51. */\n#undef GETPWNAM_FAKED\n\n/* The global file to source whenever zsh is run as a login shell; if\n   undefined, don't source anything */\n#undef GLOBAL_ZLOGIN\n\n/* The global file to source whenever zsh was run as a login shell. This is\n   sourced right before exiting. If undefined, don't source anything. */\n#undef GLOBAL_ZLOGOUT\n\n/* The global file to source whenever zsh is run as a login shell, before\n   zshrc is read; if undefined, don't source anything. */\n#undef GLOBAL_ZPROFILE\n\n/* The global file to source absolutely first whenever zsh is run; if\n   undefined, don't source anything. */\n#undef GLOBAL_ZSHENV\n\n/* The global file to source whenever zsh is run; if undefined, don't source\n   anything */\n#undef GLOBAL_ZSHRC\n\n/* Define if TIOCGWINSZ is defined in sys/ioctl.h but not in termios.h. */\n#undef GWINSZ_IN_SYS_IOCTL\n\n/* Define to 1 if you have `alloca', as a function or macro. */\n#undef HAVE_ALLOCA\n\n/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).\n   */\n#undef HAVE_ALLOCA_H\n\n/* Define to 1 if you have the <bind/netdb.h> header file. */\n#undef HAVE_BIND_NETDB_H\n\n/* Define if you have the termcap boolcodes symbol. */\n#undef HAVE_BOOLCODES\n\n/* Define if you have the terminfo boolnames symbol. */\n#undef HAVE_BOOLNAMES\n\n/* Define to 1 if you have the `brk' function. */\n#undef HAVE_BRK\n\n/* Define to 1 if there is a prototype defined for brk() on your system. */\n#undef HAVE_BRK_PROTO\n\n/* Define to 1 if you have the `canonicalize_file_name' function. */\n#undef HAVE_CANONICALIZE_FILE_NAME\n\n/* Define to 1 if you have the `cap_get_proc' function. */\n#undef HAVE_CAP_GET_PROC\n\n/* Define to 1 if you have the `clock_gettime' function. */\n#undef HAVE_CLOCK_GETTIME\n\n/* Define to 1 if you have the <curses.h> header file. */\n#undef HAVE_CURSES_H\n\n/* Define to 1 if you have the `cygwin_conv_path' function. */\n#undef HAVE_CYGWIN_CONV_PATH\n\n/* Define to 1 if you have the `difftime' function. */\n#undef HAVE_DIFFTIME\n\n/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n   */\n#undef HAVE_DIRENT_H\n\n/* Define to 1 if you have the `dlclose' function. */\n#undef HAVE_DLCLOSE\n\n/* Define to 1 if you have the `dlerror' function. */\n#undef HAVE_DLERROR\n\n/* Define to 1 if you have the <dlfcn.h> header file. */\n#undef HAVE_DLFCN_H\n\n/* Define to 1 if you have the `dlopen' function. */\n#undef HAVE_DLOPEN\n\n/* Define to 1 if you have the `dlsym' function. */\n#undef HAVE_DLSYM\n\n/* Define to 1 if you have the <dl.h> header file. */\n#undef HAVE_DL_H\n\n/* Define to 1 if you have the `endutxent' function. */\n#undef HAVE_ENDUTXENT\n\n/* Define to 1 if you have the `erand48' function. */\n#undef HAVE_ERAND48\n\n/* Define to 1 if you have the <errno.h> header file. */\n#undef HAVE_ERRNO_H\n\n/* Define to 1 if you have the `faccessx' function. */\n#undef HAVE_FACCESSX\n\n/* Define to 1 if you have the `fchdir' function. */\n#undef HAVE_FCHDIR\n\n/* Define to 1 if you have the `fchmod' function. */\n#undef HAVE_FCHMOD\n\n/* Define to 1 if you have the `fchown' function. */\n#undef HAVE_FCHOWN\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#undef HAVE_FCNTL_H\n\n/* Define to 1 if system has working FIFOs. */\n#undef HAVE_FIFOS\n\n/* Define to 1 if you have the `fseeko' function. */\n#undef HAVE_FSEEKO\n\n/* Define to 1 if you have the `fstat' function. */\n#undef HAVE_FSTAT\n\n/* Define to 1 if you have the `ftello' function. */\n#undef HAVE_FTELLO\n\n/* Define to 1 if you have the `ftruncate' function. */\n#undef HAVE_FTRUNCATE\n\n/* Define to 1 if you have the <gdbm.h> header file. */\n#undef HAVE_GDBM_H\n\n/* Define to 1 if you have the `gdbm_open' function. */\n#undef HAVE_GDBM_OPEN\n\n/* Define to 1 if you have the `getcchar' function. */\n#undef HAVE_GETCCHAR\n\n/* Define to 1 if you have the `getcwd' function. */\n#undef HAVE_GETCWD\n\n/* Define to 1 if you have the `getenv' function. */\n#undef HAVE_GETENV\n\n/* Define to 1 if you have the `getgrgid' function. */\n#undef HAVE_GETGRGID\n\n/* Define to 1 if you have the `getgrnam' function. */\n#undef HAVE_GETGRNAM\n\n/* Define to 1 if you have the `gethostbyname2' function. */\n#undef HAVE_GETHOSTBYNAME2\n\n/* Define to 1 if you have the `gethostname' function. */\n#undef HAVE_GETHOSTNAME\n\n/* Define to 1 if you have the `getipnodebyname' function. */\n#undef HAVE_GETIPNODEBYNAME\n\n/* Define to 1 if you have the `getlogin' function. */\n#undef HAVE_GETLOGIN\n\n/* Define to 1 if you have the `getpagesize' function. */\n#undef HAVE_GETPAGESIZE\n\n/* Define to 1 if you have the `getpwent' function. */\n#undef HAVE_GETPWENT\n\n/* Define to 1 if you have the `getpwnam' function. */\n#undef HAVE_GETPWNAM\n\n/* Define to 1 if you have the `getpwuid' function. */\n#undef HAVE_GETPWUID\n\n/* Define to 1 if you have the `getrlimit' function. */\n#undef HAVE_GETRLIMIT\n\n/* Define to 1 if you have the `getrusage' function. */\n#undef HAVE_GETRUSAGE\n\n/* Define to 1 if you have the `gettimeofday' function. */\n#undef HAVE_GETTIMEOFDAY\n\n/* Define to 1 if you have the `getutent' function. */\n#undef HAVE_GETUTENT\n\n/* Define to 1 if you have the `getutxent' function. */\n#undef HAVE_GETUTXENT\n\n/* Define to 1 if you have the `getxattr' function. */\n#undef HAVE_GETXATTR\n\n/* Define to 1 if you have the `grantpt' function. */\n#undef HAVE_GRANTPT\n\n/* Define to 1 if you have the <grp.h> header file. */\n#undef HAVE_GRP_H\n\n/* Define to 1 if you have the `htons' function. */\n#undef HAVE_HTONS\n\n/* Define to 1 if you have the `iconv' function. */\n#undef HAVE_ICONV\n\n/* Define to 1 if you have the <iconv.h> header file. */\n#undef HAVE_ICONV_H\n\n/* Define to 1 if you have the `inet_aton' function. */\n#undef HAVE_INET_ATON\n\n/* Define to 1 if you have the `inet_ntop' function. */\n#undef HAVE_INET_NTOP\n\n/* Define to 1 if you have the `inet_pton' function. */\n#undef HAVE_INET_PTON\n\n/* Define to 1 if you have the `initgroups' function. */\n#undef HAVE_INITGROUPS\n\n/* Define to 1 if you have the `initscr' function. */\n#undef HAVE_INITSCR\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#undef HAVE_INTTYPES_H\n\n/* Define to 1 if there is a prototype defined for ioctl() on your system. */\n#undef HAVE_IOCTL_PROTO\n\n/* Define to 1 if you have the `isblank' function. */\n#undef HAVE_ISBLANK\n\n/* Define to 1 if you have the `isinf' macro or function. */\n#undef HAVE_ISINF\n\n/* Define to 1 if you have the `isnan' macro or function. */\n#undef HAVE_ISNAN\n\n/* Define to 1 if you have the `iswblank' function. */\n#undef HAVE_ISWBLANK\n\n/* Define to 1 if you have the `killpg' function. */\n#undef HAVE_KILLPG\n\n/* Define to 1 if you have the <langinfo.h> header file. */\n#undef HAVE_LANGINFO_H\n\n/* Define to 1 if you have the `lchown' function. */\n#undef HAVE_LCHOWN\n\n/* Define to 1 if you have the `cap' library (-lcap). */\n#undef HAVE_LIBCAP\n\n/* Define to 1 if you have the <libc.h> header file. */\n#undef HAVE_LIBC_H\n\n/* Define to 1 if you have the `dl' library (-ldl). */\n#undef HAVE_LIBDL\n\n/* Define to 1 if you have the `gdbm' library (-lgdbm). */\n#undef HAVE_LIBGDBM\n\n/* Define to 1 if you have the `m' library (-lm). */\n#undef HAVE_LIBM\n\n/* Define to 1 if you have the `rt' library (-lrt). */\n#undef HAVE_LIBRT\n\n/* Define to 1 if you have the `socket' library (-lsocket). */\n#undef HAVE_LIBSOCKET\n\n/* Define to 1 if you have the <limits.h> header file. */\n#undef HAVE_LIMITS_H\n\n/* Define to 1 if system has working link(). */\n#undef HAVE_LINK\n\n/* Define to 1 if you have the `load' function. */\n#undef HAVE_LOAD\n\n/* Define to 1 if you have the `loadbind' function. */\n#undef HAVE_LOADBIND\n\n/* Define to 1 if you have the `loadquery' function. */\n#undef HAVE_LOADQUERY\n\n/* Define to 1 if you have the <locale.h> header file. */\n#undef HAVE_LOCALE_H\n\n/* Define to 1 if you have the `log2' function. */\n#undef HAVE_LOG2\n\n/* Define to 1 if you have the `lstat' function. */\n#undef HAVE_LSTAT\n\n/* Define to 1 if you have the `memcpy' function. */\n#undef HAVE_MEMCPY\n\n/* Define to 1 if you have the `memmove' function. */\n#undef HAVE_MEMMOVE\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if you have the `mkfifo' function. */\n#undef HAVE_MKFIFO\n\n/* Define to 1 if there is a prototype defined for mknod() on your system. */\n#undef HAVE_MKNOD_PROTO\n\n/* Define to 1 if you have the `mkstemp' function. */\n#undef HAVE_MKSTEMP\n\n/* Define to 1 if you have the `mktime' function. */\n#undef HAVE_MKTIME\n\n/* Define to 1 if you have a working `mmap' system call. */\n#undef HAVE_MMAP\n\n/* Define to 1 if you have the `msync' function. */\n#undef HAVE_MSYNC\n\n/* Define to 1 if you have the `munmap' function. */\n#undef HAVE_MUNMAP\n\n/* Define to 1 if you have the `nanosleep' function. */\n#undef HAVE_NANOSLEEP\n\n/* Define to 1 if you have the <ncursesw/ncurses.h> header file. */\n#undef HAVE_NCURSESW_NCURSES_H\n\n/* Define to 1 if you have the <ncursesw/term.h> header file. */\n#undef HAVE_NCURSESW_TERM_H\n\n/* Define to 1 if you have the <ncurses.h> header file. */\n#undef HAVE_NCURSES_H\n\n/* Define to 1 if you have the <ncurses/ncurses.h> header file. */\n#undef HAVE_NCURSES_NCURSES_H\n\n/* Define to 1 if you have the <ncurses/term.h> header file. */\n#undef HAVE_NCURSES_TERM_H\n\n/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */\n#undef HAVE_NDIR_H\n\n/* Define to 1 if you have the <netinet/in_systm.h> header file. */\n#undef HAVE_NETINET_IN_SYSTM_H\n\n/* Define to 1 if you have the `nice' function. */\n#undef HAVE_NICE\n\n/* Define to 1 if you have NIS. */\n#undef HAVE_NIS\n\n/* Define to 1 if you have the `nis_list' function. */\n#undef HAVE_NIS_LIST\n\n/* Define to 1 if you have NISPLUS. */\n#undef HAVE_NIS_PLUS\n\n/* Define to 1 if you have the `nl_langinfo' function. */\n#undef HAVE_NL_LANGINFO\n\n/* Define to 1 if you have the `ntohs' function. */\n#undef HAVE_NTOHS\n\n/* Define if you have the termcap numcodes symbol. */\n#undef HAVE_NUMCODES\n\n/* Define if you have the terminfo numnames symbol. */\n#undef HAVE_NUMNAMES\n\n/* Define to 1 if you have the `open_memstream' function. */\n#undef HAVE_OPEN_MEMSTREAM\n\n/* Define to 1 if your termcap library has the ospeed variable */\n#undef HAVE_OSPEED\n\n/* Define to 1 if you have the `pathconf' function. */\n#undef HAVE_PATHCONF\n\n/* Define to 1 if you have the `pcre_compile' function. */\n#undef HAVE_PCRE_COMPILE\n\n/* Define to 1 if you have the `pcre_exec' function. */\n#undef HAVE_PCRE_EXEC\n\n/* Define to 1 if you have the <pcre.h> header file. */\n#undef HAVE_PCRE_H\n\n/* Define to 1 if you have the `pcre_study' function. */\n#undef HAVE_PCRE_STUDY\n\n/* Define to 1 if you have the `poll' function. */\n#undef HAVE_POLL\n\n/* Define to 1 if you have the <poll.h> header file. */\n#undef HAVE_POLL_H\n\n/* Define to 1 if you have the `posix_openpt' function. */\n#undef HAVE_POSIX_OPENPT\n\n/* Define to 1 if you have the `ptsname' function. */\n#undef HAVE_PTSNAME\n\n/* Define to 1 if you have the `putenv' function. */\n#undef HAVE_PUTENV\n\n/* Define to 1 if you have the <pwd.h> header file. */\n#undef HAVE_PWD_H\n\n/* Define to 1 if you have the `readlink' function. */\n#undef HAVE_READLINK\n\n/* Define to 1 if you have the `realpath' function. */\n#undef HAVE_REALPATH\n\n/* Define to 1 if you have the `regcomp' function. */\n#undef HAVE_REGCOMP\n\n/* Define to 1 if you have the `regerror' function. */\n#undef HAVE_REGERROR\n\n/* Define to 1 if you have the `regexec' function. */\n#undef HAVE_REGEXEC\n\n/* Define to 1 if you have the `regfree' function. */\n#undef HAVE_REGFREE\n\n/* Define to 1 if you have the `resize_term' function. */\n#undef HAVE_RESIZE_TERM\n\n/* Define to 1 if RLIMIT_AIO_MEM is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_AIO_MEM\n\n/* Define to 1 if RLIMIT_AIO_OPS is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_AIO_OPS\n\n/* Define to 1 if RLIMIT_AS is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_AS\n\n/* Define to 1 if RLIMIT_KQUEUES is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_KQUEUES\n\n/* Define to 1 if RLIMIT_LOCKS is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_LOCKS\n\n/* Define to 1 if RLIMIT_MEMLOCK is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_MEMLOCK\n\n/* Define to 1 if RLIMIT_MSGQUEUE is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_MSGQUEUE\n\n/* Define to 1 if RLIMIT_NICE is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_NICE\n\n/* Define to 1 if RLIMIT_NOFILE is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_NOFILE\n\n/* Define to 1 if RLIMIT_NPROC is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_NPROC\n\n/* Define to 1 if RLIMIT_NPTS is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_NPTS\n\n/* Define to 1 if RLIMIT_NTHR is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_NTHR\n\n/* Define to 1 if RLIMIT_POSIXLOCKS is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_POSIXLOCKS\n\n/* Define to 1 if RLIMIT_PTHREAD is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_PTHREAD\n\n/* Define to 1 if RLIMIT_RSS is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_RSS\n\n/* Define to 1 if RLIMIT_RTPRIO is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_RTPRIO\n\n/* Define to 1 if RLIMIT_SBSIZE is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_SBSIZE\n\n/* Define to 1 if RLIMIT_SIGPENDING is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_SIGPENDING\n\n/* Define to 1 if RLIMIT_SWAP is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_SWAP\n\n/* Define to 1 if RLIMIT_TCACHE is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_TCACHE\n\n/* Define to 1 if RLIMIT_VMEM is present (whether or not as a macro). */\n#undef HAVE_RLIMIT_VMEM\n\n/* Define to 1 if you have the `sbrk' function. */\n#undef HAVE_SBRK\n\n/* Define to 1 if there is a prototype defined for sbrk() on your system. */\n#undef HAVE_SBRK_PROTO\n\n/* Define to 1 if you have the `scalbn' function. */\n#undef HAVE_SCALBN\n\n/* Define to 1 if you have the `select' function. */\n#undef HAVE_SELECT\n\n/* Define to 1 if you have the `setcchar' function. */\n#undef HAVE_SETCCHAR\n\n/* Define to 1 if you have the `setenv' function. */\n#undef HAVE_SETENV\n\n/* Define to 1 if you have the `seteuid' function. */\n#undef HAVE_SETEUID\n\n/* Define to 1 if you have the `setlocale' function. */\n#undef HAVE_SETLOCALE\n\n/* Define to 1 if you have the `setpgid' function. */\n#undef HAVE_SETPGID\n\n/* Define to 1 if you have the `setpgrp' function. */\n#undef HAVE_SETPGRP\n\n/* Define to 1 if the system supports `setproctitle' to change process name */\n#undef HAVE_SETPROCTITLE\n\n/* Define to 1 if you have the `setresuid' function. */\n#undef HAVE_SETRESUID\n\n/* Define to 1 if you have the `setreuid' function. */\n#undef HAVE_SETREUID\n\n/* Define to 1 if you have the `setsid' function. */\n#undef HAVE_SETSID\n\n/* Define to 1 if you have the `setuid' function. */\n#undef HAVE_SETUID\n\n/* Define to 1 if you have the `setupterm' function. */\n#undef HAVE_SETUPTERM\n\n/* Define to 1 if you have the `setutxent' function. */\n#undef HAVE_SETUTXENT\n\n/* Define to 1 if you have the `shl_findsym' function. */\n#undef HAVE_SHL_FINDSYM\n\n/* Define to 1 if you have the `shl_load' function. */\n#undef HAVE_SHL_LOAD\n\n/* Define to 1 if you have the `shl_unload' function. */\n#undef HAVE_SHL_UNLOAD\n\n/* Define to 1 if you have the `sigaction' function. */\n#undef HAVE_SIGACTION\n\n/* Define to 1 if you have the `sigblock' function. */\n#undef HAVE_SIGBLOCK\n\n/* Define to 1 if you have the `sighold' function. */\n#undef HAVE_SIGHOLD\n\n/* Define to 1 if you have the `signgam' function. */\n#undef HAVE_SIGNGAM\n\n/* Define to 1 if you have the `sigprocmask' function. */\n#undef HAVE_SIGPROCMASK\n\n/* Define to 1 if you have the `sigrelse' function. */\n#undef HAVE_SIGRELSE\n\n/* Define to 1 if you have the `sigsetmask' function. */\n#undef HAVE_SIGSETMASK\n\n/* Define to 1 if you have the `srand_deterministic' function. */\n#undef HAVE_SRAND_DETERMINISTIC\n\n/* Define to 1 if you have the <stdarg.h> header file. */\n#undef HAVE_STDARG_H\n\n/* Define to 1 if you have the <stddef.h> header file. */\n#undef HAVE_STDDEF_H\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#undef HAVE_STDINT_H\n\n/* Define to 1 if you have the <stdio.h> header file. */\n#undef HAVE_STDIO_H\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#undef HAVE_STDLIB_H\n\n/* Define if you have the termcap strcodes symbol. */\n#undef HAVE_STRCODES\n\n/* Define to 1 if you have the `strcoll' function and it is properly defined.\n   */\n#undef HAVE_STRCOLL\n\n/* Define to 1 if you have the `strerror' function. */\n#undef HAVE_STRERROR\n\n/* Define to 1 if you have the `strftime' function. */\n#undef HAVE_STRFTIME\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#undef HAVE_STRING_H\n\n/* Define if you have the terminfo strnames symbol. */\n#undef HAVE_STRNAMES\n\n/* Define to 1 if you have the `strptime' function. */\n#undef HAVE_STRPTIME\n\n/* Define to 1 if you have the `strstr' function. */\n#undef HAVE_STRSTR\n\n/* Define to 1 if you have the `strtoul' function. */\n#undef HAVE_STRTOUL\n\n/* Define if your system's struct direct has a member named d_ino. */\n#undef HAVE_STRUCT_DIRECT_D_INO\n\n/* Define if your system's struct direct has a member named d_stat. */\n#undef HAVE_STRUCT_DIRECT_D_STAT\n\n/* Define if your system's struct dirent has a member named d_ino. */\n#undef HAVE_STRUCT_DIRENT_D_INO\n\n/* Define if your system's struct dirent has a member named d_stat. */\n#undef HAVE_STRUCT_DIRENT_D_STAT\n\n/* Define to 1 if `ru_idrss' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_IDRSS\n\n/* Define to 1 if `ru_inblock' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_INBLOCK\n\n/* Define to 1 if `ru_isrss' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_ISRSS\n\n/* Define to 1 if `ru_ixrss' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_IXRSS\n\n/* Define to 1 if `ru_majflt' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_MAJFLT\n\n/* Define to 1 if `ru_maxrss' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_MAXRSS\n\n/* Define to 1 if `ru_minflt' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_MINFLT\n\n/* Define to 1 if `ru_msgrcv' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_MSGRCV\n\n/* Define to 1 if `ru_msgsnd' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_MSGSND\n\n/* Define to 1 if `ru_nivcsw' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_NIVCSW\n\n/* Define to 1 if `ru_nsignals' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_NSIGNALS\n\n/* Define to 1 if `ru_nswap' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_NSWAP\n\n/* Define to 1 if `ru_nvcsw' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_NVCSW\n\n/* Define to 1 if `ru_oublock' is a member of `struct rusage'. */\n#undef HAVE_STRUCT_RUSAGE_RU_OUBLOCK\n\n/* Define if your system's struct sockaddr_in6 has a member named\n   sin6_scope_id. */\n#undef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID\n\n/* Define to 1 if `st_atimensec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_ATIMENSEC\n\n/* Define to 1 if `st_atimespec.tv_nsec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC\n\n/* Define to 1 if `st_atim.tv_nsec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC\n\n/* Define to 1 if `st_ctimensec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_CTIMENSEC\n\n/* Define to 1 if `st_ctimespec.tv_nsec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_CTIMESPEC_TV_NSEC\n\n/* Define to 1 if `st_ctim.tv_nsec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC\n\n/* Define to 1 if `st_mtimensec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_MTIMENSEC\n\n/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC\n\n/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */\n#undef HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n\n/* Define to 1 if struct timespec is defined by a system header */\n#undef HAVE_STRUCT_TIMESPEC\n\n/* Define to 1 if struct timezone is defined by a system header */\n#undef HAVE_STRUCT_TIMEZONE\n\n/* Define to 1 if struct utmp is defined by a system header */\n#undef HAVE_STRUCT_UTMP\n\n/* Define to 1 if struct utmpx is defined by a system header */\n#undef HAVE_STRUCT_UTMPX\n\n/* Define if your system's struct utmpx has a member named ut_host. */\n#undef HAVE_STRUCT_UTMPX_UT_HOST\n\n/* Define if your system's struct utmpx has a member named ut_tv. */\n#undef HAVE_STRUCT_UTMPX_UT_TV\n\n/* Define if your system's struct utmpx has a member named ut_xtime. */\n#undef HAVE_STRUCT_UTMPX_UT_XTIME\n\n/* Define if your system's struct utmp has a member named ut_host. */\n#undef HAVE_STRUCT_UTMP_UT_HOST\n\n/* Define to 1 if you have RFS superroot directory. */\n#undef HAVE_SUPERROOT\n\n/* Define to 1 if you have the `symlink' function. */\n#undef HAVE_SYMLINK\n\n/* Define to 1 if you have the `sysconf' function. */\n#undef HAVE_SYSCONF\n\n/* Define to 1 if you have the <sys/capability.h> header file. */\n#undef HAVE_SYS_CAPABILITY_H\n\n/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.\n   */\n#undef HAVE_SYS_DIR_H\n\n/* Define to 1 if you have the <sys/filio.h> header file. */\n#undef HAVE_SYS_FILIO_H\n\n/* Define to 1 if you have the <sys/mman.h> header file. */\n#undef HAVE_SYS_MMAN_H\n\n/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.\n   */\n#undef HAVE_SYS_NDIR_H\n\n/* Define to 1 if you have the <sys/param.h> header file. */\n#undef HAVE_SYS_PARAM_H\n\n/* Define to 1 if you have the <sys/resource.h> header file. */\n#undef HAVE_SYS_RESOURCE_H\n\n/* Define to 1 if you have the <sys/select.h> header file. */\n#undef HAVE_SYS_SELECT_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#undef HAVE_SYS_STAT_H\n\n/* Define to 1 if you have the <sys/stropts.h> header file. */\n#undef HAVE_SYS_STROPTS_H\n\n/* Define to 1 if you have the <sys/times.h> header file. */\n#undef HAVE_SYS_TIMES_H\n\n/* Define to 1 if you have the <sys/time.h> header file. */\n#undef HAVE_SYS_TIME_H\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#undef HAVE_SYS_TYPES_H\n\n/* Define to 1 if you have the <sys/utsname.h> header file. */\n#undef HAVE_SYS_UTSNAME_H\n\n/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */\n#undef HAVE_SYS_WAIT_H\n\n/* Define to 1 if you have the <sys/xattr.h> header file. */\n#undef HAVE_SYS_XATTR_H\n\n/* Define to 1 if you have the `tcgetattr' function. */\n#undef HAVE_TCGETATTR\n\n/* Define to 1 if you have the `tcsetpgrp' function. */\n#undef HAVE_TCSETPGRP\n\n/* Define to 1 if you have the <termcap.h> header file. */\n#undef HAVE_TERMCAP_H\n\n/* Define to 1 if you have the <termios.h> header file. */\n#undef HAVE_TERMIOS_H\n\n/* Define to 1 if you have the <termio.h> header file. */\n#undef HAVE_TERMIO_H\n\n/* Define to 1 if you have the <term.h> header file. */\n#undef HAVE_TERM_H\n\n/* Define to 1 if you have the `tgamma' function. */\n#undef HAVE_TGAMMA\n\n/* Define to 1 if you have the `tgetent' function. */\n#undef HAVE_TGETENT\n\n/* Define to 1 if you have the `tigetflag' function. */\n#undef HAVE_TIGETFLAG\n\n/* Define to 1 if you have the `tigetnum' function. */\n#undef HAVE_TIGETNUM\n\n/* Define to 1 if you have the `tigetstr' function. */\n#undef HAVE_TIGETSTR\n\n/* Define to 1 if you have the `timelocal' function. */\n#undef HAVE_TIMELOCAL\n\n/* Define to 1 if you have the `uname' function. */\n#undef HAVE_UNAME\n\n/* Define to 1 if the compiler can initialise a union. */\n#undef HAVE_UNION_INIT\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#undef HAVE_UNISTD_H\n\n/* Define to 1 if you have the `unload' function. */\n#undef HAVE_UNLOAD\n\n/* Define to 1 if you have the `unlockpt' function. */\n#undef HAVE_UNLOCKPT\n\n/* Define to 1 if you have the `unsetenv' function. */\n#undef HAVE_UNSETENV\n\n/* Define to 1 if you have the `use_default_colors' function. */\n#undef HAVE_USE_DEFAULT_COLORS\n\n/* Define to 1 if you have the <utmpx.h> header file. */\n#undef HAVE_UTMPX_H\n\n/* Define to 1 if you have the <utmp.h> header file. */\n#undef HAVE_UTMP_H\n\n/* Define to 1 if you have the <varargs.h> header file. */\n#undef HAVE_VARARGS_H\n\n/* Define to 1 if compiler supports variable-length arrays */\n#undef HAVE_VARIABLE_LENGTH_ARRAYS\n\n/* Define to 1 if you have the `waddwstr' function. */\n#undef HAVE_WADDWSTR\n\n/* Define to 1 if you have the `wait3' function. */\n#undef HAVE_WAIT3\n\n/* Define to 1 if you have the `waitpid' function. */\n#undef HAVE_WAITPID\n\n/* Define to 1 if you have the <wchar.h> header file. */\n#undef HAVE_WCHAR_H\n\n/* Define to 1 if you have the `wctomb' function. */\n#undef HAVE_WCTOMB\n\n/* Define to 1 if you have the `wget_wch' function. */\n#undef HAVE_WGET_WCH\n\n/* Define to 1 if you have the `win_wch' function. */\n#undef HAVE_WIN_WCH\n\n/* Define to 1 if you have the `xw' function. */\n#undef HAVE_XW\n\n/* Define to 1 if you have the `_mktemp' function. */\n#undef HAVE__MKTEMP\n\n/* Define to 1 if you want to use dynamically loaded modules on HPUX 10. */\n#undef HPUX10DYNAMIC\n\n/* Define as const if the declaration of iconv() needs const. */\n#undef ICONV_CONST\n\n/* Define to 1 if iconv() is linked from libiconv */\n#undef ICONV_FROM_LIBICONV\n\n/* Define to 1 if ino_t is 64 bit (for large file support). */\n#undef INO_T_IS_64_BIT\n\n/* Define to 1 if we must include <sys/ioctl.h> to get a prototype for\n   ioctl(). */\n#undef IOCTL_IN_SYS_IOCTL\n\n/* Define to 1 if musl is being used as the C library */\n#undef LIBC_MUSL\n\n/* Definitions used when a long is less than eight byte, to try to provide\n   some support for eight byte operations. Note that ZSH_64_BIT_TYPE,\n   OFF_T_IS_64_BIT, INO_T_IS_64_BIT do *not* get defined if long is already 64\n   bits, since in that case no special handling is required. Define to 1 if\n   long is 64 bits */\n#undef LONG_IS_64_BIT\n\n/* Define to be the machine type (microprocessor class or machine model). */\n#undef MACHTYPE\n\n/* Define for Maildir support */\n#undef MAILDIR_SUPPORT\n\n/* Define for function depth limits */\n#undef MAX_FUNCTION_DEPTH\n\n/* Define to 1 if you want support for multibyte character sets. */\n#undef MULTIBYTE_SUPPORT\n\n/* Define to 1 if you have ospeed, but it is not defined in termcap.h */\n#undef MUST_DEFINE_OSPEED\n\n/* Define to 1 if you have no signal blocking at all (bummer). */\n#undef NO_SIGNAL_BLOCKING\n\n/* Define to 1 if off_t is 64 bit (for large file support) */\n#undef OFF_T_IS_64_BIT\n\n/* Define to be the name of the operating system. */\n#undef OSTYPE\n\n/* Define to the address where bug reports for this package should be sent. */\n#undef PACKAGE_BUGREPORT\n\n/* Define to the full name of this package. */\n#undef PACKAGE_NAME\n\n/* Define to the full name and version of this package. */\n#undef PACKAGE_STRING\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the home page for this package. */\n#undef PACKAGE_URL\n\n/* Define to the version of this package. */\n#undef PACKAGE_VERSION\n\n/* Define to the path of the /dev/fd filesystem. */\n#undef PATH_DEV_FD\n\n/* Define to be location of utmpx file. */\n#undef PATH_UTMPX_FILE\n\n/* Define to be location of utmp file. */\n#undef PATH_UTMP_FILE\n\n/* Define to be location of wtmpx file. */\n#undef PATH_WTMPX_FILE\n\n/* Define to be location of wtmp file. */\n#undef PATH_WTMP_FILE\n\n/* Define to 1 if you use POSIX style signal handling. */\n#undef POSIX_SIGNALS\n\n/* Define to 1 if printf and sprintf support %lld for long long. */\n#undef PRINTF_HAS_LLD\n\n/* Define to 1 if ANSI function prototypes are usable. */\n#undef PROTOTYPES\n\n/* Define if realpath() accepts NULL as its second argument. */\n#undef REALPATH_ACCEPTS_NULL\n\n/* Undefine this if you don't want to get a restricted shell when zsh is\n   exec'd with basename that starts with r. By default this is defined. */\n#undef RESTRICTED_R\n\n/* Define to 1 if RLIMIT_RSS and RLIMIT_AS both exist and are equal. */\n#undef RLIMIT_RSS_IS_AS\n\n/* Define to 1 if RLIMIT_VMEM and RLIMIT_AS both exist and are equal. */\n#undef RLIMIT_VMEM_IS_AS\n\n/* Define to 1 if RLIMIT_VMEM and RLIMIT_RSS both exist and are equal. */\n#undef RLIMIT_VMEM_IS_RSS\n\n/* Define to 1 if struct rlimit uses long long */\n#undef RLIM_T_IS_LONG_LONG\n\n/* Define to 1 if struct rlimit uses quad_t. */\n#undef RLIM_T_IS_QUAD_T\n\n/* Define to 1 if struct rlimit uses unsigned. */\n#undef RLIM_T_IS_UNSIGNED\n\n/* Define to 1 if select() is defined in <sys/socket.h>, ie BeOS R4.51 */\n#undef SELECT_IN_SYS_SOCKET_H\n\n/* If using the C implementation of alloca, define if you know the\n   direction of stack growth for your system; otherwise it will be\n   automatically deduced at runtime.\n\tSTACK_DIRECTION > 0 => grows toward higher addresses\n\tSTACK_DIRECTION < 0 => grows toward lower addresses\n\tSTACK_DIRECTION = 0 => direction of growth unknown */\n#undef STACK_DIRECTION\n\n/* Define to 1 if the `S_IS*' macros in <sys/stat.h> do not work properly. */\n#undef STAT_MACROS_BROKEN\n\n/* Define to 1 if you have the ANSI C header files. */\n#undef STDC_HEADERS\n\n/* Define to 1 if you use SYS style signal handling (and can block signals).\n   */\n#undef SYSV_SIGNALS\n\n/* Define to 1 if tgetent() accepts NULL as a buffer. */\n#undef TGETENT_ACCEPTS_NULL\n\n/* Define to what tgetent() returns on success (0 on HP-UX X/Open curses). */\n#undef TGETENT_SUCCESS\n\n/* Define if there is no prototype for the tgoto() terminal function. */\n#undef TGOTO_PROTO_MISSING\n\n/* Define if sys/time.h and sys/select.h cannot be both included. */\n#undef TIME_H_SELECT_H_CONFLICTS\n\n/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n#undef TIME_WITH_SYS_TIME\n\n/* Define to 1 if all the kit for using /dev/ptmx for ptys is available. */\n#undef USE_DEV_PTMX\n\n/* Define to 1 if you need to use the native getcwd. */\n#undef USE_GETCWD\n\n/* Define to 1 if h_errno is not defined by the system. */\n#undef USE_LOCAL_H_ERRNO\n\n/* Define to 1 if you want to allocate stack memory e.g. with `alloca'. */\n#undef USE_STACK_ALLOCATION\n\n/* Define to be a string corresponding the vendor of the machine. */\n#undef VENDOR\n\n/* Define if your should include sys/stream.h and sys/ptem.h. */\n#undef WINSIZE_IN_PTEM\n\n/* Define if getxattr() etc. require additional MacOS-style arguments */\n#undef XATTR_EXTRA_ARGS\n\n/* Define to 1 if the zlong type uses 64-bit long int. */\n#undef ZLONG_IS_LONG_64\n\n/* Define to 1 if the zlong type uses long long int. */\n#undef ZLONG_IS_LONG_LONG\n\n/* Define to a 64 bit integer type if there is one, but long is shorter. */\n#undef ZSH_64_BIT_TYPE\n\n/* Define to an unsigned variant of ZSH_64_BIT_TYPE if that is defined. */\n#undef ZSH_64_BIT_UTYPE\n\n/* Define to 1 if you want to get debugging information on internal hash\n   tables. This turns on the `hashinfo' builtin. */\n#undef ZSH_HASH_DEBUG\n\n/* Define to 1 if some variant of a curses header can be included */\n#undef ZSH_HAVE_CURSES_H\n\n/* Define to 1 if some variant of term.h can be included */\n#undef ZSH_HAVE_TERM_H\n\n/* Define to 1 if you want to turn on error checking for heap allocation. */\n#undef ZSH_HEAP_DEBUG\n\n/* Define to 1 if you want to use zsh's own memory allocation routines */\n#undef ZSH_MEM\n\n/* Define to 1 if you want to debug zsh memory allocation routines. */\n#undef ZSH_MEM_DEBUG\n\n/* Define to 1 if you want to turn on warnings of memory allocation errors */\n#undef ZSH_MEM_WARNING\n\n/* Define if _XOPEN_SOURCE_EXTENDED should not be defined to avoid clashes */\n#undef ZSH_NO_XOPEN\n\n/* Define to 1 if you want to turn on memory checking for free(). */\n#undef ZSH_SECURE_FREE\n\n/* Define to 1 if you want to add code for valgrind to debug heap memory. */\n#undef ZSH_VALGRIND\n\n/* Define to the base type of the third argument of accept */\n#undef ZSOCKLEN_T\n\n/* Enable large inode numbers on Mac OS X 10.5.  */\n#ifndef _DARWIN_USE_64_BIT_INODE\n# define _DARWIN_USE_64_BIT_INODE 1\n#endif\n\n/* Number of bits in a file offset, on hosts where this is settable. */\n#undef _FILE_OFFSET_BITS\n\n/* Define for large files, on AIX-style hosts. */\n#undef _LARGE_FILES\n\n/* Define to empty if `const' does not conform to ANSI C. */\n#undef const\n\n/* Define to `int' if <sys/types.h> doesn't define. */\n#undef gid_t\n\n/* Define to `unsigned long' if <sys/types.h> doesn't define. */\n#undef ino_t\n\n/* Define to `int' if <sys/types.h> does not define. */\n#undef mode_t\n\n/* Define to `long int' if <sys/types.h> does not define. */\n#undef off_t\n\n/* Define to `int' if <sys/types.h> does not define. */\n#undef pid_t\n\n/* Define to the type used in struct rlimit. */\n#undef rlim_t\n\n/* Define to `unsigned int' if <sys/types.h> or <signal.h> doesn't define */\n#undef sigset_t\n\n/* Define to `unsigned int' if <sys/types.h> does not define. */\n#undef size_t\n\n/* Define to `int' if <sys/types.h> doesn't define. */\n#undef uid_t\n",
        "/tmp/vanessa/spack-stage/spack-stage-zsh-5.6.2-in6fa74mnlid6t7rhhv7rn7bvrxkfdak/spack-src/configure.ac": "dnl\ndnl  configure.ac: Configure template for zsh.\ndnl  Process this file with autoconf to produce a configure script.\ndnl\ndnl  Copyright (c) 1995-1997 Richard Coleman\ndnl  All rights reserved.\ndnl\ndnl  Permission is hereby granted, without written agreement and without\ndnl  license or royalty fees, to use, copy, modify, and distribute this\ndnl  software and to distribute modified versions of this software for any\ndnl  purpose, provided that the above copyright notice and the following\ndnl  two paragraphs appear in all copies of this software.\ndnl\ndnl  In no event shall Richard Coleman or the Zsh Development Group be liable\ndnl  to any party for direct, indirect, special, incidental, or consequential\ndnl  damages arising out of the use of this software and its documentation,\ndnl  even if Richard Coleman and the Zsh Development Group have been advised of\ndnl  the possibility of such damage.\ndnl\ndnl  Richard Coleman and the Zsh Development Group specifically disclaim any\ndnl  warranties, including, but not limited to, the implied warranties of\ndnl  merchantability and fitness for a particular purpose.  The software\ndnl  provided hereunder is on an \"as is\" basis, and Richard Coleman and the\ndnl  Zsh Development Group have no obligation to provide maintenance,\ndnl  support, updates, enhancements, or modifications.\ndnl\n\nAC_INIT\nAC_CONFIG_SRCDIR([Src/zsh.h])\nAC_PREREQ([2.69])\nAC_CONFIG_HEADER(config.h)\n\ndnl What version of zsh are we building ?\n. ${srcdir}/Config/version.mk\necho \"configuring for zsh $VERSION\"\n\ndnl ----------------------------------------------\ndnl CHECK FOR MACHINE/VENDOR/OPERATING SYSTEM TYPE\ndnl ----------------------------------------------\ndnl Find out machine type, vendor, and operating system\ndnl What type of host is this?\nAC_CANONICAL_HOST\nAC_DEFINE_UNQUOTED(MACHTYPE, \"$host_cpu\",\n[Define to be the machine type (microprocessor class or machine model).])\nAC_DEFINE_UNQUOTED(VENDOR,   \"$host_vendor\",\n[Define to be a string corresponding the vendor of the machine.])\nAC_DEFINE_UNQUOTED(OSTYPE,   \"$host_os\",\n[Define to be the name of the operating system.])\n\ndnl -----------------------------\ndnl CHECKING COMMAND LINE OPTIONS\ndnl -----------------------------\ndnl Handle --program-prefix, --program-suffix, etc.\nzsh_ARG_PROGRAM\n\ndnl Handle setting of compile flags (CPPFLAGS, CFLAGS, LDFLAGS, LIBS).\nzsh_COMPILE_FLAGS($CPPFLAGS, $CFLAGS, $LDFLAGS, $LIBS)\n\ndnl Do you want to debug zsh?\nifdef([zsh-debug],[undefine([zsh-debug])])dnl\nAH_TEMPLATE([DEBUG],\n[Define to 1 if you want to debug zsh.])\nAC_ARG_ENABLE(zsh-debug,\nAS_HELP_STRING([--enable-zsh-debug],[compile with debug code and debugger symbols]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(DEBUG)\nfi])\n\ndnl Do you want zsh memory allocation routines.\nifdef([zsh-mem],[undefine([zsh-mem])])dnl\nAH_TEMPLATE([ZSH_MEM],\n[Define to 1 if you want to use zsh's own memory allocation routines])\nAC_ARG_ENABLE(zsh-mem,\nAS_HELP_STRING([--enable-zsh-mem],[compile with zsh memory allocation routines]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(ZSH_MEM)\nfi])\n\ndnl Do you want to debug zsh memory allocation routines.\nifdef([zsh-mem-debug],[undefine([zsh-mem-debug])])dnl\nAH_TEMPLATE([ZSH_MEM_DEBUG],\n[Define to 1 if you want to debug zsh memory allocation routines.])\nAC_ARG_ENABLE(zsh-mem-debug,\nAS_HELP_STRING([--enable-zsh-mem-debug],[debug zsh memory allocation routines]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(ZSH_MEM_DEBUG)\nfi])\n\ndnl Do you want to print warnings when errors in memory allocation.\nAH_TEMPLATE([ZSH_MEM_WARNING],\n[Define to 1 if you want to turn on warnings of memory allocation errors])\nifdef([zsh-mem-warning],[undefine([zsh-mem-warning])])dnl\nAC_ARG_ENABLE(zsh-mem-warning,\nAS_HELP_STRING([--enable-zsh-mem-warning],[print warnings for errors in memory allocation]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(ZSH_MEM_WARNING)\nfi])\n\ndnl Do you want to turn on error checking for free().\nifdef([zsh-secure-free],[undefine([zsh-secure-free])])dnl\nAH_TEMPLATE([ZSH_SECURE_FREE],\n[Define to 1 if you want to turn on memory checking for free().])\nAC_ARG_ENABLE(zsh-secure-free,\nAS_HELP_STRING([--enable-zsh-secure-free],[turn on error checking for free()]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(ZSH_SECURE_FREE)\nfi])\n\ndnl Do you want to debug zsh heap allocation?\ndnl Does not depend on zsh-mem.\nifdef([zsh-heap-debug],[undefine([zsh-heap-debug])])dnl\nAH_TEMPLATE([ZSH_HEAP_DEBUG],\n[Define to 1 if you want to turn on error checking for heap allocation.])\nAC_ARG_ENABLE(zsh-heap-debug,\nAS_HELP_STRING([--enable-zsh-heap-debug],[turn on error checking for heap allocation]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(ZSH_HEAP_DEBUG)\nfi])\n\ndnl Do you want to allow Valgrind to debug heap allocation?\nifdef([zsh-valgrind],[undefine([zsh-valgrind])])dnl\nAH_TEMPLATE([ZSH_VALGRIND],\n[Define to 1 if you want to add code for valgrind to debug heap memory.])\nAC_ARG_ENABLE(zsh-valgrind,\nAS_HELP_STRING([--enable-zsh-valgrind],[turn on support for valgrind debugging of heap memory]),\n[if test x$enableval = xyes;  then\n  AC_DEFINE(ZSH_VALGRIND)\nfi])\n\ndnl Do you want debugging information on internal hash tables.\ndnl This turns on the `hashinfo' builtin command.\nifdef([zsh-hash-debug],[undefine([zsh-hash-debug])])dnl\nAH_TEMPLATE([ZSH_HASH_DEBUG],\n[Define to 1 if you want to get debugging information on internal\n hash tables.  This turns on the `hashinfo' builtin.])\nAC_ARG_ENABLE(zsh-hash-debug,\nAS_HELP_STRING([--enable-zsh-hash-debug],[turn on debugging of internal hash tables]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(ZSH_HASH_DEBUG)\nfi])\n\ndnl Do you want to dynamically allocate memory on the stack where possible?\nifdef([stack-allocation],[undefine([stack-allocation])])dnl\nAH_TEMPLATE([USE_STACK_ALLOCATION],\n[Define to 1 if you want to allocate stack memory e.g. with `alloca'.])\nAC_ARG_ENABLE(stack-allocation,\nAS_HELP_STRING([--enable-stack-allocation],[allocate stack memory e.g. with `alloca']),\n[if test x$enableval = xyes; then\n  AC_DEFINE(USE_STACK_ALLOCATION)\nfi])\n\ndnl Pathnames for global zsh scripts\nifdef([etcdir],[undefine([etcdir])])dnl\nAC_ARG_ENABLE(etcdir,\nAS_HELP_STRING([--enable-etcdir=DIR],[the default directory for global zsh scripts]),\n[etcdir=\"$enableval\"], [etcdir=/etc])\n\nifdef([zshenv],[undefine([zshenv])])dnl\nAC_ARG_ENABLE(zshenv,\nAS_HELP_STRING([--enable-zshenv=FILE],[the full pathname of the global zshenv script]),\n[zshenv=\"$enableval\"],\n[if test \"x$etcdir\" = xno; then\n  zshenv=no\nelse\n  zshenv=\"$etcdir/zshenv\"\nfi])\nAH_TEMPLATE([GLOBAL_ZSHENV],\n[The global file to source absolutely first whenever zsh is run;\n if undefined, don't source anything.])\nif test \"x$zshenv\" != xno; then\n  AC_DEFINE_UNQUOTED(GLOBAL_ZSHENV, \"$zshenv\")\nfi\n\nifdef([zshrc],[undefine([zshrc])])dnl\nAC_ARG_ENABLE(zshrc,\nAS_HELP_STRING([--enable-zshrc=FILE],[the full pathname of the global zshrc script]),\n[zshrc=\"$enableval\"],\n[if test \"x$etcdir\" = xno; then\n  zshrc=no\nelse\n  zshrc=\"$etcdir/zshrc\"\nfi])\nAH_TEMPLATE([GLOBAL_ZSHRC],\n[The global file to source whenever zsh is run;\n if undefined, don't source anything])\nif test \"x$zshrc\" != xno; then\n  AC_DEFINE_UNQUOTED(GLOBAL_ZSHRC, \"$zshrc\")\nfi\n\nifdef([zprofile],[undefine([zprofile])])dnl\nAC_ARG_ENABLE(zprofile,\nAS_HELP_STRING([--enable-zprofile=FILE],[the full pathname of the global zprofile script]),\n[zprofile=\"$enableval\"],\n[if test \"x$etcdir\" = xno; then\n  zprofile=no\nelse\n  zprofile=\"$etcdir/zprofile\"\nfi])\nAH_TEMPLATE([GLOBAL_ZPROFILE],\n[The global file to source whenever zsh is run as a login shell,\n before zshrc is read; if undefined, don't source anything.])\nif test \"x$zprofile\" != xno; then\n  AC_DEFINE_UNQUOTED(GLOBAL_ZPROFILE, \"$zprofile\")\nfi\n\nifdef([zlogin],[undefine([zlogin])])dnl\nAC_ARG_ENABLE(zlogin,\nAS_HELP_STRING([--enable-zlogin=FILE],[the full pathname of the global zlogin script]),\n[zlogin=\"$enableval\"],\n[if test \"x$etcdir\" = xno; then\n  zlogin=no\nelse\n  zlogin=\"$etcdir/zlogin\"\nfi])\nAH_TEMPLATE([GLOBAL_ZLOGIN],\n[The global file to source whenever zsh is run as a login shell;\n if undefined, don't source anything])\nif test \"x$zlogin\" != xno; then\n  AC_DEFINE_UNQUOTED(GLOBAL_ZLOGIN, \"$zlogin\")\nfi\n\nifdef([zlogout],[undefine([zlogout])])dnl\nAC_ARG_ENABLE(zlogout,\nAS_HELP_STRING([--enable-zlogout=FILE],[the full pathname of the global zlogout script]),\n[zlogout=\"$enableval\"],\n[if test \"x$etcdir\" = xno; then\n  zlogout=no\nelse\n  zlogout=\"$etcdir/zlogout\"\nfi])\nAH_TEMPLATE([GLOBAL_ZLOGOUT],\n[The global file to source whenever zsh was run as a login shell.\n This is sourced right before exiting.  If undefined, don't source\n anything.])\nif test \"x$zlogout\" != xno; then\n  AC_DEFINE_UNQUOTED(GLOBAL_ZLOGOUT, \"$zlogout\")\nfi\n\nAC_SUBST(zshenv)dnl\nAC_SUBST(zshrc)dnl\nAC_SUBST(zprofile)dnl\nAC_SUBST(zlogin)dnl\nAC_SUBST(zlogout)dnl\n\ndnl Do you want dynamically loaded binary modules.\nifdef([dynamic],[undefine([dynamic])])dnl\nAC_ARG_ENABLE(dynamic,\nAS_HELP_STRING([--disable-dynamic],[turn off dynamically loaded binary modules]),\n[dynamic=\"$enableval\"], [dynamic=yes])\n\ndnl Do you want to disable restricted on r* commands\nifdef([restricted-r],[undefine([restricted-r])])dnl\nAH_TEMPLATE([RESTRICTED_R],\n[Undefine this if you don't want to get a restricted shell\n when zsh is exec'd with basename that starts with r.\n By default this is defined.])\nAC_ARG_ENABLE(restricted-r,\nAS_HELP_STRING([--disable-restricted-r],[turn off r* invocation for restricted shell]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(RESTRICTED_R)\nfi],\nAC_DEFINE(RESTRICTED_R)\n)\n\ndnl Do you want to disable use of locale functions\nAH_TEMPLATE([CONFIG_LOCALE],\n[Undefine if you don't want local features.  By default this is defined.])\nAC_ARG_ENABLE([locale],\nAS_HELP_STRING([--disable-locale],[turn off locale features]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(CONFIG_LOCALE)\nfi],\nAC_DEFINE(CONFIG_LOCALE)\n)\n\ndnl Do you want to compile as K&R C.\nAC_ARG_ENABLE(ansi2knr,\nAS_HELP_STRING([--enable-ansi2knr],[translate source to K&R C before compiling]),\n[ansi2knr=\"$enableval\"], [ansi2knr=default])\n\nifdef([runhelpdir],[undefine([runhelpdir])])dnl\nAC_ARG_ENABLE(runhelpdir,\nAS_HELP_STRING([--enable-runhelpdir=DIR],[the directory in which to install run-help files]),\n[if test x\"$enableval\" = xno; then\n  runhelpdir=\nelse\n  runhelpdir=\"$enableval\"\nfi], [runhelpdir=yes])\nif test x\"$runhelpdir\" = xyes; then\n  runhelpdir=${datadir}/${tzsh_name}/'${VERSION}'/help\nfi\nif test x\"$runhelpdir\" = x; then\n  runhelp=\nelse\n  runhelp=runhelp\nfi\n\nifdef([fndir],[undefine([fndir])])dnl\nAC_ARG_ENABLE(fndir,\nAS_HELP_STRING([--enable-fndir=DIR],[the directory in which to install functions]),\ndnl ${VERSION} to be determined at compile time.\n[if test x$enableval = xyes; then\n  fndir=${datadir}/${tzsh_name}/'${VERSION}'/functions\nelse\n  fndir=\"$enableval\"\nfi], [fndir=${datadir}/${tzsh_name}/'${VERSION}'/functions])\n\nifdef([sitefndir],[undefine([sitefndir])])dnl\nAC_ARG_ENABLE(site-fndir,\nAS_HELP_STRING([--enable-site-fndir=DIR],[same for site functions (not version specific)]),\n[if test x$enableval = xyes; then\n  sitefndir=${datadir}/${tzsh_name}/site-functions\nelse\n  sitefndir=\"$enableval\"\nfi], [sitefndir=${datadir}/${tzsh_name}/site-functions])\n\ndnl Add /usr/local/share/zsh/site-functions if not yet present\ndnl owing to $sitefndir, whether or not explicitly given.\ndnl If not explicitly given, it hasn't been expanded yet.\nif test X$sitefndir = X/usr/local/share/zsh/site-functions || \\\n   test X$sitefndir = Xno\nthen fixed_sitefndir=''\nelif test X$prefix != X/usr/local; then\n  if test X$prefix = XNONE && test X$ac_default_prefix = X/usr/local; then\n    if test X$tzsh_name != Xzsh\n    then fixed_sitefndir=/usr/local/share/zsh/site-functions\n    else fixed_sitefndir=''\n    fi\n  else fixed_sitefndir=/usr/local/share/zsh/site-functions\n  fi\nelif test X$tzsh_name != Xzsh\nthen fixed_sitefndir=/usr/local/share/zsh/site-functions\nelse fixed_sitefndir=''\nfi\n\nifdef([function_subdirs],[undefine([function_subdirs])])\nAC_ARG_ENABLE(function-subdirs,\nAS_HELP_STRING([--enable-function-subdirs],[install functions in subdirectories]))\n\nif test \"x${enable_function_subdirs}\" != x &&\n  test \"x${enable_function_subdirs}\" != xno; then\n  FUNCTIONS_SUBDIRS=yes\nelse\n  FUNCTIONS_SUBDIRS=no\nfi\n\nifdef([additionalfpath],[undefine([additionalfpath])])dnl\nAC_ARG_ENABLE(additional-fpath,\nAS_HELP_STRING([--enable-additional-fpath=DIR],[add directories to default function path]),\n[if test x$enableval = xyes; then\n  additionalfpath=\"\"\nelse\n  additionalfpath=\"${enableval}\"\nfi], [additionalfpath=\"\"])\n\nAC_SUBST(runhelpdir)dnl\nAC_SUBST(runhelp)dnl\nAC_SUBST(additionalfpath)dnl\nAC_SUBST(fndir)dnl\nAC_SUBST(sitefndir)dnl\nAC_SUBST(fixed_sitefndir)dnl\nAC_SUBST(FUNCTIONS_SUBDIRS)dnl\n\ndnl Directories for scripts such as newuser.\n\nifdef([scriptdir],[undefine([scriptdir])])dnl\nAC_ARG_ENABLE(scriptdir,\nAS_HELP_STRING([--enable-scriptdir=DIR],[the directory in which to install scripts]),\ndnl ${VERSION} to be determined at compile time.\n[if test x$enableval = xyes; then\n  scriptdir=${datadir}/${tzsh_name}/'${VERSION}'/scripts\nelse\n  scriptdir=\"$enableval\"\nfi], [scriptdir=${datadir}/${tzsh_name}/'${VERSION}'/scripts])\n\nifdef([sitescriptdir],[undefine([sitescriptdir])])dnl\nAC_ARG_ENABLE(site-scriptdir,\nAS_HELP_STRING([--enable-site-scriptdir=DIR],[same for site scripts (not version specific)]),\n[if test x$enableval = xyes; then\n  sitescriptdir=${datadir}/${tzsh_name}/scripts\nelse\n  sitescriptdir=\"$enableval\"\nfi], [sitescriptdir=${datadir}/${tzsh_name}/scripts])\n\nAC_SUBST(scriptdir)dnl\nAC_SUBST(sitescriptdir)dnl\n\ndnl htmldir is already handled, but if it wasn't set, use\ndnl the standard zsh default.\nif test x$htmldir = x'${docdir}' || test x$htmldir = x; then\n  htmldir='$(datadir)/$(tzsh)/htmldoc'\nfi\n\nAH_TEMPLATE([CUSTOM_PATCHLEVEL],\n[Define to a custom value for the ZSH_PATCHLEVEL parameter])\nAC_ARG_ENABLE(custom-patchlevel,\nAS_HELP_STRING([--enable-custom-patchlevel],[set a custom ZSH_PATCHLEVEL value]),\n[if test x$enableval != x && test x$enableval != xno; then\n  AC_DEFINE_UNQUOTED([CUSTOM_PATCHLEVEL], [\"$enableval\"])\nfi])\n\ndnl Do you want maildir support?\nifdef([maildir_support],[undefine([maildir_support])])dnl\nAH_TEMPLATE([MAILDIR_SUPPORT],\n[Define for Maildir support])\nAC_ARG_ENABLE(maildir-support,\nAS_HELP_STRING([--enable-maildir-support],[enable maildir support in MAIL and MAILPATH]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(MAILDIR_SUPPORT)\nfi])\n\ndnl Do you want to set a maximum function depth?\nifdef([max_function_depth],[undefine([max_function_depth])])dnl\nAH_TEMPLATE([MAX_FUNCTION_DEPTH],\n[Define for function depth limits])\nAC_ARG_ENABLE(max-function-depth,\nAS_HELP_STRING([--enable-max-function-depth=MAX],[limit function depth to MAX, default 500]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(MAX_FUNCTION_DEPTH, 500)\nelif test x$enableval != xno; then\n  AC_DEFINE_UNQUOTED(MAX_FUNCTION_DEPTH, $enableval)\nfi],\n[AC_DEFINE(MAX_FUNCTION_DEPTH, 500)]\n)\n\nifdef([default_readnullcmd],[undefine([default_readnullcmd])])dnl\nAH_TEMPLATE([DEFAULT_READNULLCMD],\n[Define default pager used by readnullcmd])\nAC_ARG_ENABLE(readnullcmd,\nAS_HELP_STRING([--enable-readnullcmd=PAGER],[pager used when READNULLCMD is not set]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(DEFAULT_READNULLCMD,\"more\")\nelif test x$enableval != xno; then\n  AC_DEFINE_UNQUOTED(DEFAULT_READNULLCMD,\"$enableval\")\nfi],\n[AC_DEFINE(DEFAULT_READNULLCMD,\"more\")]\n)\n\ndnl Do you want to look for pcre support?\nAC_ARG_ENABLE(pcre,\nAS_HELP_STRING([--enable-pcre],[enable the search for the pcre library (may create run-time library dependencies)]))\n\ndnl Do you want to look for capability support?\nAC_ARG_ENABLE(cap,\nAS_HELP_STRING([--enable-cap],[enable the search for POSIX capabilities (may require additional headers to be added by hand)]))\n\nAC_ARG_ENABLE(gdbm,\nAS_HELP_STRING([--disable-gdbm],[turn off search for gdbm library]),\n[gdbm=\"$enableval\"], [gdbm=yes])\n\ndnl ------------------\ndnl CHECK THE COMPILER\ndnl ------------------\ndnl We want these before the checks, so the checks can modify their values.\ntest -z \"${CFLAGS+set}\"  && CFLAGS=  auto_cflags=1\ntest -z \"${LDFLAGS+set}\" && LDFLAGS= auto_ldflags=1\n\nAC_PROG_CC\n\ndnl Check for large file support.\n\ndnl Gross hack for ReliantUNIX - GCC does not understand getconf options\ndnl For now just disable LFS in this case\ndnl Any takers?\nif test \"$host\" = mips-sni-sysv4 && test -n \"$GCC\"; then\n  : \nelse\n  AC_SYS_LARGEFILE\nfi\n\ndnl if the user hasn't specified CFLAGS, then\ndnl   if compiler is gcc, then use -O2 and some warning flags\ndnl   else use -O\nif test -n \"$auto_cflags\" && test .\"$ansi2knr\" != .yes; then\n  if test \"${enable_zsh_debug}\" = yes; then\n    if test -n \"$GCC\"; then\n      CFLAGS=\"$CFLAGS -Wall -Wmissing-prototypes -ggdb\"\n    else\n      CFLAGS=\"$CFLAGS -g\"\n    fi\n  else\n    if test -n \"$GCC\"; then\n      CFLAGS=\"$CFLAGS -Wall -Wmissing-prototypes -O2\"\n    else\n      CFLAGS=\"$CFLAGS -O\"\n    fi\n  fi\nfi\nif test -n \"$auto_ldflags\"; then\n  case \"${enable_zsh_debug}$host_os\" in\n    yesaix*|yeshpux*|yesnetbsd*|yesopenbsd*) ;;  # \"ld -g\" is not valid on these systems\n    darwin*) LDFLAGS=-Wl,-x ;;\n    yes*)    LDFLAGS=-g ;;\n    *)       LDFLAGS=-s ;;\n  esac\nfi\n\ndnl ----------\ndnl SCO KLUDGE\ndnl ----------\ndnl Sco doesn't define any useful compiler symbol,\ndnl so we will check for sco and define __sco if\ndnl found.\ncase \"$host_os\" in\n  sco*) CFLAGS=\"-D__sco $CFLAGS\" ;;\nesac\n\nsed=':1\n     s/ -s / /g\n     t1\n     s/^ *//\n     s/ *$//'\n\ncase \" $LDFLAGS \" in\n  *\" -s \"*) strip_exeldflags=true strip_libldflags=true\n    LDFLAGS=`echo \" $LDFLAGS \" | sed \"$sed\"` ;;\n  *) strip_exeldflags=false strip_libldflags=false ;;\nesac\n\ncase \" ${EXELDFLAGS+$EXELDFLAGS }\" in\n  \" \") ;;\n  *\" -s \"*) strip_exeldflags=true\n    EXELDFLAGS=`echo \" $EXELDFLAGS \" | sed \"$sed\"` ;;\n  *) strip_exeldflags=false ;;\nesac\n\ncase \" ${LIBLDFLAGS+$LIBLDFLAGS }\" in\n  \" \") ;;\n  *\" -s \"*) strip_libldflags=true\n    LIBLDFLAGS=`echo \" $LIBLDFLAGS \" | sed \"$sed\"` ;;\n  *) strip_libldflags=false ;;\nesac\n\nAC_SUBST(CFLAGS)dnl\nAC_SUBST(LDFLAGS)dnl\nAC_SUBST(EXELDFLAGS)dnl\nAC_SUBST(LIBLDFLAGS)dnl\n\nAC_PROG_CPP                 dnl Figure out how to run C preprocessor.\nAC_C_CONST                  dnl Does compiler support `const'.\n\ndnl Default preprocessing on Mac OS X produces warnings\ndnl Mac OS X 10.6 (darwin10.x.x) does not need this.\ncase \"$host_os\" in\n  darwin[[0-9]].*) CPP=\"$CPP -traditional-cpp\" ;;\nesac\n\nfp_PROG_CC_STDC\nAC_MSG_CHECKING([whether to use prototypes])\nif test .\"$ansi2knr\" = .yes || test .\"$ansi2knr\" = .no; then\n  msg=\"(overridden) \"\nelse\n  msg=\n  if test .\"$fp_cv_prog_cc_stdc\" = .no; then\n    ansi2knr=yes\n  else\n    ansi2knr=no\n  fi\nfi\nAH_TEMPLATE([PROTOTYPES],\n[Define to 1 if ANSI function prototypes are usable.])\nif test \"$ansi2knr\" = yes; then\n  AC_MSG_RESULT(${msg}no)\n  U=_\nelse\n  AC_MSG_RESULT(${msg}yes)\n  AC_DEFINE(PROTOTYPES)\n  U=\nfi\nAC_SUBST(U)\n\nAC_FUNC_ALLOCA              dnl Check how to get `alloca'.\n\ndnl If the compiler supports union initialisation\nAC_CACHE_CHECK(if the compiler supports union initialisation,\nzsh_cv_c_have_union_init,\n[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[union{void *p;long l;}u={0};]], [[u.l=1;]])],[zsh_cv_c_have_union_init=yes],[zsh_cv_c_have_union_init=no])])\nAH_TEMPLATE([HAVE_UNION_INIT],\n[Define to 1 if the compiler can initialise a union.])\nif test x$zsh_cv_c_have_union_init = xyes; then\n  AC_DEFINE(HAVE_UNION_INIT)\nfi\n\ndnl  Checking if compiler correctly cast signed to unsigned.\nAC_CACHE_CHECK(if signed to unsigned casting is broken,\nzsh_cv_c_broken_signed_to_unsigned_casting,\n[AC_RUN_IFELSE([AC_LANG_SOURCE([[main(){return((int)(unsigned char)((char) -1) == 255);}]])],[zsh_cv_c_broken_signed_to_unsigned_casting=yes],[zsh_cv_c_broken_signed_to_unsigned_casting=no],[zsh_cv_c_broken_signed_to_unsigned_casting=no])])\nAH_TEMPLATE([BROKEN_SIGNED_TO_UNSIGNED_CASTING],\n[Define to 1 if compiler incorrectly cast signed to unsigned.])\nif test x$zsh_cv_c_broken_signed_to_unsigned_casting = xyes; then\n  AC_DEFINE(BROKEN_SIGNED_TO_UNSIGNED_CASTING)\nfi\n\ndnl Checking if the compiler supports variable-length arrays\nAC_CACHE_CHECK(if the compiler supports variable-length arrays,\nzsh_cv_c_variable_length_arrays,\n[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[int foo(), n;]], [[int i[foo()], a[n+1];]])],[zsh_cv_c_variable_length_arrays=yes],[zsh_cv_c_variable_length_arrays=no])])\nAH_TEMPLATE([HAVE_VARIABLE_LENGTH_ARRAYS],\n[Define to 1 if compiler supports variable-length arrays])\nif test x$zsh_cv_c_variable_length_arrays = xyes; then\n  AC_DEFINE(HAVE_VARIABLE_LENGTH_ARRAYS)\nfi\n\ndnl ------------------\ndnl CHECK FOR PROGRAMS\ndnl ------------------\nAC_PROG_MAKE_SET            dnl Does make define $MAKE\nAC_PROG_INSTALL             dnl Check for BSD compatible `install'\nAC_PROG_AWK                 dnl Check for mawk,gawk,nawk, then awk.\nAC_PROG_LN                  dnl Check for working ln, for \"make install\"\nAC_PROG_LN_S                dnl Use ln -s/ln/cp for \"make install.runhelp\"\nAC_PROG_EGREP               dnl sets $EGREP to grep -E or egrep\nAC_CHECK_PROGS([YODL], [yodl], [: yodl])\n\nYODL_OPTIONS=''\nif test \"x$ac_cv_prog_YODL\" = xyodl; then\n    case `yodl --version` in\n      *\"version 2.\"*) YODL_OPTIONS='-k' ;;\n      *\"version 3.\"*) YODL_OPTIONS='-k -L' ;;\n      *\"version 4.\"*) YODL_OPTIONS='-k -L' ;;\n    esac\nfi\nAC_SUBST(YODL_OPTIONS)\n\nAC_CHECK_PROGS([TEXI2DVI], [texi2dvi], [: texi2dvi])\nAC_CHECK_PROGS([TEXI2PDF], [texi2pdf], [: texi2pdf])\nAC_CHECK_PROGS([TEXI2HTML], [texi2any texi2html], [: texi2html])\n\nif test x\"$TEXI2PDF\" != xtexi2pdf && test x\"$TEXI2DVI\" = xtexi2dvi; then\n  TEXI2PDF='texi2dvi --pdf'\nfi\n\nif test x\"$TEXI2HTML\" = xtexi2any; then\n  TEXI2HTML='texi2any -c TEXI2HTML=1'\nfi\n\ncase \"$LC_PAPER\" in\n  ??_US*) PAPERSIZE=us ;;\n  *)      PAPERSIZE=a4 ;;\nesac\nAC_SUBST(PAPERSIZE)\n\nAC_CHECK_PROGS([ANSI2KNR], [ansi2knr], [: ansi2knr])\n\nif test x\"$ansi2knr\" = xyes && test x\"$ANSI2KNR\" = x\": ansi2knr\"; then\n    echo \"----------\"\n    echo \"configure fatal error:\"\n    echo \"ansi2knr was specified (--enable-ansi2knr) but the program could not be found.\"\n    echo \"Either remove the configure option if it is not required or build the ansi2knr\"\n    echo \"program before reconfiguring Zsh.  The source code for ansi2knr is also\"\n    echo \"available in the GPL directory on Zsh distribution sites.\"\n    exit 1\nfi\n\ndnl ------------------\ndnl CHECK HEADER FILES\ndnl ------------------\nAC_HEADER_DIRENT\nAC_HEADER_STDC\nAC_HEADER_TIME\nAC_HEADER_STAT\nAC_HEADER_SYS_WAIT\n\noldcflags=\"$CFLAGS\"\nif test x$enable_pcre = xyes; then\nAC_CHECK_PROG([PCRECONF], pcre-config, pcre-config)\ndnl Typically (meaning on this single RedHat 9 box in front of me)\ndnl pcre-config --cflags produces a -I output which needs to go into\ndnl CPPFLAGS else configure's preprocessor tests don't pick it up,\ndnl producing a warning.\nif test \"x$ac_cv_prog_PCRECONF\" = xpcre-config; then\n  CPPFLAGS=\"$CPPFLAGS `pcre-config --cflags`\"\nfi\nfi\n\nAC_CHECK_HEADERS(sys/time.h sys/times.h sys/select.h termcap.h termio.h \\\n\t\t termios.h sys/param.h sys/filio.h string.h memory.h \\\n\t\t limits.h fcntl.h libc.h sys/utsname.h sys/resource.h \\\n\t\t locale.h errno.h stdio.h stdarg.h varargs.h stdlib.h \\\n\t\t unistd.h sys/capability.h \\\n\t\t utmp.h utmpx.h sys/types.h pwd.h grp.h poll.h sys/mman.h \\\n\t\t netinet/in_systm.h pcre.h langinfo.h wchar.h stddef.h \\\n\t\t sys/stropts.h iconv.h ncurses.h ncursesw/ncurses.h \\\n\t\t ncurses/ncurses.h)\nif test x$dynamic = xyes; then\n  AC_CHECK_HEADERS(dlfcn.h)\n  AC_CHECK_HEADERS(dl.h)\nfi\n\ndnl Some SCO systems cannot include both sys/time.h and sys/select.h\nAH_TEMPLATE([TIME_H_SELECT_H_CONFLICTS],\n[Define if sys/time.h and sys/select.h cannot be both included.])\nif test x$ac_cv_header_sys_time_h = xyes && test x$ac_cv_header_sys_select_h = xyes; then\n  AC_CACHE_CHECK(for conflicts in sys/time.h and sys/select.h,\n  zsh_cv_header_time_h_select_h_conflicts,\n  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/time.h>\n#include <sys/select.h>]], [[int i;]])],[zsh_cv_header_time_h_select_h_conflicts=no],[zsh_cv_header_time_h_select_h_conflicts=yes])])\n  if test x$zsh_cv_header_time_h_select_h_conflicts = xyes; then\n    AC_DEFINE(TIME_H_SELECT_H_CONFLICTS)\n  fi\nfi\n\nAH_TEMPLATE([GWINSZ_IN_SYS_IOCTL],\n[Define if TIOCGWINSZ is defined in sys/ioctl.h but not in termios.h.])\nif test x$ac_cv_header_termios_h = xyes; then\n  AC_CACHE_CHECK(TIOCGWINSZ in termios.h,\n  zsh_cv_header_termios_h_tiocgwinsz,\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#include <termios.h>]], [[int x = TIOCGWINSZ;]])],[zsh_cv_header_termios_h_tiocgwinsz=yes],[zsh_cv_header_termios_h_tiocgwinsz=no])])\nelse\n  zsh_cv_header_termios_h_tiocgwinsz=no\nfi\nif test x$zsh_cv_header_termios_h_tiocgwinsz = xno; then\n  AC_CACHE_CHECK(TIOCGWINSZ in sys/ioctl.h,\n  zsh_cv_header_sys_ioctl_h_tiocgwinsz,\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#include <sys/ioctl.h>]], [[int x = TIOCGWINSZ;]])],[zsh_cv_header_sys_ioctl_h_tiocgwinsz=yes],[zsh_cv_header_sys_ioctl_h_tiocgwinsz=no])])\n  if test x$zsh_cv_header_sys_ioctl_h_tiocgwinsz = xyes; then\n    AC_DEFINE(GWINSZ_IN_SYS_IOCTL)\n  fi\nfi\n \nAH_TEMPLATE([WINSIZE_IN_PTEM],\n[Define if your should include sys/stream.h and sys/ptem.h.])\nAC_CACHE_CHECK(for streams headers including struct winsize,\nac_cv_winsize_in_ptem,\n[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/stream.h>\n#include <sys/ptem.h>]], [[struct winsize wsz]])],[ac_cv_winsize_in_ptem=yes],[ac_cv_winsize_in_ptem=no])])\nif test x$ac_cv_winsize_in_ptem = xyes; then\n  AC_DEFINE(WINSIZE_IN_PTEM)\nfi\n\ndnl -------------------\ndnl CHECK FOR LIBRARIES\ndnl -------------------\n\ndnl On some systems, modules need to be linked against libc explicitly,\ndnl in case they require objects that exist only in the static version\ndnl and might not be compiled into the zsh executable.\ndnl On ReliantUNIX -lc better be the last library, else funny things\ndnl may happen.\nAC_CHECK_LIB(c, printf, [LIBS=\"$LIBS -lc\"])\n\nAC_CHECK_LIB(m, pow)\n\nAC_CHECK_LIB(rt, clock_gettime)\n\ndnl Various features of ncurses depend on having the right header\ndnl (the system's own curses.h may well not be good enough).\ndnl So don't search for ncurses unless we found the header.\nif test x$ac_cv_header_ncurses_h = xyes || test x$ac_cv_header_ncurses_ncurses_h = xyes || test x$ac_cv_header_ncursesw_ncurses_h = xyes; then\n  ncursesw_test=ncursesw\n  ncurses_test=ncurses\nelse\n  ncursesw_test=\n  ncurses_test=\nfi\n\ndnl Prefer BSD termcap library to SysV curses library, except on certain\ndnl SYSV-derived systems.  However, if we find terminfo and termcap\ndnl stuff in the same library we will use that; typically this\ndnl is ncurses or curses.\ndnl On pre-11.11 HPUX, Hcurses is reported to work better than curses.\ndnl Prefer ncurses to curses on all systems.  tinfo isn't very common now.\nAC_ARG_WITH(term-lib,\nAS_HELP_STRING([--with-term-lib=LIBS],[search space-separated LIBS for terminal handling]),\n[if test \"x$withval\" != xno && test \"x$withval\" != x ; then\n  termcap_curses_order=\"$withval\"\n  AC_SEARCH_LIBS(tigetstr, [$termcap_curses_order])\nelse\n  termcap_curses_order=\"$ncursesw_test tinfo termcap $ncurses_test curses\"\nfi],\n[case \"$host_os\" in\n  solaris*)\n   termcap_curses_order=\"$ncursesw_test $ncurses_test curses termcap\" ;;\n  hpux10.*|hpux11.*)\n   DL_EXT=\"${DL_EXT=sl}\"\n   termcap_curses_order=\"Hcurses $ncursesw_test $ncurses_test curses termcap\" ;;\n  *)\n   termcap_curses_order=\"$ncursesw_test tinfo termcap $ncurses_test curses\" ;;\nesac])dnl\n\nAH_TEMPLATE([ZSH_NO_XOPEN],\n[Define if _XOPEN_SOURCE_EXTENDED should not be defined to avoid clashes])\nAC_CACHE_CHECK(if _XOPEN_SOURCE_EXTENDED should not be defined,\nzsh_cv_no_xopen,\n[[case \"$host_os\" in\n  *freebsd5*|*freebsd6.[012]*|*aix*)\n  zsh_cv_no_xopen=yes\n  ;;\n  *)\n  zsh_cv_no_xopen=no\n  ;;\nesac]])\nif test x$zsh_cv_no_xopen = xyes; then\n  AC_DEFINE(ZSH_NO_XOPEN)\nfi\n\ndnl Check for tigetflag (terminfo) before tgetent (termcap).\ndnl That's so that on systems where termcap and [n]curses are\ndnl both available and both contain termcap functions, while\ndnl only [n]curses contains terminfo functions, we only link against\ndnl [n]curses.\nAC_SEARCH_LIBS(tigetflag, [$termcap_curses_order])\nAC_SEARCH_LIBS(tgetent, [$termcap_curses_order],\n  true,\n  AC_MSG_FAILURE([\"No terminal handling library was found on your system.\nThis is probably a library called 'curses' or 'ncurses'.  You may\nneed to install a package called 'curses-devel' or 'ncurses-devel' on your\nsystem.\"], 255))\nAC_CHECK_HEADERS(curses.h, [],\n[AC_CACHE_CHECK(for Solaris 8 curses.h mistake, ac_cv_header_curses_solaris,\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <curses.h>]], [[]])],[ac_cv_header_curses_h=yes\nac_cv_header_curses_solaris=yes],[ac_cv_header_curses_h=no\nac_cv_header_curses_solaris=no]))\nif test x$ac_cv_header_curses_solaris = xyes; then\nAC_DEFINE(HAVE_CURSES_H)\nfi])\n\ndnl If our terminal library is not ncurses, don't try including\ndnl any ncurses headers.\nAC_CACHE_CHECK(if we need to ignore ncurses, zsh_cv_ignore_ncurses,\n[case $LIBS in\n  *-lncurses*)\n  zsh_cv_ignore_ncurses=no\n  ;;\n  *)\n  zsh_cv_ignore_ncurses=yes\n  ;;\nesac])\n\nAC_SEARCH_LIBS(getpwnam, nsl)\n\ndnl I am told that told that unicos reqire these for nis_list\nif test `echo $host_os | sed 's/^\\(unicos\\).*/\\1/'` = unicos; then\n  LIBS=\"-lcraylm -lkrb -lnisdb -lnsl -lrpcsvc $LIBS\"\nfi\n\nif test \"x$dynamic\" = xyes; then\n  AC_CHECK_LIB(dl, dlopen)\nfi\n\nif test x$enable_cap = xyes; then\n  AC_CHECK_LIB(cap, cap_get_proc)\nfi\n\nAC_CHECK_LIB(socket, socket)\nAC_SEARCH_LIBS(gethostbyname2, bind)\n\ncase $LIBS in\n  *-lbind*)\n  AC_CHECK_HEADERS(bind/netdb.h)\n  ;;\nesac\n\ndnl ---------------\ndnl CHECK FOR ICONV\ndnl ---------------\n\ndnl Find iconv. It may be in libiconv and may be iconv() or libiconv()\nif test \"x$ac_cv_header_iconv_h\" = \"xyes\"; then\n  AC_CHECK_FUNC(iconv, ac_found_iconv=yes, ac_found_iconv=no)\n  if test \"x$ac_found_iconv\" = \"xno\"; then\n    AC_CHECK_LIB(iconv, iconv, ac_found_iconv=yes)\n    if test \"x$ac_found_iconv\" = \"xno\"; then\n      AC_CHECK_LIB(iconv, libiconv, ac_found_iconv=yes)\n    fi\n    if test \"x$ac_found_iconv\" != \"xno\"; then\n      LIBS=\"-liconv $LIBS\"\n    fi\n  else\n    dnl Handle case where there is a native iconv but iconv.h is from libiconv\n    AC_CHECK_DECL(_libiconv_version,\n      [ AC_CHECK_LIB(iconv, libiconv, LIBS=\"-liconv $LIBS\") ],,\n      [ #include <iconv.h> ])\n  fi\nfi\nAH_TEMPLATE([ICONV_FROM_LIBICONV],\n[Define to 1 if iconv() is linked from libiconv])\nif test \"x$ac_found_iconv\" = xyes; then\n  AC_DEFINE(HAVE_ICONV, 1, [Define if you have the iconv() function.])\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <iconv.h>]], [[int myversion = _libiconv_version]])],[AC_DEFINE(ICONV_FROM_LIBICONV)],[])\nfi\n\ndnl Check if iconv uses const in prototype declaration\nif test \"x$ac_found_iconv\" = \"xyes\"; then\n  AC_CACHE_CHECK(for iconv declaration, ac_cv_iconv_const,\n    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <stdlib.h>\n        #include <iconv.h>]],\n        [[#ifdef __cplusplus\n          \"C\"\n          #endif\n          #if defined(__STDC__) || defined(__cplusplus)\n          size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\n          #else\n          size_t iconv();\n          #endif]])],\n      [ac_cv_iconv_const=],\n      [ac_cv_iconv_const=const])])\n  AC_DEFINE_UNQUOTED([ICONV_CONST], $ac_cv_iconv_const,\n    [Define as const if the declaration of iconv() needs const.])\nfi\n\nif test x$enable_pcre = xyes; then\ndnl pcre-config should probably be employed here\ndnl AC_SEARCH_LIBS(pcre_compile, pcre)\n  LIBS=\"`$ac_cv_prog_PCRECONF --libs` $LIBS\"\nfi\n\ndnl ---------------------\ndnl CHECK TERMCAP LIBRARY\ndnl ---------------------\ndnl Checks for external variable ospeed in the termcap library.\nAC_CACHE_CHECK(if an include file defines ospeed,\nzsh_cv_decl_ospeed_include_defines,\n[AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <sys/types.h>\n#if HAVE_TERMIOS_H\n#include <termios.h>\n#endif\n#if HAVE_TERMCAP_H\n#include <termcap.h>\n#endif]], [[ospeed = 0;]])],[zsh_cv_decl_ospeed_include_defines=yes],[zsh_cv_decl_ospeed_include_defines=no])])\n\nif test x$zsh_cv_decl_ospeed_include_defines = xno; then\n  AC_CACHE_CHECK(if you must define ospeed,\n  zsh_cv_decl_ospeed_must_define,\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[extern short ospeed; ospeed = 0;]])],[zsh_cv_decl_ospeed_must_define=yes],[zsh_cv_decl_ospeed_must_define=no])])\nfi\n\nAH_TEMPLATE([HAVE_OSPEED],\n[Define to 1 if your termcap library has the ospeed variable])\nAH_TEMPLATE([MUST_DEFINE_OSPEED],\n[Define to 1 if you have ospeed, but it is not defined in termcap.h])\nif test x$zsh_cv_decl_ospeed_include_defines = xyes; then\n  AC_DEFINE(HAVE_OSPEED)\nelif test x$zsh_cv_decl_ospeed_must_define = xyes; then\n  AC_DEFINE(HAVE_OSPEED)\n  AC_DEFINE(MUST_DEFINE_OSPEED)\nfi\n\nif test x$gdbm != xno; then\n  AC_CHECK_HEADERS(gdbm.h)\n  AC_CHECK_LIB(gdbm, gdbm_open)\nfi\n\nAC_CHECK_HEADERS(sys/xattr.h)\n\ndnl --------------\ndnl CHECK TYPEDEFS\ndnl --------------\n\nAC_TYPE_PID_T\nAC_TYPE_OFF_T\nAC_CHECK_TYPE(ino_t, unsigned long)\nAC_TYPE_MODE_T\nAC_TYPE_UID_T\nAC_TYPE_SIZE_T\n\ndnl ------------------------------------------------\ndnl Check size of long and try to find a 64-bit type\ndnl ------------------------------------------------\ndnl AC_CHECK_SIZEOF is no good, because we need the result here,\ndnl and that doesn't seem to define a shell parameter.\nAC_CACHE_CHECK(if long is 64 bits, zsh_cv_long_is_64_bit,\n[AC_RUN_IFELSE([AC_LANG_SOURCE([[int main() { return sizeof(long) < 8; }]])],[zsh_cv_long_is_64_bit=yes],[zsh_cv_long_is_64_bit=no],[zsh_cv_long_is_64_bit=no])])\n\nAH_TEMPLATE([ino_t],\n[Define to `unsigned long' if <sys/types.h> doesn't define.])\nAH_TEMPLATE([LONG_IS_64_BIT],\n[Definitions used when a long is less than eight byte, to try to\n provide some support for eight byte operations.\n\n Note that ZSH_64_BIT_TYPE, OFF_T_IS_64_BIT, INO_T_IS_64_BIT do *not* get\n defined if long is already 64 bits, since in that case no special handling\n is required.\n\n Define to 1 if long is 64 bits])\nAH_TEMPLATE([ZSH_64_BIT_TYPE],\n[Define to a 64 bit integer type if there is one, but long is shorter.])\nAH_TEMPLATE([ZSH_64_BIT_UTYPE],\n[Define to an unsigned variant of ZSH_64_BIT_TYPE if that is defined.])\nAH_TEMPLATE([OFF_T_IS_64_BIT],\n[Define to 1 if off_t is 64 bit (for large file support)])\nAH_TEMPLATE([INO_T_IS_64_BIT],\n[Define to 1 if ino_t is 64 bit (for large file support).])\nif test x$zsh_cv_long_is_64_bit = xyes; then\n  AC_DEFINE(LONG_IS_64_BIT)\nelse\n  AC_CACHE_CHECK(if off_t is 64 bit, zsh_cv_off_t_is_64_bit,\n  [AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <sys/types.h>\n\nmain() { return sizeof(off_t) < 8; }\n]])],[zsh_cv_off_t_is_64_bit=yes],[zsh_cv_off_t_is_64_bit=no],[zsh_cv_off_t_is_64_bit=no])])\n  if test x$zsh_cv_off_t_is_64_bit = xyes; then\n    AC_DEFINE(OFF_T_IS_64_BIT)\n  fi\n\n  AC_CACHE_CHECK(if ino_t is 64 bit, zsh_cv_ino_t_is_64_bit,\n  [AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <sys/types.h>\n\nmain() { return sizeof(ino_t) < 8; }\n]])],[zsh_cv_ino_t_is_64_bit=yes],[zsh_cv_ino_t_is_64_bit=no],[zsh_cv_ino_t_is_64_bit=no])])\n  if test x$zsh_cv_ino_t_is_64_bit = xyes; then\n    AC_DEFINE(INO_T_IS_64_BIT)\n  fi\n\n  if test x$enable_largefile != xno -o x$zsh_cv_off_t_is_64_bit = xyes \\\n  -o $zsh_cv_ino_t_is_64_bit = yes; then\n    AC_CACHE_CHECK(if compiler has a 64 bit type, zsh_cv_64_bit_type,\n    [zsh_64_BIT_TYPE(long long, zsh_cv_64_bit_type)\n     if test \"$zsh_cv_64_bit_type\" = no; then\n       zsh_64_BIT_TYPE(quad_t, zsh_cv_64_bit_type)\n     fi\n     if test \"$zsh_cv_64_bit_type\" = no; then\n       zsh_64_BIT_TYPE(__int64_t, zsh_cv_64_bit_type)\n     fi\n     dnl As a last resort, if we know off_t has 64 bits, use that as\n     dnl the 64-bit integer type.  I don't dare try ino_t since there's\n     dnl probably nothing to stop that being unsigned.\n     if test \"$zsh_cv_64_bit_type\" = no &&\n        test \"$zsh_cv_off_t_is_64_bit\" = yes; then\n       zsh_64_BIT_TYPE(off_t, zsh_cv_64_bit_type)\n     fi])\n    if test \"$zsh_cv_64_bit_type\" != no; then\n      AC_DEFINE_UNQUOTED(ZSH_64_BIT_TYPE, $zsh_cv_64_bit_type)\n\n      dnl Handle cases where unsigned type cannot be simply\n      dnl `unsigned ZSH_64_BIT_TYPE'.  More tests may be required.\n      AC_CACHE_CHECK(for a corresponding unsigned 64 bit type,\n      zsh_cv_64_bit_utype,\n      [zsh_64_BIT_TYPE(unsigned $zsh_cv_64_bit_type, zsh_cv_64_bit_utype,\n       force)\n       if test \"$zsh_cv_64_bit_utype\" = no; then\n         zsh_64_BIT_TYPE(__uint64_t, zsh_cv_64_bit_utype)\n       fi])\n      if test \"$zsh_cv_64_bit_utype\" != no; then\n        AC_DEFINE_UNQUOTED(ZSH_64_BIT_UTYPE, $zsh_cv_64_bit_utype)\n      fi\n    fi\n  fi\nfi\nAH_TEMPLATE([ZLONG_IS_LONG_LONG],\n[Define to 1 if the zlong type uses long long int.])\nAH_TEMPLATE([ZLONG_IS_LONG_64],\n[Define to 1 if the zlong type uses 64-bit long int.])\nif test \"$zsh_cv_64_bit_type\" = \"long long\"; then\n  dnl Remember this so we can get (s)printf output right.\n  AC_DEFINE(ZLONG_IS_LONG_LONG)\nelse\n  if test \"$zsh_cv_64_bit_type\" = \"long\"; then\n      AC_DEFINE(ZLONG_IS_LONG_64)\n  fi\nfi\n\ndnl We'll blithely assume (f)printf supports the same types as sprintf.\nAC_CACHE_CHECK(for %lld printf support, zsh_cv_printf_has_lld,\n[AC_RUN_IFELSE([AC_LANG_SOURCE([[#include <stdio.h>\n#include <string.h>\nint main(int argc, char **argv)\n{\n   long long foo = ((long long)0xdead << 40) | 0xf00d;\n   char buf[80];\n   sprintf(buf, \"before%lldafter\", foo);\n   if (!strcmp(buf, \"before62677660341432333after\")) {\n      return 0;\n   }\n   return 1;\n}\n]])],[zsh_cv_printf_has_lld=yes],[zsh_cv_printf_has_lld=no],[zsh_cv_printf_has_lld=no])])\nAH_TEMPLATE(PRINTF_HAS_LLD,\n[Define to 1 if printf and sprintf support %lld for long long.])\nif test x$zsh_cv_printf_has_lld = xyes; then\n  AC_DEFINE(PRINTF_HAS_LLD)\nfi\n\ndnl Check for sigset_t.  Currently I'm looking in\ndnl <sys/types.h> and <signal.h>.  Others might need\ndnl to be added.\nAC_CACHE_CHECK(for sigset_t, zsh_cv_type_sigset_t,\n[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#define _POSIX_C_SOURCE 200809L\n#include <sys/types.h>\n#include <signal.h>]], [[sigset_t tempsigset;]])],[zsh_cv_type_sigset_t=yes],[zsh_cv_type_sigset_t=no])])\nAH_TEMPLATE([sigset_t],\n[Define to `unsigned int' if <sys/types.h> or <signal.h> doesn't define])\nif test x$zsh_cv_type_sigset_t = xno; then\n  AC_DEFINE(sigset_t, unsigned int)\nfi\n\ndnl check structures for high resolution timestamps\nAC_CHECK_MEMBERS([struct stat.st_atim.tv_nsec,\n                  struct stat.st_atimespec.tv_nsec,\n                  struct stat.st_atimensec,\n                  struct stat.st_mtim.tv_nsec,\n                  struct stat.st_mtimespec.tv_nsec,\n                  struct stat.st_mtimensec,\n                  struct stat.st_ctim.tv_nsec,\n                  struct stat.st_ctimespec.tv_nsec,\n                  struct stat.st_ctimensec])\n\ndnl Check for struct timezone since some old SCO versions do not define it\nzsh_TYPE_EXISTS([\n#define _GNU_SOURCE 1\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n], struct timezone)\n\ndnl Check for struct timespec since POSIX only gained it in 2008\nzsh_TYPE_EXISTS([\n#define _GNU_SOURCE 1\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n], struct timespec)\n\ndnl Check for utmp structures, for watch\nzsh_TYPE_EXISTS([\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_UTMP_H\n# include <utmp.h>\n#endif\n], struct utmp)\nzsh_TYPE_EXISTS([\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_UTMPX_H\n# include <utmpx.h>\n#endif\n], struct utmpx)\n\ndnl Check contents of utmp structures\nzsh_STRUCT_MEMBER([\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_UTMP_H\n# include <utmp.h>\n#endif\n], struct utmp, ut_host)\nzsh_STRUCT_MEMBER([\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_UTMPX_H\n# include <utmpx.h>\n#endif\n], struct utmpx, ut_host)\nzsh_STRUCT_MEMBER([\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_UTMPX_H\n# include <utmpx.h>\n#endif\n], struct utmpx, ut_xtime)\nzsh_STRUCT_MEMBER([\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_UTMPX_H\n# include <utmpx.h>\n#endif\n], struct utmpx, ut_tv)\n\ndnl Check for inode numbers in directory entry structures\nzsh_STRUCT_MEMBER([\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_DIRENT_H\n# include <dirent.h>\n#endif\n], struct dirent, d_ino)\nzsh_STRUCT_MEMBER([\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_DIRENT_H\n# include <dirent.h>\n#endif\n], struct dirent, d_stat)\nzsh_STRUCT_MEMBER([\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_NDIR_H\n# include <sys/ndir.h>\n#endif\n#ifdef HAVE_SYS_DIR_H\n# include <sys/dir.h>\n#endif\n#ifdef HAVE_NDIR_H\n# include <ndir.h>\n#endif\n], struct direct, d_ino)\nzsh_STRUCT_MEMBER([\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_NDIR_H\n# include <sys/ndir.h>\n#endif\n#ifdef HAVE_SYS_DIR_H\n# include <sys/dir.h>\n#endif\n#ifdef HAVE_NDIR_H\n# include <ndir.h>\n#endif\n], struct direct, d_stat)\n\ndnl Check IPv6 socket address structure type\nzsh_STRUCT_MEMBER([\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#include <netinet/in.h>\n], struct sockaddr_in6, sin6_scope_id)\n\ndnl Check for h_errno external variable\nAH_TEMPLATE([USE_LOCAL_H_ERRNO],\n[Define to 1 if h_errno is not defined by the system.])\nAC_CACHE_CHECK(if we need our own h_errno,\n  zsh_cv_decl_h_errno_use_local,\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[extern int h_errno; h_errno = 0;]])],[zsh_cv_decl_h_errno_use_local=no],[zsh_cv_decl_h_errno_use_local=yes])])\n\nif test x$zsh_cv_decl_h_errno_use_local = xyes; then\n  AC_DEFINE(USE_LOCAL_H_ERRNO)\nfi\n\ndnl ---------------\ndnl CHECK FUNCTIONS\ndnl ---------------\n\ndnl need to integrate this function\ndnl AC_FUNC_STRFTIME\n\nAC_CHECK_FUNCS(strftime strptime mktime timelocal \\\n\t       difftime gettimeofday clock_gettime \\\n\t       select poll \\\n\t       readlink faccessx fchdir ftruncate \\\n\t       fstat lstat lchown fchown fchmod \\\n\t       fseeko ftello \\\n\t       mkfifo _mktemp mkstemp \\\n\t       waitpid wait3 \\\n\t       sigaction sigblock sighold sigrelse sigsetmask sigprocmask \\\n\t       killpg setpgid setpgrp tcsetpgrp tcgetattr nice \\\n\t       gethostname gethostbyname2 getipnodebyname \\\n\t       inet_aton inet_pton inet_ntop \\\n\t       getlogin getpwent getpwnam getpwuid getgrgid getgrnam \\\n\t       initgroups nis_list \\\n\t       setuid seteuid setreuid setresuid setsid \\\n\t       memcpy memmove strstr strerror strtoul \\\n\t       getrlimit getrusage \\\n\t       setlocale \\\n\t       isblank iswblank \\\n\t       uname \\\n\t       signgam tgamma \\\n\t       log2 \\\n\t       scalbn \\\n\t       putenv getenv setenv unsetenv xw\\\n\t       brk sbrk \\\n\t       pathconf sysconf \\\n\t       tgetent tigetflag tigetnum tigetstr setupterm initscr resize_term \\\n\t       getcchar setcchar waddwstr wget_wch win_wch use_default_colors \\\n\t       pcre_compile pcre_study pcre_exec \\\n\t       nl_langinfo \\\n\t       erand48 open_memstream \\\n\t       posix_openpt \\\n\t       wctomb iconv \\\n\t       grantpt unlockpt ptsname \\\n\t       htons ntohs \\\n\t       regcomp regexec regerror regfree \\\n\t       gdbm_open getxattr \\\n\t       realpath canonicalize_file_name \\\n\t       symlink getcwd \\\n\t       cygwin_conv_path \\\n\t       nanosleep \\\n\t       srand_deterministic \\\n\t       setutxent getutxent endutxent getutent)\nAC_FUNC_STRCOLL\n\n# isinf() and isnan() can exist as either functions or macros.\nAH_TEMPLATE([HAVE_ISINF],\n  [Define to 1 if you have the `isinf' macro or function.])\nAC_MSG_CHECKING([for isinf])\nAC_LINK_IFELSE([AC_LANG_SOURCE(\n[[#include <math.h>\nint main () { return (isinf(1.0) != 0); }]])],\n  [AC_MSG_RESULT([yes])\n   AC_DEFINE([HAVE_ISINF])],\n  [AC_MSG_RESULT([no])])\n\nAH_TEMPLATE([HAVE_ISNAN],\n  [Define to 1 if you have the `isnan' macro or function.])\nAC_MSG_CHECKING([for isnan])\nAC_LINK_IFELSE([AC_LANG_SOURCE([[\n#include <math.h>\nint main () { return (isnan(1.0) != 0); }]])],\n  [AC_MSG_RESULT([yes])\n   AC_DEFINE([HAVE_ISNAN])],\n  [AC_MSG_RESULT([no])])\n\nAH_TEMPLATE([REALPATH_ACCEPTS_NULL],\n[Define if realpath() accepts NULL as its second argument.])\nAC_CACHE_CHECK([if realpath accepts NULL],\nzsh_cv_func_realpath_accepts_null,\n[AC_RUN_IFELSE([AC_LANG_PROGRAM([\n#include <stdlib.h>\n#include <limits.h>\n],[\nexit(!realpath(\"/\", (char*)0));\n])],\n[zsh_cv_func_realpath_accepts_null=yes],\n[zsh_cv_func_realpath_accepts_null=no],\n[zsh_cv_func_realpath_accepts_null=$ac_cv_func_canonicalize_file_name])])\nif test x$zsh_cv_func_realpath_accepts_null = xyes; then\n  AC_DEFINE(REALPATH_ACCEPTS_NULL)\nfi\n\nif test x$enable_cap = xyes; then\n  AC_CHECK_FUNCS(cap_get_proc)\nfi\n\ndnl  Check if tgetent accepts NULL (and will allocate its own termcap buffer)\ndnl  Some termcaps reportedly accept a zero buffer, but then dump core\ndnl  in tgetstr().\ndnl  Under Cygwin test program crashes but exit code is still 0. So,\ndnl  we test for a file that porgram should create\nAH_TEMPLATE([TGETENT_ACCEPTS_NULL],\n[Define to 1 if tgetent() accepts NULL as a buffer.])\nAC_CACHE_CHECK(if tgetent accepts NULL,\nzsh_cv_func_tgetent_accepts_null,\n[AC_RUN_IFELSE([AC_LANG_SOURCE([[\nmain()\n{\n    char buf[4096];\n    int r1 = tgetent(buf, \"vt100\");\n    int r2 = tgetent((char*)0,\"vt100\");\n    if (r1 >= 0 && r1 == r2) {\n        char tbuf[1024], *u;\n        u = tbuf;\n    \ttgetstr(\"cl\", &u);\n\tcreat(\"conftest.tgetent\", 0640);\n    }\n    exit((r1 != r2) || r2 == -1);\n}\n]])],[if test -f conftest.tgetent; then\n    zsh_cv_func_tgetent_accepts_null=yes\n  else\n    zsh_cv_func_tgetent_accepts_null=no\n  fi],[zsh_cv_func_tgetent_accepts_null=no],[zsh_cv_func_tgetent_accepts_null=no])])\nif test x$zsh_cv_func_tgetent_accepts_null = xyes; then\n  AC_DEFINE(TGETENT_ACCEPTS_NULL)\nfi\nAC_CACHE_CHECK(if tgetent returns 0 on success,\nzsh_cv_func_tgetent_zero_success,\n[AC_RUN_IFELSE([AC_LANG_SOURCE([[\nmain()\n{\n    char buf[4096];\n    int r1 = tgetent(buf, \"!@#$%^&*\");\n    int r2 = tgetent(buf, \"vt100\");\n    if (r1 < 0 && r2 == 0) {\n        char tbuf[1024], *u;\n        u = tbuf;\n    \ttgetstr(\"cl\", &u);\n\tcreat(\"conftest.tgetent0\", 0640);\n    }\n    exit(r1 == r2);\n}\n]])],[if test -f conftest.tgetent0; then\n    zsh_cv_func_tgetent_zero_success=yes\n  else\n    zsh_cv_func_tgetent_zero_success=no\n  fi],[zsh_cv_func_tgetent_zero_success=no],[zsh_cv_func_tgetent_zero_success=no])])\nAH_TEMPLATE([TGETENT_SUCCESS],\n[Define to what tgetent() returns on success (0 on HP-UX X/Open curses).])\nif test x$zsh_cv_func_tgetent_zero_success = xyes; then\n  AC_DEFINE(TGETENT_SUCCESS, 0)\nelse\n  AC_DEFINE(TGETENT_SUCCESS, 1)\nfi\n\nAC_FUNC_MMAP\nif test x$ac_cv_func_mmap_fixed_mapped = xyes; then\n  AC_CHECK_FUNCS(munmap msync)\nfi\n\nif test x$ac_cv_func_setpgrp = xyes; then\n  AC_FUNC_GETPGRP\nelse\n  dnl If there is no setpgrp, the test for getpgrp(void) will fail\n  dnl because the program will not compile.  However, in that case\n  dnl we can be reasonably confident we are not dealing with a\n  dnl Berkeleyesque system, so assume getpgrp does take void.\n  ac_cv_func_getpgrp_void=yes\n  AC_DEFINE(GETPGRP_VOID)\nfi\n\nif test x$dynamic = xyes; then\n  AC_CHECK_FUNCS(dlopen dlerror dlsym dlclose load loadquery loadbind unload \\\n\t\tshl_load shl_unload shl_findsym)\nfi\n\nAH_TEMPLATE([XATTR_EXTRA_ARGS],\nDefine if getxattr() etc. require additional MacOS-style arguments)\nif test x$ac_cv_func_getxattr = xyes && test x$ac_cv_header_sys_xattr_h = xyes\nthen\n  AC_CACHE_CHECK(if getxattr etc. are Linux-like,\n  zsh_cv_getxattr_linux,\n  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/types.h>\n#include <sys/xattr.h>]],\n  [[\n  (void)listxattr(\"\", 0, 0);\n  (void)getxattr(\"\", \"\", 0, 0);\n  (void)setxattr(\"\", \"\", \"\", 0, 0);\n  (void)removexattr(\"\", \"\");\n  ]])],\n  [zsh_cv_getxattr_linux=yes],\n  [zsh_cv_getxattr_linux=no])])\n\n  if test x$zsh_cv_getxattr_linux != xyes; then\n    AC_CACHE_CHECK(if getxattr etc. are MAC-like,\n    zsh_cv_getxattr_mac,\n    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/types.h>\n#include <sys/xattr.h>]],\n    [[(void)listxattr(\"\", 0, 0, 0);\n    (void)getxattr(\"\", \"\", 0, 0, 0, 0);\n    (void)setxattr(\"\", \"\", \"\", 0, 0, 0);\n    (void)removexattr(\"\", \"\", 0);]])],\n    [zsh_cv_getxattr_mac=yes],\n    [zsh_cv_getxattr_mac=no])])\n\n    if test x$zsh_cv_getxattr_mac = xyes; then\n      AC_DEFINE(XATTR_EXTRA_ARGS)\n    fi\n  fi\nfi\n\nAC_CACHE_CHECK(if getxattr etc. are usable,\nzsh_cv_use_xattr,\n[if test x$zsh_cv_getxattr_linux = xyes || test x$zsh_cv_getxattr_mac = xyes\nthen\nzsh_cv_use_xattr=yes\nelse\nzsh_cv_use_xattr=no\nfi])\n\ndnl -------------\ndnl CHECK SIGNALS\ndnl -------------\ndnl What style of signal do you have (POSIX, BSD, or SYSV)?\nAH_TEMPLATE([POSIX_SIGNALS],\n[Define to 1 if you use POSIX style signal handling.])\nAH_TEMPLATE([BSD_SIGNALS],\n[Define to 1 if you use BSD style signal handling (and can block signals).])\nAH_TEMPLATE([SYSV_SIGNALS],\n[Define to 1 if you use SYS style signal handling (and can block signals).])\nAH_TEMPLATE([NO_SIGNAL_BLOCKING],\n[Define to 1 if you have no signal blocking at all (bummer).])\nAC_MSG_CHECKING(what style of signals to use)\nif test x$ac_cv_func_sigaction = xyes && test x$ac_cv_func_sigprocmask = xyes; then\n  signals_style=POSIX_SIGNALS\n  AC_DEFINE(POSIX_SIGNALS)\nelif test x$ac_cv_func_sigblock = xyes && test x$ac_cv_func_sigsetmask = xyes; then\n  signals_style=BSD_SIGNALS\n  AC_DEFINE(BSD_SIGNALS)\nelif test x$ac_cv_func_sighold = xyes && test x$ac_cv_func_sigrelse = xyes; then\n  signals_style=SYSV_SIGNALS\n  AC_DEFINE(SYSV_SIGNALS)\nelse\n  signals_style=NO_SIGNAL_BLOCKING\n  AC_DEFINE(NO_SIGNAL_BLOCKING)\nfi\nAC_DEFINE_UNQUOTED($signals_style)\nAC_MSG_RESULT($signals_style)\n\ndnl Where is <signal.h> located?  Needed as input for signals.awk\nAC_CACHE_CHECK(where signal.h is located, zsh_cv_path_signal_h,\n[dnl Look at the output from the preprocessor.\ndnl We should get lines of the form `# 1 \"/usr/include/signal.h\"'\ndnl The following assumes the real definitions are in a file which\ndnl contains the name `sig'; we could relax this if necessary,\ndnl but then you can get a rather long list of files to test.\ndnl The backslash substitution is to persuade cygwin to cough up\ndnl slashes rather than doubled backslashes in the path.\necho \"#include <signal.h>\" > nametmp.c\nsigfile_list=\"`$CPP $CPPFLAGS nametmp.c |\nsed -n -e 's/^#line[ \t].*\\\"\\(.*\\)\\\"/\\1/p' \\\n       -e 's/^#[ \t].*\\\"\\(.*\\)\\\"/\\1/p' |\nsed 's/\\\\\\\\\\\\\\\\/\\//g' |\n$AWK '{ if ($1 ~ /sig/) files[[$1]] = $1 }\n  END { for (var in files) print var }'`\"\nrm -f nametmp.c\nif test -z \"$sigfile_list\"; then\n  dnl In case we don't get the stuff from the preprocesor, use the old\n  dnl list of standard places.\n  sigfile_list=\"/usr/include/sys/iso/signal_iso.h\n/usr/include/bsd/sys/signal.h\n/usr/include/signum.h\n/usr/include/asm/signum.h\n/usr/include/asm/signal.h\n/usr/include/linux/signal.h\n/usr/include/sys/signal.h\n/usr/include/bits/signum.h\n/dev/null\"\nfi\nfor SIGNAL_TRY_H in $sigfile_list\ndo\n  dnl Try to make sure it doesn't get confused by files that don't\n  dnl have real signal definitions in, but do #define SIG* by counting\n  dnl the number of signals.  Maybe we could even check for e.g. SIGHUP?\n  nsigs=`test -f $SIGNAL_TRY_H && \\\n  grep '#[ \t]*define[ \t][ \t]*SIG[0-9A-Z]*[ \t]*[0-9][0-9]*' $SIGNAL_TRY_H | \\\n  wc -l | sed 's/[ \t]//g'`\n  if test \"x$nsigs\" != x && test \"$nsigs\" -ge 7\n  then\n    SIGNAL_H=\"$SIGNAL_H $SIGNAL_TRY_H\"\n  fi\ndone\nif test \"x$SIGNAL_H\" = x; then\n  AC_MSG_ERROR(SIGNAL MACROS NOT FOUND:  please report to developers)\nfi\nzsh_cv_path_signal_h=\"$SIGNAL_H\"\n])\nSIGNAL_H=\"$zsh_cv_path_signal_h\"\nAC_SUBST(SIGNAL_H)dnl\n\ndnl Where are error names located?  Needed as input for errnames1.awk\nAC_CACHE_CHECK(where error names are located, zsh_cv_path_errno_h,\n[dnl Look at the output from the preprocessor.\ndnl We should get lines of the form `# 1 \"/usr/include/errno.h\"'\ndnl The following assumes the real definitions are in a file which\ndnl contains the name `err'; we could relax this if necessary,\ndnl but then you can get a rather long list of files to test.\ndnl The backslash substitution is to persuade cygwin to cough up\ndnl slashes rather than doubled backslashes in the path.\necho \"#include <errno.h>\" > nametmp.c\nerrfile_list=\"`$CPP $CPPFLAGS nametmp.c |\nsed -n -e 's/^#line[ \t].*\\\"\\(.*\\)\\\"/\\1/p' \\\n       -e 's/^#[ \t0-9].*\\\"\\(.*\\)\\\"/\\1/p' |\nsed 's/\\\\\\\\\\\\\\\\/\\//g' |\n$AWK '{ if ($1 ~ /err/) files[[$1]] = $1 }\n  END { for (var in files) print var }'`\"\nrm -f nametmp.c\nfor ERRNO_TRY_H in $errfile_list /dev/null\ndo\n  dnl Try to make sure it doesn't get confused by files that don't\n  dnl have real error definitions in.  Count definitions to make sure.\n  dnl Definitions of error numbers have become more and more general, so\n  dnl make a list of files containing any definitions in and keep them all.\n  dnl Careful with cut and paste in the pattern: the square brackets\n  dnl must contain a space and a tab.\n  nerrs=`test -f $ERRNO_TRY_H && \\\n  $EGREP '#[ \t]*define[ \t][ \t]*E[0-9A-Z]*[ \t]*(_HURD_ERRNO )?\\(?[_A-Z0-9]' $ERRNO_TRY_H | \\\n  wc -l | sed 's/[ \t]//g'`\n  if test \"x$nerrs\" != x && test \"$nerrs\" -ge 1\n  then\n    ERRNO_H=\"$ERRNO_H $ERRNO_TRY_H\"\n  fi\ndone\nif test x\"$ERRNO_H\" = x; then\n  AC_MSG_ERROR(ERROR MACROS NOT FOUND:  please report to developers)\nfi\nzsh_cv_path_errno_h=\"$ERRNO_H\"\n])\nERRNO_H=\"$zsh_cv_path_errno_h\"\nAC_SUBST(ERRNO_H)dnl\n\nAC_CACHE_CHECK(location of curses header, zsh_cv_path_curses_header,\n[if test x$zsh_cv_ignore_ncurses = xyes; then\n  if test x$ac_cv_header_curses_h = xyes; then\n    zsh_cv_path_curses_header=curses.h\n  else\n    zsh_cv_path_curses_header=none\n  fi\nelif test x$ac_cv_header_ncursesw_ncurses_h = xyes; then\n  zsh_cv_path_curses_header=ncursesw/ncurses.h\nelif test x$ac_cv_header_ncurses_ncurses_h = xyes; then\n  zsh_cv_path_curses_header=ncurses/ncurses.h\nelif test x$ac_cv_header_ncurses_h = xyes; then\n  zsh_cv_path_curses_header=ncurses.h\nelif test x$ac_cv_header_curses_h = xyes; then\n  zsh_cv_path_curses_header=curses.h\nelse\n  zsh_cv_path_curses_header=none\nfi])\nAH_TEMPLATE([ZSH_HAVE_CURSES_H],\n[Define to 1 if some variant of a curses header can be included])\nif test x$zsh_cv_path_curses_header != xnone; then\n  AC_DEFINE(ZSH_HAVE_CURSES_H)\n  ZSH_CURSES_H=$zsh_cv_path_curses_header\nelse\n  ZSH_CURSES_H=\nfi\nAC_SUBST(ZSH_CURSES_H)\n\ndnl Where are curses key definitions located?  Need for keypad() mode.\nAC_CACHE_CHECK(where curses key definitions are located, zsh_cv_path_curses_keys_h,\n[dnl This is an identical trick to errno.h, except we use ncurses.h\ndnl if we can.\nif test x$zsh_cv_path_curses_header = xnone; then\n  echo >nametmp.c\nelse\n  echo \"#include <$zsh_cv_path_curses_header>\" >nametmp.c\nfi\n\ncurses_list=\"`$CPP $CPPFLAGS nametmp.c |\nsed -n -e 's/^#line[ \t].*\\\"\\(.*\\)\\\"/\\1/p' \\\n       -e 's/^#[ \t0-9].*\\\"\\(.*\\)\\\"/\\1/p' |\nsed 's/\\\\\\\\\\\\\\\\/\\//g' |\n$AWK '{ if ($1 ~ /\\.h/) files[[$1]] = $1 }\n  END { for (var in files) print var }'`\"\nrm -f nametmp.c\nfor CURSES_TRY_H in $curses_list /dev/null\ndo\n  nkeys=`test -f $CURSES_TRY_H && \\\n  $EGREP '#[ \t]*define[ \t][ \t]*KEY_' $CURSES_TRY_H | \\\n  wc -l | sed 's/[ \t]//g'`\n  if test \"x$nkeys\" != x && test \"$nkeys\" -ge 10\n  then\n    CURSES_KEYS_H=$CURSES_TRY_H\n    break\n  fi\ndone\nzsh_cv_path_curses_keys_h=\"$CURSES_KEYS_H\"\n])\nCURSES_KEYS_H=\"$zsh_cv_path_curses_keys_h\"\nAC_SUBST(CURSES_KEYS_H)dnl\n\ndnl See if there are variants of term.h.  For testing each one\ndnl we include the most likely variant of the curses header.\nAC_CHECK_HEADERS(ncursesw/term.h,\ntrue, true,\n[#include <ncursesw/ncurses.h>])\nAC_CHECK_HEADERS(ncurses/term.h,\ntrue, true,\n[#include <ncurses/ncurses.h>])\nAC_CHECK_HEADERS(term.h,\ntrue, true,\n[#include <curses.h>])\n\ndnl See if term.h is bundled along with the curses library we\ndnl are using.  If this isn't the default system curses, compilation\ndnl could barf unless we include from the right subdirectory.\nAC_CACHE_CHECK(where term.h is located, zsh_cv_path_term_header,\n[case x$zsh_cv_path_curses_header in\n  xncursesw/*)\n  if test x$ac_cv_header_ncursesw_term_h = xyes; then\n    zsh_cv_path_term_header=ncursesw/term.h\n  fi\n  ;;\n  xncurses/*)\n  if test x$ac_cv_header_ncurses_term_h = xyes; then\n    zsh_cv_path_term_header=ncurses/term.h\n  fi\n  ;;\nesac\nif test x$zsh_cv_path_term_header = x; then\n  if test x$ac_cv_header_term_h = xyes; then\n    zsh_cv_path_term_header=term.h\n  else\n    zsh_cv_path_term_header=none\n  fi\nfi])\n\nAH_TEMPLATE([ZSH_HAVE_TERM_H],\n[Define to 1 if some variant of term.h can be included])\nAH_TEMPLATE([HAVE_BOOLCODES],\n[Define if you have the termcap boolcodes symbol.])\nAH_TEMPLATE([HAVE_NUMCODES],\n[Define if you have the termcap numcodes symbol.])\nAH_TEMPLATE([HAVE_STRCODES],\n[Define if you have the termcap strcodes symbol.])\nAH_TEMPLATE([HAVE_BOOLNAMES],\n[Define if you have the terminfo boolnames symbol.])\nAH_TEMPLATE([HAVE_NUMNAMES],\n[Define if you have the terminfo numnames symbol.])\nAH_TEMPLATE([HAVE_STRNAMES],\n[Define if you have the terminfo strnames symbol.])\nAH_TEMPLATE([TGOTO_PROTO_MISSING],\n[Define if there is no prototype for the tgoto() terminal function.])\n\nif test x$zsh_cv_path_term_header != xnone; then\n  AC_DEFINE(ZSH_HAVE_TERM_H)\n  ZSH_TERM_H=$zsh_cv_path_term_header\n  if test x$zsh_cv_path_curses_header != xnone; then\n    term_includes=\"#include <$zsh_cv_path_curses_header>\n#include <$zsh_cv_path_term_header>\"\n  else\n    term_includes=\"#include <$zsh_cv_path_term_header>\"\n  fi\n\n  AC_MSG_CHECKING(if boolcodes is available)\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([[$term_includes]], [[char **test = boolcodes; puts(*test);]])],[AC_DEFINE(HAVE_BOOLCODES) boolcodes=yes],[boolcodes=no])\n  AC_MSG_RESULT($boolcodes)\n\n  AC_MSG_CHECKING(if numcodes is available)\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([[$term_includes]], [[char **test = numcodes; puts(*test);]])],[AC_DEFINE(HAVE_NUMCODES) numcodes=yes],[numcodes=no])\n  AC_MSG_RESULT($numcodes)\n\n  AC_MSG_CHECKING(if strcodes is available)\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([[$term_includes]], [[char **test = strcodes; puts(*test);]])],[AC_DEFINE(HAVE_STRCODES) strcodes=yes],[strcodes=no])\n  AC_MSG_RESULT($strcodes)\n\n  AC_MSG_CHECKING(if boolnames is available)\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([[$term_includes]], [[char **test = boolnames; puts(*test);]])],[AC_DEFINE(HAVE_BOOLNAMES) boolnames=yes],[boolnames=no])\n  AC_MSG_RESULT($boolnames)\n\n  AC_MSG_CHECKING(if numnames is available)\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([[$term_includes]], [[char **test = numnames; puts(*test);]])],[AC_DEFINE(HAVE_NUMNAMES) numnames=yes],[numnames=no])\n  AC_MSG_RESULT($numnames)\n\n  AC_MSG_CHECKING(if strnames is available)\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([[$term_includes]], [[char **test = strnames; puts(*test);]])],[AC_DEFINE(HAVE_STRNAMES) strnames=yes],[strnames=no])\n  AC_MSG_RESULT($strnames)\n\n  dnl There are apparently defective terminal library headers on some\n  dnl versions of Solaris before 11.\n  AC_MSG_CHECKING(if tgoto prototype is missing)\n  tgoto_includes=\"$term_includes\n/* guaranteed to clash with any valid tgoto prototype */\nextern void tgoto(int **stuff, float **more_stuff);\"\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([[$tgoto_includes]], [[int *stuff; float *more_stuff; tgoto(&stuff, &more_stuff);]])],[AC_DEFINE(TGOTO_PROTO_MISSING) tgotoprotomissing=yes],[tgotoprotomissing=no])\n  AC_MSG_RESULT($tgotoprotomissing)\nelse\n  ZSH_TERM_H=\nfi\nAC_SUBST(ZSH_TERM_H)\n\n\ndnl -----------------------------------------------------\ndnl Look for the file containing the RLIMIT_* definitions\ndnl -----------------------------------------------------\ndnl CALL FOR MORE (FEWER?) LOCATIONS:  I've just copied the signal checking.\nAC_CACHE_CHECK(where the RLIMIT macros are located,zsh_cv_path_rlimit_h,\n[dnl Look at the output from the preprocessor.\ndnl Copied from the search for the signal names above.\necho \"#include <sys/resource.h>\" >restmp.c\nresourcefile_list=\"`$CPP $CPPFLAGS restmp.c |\nsed -n -e 's/^#line[ \t].*\\\"\\(.*\\)\\\"/\\1/p' \\\n       -e 's/^#[ \t].*\\\"\\(.*\\)\\\"/\\1/p' |\nsed 's/\\\\\\\\\\\\\\\\/\\//g' |\n$AWK '{ if ($1 ~ /resource/) files[[$1]] = $1 }\n  END { for (var in files) print var }'`\"\nrm -f restmp.c\nif test -z \"$resourcefile_list\"; then\n  dnl No list: look at standard places.\n  resourcefile_list=\"/usr/include/bsd/sys/resource.h\n/usr/include/asm/resource.h\n/usr/include/linux/resource.h\n/usr/include/sys/resource.h\n/usr/include/bits/resource.h\n/usr/include/resourcebits.h\"\nfi\nfor RESOURCE_H in $resourcefile_list /dev/null;\ndo\n  test -f $RESOURCE_H && \\\n  grep '#[ \t]*define[ \t][ \t]*RLIMIT_[A-Z]*[ \t]*[0-9A-Z][0-9]*' $RESOURCE_H > /dev/null && \\\n  break\ndone\nzsh_cv_path_rlimit_h=$RESOURCE_H\nif test x$RESOURCE_H = x\"/dev/null\" && test x$ac_cv_func_getrlimit = xyes; then\n  AC_MSG_WARN(RLIMIT MACROS NOT FOUND:  please report to developers)\nfi])\nRLIMITS_INC_H=$zsh_cv_path_rlimit_h\nif test \"$RLIMITS_INC_H\" = \"/dev/null\"; then\n  RLIMITS_INC_H=''\nfi\ndnl rlimits.h only appears in dependencies if we are actually using it.\ndnl We are using it any time we have getrlimit, though if the macros were\ndnl not found we simply awk through /dev/null and fail to find them.\ndnl Thus, limit won't work, but at least the shell will compile.\nAC_SUBST(RLIMITS_INC_H)dnl\n\ndnl ------------------\ndnl rlimit type checks\ndnl ------------------\nAH_TEMPLATE([RLIM_T_IS_QUAD_T],\n[Define to 1 if struct rlimit uses quad_t.])\nAH_TEMPLATE([RLIM_T_IS_LONG_LONG],\n[Define to 1 if struct rlimit uses long long])\nAH_TEMPLATE([RLIM_T_IS_UNSIGNED],\n[Define to 1 if struct rlimit uses unsigned.])\nAH_TEMPLATE([rlim_t],\n[Define to the type used in struct rlimit.])\nDEFAULT_RLIM_T=long\nAC_CACHE_CHECK(if rlim_t is longer than a long,\nzsh_cv_rlim_t_is_longer,\n[AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include <sys/resource.h>\nmain(){struct rlimit r;exit(sizeof(r.rlim_cur) <= sizeof(long));}]])],[zsh_cv_rlim_t_is_longer=yes],[zsh_cv_rlim_t_is_longer=no],[zsh_cv_rlim_t_is_longer=yes])])\nif test x$zsh_cv_rlim_t_is_longer = xyes; then\n  AC_CACHE_CHECK(if rlim_t is a quad,\n  zsh_cv_rlim_t_is_quad_t,\n  [AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include <stdio.h>\n#include <sys/resource.h>\nmain() { \n  struct rlimit r;\n  char buf[20];\n  r.rlim_cur = 0;\n  sprintf(buf, \"%qd\", r.rlim_cur);\n  exit(strcmp(buf, \"0\"));\n}]])],[zsh_cv_rlim_t_is_quad_t=yes],[zsh_cv_rlim_t_is_quad_t=no],[zsh_cv_rlim_t_is_quad_t=no])])\n  if test x$zsh_cv_rlim_t_is_quad_t = xyes; then\n    AC_DEFINE(RLIM_T_IS_QUAD_T)\n    DEFAULT_RLIM_T=quad_t\n  else\n    AC_DEFINE(RLIM_T_IS_LONG_LONG)\n    DEFAULT_RLIM_T='long long'\n  fi\nelse\n  AC_CACHE_CHECK(if the rlim_t is unsigned,\n  zsh_cv_type_rlim_t_is_unsigned,\n  [AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include <sys/resource.h>\n  main(){struct rlimit r;r.rlim_cur=-1;exit(r.rlim_cur<0);}]])],[zsh_cv_type_rlim_t_is_unsigned=yes],[zsh_cv_type_rlim_t_is_unsigned=no],[zsh_cv_type_rlim_t_is_unsigned=no])])\n  if test x$zsh_cv_type_rlim_t_is_unsigned = xyes; then\n    AC_DEFINE(RLIM_T_IS_UNSIGNED)\n    DEFAULT_RLIM_T=\"unsigned $DEFAULT_RLIM_T\"\n  fi\nfi\n\nAC_CACHE_CHECK(for rlim_t, zsh_cv_type_rlim_t,\n[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include <sys/resource.h>]], [[rlim_t l;]])],[zsh_cv_type_rlim_t=yes],[zsh_cv_type_rlim_t=no])])\nif test x$zsh_cv_type_rlim_t = xno; then\n  AC_DEFINE_UNQUOTED(rlim_t, $DEFAULT_RLIM_T)\nfi\n\n\ndnl On some systems the RLIMIT_* don't evaluate to integers at compile time\ndnl (they may be enums).  In this case we are not able to do preprocessor\ndnl comparisons and need our tests to determine what values exist and\ndnl if there are clashing definitions.\n\nzsh_LIMIT_PRESENT(RLIMIT_AIO_MEM)\nzsh_LIMIT_PRESENT(RLIMIT_AIO_OPS)\nzsh_LIMIT_PRESENT(RLIMIT_AS)\nzsh_LIMIT_PRESENT(RLIMIT_LOCKS)\nzsh_LIMIT_PRESENT(RLIMIT_MEMLOCK)\nzsh_LIMIT_PRESENT(RLIMIT_NPROC)\nzsh_LIMIT_PRESENT(RLIMIT_NTHR)\nzsh_LIMIT_PRESENT(RLIMIT_NOFILE)\nzsh_LIMIT_PRESENT(RLIMIT_PTHREAD)\nzsh_LIMIT_PRESENT(RLIMIT_RSS)\nzsh_LIMIT_PRESENT(RLIMIT_SBSIZE)\nzsh_LIMIT_PRESENT(RLIMIT_TCACHE)\nzsh_LIMIT_PRESENT(RLIMIT_VMEM)\nzsh_LIMIT_PRESENT(RLIMIT_SIGPENDING)\nzsh_LIMIT_PRESENT(RLIMIT_MSGQUEUE)\nzsh_LIMIT_PRESENT(RLIMIT_NICE)\nzsh_LIMIT_PRESENT(RLIMIT_RTPRIO)\nzsh_LIMIT_PRESENT(RLIMIT_POSIXLOCKS)\nzsh_LIMIT_PRESENT(RLIMIT_NPTS)\nzsh_LIMIT_PRESENT(RLIMIT_SWAP)\nzsh_LIMIT_PRESENT(RLIMIT_KQUEUES)\n\nAH_TEMPLATE([RLIMIT_VMEM_IS_RSS],\n[Define to 1 if RLIMIT_VMEM and RLIMIT_RSS both exist and are equal.])\nAC_CACHE_CHECK(if RLIMIT_VMEM and RLIMIT_RSS are the same,\nzsh_cv_rlimit_vmem_is_rss,\n[AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include <sys/resource.h>\nint main()\n{\nint ret = 1;\n#if defined(HAVE_RLIMIT_VMEM) && defined(HAVE_RLIMIT_RSS)\nif (RLIMIT_RSS == RLIMIT_VMEM) ret = 0;\n#endif\nreturn ret;\n}]])],[zsh_cv_rlimit_vmem_is_rss=yes],[zsh_cv_rlimit_vmem_is_rss=no],[zsh_cv_rlimit_vmem_is_rss=no])])\n\nif test x$zsh_cv_rlimit_vmem_is_rss = xyes; then\n  AC_DEFINE(RLIMIT_VMEM_IS_RSS)\nfi\n\n\nAH_TEMPLATE([RLIMIT_VMEM_IS_AS],\n[Define to 1 if RLIMIT_VMEM and RLIMIT_AS both exist and are equal.])\nAC_CACHE_CHECK(if RLIMIT_VMEM and RLIMIT_AS are the same,\nzsh_cv_rlimit_vmem_is_as,\n[AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include <sys/resource.h>\nint main()\n{\nint ret = 1;\n#if defined(HAVE_RLIMIT_VMEM) && defined(HAVE_RLIMIT_AS)\nif (RLIMIT_AS == RLIMIT_VMEM) ret = 0;\n#endif\nreturn ret;\n}]])],[zsh_cv_rlimit_vmem_is_as=yes],[zsh_cv_rlimit_vmem_is_as=no],[zsh_cv_rlimit_vmem_is_as=no])])\n\nif test x$zsh_cv_rlimit_vmem_is_as = xyes; then\n  AC_DEFINE(RLIMIT_VMEM_IS_AS)\nfi\n\n\nAH_TEMPLATE([RLIMIT_RSS_IS_AS],\n[Define to 1 if RLIMIT_RSS and RLIMIT_AS both exist and are equal.])\nAC_CACHE_CHECK(if RLIMIT_RSS and RLIMIT_AS are the same,\nzsh_cv_rlimit_rss_is_as,\n[AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include <sys/resource.h>\nint main()\n{\nint ret = 1;\n#if defined(HAVE_RLIMIT_RSS) && defined(HAVE_RLIMIT_AS)\nif (RLIMIT_AS == RLIMIT_RSS) ret = 0;\n#endif\nreturn ret;\n}]])],[zsh_cv_rlimit_rss_is_as=yes],[zsh_cv_rlimit_rss_is_as=no],[zsh_cv_rlimit_rss_is_as=no])])\n\nif test x$zsh_cv_rlimit_rss_is_as = xyes; then\n  AC_DEFINE(RLIMIT_RSS_IS_AS)\nfi\n\n\ndnl --------------------------------------------\ndnl Check for members of struct rusage\ndnl --------------------------------------------\nif test x$ac_cv_func_getrusage = xyes; then\n  AC_CHECK_MEMBERS([struct rusage.ru_maxrss,\n\t\t    struct rusage.ru_ixrss,\n\t\t    struct rusage.ru_idrss,\n\t\t    struct rusage.ru_isrss,\n\t\t    struct rusage.ru_minflt,\n\t\t    struct rusage.ru_majflt,\n\t\t    struct rusage.ru_nswap,\n\t\t    struct rusage.ru_inblock,\n\t\t    struct rusage.ru_oublock,\n\t\t    struct rusage.ru_msgsnd,\n\t\t    struct rusage.ru_msgrcv,\n\t\t    struct rusage.ru_nsignals,\n\t\t    struct rusage.ru_nvcsw,\n\t\t    struct rusage.ru_nivcsw],,,\n[#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include <sys/resource.h>])\nfi\n\n\ndnl --------------------------------------------\ndnl CHECK FOR DEFAULT PATH (used for command -p)\ndnl --------------------------------------------\nAC_CACHE_VAL(zsh_cv_cs_path,\n[if getconf _CS_PATH >/dev/null 2>&1; then\n  zsh_cv_cs_path=`getconf _CS_PATH`\nelif getconf CS_PATH >/dev/null 2>&1; then\n  zsh_cv_cs_path=`getconf CS_PATH`\nelif getconf PATH >/dev/null 2>&1; then\n  zsh_cv_cs_path=`getconf PATH`\nelse\n  zsh_cv_cs_path=\"/bin:/usr/bin\"\nfi])\nAC_DEFINE_UNQUOTED(DEFAULT_PATH, \"$zsh_cv_cs_path\",\n[The default path; used when running commands with command -p])\n\n\ndnl ----------------------------\ndnl CHECK FOR /dev/fd FILESYSTEM\ndnl ----------------------------\ndnl FreeBSD 5 only supports /dev/fd/0 to /dev/fd/2 without mounting\ndnl a special file system.  As zsh needs arbitrary /dev/fd (typically\ndnl >10) for its own use, we need to make sure higher fd's are available.\ndnl Since we're using the shell, we're restricted to 0 to 9 but 3 should\ndnl be good enough.\nAH_TEMPLATE([PATH_DEV_FD],\n[Define to the path of the /dev/fd filesystem.])\nAC_CACHE_CHECK(for /dev/fd filesystem, zsh_cv_sys_path_dev_fd,\n[if test \"$host_os\" = cygwin; then\ndnl In current (2008/12/01) versions of Cygwin these are present but don't\ndnl seem to work smoothly for process substitution; no great surprise\ndnl since getting processes to work at all on Cygwin is a big challenge.\ndnl We'll rely on FIFOs, since they do what we need.\nzsh_cv_sys_path_dev_fd=no\nelse\n[for zsh_cv_sys_path_dev_fd in /proc/self/fd /dev/fd no; do\n   test x`echo ok|(exec 3<&0; cat $zsh_cv_sys_path_dev_fd/3 2>/dev/null;)` = xok && break\n done]\nfi])\nif test x$zsh_cv_sys_path_dev_fd != xno; then\n  AC_DEFINE_UNQUOTED(PATH_DEV_FD, \"$zsh_cv_sys_path_dev_fd\")\nfi\n\ndnl ---------------------------------\ndnl CHECK FOR RFS SUPERROOT DIRECTORY\ndnl ---------------------------------\nAC_CACHE_CHECK(for RFS superroot directory, zsh_cv_sys_superroot,\n[test -d /../.LOCALROOT && zsh_cv_sys_superroot=yes || zsh_cv_sys_superroot=no])\nAH_TEMPLATE([HAVE_SUPERROOT],\n[Define to 1 if you have RFS superroot directory.])\nif test x$zsh_cv_sys_superroot = xyes; then\n  AC_DEFINE(HAVE_SUPERROOT)\nfi\n\ndnl CHECK FOR SYSTEMS REQUIRING GETCWD\nAC_CACHE_CHECK(whether we should use the native getcwd,\nzsh_cv_use_getcwd,\n[case \"${host_cpu}-${host_vendor}-${host_os}\" in\n    *QNX*) zsh_cv_use_getcwd=yes ;;\n    *) zsh_cv_use_getcwd=no ;;\n esac])\nAH_TEMPLATE([USE_GETCWD],\n[Define to 1 if you need to use the native getcwd.])\nif test x$zsh_cv_use_getcwd = xyes; then\n  AC_DEFINE(USE_GETCWD)\nfi\n\ndnl GNU getcwd() can allocate as much space as necessary for a\ndnl directory name, preventing guessing games.\nAH_TEMPLATE([GETCWD_CALLS_MALLOC],\n[Define to 1 if getcwd() calls malloc to allocate memory.])\nif test x$ac_cv_func_getcwd = xyes; then\n  AC_CACHE_CHECK(whether getcwd calls malloc to allocate memory,\n  zsh_cv_getcwd_malloc,\n  [AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <unistd.h>\n#include <string.h>\nint main() {\n    char buf[1024], *ptr1, *ptr2;\n    ptr1 = getcwd(buf, 1024);\n    ptr2 = getcwd(NULL, 0);\n    if (ptr1 && ptr2 && !strcmp(ptr1, ptr2)) {\n      return 0;\n    }\n    return 1;\n}\n]])],[zsh_cv_getcwd_malloc=yes],[zsh_cv_getcwd_malloc=no],[zsh_cv_getcwd_malloc=no])])\n  if test x$zsh_cv_getcwd_malloc = xyes; then\n    AC_DEFINE(GETCWD_CALLS_MALLOC)\n  fi\nfi\n\ndnl CHECK FOR setproctitle() FOR jobs -Z / ARGV0\nAH_TEMPLATE([HAVE_SETPROCTITLE],\n[Define to 1 if the system supports `setproctitle' to change process name])\nAC_CHECK_FUNC(setproctitle,AC_DEFINE(HAVE_SETPROCTITLE),\nAC_SEARCH_LIBS(setproctitle,util,AC_DEFINE(HAVE_SETPROCTITLE)))\n\ndnl -------------\ndnl CHECK FOR NIS\ndnl -------------\nAH_TEMPLATE([HAVE_NIS],\n[Define to 1 if you have NIS.])\nAC_CACHE_CHECK(for NIS, zsh_cv_sys_nis,\n[test -f /usr/bin/ypcat && /usr/bin/ypcat passwd.byname > /dev/null 2>&1 && \\\nzsh_cv_sys_nis=yes || zsh_cv_sys_nis=no])\nif test x$zsh_cv_sys_nis = xyes; then\n  AC_DEFINE(HAVE_NIS)\ndnl Some systems (Solaris 2.x, Linux Redhat 5.x) require\ndnl libnsl (Network Services Library) to find yp_all\n  AC_SEARCH_LIBS(yp_all, nsl)\nfi\n\ndnl -----------------\ndnl CHECK FOR NISPLUS\ndnl -----------------\nAH_TEMPLATE([HAVE_NIS_PLUS],\n[Define to 1 if you have NISPLUS.])\nAC_CACHE_CHECK(for NIS+, zsh_cv_sys_nis_plus,\n[test x$ac_cv_func_nis_list = xyes && test -f /usr/bin/nisls && \\\n /usr/bin/nisls > /dev/null 2>&1 && \\\nzsh_cv_sys_nis_plus=yes || zsh_cv_sys_nis_plus=no])\nif test x$zsh_cv_sys_nis_plus = xyes; then\n  AC_DEFINE(HAVE_NIS_PLUS)\nfi\n\ndnl ----------------------------------------\ndnl CHECK FOR LOCATION OF {U,W}TMP{,X} FILES\ndnl ----------------------------------------\nzsh_PATH_UTMP(utmp)\nzsh_PATH_UTMP(wtmp)\nzsh_PATH_UTMP(utmpx)\nzsh_PATH_UTMP(wtmpx)\n\ndnl -------------------\ndnl brk/sbrk PROTOTYPES\ndnl -------------------\nAC_CACHE_CHECK(for brk() prototype in <unistd.h>,\nzsh_cv_header_unistd_h_brk_proto,\n[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <unistd.h>\ndouble brk();]], [[int i;]])],[zsh_cv_header_unistd_h_brk_proto=no],[zsh_cv_header_unistd_h_brk_proto=yes])])\nAH_TEMPLATE([HAVE_BRK_PROTO],\n[Define to 1 if there is a prototype defined for brk() on your system.])\nif test x$zsh_cv_header_unistd_h_brk_proto = xyes; then\n  AC_DEFINE(HAVE_BRK_PROTO)\nfi\n\nAC_CACHE_CHECK(for sbrk() prototype in <unistd.h>,\nzsh_cv_header_unistd_h_sbrk_proto,\n[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <unistd.h>\ndouble sbrk();]], [[int i;]])],[zsh_cv_header_unistd_h_sbrk_proto=no],[zsh_cv_header_unistd_h_sbrk_proto=yes])])\nAH_TEMPLATE([HAVE_SBRK_PROTO],\n[Define to 1 if there is a prototype defined for sbrk() on your system.])\nif test x$zsh_cv_header_unistd_h_sbrk_proto = xyes; then\n  AC_DEFINE(HAVE_SBRK_PROTO)\nfi\n\ndnl -----------------------\ndnl mknod prototype for OSF\ndnl -----------------------\nAH_TEMPLATE([HAVE_MKNOD_PROTO],\n[Define to 1 if there is a prototype defined for mknod() on your system.])\nif test \"$ac_cv_prog_cc_stdc\" != no; then\n  AC_CACHE_CHECK(for mknod prototype in <sys/stat.h>,\n  zsh_cv_header_sys_stat_h_mknod_proto,\n  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/stat.h>\n   int mknod(double x);]], [[int i;]])],[zsh_cv_header_sys_stat_h_mknod_proto=no],[zsh_cv_header_sys_stat_h_mknod_proto=yes])])\n  if test x$zsh_cv_header_sys_stat_h_mknod_proto = xyes; then\n    AC_DEFINE(HAVE_MKNOD_PROTO)\n  fi\nfi\n\ndnl ----------------------------------------\ndnl presence and location of ioctl prototype\ndnl ----------------------------------------\nAC_CACHE_CHECK(for ioctl prototype in <unistd.h> or <termios.h>,\nzsh_cv_header_unistd_h_termios_h_ioctl_proto,\n[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n#ifdef HAVE_TERMIOS_H\n# include <termios.h>\n#endif\ndouble ioctl();]], [[int i;]])],[zsh_cv_header_unistd_h_termios_h_ioctl_proto=no],[zsh_cv_header_unistd_h_termios_h_ioctl_proto=yes])])\n\nif test x$zsh_cv_header_unistd_h_termios_h_ioctl_proto = xno; then\n  AC_CACHE_CHECK(for ioctl prototype in <sys/ioctl.h>,\n  zsh_cv_header_sys_ioctl_h_ioctl_proto,\n  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/ioctl.h>\n  double ioctl();]], [[int i;]])],[zsh_cv_header_sys_ioctl_h_ioctl_proto=no],[zsh_cv_header_sys_ioctl_h_ioctl_proto=yes])])\nelse\n  zsh_cv_header_sys_ioctl_h_ioctl_proto=no\nfi\n\nAH_TEMPLATE([HAVE_IOCTL_PROTO],\n[Define to 1 if there is a prototype defined for ioctl() on your system.])\nif test x$zsh_cv_header_unistd_h_termios_h_ioctl_proto = xyes || \\\n   test x$zsh_cv_header_sys_ioctl_h_ioctl_proto = xyes; then\n  AC_DEFINE(HAVE_IOCTL_PROTO)\nfi\nAH_TEMPLATE([IOCTL_IN_SYS_IOCTL],\n[Define to 1 if we must include <sys/ioctl.h> to get a prototype for ioctl().])\nif test x$zsh_cv_header_sys_ioctl_h_ioctl_proto = xyes; then\n  AC_DEFINE(IOCTL_IN_SYS_IOCTL)\nfi\n\ndnl -------------------\ndnl select() defined in <sys/socket.h>, ie BeOS R4.51\ndnl -------------------\nAH_TEMPLATE([SELECT_IN_SYS_SOCKET_H],\n[Define to 1 if select() is defined in <sys/socket.h>, ie BeOS R4.51])\nif test x$ac_cv_header_sys_select_h != xyes; then\n  AC_CACHE_CHECK(for select() in <sys/socket.h>,\n  zsh_cv_header_socket_h_select_proto,\n  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]], [[fd_set fd;]])],[zsh_cv_header_socket_h_select_proto=yes],[zsh_cv_header_socket_h_select_proto=no])])\n  if test x$zsh_cv_header_socket_h_select_proto = xyes; then\n    AC_DEFINE(SELECT_IN_SYS_SOCKET_H)\n  fi\nfi\n\ndnl -----------\ndnl named FIFOs\ndnl -----------\ndnl\ndnl Named FIFOs work well enough on recent versions of Cygwin\ndnl to provide what we want.  Simply enable them.\nAC_CACHE_CHECK(if named FIFOs work,\nzsh_cv_sys_fifo,\n[if test \"$host_os\" = cygwin; then\nzsh_cv_sys_fifo=yes\nelse\nAC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <fcntl.h>\n#include <signal.h>\nmain()\n{\n    char c;\n    int fd;\n    int pid, ret;\n    unlink(\"/tmp/fifo$$\");\n#ifdef HAVE_MKFIFO\n    if(mkfifo(\"/tmp/fifo$$\", 0600) < 0)\n#else\n    if(mknod(\"/tmp/fifo$$\", 0010600, 0) < 0)\n#endif\n\texit(1);\n    pid = fork();\n    if(pid < 0)\n\texit(1);\n    if(pid) {\n\tfd = open(\"/tmp/fifo$$\", O_RDONLY);\n\texit(fd < 0 || read(fd, &c, 1) != 1 || c != 'x');\n    }\n    fd = open(\"/tmp/fifo$$\", O_WRONLY);\n    ret = (fd < 0 || write(fd, \"x\", 1) < 1);\n    unlink(\"/tmp/fifo$$\");\n    exit(ret);\n}\n]])],[zsh_cv_sys_fifo=yes],[zsh_cv_sys_fifo=no],[zsh_cv_sys_fifo=yes])\nfi])\nAH_TEMPLATE([HAVE_FIFOS],\n[Define to 1 if system has working FIFOs.])\nif test x$zsh_cv_sys_fifo = xyes; then\n  AC_DEFINE(HAVE_FIFOS)\nfi\n\ndnl -----------\ndnl test for whether link() works\ndnl for instance, BeOS R4.51 doesn't support hard links yet\ndnl -----------\nAC_CACHE_CHECK(if link() works,\nzsh_cv_sys_link,\n[AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <unistd.h>\n#include <fcntl.h>\nmain()\n{\n    int ret;\n    char *tmpfile, *newfile;\n    tmpfile=\"/tmp/zsh.linktest$$\";\n    newfile=\"/tmp/zsh.linktest2$$\";\n    unlink(tmpfile);\n    unlink(newfile);\n    if(creat(tmpfile, 0644) < 0)\n\texit(1);\n    ret = link(tmpfile, newfile);\n    unlink(tmpfile);\n    unlink(newfile);\n    exit(ret<0);\n}\n]])],[zsh_cv_sys_link=yes],[zsh_cv_sys_link=no],[zsh_cv_sys_link=yes])])\nAH_TEMPLATE([HAVE_LINK],\n[Define to 1 if system has working link().])\nif test x$zsh_cv_sys_link = xyes; then\n  AC_DEFINE(HAVE_LINK)\nfi\n\ndnl -----------\ndnl test for whether kill(pid, 0) where pid doesn't exit\ndnl should set errno to ESRCH, but some like BeOS R4.51 set to EINVAL\ndnl -----------\nAC_CACHE_CHECK(if kill(pid, 0) returns ESRCH correctly,\nzsh_cv_sys_killesrch,\n[AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <unistd.h>\n#include <signal.h>\n#include <errno.h>\nmain()\n{\n    int pid = (getpid() + 10000) & 0xffffff;\n    while (pid && (kill(pid, 0) == 0 || errno != ESRCH)) pid >>= 1;\n    exit(errno!=ESRCH);\n}\n]])],[zsh_cv_sys_killesrch=yes],[zsh_cv_sys_killesrch=no],[zsh_cv_sys_killesrch=yes])])\nAH_TEMPLATE([BROKEN_KILL_ESRCH],\n[Define to 1 if kill(pid, 0) doesn't return ESRCH, ie BeOS R4.51.])\nif test x$zsh_cv_sys_killesrch = xno; then\n  AC_DEFINE(BROKEN_KILL_ESRCH)\nfi\n\ndnl -----------\ndnl if POSIX, test for working sigsuspend().\ndnl for instance, BeOS R4.51 is broken.\ndnl -----------\nAH_TEMPLATE([BROKEN_POSIX_SIGSUSPEND],\nDefine to 1 if sigsuspend() is broken, ie BeOS R4.51.])\nif test x$signals_style = xPOSIX_SIGNALS; then\n    AC_CACHE_CHECK(if POSIX sigsuspend() works,\n    zsh_cv_sys_sigsuspend,\n    [AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <signal.h>\n#include <unistd.h>\nint child=0;\nvoid handler(sig)\n    int sig;\n{if(sig==SIGCHLD) child=1;}\nmain() {\n    struct sigaction act;\n    sigset_t set;\n    int pid, ret;\n    act.sa_handler = &handler;\n    sigfillset(&act.sa_mask);\n    act.sa_flags = 0;\n    sigaction(SIGCHLD, &act, 0);\n    sigfillset(&set);\n    sigprocmask(SIG_SETMASK, &set, 0);\n    pid=fork();\n    if(pid==0) return 0;\n    if(pid>0) {\n    sigemptyset(&set);\n        ret=sigsuspend(&set);\n        exit(child==0);\n    }\n}\n]])],[zsh_cv_sys_sigsuspend=yes],[zsh_cv_sys_sigsuspend=no],[zsh_cv_sys_sigsuspend=yes])])\n    if test x$zsh_cv_sys_sigsuspend = xno; then\n      AC_DEFINE(BROKEN_POSIX_SIGSUSPEND)\n    fi\nfi\n\ndnl -----------\ndnl if found tcsetpgrp, test to see if it actually works\ndnl for instance, BeOS R4.51 does not support it yet\ndnl -----------\nAH_TEMPLATE([BROKEN_TCSETPGRP],\n[Define to 1 if tcsetpgrp() doesn't work, ie BeOS R4.51.])\nAC_ARG_WITH(tcsetpgrp,\nAS_HELP_STRING([--with-tcsetpgrp],[assumes that tcsetpgrp() exists and works correctly]),[\ncase \"x$withval\" in\n    xyes) zsh_working_tcsetpgrp=yes;;\n    xno)  zsh_working_tcsetpgrp=no;;\n    *)    AC_MSG_ERROR(please use --with-tcsetpgrp=yes or --with-tcsetpgrp=no);;\nesac],[zsh_working_tcsetpgrp=check])\nif test \"x$ac_cv_func_tcsetpgrp\" = xyes; then\ncase \"x$zsh_working_tcsetpgrp\" in\n  xcheck)\n    trap \"\" TTOU > /dev/null 2>&1 || :\n    AC_CACHE_CHECK(if tcsetpgrp() actually works,\n    zsh_cv_sys_tcsetpgrp,\n    [AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\nmain() {\n    int fd;\n    int ret;\n    fd=open(\"/dev/tty\", O_RDWR);\n    if (fd < 0) exit(2);\n    ret=tcsetpgrp(fd, tcgetpgrp(fd));\n    if (ret < 0) exit(1);\n    exit(0);\n}\n]])],[zsh_cv_sys_tcsetpgrp=yes],[\ncase $? in\n    1) zsh_cv_sys_tcsetpgrp=no;;\n    2) zsh_cv_sys_tcsetpgrp=notty;;\n    *) zsh_cv_sys_tcsetpgrp=error;;\nesac\n      ],[zsh_cv_sys_tcsetpgrp=yes])])\n    case \"x$zsh_cv_sys_tcsetpgrp\" in\n      xno)    AC_DEFINE(BROKEN_TCSETPGRP);;\n      xyes)   :;;\n      xnotty) AC_MSG_ERROR([no controlling tty\nTry running configure with --with-tcsetpgrp or --without-tcsetpgrp]);;\n      *)      AC_MSG_ERROR([unexpected return status]);;\n    esac\n    trap - TTOU > /dev/null 2>&1 || :\n    ;;\n  xyes) :;;\n  xno)  AC_DEFINE(BROKEN_TCSETPGRP);;\n  *)    AC_MSG_ERROR([unexpected value zsh_working_tcsetpgrp=$zsh_working_tcsetpgrp]);;\nesac\nfi\n\ndnl -----------\ndnl test for faked getpwnam() entry, ie a single entry returned for any username\ndnl for instance, BeOS R4.51 is not multiuser yet, and fakes getpwnam()\ndnl test by looking up two usernames that shouldn't succeed, and compare entry\ndnl -----------\nAH_TEMPLATE([GETPWNAM_FAKED],\n[Define to 1 if getpwnam() is faked, ie BeOS R4.51.])\nif test x$ac_cv_func_getpwnam = xyes; then\n    AC_CACHE_CHECK(if getpwnam() is faked,\n    zsh_cv_sys_getpwnam_faked,\n    [AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <pwd.h>\nmain() {\n    struct passwd *pw1, *pw2;\n    char buf[1024], name[1024];\n    sprintf(buf, \"%d:%d\", getpid(), rand());\n    pw1=getpwnam(buf);\n    if (pw1) strcpy(name, pw1->pw_name);\n    sprintf(buf, \"%d:%d\", rand(), getpid());\n    pw2=getpwnam(buf);\n    exit(pw1!=0 && pw2!=0 && !strcmp(name, pw2->pw_name));\n}\n]])],[zsh_cv_sys_getpwnam_faked=no],[zsh_cv_sys_getpwnam_faked=yes],[zsh_cv_sys_getpwnam_faked=no])])\n    if test x$zsh_cv_sys_getpwnam_faked = xyes; then\n      AC_DEFINE(GETPWNAM_FAKED)\n    fi\nfi\n\n\ndnl ---------------\ndnl check for the type of third argument of accept\ndnl ---------------\n\nzsh_CHECK_SOCKLEN_T\n\ndnl ---------------\ndnl Check for pty multiplexer for use in pty module.\ndnl We need to open it read/write, so make sure it is writeable.\ndnl Yet another test which won't work when cross-compiling.\ndnl ---------------\nAC_CACHE_CHECK(if your system has /dev/ptmx,\nac_cv_have_dev_ptmx,\n[if test -w /dev/ptmx; then\n  ac_cv_have_dev_ptmx=yes\nelse\n  ac_cv_have_dev_ptmx=no\nfi])\n\ndnl --------\ndnl Check if the ptmx functions are usable.\ndnl We need to be able to find the prototypes, which may\ndnl require non-POSIX source definitions.  So test to see\ndnl if ptsname is correctly recognised as returning a char *.\ndnl We do this by making sure a program where ptsname() is declared\ndnl as returning int does *not* compile.\ndnl On Linux we need the XOPEN extensions.  The easiest way to get\ndnl these is by defining _GNU_SOURCE.\ndnl -------\nAH_TEMPLATE([USE_DEV_PTMX],\n[Define to 1 if all the kit for using /dev/ptmx for ptys is available.])\nif test x$ac_cv_have_dev_ptmx = xyes -o x$ac_cv_func_posix_openpt = xyes && \\\n   test x$ac_cv_func_grantpt = xyes && \\\n   test x$ac_cv_func_unlockpt = xyes && \\\n   test x$ac_cv_func_ptsname = xyes; then\n   AC_CACHE_CHECK([if /dev/ptmx is usable],\n   ac_cv_use_dev_ptmx,\n   [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#ifdef __linux\n#define _GNU_SOURCE 1\n#endif\n#include <stdlib.h>\nint ptsname();]], [[]])],[ac_cv_use_dev_ptmx=no],[ac_cv_use_dev_ptmx=yes])])\n   if test x$ac_cv_use_dev_ptmx = xyes; then\n     AC_DEFINE(USE_DEV_PTMX)\n   fi\nfi\n\ndnl -----------------\ndnl multibyte support\ndnl -----------------\nAC_ARG_ENABLE(multibyte,\nAS_HELP_STRING([--enable-multibyte],[support multibyte characters]),\n[zsh_cv_c_unicode_support=$enableval],\n[AC_CACHE_VAL(zsh_cv_c_unicode_support,\n  AC_MSG_NOTICE([checking for functions supporting multibyte characters])\n  [zfuncs_absent=\ndnl\ndnl Note that iswblank is not included and checked separately.\ndnl As iswblank() was added to C long after the others, we still\ndnl want to enabled unicode support even if iswblank is not available\ndnl (we then just do the SPC+TAB approximation)\ndnl\n   for zfunc in iswalnum iswcntrl iswdigit iswgraph iswlower iswprint \\\niswpunct iswspace iswupper iswxdigit mbrlen mbrtowc towupper towlower \\\nwcschr wcscpy wcslen wcsncmp wcsncpy wcrtomb wcwidth wmemchr wmemcmp \\\nwmemcpy wmemmove wmemset; do\n     AC_CHECK_FUNC($zfunc,\n     [:], [zfuncs_absent=\"$zfuncs_absent $zfunc\"])\n    done\n    if test x\"$zfuncs_absent\" = x; then\n      AC_MSG_NOTICE([all functions found, multibyte support enabled])\n      zsh_cv_c_unicode_support=yes\n    else\n      AC_MSG_NOTICE([missing functions, multibyte support disabled])\n      zsh_cv_c_unicode_support=no\n    fi\n  ])\n])\nAH_TEMPLATE([MULTIBYTE_SUPPORT],\n[Define to 1 if you want support for multibyte character sets.])\n\ndnl\ndnl unicode9 support\ndnl\nAH_TEMPLATE([ENABLE_UNICODE9],\n[Define to 1 if you want use unicode9 character widths.])\nAC_ARG_ENABLE(unicode9,\nAS_HELP_STRING([--enable-unicode9],[compile with unicode9 character widths]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(ENABLE_UNICODE9)\nfi])\n\nAH_TEMPLATE([BROKEN_ISPRINT],\n[Define to 1 if the isprint() function is broken under UTF-8 locale.])\n\nif test x$zsh_cv_c_unicode_support = xyes; then\n  AC_DEFINE(MULTIBYTE_SUPPORT)\n\n  dnl Test if wcwidth() and/or iswprint() is broken for\n  dnl   zero-width combining characters, or\n  dnl   some characters in the Latin Extended-B.\n  dnl If either of the functions is broken, both functions will be replaced\n  dnl by the ones from wcwidth9.h by defining ENABLE_UNICODE9. We will do\n  dnl this only if __STDC_ISO_10646__ is defined (or if building on macOS,\n  dnl where __STDC_ISO_10646__ is not defined but wchar_t is UCS).\n  dnl For the test we use a combining acute accent (\\u0301) or\n  dnl a LATIN SMALL LETTER L WITH CURL (\\u0234).\n  dnl We input it as UTF-8 since that is the standard we can rely\n  dnl upon most:  we can't rely on a wchar_t being stored as a\n  dnl Unicode code point on all systems.\n  dnl The programme returns 0 only if all the conditions for brokenness\n  dnl are met:\n  dnl - the programme compiled, linked and ran\n  dnl - we successfully set a UTF-8 locale\n  dnl - the locale we set plausibly converted the UTF-8 string\n  dnl   into the correct wide character\n  dnl - but wcwidth() or iswprint() is broken for the converted wide character.\n  dnl locale -a is a fallback; on most systems we should find en_US.UTF-8.\n  [locale_prog='char *my_locales[] = {\n  \"en_US.UTF-8\", \"en_GB.UTF-8\", \"en.UTF-8\", '\n  locale_prog=\"$locale_prog\"`locale -a 2>/dev/null | \\\n    sed -e 's/utf8/UTF-8/' | grep UTF-8 | \\\n    while read line; do echo \" \\\"$line\\\",\"; done;`\n  locale_prog=\"$locale_prog 0 };\n  #define _XOPEN_SOURCE\n  #include <stdlib.h>\n  #include <locale.h>\n  #include <wchar.h>\n  #include <wctype.h>\n\n  int main() {\n    char **localep;\n    char comb_acute_mb[] = { (char)0xcc, (char)0x81 };\n    char u_0234[] = { (char)0xc8, (char)0xb4 };\n    wchar_t wc;\n  #if !defined(__STDC_ISO_10646__) && !defined(__APPLE__)\n    return 1;\n  #endif\n\n    for (localep = my_locales; *localep; localep++)\n      if (setlocale(LC_ALL, *localep))\n\t  break;\n    if (!*localep)\n      return 1;\n    if (mbtowc(&wc, comb_acute_mb, 2) == 2 && (wcwidth(wc) != 0 || !iswprint(wc)))\n      return 0;\n    if (mbtowc(&wc, u_0234, 2) == 2 && (wcwidth(wc) != 1 || !iswprint(wc)))\n      return 0;\n    return 1;\n  }\n  \"]\n\n  AC_CACHE_CHECK(if the wcwidth() and/or iswprint() functions are broken,\n  zsh_cv_c_broken_wcwidth,\n  [AC_RUN_IFELSE([AC_LANG_SOURCE([[$locale_prog]])],[zsh_cv_c_broken_wcwidth=yes],[zsh_cv_c_broken_wcwidth=no],[zsh_cv_c_broken_wcwidth=no])])\n  if test x$zsh_cv_c_broken_wcwidth = xyes; then\n    AC_DEFINE(ENABLE_UNICODE9)\n  fi\n\n  dnl Check if isprint() behaves correctly under UTF-8 locale.\n  dnl On some platform (maybe only on Mac OS X), isprint() returns\n  dnl true for all characters in the range from 0xa0 to 0xff if\n  dnl called under UTF-8 locale.\n  [locale_prog='char *my_locales[] = {\n  \"en_US.UTF-8\", \"en_GB.UTF-8\", \"en.UTF-8\", '\n  locale_prog=\"$locale_prog\"`locale -a 2>/dev/null | \\\n    sed -e 's/utf8/UTF-8/' | grep UTF-8 | \\\n    while read line; do echo \" \\\"$line\\\",\"; done;`\n  locale_prog=\"$locale_prog 0 };\n  #include <locale.h>\n  #include <ctype.h>\n\n  int main() {\n    char **localep;\n    for (localep = my_locales; *localep; localep++)\n      if (setlocale(LC_ALL, *localep) && isprint(0xa0))\n\treturn 0;\n    return 1;\n  }\n  \"]\n\n  AC_CACHE_CHECK(if the isprint() function is broken,\n  zsh_cv_c_broken_isprint,\n  [AC_RUN_IFELSE([AC_LANG_SOURCE([[$locale_prog]])],[zsh_cv_c_broken_isprint=yes],[zsh_cv_c_broken_isprint=no],[zsh_cv_c_broken_isprint=no])])\n  if test x$zsh_cv_c_broken_isprint = xyes; then\n    AC_DEFINE(BROKEN_ISPRINT)\n  fi\nfi\n\ndnl\ndnl musl support\ndnl\nAH_TEMPLATE([LIBC_MUSL],\n[Define to 1 if musl is being used as the C library])\nAC_ARG_ENABLE(libc-musl,\nAS_HELP_STRING([--enable-libc-musl],[compile with musl as the C library]),\n[if test x$enableval = xyes; then\n  AC_DEFINE(LIBC_MUSL)\nfi])\n\ndnl\ndnl static user lookup\ndnl\nAC_ARG_ENABLE(dynamic-nss,\n\t      AS_HELP_STRING([--disable-dynamic-nss],[do not call\n\t\t\t      functions that will require dynamic NSS\n\t\t\t      modules]),\n[zsh_cv_c_dynamic_nss=$enableval],\n[])\n\nAH_TEMPLATE([DISABLE_DYNAMIC_NSS],\n[Define to 1 if you want to avoid calling functions that will require\n dynamic NSS modules.])\nif test x$zsh_cv_c_dynamic_nss = xno; then\n  AC_DEFINE(DISABLE_DYNAMIC_NSS)\nfi\n\ndnl ---------------\ndnl dynamic loading\ndnl ---------------\nAH_TEMPLATE([HPUX10DYNAMIC],\n[Define to 1 if you want to use dynamically loaded modules on HPUX 10.])\nL=N\nINSTLIB=\"install.bin-\\$(L)\"\nUNINSTLIB=\"uninstall.bin-\\$(L)\"\nLINKMODS=NOLINKMODS\nMOD_EXPORT=\nMOD_IMPORT_VARIABLE=\nMOD_IMPORT_FUNCTION=\naixdynamic=no\nhpuxdynamic=no\nif test \"$ac_cv_func_load\"      = yes &&\n   test \"$ac_cv_func_unload\"    = yes &&\n   test \"$ac_cv_func_loadbind\"  = yes &&\n   test \"$ac_cv_func_loadquery\" = yes; then\n  dnl Force AIXDYNAMIC even on newer versions that have dl family\n  if test \"x$dynamic\" = xyes; then\n    aixdynamic=yes\n  fi\nelif test \"$ac_cv_func_dlopen\"  != yes ||\n     test \"$ac_cv_func_dlsym\"   != yes ||\n     test \"$ac_cv_func_dlerror\" != yes; then\n  if test \"$ac_cv_func_shl_load\" != yes ||\n     test \"$ac_cv_func_shl_unload\" != yes ||\n     test \"$ac_cv_func_shl_findsym\" != yes; then\n    dynamic=no\n  elif test \"x$dynamic\" = xyes; then\n    hpuxdynamic=yes\n    DL_EXT=\"${DL_EXT=sl}\"\n    dnl autoheader won't allow us to define anything which isn't\n    dnl going into a header, and we can't undefine anything, so\n    dnl just define this anyway and rely on the later tests to\n    dnl define DYNAMIC or not.\n    AC_DEFINE(HPUX10DYNAMIC)dnl\n  fi\nfi\n\ntest -n \"$GCC\" && LDARG=-Wl,\n\nAH_TEMPLATE([DLSYM_NEEDS_UNDERSCORE],\n[Define to 1 if an underscore has to be prepended to dlsym() argument.])\nAH_TEMPLATE([DYNAMIC_NAME_CLASH_OK],\n[Define to 1 if multiple modules defining the same symbol are OK.])\nif test \"x$aixdynamic\" = xyes; then\n  DL_EXT=\"${DL_EXT=so}\"\n  DLLD=\"${DLLD=$CC}\"\n  zsh_cv_func_dlsym_needs_underscore=no\n  if test -n \"$GCC\"; then\n    DLLDFLAGS=${DLLDFLAGS=-shared}\n  else\n    DLLDFLAGS=${DLLDFLAGS=-bM:SRE}\n  fi\n  DLLDFLAGS=${DLLDFLAGS=}\n  EXTRA_LDFLAGS=${EXTRA_LDFLAGS=}\n  EXPOPT=${LDARG}-bE:\n  IMPOPT=${LDARG}-bI:\n  zsh_cv_sys_dynamic_clash_ok=\"${zsh_cv_sys_dynamic_clash_ok=yes}\"\n  zsh_cv_sys_dynamic_rtld_global=\"${zsh_cv_sys_dynamic_rtld_global=yes}\"\n  zsh_cv_sys_dynamic_execsyms=\"${zsh_cv_sys_dynamic_execsyms=yes}\"\n  zsh_cv_sys_dynamic_strip_exe=\"${zsh_cv_sys_dynamic_strip_exe=yes}\"\n  zsh_cv_sys_dynamic_strip_lib=\"${zsh_cv_sys_dynamic_strip_lib=yes}\"\n  zsh_cv_shared_environ=\"${zsh_cv_shared_environ=yes}\"\nelif test \"$host_os\" = cygwin; then\n  DL_EXT=\"${DL_EXT=dll}\"\n##DLLD=\"${DLLD=dllwrap}\"\n  DLLD=\"${DLLD=$CC}\"\n##DLLDFLAGS=\"${DLLDFLAGS=--export-all-symbols}\"\n  DLLDFLAGS=${DLLDFLAGS=-shared -Wl,--export-all-symbols}\n  zsh_cv_func_dlsym_needs_underscore=no\n  DLLDFLAGS=${DLLDFLAGS=}\n  EXTRA_LDFLAGS=${EXTRA_LDFLAGS=}\n  zsh_cv_sys_dynamic_clash_ok=\"${zsh_cv_sys_dynamic_clash_ok=no}\"\n  zsh_cv_sys_dynamic_rtld_global=\"${zsh_cv_sys_dynamic_rtld_global=yes}\"\n  zsh_cv_sys_dynamic_execsyms=\"${zsh_cv_sys_dynamic_execsyms=no}\"\n  zsh_cv_sys_dynamic_strip_exe=\"${zsh_cv_sys_dynamic_strip_exe=yes}\"\n  zsh_cv_sys_dynamic_strip_lib=\"${zsh_cv_sys_dynamic_strip_lib=yes}\"\n  #\n  # THAT SUCKS! and must be changed\n  #\n  zsh_cv_shared_environ=\"${zsh_cv_shared_environ=yes}\"\n  LINKMODS=LINKMODS\n  MOD_EXPORT=\"__attribute__((__dllexport__))\"\n  MOD_IMPORT_VARIABLE=\"__attribute__((__dllimport__))\"\n  MOD_IMPORT_FUNCTION=\nelif test \"x$dynamic\" = xyes; then\n  AC_CACHE_CHECK(if your system uses ELF binaries,\n   zsh_cv_sys_elf,\n   [AC_RUN_IFELSE([AC_LANG_SOURCE([[/* Test for whether ELF binaries are produced */\n#include <fcntl.h>\n#include <stdlib.h>\nmain(argc, argv)\nint argc;\nchar *argv[];\n{\n\tchar b[4];\n\tint i = open(argv[0],O_RDONLY);\n\tif(i == -1) \n\t\texit(1); /* fail */\n\tif(read(i,b,4)==4 && b[0]==127 && b[1]=='E' && b[2]=='L' && b[3]=='F')\n\t\texit(0); /* succeed (yes, it's ELF) */\n\telse\n\t\texit(1); /* fail */\n}]])],[zsh_cv_sys_elf=yes],[zsh_cv_sys_elf=no],[zsh_cv_sys_elf=yes])])\n\n  # We use [0-9]* in case statements, so need to change quoting\n  changequote(, )\n\n  DL_EXT=\"${DL_EXT=so}\"\n  if test x$zsh_cv_sys_elf = xyes; then\n    case \"$host\" in\n      mips-sni-sysv4*)\n        # Forcibly set ld to native compiler to avoid obscure GCC problems\n\tDLLD=\"${DLLD=/usr/ccs/bin/cc}\"\n\tDLLDARG=\"${LDARG}\"\n      ;;\n      * )\n\tDLLD=\"${DLLD=$CC}\"\n\tDLLDARG=\"${LDARG}\"\n      ;;\n    esac\n  else\n    case \"$host\" in\n      *openbsd*)\n\tcase \"$host_os\" in\n\t  openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)\n\t    DLLD=\"${DLLD=ld}\"\n\t  ;;\n\t  *)\n\t    DLLD=\"${DLLD=$CC}\"\n\t  ;;\n\tesac\n\tDLLDARG=\"${LDARG}\"\n      ;;\n      *darwin*)\n        DLLD=\"${DLLD=$CC}\"\n        DLLDARG=\"\"\n      ;;\n      *interix*)\n        DLLD=\"${DLLD=$CC}\"\n        DLLDARG=\"\"\n      ;;\n      * )\n\tDLLD=\"${DLLD=ld}\"\n\tDLLDARG=\"\"\n      ;;\n    esac\n  fi\n  if test -n \"$GCC\"; then\n    case \"$host_os\" in\n      hpux*)   DLLDFLAGS=\"${DLLDFLAGS=-shared}\" ;;\n      darwin*) DLCFLAGS=\"${DLCFLAGS=-fno-common}\" ;;\n      interix*) DLCFLAGS=\"${DLCFLAGS=}\" ;;\n      *)       DLCFLAGS=\"${DLCFLAGS=-fPIC}\" ;;\n    esac\n  else\n    case \"$host_os\" in\n      hpux*)\n        DLCFLAGS=\"${DLCFLAGS=+z}\"\n        DLLDFLAGS=\"${DLLDFLAGS=-b}\"\n      ;;\n      sunos*)                DLCFLAGS=\"${DLCFLAGS=-pic}\" ;;\n      solaris*|sysv4*|esix*) DLCFLAGS=\"${DLCFLAGS=-KPIC}\" ;;\n    esac\n  fi\n  case \"$host_os\" in\n    osf*) DLLDFLAGS=\"${DLLDFLAGS=-shared -expect_unresolved '*'}\" ;;\n    *freebsd*|*netbsd*|linux*|irix*|gnu*|interix*|dragonfly*) DLLDFLAGS=\"${DLLDFLAGS=-shared}\" ;;\n    sunos*)       DLLDFLAGS=\"${DLLDFLAGS=-assert nodefinitions}\" ;;\n    sysv4*|esix*) DLLDFLAGS=\"${DLLDFLAGS=-G $ldflags}\" ;;\n    aix*)         DLLDFLAGS=\"${DLLDFLAGS=-G -bexpall -lc}\" ;;\n    solaris*|sysv4*|esix*) DLLDFLAGS=\"${DLLDFLAGS=-G}\" ;;\n    darwin*)      DLLDFLAGS=\"${DLLDFLAGS=-bundle -flat_namespace -undefined suppress}\" ;;\n    beos*|haiku*) DLLDFLAGS=\"${DLLDFLAGS=-nostart}\" ;;\n    openbsd*)\n      if test x$zsh_cv_sys_elf = xyes; then\n\tDLLDFLAGS=\"${DLLDFLAGS=-shared -fPIC}\"\n      else\n\tcase \"$host_os\" in\n\t  openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)\n\t   DLLDFLAGS=\"${DLLDFLAGS=-Bshareable}\"\n\t  ;;\n\t  *)\n\t    DLLDFLAGS=\"${DLLDFLAGS=-shared -fPIC}\"\n\t  ;;\n\tesac\n      fi\n    ;;\n  esac\n  case \"$host\" in\n    *-hpux*)  EXTRA_LDFLAGS=\"${EXTRA_LDFLAGS=-Wl,-E}\" ;;\n    *openbsd*)\n       if test x$zsh_cv_sys_elf = xyes; then\n\t EXTRA_LDFLAGS=\"${EXTRA_LDFLAGS=-Wl,-E}\"\n       fi\n    ;;\n    mips-sni-sysv4)\n      #\n      # unfortunately, we have different compilers\n      # that need different flags\n      #\n      if test -n \"$GCC\"; then\n        sni_cc_version=GCC\n      else\n        sni_cc_version=`$CC -V 2>&1 | head -1`\n      fi\n      case \"$sni_cc_version\" in\n        *CDS*|GCC )\n         EXTRA_LDFLAGS=\"${EXTRA_LDFLAGS=-Wl,-Blargedynsym}\"\n       ;;\n       * )\n         EXTRA_LDFLAGS=\"${EXTRA_LDFLAGS=-LD-Blargedynsym}\"\n       ;;\n      esac\n    ;;\n    *-beos*)\n      # gcc on BeOS doesn't like -rdynamic...\n      EXTRA_LDFLAGS=\"${EXTRA_LDFLAGS= }\"\n      # also, dlopen() at least in Zeta respects $LIBRARY_PATH, so needs %A added to it.\n      export LIBRARY_PATH=\"$LIBRARY_PATH:%A/\"\n    ;;\n    *-haiku*)\n      # \n    ;;\n  esac\n\n  # Done with our shell code, so restore autotools quoting\n  changequote([, ])\n\nAC_CACHE_CHECK(if we can use -rdynamic, zsh_cv_rdynamic_available,\nold_LDFLAGS=\"$LDFLAGS\"\nLDFLAGS=\"$LDFLAGS -rdynamic\"\nAC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[]])],[zsh_cv_rdynamic_available=yes\nEXTRA_LDFLAGS=\"${EXTRA_LDFLAGS=-rdynamic}\"],[zsh_cvs_rdynamic_available=no])\nLDFLAGS=\"$old_LDFLAGS\")\n  AC_CACHE_CHECK(if your dlsym() needs a leading underscore,\n   zsh_cv_func_dlsym_needs_underscore,\n   [echo failed >conftestval && cat >conftest.c <<EOM\nfred () { }\nEOM\n    AC_TRY_COMMAND($CC -c $CFLAGS $CPPFLAGS $DLCFLAGS conftest.c 1>&AS_MESSAGE_LOG_FD) &&\n    AC_TRY_COMMAND($DLLD $LDFLAGS $DLLDFLAGS -o conftest.$DL_EXT conftest.o 1>&AS_MESSAGE_LOG_FD) &&\n    AC_RUN_IFELSE([AC_LANG_SOURCE([[\n#include <stdio.h>\n#ifdef HPUX10DYNAMIC\n#include <dl.h>\n#define RTLD_LAZY BIND_DEFERRED\n#define RTLD_GLOBAL DYNAMIC_PATH\n\nchar *zsh_gl_sym_addr ;\n\n#define dlopen(file,mode) (void *)shl_load((file), (mode), (long) 0)\n#define dlclose(handle) shl_unload((shl_t)(handle))\n#define dlsym(handle,name) (zsh_gl_sym_addr=0,shl_findsym((shl_t *)&(handle),name,TYPE_UNDEFINED,&zsh_gl_sym_addr), (void *)zsh_gl_sym_addr)\n#define dlerror() 0\n#else\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#else\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#endif\n#endif\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n\nextern int fred() ;\n\nmain()\n{\n    void * handle ;\n    void * symbol ;\n    FILE *f=fopen(\"conftestval\", \"w\");\n    if (!f) exit(1);\n    handle = dlopen(\"./conftest.$DL_EXT\", RTLD_LAZY) ;\n    if (handle == NULL) {\n        fprintf (f, \"dlopen failed\") ;\n            exit(1);\n    }\n    symbol = dlsym(handle, \"fred\") ;\n    if (symbol == NULL) {\n                /* try putting a leading underscore */\n        symbol = dlsym(handle, \"_fred\") ;\n        if (symbol == NULL) {\n            fprintf (f, \"dlsym failed\") ;\n                exit(1);\n                }\n        fprintf (f, \"yes\") ;\n    }\n    else\n        fprintf (f, \"no\") ;\n    exit(0);\n}]])],[zsh_cv_func_dlsym_needs_underscore=`cat conftestval`],[zsh_cv_func_dlsym_needs_underscore=failed\n    dynamic=no],[zsh_cv_func_dlsym_needs_underscore=no])])\n  if test \"x$zsh_cv_func_dlsym_needs_underscore\" = xyes; then\n    AC_DEFINE(DLSYM_NEEDS_UNDERSCORE)\n  elif test \"x$zsh_cv_func_dlsym_needs_underscore\" != xno; then\n    dnl Do not cache failed value\n    unset zsh_cv_func_dlsym_needs_underscore\n  fi\nfi\n\nif test \"x$dynamic\" = xyes; then\n  zsh_SHARED_VARIABLE([environ], [char **])\n  test \"$zsh_cv_shared_environ\" = yes || dynamic=no\n  if test \"$ac_cv_func_tgetent\" = yes; then\n    zsh_SHARED_FUNCTION([tgetent])\n  fi\n  if test \"$ac_cv_func_tigetstr\" = yes; then\n    zsh_SHARED_FUNCTION([tigetstr])\n  fi\nfi\n\nif test \"x$dynamic\" = xyes; then\n  zsh_SYS_DYNAMIC_CLASH\n  zsh_SYS_DYNAMIC_GLOBAL\n  RTLD_GLOBAL_OK=$zsh_cv_sys_dynamic_rtld_global\n  zsh_SYS_DYNAMIC_EXECSYMS\n  if test \"$zsh_cv_sys_dynamic_execsyms\" != yes; then\n    L=L\n  fi\n  zsh_SYS_DYNAMIC_STRIP_EXE\n  zsh_SYS_DYNAMIC_STRIP_LIB\n  if $strip_exeldflags && test \"$zsh_cv_sys_dynamic_strip_exe\" = yes; then\n    EXELDFLAGS=\"$EXELDFLAGS -s\"\n  fi\n  if $strip_libldflags && test \"$zsh_cv_sys_dynamic_strip_lib\" = yes; then\n    LIBLDFLAGS=\"$LIBLDFLAGS -s\"\n  fi\n  if test \"$host_os\" = cygwin; then\n    INSTLIB=\"install.cygwin-lib\"\n    UNINSTLIB=\"uninstall.cygwin-lib\"\n  fi\nelse\n  $strip_exeldflags && EXELDFLAGS=\"$EXELDFLAGS -s\"\n  $strip_libldflags && LIBLDFLAGS=\"$LIBLDFLAGS -s\"\n  RTLD_GLOBAL_OK=no\nfi\n\nAH_TEMPLATE([DYNAMIC],\n[Define to 1 if you want to use dynamically loaded modules.])\nif test \"x$dynamic\" = xyes; then\n  D=D\n  AC_DEFINE(DYNAMIC)dnl\nelse\n  D=N\nfi\n\nAH_TEMPLATE([AIXDYNAMIC],\n[Define to 1 if you want to use dynamically loaded modules on AIX.])\nif test \"x$aixdynamic\" = xyes; then\n  E=E\n  AC_DEFINE(AIXDYNAMIC)dnl\nelse\n  E=N\nfi\n\nif test \"x$zsh_cv_sys_dynamic_clash_ok\" = xyes; then\n  SHORTBOOTNAMES=yes\nelse\n  SHORTBOOTNAMES=no\nfi\nAC_SUBST(SHORTBOOTNAMES)\n\nAC_SUBST(INSTLIB)dnl\nAC_SUBST(UNINSTLIB)dnl\n\nif test \"$host_os\" = cygwin; then\n  EXTRAZSHOBJS=\"$EXTRAZSHOBJS zsh.res.o\"\nfi\n\nAC_DEFINE_UNQUOTED(DL_EXT, \"$DL_EXT\",\n[The extension used for dynamically loaded modules.])dnl\nAC_SUBST(D)dnl\nAC_SUBST(DL_EXT)dnl\nAC_SUBST(DLLD)dnl\nAC_SUBST(DLCFLAGS)dnl\nAC_SUBST(DLLDFLAGS)dnl\nAC_SUBST(E)dnl\nAC_SUBST(EXTRA_LDFLAGS)dnl\nAC_SUBST(EXPOPT)dnl\nAC_SUBST(IMPOPT)dnl\nAC_SUBST(L)dnl\nAC_SUBST(LINKMODS)dnl\nAC_SUBST(MOD_EXPORT)dnl\nAC_SUBST(MOD_IMPORT_VARIABLE)dnl\nAC_SUBST(MOD_IMPORT_FUNCTION)dnl\nAC_SUBST(EXTRAZSHOBJS)dnl\n\n# Generate config.modules.  We look for *.mdd files in first and second\n# level subdirectories.  Any existing line not containing 'auto=y' will be\n# retained, provided the .mdd file itself was found.\nCONFIG_MODULES=./config.modules\ncat <<EOM > ${CONFIG_MODULES}.sh\nsrcdir=\"$srcdir\"\ndynamic=\"$dynamic\"\nCONFIG_MODULES=\"${CONFIG_MODULES}\"\nEOM\ncat <<\\EOM >> ${CONFIG_MODULES}.sh\necho \"creating ${CONFIG_MODULES}\"\nuserlist=\" \"\nif test -f ${CONFIG_MODULES}; then\n  userlist=\"`sed -e '/^#/d' -e '/auto=y/d' -e 's/ .*/ /' -e 's/^name=/ /' \\\n        ${CONFIG_MODULES}`\"\n  mv ${CONFIG_MODULES} ${CONFIG_MODULES}.old\nelse\n  # Save testing for existence each time.\n  echo > ${CONFIG_MODULES}.old\nfi\n(echo \"# Edit this file to change the way modules are loaded.\"\necho \"# The format is strict; do not break lines or add extra spaces.\"\necho \"# Run \\`make prep' if you change anything here after compiling\"\necho \"# (there is no need if you change this just after the first time\"\necho \"# you run \\`configure').\"\necho \"#\"\necho \"# Values of \\`link' are \\`static', \\`dynamic' or \\`no' to compile the\"\necho \"# module into the shell, link it in at run time, or not use it at all.\"\necho \"# In the final case, no attempt will be made to compile it.\"\necho \"# Use \\`static' or \\`no' if you do not have dynamic loading.\"\necho \"#\"\necho \"# Values of \\`load' are \\`yes' or \\`no'; if yes, any builtins etc.\"\necho \"# provided by the module will be autoloaded by the main shell\"\necho \"# (so long as \\`link' is not set to \\`no').\"\necho \"#\"\necho \"# Values of \\`auto' are \\`yes' or \\`no'. configure sets the value to\"\necho \"# \\`yes'.  If you set it by hand to \\`no', the line will be retained\"\necho \"# when the file is regenerated in future.\"\necho \"#\"\necho \"# Note that the \\`functions' entry extends to the end of the line.\"\necho \"# It should not be quoted; it is used verbatim to find files to install.\"\necho \"#\"\necho \"# You will need to run \\`config.status --recheck' if you add a new\"\necho \"# module.\"\necho \"#\"\necho \"# You should not change the values for the pseudo-module zsh/main,\"\necho \"# which is the main shell (apart from the functions entry).\"\nEOM\ndnl The autoconf macros are only available in configure, not\ndnl config.status, and only change when configure is rerun.\ndnl So we need to run the autoconf tests here and store the results.\ndnl We then generate config.modules, preserving any user-generated\ndnl information, from config.status.\nfor modfile in `cd ${srcdir}; echo */*.mdd */*/*.mdd`; do\n  name=\n  link=\n  load=\n  functions=\n  result=\n  . ${srcdir}/$modfile\n  if test x$name != x && test x\"$link\" != x; then\n    case \"$link\" in\n      *\\ *) eval \"link=\\`$link\\`\"\n\t    ;;\n    esac\n    case \"${load}\" in\n      y*) load=\" load=yes\"\n\t  ;;\n      *) load=\" load=no\"\n\t ;;\n    esac\n    if test \"x$functions\" != x; then\n      # N.B. no additional quotes\n      f=\" functions=$functions\"\n    else\n      f=\n    fi\n    case \"$link\" in\n      static) result=\"name=$name modfile=$modfile link=static auto=yes${load}$f\"\n\t      ;;\n      dynamic) if test x$dynamic != xno; then\n\t\t  result=\"name=$name modfile=$modfile link=dynamic\\\n auto=yes${load}$f\"\n\t       else\n\t\t result=\"name=$name modfile=$modfile link=no\\\n auto=yes load=no$f\"\n\t       fi\n\t       ;;\n      either) if test x$dynamic != xno; then\n\t\tresult=\"name=$name modfile=$modfile link=dynamic\\\n auto=yes${load}$f\"\n\t      else\n\t\tresult=\"name=$name modfile=$modfile link=static\\\n auto=yes${load}$f\"\n\t      fi\n\t      ;;\n       *) result=\"name=$name modfile=$modfile link=no auto=yes load=no$f\"\n\t  ;;\n    esac\ndnl $result is the default output for config.modules.  We generate\ndnl code to check if we should use this.\ncat <<EOM >> ${CONFIG_MODULES}.sh\ncase \"\\$userlist\" in\n  *\" $name \"*) grep \"^name=$name \" \\${CONFIG_MODULES}.old;;\n  *) echo \"$result\";;\nesac\nEOM\n  fi\ndone\ncat <<\\EOM >> ${CONFIG_MODULES}.sh\n) >${CONFIG_MODULES}\nrm -f ${CONFIG_MODULES}.old\nEOM\n\ndnl AH_TOP replaces the code which used to appear at the top\ndnl of acconfig.h.\nAH_TOP([/***** begin user configuration section *****/\n\n/* Define this to be the location of your password file */\n#define PASSWD_FILE \"/etc/passwd\"\n\n/* Define this to be the name of your NIS/YP password *\n * map (if applicable)                                */\n#define PASSWD_MAP \"passwd.byname\"\n\n/* Define to 1 if you want user names to be cached */\n#define CACHE_USERNAMES 1\n\n/* Define to 1 if system supports job control */\n#define JOB_CONTROL 1\n\n/* Define this if you use \"suspended\" instead of \"stopped\" */\n#define USE_SUSPENDED 1\n \n/* The default history buffer size in lines */\n#define DEFAULT_HISTSIZE 30\n\n/* The default editor for the fc builtin */\n#define DEFAULT_FCEDIT \"vi\"\n\n/* The default prefix for temporary files */\n#define DEFAULT_TMPPREFIX \"/tmp/zsh\"\n\n/***** end of user configuration section            *****/\n/***** shouldn't have to change anything below here *****/\n\n])\n\nCLEAN_MK=\"${srcdir}/Config/clean.mk\"\nCONFIG_MK=\"${srcdir}/Config/config.mk\"\ndnl defs.mk is in the build tree, not the source tree\nDEFS_MK=\"Config/defs.mk\"\nVERSION_MK=\"${srcdir}/Config/version.mk\"\n\nAC_SUBST_FILE(CLEAN_MK)dnl\nAC_SUBST_FILE(CONFIG_MK)dnl\nAC_SUBST_FILE(DEFS_MK)dnl\nAC_SUBST_FILE(VERSION_MK)dnl\n\nAC_CONFIG_FILES(Config/defs.mk Makefile Doc/Makefile Etc/Makefile \\\nSrc/Makefile Test/Makefile)\nAC_CONFIG_COMMANDS([config.modules], [. ./config.modules.sh])\nAC_CONFIG_COMMANDS([stamp-h], [echo >stamp-h])\n\nAC_OUTPUT\n\neval \"zshbin1=${bindir}\"\neval \"zshbin2=${zshbin1}\"\neval \"zshman1=${mandir}\"\neval \"zshman2=${zshman1}\"\neval \"zshinfo1=${infodir}\"\neval \"zshinfo2=${zshinfo1}\"\neval \"zshfndir1=${fndir}\"\neval \"zshfndir2=${zshfndir1}\"\n\necho \"\nzsh configuration\n-----------------\nzsh version               : ${VERSION}\nhost operating system     : ${host_cpu}-${host_vendor}-${host_os}\nsource code location      : ${srcdir}\ncompiler                  : ${CC}\npreprocessor flags        : ${CPPFLAGS}\nexecutable compiler flags : ${CFLAGS}\"\nif test \"x$dynamic\" = xyes; then\n  echo \"\\\nmodule compiler flags     : ${CFLAGS} ${DLCFLAGS}\"\nfi\necho \"\\\nexecutable linker flags   : ${LDFLAGS} ${EXELDFLAGS} ${EXTRA_LDFLAGS}\"\nif test \"x$dynamic\" = xyes; then\n  echo \"\\\nmodule linker flags       : ${LDFLAGS} ${LIBLDFLAGS} ${DLLDFLAGS}\"\nfi\necho \"\\\nlibrary flags             : ${LIBS}\ninstallation basename     : ${tzsh_name}\nbinary install path       : ${zshbin2}\nman page install path     : ${zshman2}\ninfo install path         : ${zshinfo2}\"\nif test \"$zshfndir2\" != no; then\n  echo \"functions install path    : ${zshfndir2}\"\nfi\nif test \"x$additionalfpath\" != x; then\n  echo \"additional fpath entries  : ${additionalfpath}\"\nfi\necho \"See config.modules for installed modules and functions.\n\"\n\ncase x$LIBS in\n  *-lgdbm*)\n  echo \"WARNING: zsh will be linked against libgdbm.\nThis means the binary is covered by the GNU General Public License.\nThis does not affect the source code.\nRun configure with --disable-gdbm if required.\"\n  ;;\nesac\n\nexit 0\n",
        "/tmp/vanessa/spack-stage/spack-stage-zsh-5.6.2-in6fa74mnlid6t7rhhv7rn7bvrxkfdak/spack-src/aczsh.m4": "dnl\ndnl  Autconf tests for zsh.\ndnl\ndnl  Copyright (c) 1995-1997 Richard Coleman\ndnl  All rights reserved.\ndnl\ndnl  Permission is hereby granted, without written agreement and without\ndnl  license or royalty fees, to use, copy, modify, and distribute this\ndnl  software and to distribute modified versions of this software for any\ndnl  purpose, provided that the above copyright notice and the following\ndnl  two paragraphs appear in all copies of this software.\ndnl\ndnl  In no event shall Richard Coleman or the Zsh Development Group be liable\ndnl  to any party for direct, indirect, special, incidental, or consequential\ndnl  damages arising out of the use of this software and its documentation,\ndnl  even if Richard Coleman and the Zsh Development Group have been advised of\ndnl  the possibility of such damage.\ndnl\ndnl  Richard Coleman and the Zsh Development Group specifically disclaim any\ndnl  warranties, including, but not limited to, the implied warranties of\ndnl  merchantability and fitness for a particular purpose.  The software\ndnl  provided hereunder is on an \"as is\" basis, and Richard Coleman and the\ndnl  Zsh Development Group have no obligation to provide maintenance,\ndnl  support, updates, enhancements, or modifications.\ndnl\n\ndnl\ndnl zsh_64_BIT_TYPE\ndnl   Check whether the first argument works as a 64-bit type.\ndnl   If there is a non-zero third argument, we just assume it works\ndnl   when we're cross compiling.  This is to allow a type to be\ndnl   specified directly as --enable-lfs=\"long long\".\ndnl   Sets the variable given in the second argument to the first argument\ndnl   if the test worked, `no' otherwise.  Be careful testing this, as it\ndnl   may produce two words `long long' on an unquoted substitution.\ndnl   Also check that the compiler does not mind it being cast to int.\ndnl   This macro does not produce messages as it may be run several times\ndnl   before finding the right type.\ndnl\n\nAC_DEFUN(zsh_64_BIT_TYPE,\n[AC_TRY_RUN([\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\nmain()\n{\n  $1 foo = 0; \n  int bar = (int) foo;\n  return sizeof($1) != 8;\n}\n], $2=\"$1\", $2=no,\n  [if test x$3 != x ; then\n    $2=\"$1\"\n  else\n    $2=no\n  fi])\n])\n\n\ndnl\ndnl zsh_SHARED_FUNCTION\ndnl\ndnl This is just a frontend to zsh_SHARED_SYMBOL\ndnl\ndnl Usage: zsh_SHARED_FUNCTION(name[,rettype[,paramtype]])\ndnl\n\nAC_DEFUN(zsh_SHARED_FUNCTION,\n[zsh_SHARED_SYMBOL($1, ifelse([$2], ,[int ],[$2]) $1 [(]ifelse([$3], ,[ ],[$3])[)], $1)])\n\ndnl\ndnl zsh_SHARED_VARIABLE\ndnl\ndnl This is just a frontend to zsh_SHARED_SYMBOL\ndnl\ndnl Usage: zsh_SHARED_VARIABLE(name[,type])\ndnl\n\nAC_DEFUN(zsh_SHARED_VARIABLE,\n[zsh_SHARED_SYMBOL($1, ifelse([$2], ,[int ],[$2]) $1, [&$1])])\n\ndnl\ndnl zsh_SHARED_SYMBOL\ndnl   Check whether symbol is available in static or shared library\ndnl\ndnl   On some systems, static modifiable library symbols (such as environ)\ndnl   may appear only in statically linked libraries.  If this is the case,\ndnl   then two shared libraries that reference the same symbol, each linked\ndnl   with the static library, could be given distinct copies of the symbol.\ndnl\ndnl Usage: zsh_SHARED_SYMBOL(name,declaration,address)\ndnl Sets zsh_cv_shared_$1 cache variable to yes/no\ndnl\n\nAC_DEFUN(zsh_SHARED_SYMBOL,\n[AC_CACHE_CHECK([if $1 is available in shared libraries],\nzsh_cv_shared_$1,\n[if test \"$zsh_cv_func_dlsym_needs_underscore\" = yes; then\n    us=_\nelse\n    us=\nfi\necho '\nvoid *zsh_getaddr1()\n{\n#ifdef __CYGWIN__\n\t__attribute__((__dllimport__))\t\n#endif\n\textern $2;\n\treturn $3;\n};\n' > conftest1.c\nsed 's/zsh_getaddr1/zsh_getaddr2/' < conftest1.c > conftest2.c\nif AC_TRY_COMMAND($CC -c $CFLAGS $CPPFLAGS $DLCFLAGS conftest1.c 1>&AC_FD_CC) &&\nAC_TRY_COMMAND($DLLD -o conftest1.$DL_EXT $LDFLAGS $DLLDFLAGS conftest1.o $LIBS 1>&AC_FD_CC) &&\nAC_TRY_COMMAND($CC -c $CFLAGS $CPPFLAGS $DLCFLAGS conftest2.c 1>&AC_FD_CC) &&\nAC_TRY_COMMAND($DLLD -o conftest2.$DL_EXT $LDFLAGS $DLLDFLAGS conftest2.o $LIBS 1>&AC_FD_CC); then\n    AC_TRY_RUN([\n#ifdef HPUX10DYNAMIC\n#include <dl.h>\n#define RTLD_LAZY BIND_DEFERRED\n#define RTLD_GLOBAL DYNAMIC_PATH\n\nchar *zsh_gl_sym_addr ;\n\n#define dlopen(file,mode) (void *)shl_load((file), (mode), (long) 0)\n#define dlclose(handle) shl_unload((shl_t)(handle))\n#define dlsym(handle,name) (zsh_gl_sym_addr=0,shl_findsym((shl_t *)&(handle),name,TYPE_UNDEFINED,&zsh_gl_sym_addr), (void *)zsh_gl_sym_addr)\n#define dlerror() 0\n#else\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#else\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#endif\n#endif\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\nmain()\n{\n    void *handle1, *handle2;\n    void *(*zsh_getaddr1)(), *(*zsh_getaddr2)();\n    void *sym1, *sym2;\n    handle1 = dlopen(\"./conftest1.$DL_EXT\", RTLD_LAZY | RTLD_GLOBAL);\n    if(!handle1) exit(1);\n    handle2 = dlopen(\"./conftest2.$DL_EXT\", RTLD_LAZY | RTLD_GLOBAL);\n    if(!handle2) exit(1);\n    zsh_getaddr1 = (void *(*)()) dlsym(handle1, \"${us}zsh_getaddr1\");\n    zsh_getaddr2 = (void *(*)()) dlsym(handle2, \"${us}zsh_getaddr2\");\n    sym1 = zsh_getaddr1();\n    sym2 = zsh_getaddr2();\n    if(!sym1 || !sym2) exit(1);\n    if(sym1 != sym2) exit(1);\n    dlclose(handle1);\n    handle1 = dlopen(\"./conftest1.$DL_EXT\", RTLD_LAZY | RTLD_GLOBAL);\n    if(!handle1) exit(1);\n    zsh_getaddr1 = (void *(*)()) dlsym(handle1, \"${us}zsh_getaddr1\");\n    sym1 = zsh_getaddr1();\n    if(!sym1) exit(1);\n    if(sym1 != sym2) exit(1);\n    exit(0);\n}\n], [zsh_cv_shared_$1=yes],\n[zsh_cv_shared_$1=no],\n[zsh_cv_shared_$1=no]\n)\nelse\n    zsh_cv_shared_$1=no\nfi\n])\n])\n\ndnl\ndnl zsh_SYS_DYNAMIC_CLASH\ndnl   Check whether symbol name clashes in shared libraries are acceptable.\ndnl\n\nAC_DEFUN(zsh_SYS_DYNAMIC_CLASH,\n[AC_CACHE_CHECK([if name clashes in shared objects are OK],\nzsh_cv_sys_dynamic_clash_ok,\n[if test \"$zsh_cv_func_dlsym_needs_underscore\" = yes; then\n    us=_\nelse\n    us=\nfi\necho 'int fred () { return 42; }' > conftest1.c\necho 'int fred () { return 69; }' > conftest2.c\nif AC_TRY_COMMAND($CC -c $CFLAGS $CPPFLAGS $DLCFLAGS conftest1.c 1>&AC_FD_CC) &&\nAC_TRY_COMMAND($DLLD -o conftest1.$DL_EXT $LDFLAGS $DLLDFLAGS conftest1.o $LIBS 1>&AC_FD_CC) &&\nAC_TRY_COMMAND($CC -c $CFLAGS $CPPFLAGS $DLCFLAGS conftest2.c 1>&AC_FD_CC) &&\nAC_TRY_COMMAND($DLLD -o conftest2.$DL_EXT $LDFLAGS $DLLDFLAGS conftest2.o $LIBS 1>&AC_FD_CC); then\n    AC_TRY_RUN([\n#ifdef HPUX10DYNAMIC\n#include <dl.h>\n#define RTLD_LAZY BIND_DEFERRED\n#define RTLD_GLOBAL DYNAMIC_PATH\n\nchar *zsh_gl_sym_addr ;\n\n#define dlopen(file,mode) (void *)shl_load((file), (mode), (long) 0)\n#define dlclose(handle) shl_unload((shl_t)(handle))\n#define dlsym(handle,name) (zsh_gl_sym_addr=0,shl_findsym((shl_t *)&(handle),name,TYPE_UNDEFINED,&zsh_gl_sym_addr), (void *)zsh_gl_sym_addr)\n#define dlerror() 0\n#else\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#else\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#endif\n#endif\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n\nmain()\n{\n    void *handle1, *handle2;\n    int (*fred1)(), (*fred2)();\n    handle1 = dlopen(\"./conftest1.$DL_EXT\", RTLD_LAZY | RTLD_GLOBAL);\n    if(!handle1) exit(1);\n    handle2 = dlopen(\"./conftest2.$DL_EXT\", RTLD_LAZY | RTLD_GLOBAL);\n    if(!handle2) exit(1);\n    fred1 = (int (*)()) dlsym(handle1, \"${us}fred\");\n    fred2 = (int (*)()) dlsym(handle2, \"${us}fred\");\n    if(!fred1 || !fred2) exit(1);\n    exit((*fred1)() != 42 || (*fred2)() != 69);\n}\n], [zsh_cv_sys_dynamic_clash_ok=yes],\n[zsh_cv_sys_dynamic_clash_ok=no],\n[zsh_cv_sys_dynamic_clash_ok=no]\n)\nelse\n    zsh_cv_sys_dynamic_clash_ok=no\nfi\n])\nif test \"$zsh_cv_sys_dynamic_clash_ok\" = yes; then\n    AC_DEFINE(DYNAMIC_NAME_CLASH_OK)\nfi\n])\n\ndnl\ndnl zsh_SYS_DYNAMIC_GLOBAL\ndnl   Check whether symbols in one dynamically loaded library are\ndnl   available to another dynamically loaded library.\ndnl\n\nAC_DEFUN(zsh_SYS_DYNAMIC_GLOBAL,\n[AC_CACHE_CHECK([for working RTLD_GLOBAL],\nzsh_cv_sys_dynamic_rtld_global,\n[if test \"$zsh_cv_func_dlsym_needs_underscore\" = yes; then\n    us=_\nelse\n    us=\nfi\necho 'int fred () { return 42; }' > conftest1.c\necho 'extern int fred(); int barney () { return fred() + 27; }' > conftest2.c\nif AC_TRY_COMMAND($CC -c $CFLAGS $CPPFLAGS $DLCFLAGS conftest1.c 1>&AC_FD_CC) &&\nAC_TRY_COMMAND($DLLD -o conftest1.$DL_EXT $LDFLAGS $DLLDFLAGS conftest1.o $LIBS 1>&AC_FD_CC) &&\nAC_TRY_COMMAND($CC -c $CFLAGS $CPPFLAGS $DLCFLAGS conftest2.c 1>&AC_FD_CC) &&\nAC_TRY_COMMAND($DLLD -o conftest2.$DL_EXT $LDFLAGS $DLLDFLAGS conftest2.o $LIBS 1>&AC_FD_CC); then\n    AC_TRY_RUN([\n#ifdef HPUX10DYNAMIC\n#include <dl.h>\n#define RTLD_LAZY BIND_DEFERRED\n#define RTLD_GLOBAL DYNAMIC_PATH\n\nchar *zsh_gl_sym_addr ;\n\n#define dlopen(file,mode) (void *)shl_load((file), (mode), (long) 0)\n#define dlclose(handle) shl_unload((shl_t)(handle))\n#define dlsym(handle,name) (zsh_gl_sym_addr=0,shl_findsym((shl_t *)&(handle),name,TYPE_UNDEFINED,&zsh_gl_sym_addr), (void *)zsh_gl_sym_addr)\n#define dlerror() 0\n#else\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#else\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#endif\n#endif\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\nmain()\n{\n    void *handle;\n    int (*barneysym)();\n    handle = dlopen(\"./conftest1.$DL_EXT\", RTLD_LAZY | RTLD_GLOBAL);\n    if(!handle) exit(1);\n    handle = dlopen(\"./conftest2.$DL_EXT\", RTLD_LAZY | RTLD_GLOBAL);\n    if(!handle) exit(1);\n    barneysym = (int (*)()) dlsym(handle, \"${us}barney\");\n    if(!barneysym) exit(1);\n    exit((*barneysym)() != 69);\n}\n], [zsh_cv_sys_dynamic_rtld_global=yes],\n[zsh_cv_sys_dynamic_rtld_global=no],\n[zsh_cv_sys_dynamic_rtld_global=no]\n)\nelse\n    zsh_cv_sys_dynamic_rtld_global=no\nfi\n])\n])\n\ndnl\ndnl zsh_SYS_DYNAMIC_EXECSYMS\ndnl   Check whether symbols in the executable are available to dynamically\ndnl   loaded libraries.\ndnl\n\nAC_DEFUN(zsh_SYS_DYNAMIC_EXECSYMS,\n[AC_CACHE_CHECK([whether symbols in the executable are available],\nzsh_cv_sys_dynamic_execsyms,\n[if test \"$zsh_cv_func_dlsym_needs_underscore\" = yes; then\n    us=_\nelse\n    us=\nfi\necho 'extern int fred(); int barney () { return fred() + 27; }' > conftest1.c\nif AC_TRY_COMMAND($CC -c $CFLAGS $CPPFLAGS $DLCFLAGS conftest1.c 1>&AC_FD_CC) &&\nAC_TRY_COMMAND($DLLD -o conftest1.$DL_EXT $LDFLAGS $DLLDFLAGS conftest1.o $LIBS 1>&AC_FD_CC); then\n    save_ldflags=$LDFLAGS\n    LDFLAGS=\"$LDFLAGS $EXTRA_LDFLAGS\"\n    AC_TRY_RUN([\n#ifdef HPUX10DYNAMIC\n#include <dl.h>\n#define RTLD_LAZY BIND_DEFERRED\n#define RTLD_GLOBAL DYNAMIC_PATH\n\nchar *zsh_gl_sym_addr ;\n\n#define dlopen(file,mode) (void *)shl_load((file), (mode), (long) 0)\n#define dlclose(handle) shl_unload((shl_t)(handle))\n#define dlsym(handle,name) (zsh_gl_sym_addr=0,shl_findsym((shl_t *)&(handle),name,TYPE_UNDEFINED,&zsh_gl_sym_addr), (void *)zsh_gl_sym_addr)\n#define dlerror() 0\n#else\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#else\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#endif\n#endif\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\nmain()\n{\n    void *handle;\n    int (*barneysym)();\n    handle = dlopen(\"./conftest1.$DL_EXT\", RTLD_LAZY | RTLD_GLOBAL);\n    if(!handle) exit(1);\n    barneysym = (int (*)()) dlsym(handle, \"${us}barney\");\n    if(!barneysym) exit(1);\n    exit((*barneysym)() != 69);\n}\n\nint fred () { return 42; }\n], [zsh_cv_sys_dynamic_execsyms=yes],\n[zsh_cv_sys_dynamic_execsyms=no],\n[zsh_cv_sys_dynamic_execsyms=no]\n)\n    LDFLAGS=$save_ldflags\nelse\n    zsh_cv_sys_dynamic_execsyms=no\nfi\n])\n])\n\ndnl\ndnl zsh_SYS_DYNAMIC_STRIP_EXE\ndnl   Check whether it is safe to strip executables.\ndnl\n\nAC_DEFUN(zsh_SYS_DYNAMIC_STRIP_EXE,\n[AC_REQUIRE([zsh_SYS_DYNAMIC_EXECSYMS])\nAC_CACHE_CHECK([whether executables can be stripped],\nzsh_cv_sys_dynamic_strip_exe,\n[if test \"$zsh_cv_sys_dynamic_execsyms\" != yes; then\n    zsh_cv_sys_dynamic_strip_exe=yes\nelif\n    if test \"$zsh_cv_func_dlsym_needs_underscore\" = yes; then\n\tus=_\n    else\n\tus=\n    fi\n    echo 'extern int fred(); int barney() { return fred() + 27; }' > conftest1.c\n    AC_TRY_COMMAND($CC -c $CFLAGS $CPPFLAGS $DLCFLAGS conftest1.c 1>&AC_FD_CC) &&\n    AC_TRY_COMMAND($DLLD -o conftest1.$DL_EXT $LDFLAGS $DLLDFLAGS conftest1.o $LIBS 1>&AC_FD_CC); then\n    save_ldflags=$LDFLAGS\n    LDFLAGS=\"$LDFLAGS $EXTRA_LDFLAGS -s\"\n    AC_TRY_RUN([\n#ifdef HPUX10DYNAMIC\n#include <dl.h>\n#define RTLD_LAZY BIND_DEFERRED\n#define RTLD_GLOBAL DYNAMIC_PATH\n\nchar *zsh_gl_sym_addr ;\n\n#define dlopen(file,mode) (void *)shl_load((file), (mode), (long) 0)\n#define dlclose(handle) shl_unload((shl_t)(handle))\n#define dlsym(handle,name) (zsh_gl_sym_addr=0,shl_findsym((shl_t *)&(handle),name,TYPE_UNDEFINED,&zsh_gl_sym_addr), (void *)zsh_gl_sym_addr)\n#define dlerror() 0\n#else\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#else\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#endif\n#endif\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\nmain()\n{\n    void *handle;\n    int (*barneysym)();\n    handle = dlopen(\"./conftest1.$DL_EXT\", RTLD_LAZY | RTLD_GLOBAL);\n    if(!handle) exit(1);\n    barneysym = (int (*)()) dlsym(handle, \"${us}barney\");\n    if(!barneysym) exit(1);\n    exit((*barneysym)() != 69);\n}\n\nint fred () { return 42; }\n], [zsh_cv_sys_dynamic_strip_exe=yes],\n[zsh_cv_sys_dynamic_strip_exe=no],\n[zsh_cv_sys_dynamic_strip_exe=no]\n)\n    LDFLAGS=$save_ldflags\nelse\n    zsh_cv_sys_dynamic_strip_exe=no\nfi\n])\n])\n\ndnl\ndnl zsh_SYS_DYNAMIC_STRIP_EXE\ndnl   Check whether it is safe to strip dynamically loaded libraries.\ndnl\n\nAC_DEFUN(zsh_SYS_DYNAMIC_STRIP_LIB,\n[AC_CACHE_CHECK([whether libraries can be stripped],\nzsh_cv_sys_dynamic_strip_lib,\n[if test \"$zsh_cv_func_dlsym_needs_underscore\" = yes; then\n    us=_\nelse\n    us=\nfi\necho 'int fred () { return 42; }' > conftest1.c\nif AC_TRY_COMMAND($CC -c $CFLAGS $CPPFLAGS $DLCFLAGS conftest1.c 1>&AC_FD_CC) &&\nAC_TRY_COMMAND($DLLD -o conftest1.$DL_EXT $LDFLAGS $DLLDFLAGS -s conftest1.o $LIBS 1>&AC_FD_CC); then\n    AC_TRY_RUN([\n#ifdef HPUX10DYNAMIC\n#include <dl.h>\n#define RTLD_LAZY BIND_DEFERRED\n#define RTLD_GLOBAL DYNAMIC_PATH\n\nchar *zsh_gl_sym_addr ;\n\n#define dlopen(file,mode) (void *)shl_load((file), (mode), (long) 0)\n#define dlclose(handle) shl_unload((shl_t)(handle))\n#define dlsym(handle,name) (zsh_gl_sym_addr=0,shl_findsym((shl_t *)&(handle),name,TYPE_UNDEFINED,&zsh_gl_sym_addr), (void *)zsh_gl_sym_addr)\n#define dlerror() 0\n#else\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#else\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#endif\n#endif\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\nmain()\n{\n    void *handle;\n    int (*fredsym)();\n    handle = dlopen(\"./conftest1.$DL_EXT\", RTLD_LAZY | RTLD_GLOBAL);\n    if(!handle) exit(1);\n    fredsym = (int (*)()) dlsym(handle, \"${us}fred\");\n    if(!fredsym) exit(1);\n    exit((*fredsym)() != 42);\n}\n], [zsh_cv_sys_dynamic_strip_lib=yes],\n[zsh_cv_sys_dynamic_strip_lib=no],\n[zsh_cv_sys_dynamic_strip_lib=no]\n)\nelse\n    zsh_cv_sys_dynamic_strip_lib=no\nfi\n])\n])\n\ndnl\ndnl zsh_PATH_UTMP(filename)\ndnl   Search for a specified utmp-type file.\ndnl\n\nAC_DEFUN(zsh_PATH_UTMP,\n[AC_CACHE_CHECK([for $1 file], [zsh_cv_path_$1],\n[for dir in /etc /usr/etc /var/adm /usr/adm /var/run /var/log ./conftest; do\n  zsh_cv_path_$1=${dir}/$1\n  test -f $zsh_cv_path_$1 && break\n  zsh_cv_path_$1=no\ndone\n])\nAH_TEMPLATE([PATH_]translit($1, [a-z], [A-Z])[_FILE],\n[Define to be location of ]$1[ file.])\nif test $zsh_cv_path_$1 != no; then\n  AC_DEFINE_UNQUOTED([PATH_]translit($1, [a-z], [A-Z])[_FILE],\n  \"$zsh_cv_path_$1\")\nfi\n])\n\ndnl\ndnl zsh_TYPE_EXISTS(#includes, type name)\ndnl   Check whether a specified type exists.\ndnl\n\nAC_DEFUN(zsh_TYPE_EXISTS,\n[AC_CACHE_CHECK([for $2], [zsh_cv_type_exists_[]translit($2, [ ], [_])],\n[AC_TRY_COMPILE([$1], [$2 testvar;],\n[zsh_cv_type_exists_[]translit($2, [ ], [_])=yes],\n[zsh_cv_type_exists_[]translit($2, [ ], [_])=no])\n])\nAH_TEMPLATE([HAVE_]translit($2, [ a-z], [_A-Z]),\n[Define to 1 if ]$2[ is defined by a system header])\nif test $zsh_cv_type_exists_[]translit($2, [ ], [_]) = yes; then\n  AC_DEFINE([HAVE_]translit($2, [ a-z], [_A-Z]))\nfi\n])\n\ndnl\ndnl zsh_STRUCT_MEMBER(#includes, type name, member name)\ndnl   Check whether a specified aggregate type exists and contains\ndnl   a specified member.\ndnl\n\nAC_DEFUN(zsh_STRUCT_MEMBER,\n[AC_CACHE_CHECK([for $3 in $2], [zsh_cv_struct_member_[]translit($2, [ ], [_])_$3],\n[AC_TRY_COMPILE([$1], [$2 testvar; testvar.$3;],\n[zsh_cv_struct_member_[]translit($2, [ ], [_])_$3=yes],\n[zsh_cv_struct_member_[]translit($2, [ ], [_])_$3=no])\n])\nAH_TEMPLATE([HAVE_]translit($2_$3, [ a-z], [_A-Z]),\n[Define if your system's ]$2[ has a member named ]$3[.])\nif test $zsh_cv_struct_member_[]translit($2, [ ], [_])_$3 = yes; then\n  AC_DEFINE([HAVE_]translit($2_$3, [ a-z], [_A-Z]))\nfi\n])\n\ndnl\ndnl zsh_ARG_PROGRAM\ndnl   Handle AC_ARG_PROGRAM substitutions into other zsh configure macros.\ndnl   After processing this macro, the configure script may refer to\ndnl   and $tzsh_name, and @tzsh@ is defined for make substitutions.\ndnl\n\nAC_DEFUN(zsh_ARG_PROGRAM,\n[AC_ARG_PROGRAM\n# Un-double any \\ or $ (doubled by AC_ARG_PROGRAM).\ncat <<\\EOF_SED > conftestsed\ns,\\\\\\\\,\\\\,g; s,\\$\\$,$,g\nEOF_SED\nzsh_transform_name=`echo \"${program_transform_name}\" | sed -f conftestsed`\nrm -f conftestsed\ntzsh_name=`echo zsh | sed -e \"${zsh_transform_name}\"`\n# Double any \\ or $ in the transformed name that results.\ncat <<\\EOF_SED >> conftestsed\ns,\\\\,\\\\\\\\,g; s,\\$,$$,g\nEOF_SED\ntzsh=`echo ${tzsh_name} | sed -f conftestsed`\nrm -f conftestsed\nAC_SUBST(tzsh)dnl\n])\n\nAC_DEFUN(zsh_COMPILE_FLAGS,\n    [AC_ARG_ENABLE(cppflags,\n\tAC_HELP_STRING([--enable-cppflags=...], [specify C preprocessor flags]),\n\tif test \"$enableval\" = \"yes\"\n\tthen CPPFLAGS=\"$1\"\n\telse CPPFLAGS=\"$enable_cppflags\"\n\tfi)\n    AC_ARG_ENABLE(cflags,\n\tAC_HELP_STRING([--enable-cflags=...], [specify C compiler flags]),\n\tif test \"$enableval\" = \"yes\"\n\tthen CFLAGS=\"$2\"\n\telse CFLAGS=\"$enable_cflags\"\n\tfi)\n    AC_ARG_ENABLE(ldflags,\n\tAC_HELP_STRING([--enable-ldflags=...], [specify linker flags]),\n\tif test \"$enableval\" = \"yes\"\n\tthen LDFLAGS=\"$3\"\n\telse LDFLAGS=\"$enable_ldflags\"\n\tfi)\n    AC_ARG_ENABLE(libs,\n\tAC_HELP_STRING([--enable-libs=...], [specify link libraries]),\n\tif test \"$enableval\" = \"yes\"\n\tthen LIBS=\"$4\"\n\telse LIBS=\"$enable_libs\"\n\tfi)])\n\ndnl \ndnl zsh_CHECK_SOCKLEN_T\ndnl\ndnl\tcheck type of third argument of some network functions; currently\ndnl\ttested are size_t *, unsigned long *, int *.\ndnl     call the result ZSOCKLEN_T since some systems have SOCKLEN_T already\ndnl\nAC_DEFUN([zsh_CHECK_SOCKLEN_T],[\n  AC_CACHE_CHECK(\n    [base type of the third argument to accept],\n    [zsh_cv_type_socklen_t],\n    [zsh_cv_type_socklen_t=\n    for zsh_type in socklen_t int \"unsigned long\" size_t ; do\n      AC_TRY_COMPILE(\n        [#include <sys/types.h>\n         #include <sys/socket.h>],\n        [extern int accept (int, struct sockaddr *, $zsh_type *);],\n        [zsh_cv_type_socklen_t=\"$zsh_type\"; break],\n        []\n      )\n    done\n    if test -z \"$zsh_cv_type_socklen_t\"; then\n      zsh_cv_type_socklen_t=int\n    fi]\n  )\n  AC_DEFINE_UNQUOTED([ZSOCKLEN_T], [$zsh_cv_type_socklen_t],\n  [Define to the base type of the third argument of accept])]\n)\n\ndnl Check for limit $1 e.g. RLIMIT_RSS.\nAC_DEFUN(zsh_LIMIT_PRESENT,\n[AH_TEMPLATE([HAVE_]$1,\n[Define to 1 if ]$1[ is present (whether or not as a macro).])\nAC_CACHE_CHECK([for limit $1],\nzsh_cv_have_$1,\n[AC_TRY_COMPILE([\n#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#include <sys/resource.h>],\n[$1],\n  zsh_cv_have_$1=yes,\n  zsh_cv_have_$1=no)])\n\nif test $zsh_cv_have_$1 = yes; then\n  AC_DEFINE(HAVE_$1)\nfi])\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-zsh-5.6.2-in6fa74mnlid6t7rhhv7rn7bvrxkfdak/spack-src/Src/module.c": "/*\n * module.c - deal with dynamic modules\n *\n * This file is part of zsh, the Z shell.\n *\n * Copyright (c) 1996-1997 Zolt\u00e1n Hidv\u00e9gi\n * All rights reserved.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and to distribute modified versions of this software for any\n * purpose, provided that the above copyright notice and the following\n * two paragraphs appear in all copies of this software.\n *\n * In no event shall Zolt\u00e1n Hidv\u00e9gi or the Zsh Development Group be liable\n * to any party for direct, indirect, special, incidental, or consequential\n * damages arising out of the use of this software and its documentation,\n * even if Zolt\u00e1n Hidv\u00e9gi and the Zsh Development Group have been advised of\n * the possibility of such damage.\n *\n * Zolt\u00e1n Hidv\u00e9gi and the Zsh Development Group specifically disclaim any\n * warranties, including, but not limited to, the implied warranties of\n * merchantability and fitness for a particular purpose.  The software\n * provided hereunder is on an \"as is\" basis, and Zolt\u00e1n Hidv\u00e9gi and the\n * Zsh Development Group have no obligation to provide maintenance,\n * support, updates, enhancements, or modifications.\n */\n\n#include \"zsh.mdh\"\n#include \"module.pro\"\n\n/*\n * List of linked-in modules.\n * This is set up at boot and remains for the life of the shell;\n * entries do not appear in \"zmodload\" listings.\n */\n\n/**/\nLinkList linkedmodules;\n\n/* $module_path ($MODULE_PATH) */\n\n/**/\nchar **module_path;\n\n/* Hash of modules */\n\n/**/\nmod_export HashTable modulestab;\n\n/*\n * Bit flags passed as the \"flags\" argument of a autofeaturefn_t.\n * Used in other places, such as the final argument to\n * do_module_features().\n */\nenum {\n    /*\n     * `-i' option: ignore errors pertaining to redefinitions,\n     * or indicate to do_module_features() that it should be\n     * silent.\n     */\n    FEAT_IGNORE = 0x0001,\n    /* If a condition, condition is infix rather than prefix */\n    FEAT_INFIX = 0x0002,\n    /*\n     * Enable all features in the module when autoloading.\n     * This is the traditional zmodload -a behaviour;\n     * zmodload -Fa only enables features explicitly marked for\n     * autoloading.\n     */\n    FEAT_AUTOALL = 0x0004,\n    /*\n     * Remove feature:  alternative to \"-X:NAME\" used if\n     * X is passed separately from NAME.\n     */\n    FEAT_REMOVE = 0x0008,\n    /*\n     * For do_module_features().  Check that any autoloads\n     * for the module are actually provided.\n     */\n    FEAT_CHECKAUTO = 0x0010\n};\n\n/*\n * All functions to add or remove autoloadable features fit\n * the following prototype.\n *\n * \"module\" is the name of the module.\n *\n * \"feature\" is the name of the feature, minus any type prefix.\n *\n * \"flags\" is a set of the bits above.\n *\n * The return value is 0 for success, -1 for failure with no\n * message needed, and one of the following to indicate the calling\n * function should print a message:\n *\n * 1:  failed to add [type] `[feature]'\n * 2:  [feature]: no such [type]\n * 3:  [feature]: [type] is already defined\n */\ntypedef int (*autofeaturefn_t)(const char *module, const char *feature,\n\t\t\t       int flags);\n\n/* Bits in the second argument to find_module. */\nenum {\n    /*\n     * Resolve any aliases to the underlying module.\n     */\n    FINDMOD_ALIASP = 0x0001,\n    /*\n     * Create an element for the module in the list if\n     * it is not found.\n     */\n    FINDMOD_CREATE = 0x0002,\n};\n\nstatic void\nfreemodulenode(HashNode hn)\n{\n    Module m = (Module) hn;\n\n    if (m->node.flags & MOD_ALIAS)\n\tzsfree(m->u.alias);\n    zsfree(m->node.nam);\n    if (m->autoloads)\n\tfreelinklist(m->autoloads, freestr);\n    if (m->deps)\n\tfreelinklist(m->deps, freestr);\n    zfree(m, sizeof(*m));\n}\n\n/* flags argument to printmodulenode */\nenum {\n    /* -L flag, output zmodload commands */\n    PRINTMOD_LIST = 0x0001,\n    /* -e flag */\n    PRINTMOD_EXIST = 0x0002,\n    /* -A flag */\n    PRINTMOD_ALIAS = 0x0004,\n    /* -d flag */\n    PRINTMOD_DEPS = 0x0008,\n    /* -F flag */\n    PRINTMOD_FEATURES = 0x0010,\n    /* -l flag in combination with -L flag */\n    PRINTMOD_LISTALL = 0x0020,\n    /* -a flag */\n    PRINTMOD_AUTO = 0x0040\n};\n\n/* Scan function for printing module details */\n\nstatic void\nprintmodulenode(HashNode hn, int flags)\n{\n    Module m = (Module)hn;\n    /*\n     * If we check for a module loaded under an alias, we\n     * need the name of the alias.  We can use it in other\n     * cases, too.\n     */\n    const char *modname = m->node.nam;\n\n    if (flags & PRINTMOD_DEPS) {\n\t/*\n\t * Print the module's dependencies.\n\t */\n\tLinkNode n;\n\n\tif (!m->deps)\n\t    return;\n\n\tif (flags & PRINTMOD_LIST) {\n\t    printf(\"zmodload -d \");\n\t    if (modname[0] == '-')\n\t\tfputs(\"-- \", stdout);\n\t    quotedzputs(modname, stdout);\n\t} else {\n\t    nicezputs(modname, stdout);\n\t    putchar(':');\n\t}\n\tfor (n = firstnode(m->deps); n; incnode(n)) {\n\t    putchar(' ');\n\t    if (flags & PRINTMOD_LIST)\n\t\tquotedzputs((char *) getdata(n), stdout);\n\t    else\n\t\tnicezputs((char *) getdata(n), stdout);\n\t}\n    } else if (flags & PRINTMOD_EXIST) {\n\t/*\n\t * Just print the module name, provided the module is\n\t * present under an alias or otherwise.\n\t */\n\tif (m->node.flags & MOD_ALIAS) {\n\t    if (!(flags & PRINTMOD_ALIAS) ||\n\t\t!(m = find_module(m->u.alias, FINDMOD_ALIASP, NULL)))\n\t\treturn;\n\t}\n\tif (!m->u.handle || (m->node.flags & MOD_UNLOAD))\n\t    return;\n\tnicezputs(modname, stdout);\n   } else if (m->node.flags & MOD_ALIAS) {\n\t/*\n\t * Normal listing, but for aliases.\n\t */\n\tif (flags & PRINTMOD_LIST) {\n\t    printf(\"zmodload -A \");\n\t    if (modname[0] == '-')\n\t\tfputs(\"-- \", stdout);\n\t    quotedzputs(modname, stdout);\n\t    putchar('=');\n\t    quotedzputs(m->u.alias, stdout);\n\t} else {\n\t    nicezputs(modname, stdout);\n\t    fputs(\" -> \", stdout);\n\t    nicezputs(m->u.alias, stdout);\n\t}\n    } else if (m->u.handle || (flags & PRINTMOD_AUTO)) {\n\t/*\n\t * Loaded module.\n\t */\n\tif (flags & PRINTMOD_LIST) {\n\t    /*\n\t     * List with -L format.  Possibly we are printing\n\t     * features, either enables or autoloads.\n\t     */\n\t    char **features = NULL;\n\t    int *enables = NULL;\n\t    if (flags & PRINTMOD_AUTO) {\n\t\tif (!m->autoloads || !firstnode(m->autoloads))\n\t\t    return;\n\t    } else if (flags & PRINTMOD_FEATURES) {\n\t\tif (features_module(m, &features) ||\n\t\t    enables_module(m, &enables) ||\n\t\t    !*features)\n\t\t    return;\n\t    }\n\t    printf(\"zmodload \");\n\t    if (flags & PRINTMOD_AUTO) {\n\t\tfputs(\"-Fa \", stdout);\n\t    } else if (features)\n\t\tfputs(\"-F \", stdout);\n\t    if(modname[0] == '-')\n\t\tfputs(\"-- \", stdout);\n\t    quotedzputs(modname, stdout);\n\t    if (flags & PRINTMOD_AUTO) {\n\t\tLinkNode an;\n\t\tfor (an = firstnode(m->autoloads); an; incnode(an)) {\n\t\t    putchar(' ');\n\t\t    quotedzputs((char *)getdata(an), stdout);\n\t\t}\n\t    } else if (features) {\n\t\tconst char *f;\n\t\twhile ((f = *features++)) {\n\t\t    int on = *enables++;\n\t\t    if (flags & PRINTMOD_LISTALL)\n\t\t\tprintf(\" %s\", on ? \"+\" : \"-\");\n\t\t    else if (!on)\n\t\t\tcontinue;\n\t\t    else\n\t\t\tputchar(' ');\n\t\t    quotedzputs(f, stdout);\n\t\t}\n\t    }\n\t} else /* -l */\n\t    nicezputs(modname, stdout);\n    } else\n\treturn;\n    putchar('\\n');\n}\n\n/**/\nHashTable\nnewmoduletable(int size, char const *name)\n{\n    HashTable ht;\n    ht = newhashtable(size, name, NULL);\n\n    ht->hash        = hasher;\n    ht->emptytable  = emptyhashtable;\n    ht->filltable   = NULL;\n    ht->cmpnodes    = strcmp;\n    ht->addnode     = addhashnode;\n    /* DISABLED is not supported */\n    ht->getnode     = gethashnode2;\n    ht->getnode2    = gethashnode2;\n    ht->removenode  = removehashnode;\n    ht->disablenode = NULL;\n    ht->enablenode  = NULL;\n    ht->freenode    = freemodulenode;\n    ht->printnode   = printmodulenode;\n\n    return ht;\n}\n\n/************************************************************************\n * zsh/main standard module functions\n ************************************************************************/\n\n/* The `zsh/main' module contains all the base code that can't actually be *\n * built as a separate module.  It is initialised by main(), so there's    *\n * nothing for the boot function to do.                                    */\n\n/**/\nint\nsetup_(UNUSED(Module m))\n{\n    return 0;\n}\n\n/**/\nint\nfeatures_(UNUSED(Module m), UNUSED(char ***features))\n{\n    /*\n     * There are lots and lots of features, but they're not\n     * handled here.\n     */\n    return 1;\n}\n\n/**/\nint\nenables_(UNUSED(Module m), UNUSED(int **enables))\n{\n    return 1;\n}\n\n/**/\nint\nboot_(UNUSED(Module m))\n{\n    return 0;\n}\n\n/**/\nint\ncleanup_(UNUSED(Module m))\n{\n    return 0;\n}\n\n/**/\nint\nfinish_(UNUSED(Module m))\n{\n    return 0;\n}\n\n\n/************************************************************************\n * Module utility functions\n ************************************************************************/\n\n/* This registers a builtin module.                                   */\n\n/**/\nvoid\nregister_module(char *n, Module_void_func setup,\n\t\tModule_features_func features,\n\t\tModule_enables_func enables,\n\t\tModule_void_func boot,\n\t\tModule_void_func cleanup,\n\t\tModule_void_func finish)\n{\n    Linkedmod m;\n\n    m = (Linkedmod) zalloc(sizeof(*m));\n\n    m->name = ztrdup(n);\n    m->setup = setup;\n    m->features = features;\n    m->enables = enables;\n    m->boot = boot;\n    m->cleanup = cleanup;\n    m->finish = finish;\n\n    zaddlinknode(linkedmodules, m);\n}\n\n/* Check if a module is linked in. */\n\n/**/\nLinkedmod\nmodule_linked(char const *name)\n{\n    LinkNode node;\n\n    for (node = firstnode(linkedmodules); node; incnode(node))\n\tif (!strcmp(((Linkedmod) getdata(node))->name, name))\n\t    return (Linkedmod) getdata(node);\n\n    return NULL;\n}\n\n\n/************************************************************************\n * Support for the various feature types.\n * First, builtins.\n ************************************************************************/\n\n/* addbuiltin() can be used to add a new builtin.  It returns zero on *\n * success, 1 on failure.  The only possible type of failure is that  *\n * a builtin with the specified name already exists.  An autoloaded   *\n * builtin can be replaced using this function.                       */\n\n/**/\nstatic int\naddbuiltin(Builtin b)\n{\n    Builtin bn = (Builtin) builtintab->getnode2(builtintab, b->node.nam);\n    if (bn && (bn->node.flags & BINF_ADDED))\n\treturn 1;\n    if (bn)\n\tbuiltintab->freenode(builtintab->removenode(builtintab, b->node.nam));\n    builtintab->addnode(builtintab, b->node.nam, b);\n    return 0;\n}\n\n/* Define an autoloadable builtin.  It returns 0 on success, or 1 on *\n * failure.  The only possible cause of failure is that a builtin    *\n * with the specified name already exists.                           */\n\n/**/\nstatic int\nadd_autobin(const char *module, const char *bnam, int flags)\n{\n    Builtin bn;\n    int ret;\n\n    bn = zshcalloc(sizeof(*bn));\n    bn->node.nam = ztrdup(bnam);\n    bn->optstr = ztrdup(module);\n    if (flags & FEAT_AUTOALL)\n\tbn->node.flags |= BINF_AUTOALL;\n    if ((ret = addbuiltin(bn))) {\n\tbuiltintab->freenode(&bn->node);\n\tif (!(flags & FEAT_IGNORE))\n\t    return 1;\n    }\n    return 0;\n}\n\n/* Remove the builtin added previously by addbuiltin().  Returns *\n * zero on succes and -1 if there is no builtin with that name.  */\n\n/**/\nint\ndeletebuiltin(const char *nam)\n{\n    Builtin bn;\n\n    bn = (Builtin) builtintab->removenode(builtintab, nam);\n    if (!bn)\n\treturn -1;\n    builtintab->freenode(&bn->node);\n    return 0;\n}\n\n/* Remove an autoloaded added by add_autobin */\n\n/**/\nstatic int\ndel_autobin(UNUSED(const char *module), const char *bnam, int flags)\n{\n    Builtin bn = (Builtin) builtintab->getnode2(builtintab, bnam);\n    if (!bn) {\n\tif(!(flags & FEAT_IGNORE))\n\t    return 2;\n    } else if (bn->node.flags & BINF_ADDED) {\n\tif (!(flags & FEAT_IGNORE))\n\t    return 3;\n    } else\n\tdeletebuiltin(bnam);\n\n    return 0;\n}\n\n/*\n * Manipulate a set of builtins.  This should be called\n * via setfeatureenables() (or, usually, via the next level up,\n * handlefeatures()).\n *\n * \"nam\" is the name of the calling code builtin, probably \"zmodload\".\n *\n * \"binl\" is the builtin table containing an array of \"size\" builtins.\n *\n * \"e\" is either NULL, in which case all builtins in the\n * table are removed, or else an array corresponding to \"binl\"\n * with a 1 for builtins that are to be added and a 0 for builtins\n * that are to be removed.  Any builtin already in the appropriate\n * state is left alone.\n *\n * Returns 1 on any error, 0 for success.  The recommended way\n * of handling errors is to compare the enables passed down\n * with the set retrieved after the error to find what failed.\n */\n\n/**/\nstatic int\nsetbuiltins(char const *nam, Builtin binl, int size, int *e)\n{\n    int ret = 0, n;\n\n    for(n = 0; n < size; n++) {\n\tBuiltin b = &binl[n];\n\tif (e && *e++) {\n\t    if (b->node.flags & BINF_ADDED)\n\t\tcontinue;\n\t    if (addbuiltin(b)) {\n\t\tzwarnnam(nam,\n\t\t\t \"name clash when adding builtin `%s'\", b->node.nam);\n\t\tret = 1;\n\t    } else {\n\t\tb->node.flags |= BINF_ADDED;\n\t    }\n\t} else {\n\t    if (!(b->node.flags & BINF_ADDED))\n\t\tcontinue;\n\t    if (deletebuiltin(b->node.nam)) {\n\t\tzwarnnam(nam, \"builtin `%s' already deleted\", b->node.nam);\n\t\tret = 1;\n\t    } else {\n\t\tb->node.flags &= ~BINF_ADDED;\n\t    }\n\t}\n    }\n    return ret;\n}\n\n/*\n * Add multiple builtins.  binl points to a table of `size' builtin\n * structures.  Those for which (.flags & BINF_ADDED) is false are to be\n * added; that flag is set if they succeed.\n *\n * If any fail, an error message is printed, using nam as the leading name.\n * Returns 0 on success, 1 for any failure.\n *\n * This should not be used from a module; instead, use handlefeatures().\n */\n\n/**/\nmod_export int\naddbuiltins(char const *nam, Builtin binl, int size)\n{\n    int ret = 0, n;\n\n    for(n = 0; n < size; n++) {\n\tBuiltin b = &binl[n];\n\tif(b->node.flags & BINF_ADDED)\n\t    continue;\n\tif(addbuiltin(b)) {\n\t    zwarnnam(nam, \"name clash when adding builtin `%s'\", b->node.nam);\n\t    ret = 1;\n\t} else {\n\t    b->node.flags |= BINF_ADDED;\n\t}\n    }\n    return ret;\n}\n\n\n/************************************************************************\n * Function wrappers.\n ************************************************************************/\n\n/* The list of function wrappers defined. */\n\n/**/\nFuncWrap wrappers;\n\n/* This adds a definition for a wrapper. Return value is one in case of *\n * error and zero if all went fine. */\n\n/**/\nmod_export int\naddwrapper(Module m, FuncWrap w)\n{\n    FuncWrap p, q;\n\n    /*\n     * We can't add a wrapper to an alias, since it's supposed\n     * to behave identically to the resolved module.  This shouldn't\n     * happen since we usually add wrappers when a real module is\n     * loaded.\n     */\n    if (m->node.flags & MOD_ALIAS)\n\treturn 1;\n\n    if (w->flags & WRAPF_ADDED)\n\treturn 1;\n    for (p = wrappers, q = NULL; p; q = p, p = p->next);\n    if (q)\n\tq->next = w;\n    else\n\twrappers = w;\n    w->next = NULL;\n    w->flags |= WRAPF_ADDED;\n    w->module = m;\n\n    return 0;\n}\n\n/* This removes the given wrapper definition from the list. Returned is *\n * one in case of error and zero otherwise. */\n\n/**/\nmod_export int\ndeletewrapper(Module m, FuncWrap w)\n{\n    FuncWrap p, q;\n\n    if (m->node.flags & MOD_ALIAS)\n\treturn 1;\n\n    if (w->flags & WRAPF_ADDED) {\n\tfor (p = wrappers, q = NULL; p && p != w; q = p, p = p->next);\n\n\tif (p) {\n\t    if (q)\n\t\tq->next = p->next;\n\t    else\n\t\twrappers = p->next;\n\t    p->flags &= ~WRAPF_ADDED;\n\n\t    return 0;\n\t}\n    }\n    return 1;\n}\n\n\n/************************************************************************\n * Conditions.\n ************************************************************************/\n\n/* The list of module-defined conditions. */\n\n/**/\nmod_export Conddef condtab;\n\n/* This gets a condition definition with the given name. The first        *\n * argument says if we have to look for an infix condition. The last      *\n * argument is non-zero if we should autoload modules if needed. */\n\n/**/\nConddef\ngetconddef(int inf, const char *name, int autol)\n{\n    Conddef p;\n    int f = 1;\n    char *lookup, *s;\n\n    /* detokenize the Dash to the form encoded in lookup tables */\n    lookup = dupstring(name);\n    if (!lookup)\n\treturn NULL;\n    for (s = lookup; *s != '\\0'; s++) {\n\tif (*s == Dash)\n\t    *s = '-';\n    }\n\n    do {\n\tfor (p = condtab; p; p = p->next) {\n\t    if ((!!inf == !!(p->flags & CONDF_INFIX)) &&\n\t\t!strcmp(lookup, p->name))\n\t\tbreak;\n\t}\n\tif (autol && p && p->module) {\n\t    /*\n\t     * This is a definition for an autoloaded condition; load the\n\t     * module if we haven't tried that already.\n\t     */\n\t    if (f) {\n\t\t(void)ensurefeature(p->module,\n\t\t\t\t    (p->flags & CONDF_INFIX) ? \"C:\" : \"c:\",\n\t\t\t\t    (p->flags & CONDF_AUTOALL) ? NULL : lookup);\n\t\tf = 0;\n\t\tp = NULL;\n\t    } else {\n\t\tdeleteconddef(p);\n\t\treturn NULL;\n\t    }\n\t} else\n\t    break;\n    } while (!p);\n\n    return p;\n}\n\n/*\n * This adds the given condition definition. The return value is zero on *\n * success and 1 on failure. If there is a matching definition for an    *\n * autoloaded condition, it is removed.\n *\n * This is used for adding both an autoload definition or\n * a real condition.  In the latter case the caller is responsible\n * for setting the CONDF_ADDED flag.\n */\n\n/**/\nstatic int\naddconddef(Conddef c)\n{\n    Conddef p = getconddef((c->flags & CONDF_INFIX), c->name, 0);\n\n    if (p) {\n\tif (!p->module || (p->flags & CONDF_ADDED))\n\t    return 1;\n\t/* There is an autoload definition. */\n\n\tdeleteconddef(p);\n    }\n    c->next = condtab;\n    condtab = c;\n    return 0;\n}\n\n/* This removes the given condition definition from the list(s). If this *\n * is a definition for a autoloaded condition, the memory is freed. */\n\n/**/\nint\ndeleteconddef(Conddef c)\n{\n    Conddef p, q;\n\n    for (p = condtab, q = NULL; p && p != c; q = p, p = p->next);\n\n    if (p) {\n\tif (q)\n\t    q->next = p->next;\n\telse\n\t    condtab = p->next;\n\n\tif (p->module) {\n\t    /* autoloaded, free it */\n\t    zsfree(p->name);\n\t    zsfree(p->module);\n\t    zfree(p, sizeof(*p));\n\t}\n\treturn 0;\n    }\n    return -1;\n}\n\n/*\n * Add or remove sets of conditions.  The interface is\n * identical to setbuiltins().\n */\n\n/**/\nstatic int\nsetconddefs(char const *nam, Conddef c, int size, int *e)\n{\n    int ret = 0;\n\n    while (size--) {\n\tif (e && *e++) {\n\t    if (c->flags & CONDF_ADDED) {\n\t\tc++;\n\t\tcontinue;\n\t    }\n\t    if (addconddef(c)) {\n\t\tzwarnnam(nam, \"name clash when adding condition `%s'\",\n\t\t\t c->name);\n\t\tret = 1;\n\t    } else {\n\t\tc->flags |= CONDF_ADDED;\n\t    }\n\t} else {\n\t    if (!(c->flags & CONDF_ADDED)) {\n\t\tc++;\n\t\tcontinue;\n\t    }\n\t    if (deleteconddef(c)) {\n\t\tzwarnnam(nam, \"condition `%s' already deleted\", c->name);\n\t\tret = 1;\n\t    } else {\n\t\tc->flags &= ~CONDF_ADDED;\n\t    }\n\t}\n\tc++;\n    }\n    return ret;\n}\n\n/* This adds a definition for autoloading a module for a condition. */\n\n/**/\nstatic int\nadd_autocond(const char *module, const char *cnam, int flags)\n{\n    Conddef c;\n\n    c = (Conddef) zalloc(sizeof(*c));\n\n    c->name = ztrdup(cnam);\n    c->flags = ((flags & FEAT_INFIX) ? CONDF_INFIX : 0);\n    if (flags & FEAT_AUTOALL)\n\tc->flags |= CONDF_AUTOALL;\n    c->module = ztrdup(module);\n\n    if (addconddef(c)) {\n\tzsfree(c->name);\n\tzsfree(c->module);\n\tzfree(c, sizeof(*c));\n\n\tif (!(flags & FEAT_IGNORE))\n\t    return 1;\n    }\n    return 0;\n}\n\n/* Remove a condition added with add_autocond */\n\n/**/\nstatic int\ndel_autocond(UNUSED(const char *modnam), const char *cnam, int flags)\n{\n    Conddef cd = getconddef((flags & FEAT_INFIX) ? 1 : 0, cnam, 0);\n\n    if (!cd) {\n\tif (!(flags & FEAT_IGNORE)) {\n\t    return 2;\n\t}\n    } else if (cd->flags & CONDF_ADDED) {\n\tif (!(flags & FEAT_IGNORE))\n\t    return 3;\n    } else\n\tdeleteconddef(cd);\n\n    return 0;\n}\n\n/************************************************************************\n * Hook functions.\n ************************************************************************/\n\n/* This list of hook functions defined. */\n\n/**/\nHookdef hooktab;\n\n/* Find a hook definition given the name. */\n\n/**/\nHookdef\ngethookdef(char *n)\n{\n    Hookdef p;\n\n    for (p = hooktab; p; p = p->next)\n\tif (!strcmp(n, p->name))\n\t    return p;\n    return NULL;\n}\n\n/* This adds the given hook definition. The return value is zero on      *\n * success and 1 on failure.                                             */\n\n/**/\nint\naddhookdef(Hookdef h)\n{\n    if (gethookdef(h->name))\n\treturn 1;\n\n    h->next = hooktab;\n    hooktab = h;\n    h->funcs = znewlinklist();\n\n    return 0;\n}\n\n/*\n * This adds multiple hook definitions. This is like addbuiltins().\n * This allows a NULL module because we call it from init.c.\n */\n\n/**/\nmod_export int\naddhookdefs(Module m, Hookdef h, int size)\n{\n    int ret = 0;\n\n    while (size--) {\n\tif (addhookdef(h)) {\n\t    zwarnnam(m ? m->node.nam : NULL,\n\t\t     \"name clash when adding hook `%s'\", h->name);\n\t    ret = 1;\n\t}\n\th++;\n    }\n    return ret;\n}\n\n/* Delete hook definitions. */\n\n/**/\nint\ndeletehookdef(Hookdef h)\n{\n    Hookdef p, q;\n\n    for (p = hooktab, q = NULL; p && p != h; q = p, p = p->next);\n\n    if (!p)\n\treturn 1;\n\n    if (q)\n\tq->next = p->next;\n    else\n\thooktab = p->next;\n    freelinklist(p->funcs, NULL);\n    return 0;\n}\n\n/* Remove multiple hook definitions. */\n\n/**/\nmod_export int\ndeletehookdefs(UNUSED(Module m), Hookdef h, int size)\n{\n    int ret = 0;\n\n    while (size--) {\n\tif (deletehookdef(h))\n\t    ret = 1;\n\th++;\n    }\n    return ret;\n}\n\n/* Add a function to a hook. */\n\n/**/\nint\naddhookdeffunc(Hookdef h, Hookfn f)\n{\n    zaddlinknode(h->funcs, (void *) f);\n\n    return 0;\n}\n\n/**/\nmod_export int\naddhookfunc(char *n, Hookfn f)\n{\n    Hookdef h = gethookdef(n);\n\n    if (h)\n\treturn addhookdeffunc(h, f);\n    return 1;\n}\n\n/* Delete a function from a hook. */\n\n/**/\nint\ndeletehookdeffunc(Hookdef h, Hookfn f)\n{\n    LinkNode p;\n\n    for (p = firstnode(h->funcs); p; incnode(p))\n\tif (f == (Hookfn) getdata(p)) {\n\t    remnode(h->funcs, p);\n\t    return 0;\n\t}\n    return 1;\n}\n\n/* Delete a hook. */\n\n/**/\nmod_export int\ndeletehookfunc(char *n, Hookfn f)\n{\n    Hookdef h = gethookdef(n);\n\n    if (h)\n\treturn deletehookdeffunc(h, f);\n    return 1;\n}\n\n/* Run the function(s) for a hook. */\n\n/**/\nmod_export int\nrunhookdef(Hookdef h, void *d)\n{\n    if (empty(h->funcs)) {\n\tif (h->def)\n\t    return h->def(h, d);\n\treturn 0;\n    } else if (h->flags & HOOKF_ALL) {\n\tLinkNode p;\n\tint r;\n\n\tfor (p = firstnode(h->funcs); p; incnode(p))\n\t    if ((r = ((Hookfn) getdata(p))(h, d)))\n\t\treturn r;\n\tif (h->def)\n\t    return h->def(h, d);\n\treturn 0;\n    } else\n\treturn ((Hookfn) getdata(lastnode(h->funcs)))(h, d);\n}\n\n\n\n/************************************************************************\n * Shell parameters.\n ************************************************************************/\n\n/*\n * Check that it's possible to add a parameter.  This\n * requires that either there's no parameter already present,\n * or it's a global parameter marked for autoloading.\n *\n * The special status 2 is to indicate it didn't work but\n * -i was in use so we didn't print a warning.\n */\n\nstatic int\ncheckaddparam(const char *nam, int opt_i)\n{\n    Param pm;\n\n    if (!(pm = (Param) gethashnode2(paramtab, nam)))\n\treturn 0;\n\n    if (pm->level || !(pm->node.flags & PM_AUTOLOAD)) {\n\t/*\n\t * -i suppresses \"it's already that way\" warnings,\n\t * but not \"this can't possibly work\" warnings, so we print\n\t * the message anyway if there's a local parameter blocking\n\t * the parameter we want to add, not if there's a\n\t * non-autoloadable parameter already there.  This\n\t * is consistent with the way add_auto* functions work.\n\t */\n\tif (!opt_i || !pm->level) {\n\t    zwarn(\"Can't add module parameter `%s': %s\",\n\t\t  nam, pm->level ?\n\t\t  \"local parameter exists\" :\n\t\t  \"parameter already exists\");\n\t    return 1;\n\t}\n\treturn 2;\n    }\n\n    unsetparam_pm(pm, 0, 1);\n    return 0;\n}\n\n/* This adds the given parameter definition. The return value is zero on *\n * success and 1 on failure. */\n\n/**/\nint\naddparamdef(Paramdef d)\n{\n    Param pm;\n\n    if (checkaddparam(d->name, 0))\n\treturn 1;\n\n    if (d->getnfn) {\n\tif (!(pm = createspecialhash(d->name, d->getnfn,\n\t\t\t\t     d->scantfn, d->flags)))\n\t    return 1;\n    }\n    else if (!(pm = createparam(d->name, d->flags)) &&\n\t!(pm = (Param) paramtab->getnode(paramtab, d->name)))\n\treturn 1;\n\n    d->pm = pm;\n    pm->level = 0;\n    if (d->var)\n\tpm->u.data = d->var;\n    if (d->var || d->gsu) {\n\t/*\n\t * If no get/set/unset class, use the appropriate\n\t * variable type, else use the one supplied.\n\t */\n\tswitch (PM_TYPE(pm->node.flags)) {\n\tcase PM_SCALAR:\n\t    pm->gsu.s = d->gsu ? (GsuScalar)d->gsu : &varscalar_gsu;\n\t    break;\n\n\tcase PM_INTEGER:\n\t    pm->gsu.i = d->gsu ? (GsuInteger)d->gsu : &varinteger_gsu;\n\t    break;\n\n\tcase PM_FFLOAT:\n\tcase PM_EFLOAT:\n\t    pm->gsu.f = d->gsu;\n\t    break;\n\n\tcase PM_ARRAY:\n\t    pm->gsu.a = d->gsu ? (GsuArray)d->gsu : &vararray_gsu;\n\t    break;\n\n\tcase PM_HASHED:\n\t    /* hashes may behave like standard hashes */\n\t    if (d->gsu)\n\t\tpm->gsu.h = (GsuHash)d->gsu;\n\t    break;\n\n\tdefault:\n\t    unsetparam_pm(pm, 0, 1);\n\t    return 1;\n\t}\n    }\n\n    return 0;\n}\n\n/* Delete parameters defined. No error checking yet. */\n\n/**/\nint\ndeleteparamdef(Paramdef d)\n{\n    Param pm = (Param) paramtab->getnode(paramtab, d->name);\n\n    if (!pm)\n\treturn 1;\n    if (pm != d->pm) {\n\t/*\n\t * See if the parameter has been hidden.  If so,\n\t * bring it to the front to unset it.\n\t */\n\tParam prevpm, searchpm;\n\tfor (prevpm = pm, searchpm = pm->old;\n\t     searchpm;\n\t     prevpm = searchpm, searchpm = searchpm->old)\n\t    if (searchpm == d->pm)\n\t\tbreak;\n\n\tif (!searchpm)\n\t    return 1;\n\n\tparamtab->removenode(paramtab, pm->node.nam);\n\tprevpm->old = searchpm->old;\n\tsearchpm->old = pm;\n\tparamtab->addnode(paramtab, searchpm->node.nam, searchpm);\n\n\tpm = searchpm;\n    }\n    pm->node.flags = (pm->node.flags & ~PM_READONLY) | PM_REMOVABLE;\n    unsetparam_pm(pm, 0, 1);\n    d->pm = NULL;\n    return 0;\n}\n\n/*\n * Add or remove sets of parameters.  The interface is\n * identical to setbuiltins().\n */\n\n/**/\nstatic int\nsetparamdefs(char const *nam, Paramdef d, int size, int *e)\n{\n    int ret = 0;\n\n    while (size--) {\n\tif (e && *e++) {\n\t    if (d->pm) {\n\t\td++;\n\t\tcontinue;\n\t    }\n\t    if (addparamdef(d)) {\n\t\tzwarnnam(nam, \"error when adding parameter `%s'\", d->name);\n\t\tret = 1;\n\t    }\n\t} else {\n\t    if (!d->pm) {\n\t\td++;\n\t\tcontinue;\n\t    }\n\t    if (deleteparamdef(d)) {\n\t\tzwarnnam(nam, \"parameter `%s' already deleted\", d->name);\n\t\tret = 1;\n\t    }\n\t}\n\td++;\n    }\n    return ret;\n}\n\n/* This adds a definition for autoloading a module for a parameter. */\n\n/**/\nstatic int\nadd_autoparam(const char *module, const char *pnam, int flags)\n{\n    Param pm;\n    int ret;\n\n    queue_signals();\n    if ((ret = checkaddparam(pnam, (flags & FEAT_IGNORE)))) {\n\tunqueue_signals();\n\t/*\n\t * checkaddparam() has already printed a message if one was\n\t * needed.  If it wasn't owing to the presence of -i, ret is 2;\n\t * for consistency with other add_auto* functions we return\n\t * status 0 to indicate there's already such a parameter and\n\t * we've been told not to worry if so.\n\t */\n\treturn ret == 2 ? 0 : -1;\n    }\n\n    pm = setsparam(dupstring(pnam), ztrdup(module));\n\n    pm->node.flags |= PM_AUTOLOAD;\n    if (flags & FEAT_AUTOALL)\n\tpm->node.flags |= PM_AUTOALL;\n    unqueue_signals();\n\n    return 0;\n}\n\n/* Remove a parameter added with add_autoparam() */\n\n/**/\nstatic int\ndel_autoparam(UNUSED(const char *modnam), const char *pnam, int flags)\n{\n    Param pm = (Param) gethashnode2(paramtab, pnam);\n\n    if (!pm) {\n\tif (!(flags & FEAT_IGNORE))\n\t    return 2;\n    } else if (!(pm->node.flags & PM_AUTOLOAD)) {\n\tif (!(flags & FEAT_IGNORE))\n\t    return 3;\n    } else\n\tunsetparam_pm(pm, 0, 1);\n\n    return 0;\n}\n\n/************************************************************************\n * Math functions.\n ************************************************************************/\n\n/* List of math functions. */\n\n/**/\nMathFunc mathfuncs;\n\n/*\n * Remove a single math function form the list (utility function).\n * This does not delete a module math function, that's deletemathfunc().\n */\n\n/**/\nvoid\nremovemathfunc(MathFunc previous, MathFunc current)\n{\n    if (previous)\n\tprevious->next = current->next;\n    else\n\tmathfuncs = current->next;\n\n    zsfree(current->name);\n    zsfree(current->module);\n    zfree(current, sizeof(*current));\n}\n\n/* Find a math function in the list, handling autoload if necessary. */\n\n/**/\nMathFunc\ngetmathfunc(const char *name, int autol)\n{\n    MathFunc p, q = NULL;\n\n    for (p = mathfuncs; p; q = p, p = p->next)\n\tif (!strcmp(name, p->name)) {\n\t    if (autol && p->module && !(p->flags & MFF_USERFUNC)) {\n\t\tchar *n = dupstring(p->module);\n\t\tint flags = p->flags;\n\n\t\tremovemathfunc(q, p);\n\n\t\t(void)ensurefeature(n, \"f:\", (flags & MFF_AUTOALL) ? NULL :\n\t\t\t\t    name);\n\n\t       p = getmathfunc(name, 0);\n\t       if (!p) {\n\t\t   zerr(\"autoloading module %s failed to define math function: %s\", n, name);\n\t       }\n\t    }\n\t    return p;\n\t}\n\n    return NULL;\n}\n\n/* Add a single math function */\n\n/**/\nstatic int\naddmathfunc(MathFunc f)\n{\n    MathFunc p, q = NULL;\n\n    if (f->flags & MFF_ADDED)\n\treturn 1;\n\n    for (p = mathfuncs; p; q = p, p = p->next)\n\tif (!strcmp(f->name, p->name)) {\n\t    if (p->module && !(p->flags & MFF_USERFUNC)) {\n\t\t/*\n\t\t * Autoloadable, replace.\n\t\t */\n\t\tremovemathfunc(q, p);\n\t\tbreak;\n\t    }\n\t    return 1;\n\t}\n\n    f->next = mathfuncs;\n    mathfuncs = f;\n\n    return 0;\n}\n\n/* Delete a single math function */\n\n/**/\nmod_export int\ndeletemathfunc(MathFunc f)\n{\n    MathFunc p, q;\n\n    for (p = mathfuncs, q = NULL; p && p != f; q = p, p = p->next);\n\n    if (p) {\n\tif (q)\n\t    q->next = f->next;\n\telse\n\t    mathfuncs = f->next;\n\n\t/* the following applies to both unloaded and user-defined functions */\n\tif (f->module) {\n\t    zsfree(f->name);\n\t    zsfree(f->module);\n\t    zfree(f, sizeof(*f));\n\t} else\n\t    f->flags &= ~MFF_ADDED;\n\n\treturn 0;\n    }\n    return -1;\n}\n\n/*\n * Add or remove sets of math functions.  The interface is\n * identical to setbuiltins().\n */\n\n/**/\nstatic int\nsetmathfuncs(char const *nam, MathFunc f, int size, int *e)\n{\n    int ret = 0;\n\n    while (size--) {\n\tif (e && *e++) {\n\t    if (f->flags & MFF_ADDED) {\n\t\tf++;\n\t\tcontinue;\n\t    }\n\t    if (addmathfunc(f)) {\n\t\tzwarnnam(nam, \"name clash when adding math function `%s'\",\n\t\t\t f->name);\n\t\tret = 1;\n\t    } else {\n\t\tf->flags |= MFF_ADDED;\n\t    }\n\t} else {\n\t    if (!(f->flags & MFF_ADDED)) {\n\t\tf++;\n\t\tcontinue;\n\t    }\n\t    if (deletemathfunc(f)) {\n\t\tzwarnnam(nam, \"math function `%s' already deleted\", f->name);\n\t\tret = 1;\n\t    } else {\n\t\tf->flags &= ~MFF_ADDED;\n\t    }\n\t}\n\tf++;\n    }\n    return ret;\n}\n\n/* Add an autoload definition for a math function. */\n\n/**/\nstatic int\nadd_automathfunc(const char *module, const char *fnam, int flags)\n{\n    MathFunc f;\n\n    f = (MathFunc) zalloc(sizeof(*f));\n\n    f->name = ztrdup(fnam);\n    f->module = ztrdup(module);\n    f->flags = 0;\n\n    if (addmathfunc(f)) {\n\tzsfree(f->name);\n\tzsfree(f->module);\n\tzfree(f, sizeof(*f));\n\n\tif (!(flags & FEAT_IGNORE))\n\t    return 1;\n    }\n\n    return 0;\n}\n\n/* Remove a math function added with add_automathfunc() */\n\n/**/\nstatic int\ndel_automathfunc(UNUSED(const char *modnam), const char *fnam, int flags)\n{\n    MathFunc f = getmathfunc(fnam, 0);\n    \n    if (!f) {\n\tif (!(flags & FEAT_IGNORE))\n\t    return 2;\n    } else if (f->flags & MFF_ADDED) {\n\tif (!(flags & FEAT_IGNORE))\n\t    return 3;\n    } else\n\tdeletemathfunc(f);\n\n    return 0;\n}\n\n/************************************************************************\n * Now support for dynamical loading and the fallback functions\n * we use for loading if dynamical loading is not available.\n ************************************************************************/\n\n/**/\n#ifdef DYNAMIC\n\n/**/\n#ifdef AIXDYNAMIC\n\n#include <sys/ldr.h>\n\nstatic char *dlerrstr[256];\n\nstatic void *\nload_and_bind(const char *fn)\n{\n    void *ret = (void *) load((char *) fn, L_NOAUTODEFER, NULL);\n\n    if (ret) {\n\tModule m;\n\tint i, err = loadbind(0, (void *) addbuiltin, ret);\n\tfor (i = 0; i < modulestab->hsize && !err; i++) {\n\t    for (m = (Module)modulestab->nodes[i]; m && !err;\n\t\t m = (Module)m->node.next) {\n\t\tif (!(m->node.flags & MOD_ALIAS) &&\n\t\t    m->u.handle && !(m->node.flags & MOD_LINKED))\n\t\t    err |= loadbind(0, m->u.handle, ret);\n\t    }\n\t}\n\n\tif (err) {\n\t    loadquery(L_GETMESSAGES, dlerrstr, sizeof(dlerrstr));\n\t    unload(ret);\n\t    ret = NULL;\n\t}\n    } else\n\tloadquery(L_GETMESSAGES, dlerrstr, sizeof(dlerrstr));\n\n    return ret;\n}\n\n#define dlopen(X,Y) load_and_bind(X)\n#define dlclose(X)  unload(X)\n#define dlerror()   (dlerrstr[0])\n#ifndef HAVE_DLERROR\n# define HAVE_DLERROR 1\n#endif\n\n/**/\n#else\n\n#ifdef HAVE_DLFCN_H\n# if defined(HAVE_DL_H) && defined(HPUX10DYNAMIC)\n#  include <dl.h>\n# else\n#  include <dlfcn.h>\n# endif\n#else\n# ifdef HAVE_DL_H\n#  include <dl.h>\n#  define RTLD_LAZY BIND_DEFERRED\n#  define RTLD_GLOBAL DYNAMIC_PATH\n# else\n#  include <sys/types.h>\n#  include <nlist.h>\n#  include <link.h>\n# endif\n#endif\n\n/**/\n#ifdef HPUX10DYNAMIC\n# define dlopen(file,mode) (void *)shl_load((file), (mode), (long) 0)\n# define dlclose(handle) shl_unload((shl_t)(handle))\n\nstatic\nvoid *\nhpux_dlsym(void *handle, char *name)\n{\n    void *sym_addr;\n    if (!shl_findsym((shl_t *)&handle, name, TYPE_UNDEFINED, &sym_addr))\n\treturn sym_addr;\n    return NULL;\n}\n\n# define dlsym(handle,name) hpux_dlsym(handle,name)\n# ifdef HAVE_DLERROR\t\t/* paranoia */\n#  undef HAVE_DLERROR\n# endif\n#else\n# ifndef HAVE_DLCLOSE\n#  define dlclose(X) ((X), 0)\n# endif\n/**/\n#endif\n\n#ifdef DLSYM_NEEDS_UNDERSCORE\n# define STR_SETUP     \"_setup_\"\n# define STR_FEATURES  \"_features_\"\n# define STR_ENABLES   \"_enables_\"\n# define STR_BOOT      \"_boot_\"\n# define STR_CLEANUP   \"_cleanup_\"\n# define STR_FINISH    \"_finish_\"\n#else /* !DLSYM_NEEDS_UNDERSCORE */\n# define STR_SETUP     \"setup_\"\n# define STR_FEATURES  \"features_\"\n# define STR_ENABLES   \"enables_\"\n# define STR_BOOT      \"boot_\"\n# define STR_CLEANUP   \"cleanup_\"\n# define STR_FINISH    \"finish_\"\n#endif /* !DLSYM_NEEDS_UNDERSCORE */\n\n/**/\n#endif /* !AIXDYNAMIC */\n\n#ifndef RTLD_LAZY\n# define RTLD_LAZY 1\n#endif\n#ifndef RTLD_GLOBAL\n# define RTLD_GLOBAL 0\n#endif\n\n/*\n * Attempt to load a module.  This is the lowest level of\n * zsh function for dynamical modules.  Returns the handle\n * from the dynamic loader.\n */\n\n/**/\nstatic void *\ntry_load_module(char const *name)\n{\n    char buf[PATH_MAX + 1];\n    char **pp;\n    void *ret = NULL;\n    int l;\n\n    l = 1 + strlen(name) + 1 + strlen(DL_EXT);\n    for (pp = module_path; !ret && *pp; pp++) {\n\tif (l + (**pp ? strlen(*pp) : 1) > PATH_MAX)\n\t    continue;\n\tsprintf(buf, \"%s/%s.%s\", **pp ? *pp : \".\", name, DL_EXT);\n\tunmetafy(buf, NULL);\n\tif (*buf) /* dlopen(NULL) returns a handle to the main binary */\n\t    ret = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);\n    }\n\n    return ret;\n}\n\n/*\n * Load a module, with option to complain or not.\n * Returns the handle from the dynamic loader.\n */\n\n/**/\nstatic void *\ndo_load_module(char const *name, int silent)\n{\n    void *ret;\n\n    ret = try_load_module(name);\n    if (!ret && !silent) {\n#ifdef HAVE_DLERROR\n\tchar *errstr = dlerror();\n\tzwarn(\"failed to load module `%s': %s\", name,\n\t      errstr ? metafy(errstr, -1, META_HEAPDUP) : \"empty module path\");\n#else\n\tzwarn(\"failed to load module: %s\", name);\n#endif\n    }\n    return ret;\n}\n\n/**/\n#else /* !DYNAMIC */\n\n/*\n * Dummy loader when no dynamic loading available; always fails.\n */\n\n/**/\nstatic void *\ndo_load_module(char const *name, int silent)\n{\n    if (!silent)\n\tzwarn(\"failed to load module: %s\", name);\n\n    return NULL;\n}\n\n/**/\n#endif /* !DYNAMIC */\n\n/*\n * Find a module in the list.\n * flags is a set of bits defined in the enum above.\n * If namep is set, this is set to point to the last alias value resolved,\n *   even if that module was not loaded. or the module name if no aliases.\n *   Hence this is always the physical module to load in a chain of aliases.\n * Return NULL if the module named is not stored as a structure, or if we were\n * resolving aliases and the final module named is not stored as a\n * structure.\n */\n/**/\nstatic Module\nfind_module(const char *name, int flags, const char **namep)\n{\n    Module m;\n\n    m = (Module)modulestab->getnode2(modulestab, name);\n    if (m) {\n\tif ((flags & FINDMOD_ALIASP) && (m->node.flags & MOD_ALIAS)) {\n\t    if (namep)\n\t\t*namep = m->u.alias;\n\t    return find_module(m->u.alias, flags, namep);\n\t}\n\tif (namep)\n\t    *namep = m->node.nam;\n\treturn m;\n    }\n    if (!(flags & FINDMOD_CREATE))\n\treturn NULL;\n    m = zshcalloc(sizeof(*m));\n    modulestab->addnode(modulestab, ztrdup(name), m);\n    return m;\n}\n\n/*\n * Unlink and free a module node from the linked list.\n */\n\n/**/\nstatic void\ndelete_module(Module m)\n{\n    modulestab->removenode(modulestab, m->node.nam);\n\n    modulestab->freenode(&m->node);\n}\n\n/*\n * Return 1 if a module is fully loaded else zero.\n * A linked module may be marked as unloaded even though\n * we can't fully unload it; this returns 0 to try to\n * make that state transparently like an unloaded module.\n */\n\n/**/\nmod_export int\nmodule_loaded(const char *name)\n{\n    Module m;\n\n    return ((m = find_module(name, FINDMOD_ALIASP, NULL)) &&\n\t    m->u.handle &&\n\t    !(m->node.flags & MOD_UNLOAD));\n}\n\n/*\n * Setup and cleanup functions:  we don't search for aliases here,\n * since they should have been resolved before we try to load or unload\n * the module.\n */\n\n/**/\n#ifdef DYNAMIC\n\n/**/\n#ifdef AIXDYNAMIC\n\n/**/\nstatic int\ndyn_setup_module(Module m)\n{\n    return ((int (*)_((int,Module, void*))) m->u.handle)(0, m, NULL);\n}\n\n/**/\nstatic int\ndyn_features_module(Module m, char ***features)\n{\n    return ((int (*)_((int,Module, void*))) m->u.handle)(4, m, features);\n}\n\n/**/\nstatic int\ndyn_enables_module(Module m, int **enables)\n{\n    return ((int (*)_((int,Module, void*))) m->u.handle)(5, m, enables);\n}\n\n/**/\nstatic int\ndyn_boot_module(Module m)\n{\n    return ((int (*)_((int,Module, void*))) m->u.handle)(1, m, NULL);\n}\n\n/**/\nstatic int\ndyn_cleanup_module(Module m)\n{\n    return ((int (*)_((int,Module, void*))) m->u.handle)(2, m, NULL);\n}\n\n/**/\nstatic int\ndyn_finish_module(Module m)\n{\n    return ((int (*)_((int,Module,void *))) m->u.handle)(3, m, NULL);\n}\n\n/**/\n#else\n\nstatic Module_generic_func\nmodule_func(Module m, char *name)\n{\n#ifdef DYNAMIC_NAME_CLASH_OK\n    return (Module_generic_func) dlsym(m->u.handle, name);\n#else /* !DYNAMIC_NAME_CLASH_OK */\n    VARARR(char, buf, strlen(name) + strlen(m->node.nam)*2 + 1);\n    char const *p;\n    char *q;\n    strcpy(buf, name);\n    q = strchr(buf, 0);\n    for(p = m->node.nam; *p; p++) {\n\tif(*p == '/') {\n\t    *q++ = 'Q';\n\t    *q++ = 's';\n\t} else if(*p == '_') {\n\t    *q++ = 'Q';\n\t    *q++ = 'u';\n\t} else if(*p == 'Q') {\n\t    *q++ = 'Q';\n\t    *q++ = 'q';\n\t} else\n\t    *q++ = *p;\n    }\n    *q = 0;\n    return (Module_generic_func) dlsym(m->u.handle, buf);\n#endif /* !DYNAMIC_NAME_CLASH_OK */\n}\n\n/**/\nstatic int\ndyn_setup_module(Module m)\n{\n    Module_void_func fn = (Module_void_func)module_func(m, STR_SETUP);\n\n    if (fn)\n\treturn fn(m);\n    zwarnnam(m->node.nam, \"no setup function\");\n    return 1;\n}\n\n/**/\nstatic int\ndyn_features_module(Module m, char ***features)\n{\n    Module_features_func fn =\n\t(Module_features_func)module_func(m, STR_FEATURES);\n\n    if (fn)\n\treturn fn(m, features);\n    /* not a user-visible error if no features function */\n    return 1;\n}\n\n/**/\nstatic int\ndyn_enables_module(Module m, int **enables)\n{\n    Module_enables_func fn = (Module_enables_func)module_func(m, STR_ENABLES);\n\n    if (fn)\n\treturn fn(m, enables);\n    /* not a user-visible error if no enables function */\n    return 1;\n}\n\n/**/\nstatic int\ndyn_boot_module(Module m)\n{\n    Module_void_func fn = (Module_void_func)module_func(m, STR_BOOT);\n\n    if(fn)\n\treturn fn(m);\n    zwarnnam(m->node.nam, \"no boot function\");\n    return 1;\n}\n\n/**/\nstatic int\ndyn_cleanup_module(Module m)\n{\n    Module_void_func fn = (Module_void_func)module_func(m, STR_CLEANUP);\n\n    if(fn)\n\treturn fn(m);\n    zwarnnam(m->node.nam, \"no cleanup function\");\n    return 1;\n}\n\n/* Note that this function does more than just calling finish_foo(), *\n * it really unloads the module. */\n\n/**/\nstatic int\ndyn_finish_module(Module m)\n{\n    Module_void_func fn = (Module_void_func)module_func(m, STR_FINISH);\n    int r;\n\n    if (fn)\n\tr = fn(m);\n    else {\n\tzwarnnam(m->node.nam, \"no finish function\");\n\tr = 1;\n    }\n    dlclose(m->u.handle);\n    return r;\n}\n\n/**/\n#endif /* !AIXDYNAMIC */\n\n/**/\nstatic int\nsetup_module(Module m)\n{\n    return ((m->node.flags & MOD_LINKED) ?\n\t    (m->u.linked->setup)(m) : dyn_setup_module(m));\n}\n\n/**/\nstatic int\nfeatures_module(Module m, char ***features)\n{\n    return ((m->node.flags & MOD_LINKED) ?\n\t    (m->u.linked->features)(m, features) :\n\t    dyn_features_module(m, features));\n}\n\n/**/\nstatic int\nenables_module(Module m, int **enables)\n{\n    return ((m->node.flags & MOD_LINKED) ?\n\t    (m->u.linked->enables)(m, enables) :\n\t    dyn_enables_module(m, enables));\n}\n\n/**/\nstatic int\nboot_module(Module m)\n{\n    return ((m->node.flags & MOD_LINKED) ?\n\t    (m->u.linked->boot)(m) : dyn_boot_module(m));\n}\n\n/**/\nstatic int\ncleanup_module(Module m)\n{\n    return ((m->node.flags & MOD_LINKED) ?\n\t    (m->u.linked->cleanup)(m) : dyn_cleanup_module(m));\n}\n\n/**/\nstatic int\nfinish_module(Module m)\n{\n    return ((m->node.flags & MOD_LINKED) ?\n\t    (m->u.linked->finish)(m) : dyn_finish_module(m));\n}\n\n/**/\n#else /* !DYNAMIC */\n\n/**/\nstatic int\nsetup_module(Module m)\n{\n    return ((m->node.flags & MOD_LINKED) ? (m->u.linked->setup)(m) : 1);\n}\n\n/**/\nstatic int\nfeatures_module(Module m, char ***features)\n{\n    return ((m->node.flags & MOD_LINKED) ? (m->u.linked->features)(m, features)\n\t    : 1);\n}\n\n/**/\nstatic int\nenables_module(Module m, int **enables)\n{\n    return ((m->node.flags & MOD_LINKED) ? (m->u.linked->enables)(m, enables)\n\t    : 1);\n}\n\n/**/\nstatic int\nboot_module(Module m)\n{\n    return ((m->node.flags & MOD_LINKED) ? (m->u.linked->boot)(m) : 1);\n}\n\n/**/\nstatic int\ncleanup_module(Module m)\n{\n    return ((m->node.flags & MOD_LINKED) ? (m->u.linked->cleanup)(m) : 1);\n}\n\n/**/\nstatic int\nfinish_module(Module m)\n{\n    return ((m->node.flags & MOD_LINKED) ? (m->u.linked->finish)(m) : 1);\n}\n\n/**/\n#endif /* !DYNAMIC */\n\n\n/************************************************************************\n * Functions called when manipulating modules\n ************************************************************************/\n\n/*\n * Set the features for the module, which must be loaded\n * by now (though may not be fully set up).\n *\n * Return 0 for success, 1 for failure, 2 if some features\n * couldn't be set by the module itself (non-existent features\n * are tested here and cause 1 to be returned).\n */\n\n/**/\nstatic int\ndo_module_features(Module m, Feature_enables enablesarr, int flags)\n{\n    char **features;\n    int ret = 0;\n\n    if (features_module(m, &features) == 0) {\n\t/*\n\t * Features are supported.  If we were passed\n\t * a NULL array, enable all features, else\n\t * enable only the features listed.\n\t * (This may in principle be an empty array,\n\t * although that's not very pointful.)\n\t */\n\tint *enables = NULL;\n\tif (enables_module(m, &enables)) {\n\t    /* If features are supported, enables should be, too */\n\t    if (!(flags & FEAT_IGNORE))\n\t\tzwarn(\"error getting enabled features for module `%s'\",\n\t\t      m->node.nam);\n\t    return 1;\n\t}\n\n\tif ((flags & FEAT_CHECKAUTO) && m->autoloads) {\n\t    /*\n\t     * Check autoloads are available.  Since these\n\t     * have been requested at some other point, they\n\t     * don't affect the return status unless something\n\t     * in enablesstr doesn't work.\n\t     */\n\t    LinkNode an, nextn;\n\t    for (an = firstnode(m->autoloads); an; an = nextn) {\n\t\tchar *al = (char *)getdata(an), **ptr;\n\t\t/* careful, we can delete the current node */\n\t\tnextn = nextnode(an);\n\t\tfor (ptr = features; *ptr; ptr++)\n\t\t    if (!strcmp(al, *ptr))\n\t\t\tbreak;\n\t\tif (!*ptr) {\n\t\t    char *arg[2];\n\t\t    if (!(flags & FEAT_IGNORE))\n\t\t\tzwarn(\n\t\t    \"module `%s' has no such feature: `%s': autoload cancelled\",\n\t\t    m->node.nam, al);\n\t\t    /*\n\t\t     * This shouldn't happen, so it's not worth optimising\n\t\t     * the call to autofeatures...\n\t\t     */\n\t\t    arg[0] = al = dupstring(al);\n\t\t    arg[1] = NULL;\n\t\t    (void)autofeatures(NULL, m->node.nam, arg, 0,\n\t\t\t\t       FEAT_IGNORE|FEAT_REMOVE);\n\t\t    /*\n\t\t     * don't want to try to enable *that*...\n\t\t     * expunge it from the enable string.\n\t\t     */\n\t\t    if (enablesarr) {\n\t\t\tFeature_enables fep;\n\t\t\tfor (fep = enablesarr; fep->str; fep++) {\n\t\t\t    char *str = fep->str;\n\t\t\t    if (*str == '+' || *str == '-')\n\t\t\t\tstr++;\n\t\t\t    if (fep->pat ? pattry(fep->pat, al) :\n\t\t\t\t!strcmp(al, str)) {\n\t\t\t\t/* can't enable it after all, so return 1 */\n\t\t\t\tret = 1;\n\t\t\t\twhile (fep->str) {\n\t\t\t\t    fep->str = fep[1].str;\n\t\t\t\t    fep->pat = fep[1].pat;\n\t\t\t\t    fep++;\n\t\t\t\t}\n\t\t\t\tif (!fep->pat)\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (enablesarr) {\n\t    Feature_enables fep;\n\t    for (fep = enablesarr; fep->str; fep++) {\n\t\tchar **fp, *esp = fep->str;\n\t\tint on = 1, found = 0;\n\t\tif (*esp == '+')\n\t\t    esp++;\n\t\telse if (*esp == '-') {\n\t\t    on = 0;\n\t\t    esp++;\n\t\t}\n\t\tfor (fp = features; *fp; fp++)\n\t\t    if (fep->pat ? pattry(fep->pat, *fp) : !strcmp(*fp, esp)) {\n\t\t\tenables[fp - features] = on;\n\t\t\tfound++;\n\t\t\tif (!fep->pat)\n\t\t\t    break;\n\t\t    }\n\t\tif (!found) {\n\t\t    if (!(flags & FEAT_IGNORE))\n\t\t\tzwarn(fep->pat ?\n\t\t\t      \"module `%s' has no feature matching: `%s'\" :\n\t\t\t      \"module `%s' has no such feature: `%s'\",\n\t\t\t      m->node.nam, esp);\n\t\t    return 1;\n\t\t}\n\t    }\n\t} else {\n\t    /*\n\t     * Enable all features.  This is used when loading\n\t     * without using zmodload -F.\n\t     */\n\t    int n_features = arrlen(features);\n\t    int *ep;\n\t    for (ep = enables; n_features--; ep++)\n\t\t*ep = 1;\n\t}\n\n\tif (enables_module(m, &enables))\n\t    return 2;\n    } else if (enablesarr) {\n\tif (!(flags & FEAT_IGNORE))\n\t    zwarn(\"module `%s' does not support features\", m->node.nam);\n\treturn 1;\n    }\n    /* Else it doesn't support features but we don't care. */\n\n    return ret;\n}\n\n/*\n * Boot the module, including setting up features.\n * As we've only just loaded the module, we don't yet\n * know what features it supports, so we get them passed\n * as a string.\n *\n * Returns 0 if OK, 1 if completely failed, 2 if some features\n * couldn't be set up.\n */\n\n/**/\nstatic int\ndo_boot_module(Module m, Feature_enables enablesarr, int silent)\n{\n    int ret = do_module_features(m, enablesarr,\n\t\t\t\t silent ? FEAT_IGNORE|FEAT_CHECKAUTO :\n\t\t\t\t FEAT_CHECKAUTO);\n\n    if (ret == 1)\n\treturn 1;\n\n    if (boot_module(m))\n\treturn 1;\n    return ret;\n}\n\n/*\n * Cleanup the module.\n */\n\n/**/\nstatic int\ndo_cleanup_module(Module m)\n{\n    return (m->node.flags & MOD_LINKED) ?\n\t(m->u.linked && m->u.linked->cleanup(m)) :\n\t(m->u.handle && cleanup_module(m));\n}\n\n/*\n * Test a module name contains only valid characters: those\n * allowed in a shell identifier plus slash.  Return 1 if so.\n */\n\n/**/\nstatic int\nmodname_ok(char const *p)\n{\n    do {\n\tp = itype_end(p, IIDENT, 0);\n\tif (!*p)\n\t    return 1;\n    } while(*p++ == '/');\n    return 0;\n}\n\n/*\n * High level function to load a module, encapsulating\n * all the handling of module functions.\n *\n * \"*enablesstr\" is NULL if the caller is not feature-aware;\n * then the module should turn on all features.  If it\n * is not NULL it points to an array of features to be\n * turned on.  This function is responsible for testing whether\n * the module supports those features.\n *\n * If \"silent\" is 1, don't issue warnings for errors.\n *\n * Now returns 0 for success (changed post-4.3.4),\n * 1 for complete failure, 2 if some features couldn't be set.\n */\n\n/**/\nmod_export int\nload_module(char const *name, Feature_enables enablesarr, int silent)\n{\n    Module m;\n    void *handle = NULL;\n    Linkedmod linked;\n    int set, bootret;\n\n    if (!modname_ok(name)) {\n\tif (!silent)\n\t    zerr(\"invalid module name `%s'\", name);\n\treturn 1;\n    }\n    /*\n     * The following function call may alter name to the final name in a\n     * chain of aliases.  This makes sure the actual module loaded\n     * is the right one.\n     */\n    queue_signals();\n    if (!(m = find_module(name, FINDMOD_ALIASP, &name))) {\n\tif (!(linked = module_linked(name)) &&\n\t    !(handle = do_load_module(name, silent))) {\n\t    unqueue_signals();\n\t    return 1;\n\t}\n\tm = zshcalloc(sizeof(*m));\n\tif (handle) {\n\t    m->u.handle = handle;\n\t    m->node.flags |= MOD_SETUP;\n\t} else {\n\t    m->u.linked = linked;\n\t    m->node.flags |= MOD_SETUP | MOD_LINKED;\n\t}\n\tmodulestab->addnode(modulestab, ztrdup(name), m);\n\n\tif ((set = setup_module(m)) ||\n\t    (bootret = do_boot_module(m, enablesarr, silent)) == 1) {\n\t    if (!set)\n\t\tdo_cleanup_module(m);\n\t    finish_module(m);\n\t    delete_module(m);\n\t    unqueue_signals();\n\t    return 1;\n\t}\n\tm->node.flags |= MOD_INIT_S | MOD_INIT_B;\n\tm->node.flags &= ~MOD_SETUP;\n\tunqueue_signals();\n\treturn bootret;\n    }\n    if (m->node.flags & MOD_SETUP) {\n\tunqueue_signals();\n\treturn 0;\n    }\n    if (m->node.flags & MOD_UNLOAD)\n\tm->node.flags &= ~MOD_UNLOAD;\n    else if ((m->node.flags & MOD_LINKED) ? m->u.linked : m->u.handle) {\n\tunqueue_signals();\n\treturn 0;\n    }\n    if (m->node.flags & MOD_BUSY) {\n\tunqueue_signals();\n\tzerr(\"circular dependencies for module ;%s\", name);\n\treturn 1;\n    }\n    m->node.flags |= MOD_BUSY;\n    /*\n     * TODO: shouldn't we unload the module if one of\n     * its dependencies fails?\n     */\n    if (m->deps) {\n\tLinkNode n;\n\tfor (n = firstnode(m->deps); n; incnode(n))\n\t    if (load_module((char *) getdata(n), NULL, silent) == 1) {\n\t\tm->node.flags &= ~MOD_BUSY;\n\t\tunqueue_signals();\n\t\treturn 1;\n\t    }\n    }\n    m->node.flags &= ~MOD_BUSY;\n    if (!m->u.handle) {\n\thandle = NULL;\n\tif (!(linked = module_linked(name)) &&\n\t    !(handle = do_load_module(name, silent))) {\n\t    unqueue_signals();\n\t    return 1;\n\t}\n\tif (handle) {\n\t    m->u.handle = handle;\n\t    m->node.flags |= MOD_SETUP;\n\t} else {\n\t    m->u.linked = linked;\n\t    m->node.flags |= MOD_SETUP | MOD_LINKED;\n\t}\n\tif (setup_module(m)) {\n\t    finish_module(m);\n\t    if (handle)\n\t\tm->u.handle = NULL;\n\t    else\n\t\tm->u.linked = NULL;\n\t    m->node.flags &= ~MOD_SETUP;\n\t    unqueue_signals();\n\t    return 1;\n\t}\n\tm->node.flags |= MOD_INIT_S;\n    }\n    m->node.flags |= MOD_SETUP;\n    if ((bootret = do_boot_module(m, enablesarr, silent)) == 1) {\n\tdo_cleanup_module(m);\n\tfinish_module(m);\n\tif (m->node.flags & MOD_LINKED)\n\t    m->u.linked = NULL;\n\telse\n\t    m->u.handle = NULL;\n\tm->node.flags &= ~MOD_SETUP;\n\tunqueue_signals();\n\treturn 1;\n    }\n    m->node.flags |= MOD_INIT_B;\n    m->node.flags &= ~MOD_SETUP;\n    unqueue_signals();\n    return bootret;\n}\n\n/* This ensures that the module with the name given as the first argument\n * is loaded.\n * The other argument is the array of features to set.  If this is NULL\n * all features are enabled (even if the module was already loaded).\n *\n * If this is non-NULL the module features are set accordingly\n * whether or not the module is loaded; it is an error if the\n * module does not support the features passed (even if the feature\n * is to be turned off) or if the module does not support features\n * at all.\n * The return value is 0 if the module was found or loaded\n * (this changed post-4.3.4, because I got so confused---pws),\n * 1 if loading failed completely, 2 if some features couldn't be set.\n *\n * This function behaves like load_module() except that it\n * handles the case where the module was already loaded, and\n * sets features accordingly.\n */\n\n/**/\nmod_export int\nrequire_module(const char *module, Feature_enables features, int silent)\n{\n    Module m = NULL;\n    int ret = 0;\n\n    /* Resolve aliases and actual loadable module as for load_module */\n    queue_signals();\n    m = find_module(module, FINDMOD_ALIASP, &module);\n    if (!m || !m->u.handle ||\n\t(m->node.flags & MOD_UNLOAD))\n\tret = load_module(module, features, silent);\n    else\n\tret = do_module_features(m, features, 0);\n    unqueue_signals();\n\n    return ret;\n}\n\n/*\n * Indicate that the module named \"name\" depends on the module\n * named \"from\".\n */\n\n/**/\nvoid\nadd_dep(const char *name, char *from)\n{\n    LinkNode node;\n    Module m;\n\n    /*\n     * If we were passed an alias, we must resolve it to a final\n     * module name (and maybe add the corresponding struct), since otherwise\n     * we would need to check all modules to see if they happen\n     * to be aliased to the same thing to implement dependencies properly.\n     *\n     * This should mean that an attempt to add an alias which would\n     * have the same name as a module which has dependencies is correctly\n     * rejected, because then the module named already exists as a non-alias.\n     * Better make sure.  (There's no problem making a an alias which\n     * *points* to a module with dependencies, of course.)\n     */\n    m = find_module(name, FINDMOD_ALIASP|FINDMOD_CREATE, &name);\n    if (!m->deps)\n\tm->deps = znewlinklist();\n    for (node = firstnode(m->deps);\n\t node && strcmp((char *) getdata(node), from);\n\t incnode(node));\n    if (!node)\n\tzaddlinknode(m->deps, ztrdup(from));\n}\n\n/*\n * Function to be used when scanning the builtins table to\n * find and print autoloadable builtins.\n */\n\n/**/\nstatic void\nautoloadscan(HashNode hn, int printflags)\n{\n    Builtin bn = (Builtin) hn;\n\n    if(bn->node.flags & BINF_ADDED)\n\treturn;\n    if(printflags & PRINT_LIST) {\n\tfputs(\"zmodload -ab \", stdout);\n\tif(bn->optstr[0] == '-')\n\t    fputs(\"-- \", stdout);\n\tquotedzputs(bn->optstr, stdout);\n\tif(strcmp(bn->node.nam, bn->optstr)) {\n\t    putchar(' ');\n\t    quotedzputs(bn->node.nam, stdout);\n\t}\n    } else {\n\tnicezputs(bn->node.nam, stdout);\n\tif(strcmp(bn->node.nam, bn->optstr)) {\n\t    fputs(\" (\", stdout);\n\t    nicezputs(bn->optstr, stdout);\n\t    putchar(')');\n\t}\n    }\n    putchar('\\n');\n}\n\n\n/************************************************************************\n * Handling for the zmodload builtin and its various options.\n ************************************************************************/\n\n/*\n * Main builtin entry point for zmodload.\n */\n\n/**/\nint\nbin_zmodload(char *nam, char **args, Options ops, UNUSED(int func))\n{\n    int ops_bcpf = OPT_ISSET(ops,'b') || OPT_ISSET(ops,'c') || \n\tOPT_ISSET(ops,'p') || OPT_ISSET(ops,'f');\n    int ops_au = OPT_ISSET(ops,'a') || OPT_ISSET(ops,'u');\n    int ret = 1, autoopts;\n    /* options only allowed with -F */\n    char *fonly = \"lP\", *fp;\n\n    if (ops_bcpf && !ops_au) {\n\tzwarnnam(nam, \"-b, -c, -f, and -p must be combined with -a or -u\");\n\treturn 1;\n    }\n    if (OPT_ISSET(ops,'F') && (ops_bcpf || OPT_ISSET(ops,'u'))) {\n\tzwarnnam(nam, \"-b, -c, -f, -p and -u cannot be combined with -F\");\n\treturn 1;\n    }\n    if (OPT_ISSET(ops,'A') || OPT_ISSET(ops,'R')) {\n\tif (ops_bcpf || ops_au || OPT_ISSET(ops,'d') || \n\t    (OPT_ISSET(ops,'R') && OPT_ISSET(ops,'e'))) {\n\t    zwarnnam(nam, \"illegal flags combined with -A or -R\");\n\t    return 1;\n\t}\n\tif (!OPT_ISSET(ops,'e'))\n\t    return bin_zmodload_alias(nam, args, ops);\n    }\n    if (OPT_ISSET(ops,'d') && OPT_ISSET(ops,'a')) {\n\tzwarnnam(nam, \"-d cannot be combined with -a\");\n\treturn 1;\n    }\n    if (OPT_ISSET(ops,'u') && !*args) {\n\tzwarnnam(nam, \"what do you want to unload?\");\n\treturn 1;\n    }\n    if (OPT_ISSET(ops,'e') && (OPT_ISSET(ops,'I') || OPT_ISSET(ops,'L') || \n\t\t\t       (OPT_ISSET(ops,'a') && !OPT_ISSET(ops,'F'))\n\t\t\t       || OPT_ISSET(ops,'d') ||\n\t\t\t       OPT_ISSET(ops,'i') || OPT_ISSET(ops,'u'))) {\n\tzwarnnam(nam, \"-e cannot be combined with other options\");\n\t/* except -F ... */\n\treturn 1;\n    }\n    for (fp = fonly; *fp; fp++) {\n\tif (OPT_ISSET(ops,STOUC(*fp)) && !OPT_ISSET(ops,'F')) {\n\t    zwarnnam(nam, \"-%c is only allowed with -F\", *fp);\n\t    return 1;\n\t}\n    }\n    queue_signals();\n    if (OPT_ISSET(ops, 'F'))\n\tret = bin_zmodload_features(nam, args, ops);\n    else if (OPT_ISSET(ops,'e'))\n\tret = bin_zmodload_exist(nam, args, ops);\n    else if (OPT_ISSET(ops,'d'))\n\tret = bin_zmodload_dep(nam, args, ops);\n    else if ((autoopts = OPT_ISSET(ops, 'b') + OPT_ISSET(ops, 'c') +\n\t      OPT_ISSET(ops, 'p') + OPT_ISSET(ops, 'f')) ||\n\t     /* zmodload -a is equivalent to zmodload -ab, annoyingly */\n\t     OPT_ISSET(ops, 'a')) {\n\tif (autoopts > 1) {\n\t    zwarnnam(nam, \"use only one of -b, -c, or -p\");\n\t    ret = 1;\n\t} else\n\t    ret = bin_zmodload_auto(nam, args, ops);\n    } else\n\tret = bin_zmodload_load(nam, args, ops);\n    unqueue_signals();\n\n    return ret;\n}\n\n/* zmodload -A */\n\n/**/\nstatic int\nbin_zmodload_alias(char *nam, char **args, Options ops)\n{\n    /*\n     * TODO: while it would be too nasty to have aliases, as opposed\n     * to real loadable modules, with dependencies --- just what would\n     * we need to load when, exactly? --- there is in principle no objection\n     * to making it possible to force an alias onto an existing unloaded\n     * module which has dependencies.  This would simply transfer\n     * the dependencies down the line to the aliased-to module name.\n     * This is actually useful, since then you can alias zsh/zle=mytestzle\n     * to load another version of zle.  But then what happens when the\n     * alias is removed?  Do you transfer the dependencies back? And\n     * suppose other names are aliased to the same file?  It might be\n     * kettle of fish best left unwormed.\n     */\n    Module m;\n\n    if (!*args) {\n\tif (OPT_ISSET(ops,'R')) {\n\t    zwarnnam(nam, \"no module alias to remove\");\n\t    return 1;\n\t}\n\tscanhashtable(modulestab, 1, MOD_ALIAS, 0,\n\t\t      modulestab->printnode,\n\t\t      OPT_ISSET(ops,'L') ? PRINTMOD_LIST : 0);\n\treturn 0;\n    }\n\n    for (; *args; args++) {\n\tchar *eqpos = strchr(*args, '=');\n\tchar *aliasname = eqpos ? eqpos+1 : NULL;\n\tif (eqpos)\n\t    *eqpos = '\\0';\n\tif (!modname_ok(*args)) {\n\t    zwarnnam(nam, \"invalid module name `%s'\", *args);\n\t    return 1;\n\t}\n\tif (OPT_ISSET(ops,'R')) {\n\t    if (aliasname) {\n\t\tzwarnnam(nam, \"bad syntax for removing module alias: %s\",\n\t\t\t *args);\n\t\treturn 1;\n\t    }\n\t    m = find_module(*args, 0, NULL);\n\t    if (m) {\n\t\tif (!(m->node.flags & MOD_ALIAS)) {\n\t\t    zwarnnam(nam, \"module is not an alias: %s\", *args);\n\t\t    return 1;\n\t\t}\n\t\tdelete_module(m);\n\t    } else {\n\t\tzwarnnam(nam, \"no such module alias: %s\", *args);\n\t\treturn 1;\n\t    }\n\t} else {\n\t    if (aliasname) {\n\t\tconst char *mname = aliasname;\n\t\tif (!modname_ok(aliasname)) {\n\t\t    zwarnnam(nam, \"invalid module name `%s'\", aliasname);\n\t\t    return 1;\n\t\t}\n\t\tdo {\n\t\t    if (!strcmp(mname, *args)) {\n\t\t\tzwarnnam(nam, \"module alias would refer to itself: %s\",\n\t\t\t\t *args);\n\t\t\treturn 1;\n\t\t    }\n\t\t} while ((m = find_module(mname, 0, NULL))\n\t\t\t && (m->node.flags & MOD_ALIAS)\n\t\t\t && (mname = m->u.alias));\n\t\tm = find_module(*args, 0, NULL);\n\t\tif (m) {\n\t\t    if (!(m->node.flags & MOD_ALIAS)) {\n\t\t\tzwarnnam(nam, \"module is not an alias: %s\", *args);\n\t\t\treturn 1;\n\t\t    }\n\t\t    zsfree(m->u.alias);\n\t\t} else {\n\t\t    m = (Module) zshcalloc(sizeof(*m));\n\t\t    m->node.flags = MOD_ALIAS;\n\t\t    modulestab->addnode(modulestab, ztrdup(*args), m);\n\t\t}\n\t\tm->u.alias = ztrdup(aliasname);\n\t    } else {\n\t\tif ((m = find_module(*args, 0, NULL))) {\n\t\t    if (m->node.flags & MOD_ALIAS)\n\t\t\tmodulestab->printnode(&m->node,\n\t\t\t\t\t      OPT_ISSET(ops,'L') ?\n\t\t\t\t\t      PRINTMOD_LIST : 0);\n\t\t    else {\n\t\t\tzwarnnam(nam, \"module is not an alias: %s\", *args);\n\t\t\treturn 1;\n\t\t    }\n\t\t} else {\n\t\t    zwarnnam(nam, \"no such module alias: %s\", *args);\n\t\t    return 1;\n\t\t}\n\t    }\n\t}\n    }\n\n    return 0;\n}\n\n/* zmodload -e (without -F) */\n\n/**/\nstatic int\nbin_zmodload_exist(UNUSED(char *nam), char **args, Options ops)\n{\n    Module m;\n\n    if (!*args) {\n\tscanhashtable(modulestab, 1, 0, 0, modulestab->printnode,\n\t\t      OPT_ISSET(ops,'A') ? PRINTMOD_EXIST|PRINTMOD_ALIAS :\n\t\t      PRINTMOD_EXIST);\n\treturn 0;\n    } else {\n\tint ret = 0;\n\n\tfor (; !ret && *args; args++) {\n\t    if (!(m = find_module(*args, FINDMOD_ALIASP, NULL))\n\t\t|| !m->u.handle\n\t\t|| (m->node.flags & MOD_UNLOAD))\n\t\tret = 1;\n\t}\n\treturn ret;\n    }\n}\n\n/* zmodload -d */\n\n/**/\nstatic int\nbin_zmodload_dep(UNUSED(char *nam), char **args, Options ops)\n{\n    Module m;\n    if (OPT_ISSET(ops,'u')) {\n\t/* remove dependencies, which can't pertain to aliases */\n\tconst char *tnam = *args++;\n\tm = find_module(tnam, FINDMOD_ALIASP, &tnam);\n\tif (!m)\n\t    return 0;\n\tif (*args && m->deps) {\n\t    do {\n\t\tLinkNode dnode;\n\t\tfor (dnode = firstnode(m->deps); dnode; incnode(dnode))\n\t\t    if (!strcmp(*args, getdata(dnode))) {\n\t\t\tzsfree(getdata(dnode));\n\t\t\tremnode(m->deps, dnode);\n\t\t\tbreak;\n\t\t    }\n\t    } while(*++args);\n\t    if (empty(m->deps)) {\n\t\tfreelinklist(m->deps, freestr);\n\t\tm->deps = NULL;\n\t    }\n\t} else {\n\t    if (m->deps) {\n\t\tfreelinklist(m->deps, freestr);\n\t\tm->deps = NULL;\n\t    }\n\t}\n\tif (!m->deps && !m->u.handle)\n\t    delete_module(m);\n\treturn 0;\n    } else if (!args[0] || !args[1]) {\n\t/* list dependencies */\n\tint depflags = OPT_ISSET(ops,'L') ?\n\t    PRINTMOD_DEPS|PRINTMOD_LIST : PRINTMOD_DEPS;\n\tif (args[0]) {\n\t    if ((m = (Module)modulestab->getnode2(modulestab, args[0])))\n\t\tmodulestab->printnode(&m->node, depflags);\n\t} else {\n\t    scanhashtable(modulestab, 1, 0, 0, modulestab->printnode,\n\t\t\t  depflags);\n\t}\n\treturn 0;\n    } else {\n\t/* add dependencies */\n\tint ret = 0;\n\tchar *tnam = *args++;\n\n\tfor (; *args; args++)\n\t    add_dep(tnam, *args);\n\treturn ret;\n    }\n}\n\n/*\n * Function for scanning the parameter table to find and print\n * out autoloadable parameters.\n */\n\nstatic void\nprintautoparams(HashNode hn, int lon)\n{\n    Param pm = (Param) hn;\n\n    if (pm->node.flags & PM_AUTOLOAD) {\n\tif (lon)\n\t    printf(\"zmodload -ap %s %s\\n\", pm->u.str, pm->node.nam);\n\telse\n\t    printf(\"%s (%s)\\n\", pm->node.nam, pm->u.str);\n    }\n}\n\n/* zmodload -a/u [bcpf] */\n\n/**/\nstatic int\nbin_zmodload_auto(char *nam, char **args, Options ops)\n{\n    int fchar, flags;\n    char *modnam;\n\n    if (OPT_ISSET(ops,'c')) {\n\tif (!*args) {\n\t    /* list autoloaded conditions */\n\t    Conddef p;\n\n\t    for (p = condtab; p; p = p->next) {\n\t\tif (p->module) {\n\t\t    if (OPT_ISSET(ops,'L')) {\n\t\t\tfputs(\"zmodload -ac\", stdout);\n\t\t\tif (p->flags & CONDF_INFIX)\n\t\t\t    putchar('I');\n\t\t\tprintf(\" %s %s\\n\", p->module, p->name);\n\t\t    } else {\n\t\t\tif (p->flags & CONDF_INFIX)\n\t\t\t    fputs(\"infix \", stdout);\n\t\t\telse\n\t\t\t    fputs(\"post \", stdout);\n\t\t\tprintf(\"%s (%s)\\n\",p->name, p->module);\n\t\t    }\n\t\t}\n\t    }\n\t    return 0;\n\t}\n\tfchar = OPT_ISSET(ops,'I') ? 'C' : 'c';\n    } else if (OPT_ISSET(ops,'p')) {\n\tif (!*args) {\n\t    /* list autoloaded parameters */\n\t    scanhashtable(paramtab, 1, 0, 0, printautoparams,\n\t\t\t  OPT_ISSET(ops,'L'));\n\t    return 0;\n\t}\n\tfchar = 'p';\n    } else if (OPT_ISSET(ops,'f')) {\n\tif (!*args) {\n\t    /* list autoloaded math functions */\n\t    MathFunc p;\n\n\t    for (p = mathfuncs; p; p = p->next) {\n\t\tif (!(p->flags & MFF_USERFUNC) && p->module) {\n\t\t    if (OPT_ISSET(ops,'L')) {\n\t\t\tfputs(\"zmodload -af\", stdout);\n\t\t\tprintf(\" %s %s\\n\", p->module, p->name);\n\t\t    } else\n\t\t\tprintf(\"%s (%s)\\n\",p->name, p->module);\n\t\t}\n\t    }\n\t    return 0;\n\t}\n\tfchar = 'f';\n    } else {\n\t/* builtins are the default; zmodload -ab or just zmodload -a */\n\tif (!*args) {\n\t    /* list autoloaded builtins */\n\t    scanhashtable(builtintab, 1, 0, 0,\n\t\t\t  autoloadscan, OPT_ISSET(ops,'L') ? PRINT_LIST : 0);\n\t    return 0;\n\t}\n\tfchar = 'b';\n    }\n\n    flags = FEAT_AUTOALL;\n    if (OPT_ISSET(ops,'i'))\n\tflags |= FEAT_IGNORE;\n    if (OPT_ISSET(ops,'u')) {\n\t/* remove autoload */\n\tflags |= FEAT_REMOVE;\n\tmodnam = NULL;\n    } else {\n\t/* add autoload */\n\tmodnam = *args;\n\n\tif (args[1])\n\t    args++;\n    }\n    return autofeatures(nam, modnam, args, fchar, flags);\n}\n\n/* Backend handler for zmodload -u */\n\n/**/\nint\nunload_module(Module m)\n{\n    int del;\n\n    /*\n     * Only unload the real module, so resolve aliases.\n     */\n    if (m->node.flags & MOD_ALIAS) {\n\tm = find_module(m->u.alias, FINDMOD_ALIASP, NULL);\n\tif (!m)\n\t    return 1;\n    }\n    /*\n     * We may need to clean up the module any time setup_ has been\n     * called.  After cleanup_ is successful we are no longer in the\n     * booted state (because features etc. are deregistered), so remove\n     * MOD_INIT_B, and also MOD_INIT_S since we won't need to cleanup\n     * again if this succeeded.\n     */\n    if ((m->node.flags & MOD_INIT_S) &&\n\t!(m->node.flags & MOD_UNLOAD) &&\n\tdo_cleanup_module(m))\n\treturn 1;\n    m->node.flags &= ~(MOD_INIT_B|MOD_INIT_S);\n\n    del = (m->node.flags & MOD_UNLOAD);\n\n    if (m->wrapper) {\n\tm->node.flags |= MOD_UNLOAD;\n\treturn 0;\n    }\n    m->node.flags &= ~MOD_UNLOAD;\n\n    /*\n     * We always need to finish the module (and unload it)\n     * if it is present.\n     */\n    if (m->node.flags & MOD_LINKED) {\n\tif (m->u.linked) {\n\t    m->u.linked->finish(m);\n\t    m->u.linked = NULL;\n\t}\n    } else {\n\tif (m->u.handle) {\n\t    finish_module(m);\n\t    m->u.handle = NULL;\n\t}\n    }\n\n    if (del && m->deps) {\n\t/* The module was unloaded delayed, unload all modules *\n\t * on which it depended. */\n\tLinkNode n;\n\n\tfor (n = firstnode(m->deps); n; incnode(n)) {\n\t    Module dm = find_module((char *) getdata(n),\n\t\t\t\t    FINDMOD_ALIASP, NULL);\n\n\t    if (dm &&\n\t\t(dm->node.flags & MOD_UNLOAD)) {\n\t\t/* See if this is the only module depending on it. */\n\t\tModule am;\n\t\tint du = 1, i;\n\t\t/* Scan hash table the hard way */\n\t\tfor (i = 0; du && i < modulestab->hsize; i++) {\n\t\t    for (am = (Module)modulestab->nodes[i]; du && am;\n\t\t\t am = (Module)am->node.next) {\n\t\t\tLinkNode sn;\n\t\t\t/*\n\t\t\t * Don't scan the module we're unloading;\n\t\t\t * ignore if no dependencies.\n\t\t\t */\n\t\t\tif (am == m || !am->deps)\n\t\t\t    continue;\n\t\t\t/* Don't scan if not loaded nor linked */\n\t\t\tif ((am->node.flags & MOD_LINKED) ?\n\t\t\t    !am->u.linked : !am->u.handle)\n\t\t\t    continue;\n\t\t\tfor (sn = firstnode(am->deps); du && sn;\n\t\t\t     incnode(sn)) {\n\t\t\t    if (!strcmp((char *) getdata(sn),\n\t\t\t\t\tdm->node.nam))\n\t\t\t\tdu = 0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (du)\n\t\t    unload_module(dm);\n\t    }\n\t}\n    }\n    if (m->autoloads && firstnode(m->autoloads)) {\n\t/*\n\t * Module has autoloadable features.  Restore them\n\t * so that the module will be reloaded when needed.\n\t */\n\tautofeatures(\"zsh\", m->node.nam,\n\t\t     hlinklist2array(m->autoloads, 0), 0, FEAT_IGNORE);\n    } else if (!m->deps) {\n\tdelete_module(m);\n    }\n    return 0;\n}\n\n/*\n * Unload a module by name (modname); nam is the command name.\n * Optionally don't print some error messages (always print\n * dependency errors).\n */\n\n/**/\nint\nunload_named_module(char *modname, char *nam, int silent)\n{\n    const char *mname;\n    Module m;\n    int ret = 0;\n\n    m = find_module(modname, FINDMOD_ALIASP, &mname);\n    if (m) {\n\tint i, del = 0;\n\tModule dm;\n\n\tfor (i = 0; i < modulestab->hsize; i++) {\n\t    for (dm = (Module)modulestab->nodes[i]; dm;\n\t\t dm = (Module)dm->node.next) {\n\t\tLinkNode dn;\n\t\tif (!dm->deps || !dm->u.handle)\n\t\t    continue;\n\t\tfor (dn = firstnode(dm->deps); dn; incnode(dn)) {\n\t\t    if (!strcmp((char *) getdata(dn), mname)) {\n\t\t\tif (dm->node.flags & MOD_UNLOAD)\n\t\t\t    del = 1;\n\t\t\telse {\n\t\t\t    zwarnnam(nam, \"module %s is in use by another module and cannot be unloaded\", mname);\n\t\t\t    return 1;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (del)\n\t    m->wrapper++;\n\tif (unload_module(m))\n\t    ret = 1;\n\tif (del)\n\t    m->wrapper--;\n    } else if (!silent) {\n\tzwarnnam(nam, \"no such module %s\", modname);\n\tret = 1;\n    }\n\n    return ret;\n}\n\n/* zmodload -u without -d */\n\n/**/\nstatic int\nbin_zmodload_load(char *nam, char **args, Options ops)\n{\n    int ret = 0;\n    if(OPT_ISSET(ops,'u')) {\n\t/* unload modules */\n\tfor(; *args; args++) {\n\t    if (unload_named_module(*args, nam, OPT_ISSET(ops,'i')))\n\t\tret = 1;\n\t}\n\treturn ret;\n    } else if(!*args) {\n\t/* list modules */\n\tscanhashtable(modulestab, 1, 0, MOD_UNLOAD|MOD_ALIAS,\n\t\t      modulestab->printnode,\n\t\t      OPT_ISSET(ops,'L') ? PRINTMOD_LIST : 0);\n\treturn 0;\n    } else {\n\t/* load modules */\n\tfor (; *args; args++) {\n\t    int tmpret = require_module(*args, NULL, OPT_ISSET(ops,'s'));\n\t    if (tmpret && ret != 1)\n\t\tret = tmpret;\n\t}\n\n\treturn ret;\n    }\n}\n\n/* zmodload -F */\n\n/**/\nstatic int\nbin_zmodload_features(const char *nam, char **args, Options ops)\n{\n    int iarg;\n    char *modname = *args;\n    Patprog *patprogs;\n    Feature_enables features, fep;\n\n    if (modname)\n\targs++;\n    else if (OPT_ISSET(ops,'L')) {\n\tint printflags = PRINTMOD_LIST|PRINTMOD_FEATURES;\n\tif (OPT_ISSET(ops,'P')) {\n\t    zwarnnam(nam, \"-P is only allowed with a module name\");\n\t    return 1;\n\t}\n\tif (OPT_ISSET(ops,'l'))\n\t    printflags |= PRINTMOD_LISTALL;\n\tif (OPT_ISSET(ops,'a'))\n\t    printflags |= PRINTMOD_AUTO;\n\tscanhashtable(modulestab, 1, 0, MOD_ALIAS,\n\t\t      modulestab->printnode, printflags);\n\treturn 0;\n    }\n\n    if (!modname) {\n\tzwarnnam(nam, \"-F requires a module name\");\n\treturn 1;\n    }\n\n    if (OPT_ISSET(ops,'m')) {\n\tchar **argp;\n\tPatprog *patprogp;\n\n\t/* not NULL terminated */\n\tpatprogp = patprogs =\n\t    (Patprog *)zhalloc(arrlen(args)*sizeof(Patprog));\n\tfor (argp = args; *argp; argp++, patprogp++) {\n\t    char *arg = *argp;\n\t    if (*arg == '+' || *arg == '-')\n\t\targ++;\n\t    tokenize(arg);\n\t    *patprogp = patcompile(arg, 0, 0);\n\t}\n    } else\n\tpatprogs = NULL;\n\n    if (OPT_ISSET(ops,'l') || OPT_ISSET(ops,'L') || OPT_ISSET(ops,'e')) {\n\t/*\n\t * With option 'l', list all features one per line with + or -.\n\t * With option 'L', list as zmodload statement showing\n\t * only options turned on.\n\t * With both options, list as zmodload showing options\n\t * to be turned both on and off.\n\t */\n\tModule m;\n\tchar **features, **fp, **arrset = NULL, **arrp = NULL;\n\tint *enables = NULL, *ep;\n\tchar *param = OPT_ARG_SAFE(ops,'P');\n\n\tm = find_module(modname, FINDMOD_ALIASP, NULL);\n\tif (OPT_ISSET(ops,'a')) {\n\t    LinkNode ln;\n\t    /*\n\t     * If there are no autoloads defined, return status 1.\n\t     */\n\t    if (!m || !m->autoloads)\n\t\treturn 1;\n\t    if (OPT_ISSET(ops,'e')) {\n\t\tfor (fp = args; *fp; fp++) {\n\t\t    char *fstr = *fp;\n\t\t    int sense = 1;\n\t\t    if (*fstr == '+')\n\t\t\tfstr++;\n\t\t    else if (*fstr == '-') {\n\t\t\tfstr++;\n\t\t\tsense = 0;\n\t\t    }\n\t\t    if ((linknodebystring(m->autoloads, fstr) != NULL) !=\n\t\t\tsense)\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t    }\n\t    if (param) {\n\t\tarrp = arrset = (char **)zalloc(sizeof(char*) *\n\t\t\t\t (countlinknodes(m->autoloads)+1));\n\t    } else if (OPT_ISSET(ops,'L')) {\n\t\tprintf(\"zmodload -aF %s%c\", m->node.nam,\n\t\t       m->autoloads && firstnode(m->autoloads) ? ' ' : '\\n');\n\t\tarrp = NULL;\n\t    }\n\t    for (ln = firstnode(m->autoloads); ln; incnode(ln)) {\n\t\tchar *al = (char *)getdata(ln);\n\t\tif (param)\n\t\t    *arrp++ = ztrdup(al);\n\t\telse\n\t\t    printf(\"%s%c\", al,\n\t\t\t   OPT_ISSET(ops,'L') && nextnode(ln) ? ' ' : '\\n');\n\t    }\n\t    if (param) {\n\t\t*arrp = NULL;\n\t\tif (!setaparam(param, arrset))\n\t\t    return 1;\n\t    }\n\t    return 0;\n\t}\n\tif (!m || !m->u.handle || (m->node.flags & MOD_UNLOAD)) {\n\t    if (!OPT_ISSET(ops,'e'))\n\t\tzwarnnam(nam, \"module `%s' is not yet loaded\", modname);\n\t    return 1;\n\t}\n\tif (features_module(m, &features)) {\n\t    if (!OPT_ISSET(ops,'e'))\n\t\tzwarnnam(nam, \"module `%s' does not support features\",\n\t\t\t m->node.nam);\n\t    return 1;\n\t}\n\tif (enables_module(m, &enables)) {\n\t    /* this shouldn't ever happen, so don't silence this error */\n\t    zwarnnam(nam, \"error getting enabled features for module `%s'\",\n\t\t     m->node.nam);\n\t    return 1;\n\t}\n\tfor (arrp = args, iarg = 0; *arrp; arrp++, iarg++) {\n\t    char *arg = *arrp;\n\t    int on, found = 0;\n\t    if (*arg == '-') {\n\t\ton = 0;\n\t\targ++;\n\t    } else if (*arg == '+') {\n\t\ton = 1;\n\t\targ++;\n\t    } else\n\t\ton = -1;\n\t    for (fp = features, ep = enables; *fp; fp++, ep++) {\n\t\tif (patprogs ? pattry(patprogs[iarg], *fp) :\n\t\t    !strcmp(arg, *fp)) {\n\t\t    /* for -e, check given state, if any */\n\t\t    if (OPT_ISSET(ops,'e') && on != -1 &&\n\t\t\ton != (*ep & 1))\n\t\t\treturn 1;\n\t\t    found++;\n\t\t    if (!patprogs)\n\t\t\tbreak;\n\t\t}\n\t    }\n\t    if (!found) {\n\t\tif (!OPT_ISSET(ops,'e'))\n\t\t    zwarnnam(nam, patprogs ?\n\t\t\t     \"module `%s' has no feature matching: `%s'\" :\n\t\t\t     \"module `%s' has no such feature: `%s'\",\n\t\t\t     modname, *arrp);\n\t\treturn 1;\n\t    }\n\t}\n\tif (OPT_ISSET(ops,'e'))\t\t/* yep, everything we want exists */\n\t    return 0;\n\tif (param) {\n\t    int arrlen = 0;\n\t    for (fp = features, ep = enables; *fp; fp++, ep++) {\n\t\tif (OPT_ISSET(ops, 'L') && !OPT_ISSET(ops, 'l') &&\n\t\t    !*ep)\n\t\t    continue;\n\t\tif (*args) {\n\t\t    char **argp;\n\t\t    for (argp = args, iarg = 0; *argp; argp++, iarg++) {\n\t\t\tchar *arg = *argp;\n\t\t\t/* ignore +/- for consistency */\n\t\t\tif (*arg == '+' || *arg == '-')\n\t\t\t    arg++;\n\t\t\tif (patprogs ? pattry(patprogs[iarg], *fp) :\n\t\t\t    !strcmp(*fp, arg))\n\t\t\t    break;\n\t\t    }\n\t\t    if (!*argp)\n\t\t\tcontinue;\n\t\t}\n\t\tarrlen++;\n\t    }\n\t    arrp = arrset = zalloc(sizeof(char *) * (arrlen+1));\n\t} else if (OPT_ISSET(ops, 'L'))\n\t    printf(\"zmodload -F %s \", m->node.nam);\n\tfor (fp = features, ep = enables; *fp; fp++, ep++) {\n\t    char *onoff;\n\t    int term;\n\t    if (*args) {\n\t\tchar **argp;\n\t\tfor (argp = args, iarg = 0; *argp; argp++, iarg++) {\n\t\t    char *arg = *argp;\n\t\t    if (*arg == '+' || *arg == '-')\n\t\t\targ++;\n\t\t    if (patprogs ? pattry(patprogs[iarg], *fp) :\n\t\t\t!strcmp(*fp, *argp))\n\t\t\tbreak;\n\t\t}\n\t\tif (!*argp)\n\t\t    continue;\n\t    }\n\t    if (OPT_ISSET(ops, 'L') && !OPT_ISSET(ops, 'l')) {\n\t\tif (!*ep)\n\t\t    continue;\n\t\tonoff = \"\";\n\t    } else if (*ep) {\n\t\tonoff = \"+\";\n\t    } else {\n\t\tonoff = \"-\";\n\t    }\n\t    if (param) {\n\t\t*arrp++ = bicat(onoff, *fp);\n\t    } else {\n\t\tif (OPT_ISSET(ops, 'L') && fp[1]) {\n\t\t    term = ' ';\n\t\t} else {\n\t\t    term = '\\n';\n\t\t}\n\t\tprintf(\"%s%s%c\", onoff, *fp, term);\n\t    }\n\t}\n\tif (param) {\n\t    *arrp = NULL;\n\t    if (!setaparam(param, arrset))\n\t\treturn 1;\n\t}\n\treturn 0;\n    } else if (OPT_ISSET(ops,'P')) {\n\tzwarnnam(nam, \"-P can only be used with -l or -L\");\n\treturn 1;\n    } else if (OPT_ISSET(ops,'a')) {\n\tif (OPT_ISSET(ops,'m')) {\n\t    zwarnnam(nam, \"-m cannot be used with -a\");\n\t    return 1;\n\t}\n\t/*\n\t * With zmodload -aF, we always use the effect of -i.\n\t * The thinking is that marking a feature for\n\t * autoload is separate from enabling or disabling it.\n\t * Arguably we could do this with the zmodload -ab method\n\t * but I've kept it there for old time's sake.\n\t * The decoupling has meant FEAT_IGNORE/-i also\n\t * suppresses an error for attempting to remove an\n\t * autoload when the feature is enabled, which used\n\t * to be a hard error before.\n\t */\n\treturn autofeatures(nam, modname, args, 0, FEAT_IGNORE);\n    }\n\n    fep = features =\n\t(Feature_enables)zhalloc((arrlen(args)+1)*sizeof(*fep));\n\n    while (*args) {\n\tfep->str = *args++;\n\tfep->pat = patprogs ? *patprogs++ : NULL;\n\tfep++;\n    }\n    fep->str = NULL;\n    fep->pat = NULL;\n\n    return require_module(modname, features, OPT_ISSET(ops,'s'));\n}\n\n\n/************************************************************************\n * Generic feature support.\n * These functions are designed to be called by modules.\n ************************************************************************/\n\n/*\n * Construct a features array out of the list of concrete\n * features given, leaving space for any abstract features\n * to be added by the module itself.\n *\n * Note the memory is from the heap.\n */\n\n/**/\nmod_export char **\nfeaturesarray(UNUSED(Module m), Features f)\n{\n    int bn_size = f->bn_size, cd_size = f->cd_size;\n    int mf_size = f->mf_size, pd_size = f->pd_size;\n    int features_size = bn_size + cd_size + pd_size + mf_size + f->n_abstract;\n    Builtin bnp = f->bn_list;\n    Conddef cdp = f->cd_list;\n    MathFunc mfp = f->mf_list;\n    Paramdef pdp = f->pd_list;\n    char **features = (char **)zhalloc((features_size + 1) * sizeof(char *));\n    char **featurep = features;\n\n    while (bn_size--)\n\t*featurep++ = dyncat(\"b:\", (bnp++)->node.nam);\n    while (cd_size--) {\n\t*featurep++ = dyncat((cdp->flags & CONDF_INFIX) ? \"C:\" : \"c:\",\n\t\t\t     cdp->name);\n\tcdp++;\n    }\n    while (mf_size--)\n\t*featurep++ = dyncat(\"f:\", (mfp++)->name);\n    while (pd_size--)\n\t*featurep++ = dyncat(\"p:\", (pdp++)->name);\n\n    features[features_size] = NULL;\n    return features;\n}\n\n/*\n * Return the current set of enables for the features in a\n * module using heap memory.  Leave space for abstract\n * features.  The array is not zero terminated.\n */\n/**/\nmod_export int *\ngetfeatureenables(UNUSED(Module m), Features f)\n{\n    int bn_size = f->bn_size, cd_size = f->cd_size;\n    int mf_size = f->mf_size, pd_size = f->pd_size;\n    int features_size = bn_size + cd_size + mf_size + pd_size + f->n_abstract;\n    Builtin bnp = f->bn_list;\n    Conddef cdp = f->cd_list;\n    MathFunc mfp = f->mf_list;\n    Paramdef pdp = f->pd_list;\n    int *enables = zhalloc(sizeof(int) * features_size);\n    int *enablep = enables;\n\n    while (bn_size--)\n\t*enablep++ = ((bnp++)->node.flags & BINF_ADDED) ? 1 : 0;\n    while (cd_size--)\n\t*enablep++ = ((cdp++)->flags & CONDF_ADDED) ? 1 : 0;\n    while (mf_size--)\n\t*enablep++ = ((mfp++)->flags & MFF_ADDED) ? 1 : 0;\n    while (pd_size--)\n\t*enablep++ = (pdp++)->pm ? 1 : 0;\n\n    return enables;\n}\n\n/*\n * Add or remove the concrete features passed in arguments,\n * depending on the corresponding element of the array e.\n * If e is NULL, disable everything.\n * Return 0 for success, 1 for failure; does not attempt\n * to imitate the return values of addbuiltins() etc.\n * Any failure in adding a requested feature is an\n * error.\n */\n\n/**/\nmod_export int\nsetfeatureenables(Module m, Features f, int *e)\n{\n    int ret = 0;\n\n    if (f->bn_size) {\n\tif (setbuiltins(m->node.nam, f->bn_list, f->bn_size, e))\n\t    ret = 1;\n\tif (e)\n\t    e += f->bn_size;\n    }\n    if (f->cd_size) {\n\tif (setconddefs(m->node.nam, f->cd_list, f->cd_size, e))\n\t    ret = 1;\n\tif (e)\n\t    e += f->cd_size;\n    }\n    if (f->mf_size) {\n\tif (setmathfuncs(m->node.nam, f->mf_list, f->mf_size, e))\n\t    ret = 1;\n\tif (e)\n\t    e += f->mf_size;\n    }\n    if (f->pd_size) {\n\tif (setparamdefs(m->node.nam, f->pd_list, f->pd_size, e))\n\t    ret = 1;\n\tif (e)\n\t    e += f->pd_size;\n    }\n    return ret;\n}\n\n/*\n * Convenient front-end to get or set features which\n * can be used in a module enables_() function.\n */\n\n/**/\nmod_export int\nhandlefeatures(Module m, Features f, int **enables)\n{\n    if (!enables || *enables)\n\treturn setfeatureenables(m, f, enables ? *enables : NULL);\n    *enables = getfeatureenables(m, f);\n    return 0;\n}\n\n/*\n * Ensure module \"modname\" is providing feature with \"prefix\"\n * and \"feature\" (e.g. \"b:\", \"limit\").  If feature is NULL,\n * ensure all features are loaded (used for compatibility\n * with the pre-feature autoloading behaviour).\n *\n * This will usually be called from the main shell to handle\n * loading of an autoloadable feature.\n *\n * Returns 0 on success, 1 for error in module, 2 for error\n * setting the feature.  However, this isn't actually all\n * that useful for testing immediately on an autoload since\n * it could be a failure to autoload a different feature\n * from the one we want.  We could fix this but it's\n * possible to test other ways.\n */\n\n/**/\nmod_export int\nensurefeature(const char *modname, const char *prefix, const char *feature)\n{\n    char *f;\n    struct feature_enables features[2];\n\n    if (!feature)\n\treturn require_module(modname, NULL, 0);\n    f = dyncat(prefix, feature);\n\n    features[0].str = f;\n    features[0].pat = NULL;\n    features[1].str = NULL;\n    features[1].pat = NULL;\n    return require_module(modname, features, 0);\n}\n\n/*\n * Add autoloadable features for a given module.\n */\n\n/**/\nint\nautofeatures(const char *cmdnam, const char *module, char **features,\n\t     int prefchar, int defflags)\n{\n    int ret = 0, subret;\n    Module defm, m;\n    char **modfeatures = NULL;\n    int *modenables = NULL;\n    if (module) {\n\tdefm = (Module)find_module(module,\n\t\t\t\t   FINDMOD_ALIASP|FINDMOD_CREATE, NULL);\n\tif ((defm->node.flags & MOD_LINKED) ? defm->u.linked :\n\t    defm->u.handle) {\n\t    (void)features_module(defm, &modfeatures);\n\t    (void)enables_module(defm, &modenables);\n\t}\n    } else\n\tdefm = NULL;\n\n    for (; *features; features++) {\n\tchar *fnam, *typnam, *feature;\n\tint add, fchar, flags = defflags;\n\tautofeaturefn_t fn;\n\n\tif (prefchar) {\n\t    /*\n\t     * \"features\" is list of bare features with no\n\t     * type prefix; prefchar gives type character.\n\t     */\n\t    add = 1; \t\t/* unless overridden by flag */\n\t    fchar = prefchar;\n\t    fnam = *features;\n\t    feature = zhalloc(strlen(fnam) + 3);\n\t    sprintf(feature, \"%c:%s\", fchar, fnam);\n\t} else {\n\t    feature = *features;\n\t    if (*feature == '-') {\n\t\tadd = 0;\n\t\tfeature++;\n\t    } else {\n\t\tadd = 1;\n\t\tif (*feature == '+')\n\t\t    feature++;\n\t    }\n\n\t    if (!*feature || feature[1] != ':') {\n\t\tzwarnnam(cmdnam, \"bad format for autoloadable feature: `%s'\",\n\t\t\t feature);\n\t\tret = 1;\n\t\tcontinue;\n\t    }\n\t    fnam = feature + 2;\n\t    fchar = feature[0];\n\t}\n\tif (flags & FEAT_REMOVE)\n\t    add = 0;\n\n\tswitch (fchar) {\n\tcase 'b':\n\t    fn = add ? add_autobin : del_autobin;\n\t    typnam = \"builtin\";\n\t    break;\n\n\tcase 'C':\n\t    flags |= FEAT_INFIX;\n\t    /* FALLTHROUGH */\n\tcase 'c':\n\t    fn = add ? add_autocond : del_autocond;\n\t    typnam = \"condition\";\n\t    break;\n\n\tcase 'f':\n\t    fn = add ? add_automathfunc : del_automathfunc;\n\t    typnam = \"math function\";\n\t    break;\n\n\tcase 'p':\n\t    fn = add ? add_autoparam : del_autoparam;\n\t    typnam = \"parameter\";\n\t    break;\n\n\tdefault:\n\t    zwarnnam(cmdnam, \"bad autoloadable feature type: `%c'\",\n\t\t     fchar);\n\t    ret = 1;\n\t    continue;\n\t}\n\n\tif (strchr(fnam, '/')) {\n\t    zwarnnam(cmdnam, \"%s: `/' is illegal in a %s\", fnam, typnam);\n\t    ret = 1;\n\t    continue;\n\t}\n\n\tif (!module) {\n\t    /*\n\t     * Traditional un-autoload syntax doesn't tell us\n\t     * which module this came from.\n\t     */\n\t    int i;\n\t    for (i = 0, m = NULL; !m && i < modulestab->hsize; i++) {\n\t\tfor (m = (Module)modulestab->nodes[i]; m;\n\t\t     m = (Module)m->node.next) {\n\t\t    if (m->autoloads &&\n\t\t\tlinknodebystring(m->autoloads, feature))\n\t\t\tbreak;\n\t\t}\n\t    }\n\t    if (!m) {\n\t\tif (!(flags & FEAT_IGNORE)) {\n\t\t    ret = 1;\n\t\t    zwarnnam(cmdnam, \"%s: no such %s\", fnam, typnam);\n\t\t}\n\t\tcontinue;\n\t    }\n\t} else\n\t    m = defm;\n\n\tsubret = 0;\n\tif (add) {\n\t    char **ptr;\n\t    if (modfeatures) {\n\t\t/*\n\t\t * If the module is already available, check that\n\t\t * it does in fact provide the necessary feature.\n\t\t */\n\t\tfor (ptr = modfeatures; *ptr; ptr++)\n\t\t    if (!strcmp(*ptr, feature))\n\t\t\tbreak;\n\t\tif (!*ptr) {\n\t\t    zwarnnam(cmdnam, \"module `%s' has no such feature: `%s'\",\n\t\t\t     m->node.nam, feature);\n\t\t    ret = 1;\n\t\t    continue;\n\t\t}\n\t\t/*\n\t\t * If the feature is already provided by the module, there's\n\t\t * nothing more to do.\n\t\t */\n\t\tif (modenables[ptr-modfeatures])\n\t\t    continue;\n\t\t/*\n\t\t * Otherwise, marking it for autoload will do the\n\t\t * right thing when the feature is eventually used.\n\t\t */\n\t    }\n\t    if (!m->autoloads) {\n\t\tm->autoloads = znewlinklist();\n\t\tzaddlinknode(m->autoloads, ztrdup(feature));\n\t    } else {\n\t\t/* Insert in lexical order */\n\t\tLinkNode ln, prev = (LinkNode)m->autoloads;\n\t\twhile ((ln = nextnode(prev))) {\n\t\t    int cmp = strcmp(feature, (char *)getdata(ln));\n\t\t    if (cmp == 0) {\n\t\t\t/* Already there.  Never an error. */\n\t\t\tbreak;\n\t\t    }\n\t\t    if (cmp < 0) {\n\t\t\tzinsertlinknode(m->autoloads, prev,\n\t\t\t\t\tztrdup(feature));\n\t\t\tbreak;\n\t\t    }\n\t\t    prev = ln;\n\t\t}\n\t\tif (!ln)\n\t\t    zaddlinknode(m->autoloads, ztrdup(feature));\n\t    }\n\t} else if (m->autoloads) {\n\t    LinkNode ln;\n\t    if ((ln = linknodebystring(m->autoloads, feature)))\n\t\tzsfree((char *)remnode(m->autoloads, ln));\n\t    else {\n\t\t/*\n\t\t * With -i (or zmodload -Fa), removing an autoload\n\t\t * that's not there is not an error.\n\t\t */\n\t\tsubret = (flags & FEAT_IGNORE) ? -2 : 2;\n\t    }\n\t}\n\n\tif (subret == 0)\n\t    subret = fn(module, fnam, flags);\n\n\tif (subret != 0) {\n\t    /* -2 indicates not an error, just skip running fn() */\n\t    if (subret != -2)\n\t\tret = 1;\n\t    switch (subret) {\n\t    case 1:\n\t\tzwarnnam(cmdnam, \"failed to add %s `%s'\", typnam, fnam);\n\t\tbreak;\n\n\t    case 2:\n\t\tzwarnnam(cmdnam, \"%s: no such %s\", fnam, typnam);\n\t\tbreak;\n\n\t    case 3:\n\t\tzwarnnam(cmdnam, \"%s: %s is already defined\", fnam, typnam);\n\t\tbreak;\n\n\t    default:\n\t\t/* no (further) message needed */\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    return ret;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-zsh-5.6.2-in6fa74mnlid6t7rhhv7rn7bvrxkfdak/spack-src/Src/zsh.ico",
        "/tmp/vanessa/spack-stage/spack-stage-zsh-5.6.2-in6fa74mnlid6t7rhhv7rn7bvrxkfdak/spack-src/Test/D02glob.ztst",
        "/tmp/vanessa/spack-stage/spack-stage-zsh-5.6.2-in6fa74mnlid6t7rhhv7rn7bvrxkfdak/spack-src/Test/A05execution.ztst"
    ],
    "total_files": 448
}