{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-slie2xlghwqb34kwk6dwl34nztyqctdw/spack-src/c/_cffi_backend.c": "#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include \"structmember.h\"\n\n#ifdef MS_WIN32\n#include <windows.h>\n#include \"misc_win32.h\"\n#else\n#include <stddef.h>\n#include <stdint.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <ffi.h>\n#include <sys/mman.h>\n#endif\n\n/* this block of #ifs should be kept exactly identical between\n   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py */\n#if defined(_MSC_VER)\n# include <malloc.h>   /* for alloca() */\n# if _MSC_VER < 1600   /* MSVC < 2010 */\n   typedef __int8 int8_t;\n   typedef __int16 int16_t;\n   typedef __int32 int32_t;\n   typedef __int64 int64_t;\n   typedef unsigned __int8 uint8_t;\n   typedef unsigned __int16 uint16_t;\n   typedef unsigned __int32 uint32_t;\n   typedef unsigned __int64 uint64_t;\n   typedef __int8 int_least8_t;\n   typedef __int16 int_least16_t;\n   typedef __int32 int_least32_t;\n   typedef __int64 int_least64_t;\n   typedef unsigned __int8 uint_least8_t;\n   typedef unsigned __int16 uint_least16_t;\n   typedef unsigned __int32 uint_least32_t;\n   typedef unsigned __int64 uint_least64_t;\n   typedef __int8 int_fast8_t;\n   typedef __int16 int_fast16_t;\n   typedef __int32 int_fast32_t;\n   typedef __int64 int_fast64_t;\n   typedef unsigned __int8 uint_fast8_t;\n   typedef unsigned __int16 uint_fast16_t;\n   typedef unsigned __int32 uint_fast32_t;\n   typedef unsigned __int64 uint_fast64_t;\n   typedef __int64 intmax_t;\n   typedef unsigned __int64 uintmax_t;\n# else\n#  include <stdint.h>\n# endif\n# if _MSC_VER < 1800   /* MSVC < 2013 */\n   typedef unsigned char _Bool;\n# endif\n#else\n# include <stdint.h>\n# if (defined (__SVR4) && defined (__sun)) || defined(_AIX)\n#  include <alloca.h>\n# endif\n#endif\n\n#include \"malloc_closure.h\"\n\n#if PY_MAJOR_VERSION >= 3\n# define STR_OR_BYTES \"bytes\"\n# define PyText_Type PyUnicode_Type\n# define PyText_Check PyUnicode_Check\n# define PyTextAny_Check PyUnicode_Check\n# define PyText_FromFormat PyUnicode_FromFormat\n# define PyText_AsUTF8 _PyUnicode_AsString   /* PyUnicode_AsUTF8 in Py3.3 */\n# define PyText_AS_UTF8 _PyUnicode_AsString\n# define PyText_GetSize PyUnicode_GetSize\n# define PyText_FromString PyUnicode_FromString\n# define PyText_FromStringAndSize PyUnicode_FromStringAndSize\n# define PyText_InternInPlace PyUnicode_InternInPlace\n# define PyText_InternFromString PyUnicode_InternFromString\n# define PyIntOrLong_Check PyLong_Check\n#else\n# define STR_OR_BYTES \"str\"\n# define PyText_Type PyString_Type\n# define PyText_Check PyString_Check\n# define PyTextAny_Check(op) (PyString_Check(op) || PyUnicode_Check(op))\n# define PyText_FromFormat PyString_FromFormat\n# define PyText_AsUTF8 PyString_AsString\n# define PyText_AS_UTF8 PyString_AS_STRING\n# define PyText_GetSize PyString_Size\n# define PyText_FromString PyString_FromString\n# define PyText_FromStringAndSize PyString_FromStringAndSize\n# define PyText_InternInPlace PyString_InternInPlace\n# define PyText_InternFromString PyString_InternFromString\n# define PyIntOrLong_Check(op) (PyInt_Check(op) || PyLong_Check(op))\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n# define PyInt_FromLong PyLong_FromLong\n# define PyInt_FromSsize_t PyLong_FromSsize_t\n# define PyInt_AsSsize_t PyLong_AsSsize_t\n# define PyInt_AsLong PyLong_AsLong\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n/* This is the default on Python3 and constant has been removed. */\n# define Py_TPFLAGS_CHECKTYPES 0\n#endif\n\n#if PY_MAJOR_VERSION < 3\n#define PyCapsule_New(pointer, name, destructor)        \\\n    (PyCObject_FromVoidPtr(pointer, destructor))\n#endif\n\n/************************************************************/\n\n/* base type flag: exactly one of the following: */\n#define CT_PRIMITIVE_SIGNED   1    /* signed integer */\n#define CT_PRIMITIVE_UNSIGNED 2    /* unsigned integer */\n#define CT_PRIMITIVE_CHAR     4    /* char, wchar_t */\n#define CT_PRIMITIVE_FLOAT    8    /* float, double, long double */\n#define CT_POINTER           16    /* pointer, excluding ptr-to-func */\n#define CT_ARRAY             32    /* array */\n#define CT_STRUCT            64    /* struct */\n#define CT_UNION            128    /* union */\n#define CT_FUNCTIONPTR      256    /* pointer to function */\n#define CT_VOID             512    /* void */\n\n/* other flags that may also be set in addition to the base flag: */\n#define CT_CAST_ANYTHING         1024    /* 'char *' and 'void *' only */\n#define CT_PRIMITIVE_FITS_LONG   2048\n#define CT_IS_OPAQUE             4096\n#define CT_IS_ENUM               8192\n#define CT_IS_PTR_TO_OWNED      16384\n#define CT_CUSTOM_FIELD_POS     32768\n#define CT_IS_LONGDOUBLE        65536\n#define CT_IS_BOOL             131072\n#define CT_IS_FILE             262144\n#define CT_IS_VOID_PTR         524288\n#define CT_WITH_VAR_ARRAY     1048576\n#define CT_IS_UNSIZED_CHAR_A  2097152\n#define CT_LAZY_FIELD_LIST    4194304\n#define CT_PRIMITIVE_ANY  (CT_PRIMITIVE_SIGNED |        \\\n                           CT_PRIMITIVE_UNSIGNED |      \\\n                           CT_PRIMITIVE_CHAR |          \\\n                           CT_PRIMITIVE_FLOAT)\n\ntypedef struct _ctypedescr {\n    PyObject_VAR_HEAD\n\n    struct _ctypedescr *ct_itemdescr;  /* ptrs and arrays: the item type */\n    PyObject *ct_stuff;                /* structs: dict of the fields\n                                          arrays: ctypedescr of the ptr type\n                                          function: tuple(abi, ctres, ctargs..)\n                                          enum: pair {\"name\":x},{x:\"name\"}\n                                          ptrs: lazily, ctypedescr of array */\n    void *ct_extra;                    /* structs: first field (not a ref!)\n                                          function types: cif_description\n                                          primitives: prebuilt \"cif\" object */\n\n    PyObject *ct_weakreflist;    /* weakref support */\n\n    Py_ssize_t ct_size;     /* size of instances, or -1 if unknown */\n    Py_ssize_t ct_length;   /* length of arrays, or -1 if unknown;\n                               or alignment of primitive and struct types;\n                               always -1 for pointers */\n    int ct_flags;           /* CT_xxx flags */\n\n    int ct_name_position;   /* index in ct_name of where to put a var name */\n    char ct_name[1];        /* string, e.g. \"int *\" for pointers to ints */\n} CTypeDescrObject;\n\ntypedef struct {\n    PyObject_HEAD\n    CTypeDescrObject *c_type;\n    char *c_data;\n    PyObject *c_weakreflist;\n} CDataObject;\n\ntypedef struct cfieldobject_s {\n    PyObject_HEAD\n    CTypeDescrObject *cf_type;\n    Py_ssize_t cf_offset;\n    short cf_bitshift;   /* >= 0: bitshift; or BS_REGULAR or BS_EMPTY_ARRAY */\n    short cf_bitsize;\n    struct cfieldobject_s *cf_next;\n} CFieldObject;\n#define BS_REGULAR     (-1)      /* a regular field, not with bitshift */\n#define BS_EMPTY_ARRAY (-2)      /* a field which is an array 'type[0]' */\n\nstatic PyTypeObject CTypeDescr_Type;\nstatic PyTypeObject CField_Type;\nstatic PyTypeObject CData_Type;\nstatic PyTypeObject CDataOwning_Type;\nstatic PyTypeObject CDataOwningGC_Type;\n\n#define CTypeDescr_Check(ob)  (Py_TYPE(ob) == &CTypeDescr_Type)\n#define CData_Check(ob)       (Py_TYPE(ob) == &CData_Type ||            \\\n                               Py_TYPE(ob) == &CDataOwning_Type ||      \\\n                               Py_TYPE(ob) == &CDataOwningGC_Type)\n#define CDataOwn_Check(ob)    (Py_TYPE(ob) == &CDataOwning_Type ||      \\\n                               Py_TYPE(ob) == &CDataOwningGC_Type)\n\ntypedef union {\n    unsigned char m_char;\n    unsigned short m_short;\n    unsigned int m_int;\n    unsigned long m_long;\n    unsigned long long m_longlong;\n    float m_float;\n    double m_double;\n    long double m_longdouble;\n} union_alignment;\n\ntypedef struct {\n    CDataObject head;\n    union_alignment alignment;\n} CDataObject_casted_primitive;\n\ntypedef struct {\n    CDataObject head;\n    union_alignment alignment;\n} CDataObject_own_nolength;\n\ntypedef struct {\n    CDataObject head;\n    Py_ssize_t length;\n    union_alignment alignment;\n} CDataObject_own_length;\n\ntypedef struct {\n    CDataObject head;\n    PyObject *structobj;\n} CDataObject_own_structptr;\n\ntypedef struct {\n    CDataObject head;\n    Py_ssize_t length;     /* same as CDataObject_own_length up to here */\n    Py_buffer *bufferview;\n} CDataObject_owngc_frombuf;\n\ntypedef struct {\n    ffi_cif cif;\n    /* the following information is used when doing the call:\n       - a buffer of size 'exchange_size' is malloced\n       - the arguments are converted from Python objects to raw data\n       - the i'th raw data is stored at 'buffer + exchange_offset_arg[1+i]'\n       - the call is done\n       - the result is read back from 'buffer + exchange_offset_arg[0]' */\n    Py_ssize_t exchange_size;\n    Py_ssize_t exchange_offset_arg[1];\n} cif_description_t;\n\n\n/* whenever running Python code, the errno is saved in this thread-local\n   variable */\n#ifndef MS_WIN32\n# ifdef USE__THREAD\n/* This macro ^^^ is defined by setup.py if it finds that it is\n   syntactically valid to use \"__thread\" with this C compiler. */\nstatic __thread int cffi_saved_errno = 0;\nstatic void save_errno(void) { cffi_saved_errno = errno; }\nstatic void restore_errno(void) { errno = cffi_saved_errno; }\nstatic void init_errno(void) { }\n# else\n#  include \"misc_thread.h\"\n# endif\n# define save_errno_only      save_errno\n# define restore_errno_only   restore_errno\n#endif\n\n#include \"minibuffer.h\"\n\n#if PY_MAJOR_VERSION >= 3\n# include \"file_emulator.h\"\n#endif\n\n#ifdef HAVE_WCHAR_H\n# include \"wchar_helper.h\"\n#endif\n\nstatic PyObject *FFIError;\n\n/************************************************************/\n\nstatic CTypeDescrObject *\nctypedescr_new(int name_size)\n{\n    CTypeDescrObject *ct = PyObject_GC_NewVar(CTypeDescrObject,\n                                              &CTypeDescr_Type,\n                                              name_size);\n    if (ct == NULL)\n        return NULL;\n\n    ct->ct_itemdescr = NULL;\n    ct->ct_stuff = NULL;\n    ct->ct_weakreflist = NULL;\n    PyObject_GC_Track(ct);\n    return ct;\n}\n\nstatic CTypeDescrObject *\nctypedescr_new_on_top(CTypeDescrObject *ct_base, const char *extra_text,\n                      int extra_position)\n{\n    int base_name_len = strlen(ct_base->ct_name);\n    int extra_name_len = strlen(extra_text);\n    CTypeDescrObject *ct = ctypedescr_new(base_name_len + extra_name_len + 1);\n    char *p;\n    if (ct == NULL)\n        return NULL;\n\n    Py_INCREF(ct_base);\n    ct->ct_itemdescr = ct_base;\n    ct->ct_name_position = ct_base->ct_name_position + extra_position;\n\n    p = ct->ct_name;\n    memcpy(p, ct_base->ct_name, ct_base->ct_name_position);\n    p += ct_base->ct_name_position;\n    memcpy(p, extra_text, extra_name_len);\n    p += extra_name_len;\n    memcpy(p, ct_base->ct_name + ct_base->ct_name_position,\n           base_name_len - ct_base->ct_name_position + 1);\n\n    return ct;\n}\n\nstatic PyObject *\nctypedescr_repr(CTypeDescrObject *ct)\n{\n    return PyText_FromFormat(\"<ctype '%s'>\", ct->ct_name);\n}\n\nstatic void\nctypedescr_dealloc(CTypeDescrObject *ct)\n{\n    PyObject_GC_UnTrack(ct);\n    if (ct->ct_weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) ct);\n    Py_XDECREF(ct->ct_itemdescr);\n    Py_XDECREF(ct->ct_stuff);\n    if (ct->ct_flags & CT_FUNCTIONPTR)\n        PyObject_Free(ct->ct_extra);\n    Py_TYPE(ct)->tp_free((PyObject *)ct);\n}\n\nstatic int\nctypedescr_traverse(CTypeDescrObject *ct, visitproc visit, void *arg)\n{\n    Py_VISIT(ct->ct_itemdescr);\n    Py_VISIT(ct->ct_stuff);\n    return 0;\n}\n\nstatic int\nctypedescr_clear(CTypeDescrObject *ct)\n{\n    Py_CLEAR(ct->ct_itemdescr);\n    Py_CLEAR(ct->ct_stuff);\n    return 0;\n}\n\n\nstatic PyObject *nosuchattr(const char *attr)\n{\n    PyErr_SetString(PyExc_AttributeError, attr);\n    return NULL;\n}\n\nstatic PyObject *ctypeget_kind(CTypeDescrObject *ct, void *context)\n{\n    char *result;\n    if (ct->ct_flags & CT_PRIMITIVE_ANY) {\n        if (ct->ct_flags & CT_IS_ENUM)\n            result = \"enum\";\n        else\n            result = \"primitive\";\n    }\n    else if (ct->ct_flags & CT_POINTER) {\n        result = \"pointer\";\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        result = \"array\";\n    }\n    else if (ct->ct_flags & CT_VOID) {\n        result = \"void\";\n    }\n    else if (ct->ct_flags & CT_STRUCT) {\n        result = \"struct\";\n    }\n    else if (ct->ct_flags & CT_UNION) {\n        result = \"union\";\n    }\n    else if (ct->ct_flags & CT_FUNCTIONPTR) {\n        result = \"function\";\n    }\n    else\n        result = \"?\";\n\n    return PyText_FromString(result);\n}\n\nstatic PyObject *ctypeget_cname(CTypeDescrObject *ct, void *context)\n{\n    return PyText_FromString(ct->ct_name);\n}\n\nstatic PyObject *ctypeget_item(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & (CT_POINTER | CT_ARRAY)) {\n        Py_INCREF(ct->ct_itemdescr);\n        return (PyObject *)ct->ct_itemdescr;\n    }\n    return nosuchattr(\"item\");\n}\n\nstatic PyObject *ctypeget_length(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_ARRAY) {\n        if (ct->ct_length >= 0) {\n            return PyInt_FromSsize_t(ct->ct_length);\n        }\n        else {\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n    return nosuchattr(\"length\");\n}\n\nstatic PyObject *\nget_field_name(CTypeDescrObject *ct, CFieldObject *cf);   /* forward */\n\n#define force_lazy_struct(ct)                                           \\\n    ((ct)->ct_stuff != NULL ? 1 : do_realize_lazy_struct(ct))\n\nstatic int do_realize_lazy_struct(CTypeDescrObject *ct);\n/* forward, implemented in realize_c_type.c */\n\nstatic PyObject *ctypeget_fields(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & (CT_STRUCT | CT_UNION)) {\n        if (!(ct->ct_flags & CT_IS_OPAQUE)) {\n            CFieldObject *cf;\n            PyObject *res;\n            if (force_lazy_struct(ct) < 0)\n                return NULL;\n            res = PyList_New(0);\n            if (res == NULL)\n                return NULL;\n            for (cf = (CFieldObject *)ct->ct_extra;\n                 cf != NULL; cf = cf->cf_next) {\n                PyObject *o = PyTuple_Pack(2, get_field_name(ct, cf),\n                                           (PyObject *)cf);\n                int err = (o != NULL) ? PyList_Append(res, o) : -1;\n                Py_XDECREF(o);\n                if (err < 0) {\n                    Py_DECREF(res);\n                    return NULL;\n                }\n            }\n            return res;\n        }\n        else {\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n    return nosuchattr(\"fields\");\n}\n\nstatic PyObject *ctypeget_args(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *t = ct->ct_stuff;\n        return PyTuple_GetSlice(t, 2, PyTuple_GET_SIZE(t));\n    }\n    return nosuchattr(\"args\");\n}\n\nstatic PyObject *ctypeget_result(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 1);\n        Py_XINCREF(res);\n        return res;\n    }\n    return nosuchattr(\"result\");\n}\n\nstatic PyObject *ctypeget_ellipsis(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = ct->ct_extra ? Py_False : Py_True;\n        Py_INCREF(res);\n        return res;\n    }\n    return nosuchattr(\"ellipsis\");\n}\n\nstatic PyObject *ctypeget_abi(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 0);\n        Py_XINCREF(res);\n        return res;\n    }\n    return nosuchattr(\"abi\");\n}\n\nstatic PyObject *ctypeget_elements(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_IS_ENUM) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 1);\n        if (res) res = PyDict_Copy(res);\n        return res;\n    }\n    return nosuchattr(\"elements\");\n}\n\nstatic PyObject *ctypeget_relements(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_IS_ENUM) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 0);\n        if (res) res = PyDict_Copy(res);\n        return res;\n    }\n    return nosuchattr(\"relements\");\n}\n\nstatic PyGetSetDef ctypedescr_getsets[] = {\n    {\"kind\", (getter)ctypeget_kind, NULL, \"kind\"},\n    {\"cname\", (getter)ctypeget_cname, NULL, \"C name\"},\n    {\"item\", (getter)ctypeget_item, NULL, \"pointer to, or array of\"},\n    {\"length\", (getter)ctypeget_length, NULL, \"array length or None\"},\n    {\"fields\", (getter)ctypeget_fields, NULL, \"struct or union fields\"},\n    {\"args\", (getter)ctypeget_args, NULL, \"function argument types\"},\n    {\"result\", (getter)ctypeget_result, NULL, \"function result type\"},\n    {\"ellipsis\", (getter)ctypeget_ellipsis, NULL, \"function has '...'\"},\n    {\"abi\", (getter)ctypeget_abi, NULL, \"function ABI\"},\n    {\"elements\", (getter)ctypeget_elements, NULL, \"enum elements\"},\n    {\"relements\", (getter)ctypeget_relements, NULL, \"enum elements, reverse\"},\n    {NULL}                        /* sentinel */\n};\n\nstatic PyObject *\nctypedescr_dir(PyObject *ct, PyObject *noarg)\n{\n    int err;\n    struct PyGetSetDef *gsdef;\n    PyObject *res = PyList_New(0);\n    if (res == NULL)\n        return NULL;\n\n    for (gsdef = ctypedescr_getsets; gsdef->name; gsdef++) {\n        PyObject *x = PyObject_GetAttrString(ct, gsdef->name);\n        if (x == NULL) {\n            PyErr_Clear();\n        }\n        else {\n            Py_DECREF(x);\n            x = PyText_FromString(gsdef->name);\n            err = (x != NULL) ? PyList_Append(res, x) : -1;\n            Py_XDECREF(x);\n            if (err < 0) {\n                Py_DECREF(res);\n                return NULL;\n            }\n        }\n    }\n    return res;\n}\n\nstatic PyMethodDef ctypedescr_methods[] = {\n    {\"__dir__\",   ctypedescr_dir,  METH_NOARGS},\n    {NULL,        NULL}           /* sentinel */\n};\n\nstatic PyTypeObject CTypeDescr_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CTypeDescr\",\n    offsetof(CTypeDescrObject, ct_name),\n    sizeof(char),\n    (destructor)ctypedescr_dealloc,             /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)ctypedescr_repr,                  /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,    /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)ctypedescr_traverse,          /* tp_traverse */\n    (inquiry)ctypedescr_clear,                  /* tp_clear */\n    0,                                          /* tp_richcompare */\n    offsetof(CTypeDescrObject, ct_weakreflist), /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    ctypedescr_methods,                         /* tp_methods */\n    0,                                          /* tp_members */\n    ctypedescr_getsets,                         /* tp_getset */\n};\n\n/************************************************************/\n\nstatic PyObject *\nget_field_name(CTypeDescrObject *ct, CFieldObject *cf)\n{\n    Py_ssize_t i = 0;\n    PyObject *d_key, *d_value;\n    while (PyDict_Next(ct->ct_stuff, &i, &d_key, &d_value)) {\n        if (d_value == (PyObject *)cf)\n            return d_key;\n    }\n    Py_FatalError(\"_cffi_backend: get_field_name()\");\n    return NULL;\n}\n\nstatic void\ncfield_dealloc(CFieldObject *cf)\n{\n    Py_DECREF(cf->cf_type);\n    PyObject_Del(cf);\n}\n\n#undef OFF\n#define OFF(x) offsetof(CFieldObject, x)\n\nstatic PyMemberDef cfield_members[] = {\n    {\"type\", T_OBJECT, OFF(cf_type), READONLY},\n    {\"offset\", T_PYSSIZET, OFF(cf_offset), READONLY},\n    {\"bitshift\", T_SHORT, OFF(cf_bitshift), READONLY},\n    {\"bitsize\", T_SHORT, OFF(cf_bitsize), READONLY},\n    {NULL}      /* Sentinel */\n};\n#undef OFF\n\nstatic PyTypeObject CField_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CField\",\n    sizeof(CFieldObject),\n    0,\n    (destructor)cfield_dealloc,                 /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    cfield_members,                             /* tp_members */\n};\n\n/************************************************************/\n\nstatic int\nCDataObject_Or_PyFloat_Check(PyObject *ob)\n{\n    return (PyFloat_Check(ob) ||\n            (CData_Check(ob) &&\n             (((CDataObject *)ob)->c_type->ct_flags & CT_PRIMITIVE_FLOAT)));\n}\n\nstatic PY_LONG_LONG\n_my_PyLong_AsLongLong(PyObject *ob)\n{\n    /* (possibly) convert and cast a Python object to a long long.\n       Like PyLong_AsLongLong(), this version accepts a Python int too, and\n       does convertions from other types of objects.  The difference is that\n       this version refuses floats. */\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        return PyInt_AS_LONG(ob);\n    }\n    else \n#endif\n    if (PyLong_Check(ob)) {\n        return PyLong_AsLongLong(ob);\n    }\n    else {\n        PyObject *io;\n        PY_LONG_LONG res;\n        PyNumberMethods *nb = ob->ob_type->tp_as_number;\n\n        if (CDataObject_Or_PyFloat_Check(ob) ||\n                nb == NULL || nb->nb_int == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"an integer is required\");\n            return -1;\n        }\n        io = (*nb->nb_int) (ob);\n        if (io == NULL)\n            return -1;\n\n        if (PyIntOrLong_Check(io)) {\n            res = _my_PyLong_AsLongLong(io);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError, \"integer conversion failed\");\n            res = -1;\n        }\n        Py_DECREF(io);\n        return res;\n    }\n}\n\nstatic unsigned PY_LONG_LONG\n_my_PyLong_AsUnsignedLongLong(PyObject *ob, int strict)\n{\n    /* (possibly) convert and cast a Python object to an unsigned long long.\n       Like PyLong_AsLongLong(), this version accepts a Python int too, and\n       does convertions from other types of objects.  If 'strict', complains\n       with OverflowError and refuses floats.  If '!strict', rounds floats\n       and masks the result. */\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        long value1 = PyInt_AS_LONG(ob);\n        if (strict && value1 < 0)\n            goto negative;\n        return (unsigned PY_LONG_LONG)(PY_LONG_LONG)value1;\n    }\n    else\n#endif\n    if (PyLong_Check(ob)) {\n        if (strict) {\n            if (_PyLong_Sign(ob) < 0)\n                goto negative;\n            return PyLong_AsUnsignedLongLong(ob);\n        }\n        else {\n            return PyLong_AsUnsignedLongLongMask(ob);\n        }\n    }\n    else {\n        PyObject *io;\n        unsigned PY_LONG_LONG res;\n        PyNumberMethods *nb = ob->ob_type->tp_as_number;\n\n        if ((strict && CDataObject_Or_PyFloat_Check(ob)) ||\n                nb == NULL || nb->nb_int == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"an integer is required\");\n            return (unsigned PY_LONG_LONG)-1;\n        }\n        io = (*nb->nb_int) (ob);\n        if (io == NULL)\n            return (unsigned PY_LONG_LONG)-1;\n\n        if (PyIntOrLong_Check(io)) {\n            res = _my_PyLong_AsUnsignedLongLong(io, strict);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError, \"integer conversion failed\");\n            res = (unsigned PY_LONG_LONG)-1;\n        }\n        Py_DECREF(io);\n        return res;\n    }\n\n negative:\n    PyErr_SetString(PyExc_OverflowError,\n                    \"can't convert negative number to unsigned\");\n    return (unsigned PY_LONG_LONG)-1;\n}\n\n#define _read_raw_data(type)                    \\\n    do {                                        \\\n        if (size == sizeof(type)) {             \\\n            type r;                             \\\n            memcpy(&r, target, sizeof(type));   \\\n            return r;                           \\\n        }                                       \\\n    } while(0)\n\nstatic PY_LONG_LONG\nread_raw_signed_data(char *target, int size)\n{\n    _read_raw_data(signed char);\n    _read_raw_data(short);\n    _read_raw_data(int);\n    _read_raw_data(long);\n    _read_raw_data(PY_LONG_LONG);\n    Py_FatalError(\"read_raw_signed_data: bad integer size\");\n    return 0;\n}\n\nstatic unsigned PY_LONG_LONG\nread_raw_unsigned_data(char *target, int size)\n{\n    _read_raw_data(unsigned char);\n    _read_raw_data(unsigned short);\n    _read_raw_data(unsigned int);\n    _read_raw_data(unsigned long);\n    _read_raw_data(unsigned PY_LONG_LONG);\n    Py_FatalError(\"read_raw_unsigned_data: bad integer size\");\n    return 0;\n}\n\n#define _write_raw_data(type)                           \\\n    do {                                                \\\n        if (size == sizeof(type)) {                     \\\n            type r = (type)source;                      \\\n            memcpy(target, &r, sizeof(type));           \\\n            return;                                     \\\n        }                                               \\\n    } while(0)\n\nstatic void\nwrite_raw_integer_data(char *target, unsigned PY_LONG_LONG source, int size)\n{\n    _write_raw_data(unsigned char);\n    _write_raw_data(unsigned short);\n    _write_raw_data(unsigned int);\n    _write_raw_data(unsigned long);\n    _write_raw_data(unsigned PY_LONG_LONG);\n    Py_FatalError(\"write_raw_integer_data: bad integer size\");\n}\n\nstatic double\nread_raw_float_data(char *target, int size)\n{\n    _read_raw_data(float);\n    _read_raw_data(double);\n    Py_FatalError(\"read_raw_float_data: bad float size\");\n    return 0;\n}\n\nstatic long double\nread_raw_longdouble_data(char *target)\n{\n    int size = sizeof(long double);\n    _read_raw_data(long double);\n    Py_FatalError(\"read_raw_longdouble_data: bad long double size\");\n    return 0;\n}\n\nstatic void\nwrite_raw_float_data(char *target, double source, int size)\n{\n    _write_raw_data(float);\n    _write_raw_data(double);\n    Py_FatalError(\"write_raw_float_data: bad float size\");\n}\n\nstatic void\nwrite_raw_longdouble_data(char *target, long double source)\n{\n    int size = sizeof(long double);\n    _write_raw_data(long double);\n}\n\nstatic PyObject *\nnew_simple_cdata(char *data, CTypeDescrObject *ct)\n{\n    CDataObject *cd = PyObject_New(CDataObject, &CData_Type);\n    if (cd == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    cd->c_data = data;\n    cd->c_type = ct;\n    cd->c_weakreflist = NULL;\n    return (PyObject *)cd;\n}\n\nstatic CDataObject *_new_casted_primitive(CTypeDescrObject *ct);  /*forward*/\n\nstatic PyObject *\nconvert_to_object(char *data, CTypeDescrObject *ct)\n{\n    if (!(ct->ct_flags & CT_PRIMITIVE_ANY)) {\n        /* non-primitive types (check done just for performance) */\n        if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n            char *ptrdata = *(char **)data;\n            /*READ(data, sizeof(char *))*/\n            return new_simple_cdata(ptrdata, ct);\n        }\n        else if (ct->ct_flags & CT_IS_OPAQUE) {\n            PyErr_Format(PyExc_TypeError, \"cdata '%s' is opaque\",\n                         ct->ct_name);\n            return NULL;\n        }\n        else if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n            return new_simple_cdata(data, ct);\n        }\n        else if (ct->ct_flags & CT_ARRAY) {\n            if (ct->ct_length < 0) {\n                /* we can't return a <cdata 'int[]'> here, because we don't\n                   know the length to give it.  As a compromize, returns\n                   <cdata 'int *'> in this case. */\n                ct = (CTypeDescrObject *)ct->ct_stuff;\n            }\n            return new_simple_cdata(data, ct);\n        }\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        PY_LONG_LONG value;\n        /*READ(data, ct->ct_size)*/\n        value = read_raw_signed_data(data, ct->ct_size);\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)value);\n        else\n            return PyLong_FromLongLong(value);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        unsigned PY_LONG_LONG value;\n        /*READ(data, ct->ct_size)*/\n        value = read_raw_unsigned_data(data, ct->ct_size);\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)value);\n        else\n            return PyLong_FromUnsignedLongLong(value);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        /*READ(data, ct->ct_size)*/\n        if (!(ct->ct_flags & CT_IS_LONGDOUBLE)) {\n            double value = read_raw_float_data(data, ct->ct_size);\n            return PyFloat_FromDouble(value);\n        }\n        else {\n            long double value = read_raw_longdouble_data(data);\n            CDataObject *cd = _new_casted_primitive(ct);\n            if (cd != NULL)\n                write_raw_longdouble_data(cd->c_data, value);\n            return (PyObject *)cd;\n        }\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_CHAR) {\n        /*READ(data, ct->ct_size)*/\n        if (ct->ct_size == sizeof(char))\n            return PyBytes_FromStringAndSize(data, 1);\n#ifdef HAVE_WCHAR_H\n        else\n            return _my_PyUnicode_FromWideChar((wchar_t *)data, 1);\n#endif\n    }\n\n    PyErr_Format(PyExc_SystemError,\n                 \"convert_to_object: '%s'\", ct->ct_name);\n    return NULL;\n}\n\nstatic PyObject *\nconvert_to_object_bitfield(char *data, CFieldObject *cf)\n{\n    CTypeDescrObject *ct = cf->cf_type;\n    /*READ(data, ct->ct_size)*/\n\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        unsigned PY_LONG_LONG value, valuemask, shiftforsign;\n        PY_LONG_LONG result;\n\n        value = (unsigned PY_LONG_LONG)read_raw_signed_data(data, ct->ct_size);\n        valuemask = (1ULL << cf->cf_bitsize) - 1ULL;\n        shiftforsign = 1ULL << (cf->cf_bitsize - 1);\n        value = ((value >> cf->cf_bitshift) + shiftforsign) & valuemask;\n        result = ((PY_LONG_LONG)value) - (PY_LONG_LONG)shiftforsign;\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)result);\n        else\n            return PyLong_FromLongLong(result);\n    }\n    else {\n        unsigned PY_LONG_LONG value, valuemask;\n\n        value = read_raw_unsigned_data(data, ct->ct_size);\n        valuemask = (1ULL << cf->cf_bitsize) - 1ULL;\n        value = (value >> cf->cf_bitshift) & valuemask;\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)value);\n        else\n            return PyLong_FromUnsignedLongLong(value);\n    }\n}\n\nstatic int _convert_overflow(PyObject *init, const char *ct_name)\n{\n    PyObject *s;\n    if (PyErr_Occurred())   /* already an exception pending */\n        return -1;\n    s = PyObject_Str(init);\n    if (s == NULL)\n        return -1;\n    PyErr_Format(PyExc_OverflowError, \"integer %s does not fit '%s'\",\n                 PyText_AS_UTF8(s), ct_name);\n    Py_DECREF(s);\n    return -1;\n}\n\nstatic int _convert_to_char(PyObject *init)\n{\n    if (PyBytes_Check(init) && PyBytes_GET_SIZE(init) == 1) {\n        return (unsigned char)(PyBytes_AS_STRING(init)[0]);\n    }\n    if (CData_Check(init) &&\n           (((CDataObject *)init)->c_type->ct_flags & CT_PRIMITIVE_CHAR) &&\n           (((CDataObject *)init)->c_type->ct_size == sizeof(char))) {\n        char *data = ((CDataObject *)init)->c_data;\n        /*READ(data, 1)*/\n        return *(unsigned char *)data;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"initializer for ctype 'char' must be a \"STR_OR_BYTES\n                 \" of length 1, not %.200s\", Py_TYPE(init)->tp_name);\n    return -1;\n}\n\n#ifdef HAVE_WCHAR_H\nstatic wchar_t _convert_to_wchar_t(PyObject *init)\n{\n    if (PyUnicode_Check(init)) {\n        wchar_t ordinal;\n        if (_my_PyUnicode_AsSingleWideChar(init, &ordinal) == 0)\n            return ordinal;\n    }\n    if (CData_Check(init) &&\n           (((CDataObject *)init)->c_type->ct_flags & CT_PRIMITIVE_CHAR) &&\n           (((CDataObject *)init)->c_type->ct_size == sizeof(wchar_t))) {\n        char *data = ((CDataObject *)init)->c_data;\n        /*READ(data, sizeof(wchar_t))*/\n        return *(wchar_t *)data;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"initializer for ctype 'wchar_t' must be a unicode string \"\n                 \"of length 1, not %.200s\", Py_TYPE(init)->tp_name);\n    return (wchar_t)-1;\n}\n#endif\n\nstatic int _convert_error(PyObject *init, const char *ct_name,\n                          const char *expected)\n{\n    if (CData_Check(init))\n        PyErr_Format(PyExc_TypeError,\n                     \"initializer for ctype '%s' must be a %s, \"\n                     \"not cdata '%s'\",\n                     ct_name, expected,\n                     ((CDataObject *)init)->c_type->ct_name);\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"initializer for ctype '%s' must be a %s, \"\n                     \"not %.200s\",\n                     ct_name, expected, Py_TYPE(init)->tp_name);\n    return -1;\n}\n\nstatic int    /* forward */\nconvert_from_object(char *data, CTypeDescrObject *ct, PyObject *init);\nstatic int    /* forward */\nconvert_from_object_bitfield(char *data, CFieldObject *cf, PyObject *init);\n\nstatic Py_ssize_t\nget_new_array_length(PyObject **pvalue)\n{\n    PyObject *value = *pvalue;\n\n    if (PyList_Check(value) || PyTuple_Check(value)) {\n        return PySequence_Fast_GET_SIZE(value);\n    }\n    else if (PyBytes_Check(value)) {\n        /* from a string, we add the null terminator */\n        return PyBytes_GET_SIZE(value) + 1;\n    }\n    else if (PyUnicode_Check(value)) {\n        /* from a unicode, we add the null terminator */\n        return _my_PyUnicode_SizeAsWideChar(value) + 1;\n    }\n    else {\n        Py_ssize_t explicitlength;\n        explicitlength = PyNumber_AsSsize_t(value, PyExc_OverflowError);\n        if (explicitlength < 0) {\n            if (!PyErr_Occurred())\n                PyErr_SetString(PyExc_ValueError, \"negative array length\");\n            return -1;\n        }\n        *pvalue = Py_None;\n        return explicitlength;\n    }\n}\n\nstatic int\nconvert_field_from_object(char *data, CFieldObject *cf, PyObject *value)\n{\n    data += cf->cf_offset;\n    if (cf->cf_bitshift >= 0)\n        return convert_from_object_bitfield(data, cf, value);\n    else\n        return convert_from_object(data, cf->cf_type, value);\n}\n\nstatic int\nconvert_vfield_from_object(char *data, CFieldObject *cf, PyObject *value,\n                           Py_ssize_t *optvarsize)\n{\n    /* a special case for var-sized C99 arrays */\n    if ((cf->cf_type->ct_flags & CT_ARRAY) && cf->cf_type->ct_size < 0) {\n        Py_ssize_t varsizelength = get_new_array_length(&value);\n        if (varsizelength < 0)\n            return -1;\n        if (optvarsize != NULL) {\n            /* in this mode, the only purpose of this function is to compute\n               the real size of the structure from a var-sized C99 array */\n            Py_ssize_t size, itemsize;\n            assert(data == NULL);\n            itemsize = cf->cf_type->ct_itemdescr->ct_size;\n            size = cf->cf_offset + itemsize * varsizelength;\n            if (size < 0 ||\n                ((size - cf->cf_offset) / itemsize) != varsizelength) {\n                PyErr_SetString(PyExc_OverflowError,\n                                \"array size would overflow a Py_ssize_t\");\n                return -1;\n            }\n            if (size > *optvarsize)\n                *optvarsize = size;\n            return 0;\n        }\n        /* if 'value' was only an integer, get_new_array_length() returns\n           it and convert 'value' to be None.  Detect if this was the case,\n           and if so, stop here, leaving the content uninitialized\n           (it should be zero-initialized from somewhere else). */\n        if (value == Py_None)\n            return 0;\n    }\n    if (optvarsize == NULL)\n        return convert_field_from_object(data, cf, value);\n    else\n        return 0;\n}\n\nstatic int\nconvert_array_from_object(char *data, CTypeDescrObject *ct, PyObject *init)\n{\n    /* used by convert_from_object(), and also to decode lists/tuples/unicodes\n       passed as function arguments.  'ct' is an CT_ARRAY in the first case\n       and a CT_POINTER in the second case. */\n    const char *expected;\n    CTypeDescrObject *ctitem = ct->ct_itemdescr;\n\n    if (PyList_Check(init) || PyTuple_Check(init)) {\n        PyObject **items;\n        Py_ssize_t i, n;\n        n = PySequence_Fast_GET_SIZE(init);\n        if (ct->ct_length >= 0 && n > ct->ct_length) {\n            PyErr_Format(PyExc_IndexError,\n                         \"too many initializers for '%s' (got %zd)\",\n                         ct->ct_name, n);\n            return -1;\n        }\n        items = PySequence_Fast_ITEMS(init);\n        for (i=0; i<n; i++) {\n            if (convert_from_object(data, ctitem, items[i]) < 0)\n                return -1;\n            data += ctitem->ct_size;\n        }\n        return 0;\n    }\n    else if ((ctitem->ct_flags & CT_PRIMITIVE_CHAR) ||\n             ((ctitem->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))\n              && (ctitem->ct_size == sizeof(char)))) {\n        if (ctitem->ct_size == sizeof(char)) {\n            char *srcdata;\n            Py_ssize_t n;\n            if (!PyBytes_Check(init)) {\n                expected = STR_OR_BYTES\" or list or tuple\";\n                goto cannot_convert;\n            }\n            n = PyBytes_GET_SIZE(init);\n            if (ct->ct_length >= 0 && n > ct->ct_length) {\n                PyErr_Format(PyExc_IndexError,\n                             \"initializer \"STR_OR_BYTES\" is too long for '%s' \"\n                             \"(got %zd characters)\", ct->ct_name, n);\n                return -1;\n            }\n            if (n != ct->ct_length)\n                n++;\n            srcdata = PyBytes_AS_STRING(init);\n            memcpy(data, srcdata, n);\n            return 0;\n        }\n#ifdef HAVE_WCHAR_H\n        else {\n            Py_ssize_t n;\n            if (!PyUnicode_Check(init)) {\n                expected = \"unicode or list or tuple\";\n                goto cannot_convert;\n            }\n            n = _my_PyUnicode_SizeAsWideChar(init);\n            if (ct->ct_length >= 0 && n > ct->ct_length) {\n                PyErr_Format(PyExc_IndexError,\n                             \"initializer unicode is too long for '%s' \"\n                             \"(got %zd characters)\", ct->ct_name, n);\n                return -1;\n            }\n            if (n != ct->ct_length)\n                n++;\n            _my_PyUnicode_AsWideChar(init, (wchar_t *)data, n);\n            return 0;\n        }\n#endif\n    }\n    else {\n        expected = \"list or tuple\";\n        goto cannot_convert;\n    }\n\n cannot_convert:\n    return _convert_error(init, ct->ct_name, expected);\n}\n\nstatic int\nconvert_struct_from_object(char *data, CTypeDescrObject *ct, PyObject *init,\n                           Py_ssize_t *optvarsize)\n{\n    const char *expected;\n\n    if (force_lazy_struct(ct) <= 0) {\n        if (!PyErr_Occurred())\n            PyErr_Format(PyExc_TypeError, \"'%s' is opaque\", ct->ct_name);\n        return -1;\n    }\n\n    if (ct->ct_flags & CT_UNION) {\n        Py_ssize_t n = PyObject_Size(init);\n        if (n < 0)\n            return -1;\n        if (n > 1) {\n            PyErr_Format(PyExc_ValueError,\n                         \"initializer for '%s': %zd items given, but \"\n                         \"only one supported (use a dict if needed)\",\n                         ct->ct_name, n);\n            return -1;\n        }\n    }\n    if (PyList_Check(init) || PyTuple_Check(init)) {\n        PyObject **items = PySequence_Fast_ITEMS(init);\n        Py_ssize_t i, n = PySequence_Fast_GET_SIZE(init);\n        CFieldObject *cf = (CFieldObject *)ct->ct_extra;\n\n        for (i=0; i<n; i++) {\n            if (cf == NULL) {\n                PyErr_Format(PyExc_ValueError,\n                             \"too many initializers for '%s' (got %zd)\",\n                             ct->ct_name, n);\n                return -1;\n            }\n            if (convert_vfield_from_object(data, cf, items[i], optvarsize) < 0)\n                return -1;\n            cf = cf->cf_next;\n        }\n        return 0;\n    }\n    if (PyDict_Check(init)) {\n        PyObject *d_key, *d_value;\n        Py_ssize_t i = 0;\n        CFieldObject *cf;\n\n        while (PyDict_Next(init, &i, &d_key, &d_value)) {\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, d_key);\n            if (cf == NULL) {\n                PyErr_SetObject(PyExc_KeyError, d_key);\n                return -1;\n            }\n            if (convert_vfield_from_object(data, cf, d_value, optvarsize) < 0)\n                return -1;\n        }\n        return 0;\n    }\n    expected = optvarsize == NULL ? \"list or tuple or dict or struct-cdata\"\n                                  : \"list or tuple or dict\";\n    return _convert_error(init, ct->ct_name, expected);\n}\n\n#ifdef __GNUC__\n# if __GNUC__ >= 4\n/* Don't go inlining this huge function.  Needed because occasionally\n   it gets inlined in places where is causes a warning: call to\n   __builtin___memcpy_chk will always overflow destination buffer\n   (which is places where the 'ct' should never represent such a large\n   primitive type anyway). */\n__attribute__((noinline))\n# endif\n#endif\nstatic int\nconvert_from_object(char *data, CTypeDescrObject *ct, PyObject *init)\n{\n    const char *expected;\n    char buf[sizeof(PY_LONG_LONG)];\n\n    /*if (ct->ct_size > 0)*/\n        /*WRITE(data, ct->ct_size)*/\n\n    if (ct->ct_flags & CT_ARRAY) {\n        return convert_array_from_object(data, ct, init);\n    }\n    if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        char *ptrdata;\n        CTypeDescrObject *ctinit;\n\n        if (!CData_Check(init)) {\n            expected = \"cdata pointer\";\n            goto cannot_convert;\n        }\n        ctinit = ((CDataObject *)init)->c_type;\n        if (!(ctinit->ct_flags & (CT_POINTER|CT_FUNCTIONPTR))) {\n            if (ctinit->ct_flags & CT_ARRAY)\n                ctinit = (CTypeDescrObject *)ctinit->ct_stuff;\n            else {\n                expected = \"pointer or array\";\n                goto cannot_convert;\n            }\n        }\n        if (ctinit != ct) {\n            if ((ct->ct_flags & CT_CAST_ANYTHING) ||\n                (ctinit->ct_flags & CT_CAST_ANYTHING))\n                ;   /* accept void* or char* as either source or target */\n            else {\n                expected = \"pointer to same type\";\n                goto cannot_convert;\n            }\n        }\n        ptrdata = ((CDataObject *)init)->c_data;\n\n        *(char **)data = ptrdata;\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        PY_LONG_LONG value = _my_PyLong_AsLongLong(init);\n        if (value == -1 && PyErr_Occurred())\n            return -1;\n        write_raw_integer_data(buf, value, ct->ct_size);\n        if (value != read_raw_signed_data(buf, ct->ct_size))\n            goto overflow;\n        write_raw_integer_data(data, value, ct->ct_size);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        unsigned PY_LONG_LONG value = _my_PyLong_AsUnsignedLongLong(init, 1);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return -1;\n        if (ct->ct_flags & CT_IS_BOOL)\n            if (value & ~1)      /* value != 0 && value != 1 */\n                goto overflow;\n        write_raw_integer_data(buf, value, ct->ct_size);\n        if (value != read_raw_unsigned_data(buf, ct->ct_size))\n            goto overflow;\n        write_raw_integer_data(data, value, ct->ct_size);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        double value;\n        if ((ct->ct_flags & CT_IS_LONGDOUBLE) &&\n                CData_Check(init) &&\n                (((CDataObject *)init)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n            long double lvalue;\n            char *initdata = ((CDataObject *)init)->c_data;\n            /*READ(initdata, sizeof(long double))*/\n            lvalue = read_raw_longdouble_data(initdata);\n            write_raw_longdouble_data(data, lvalue);\n            return 0;\n        }\n        value = PyFloat_AsDouble(init);\n        if (value == -1.0 && PyErr_Occurred())\n            return -1;\n        if (!(ct->ct_flags & CT_IS_LONGDOUBLE))\n            write_raw_float_data(data, value, ct->ct_size);\n        else\n            write_raw_longdouble_data(data, (long double)value);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_CHAR) {\n        if (ct->ct_size == sizeof(char)) {\n            int res = _convert_to_char(init);\n            if (res < 0)\n                return -1;\n            data[0] = res;\n            return 0;\n        }\n#ifdef HAVE_WCHAR_H\n        else {\n            wchar_t res = _convert_to_wchar_t(init);\n            if (res == (wchar_t)-1 && PyErr_Occurred())\n                return -1;\n            *(wchar_t *)data = res;\n            return 0;\n        }\n#endif\n    }\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n\n        if (CData_Check(init)) {\n            if (((CDataObject *)init)->c_type == ct && ct->ct_size >= 0) {\n                memcpy(data, ((CDataObject *)init)->c_data, ct->ct_size);\n                return 0;\n            }\n        }\n        return convert_struct_from_object(data, ct, init, NULL);\n    }\n    PyErr_Format(PyExc_SystemError,\n                 \"convert_from_object: '%s'\", ct->ct_name);\n    return -1;\n\n overflow:\n    return _convert_overflow(init, ct->ct_name);\n\n cannot_convert:\n    return _convert_error(init, ct->ct_name, expected);\n}\n\nstatic int\nconvert_from_object_bitfield(char *data, CFieldObject *cf, PyObject *init)\n{\n    CTypeDescrObject *ct = cf->cf_type;\n    PY_LONG_LONG fmin, fmax, value = PyLong_AsLongLong(init);\n    unsigned PY_LONG_LONG rawfielddata, rawvalue, rawmask;\n    if (value == -1 && PyErr_Occurred())\n        return -1;\n\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        fmin = -(1LL << (cf->cf_bitsize-1));\n        fmax = (1LL << (cf->cf_bitsize-1)) - 1LL;\n        if (fmax == 0)\n            fmax = 1;    /* special case to let \"int x:1\" receive \"1\" */\n    }\n    else {\n        fmin = 0LL;\n        fmax = (PY_LONG_LONG)((1ULL << cf->cf_bitsize) - 1ULL);\n    }\n    if (value < fmin || value > fmax) {\n        /* phew, PyErr_Format does not support \"%lld\" in Python 2.6 */\n        PyObject *svalue = NULL, *sfmin = NULL, *sfmax = NULL;\n        PyObject *lfmin = NULL, *lfmax = NULL;\n        svalue = PyObject_Str(init);\n        if (svalue == NULL) goto skip;\n        lfmin = PyLong_FromLongLong(fmin);\n        if (lfmin == NULL) goto skip;\n        sfmin = PyObject_Str(lfmin);\n        if (sfmin == NULL) goto skip;\n        lfmax = PyLong_FromLongLong(fmax);\n        if (lfmax == NULL) goto skip;\n        sfmax = PyObject_Str(lfmax);\n        if (sfmax == NULL) goto skip;\n        PyErr_Format(PyExc_OverflowError,\n                     \"value %s outside the range allowed by the \"\n                     \"bit field width: %s <= x <= %s\",\n                     PyText_AS_UTF8(svalue),\n                     PyText_AS_UTF8(sfmin),\n                     PyText_AS_UTF8(sfmax));\n       skip:\n        Py_XDECREF(svalue);\n        Py_XDECREF(sfmin);\n        Py_XDECREF(sfmax);\n        Py_XDECREF(lfmin);\n        Py_XDECREF(lfmax);\n        return -1;\n    }\n\n    rawmask = ((1ULL << cf->cf_bitsize) - 1ULL) << cf->cf_bitshift;\n    rawvalue = ((unsigned PY_LONG_LONG)value) << cf->cf_bitshift;\n    /*WRITE(data, ct->ct_size)*/\n    rawfielddata = read_raw_unsigned_data(data, ct->ct_size);\n    rawfielddata = (rawfielddata & ~rawmask) | (rawvalue & rawmask);\n    write_raw_integer_data(data, rawfielddata, ct->ct_size);\n    return 0;\n}\n\nstatic Py_ssize_t\nget_array_length(CDataObject *cd)\n{\n    if (cd->c_type->ct_length < 0)\n        return ((CDataObject_own_length *)cd)->length;\n    else\n        return cd->c_type->ct_length;\n}\n\nstatic int\nget_alignment(CTypeDescrObject *ct)\n{\n    int align;\n retry:\n    if ((ct->ct_flags & (CT_PRIMITIVE_ANY|CT_STRUCT|CT_UNION)) &&\n        !(ct->ct_flags & CT_IS_OPAQUE)) {\n        align = ct->ct_length;\n        if (align == -1 && (ct->ct_flags & CT_LAZY_FIELD_LIST)) {\n            force_lazy_struct(ct);\n            align = ct->ct_length;\n        }\n    }\n    else if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        struct aligncheck_ptr { char x; char *y; };\n        align = offsetof(struct aligncheck_ptr, y);\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        ct = ct->ct_itemdescr;\n        goto retry;\n    }\n    else {\n        PyErr_Format(PyExc_ValueError, \"ctype '%s' is of unknown alignment\",\n                     ct->ct_name);\n        return -1;\n    }\n\n    if ((align < 1) || (align & (align-1))) {\n        PyErr_Format(PyExc_SystemError,\n                     \"found for ctype '%s' bogus alignment '%d'\",\n                     ct->ct_name, align);\n        return -1;\n    }\n    return align;\n}\n\nstatic void cdata_dealloc(CDataObject *cd)\n{\n    if (cd->c_weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) cd);\n\n    Py_DECREF(cd->c_type);\n#ifndef CFFI_MEM_LEAK     /* never release anything, tests only */\n    Py_TYPE(cd)->tp_free((PyObject *)cd);\n#endif\n}\n\nstatic void cdataowning_dealloc(CDataObject *cd)\n{\n    assert(!(cd->c_type->ct_flags & (CT_IS_VOID_PTR | CT_FUNCTIONPTR)));\n\n    if (cd->c_type->ct_flags & CT_IS_PTR_TO_OWNED) {\n        Py_DECREF(((CDataObject_own_structptr *)cd)->structobj);\n    }\n#if defined(CFFI_MEM_DEBUG) || defined(CFFI_MEM_LEAK)\n    if (cd->c_type->ct_flags & (CT_PRIMITIVE_ANY | CT_STRUCT | CT_UNION)) {\n        assert(cd->c_type->ct_size >= 0);\n        memset(cd->c_data, 0xDD, cd->c_type->ct_size);\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        Py_ssize_t x = get_array_length(cd);\n        assert(x >= 0);\n        x *= cd->c_type->ct_itemdescr->ct_size;\n        assert(x >= 0);\n        memset(cd->c_data, 0xDD, x);\n    }\n#endif\n    cdata_dealloc(cd);\n}\n\nstatic void cdataowninggc_dealloc(CDataObject *cd)\n{\n    assert(!(cd->c_type->ct_flags & (CT_IS_PTR_TO_OWNED |\n                                     CT_PRIMITIVE_ANY |\n                                     CT_STRUCT | CT_UNION)));\n    PyObject_GC_UnTrack(cd);\n\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = (PyObject *)(cd->c_data + 42);\n        Py_DECREF(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = (ffi_closure *)cd->c_data;\n        PyObject *args = (PyObject *)(closure->user_data);\n        Py_XDECREF(args);\n        cffi_closure_free(closure);\n    }\n    else if (cd->c_type->ct_flags & CT_IS_UNSIZED_CHAR_A) {  /* from_buffer */\n        Py_buffer *view = ((CDataObject_owngc_frombuf *)cd)->bufferview;\n        PyBuffer_Release(view);\n        PyObject_Free(view);\n    }\n    cdata_dealloc(cd);\n}\n\nstatic int cdataowninggc_traverse(CDataObject *cd, visitproc visit, void *arg)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = (PyObject *)(cd->c_data + 42);\n        Py_VISIT(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = (ffi_closure *)cd->c_data;\n        PyObject *args = (PyObject *)(closure->user_data);\n        Py_VISIT(args);\n    }\n    else if (cd->c_type->ct_flags & CT_IS_UNSIZED_CHAR_A) {  /* from_buffer */\n        Py_buffer *view = ((CDataObject_owngc_frombuf *)cd)->bufferview;\n        Py_VISIT(view->obj);\n    }\n    return 0;\n}\n\nstatic int cdataowninggc_clear(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = (PyObject *)(cd->c_data + 42);\n        Py_INCREF(Py_None);\n        cd->c_data = ((char *)Py_None) - 42;\n        Py_DECREF(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = (ffi_closure *)cd->c_data;\n        PyObject *args = (PyObject *)(closure->user_data);\n        closure->user_data = NULL;\n        Py_XDECREF(args);\n    }\n    else if (cd->c_type->ct_flags & CT_IS_UNSIZED_CHAR_A) {  /* from_buffer */\n        Py_buffer *view = ((CDataObject_owngc_frombuf *)cd)->bufferview;\n        PyBuffer_Release(view);\n    }\n    return 0;\n}\n\nstatic PyObject *cdata_float(CDataObject *cd);  /*forward*/\n\nstatic PyObject *convert_cdata_to_enum_string(CDataObject *cd, int both)\n{\n    PyObject *d_key, *d_value;\n    CTypeDescrObject *ct = cd->c_type;\n\n    assert(ct->ct_flags & CT_IS_ENUM);\n    d_key = convert_to_object(cd->c_data, ct);\n    if (d_key == NULL)\n        return NULL;\n\n    d_value = PyDict_GetItem(PyTuple_GET_ITEM(ct->ct_stuff, 1), d_key);\n    if (d_value != NULL) {\n        if (both) {\n            PyObject *o = PyObject_Str(d_key);\n            if (o == NULL)\n                d_value = NULL;\n            else {\n                d_value = PyText_FromFormat(\"%s: %s\",\n                                            PyText_AS_UTF8(o),\n                                            PyText_AS_UTF8(d_value));\n                Py_DECREF(o);\n            }\n        }\n        else\n            Py_INCREF(d_value);\n    }\n    else\n        d_value = PyObject_Str(d_key);\n    Py_DECREF(d_key);\n    return d_value;\n}\n\nstatic PyObject *cdata_repr(CDataObject *cd)\n{\n    char *extra;\n    PyObject *result, *s;\n\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_ANY) {\n        if (cd->c_type->ct_flags & CT_IS_ENUM) {\n            s = convert_cdata_to_enum_string(cd, 1);\n        }\n        else if (cd->c_type->ct_flags & CT_IS_LONGDOUBLE) {\n            long double lvalue;\n            char buffer[128];   /* big enough */\n            /*READ(cd->c_data, sizeof(long double)*/\n            lvalue = read_raw_longdouble_data(cd->c_data);\n            sprintf(buffer, \"%LE\", lvalue);\n            s = PyText_FromString(buffer);\n        }\n        else {\n            PyObject *o = convert_to_object(cd->c_data, cd->c_type);\n            if (o == NULL)\n                return NULL;\n            s = PyObject_Repr(o);\n            Py_DECREF(o);\n        }\n    }\n    else if ((cd->c_type->ct_flags & CT_ARRAY) && cd->c_type->ct_length < 0) {\n        s = PyText_FromFormat(\"sliced length %zd\", get_array_length(cd));\n    }\n    else {\n        if (cd->c_data != NULL) {\n            s = PyText_FromFormat(\"%p\", cd->c_data);\n        }\n        else\n            s = PyText_FromString(\"NULL\");\n    }\n    if (s == NULL)\n        return NULL;\n    /* it's slightly confusing to get \"<cdata 'struct foo' 0x...>\" because the\n       struct foo is not owned.  Trying to make it clearer, write in this\n       case \"<cdata 'struct foo &' 0x...>\". */\n    if (cd->c_type->ct_flags & (CT_STRUCT|CT_UNION))\n        extra = \" &\";\n    else\n        extra = \"\";\n    result = PyText_FromFormat(\"<cdata '%s%s' %s>\",\n                               cd->c_type->ct_name, extra,\n                               PyText_AsUTF8(s));\n    Py_DECREF(s);\n    return result;\n}\n\nstatic PyObject *_cdata_repr2(CDataObject *cd, char *text, PyObject *x)\n{\n    PyObject *res, *s = PyObject_Repr(x);\n    if (s == NULL)\n        return NULL;\n    res = PyText_FromFormat(\"<cdata '%s' %s %s>\",\n                            cd->c_type->ct_name, text, PyText_AsUTF8(s));\n    Py_DECREF(s);\n    return res;\n}\n\nstatic PyObject *cdataowning_repr(CDataObject *cd)\n{\n    Py_ssize_t size;\n    if (cd->c_type->ct_flags & CT_POINTER)\n        size = cd->c_type->ct_itemdescr->ct_size;\n    else if (cd->c_type->ct_flags & CT_ARRAY)\n        size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n    else\n        size = cd->c_type->ct_size;\n\n    return PyText_FromFormat(\"<cdata '%s' owning %zd bytes>\",\n                             cd->c_type->ct_name, size);\n}\n\nstatic PyObject *cdataowninggc_repr(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = (PyObject *)(cd->c_data + 42);\n        return _cdata_repr2(cd, \"handle to\", x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        PyObject *args = (PyObject *)((ffi_closure *)cd->c_data)->user_data;\n        if (args == NULL)\n            return cdata_repr(cd);\n        else\n            return _cdata_repr2(cd, \"calling\", PyTuple_GET_ITEM(args, 1));\n    }\n    else if (cd->c_type->ct_flags & CT_IS_UNSIZED_CHAR_A) {  /* from_buffer */\n        Py_buffer *view = ((CDataObject_owngc_frombuf *)cd)->bufferview;\n        Py_ssize_t buflen = get_array_length(cd);\n        return PyText_FromFormat(\n            \"<cdata '%s' buffer len %zd from '%.200s' object>\",\n            cd->c_type->ct_name,\n            buflen,\n            view->obj ? Py_TYPE(view->obj)->tp_name : \"(null)\");\n    }\n    return cdataowning_repr(cd);\n}\n\nstatic int cdata_nonzero(CDataObject *cd)\n{\n    return cd->c_data != NULL;\n}\n\nstatic PyObject *cdata_int(CDataObject *cd)\n{\n    if ((cd->c_type->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_FITS_LONG))\n                             == (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_FITS_LONG)) {\n        /* this case is to handle enums, but also serves as a slight\n           performance improvement for some other primitive types */\n        long value;\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        value = (long)read_raw_signed_data(cd->c_data, cd->c_type->ct_size);\n        return PyInt_FromLong(value);\n    }\n    if (cd->c_type->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED)) {\n        return convert_to_object(cd->c_data, cd->c_type);\n    }\n    else if (cd->c_type->ct_flags & CT_PRIMITIVE_CHAR) {\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        if (cd->c_type->ct_size == sizeof(char))\n            return PyInt_FromLong((unsigned char)cd->c_data[0]);\n#ifdef HAVE_WCHAR_H\n        else\n            return PyInt_FromLong((long)*(wchar_t *)cd->c_data);\n#endif\n    }\n    else if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n        PyObject *o = cdata_float(cd);\n#if PY_MAJOR_VERSION < 3\n        PyObject *r = o ? PyNumber_Int(o) : NULL;\n#else\n        PyObject *r = o ? PyNumber_Long(o) : NULL;\n#endif\n        Py_XDECREF(o);\n        return r;\n    }\n    PyErr_Format(PyExc_TypeError, \"int() not supported on cdata '%s'\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\n#if PY_MAJOR_VERSION < 3\nstatic PyObject *cdata_long(CDataObject *cd)\n{\n    PyObject *res = cdata_int(cd);\n    if (res != NULL && PyInt_CheckExact(res)) {\n        PyObject *o = PyLong_FromLong(PyInt_AS_LONG(res));\n        Py_DECREF(res);\n        res = o;\n    }\n    return res;\n}\n#endif\n\nstatic PyObject *cdata_float(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n        double value;\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        if (!(cd->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n            value = read_raw_float_data(cd->c_data, cd->c_type->ct_size);\n        }\n        else {\n            value = (double)read_raw_longdouble_data(cd->c_data);\n        }\n        return PyFloat_FromDouble(value);\n    }\n    PyErr_Format(PyExc_TypeError, \"float() not supported on cdata '%s'\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\nstatic PyObject *cdata_richcompare(PyObject *v, PyObject *w, int op)\n{\n    int res;\n    PyObject *pyres;\n    char *v_cdata, *w_cdata;\n\n    assert(CData_Check(v));\n    if (!CData_Check(w)) {\n        pyres = Py_NotImplemented;\n        goto done;\n    }\n\n    if ((op != Py_EQ && op != Py_NE) &&\n        ((((CDataObject *)v)->c_type->ct_flags & CT_PRIMITIVE_ANY) ||\n         (((CDataObject *)w)->c_type->ct_flags & CT_PRIMITIVE_ANY)))\n        goto Error;\n\n    v_cdata = ((CDataObject *)v)->c_data;\n    w_cdata = ((CDataObject *)w)->c_data;\n\n    switch (op) {\n    case Py_EQ: res = (v_cdata == w_cdata); break;\n    case Py_NE: res = (v_cdata != w_cdata); break;\n    case Py_LT: res = (v_cdata <  w_cdata); break;\n    case Py_LE: res = (v_cdata <= w_cdata); break;\n    case Py_GT: res = (v_cdata >  w_cdata); break;\n    case Py_GE: res = (v_cdata >= w_cdata); break;\n    default: res = -1;\n    }\n    pyres = res ? Py_True : Py_False;\n done:\n    Py_INCREF(pyres);\n    return pyres;\n\n Error:\n    PyErr_SetString(PyExc_TypeError,\n                    \"cannot do comparison on a primitive cdata\");\n    return NULL;\n}\n\nstatic long cdata_hash(CDataObject *cd)\n{\n    return _Py_HashPointer(cd->c_data);\n}\n\nstatic Py_ssize_t\ncdata_length(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_ARRAY) {\n        return get_array_length(cd);\n    }\n    PyErr_Format(PyExc_TypeError, \"cdata of type '%s' has no len()\",\n                 cd->c_type->ct_name);\n    return -1;\n}\n\nstatic char *\n_cdata_get_indexed_ptr(CDataObject *cd, PyObject *key)\n{\n    Py_ssize_t i = PyNumber_AsSsize_t(key, PyExc_IndexError);\n    if (i == -1 && PyErr_Occurred())\n        return NULL;\n\n    if (cd->c_type->ct_flags & CT_POINTER) {\n        if (CDataOwn_Check(cd) && i != 0) {\n            PyErr_Format(PyExc_IndexError,\n                         \"cdata '%s' can only be indexed by 0\",\n                         cd->c_type->ct_name);\n            return NULL;\n        }\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        if (i < 0) {\n            PyErr_SetString(PyExc_IndexError,\n                            \"negative index not supported\");\n            return NULL;\n        }\n        if (i >= get_array_length(cd)) {\n            PyErr_Format(PyExc_IndexError,\n                         \"index too large for cdata '%s' (expected %zd < %zd)\",\n                         cd->c_type->ct_name,\n                         i, get_array_length(cd));\n            return NULL;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cdata of type '%s' cannot be indexed\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    return cd->c_data + i * cd->c_type->ct_itemdescr->ct_size;\n}\n\nstatic PyObject *\nnew_array_type(CTypeDescrObject *ctptr, Py_ssize_t length);   /* forward */\n\nstatic CTypeDescrObject *\n_cdata_getslicearg(CDataObject *cd, PySliceObject *slice, Py_ssize_t bounds[])\n{\n    Py_ssize_t start, stop;\n    CTypeDescrObject *ct;\n\n    start = PyInt_AsSsize_t(slice->start);\n    if (start == -1 && PyErr_Occurred()) {\n        if (slice->start == Py_None)\n            PyErr_SetString(PyExc_IndexError, \"slice start must be specified\");\n        return NULL;\n    }\n    stop = PyInt_AsSsize_t(slice->stop);\n    if (stop == -1 && PyErr_Occurred()) {\n        if (slice->stop == Py_None)\n            PyErr_SetString(PyExc_IndexError, \"slice stop must be specified\");\n        return NULL;\n    }\n    if (slice->step != Py_None) {\n        PyErr_SetString(PyExc_IndexError, \"slice with step not supported\");\n        return NULL;\n    }\n    if (start > stop) {\n        PyErr_SetString(PyExc_IndexError, \"slice start > stop\");\n        return NULL;\n    }\n\n    ct = cd->c_type;\n    if (ct->ct_flags & CT_ARRAY) {\n        if (start < 0) {\n            PyErr_SetString(PyExc_IndexError,\n                            \"negative index not supported\");\n            return NULL;\n        }\n        if (stop > get_array_length(cd)) {\n            PyErr_Format(PyExc_IndexError,\n                         \"index too large (expected %zd <= %zd)\",\n                         stop, get_array_length(cd));\n            return NULL;\n        }\n        ct = (CTypeDescrObject *)ct->ct_stuff;\n    }\n    else if (!(ct->ct_flags & CT_POINTER)) {\n        PyErr_Format(PyExc_TypeError, \"cdata of type '%s' cannot be indexed\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n    bounds[0] = start;\n    bounds[1] = stop - start;\n    return ct;\n}\n\nstatic PyObject *\ncdata_slice(CDataObject *cd, PySliceObject *slice)\n{\n    Py_ssize_t bounds[2];\n    CDataObject_own_length *scd;\n    CTypeDescrObject *ct = _cdata_getslicearg(cd, slice, bounds);\n    if (ct == NULL)\n        return NULL;\n\n    if (ct->ct_stuff == NULL) {\n        ct->ct_stuff = new_array_type(ct, -1);\n        if (ct->ct_stuff == NULL)\n            return NULL;\n    }\n    ct = (CTypeDescrObject *)ct->ct_stuff;\n\n    scd = (CDataObject_own_length *)PyObject_Malloc(\n              offsetof(CDataObject_own_length, alignment));\n    if (PyObject_Init((PyObject *)scd, &CData_Type) == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    scd->head.c_type = ct;\n    scd->head.c_data = cd->c_data + ct->ct_itemdescr->ct_size * bounds[0];\n    scd->head.c_weakreflist = NULL;\n    scd->length = bounds[1];\n    return (PyObject *)scd;\n}\n\nstatic int\ncdata_ass_slice(CDataObject *cd, PySliceObject *slice, PyObject *v)\n{\n    Py_ssize_t bounds[2], i, length, itemsize;\n    PyObject *it, *item;\n    PyObject *(*iternext)(PyObject *);\n    char *cdata;\n    int err;\n    CTypeDescrObject *ct = _cdata_getslicearg(cd, slice, bounds);\n    if (ct == NULL)\n        return -1;\n    ct = ct->ct_itemdescr;\n    itemsize = ct->ct_size;\n    cdata = cd->c_data + itemsize * bounds[0];\n    length = bounds[1];\n\n    if (CData_Check(v)) {\n        CTypeDescrObject *ctv = ((CDataObject *)v)->c_type;\n        if ((ctv->ct_flags & CT_ARRAY) && (ctv->ct_itemdescr == ct) &&\n            (get_array_length((CDataObject *)v) == length)) {\n            /* fast path: copying from exactly the correct type */\n            memmove(cdata, ((CDataObject *)v)->c_data, itemsize * length);\n            return 0;\n        }\n    }\n\n    /* A fast path for <char[]>[0:N] = b\"somestring\", which also adds\n       support for Python 3: otherwise, you get integers while enumerating\n       the string, and you can't set them to characters :-/\n    */\n    if (PyBytes_Check(v) && (ct->ct_flags & CT_PRIMITIVE_CHAR)\n            && itemsize == sizeof(char)) {\n        if (PyBytes_GET_SIZE(v) != length) {\n            PyErr_Format(PyExc_ValueError,\n                         \"need a string of length %zd, got %zd\",\n                         length, PyBytes_GET_SIZE(v));\n            return -1;\n        }\n        memcpy(cdata, PyBytes_AS_STRING(v), length);\n        return 0;\n    }\n\n    it = PyObject_GetIter(v);\n    if (it == NULL)\n        return -1;\n    iternext = *it->ob_type->tp_iternext;\n\n    for (i = 0; i < length; i++) {\n        item = iternext(it);\n        if (item == NULL) {\n            if (!PyErr_Occurred())\n                PyErr_Format(PyExc_ValueError,\n                             \"need %zd values to unpack, got %zd\",\n                             length, i);\n            goto error;\n        }\n        err = convert_from_object(cdata, ct, item);\n        Py_DECREF(item);\n        if (err < 0)\n            goto error;\n\n        cdata += itemsize;\n    }\n    item = iternext(it);\n    if (item != NULL) {\n        Py_DECREF(item);\n        PyErr_Format(PyExc_ValueError,\n                     \"got more than %zd values to unpack\", length);\n    }\n error:\n    Py_DECREF(it);\n    return PyErr_Occurred() ? -1 : 0;\n}\n\nstatic PyObject *\ncdataowning_subscript(CDataObject *cd, PyObject *key)\n{\n    char *c;\n    if (PySlice_Check(key))\n        return cdata_slice(cd, (PySliceObject *)key);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    /* use 'mp_subscript' instead of 'sq_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return NULL;\n\n    if (cd->c_type->ct_flags & CT_IS_PTR_TO_OWNED) {\n        PyObject *res = ((CDataObject_own_structptr *)cd)->structobj;\n        Py_INCREF(res);\n        return res;\n    }\n    else {\n        return convert_to_object(c, cd->c_type->ct_itemdescr);\n    }\n}\n\nstatic PyObject *\ncdata_subscript(CDataObject *cd, PyObject *key)\n{\n    char *c;\n    if (PySlice_Check(key))\n        return cdata_slice(cd, (PySliceObject *)key);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    /* use 'mp_subscript' instead of 'sq_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return NULL;\n    return convert_to_object(c, cd->c_type->ct_itemdescr);\n}\n\nstatic int\ncdata_ass_sub(CDataObject *cd, PyObject *key, PyObject *v)\n{\n    char *c;\n    CTypeDescrObject *ctitem;\n    if (PySlice_Check(key))\n        return cdata_ass_slice(cd, (PySliceObject *)key, v);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    ctitem = cd->c_type->ct_itemdescr;\n    /* use 'mp_ass_subscript' instead of 'sq_ass_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return -1;\n    if (v == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"'del x[n]' not supported for cdata objects\");\n        return -1;\n    }\n    return convert_from_object(c, ctitem, v);\n}\n\nstatic PyObject *\n_cdata_add_or_sub(PyObject *v, PyObject *w, int sign)\n{\n    Py_ssize_t i, itemsize;\n    CDataObject *cd;\n    CTypeDescrObject *ctptr;\n\n    if (!CData_Check(v)) {\n        PyObject *swap;\n        assert(CData_Check(w));\n        if (sign != 1)\n            goto not_implemented;\n        swap = v;\n        v = w;\n        w = swap;\n    }\n\n    i = PyNumber_AsSsize_t(w, PyExc_OverflowError);\n    if (i == -1 && PyErr_Occurred())\n        return NULL;\n    i *= sign;\n\n    cd = (CDataObject *)v;\n    if (cd->c_type->ct_flags & CT_POINTER)\n        ctptr = cd->c_type;\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        ctptr = (CTypeDescrObject *)cd->c_type->ct_stuff;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cannot add a cdata '%s' and a number\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    itemsize = ctptr->ct_itemdescr->ct_size;\n    if (itemsize < 0) {\n        if (ctptr->ct_flags & CT_IS_VOID_PTR) {\n            itemsize = 1;\n        }\n        else {\n            PyErr_Format(PyExc_TypeError,\n                         \"ctype '%s' points to items of unknown size\",\n                         cd->c_type->ct_name);\n            return NULL;\n        }\n    }\n    return new_simple_cdata(cd->c_data + i * itemsize, ctptr);\n\n not_implemented:\n    Py_INCREF(Py_NotImplemented);\n    return Py_NotImplemented;\n}\n\nstatic PyObject *\ncdata_add(PyObject *v, PyObject *w)\n{\n    return _cdata_add_or_sub(v, w, +1);\n}\n\nstatic PyObject *\ncdata_sub(PyObject *v, PyObject *w)\n{\n    if (CData_Check(v) && CData_Check(w)) {\n        CDataObject *cdv = (CDataObject *)v;\n        CDataObject *cdw = (CDataObject *)w;\n        CTypeDescrObject *ct = cdw->c_type;\n        Py_ssize_t diff, itemsize;\n\n        if (ct->ct_flags & CT_ARRAY)     /* ptr_to_T - array_of_T: ok */\n            ct = (CTypeDescrObject *)ct->ct_stuff;\n\n        if (ct != cdv->c_type || !(ct->ct_flags & CT_POINTER) ||\n                (ct->ct_itemdescr->ct_size <= 0 &&\n                 !(ct->ct_flags & CT_IS_VOID_PTR))) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot subtract cdata '%s' and cdata '%s'\",\n                         cdv->c_type->ct_name, ct->ct_name);\n            return NULL;\n        }\n        itemsize = ct->ct_itemdescr->ct_size;\n        if (itemsize <= 0) itemsize = 1;\n        diff = (cdv->c_data - cdw->c_data) / itemsize;\n#if PY_MAJOR_VERSION < 3\n        return PyInt_FromSsize_t(diff);\n#else\n        return PyLong_FromSsize_t(diff);\n#endif\n    }\n\n    return _cdata_add_or_sub(v, w, -1);\n}\n\nstatic PyObject *\ncdata_getattro(CDataObject *cd, PyObject *attr)\n{\n    CFieldObject *cf;\n    CTypeDescrObject *ct = cd->c_type;\n\n    if (ct->ct_flags & CT_POINTER)\n        ct = ct->ct_itemdescr;\n\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n        switch (force_lazy_struct(ct)) {\n        case 1:\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, attr);\n            if (cf != NULL) {\n                /* read the field 'cf' */\n                char *data = cd->c_data + cf->cf_offset;\n                if (cf->cf_bitshift == BS_REGULAR)\n                    return convert_to_object(data, cf->cf_type);\n                else if (cf->cf_bitshift == BS_EMPTY_ARRAY)\n                    return new_simple_cdata(data,\n                        (CTypeDescrObject *)cf->cf_type->ct_stuff);\n                else\n                    return convert_to_object_bitfield(data, cf);\n            }\n            break;\n        case -1:\n            return NULL;\n        default:\n            break;\n        }\n    }\n    return PyObject_GenericGetAttr((PyObject *)cd, attr);\n}\n\nstatic int\ncdata_setattro(CDataObject *cd, PyObject *attr, PyObject *value)\n{\n    CFieldObject *cf;\n    CTypeDescrObject *ct = cd->c_type;\n\n    if (ct->ct_flags & CT_POINTER)\n        ct = ct->ct_itemdescr;\n\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n        switch (force_lazy_struct(ct)) {\n        case 1:\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, attr);\n            if (cf != NULL) {\n                /* write the field 'cf' */\n                if (value != NULL) {\n                    return convert_field_from_object(cd->c_data, cf, value);\n                }\n                else {\n                    PyErr_SetString(PyExc_AttributeError,\n                                    \"cannot delete struct field\");\n                    return -1;\n                }\n            }\n            break;\n        case -1:\n            return -1;\n        default:\n            break;\n        }\n    }\n    return PyObject_GenericSetAttr((PyObject *)cd, attr, value);\n}\n\nstatic PyObject *\nconvert_struct_to_owning_object(char *data, CTypeDescrObject *ct); /*forward*/\n\nstatic cif_description_t *\nfb_prepare_cif(PyObject *fargs, CTypeDescrObject *, ffi_abi);      /*forward*/\n\nstatic PyObject *new_primitive_type(const char *name);             /*forward*/\n\nstatic CTypeDescrObject *_get_ct_int(void)\n{\n    static CTypeDescrObject *ct_int = NULL;\n    if (ct_int == NULL) {\n        ct_int = (CTypeDescrObject *)new_primitive_type(\"int\");\n    }\n    return ct_int;\n}\n\nstatic Py_ssize_t\n_prepare_pointer_call_argument(CTypeDescrObject *ctptr, PyObject *init,\n                               char **output_data)\n{\n    /* 'ctptr' is here a pointer type 'ITEM *'.  Accept as argument an\n       initializer for an array 'ITEM[]'.  This includes the case of\n       passing a Python byte string to a 'char *' argument.\n\n       This function returns -1 if an error occurred,\n       0 if conversion succeeded (into *output_data),\n       or N > 0 if conversion would require N bytes of storage.\n    */\n    Py_ssize_t length, datasize;\n    CTypeDescrObject *ctitem;\n\n    if (CData_Check(init))\n        goto convert_default;\n\n    ctitem = ctptr->ct_itemdescr;\n    /* XXX some code duplication, how to avoid it? */\n    if (PyBytes_Check(init)) {\n        /* from a string: just returning the string here is fine.\n           We assume that the C code won't modify the 'char *' data. */\n        if ((ctptr->ct_flags & CT_CAST_ANYTHING) ||\n            ((ctitem->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))\n             && (ctitem->ct_size == sizeof(char)))) {\n#if defined(CFFI_MEM_DEBUG) || defined(CFFI_MEM_LEAK)\n            length = PyBytes_GET_SIZE(init) + 1;\n#else\n            *output_data = PyBytes_AS_STRING(init);\n            return 0;\n#endif\n        }\n        else\n            goto convert_default;\n    }\n    else if (PyList_Check(init) || PyTuple_Check(init)) {\n        length = PySequence_Fast_GET_SIZE(init);\n    }\n    else if (PyUnicode_Check(init)) {\n        /* from a unicode, we add the null terminator */\n        length = _my_PyUnicode_SizeAsWideChar(init) + 1;\n    }\n    else if ((ctitem->ct_flags & CT_IS_FILE) && PyFile_Check(init)) {\n        *output_data = (char *)PyFile_AsFile(init);\n        if (*output_data == NULL && PyErr_Occurred())\n            return -1;\n        return 0;\n    }\n    else {\n        /* refuse to receive just an integer (and interpret it\n           as the array size) */\n        goto convert_default;\n    }\n\n    if (ctitem->ct_size <= 0)\n        goto convert_default;\n    datasize = length * ctitem->ct_size;\n    if ((datasize / ctitem->ct_size) != length) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"array size would overflow a Py_ssize_t\");\n        return -1;\n    }\n    if (datasize <= 0)\n        datasize = 1;\n    return datasize;\n\n convert_default:\n    return convert_from_object((char *)output_data, ctptr, init);\n}\n\nstatic PyObject*\ncdata_call(CDataObject *cd, PyObject *args, PyObject *kwds)\n{\n    char *buffer;\n    void** buffer_array;\n    cif_description_t *cif_descr;\n    Py_ssize_t i, nargs, nargs_declared;\n    PyObject *signature, *res = NULL, *fvarargs;\n    CTypeDescrObject *fresult;\n    char *resultdata;\n    char *errormsg;\n\n    if (!(cd->c_type->ct_flags & CT_FUNCTIONPTR)) {\n        PyErr_Format(PyExc_TypeError, \"cdata '%s' is not callable\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (kwds != NULL && PyDict_Size(kwds) != 0) {\n        PyErr_SetString(PyExc_TypeError,\n                \"a cdata function cannot be called with keyword arguments\");\n        return NULL;\n    }\n    signature = cd->c_type->ct_stuff;\n    nargs = PyTuple_Size(args);\n    if (nargs < 0)\n        return NULL;\n    nargs_declared = PyTuple_GET_SIZE(signature) - 2;\n    fresult = (CTypeDescrObject *)PyTuple_GET_ITEM(signature, 1);\n    fvarargs = NULL;\n    buffer = NULL;\n\n    cif_descr = (cif_description_t *)cd->c_type->ct_extra;\n\n    if (cif_descr != NULL) {\n        /* regular case: this function does not take '...' arguments */\n        if (nargs != nargs_declared) {\n            errormsg = \"'%s' expects %zd arguments, got %zd\";\n          bad_number_of_arguments:\n            PyErr_Format(PyExc_TypeError, errormsg,\n                         cd->c_type->ct_name, nargs_declared, nargs);\n            goto error;\n        }\n    }\n    else {\n        /* call of a variadic function */\n        ffi_abi fabi;\n        if (nargs < nargs_declared) {\n            errormsg = \"'%s' expects at least %zd arguments, got %zd\";\n            goto bad_number_of_arguments;\n        }\n        fvarargs = PyTuple_New(nargs);\n        if (fvarargs == NULL)\n            goto error;\n        for (i = 0; i < nargs_declared; i++) {\n            PyObject *o = PyTuple_GET_ITEM(signature, 2 + i);\n            Py_INCREF(o);\n            PyTuple_SET_ITEM(fvarargs, i, o);\n        }\n        for (i = nargs_declared; i < nargs; i++) {\n            PyObject *obj = PyTuple_GET_ITEM(args, i);\n            CTypeDescrObject *ct;\n\n            if (CData_Check(obj)) {\n                ct = ((CDataObject *)obj)->c_type;\n                if (ct->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_UNSIGNED |\n                                    CT_PRIMITIVE_SIGNED)) {\n                    if (ct->ct_size < (Py_ssize_t)sizeof(int)) {\n                        ct = _get_ct_int();\n                        if (ct == NULL)\n                            goto error;\n                    }\n                }\n                else if (ct->ct_flags & CT_ARRAY) {\n                    ct = (CTypeDescrObject *)ct->ct_stuff;\n                }\n                Py_INCREF(ct);\n            }\n            else {\n                PyErr_Format(PyExc_TypeError,\n                             \"argument %zd passed in the variadic part \"\n                             \"needs to be a cdata object (got %.200s)\",\n                             i + 1, Py_TYPE(obj)->tp_name);\n                goto error;\n            }\n            PyTuple_SET_ITEM(fvarargs, i, (PyObject *)ct);\n        }\n#if PY_MAJOR_VERSION < 3\n        fabi = PyInt_AS_LONG(PyTuple_GET_ITEM(signature, 0));\n#else\n        fabi = PyLong_AS_LONG(PyTuple_GET_ITEM(signature, 0));\n#endif\n        cif_descr = fb_prepare_cif(fvarargs, fresult, fabi);\n        if (cif_descr == NULL)\n            goto error;\n    }\n\n    buffer = PyObject_Malloc(cif_descr->exchange_size);\n    if (buffer == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n\n    buffer_array = (void **)buffer;\n\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *argtype;\n        char *data = buffer + cif_descr->exchange_offset_arg[1 + i];\n        PyObject *obj = PyTuple_GET_ITEM(args, i);\n\n        buffer_array[i] = data;\n\n        if (i < nargs_declared)\n            argtype = (CTypeDescrObject *)PyTuple_GET_ITEM(signature, 2 + i);\n        else\n            argtype = (CTypeDescrObject *)PyTuple_GET_ITEM(fvarargs, i);\n\n        if (argtype->ct_flags & CT_POINTER) {\n            char *tmpbuf;\n            Py_ssize_t datasize = _prepare_pointer_call_argument(\n                                            argtype, obj, (char **)data);\n            if (datasize == 0)\n                ;    /* successfully filled '*data' */\n            else if (datasize < 0)\n                goto error;\n            else {\n                tmpbuf = alloca(datasize);\n                memset(tmpbuf, 0, datasize);\n                *(char **)data = tmpbuf;\n                if (convert_array_from_object(tmpbuf, argtype, obj) < 0)\n                    goto error;\n            }\n        }\n        else if (convert_from_object(data, argtype, obj) < 0)\n            goto error;\n    }\n\n    resultdata = buffer + cif_descr->exchange_offset_arg[0];\n    /*READ(cd->c_data, sizeof(void(*)(void)))*/\n\n    Py_BEGIN_ALLOW_THREADS\n    restore_errno();\n    ffi_call(&cif_descr->cif, (void (*)(void))(cd->c_data),\n             resultdata, buffer_array);\n    save_errno();\n    Py_END_ALLOW_THREADS\n\n    if (fresult->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_SIGNED |\n                             CT_PRIMITIVE_UNSIGNED)) {\n#ifdef WORDS_BIGENDIAN\n        /* For results of precisely these types, libffi has a strange\n           rule that they will be returned as a whole 'ffi_arg' if they\n           are smaller.  The difference only matters on big-endian. */\n        if (fresult->ct_size < sizeof(ffi_arg))\n            resultdata += (sizeof(ffi_arg) - fresult->ct_size);\n#endif\n        res = convert_to_object(resultdata, fresult);\n    }\n    else if (fresult->ct_flags & CT_VOID) {\n        res = Py_None;\n        Py_INCREF(res);\n    }\n    else if (fresult->ct_flags & CT_STRUCT) {\n        res = convert_struct_to_owning_object(resultdata, fresult);\n    }\n    else {\n        res = convert_to_object(resultdata, fresult);\n    }\n    /* fall-through */\n\n error:\n    if (buffer)\n        PyObject_Free(buffer);\n    if (fvarargs != NULL) {\n        Py_DECREF(fvarargs);\n        if (cif_descr != NULL)  /* but only if fvarargs != NULL, if variadic */\n            PyObject_Free(cif_descr);\n    }\n    return res;\n}\n\nstatic PyObject *cdata_iter(CDataObject *);\n\nstatic PyNumberMethods CData_as_number = {\n    (binaryfunc)cdata_add,      /*nb_add*/\n    (binaryfunc)cdata_sub,      /*nb_subtract*/\n    0,                          /*nb_multiply*/\n#if PY_MAJOR_VERSION < 3\n    0,                          /*nb_divide*/\n#endif\n    0,                          /*nb_remainder*/\n    0,                          /*nb_divmod*/\n    0,                          /*nb_power*/\n    0,                          /*nb_negative*/\n    0,                          /*nb_positive*/\n    0,                          /*nb_absolute*/\n    (inquiry)cdata_nonzero,     /*nb_nonzero*/\n    0,                          /*nb_invert*/\n    0,                          /*nb_lshift*/\n    0,                          /*nb_rshift*/\n    0,                          /*nb_and*/\n    0,                          /*nb_xor*/\n    0,                          /*nb_or*/\n#if PY_MAJOR_VERSION < 3\n    0,                          /*nb_coerce*/\n#endif\n    (unaryfunc)cdata_int,       /*nb_int*/\n#if PY_MAJOR_VERSION < 3\n    (unaryfunc)cdata_long,      /*nb_long*/\n#else\n    0,\n#endif\n    (unaryfunc)cdata_float,     /*nb_float*/\n    0,                          /*nb_oct*/\n    0,                          /*nb_hex*/\n};\n\nstatic PyMappingMethods CData_as_mapping = {\n    (lenfunc)cdata_length, /*mp_length*/\n    (binaryfunc)cdata_subscript, /*mp_subscript*/\n    (objobjargproc)cdata_ass_sub, /*mp_ass_subscript*/\n};\n\nstatic PyMappingMethods CDataOwn_as_mapping = {\n    (lenfunc)cdata_length, /*mp_length*/\n    (binaryfunc)cdataowning_subscript, /*mp_subscript*/\n    (objobjargproc)cdata_ass_sub, /*mp_ass_subscript*/\n};\n\nstatic PyTypeObject CData_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CData\",\n    sizeof(CDataObject),\n    0,\n    (destructor)cdata_dealloc,                  /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdata_repr,                       /* tp_repr */\n    &CData_as_number,                           /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    &CData_as_mapping,                          /* tp_as_mapping */\n    (hashfunc)cdata_hash,                       /* tp_hash */\n    (ternaryfunc)cdata_call,                    /* tp_call */\n    0,                                          /* tp_str */\n    (getattrofunc)cdata_getattro,               /* tp_getattro */\n    (setattrofunc)cdata_setattro,               /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES, /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    cdata_richcompare,                          /* tp_richcompare */\n    offsetof(CDataObject, c_weakreflist),       /* tp_weaklistoffset */\n    (getiterfunc)cdata_iter,                    /* tp_iter */\n    0,                                          /* tp_iternext */\n};\n\nstatic PyTypeObject CDataOwning_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataOwn\",\n    sizeof(CDataObject),\n    0,\n    (destructor)cdataowning_dealloc,            /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdataowning_repr,                 /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    &CDataOwn_as_mapping,                       /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES, /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CData_Type,                                /* tp_base */\n};\n\nstatic PyTypeObject CDataOwningGC_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataOwnGC\",\n    sizeof(CDataObject_owngc_frombuf),\n    0,\n    (destructor)cdataowninggc_dealloc,          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdataowninggc_repr,               /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES  /* tp_flags */\n                       | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)cdataowninggc_traverse,       /* tp_traverse */\n    (inquiry)cdataowninggc_clear,               /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CDataOwning_Type,                          /* tp_base */\n};\n\n/************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    char *di_next, *di_stop;\n    CDataObject *di_object;\n    CTypeDescrObject *di_itemtype;\n} CDataIterObject;\n\nstatic PyObject *\ncdataiter_next(CDataIterObject *it)\n{\n    char *result = it->di_next;\n    if (result != it->di_stop) {\n        it->di_next = result + it->di_itemtype->ct_size;\n        return convert_to_object(result, it->di_itemtype);\n    }\n    return NULL;\n}\n\nstatic void\ncdataiter_dealloc(CDataIterObject *it)\n{\n    Py_DECREF(it->di_object);\n    PyObject_Del(it);\n}\n\nstatic PyTypeObject CDataIter_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataIter\",              /* tp_name */\n    sizeof(CDataIterObject),                /* tp_basicsize */\n    0,                                      /* tp_itemsize */\n    /* methods */\n    (destructor)cdataiter_dealloc,          /* tp_dealloc */\n    0,                                      /* tp_print */\n    0,                                      /* tp_getattr */\n    0,                                      /* tp_setattr */\n    0,                                      /* tp_compare */\n    0,                                      /* tp_repr */\n    0,                                      /* tp_as_number */\n    0,                                      /* tp_as_sequence */\n    0,                                      /* tp_as_mapping */\n    0,                                      /* tp_hash */\n    0,                                      /* tp_call */\n    0,                                      /* tp_str */\n    PyObject_GenericGetAttr,                /* tp_getattro */\n    0,                                      /* tp_setattro */\n    0,                                      /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                     /* tp_flags */\n    0,                                      /* tp_doc */\n    0,                                      /* tp_traverse */\n    0,                                      /* tp_clear */\n    0,                                      /* tp_richcompare */\n    0,                                      /* tp_weaklistoffset */\n    PyObject_SelfIter,                      /* tp_iter */\n    (iternextfunc)cdataiter_next,           /* tp_iternext */\n};\n\nstatic PyObject *\ncdata_iter(CDataObject *cd)\n{\n    CDataIterObject *it;\n\n    if (!(cd->c_type->ct_flags & CT_ARRAY)) {\n        PyErr_Format(PyExc_TypeError, \"cdata '%s' does not support iteration\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n\n    it = PyObject_New(CDataIterObject, &CDataIter_Type);\n    if (it == NULL)\n        return NULL;\n\n    Py_INCREF(cd);\n    it->di_object = cd;\n    it->di_itemtype = cd->c_type->ct_itemdescr;\n    it->di_next = cd->c_data;\n    it->di_stop = cd->c_data + get_array_length(cd) * it->di_itemtype->ct_size;\n    return (PyObject *)it;\n}\n\n/************************************************************/\n\nstatic CDataObject *allocate_owning_object(Py_ssize_t size,\n                                           CTypeDescrObject *ct)\n{\n    CDataObject *cd;\n    cd = (CDataObject *)PyObject_Malloc(size);\n    if (PyObject_Init((PyObject *)cd, &CDataOwning_Type) == NULL)\n        return NULL;\n\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_weakreflist = NULL;\n    return cd;\n}\n\nstatic PyObject *\nconvert_struct_to_owning_object(char *data, CTypeDescrObject *ct)\n{\n    CDataObject *cd;\n    Py_ssize_t dataoffset = offsetof(CDataObject_own_nolength, alignment);\n    Py_ssize_t datasize = ct->ct_size;\n\n    if ((ct->ct_flags & (CT_STRUCT|CT_IS_OPAQUE)) != CT_STRUCT) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"return type is not a struct or is opaque\");\n        return NULL;\n    }\n    cd = allocate_owning_object(dataoffset + datasize, ct);\n    if (cd == NULL)\n        return NULL;\n    cd->c_data = ((char *)cd) + dataoffset;\n\n    memcpy(cd->c_data, data, datasize);\n    return (PyObject *)cd;\n}\n\nstatic PyObject *direct_newp(CTypeDescrObject *ct, PyObject *init)\n{\n    CTypeDescrObject *ctitem;\n    CDataObject *cd;\n    Py_ssize_t dataoffset, datasize, explicitlength;\n\n    explicitlength = -1;\n    if (ct->ct_flags & CT_POINTER) {\n        dataoffset = offsetof(CDataObject_own_nolength, alignment);\n        ctitem = ct->ct_itemdescr;\n        datasize = ctitem->ct_size;\n        if (datasize < 0) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot instantiate ctype '%s' of unknown size\",\n                         ctitem->ct_name);\n            return NULL;\n        }\n        if (ctitem->ct_flags & CT_PRIMITIVE_CHAR)\n            datasize *= 2;   /* forcefully add another character: a null */\n\n        if ((ctitem->ct_flags & (CT_STRUCT | CT_UNION)) && init != Py_None) {\n            if (force_lazy_struct(ctitem) < 0)   /* for CT_WITH_VAR_ARRAY */\n                return NULL;\n            if (ctitem->ct_flags & CT_WITH_VAR_ARRAY) {\n                Py_ssize_t optvarsize = datasize;\n                if (convert_struct_from_object(NULL,ctitem, init,\n                                               &optvarsize) < 0)\n                    return NULL;\n                datasize = optvarsize;\n            }\n        }\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        dataoffset = offsetof(CDataObject_own_nolength, alignment);\n        datasize = ct->ct_size;\n        if (datasize < 0) {\n            explicitlength = get_new_array_length(&init);\n            if (explicitlength < 0)\n                return NULL;\n            ctitem = ct->ct_itemdescr;\n            dataoffset = offsetof(CDataObject_own_length, alignment);\n            datasize = explicitlength * ctitem->ct_size;\n            if (explicitlength > 0 &&\n                    (datasize / explicitlength) != ctitem->ct_size) {\n                PyErr_SetString(PyExc_OverflowError,\n                                \"array size would overflow a Py_ssize_t\");\n                return NULL;\n            }\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array ctype, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n    if (ct->ct_flags & CT_IS_PTR_TO_OWNED) {\n        /* common case of ptr-to-struct (or ptr-to-union): for this case\n           we build two objects instead of one, with the memory-owning\n           one being really the struct (or union) and the returned one\n           having a strong reference to it */\n        CDataObject *cds;\n\n        cds = allocate_owning_object(dataoffset + datasize, ct->ct_itemdescr);\n        if (cds == NULL)\n            return NULL;\n\n        cd = allocate_owning_object(sizeof(CDataObject_own_structptr), ct);\n        if (cd == NULL) {\n            Py_DECREF(cds);\n            return NULL;\n        }\n        /* store the only reference to cds into cd */\n        ((CDataObject_own_structptr *)cd)->structobj = (PyObject *)cds;\n        assert(explicitlength < 0);\n\n        cds->c_data = cd->c_data = ((char *)cds) + dataoffset;\n    }\n    else {\n        cd = allocate_owning_object(dataoffset + datasize, ct);\n        if (cd == NULL)\n            return NULL;\n\n        cd->c_data = ((char *)cd) + dataoffset;\n        if (explicitlength >= 0)\n            ((CDataObject_own_length*)cd)->length = explicitlength;\n    }\n\n    memset(cd->c_data, 0, datasize);\n    if (init != Py_None) {\n        if (convert_from_object(cd->c_data,\n              (ct->ct_flags & CT_POINTER) ? ct->ct_itemdescr : ct, init) < 0) {\n            Py_DECREF(cd);\n            return NULL;\n        }\n    }\n    return (PyObject *)cd;\n}\n\nstatic PyObject *b_newp(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *init = Py_None;\n    if (!PyArg_ParseTuple(args, \"O!|O:newp\", &CTypeDescr_Type, &ct, &init))\n        return NULL;\n    return direct_newp(ct, init);\n}\n\nstatic int\n_my_PyObject_AsBool(PyObject *ob)\n{\n    /* convert and cast a Python object to a boolean.  Accept an integer\n       or a float object, up to a CData 'long double'. */\n    PyObject *io;\n    PyNumberMethods *nb;\n    int res;\n\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        return PyInt_AS_LONG(ob) != 0;\n    }\n    else\n#endif\n    if (PyLong_Check(ob)) {\n        return _PyLong_Sign(ob) != 0;\n    }\n    else if (PyFloat_Check(ob)) {\n        return PyFloat_AS_DOUBLE(ob) != 0.0;\n    }\n    else if (CData_Check(ob)) {\n        CDataObject *cd = (CDataObject *)ob;\n        if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n            /*READ(cd->c_data, cd->c_type->ct_size)*/\n            if (cd->c_type->ct_flags & CT_IS_LONGDOUBLE) {\n                /* 'long double' objects: return the answer directly */\n                return read_raw_longdouble_data(cd->c_data) != 0.0;\n            }\n            else {\n                /* 'float'/'double' objects: return the answer directly */\n                return read_raw_float_data(cd->c_data,\n                                           cd->c_type->ct_size) != 0.0;\n            }\n        }\n    }\n    nb = ob->ob_type->tp_as_number;\n    if (nb == NULL || (nb->nb_float == NULL && nb->nb_int == NULL)) {\n        PyErr_SetString(PyExc_TypeError, \"integer/float expected\");\n        return -1;\n    }\n    if (nb->nb_float && !CData_Check(ob))\n        io = (*nb->nb_float) (ob);\n    else\n        io = (*nb->nb_int) (ob);\n    if (io == NULL)\n        return -1;\n\n    if (PyIntOrLong_Check(io) || PyFloat_Check(io)) {\n        res = _my_PyObject_AsBool(io);\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError, \"integer/float conversion failed\");\n        res = -1;\n    }\n    Py_DECREF(io);\n    return res;\n}\n\nstatic CDataObject *_new_casted_primitive(CTypeDescrObject *ct)\n{\n    int dataoffset = offsetof(CDataObject_casted_primitive, alignment);\n    CDataObject *cd = (CDataObject *)PyObject_Malloc(dataoffset + ct->ct_size);\n    if (PyObject_Init((PyObject *)cd, &CData_Type) == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_data = ((char*)cd) + dataoffset;\n    cd->c_weakreflist = NULL;\n    return cd;\n}\n\nstatic CDataObject *cast_to_integer_or_char(CTypeDescrObject *ct, PyObject *ob)\n{\n    unsigned PY_LONG_LONG value;\n    CDataObject *cd;\n\n    if (CData_Check(ob) &&\n        ((CDataObject *)ob)->c_type->ct_flags &\n                                 (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY)) {\n        value = (Py_intptr_t)((CDataObject *)ob)->c_data;\n    }\n#if PY_MAJOR_VERSION < 3\n    else if (PyString_Check(ob)) {\n        if (PyString_GET_SIZE(ob) != 1) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot cast string of length %zd to ctype '%s'\",\n                         PyString_GET_SIZE(ob), ct->ct_name);\n            return NULL;\n        }\n        value = (unsigned char)PyString_AS_STRING(ob)[0];\n    }\n#endif\n#ifdef HAVE_WCHAR_H\n    else if (PyUnicode_Check(ob)) {\n        wchar_t ordinal;\n        if (_my_PyUnicode_AsSingleWideChar(ob, &ordinal) < 0) {\n            PyErr_Format(PyExc_TypeError,\n                      \"cannot cast unicode string of length %zd to ctype '%s'\",\n                         PyUnicode_GET_SIZE(ob), ct->ct_name);\n            return NULL;\n        }\n        value = (long)ordinal;\n    }\n#endif\n    else if (PyBytes_Check(ob)) {\n        int res = _convert_to_char(ob);\n        if (res < 0)\n            return NULL;\n        value = (unsigned char)res;\n    }\n    else if (ct->ct_flags & CT_IS_BOOL) {\n        int res = _my_PyObject_AsBool(ob);\n        if (res < 0)\n            return NULL;\n        value = res;\n    }\n    else {\n        value = _my_PyLong_AsUnsignedLongLong(ob, 0);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return NULL;\n    }\n    if (ct->ct_flags & CT_IS_BOOL)\n        value = !!value;\n    cd = _new_casted_primitive(ct);\n    if (cd != NULL)\n        write_raw_integer_data(cd->c_data, value, ct->ct_size);\n    return cd;\n}\n\nstatic PyObject *do_cast(CTypeDescrObject *ct, PyObject *ob)\n{\n    CDataObject *cd;\n\n    if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY) &&\n        ct->ct_size >= 0) {\n        /* cast to a pointer, to a funcptr, or to an array.\n           Note that casting to an array is an extension to the C language,\n           which seems to be necessary in order to sanely get a\n           <cdata 'int[3]'> at some address. */\n        unsigned PY_LONG_LONG value;\n\n        if (CData_Check(ob)) {\n            CDataObject *cdsrc = (CDataObject *)ob;\n            if (cdsrc->c_type->ct_flags &\n                    (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY)) {\n                return new_simple_cdata(cdsrc->c_data, ct);\n            }\n        }\n        if ((ct->ct_flags & CT_POINTER) &&\n                (ct->ct_itemdescr->ct_flags & CT_IS_FILE) &&\n                PyFile_Check(ob)) {\n            FILE *f = PyFile_AsFile(ob);\n            if (f == NULL && PyErr_Occurred())\n                return NULL;\n            return new_simple_cdata((char *)f, ct);\n        }\n        value = _my_PyLong_AsUnsignedLongLong(ob, 0);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return NULL;\n        return new_simple_cdata((char *)(Py_intptr_t)value, ct);\n    }\n    else if (ct->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED\n                             |CT_PRIMITIVE_CHAR)) {\n        /* cast to an integer type or a char */\n        return (PyObject *)cast_to_integer_or_char(ct, ob);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        /* cast to a float */\n        double value;\n        PyObject *io;\n\n        if (CData_Check(ob)) {\n            CDataObject *cdsrc = (CDataObject *)ob;\n\n            if (!(cdsrc->c_type->ct_flags & CT_PRIMITIVE_ANY))\n                goto cannot_cast;\n            io = convert_to_object(cdsrc->c_data, cdsrc->c_type);\n            if (io == NULL)\n                return NULL;\n        }\n        else {\n            io = ob;\n            Py_INCREF(io);\n        }\n\n        if (PyBytes_Check(io)) {\n            if (PyBytes_GET_SIZE(io) != 1) {\n                Py_DECREF(io);\n                goto cannot_cast;\n            }\n            value = (unsigned char)PyBytes_AS_STRING(io)[0];\n        }\n#if HAVE_WCHAR_H\n        else if (PyUnicode_Check(io)) {\n            wchar_t ordinal;\n            if (_my_PyUnicode_AsSingleWideChar(io, &ordinal) < 0) {\n                Py_DECREF(io);\n                goto cannot_cast;\n            }\n            value = (long)ordinal;\n        }\n#endif\n        else if ((ct->ct_flags & CT_IS_LONGDOUBLE) &&\n                 CData_Check(io) &&\n                 (((CDataObject *)io)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n            long double lvalue;\n            char *data = ((CDataObject *)io)->c_data;\n            /*READ(data, sizeof(long double)*/\n            lvalue = read_raw_longdouble_data(data);\n            Py_DECREF(io);\n            cd = _new_casted_primitive(ct);\n            if (cd != NULL)\n                write_raw_longdouble_data(cd->c_data, lvalue);\n            return (PyObject *)cd;\n        }\n        else {\n            value = PyFloat_AsDouble(io);\n        }\n        Py_DECREF(io);\n        if (value == -1.0 && PyErr_Occurred())\n            return NULL;\n\n        cd = _new_casted_primitive(ct);\n        if (cd != NULL) {\n            if (!(ct->ct_flags & CT_IS_LONGDOUBLE))\n                write_raw_float_data(cd->c_data, value, ct->ct_size);\n            else\n                write_raw_longdouble_data(cd->c_data, (long double)value);\n        }\n        return (PyObject *)cd;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cannot cast to ctype '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n cannot_cast:\n    if (CData_Check(ob))\n        PyErr_Format(PyExc_TypeError, \"cannot cast ctype '%s' to ctype '%s'\",\n                     ((CDataObject *)ob)->c_type->ct_name, ct->ct_name);\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"cannot cast %.200s object to ctype '%s'\",\n                     Py_TYPE(ob)->tp_name, ct->ct_name);\n    return NULL;\n}\n\nstatic PyObject *b_cast(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *ob;\n    if (!PyArg_ParseTuple(args, \"O!O:cast\", &CTypeDescr_Type, &ct, &ob))\n        return NULL;\n\n    return do_cast(ct, ob);\n}\n\n/************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    void *dl_handle;\n    char *dl_name;\n} DynLibObject;\n\nstatic void dl_dealloc(DynLibObject *dlobj)\n{\n    dlclose(dlobj->dl_handle);\n    free(dlobj->dl_name);\n    PyObject_Del(dlobj);\n}\n\nstatic PyObject *dl_repr(DynLibObject *dlobj)\n{\n    return PyText_FromFormat(\"<clibrary '%s'>\", dlobj->dl_name);\n}\n\nstatic PyObject *dl_load_function(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *funcname;\n    void *funcptr;\n    int ok;\n\n    if (!PyArg_ParseTuple(args, \"O!s:load_function\",\n                          &CTypeDescr_Type, &ct, &funcname))\n        return NULL;\n\n    ok = 0;\n    if (ct->ct_flags & CT_FUNCTIONPTR)\n        ok = 1;\n    if ((ct->ct_flags & CT_POINTER) && (ct->ct_itemdescr->ct_flags & CT_VOID))\n        ok = 1;\n    if (!ok) {\n        PyErr_Format(PyExc_TypeError, \"function cdata expected, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n    dlerror();   /* clear error condition */\n    funcptr = dlsym(dlobj->dl_handle, funcname);\n    if (funcptr == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_KeyError,\n                     \"function '%s' not found in library '%s': %s\",\n                     funcname, dlobj->dl_name, error);\n        return NULL;\n    }\n\n    return new_simple_cdata(funcptr, ct);\n}\n\nstatic PyObject *dl_read_variable(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *varname;\n    char *data;\n\n    if (!PyArg_ParseTuple(args, \"O!s:read_variable\",\n                          &CTypeDescr_Type, &ct, &varname))\n        return NULL;\n\n    dlerror();   /* clear error condition */\n    data = dlsym(dlobj->dl_handle, varname);\n    if (data == NULL) {\n        const char *error = dlerror();\n        if (error != NULL) {\n            PyErr_Format(PyExc_KeyError,\n                         \"variable '%s' not found in library '%s': %s\",\n                         varname, dlobj->dl_name, error);\n            return NULL;\n        }\n    }\n    return convert_to_object(data, ct);\n}\n\nstatic PyObject *dl_write_variable(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *value;\n    char *varname;\n    char *data;\n\n    if (!PyArg_ParseTuple(args, \"O!sO:write_variable\",\n                          &CTypeDescr_Type, &ct, &varname, &value))\n        return NULL;\n\n    dlerror();   /* clear error condition */\n    data = dlsym(dlobj->dl_handle, varname);\n    if (data == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_KeyError,\n                     \"variable '%s' not found in library '%s': %s\",\n                     varname, dlobj->dl_name, error);\n        return NULL;\n    }\n    if (convert_from_object(data, ct, value) < 0)\n        return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyMethodDef dl_methods[] = {\n    {\"load_function\",   (PyCFunction)dl_load_function,  METH_VARARGS},\n    {\"read_variable\",   (PyCFunction)dl_read_variable,  METH_VARARGS},\n    {\"write_variable\",  (PyCFunction)dl_write_variable, METH_VARARGS},\n    {NULL,              NULL}           /* sentinel */\n};\n\nstatic PyTypeObject dl_type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.Library\",            /* tp_name */\n    sizeof(DynLibObject),               /* tp_basicsize */\n    0,                                  /* tp_itemsize */\n    /* methods */\n    (destructor)dl_dealloc,             /* tp_dealloc */\n    0,                                  /* tp_print */\n    0,                                  /* tp_getattr */\n    0,                                  /* tp_setattr */\n    0,                                  /* tp_compare */\n    (reprfunc)dl_repr,                  /* tp_repr */\n    0,                                  /* tp_as_number */\n    0,                                  /* tp_as_sequence */\n    0,                                  /* tp_as_mapping */\n    0,                                  /* tp_hash */\n    0,                                  /* tp_call */\n    0,                                  /* tp_str */\n    PyObject_GenericGetAttr,            /* tp_getattro */\n    0,                                  /* tp_setattro */\n    0,                                  /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                 /* tp_flags */\n    0,                                  /* tp_doc */\n    0,                                  /* tp_traverse */\n    0,                                  /* tp_clear */\n    0,                                  /* tp_richcompare */\n    0,                                  /* tp_weaklistoffset */\n    0,                                  /* tp_iter */\n    0,                                  /* tp_iternext */\n    dl_methods,                         /* tp_methods */\n};\n\nstatic PyObject *b_load_library(PyObject *self, PyObject *args)\n{\n    char *filename_or_null, *printable_filename;\n    void *handle;\n    DynLibObject *dlobj;\n    int flags = 0;\n\n    if (PyTuple_GET_SIZE(args) == 0 || PyTuple_GET_ITEM(args, 0) == Py_None) {\n        PyObject *dummy;\n        if (!PyArg_ParseTuple(args, \"|Oi:load_library\",\n                              &dummy, &flags))\n            return NULL;\n        filename_or_null = NULL;\n    }\n    else if (!PyArg_ParseTuple(args, \"et|i:load_library\",\n                          Py_FileSystemDefaultEncoding, &filename_or_null,\n                          &flags))\n        return NULL;\n\n    if ((flags & (RTLD_NOW | RTLD_LAZY)) == 0)\n        flags |= RTLD_NOW;\n\n    printable_filename = filename_or_null ? filename_or_null : \"<None>\";\n    handle = dlopen(filename_or_null, flags);\n    if (handle == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_OSError, \"cannot load library %s: %s\",\n                     printable_filename, error);\n        return NULL;\n    }\n\n    dlobj = PyObject_New(DynLibObject, &dl_type);\n    if (dlobj == NULL) {\n        dlclose(handle);\n        return NULL;\n    }\n    dlobj->dl_handle = handle;\n    dlobj->dl_name = strdup(printable_filename);\n    return (PyObject *)dlobj;\n}\n\n/************************************************************/\n\nstatic PyObject *unique_cache;\n\nstatic PyObject *get_unique_type(CTypeDescrObject *x,\n                                 const void *unique_key[], long keylength)\n{\n    /* Replace the CTypeDescrObject 'x' with a standardized one.\n       This either just returns x, or x is decrefed and a new reference\n       to the already-existing equivalent is returned.\n\n       In this function, 'x' always contains a reference that must be\n       either decrefed or returned.\n\n       Keys:\n           void       [\"void\"]\n           primitive  [&static_struct]\n           pointer    [ctype]\n           array      [ctype, length]\n           funcptr    [ctresult, ellipsis+abi, num_args, ctargs...]\n    */\n    long i;\n    PyObject *key, *y;\n    const void **pkey;\n    int err;\n\n    key = PyBytes_FromStringAndSize(NULL, keylength * sizeof(void *));\n    if (key == NULL)\n        goto error;\n\n    pkey = (const void **)PyBytes_AS_STRING(key);\n    for (i = 0; i < keylength; i++)\n        pkey[i] = unique_key[i];\n\n    y = PyDict_GetItem(unique_cache, key);\n    if (y != NULL) {\n        Py_DECREF(key);\n        Py_INCREF(y);\n        Py_DECREF(x);\n        return y;\n    }\n    err = PyDict_SetItem(unique_cache, key, (PyObject *)x);\n    Py_DECREF(key);\n    if (err < 0)\n        goto error;\n\n    return (PyObject *)x;\n\n error:\n    Py_DECREF(x);\n    return NULL;\n}\n\nstatic PyObject *new_primitive_type(const char *name)\n{\n#define ENUM_PRIMITIVE_TYPES                                    \\\n       EPTYPE(c, char, CT_PRIMITIVE_CHAR)                       \\\n       EPTYPE(s, short, CT_PRIMITIVE_SIGNED )                   \\\n       EPTYPE(i, int, CT_PRIMITIVE_SIGNED )                     \\\n       EPTYPE(l, long, CT_PRIMITIVE_SIGNED )                    \\\n       EPTYPE(ll, long long, CT_PRIMITIVE_SIGNED )              \\\n       EPTYPE(sc, signed char, CT_PRIMITIVE_SIGNED )            \\\n       EPTYPE(uc, unsigned char, CT_PRIMITIVE_UNSIGNED )        \\\n       EPTYPE(us, unsigned short, CT_PRIMITIVE_UNSIGNED )       \\\n       EPTYPE(ui, unsigned int, CT_PRIMITIVE_UNSIGNED )         \\\n       EPTYPE(ul, unsigned long, CT_PRIMITIVE_UNSIGNED )        \\\n       EPTYPE(ull, unsigned long long, CT_PRIMITIVE_UNSIGNED )  \\\n       EPTYPE(f, float, CT_PRIMITIVE_FLOAT )                    \\\n       EPTYPE(d, double, CT_PRIMITIVE_FLOAT )                   \\\n       EPTYPE(ld, long double, CT_PRIMITIVE_FLOAT | CT_IS_LONGDOUBLE ) \\\n       ENUM_PRIMITIVE_TYPES_WCHAR                               \\\n       EPTYPE(b, _Bool, CT_PRIMITIVE_UNSIGNED | CT_IS_BOOL )    \\\n     /* the following types are not primitive in the C sense */ \\\n       EPTYPE(i8, int8_t, CT_PRIMITIVE_SIGNED)                  \\\n       EPTYPE(u8, uint8_t, CT_PRIMITIVE_UNSIGNED)               \\\n       EPTYPE(i16, int16_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u16, uint16_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(i32, int32_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u32, uint32_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(i64, int64_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u64, uint64_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(il8, int_least8_t, CT_PRIMITIVE_SIGNED)           \\\n       EPTYPE(ul8, uint_least8_t, CT_PRIMITIVE_UNSIGNED)        \\\n       EPTYPE(il16, int_least16_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul16, uint_least16_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(il32, int_least32_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul32, uint_least32_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(il64, int_least64_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul64, uint_least64_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(if8, int_fast8_t, CT_PRIMITIVE_SIGNED)            \\\n       EPTYPE(uf8, uint_fast8_t, CT_PRIMITIVE_UNSIGNED)         \\\n       EPTYPE(if16, int_fast16_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf16, uint_fast16_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(if32, int_fast32_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf32, uint_fast32_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(if64, int_fast64_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf64, uint_fast64_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(ip, intptr_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(up, uintptr_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(im, intmax_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(um, uintmax_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(pd, ptrdiff_t, CT_PRIMITIVE_SIGNED)               \\\n       EPTYPE(sz, size_t, CT_PRIMITIVE_UNSIGNED)                \\\n       EPTYPE(ssz, ssize_t, CT_PRIMITIVE_SIGNED)\n\n#ifdef HAVE_WCHAR_H\n# define ENUM_PRIMITIVE_TYPES_WCHAR                             \\\n       EPTYPE(wc, wchar_t, CT_PRIMITIVE_CHAR )\n#else\n# define ENUM_PRIMITIVE_TYPES_WCHAR   /* nothing */\n#endif\n\n#define EPTYPE(code, typename, flags)                   \\\n    struct aligncheck_##code { char x; typename y; };\n    ENUM_PRIMITIVE_TYPES\n#undef EPTYPE\n\n    CTypeDescrObject *td;\n    static const struct descr_s { const char *name; int size, align, flags; }\n    types[] = {\n#define EPTYPE(code, typename, flags)                   \\\n        { #typename,                                    \\\n          sizeof(typename),                             \\\n          offsetof(struct aligncheck_##code, y),        \\\n          flags                                         \\\n        },\n    ENUM_PRIMITIVE_TYPES\n#undef EPTYPE\n#undef ENUM_PRIMITIVE_TYPES_WCHAR\n#undef ENUM_PRIMITIVE_TYPES\n        { NULL }\n    };\n    const struct descr_s *ptypes;\n    const void *unique_key[1];\n    int name_size;\n    ffi_type *ffitype;\n\n    for (ptypes=types; ; ptypes++) {\n        if (ptypes->name == NULL) {\n#ifndef HAVE_WCHAR_H\n            if (strcmp(name, \"wchar_t\"))\n                PyErr_SetString(PyExc_NotImplementedError, name);\n            else\n#endif\n            PyErr_SetString(PyExc_KeyError, name);\n            return NULL;\n        }\n        if (strcmp(name, ptypes->name) == 0)\n            break;\n    }\n\n    if (ptypes->flags & CT_PRIMITIVE_SIGNED) {\n        switch (ptypes->size) {\n        case 1: ffitype = &ffi_type_sint8; break;\n        case 2: ffitype = &ffi_type_sint16; break;\n        case 4: ffitype = &ffi_type_sint32; break;\n        case 8: ffitype = &ffi_type_sint64; break;\n        default: goto bad_ffi_type;\n        }\n    }\n    else if (ptypes->flags & CT_PRIMITIVE_FLOAT) {\n        if (strcmp(ptypes->name, \"float\") == 0)\n            ffitype = &ffi_type_float;\n        else if (strcmp(ptypes->name, \"double\") == 0)\n            ffitype = &ffi_type_double;\n        else if (strcmp(ptypes->name, \"long double\") == 0)\n            ffitype = &ffi_type_longdouble;\n        else\n            goto bad_ffi_type;\n    }\n    else {\n        switch (ptypes->size) {\n        case 1: ffitype = &ffi_type_uint8; break;\n        case 2: ffitype = &ffi_type_uint16; break;\n        case 4: ffitype = &ffi_type_uint32; break;\n        case 8: ffitype = &ffi_type_uint64; break;\n        default: goto bad_ffi_type;\n        }\n    }\n\n    name_size = strlen(ptypes->name) + 1;\n    td = ctypedescr_new(name_size);\n    if (td == NULL)\n        return NULL;\n\n    memcpy(td->ct_name, name, name_size);\n    td->ct_size = ptypes->size;\n    td->ct_length = ptypes->align;\n    td->ct_extra = ffitype;\n    td->ct_flags = ptypes->flags;\n    if (td->ct_flags & (CT_PRIMITIVE_SIGNED | CT_PRIMITIVE_CHAR)) {\n        if (td->ct_size <= (Py_ssize_t)sizeof(long))\n            td->ct_flags |= CT_PRIMITIVE_FITS_LONG;\n    }\n    else if (td->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        if (td->ct_size < (Py_ssize_t)sizeof(long))\n            td->ct_flags |= CT_PRIMITIVE_FITS_LONG;\n    }\n    td->ct_name_position = strlen(td->ct_name);\n    unique_key[0] = ptypes;\n    return get_unique_type(td, unique_key, 1);\n\n bad_ffi_type:\n    PyErr_Format(PyExc_NotImplementedError,\n                 \"primitive type '%s' has size %d; \"\n                 \"the supported sizes are 1, 2, 4, 8\",\n                 name, (int)ptypes->size);\n    return NULL;\n}\n\nstatic PyObject *b_new_primitive_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    if (!PyArg_ParseTuple(args, \"s:new_primitive_type\", &name))\n        return NULL;\n    return new_primitive_type(name);\n}\n\nstatic PyObject *new_pointer_type(CTypeDescrObject *ctitem)\n{\n    CTypeDescrObject *td;\n    const char *extra;\n    const void *unique_key[1];\n\n    if (ctitem->ct_flags & CT_ARRAY)\n        extra = \"(*)\";   /* obscure case: see test_array_add */\n    else\n        extra = \" *\";\n    td = ctypedescr_new_on_top(ctitem, extra, 2);\n    if (td == NULL)\n        return NULL;\n\n    td->ct_size = sizeof(void *);\n    td->ct_length = -1;\n    td->ct_flags = CT_POINTER;\n    if (ctitem->ct_flags & (CT_STRUCT|CT_UNION))\n        td->ct_flags |= CT_IS_PTR_TO_OWNED;\n    if (ctitem->ct_flags & CT_VOID)\n        td->ct_flags |= CT_IS_VOID_PTR;\n    if ((ctitem->ct_flags & CT_VOID) ||\n        ((ctitem->ct_flags & CT_PRIMITIVE_CHAR) &&\n         ctitem->ct_size == sizeof(char)))\n        td->ct_flags |= CT_CAST_ANYTHING;   /* 'void *' or 'char *' only */\n    unique_key[0] = ctitem;\n    return get_unique_type(td, unique_key, 1);\n}\n\nstatic PyObject *b_new_pointer_type(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ctitem;\n    if (!PyArg_ParseTuple(args, \"O!:new_pointer_type\",\n                          &CTypeDescr_Type, &ctitem))\n        return NULL;\n    return new_pointer_type(ctitem);\n}\n\nstatic PyObject *b_new_array_type(PyObject *self, PyObject *args)\n{\n    PyObject *lengthobj;\n    Py_ssize_t length;\n    CTypeDescrObject *ctptr;\n\n    if (!PyArg_ParseTuple(args, \"O!O:new_array_type\",\n                          &CTypeDescr_Type, &ctptr, &lengthobj))\n        return NULL;\n\n    if (lengthobj == Py_None) {\n        length = -1;\n    }\n    else {\n        length = PyNumber_AsSsize_t(lengthobj, PyExc_OverflowError);\n        if (length < 0) {\n            if (!PyErr_Occurred())\n                PyErr_SetString(PyExc_ValueError, \"negative array length\");\n            return NULL;\n        }\n    }\n    return new_array_type(ctptr, length);\n}\n\nstatic PyObject *\nnew_array_type(CTypeDescrObject *ctptr, Py_ssize_t length)\n{\n    CTypeDescrObject *td, *ctitem;\n    char extra_text[32];\n    Py_ssize_t arraysize;\n    int flags = CT_ARRAY;\n    const void *unique_key[2];\n\n    if (!(ctptr->ct_flags & CT_POINTER)) {\n        PyErr_SetString(PyExc_TypeError, \"first arg must be a pointer ctype\");\n        return NULL;\n    }\n    ctitem = ctptr->ct_itemdescr;\n    if (ctitem->ct_size < 0) {\n        PyErr_Format(PyExc_ValueError, \"array item of unknown size: '%s'\",\n                     ctitem->ct_name);\n        return NULL;\n    }\n\n    if (length < 0) {\n        sprintf(extra_text, \"[]\");\n        length = -1;\n        arraysize = -1;\n        if ((ctitem->ct_flags & CT_PRIMITIVE_CHAR) &&\n                ctitem->ct_size == sizeof(char))\n            flags |= CT_IS_UNSIZED_CHAR_A;\n    }\n    else {\n        sprintf(extra_text, \"[%llu]\", (unsigned PY_LONG_LONG)length);\n        arraysize = length * ctitem->ct_size;\n        if (length > 0 && (arraysize / length) != ctitem->ct_size) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"array size would overflow a Py_ssize_t\");\n            return NULL;\n        }\n    }\n    td = ctypedescr_new_on_top(ctitem, extra_text, 0);\n    if (td == NULL)\n        return NULL;\n\n    Py_INCREF(ctptr);\n    td->ct_stuff = (PyObject *)ctptr;\n    td->ct_size = arraysize;\n    td->ct_length = length;\n    td->ct_flags = flags;\n    unique_key[0] = ctptr;\n    unique_key[1] = (void *)length;\n    return get_unique_type(td, unique_key, 2);\n}\n\nstatic PyObject *new_void_type(void)\n{\n    int name_size = strlen(\"void\") + 1;\n    const void *unique_key[1];\n    CTypeDescrObject *td = ctypedescr_new(name_size);\n    if (td == NULL)\n        return NULL;\n\n    memcpy(td->ct_name, \"void\", name_size);\n    td->ct_size = -1;\n    td->ct_flags = CT_VOID | CT_IS_OPAQUE;\n    td->ct_name_position = strlen(\"void\");\n    unique_key[0] = \"void\";\n    return get_unique_type(td, unique_key, 1);\n}\n\nstatic PyObject *b_new_void_type(PyObject *self, PyObject *args)\n{\n    return new_void_type();\n}\n\nstatic PyObject *new_struct_or_union_type(const char *name, int flag)\n{\n    int namelen = strlen(name);\n    CTypeDescrObject *td = ctypedescr_new(namelen + 1);\n    if (td == NULL)\n        return NULL;\n\n    td->ct_size = -1;\n    td->ct_length = -1;\n    td->ct_flags = flag | CT_IS_OPAQUE;\n    td->ct_extra = NULL;\n    memcpy(td->ct_name, name, namelen + 1);\n    td->ct_name_position = namelen;\n    return (PyObject *)td;\n}\n\nstatic PyObject *b_new_struct_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    int flag;\n    if (!PyArg_ParseTuple(args, \"s:new_struct_type\", &name))\n        return NULL;\n\n    flag = CT_STRUCT;\n    if (strcmp(name, \"struct _IO_FILE\") == 0 || strcmp(name, \"FILE\") == 0)\n        flag |= CT_IS_FILE;\n    return new_struct_or_union_type(name, flag);\n}\n\nstatic PyObject *b_new_union_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    if (!PyArg_ParseTuple(args, \"s:new_union_type\", &name))\n        return NULL;\n    return new_struct_or_union_type(name, CT_UNION);\n}\n\nstatic CFieldObject *\n_add_field(PyObject *interned_fields, PyObject *fname, CTypeDescrObject *ftype,\n           Py_ssize_t offset, int bitshift, int fbitsize)\n{\n    int err;\n    Py_ssize_t prev_size;\n    CFieldObject *cf = PyObject_New(CFieldObject, &CField_Type);\n    if (cf == NULL)\n        return NULL;\n\n    Py_INCREF(ftype);\n    cf->cf_type = ftype;\n    cf->cf_offset = offset;\n    cf->cf_bitshift = bitshift;\n    cf->cf_bitsize = fbitsize;\n\n    Py_INCREF(fname);\n    PyText_InternInPlace(&fname);\n    prev_size = PyDict_Size(interned_fields);\n    err = PyDict_SetItem(interned_fields, fname, (PyObject *)cf);\n    Py_DECREF(fname);\n    Py_DECREF(cf);\n    if (err < 0)\n        return NULL;\n\n    if (PyDict_Size(interned_fields) != prev_size + 1) {\n        PyErr_Format(PyExc_KeyError, \"duplicate field name '%s'\",\n                     PyText_AS_UTF8(fname));\n        return NULL;\n    }\n    return cf;   /* borrowed reference */\n}\n\n#define SF_MSVC_BITFIELDS     0x01\n#define SF_GCC_ARM_BITFIELDS  0x02\n#define SF_GCC_X86_BITFIELDS  0x10\n\n#define SF_GCC_BIG_ENDIAN     0x04\n#define SF_GCC_LITTLE_ENDIAN  0x40\n\n#define SF_PACKED             0x08\n#define SF_STD_FIELD_POS      0x80\n\nstatic int complete_sflags(int sflags)\n{\n    /* add one of the SF_xxx_BITFIELDS flags if none is specified */\n    if (!(sflags & (SF_MSVC_BITFIELDS | SF_GCC_ARM_BITFIELDS |\n                    SF_GCC_X86_BITFIELDS))) {\n#ifdef MS_WIN32\n        sflags |= SF_MSVC_BITFIELDS;\n#else\n# if defined(__arm__) || defined(__aarch64__)\n        sflags |= SF_GCC_ARM_BITFIELDS;\n# else\n        sflags |= SF_GCC_X86_BITFIELDS;\n# endif\n#endif\n    }\n    /* add one of SF_GCC_xx_ENDIAN if none is specified */\n    if (!(sflags & (SF_GCC_BIG_ENDIAN | SF_GCC_LITTLE_ENDIAN))) {\n        int _check_endian = 1;\n        if (*(char *)&_check_endian == 0)\n            sflags |= SF_GCC_BIG_ENDIAN;\n        else\n            sflags |= SF_GCC_LITTLE_ENDIAN;\n    }\n    return sflags;\n}\n\nstatic int detect_custom_layout(CTypeDescrObject *ct, int sflags,\n                                Py_ssize_t cdef_value,\n                                Py_ssize_t compiler_value,\n                                const char *msg1, const char *txt,\n                                const char *msg2)\n{\n    if (compiler_value != cdef_value) {\n        if (sflags & SF_STD_FIELD_POS) {\n            PyErr_Format(FFIError,\n                         \"%s: %s%s%s (cdef says %zd, but C compiler says %zd).\"\n                         \" fix it or use \\\"...;\\\" in the cdef for %s to \"\n                         \"make it flexible\",\n                         ct->ct_name, msg1, txt, msg2,\n                         cdef_value, compiler_value,\n                         ct->ct_name);\n            return -1;\n        }\n        ct->ct_flags |= CT_CUSTOM_FIELD_POS;\n    }\n    return 0;\n}\n\nstatic PyObject *b_complete_struct_or_union(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *fields, *interned_fields, *ignored;\n    int is_union, alignment;\n    Py_ssize_t boffset, i, nb_fields, boffsetmax, alignedsize;\n    Py_ssize_t totalsize = -1;\n    int totalalignment = -1;\n    CFieldObject **previous;\n    int prev_bitfield_size, prev_bitfield_free;\n    int sflags = 0;\n\n    if (!PyArg_ParseTuple(args, \"O!O!|Onii:complete_struct_or_union\",\n                          &CTypeDescr_Type, &ct,\n                          &PyList_Type, &fields,\n                          &ignored, &totalsize, &totalalignment, &sflags))\n        return NULL;\n\n    sflags = complete_sflags(sflags);\n\n    if ((ct->ct_flags & (CT_STRUCT|CT_IS_OPAQUE)) ==\n                        (CT_STRUCT|CT_IS_OPAQUE)) {\n        is_union = 0;\n    }\n    else if ((ct->ct_flags & (CT_UNION|CT_IS_OPAQUE)) ==\n                             (CT_UNION|CT_IS_OPAQUE)) {\n        is_union = 1;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                  \"first arg must be a non-initialized struct or union ctype\");\n        return NULL;\n    }\n    ct->ct_flags &= ~CT_CUSTOM_FIELD_POS;\n\n    alignment = 1;\n    boffset = 0;         /* this number is in *bits*, not bytes! */\n    boffsetmax = 0;      /* the maximum value of boffset, in bits too */\n    prev_bitfield_size = 0;\n    prev_bitfield_free = 0;\n    nb_fields = PyList_GET_SIZE(fields);\n    interned_fields = PyDict_New();\n    if (interned_fields == NULL)\n        return NULL;\n\n    previous = (CFieldObject **)&ct->ct_extra;\n\n    for (i=0; i<nb_fields; i++) {\n        PyObject *fname;\n        CTypeDescrObject *ftype;\n        int fbitsize = -1, falign, do_align;\n        Py_ssize_t foffset = -1;\n\n        if (!PyArg_ParseTuple(PyList_GET_ITEM(fields, i), \"O!O!|in:list item\",\n                              &PyText_Type, &fname,\n                              &CTypeDescr_Type, &ftype,\n                              &fbitsize, &foffset))\n            goto error;\n\n        if (ftype->ct_size < 0) {\n            if ((ftype->ct_flags & CT_ARRAY) && fbitsize < 0\n                    && (i == nb_fields - 1 || foffset != -1)) {\n                ct->ct_flags |= CT_WITH_VAR_ARRAY;\n            }\n            else {\n                PyErr_Format(PyExc_TypeError,\n                             \"field '%s.%s' has ctype '%s' of unknown size\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name);\n                goto error;\n            }\n        }\n\n        if (is_union)\n            boffset = 0;   /* reset each field at offset 0 */\n\n        /* update the total alignment requirement, but skip it if the\n           field is an anonymous bitfield or if SF_PACKED */\n        falign = (sflags & SF_PACKED) ? 1 : get_alignment(ftype);\n        if (falign < 0)\n            goto error;\n\n        do_align = 1;\n        if (!(sflags & SF_GCC_ARM_BITFIELDS) && fbitsize >= 0) {\n            if (!(sflags & SF_MSVC_BITFIELDS)) {\n                /* GCC: anonymous bitfields (of any size) don't cause alignment */\n                do_align = PyText_GetSize(fname) > 0;\n            }\n            else {\n                /* MSVC: zero-sized bitfields don't cause alignment */\n                do_align = fbitsize > 0;\n            }\n        }\n        if (alignment < falign && do_align)\n            alignment = falign;\n\n        if (fbitsize < 0) {\n            /* not a bitfield: common case */\n            int bs_flag;\n\n            if (ftype->ct_flags & CT_ARRAY && ftype->ct_length == 0)\n                bs_flag = BS_EMPTY_ARRAY;\n            else\n                bs_flag = BS_REGULAR;\n\n            /* align this field to its own 'falign' by inserting padding */\n            boffset = (boffset + falign*8-1) & ~(falign*8-1); /* bits! */\n\n            if (foffset >= 0) {\n                /* a forced field position: ignore the offset just computed,\n                   except to know if we must set CT_CUSTOM_FIELD_POS */\n                if (detect_custom_layout(ct, sflags, boffset / 8, foffset,\n                                         \"wrong offset for field '\",\n                                         PyText_AS_UTF8(fname), \"'\") < 0)\n                    goto error;\n                boffset = foffset * 8;\n            }\n\n            if (PyText_GetSize(fname) == 0 &&\n                    ftype->ct_flags & (CT_STRUCT|CT_UNION)) {\n                /* a nested anonymous struct or union */\n                CFieldObject *cfsrc = (CFieldObject *)ftype->ct_extra;\n                for (; cfsrc != NULL; cfsrc = cfsrc->cf_next) {\n                    /* broken complexity in the call to get_field_name(),\n                       but we'll assume you never do that with nested\n                       anonymous structures with thousand of fields */\n                    *previous = _add_field(interned_fields,\n                                           get_field_name(ftype, cfsrc),\n                                           cfsrc->cf_type,\n                                           boffset / 8 + cfsrc->cf_offset,\n                                           cfsrc->cf_bitshift,\n                                           cfsrc->cf_bitsize);\n                    if (*previous == NULL)\n                        goto error;\n                    previous = &(*previous)->cf_next;\n                }\n                /* always forbid such structures from being passed by value */\n                ct->ct_flags |= CT_CUSTOM_FIELD_POS;\n            }\n            else {\n                *previous = _add_field(interned_fields, fname, ftype,\n                                        boffset / 8, bs_flag, -1);\n                if (*previous == NULL)\n                    goto error;\n                previous = &(*previous)->cf_next;\n            }\n            if (ftype->ct_size >= 0)\n                boffset += ftype->ct_size * 8;\n            prev_bitfield_size = 0;\n        }\n        else {\n            /* this is the case of a bitfield */\n            Py_ssize_t field_offset_bytes;\n            int bits_already_occupied, bitshift;\n\n            if (foffset >= 0) {\n                PyErr_Format(PyExc_TypeError,\n                             \"field '%s.%s' is a bitfield, \"\n                             \"but a fixed offset is specified\",\n                             ct->ct_name, PyText_AS_UTF8(fname));\n                goto error;\n            }\n\n            if (!(ftype->ct_flags & (CT_PRIMITIVE_SIGNED |\n                                     CT_PRIMITIVE_UNSIGNED |\n                                     CT_PRIMITIVE_CHAR))) {\n                PyErr_Format(PyExc_TypeError,\n                        \"field '%s.%s' declared as '%s' cannot be a bit field\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name);\n                goto error;\n            }\n            if (fbitsize > 8 * ftype->ct_size) {\n                PyErr_Format(PyExc_TypeError,\n                             \"bit field '%s.%s' is declared '%s:%d', which \"\n                             \"exceeds the width of the type\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name, fbitsize);\n                goto error;\n            }\n\n            /* compute the starting position of the theoretical field\n               that covers a complete 'ftype', inside of which we will\n               locate the real bitfield */\n            field_offset_bytes = boffset / 8;\n            field_offset_bytes &= ~(falign - 1);\n\n            if (fbitsize == 0) {\n                if (PyText_GetSize(fname) > 0) {\n                    PyErr_Format(PyExc_TypeError,\n                                 \"field '%s.%s' is declared with :0\",\n                                 ct->ct_name, PyText_AS_UTF8(fname));\n                    goto error;\n                }\n                if (!(sflags & SF_MSVC_BITFIELDS)) {\n                    /* GCC's notion of \"ftype :0;\" */\n\n                    /* pad boffset to a value aligned for \"ftype\" */\n                    if (boffset > field_offset_bytes * 8) {\n                        field_offset_bytes += falign;\n                        assert(boffset < field_offset_bytes * 8);\n                    }\n                    boffset = field_offset_bytes * 8;\n                }\n                else {\n                    /* MSVC's notion of \"ftype :0;\" */\n\n                    /* Mostly ignored.  It seems they only serve as\n                       separator between other bitfields, to force them\n                       into separate words. */\n                }\n                prev_bitfield_size = 0;\n            }\n            else {\n                if (!(sflags & SF_MSVC_BITFIELDS)) {\n                    /* GCC's algorithm */\n\n                    /* Can the field start at the offset given by 'boffset'?  It\n                       can if it would entirely fit into an aligned ftype field. */\n                    bits_already_occupied = boffset - (field_offset_bytes * 8);\n\n                    if (bits_already_occupied + fbitsize > 8 * ftype->ct_size) {\n                        /* it would not fit, we need to start at the next\n                           allowed position */\n                        if ((sflags & SF_PACKED) &&\n                            (bits_already_occupied & 7)) {\n                            PyErr_Format(PyExc_NotImplementedError,\n                                \"with 'packed', gcc would compile field \"\n                                \"'%s.%s' to reuse some bits in the previous \"\n                                \"field\", ct->ct_name, PyText_AS_UTF8(fname));\n                            goto error;\n                        }\n                        field_offset_bytes += falign;\n                        assert(boffset < field_offset_bytes * 8);\n                        boffset = field_offset_bytes * 8;\n                        bitshift = 0;\n                    }\n                    else {\n                        bitshift = bits_already_occupied;\n                        assert(bitshift >= 0);\n                    }\n                    boffset += fbitsize;\n                }\n                else {\n                    /* MSVC's algorithm */\n\n                    /* A bitfield is considered as taking the full width\n                       of their declared type.  It can share some bits\n                       with the previous field only if it was also a\n                       bitfield and used a type of the same size. */\n                    if (prev_bitfield_size == ftype->ct_size &&\n                        prev_bitfield_free >= fbitsize) {\n                        /* yes: reuse */\n                        bitshift = 8 * prev_bitfield_size - prev_bitfield_free;\n                    }\n                    else {\n                        /* no: start a new full field */\n                        boffset = (boffset + falign*8-1) & ~(falign*8-1); /*align*/\n                        boffset += ftype->ct_size * 8;\n                        bitshift = 0;\n                        prev_bitfield_size = ftype->ct_size;\n                        prev_bitfield_free = 8 * prev_bitfield_size;\n                    }\n                    prev_bitfield_free -= fbitsize;\n                    field_offset_bytes = boffset / 8 - ftype->ct_size;\n                }\n\n                if (sflags & SF_GCC_BIG_ENDIAN)\n                    bitshift = 8 * ftype->ct_size - fbitsize - bitshift;\n\n                *previous = _add_field(interned_fields, fname, ftype,\n                                       field_offset_bytes, bitshift, fbitsize);\n                if (*previous == NULL)\n                    goto error;\n                previous = &(*previous)->cf_next;\n            }\n        }\n\n        if (boffset > boffsetmax)\n            boffsetmax = boffset;\n    }\n    *previous = NULL;\n\n    /* Like C, if the size of this structure would be zero, we compute it\n       as 1 instead.  But for ctypes support, we allow the manually-\n       specified totalsize to be zero in this case. */\n    boffsetmax = (boffsetmax + 7) / 8;        /* bits -> bytes */\n    alignedsize = (boffsetmax + alignment - 1) & ~(alignment-1);\n    if (alignedsize == 0)\n        alignedsize = 1;\n\n    if (totalsize < 0) {\n        totalsize = alignedsize;\n    }\n    else {\n        if (detect_custom_layout(ct, sflags, alignedsize,\n                                 totalsize, \"wrong total size\", \"\", \"\") < 0)\n            goto error;\n        if (totalsize < boffsetmax) {\n            PyErr_Format(PyExc_TypeError,\n                         \"%s cannot be of size %zd: there are fields at least \"\n                         \"up to %zd\", ct->ct_name, totalsize, boffsetmax);\n            goto error;\n        }\n    }\n    if (totalalignment < 0) {\n        totalalignment = alignment;\n    }\n    else {\n        if (detect_custom_layout(ct, sflags, alignment, totalalignment,\n                                 \"wrong total alignment\", \"\", \"\") < 0)\n            goto error;\n    }\n\n    ct->ct_size = totalsize;\n    ct->ct_length = totalalignment;\n    ct->ct_stuff = interned_fields;\n    ct->ct_flags &= ~CT_IS_OPAQUE;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n\n error:\n    ct->ct_extra = NULL;\n    Py_DECREF(interned_fields);\n    return NULL;\n}\n\nstruct funcbuilder_s {\n    Py_ssize_t nb_bytes;\n    char *bufferp;\n    ffi_type **atypes;\n    ffi_type *rtype;\n    Py_ssize_t nargs;\n    CTypeDescrObject *fct;\n};\n\nstatic void *fb_alloc(struct funcbuilder_s *fb, Py_ssize_t size)\n{\n    if (fb->bufferp == NULL) {\n        fb->nb_bytes += size;\n        return NULL;\n    }\n    else {\n        char *result = fb->bufferp;\n        fb->bufferp += size;\n        return result;\n    }\n}\n\nstatic ffi_type *fb_fill_type(struct funcbuilder_s *fb, CTypeDescrObject *ct,\n                              int is_result_type)\n{\n    const char *place = is_result_type ? \"return value\" : \"argument\";\n\n    if (ct->ct_flags & CT_PRIMITIVE_ANY) {\n        return (ffi_type *)ct->ct_extra;\n    }\n    else if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        return &ffi_type_pointer;\n    }\n    else if ((ct->ct_flags & CT_VOID) && is_result_type) {\n        return &ffi_type_void;\n    }\n\n    if (ct->ct_size <= 0) {\n        PyErr_Format(PyExc_TypeError,\n                     ct->ct_size < 0 ? \"ctype '%s' has incomplete type\"\n                                     : \"ctype '%s' has size 0\",\n                     ct->ct_name);\n        return NULL;\n    }\n    if (ct->ct_flags & CT_STRUCT) {\n        ffi_type *ffistruct, *ffifield;\n        ffi_type **elements;\n        Py_ssize_t i, n, nflat;\n        CFieldObject *cf;\n\n        /* We can't pass a struct that was completed by verify().\n           Issue: assume verify() is given \"struct { long b; ...; }\".\n           Then it will complete it in the same way whether it is actually\n           \"struct { long a, b; }\" or \"struct { double a; long b; }\".\n           But on 64-bit UNIX, these two structs are passed by value\n           differently: e.g. on x86-64, \"b\" ends up in register \"rsi\" in\n           the first case and \"rdi\" in the second case.\n\n           Another reason for CT_CUSTOM_FIELD_POS would be anonymous\n           nested structures: we lost the information about having it\n           here, so better safe (and forbid it) than sorry (and maybe\n           crash).\n        */\n        if (force_lazy_struct(ct) < 0)\n            return NULL;\n        if (ct->ct_flags & CT_CUSTOM_FIELD_POS) {\n            /* these NotImplementedErrors may be caught and ignored until\n               a real call is made to a function of this type */\n            PyErr_Format(PyExc_NotImplementedError,\n                \"ctype '%s' not supported as %s (it is a struct declared \"\n                \"with \\\"...;\\\", but the C calling convention may depend \"\n                \"on the missing fields)\", ct->ct_name, place);\n            return NULL;\n        }\n\n        n = PyDict_Size(ct->ct_stuff);\n        nflat = 0;\n\n        /* walk the fields, expanding arrays into repetitions; first,\n           only count how many flattened fields there are */\n        cf = (CFieldObject *)ct->ct_extra;\n        for (i=0; i<n; i++) {\n            Py_ssize_t flat;\n            CTypeDescrObject *ct1;\n            assert(cf != NULL);\n            if (cf->cf_bitshift >= 0) {\n                PyErr_Format(PyExc_NotImplementedError,\n                     \"ctype '%s' not supported as %s\"\n                     \" (it is a struct with bit fields)\",\n                     ct->ct_name, place);\n                return NULL;\n            }\n            flat = 1;\n            ct1 = cf->cf_type;\n            while (ct1->ct_flags & CT_ARRAY) {\n                flat *= ct1->ct_length;\n                ct1 = ct1->ct_itemdescr;\n            }\n            if (flat <= 0) {\n                PyErr_Format(PyExc_NotImplementedError,\n                     \"ctype '%s' not supported as %s\"\n                     \" (it is a struct with a zero-length array)\",\n                     ct->ct_name, place);\n                return NULL;\n            }\n            nflat += flat;\n            cf = cf->cf_next;\n        }\n        assert(cf == NULL);\n\n        /* next, allocate and fill the flattened list */\n        elements = fb_alloc(fb, (nflat + 1) * sizeof(ffi_type*));\n        nflat = 0;\n        cf = (CFieldObject *)ct->ct_extra;\n        for (i=0; i<n; i++) {\n            Py_ssize_t j, flat = 1;\n            CTypeDescrObject *ct = cf->cf_type;\n            while (ct->ct_flags & CT_ARRAY) {\n                flat *= ct->ct_length;\n                ct = ct->ct_itemdescr;\n            }\n            ffifield = fb_fill_type(fb, ct, 0);\n            if (elements != NULL) {\n                for (j=0; j<flat; j++)\n                    elements[nflat++] = ffifield;\n            }\n            cf = cf->cf_next;\n        }\n\n        /* finally, allocate the FFI_TYPE_STRUCT */\n        ffistruct = fb_alloc(fb, sizeof(ffi_type));\n        if (ffistruct != NULL) {\n            elements[nflat] = NULL;\n            ffistruct->size = ct->ct_size;\n            ffistruct->alignment = ct->ct_length;\n            ffistruct->type = FFI_TYPE_STRUCT;\n            ffistruct->elements = elements;\n        }\n        return ffistruct;\n    }\n    else {\n        PyErr_Format(PyExc_NotImplementedError,\n                     \"ctype '%s' (size %zd) not supported as %s\",\n                     ct->ct_name, ct->ct_size, place);\n        return NULL;\n    }\n}\n\n#define ALIGN_ARG(n)  ((n) + 7) & ~7\n\nstatic int fb_build(struct funcbuilder_s *fb, PyObject *fargs,\n                    CTypeDescrObject *fresult)\n{\n    Py_ssize_t i, nargs = PyTuple_GET_SIZE(fargs);\n    Py_ssize_t exchange_offset;\n    cif_description_t *cif_descr;\n\n    /* ffi buffer: start with a cif_description */\n    cif_descr = fb_alloc(fb, sizeof(cif_description_t) +\n                             nargs * sizeof(Py_ssize_t));\n\n    /* ffi buffer: next comes an array of 'ffi_type*', one per argument */\n    fb->atypes = fb_alloc(fb, nargs * sizeof(ffi_type*));\n    fb->nargs = nargs;\n\n    /* ffi buffer: next comes the result type */\n    fb->rtype = fb_fill_type(fb, fresult, 1);\n    if (PyErr_Occurred())\n        return -1;\n    if (cif_descr != NULL) {\n        /* exchange data size */\n        /* first, enough room for an array of 'nargs' pointers */\n        exchange_offset = nargs * sizeof(void*);\n        exchange_offset = ALIGN_ARG(exchange_offset);\n        cif_descr->exchange_offset_arg[0] = exchange_offset;\n        /* then enough room for the result --- which means at least\n           sizeof(ffi_arg), according to the ffi docs */\n        i = fb->rtype->size;\n        if (i < (Py_ssize_t)sizeof(ffi_arg))\n            i = sizeof(ffi_arg);\n        exchange_offset += i;\n    }\n    else\n        exchange_offset = 0;   /* not used */\n\n    /* loop over the arguments */\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *farg;\n        ffi_type *atype;\n\n        farg = (CTypeDescrObject *)PyTuple_GET_ITEM(fargs, i);\n        /* convert arrays to pointers */\n        if (farg->ct_flags & CT_ARRAY)\n            farg = (CTypeDescrObject *)farg->ct_stuff;\n\n        /* ffi buffer: fill in the ffi for the i'th argument */\n        assert(farg != NULL);\n        atype = fb_fill_type(fb, farg, 0);\n        if (PyErr_Occurred())\n            return -1;\n\n        if (fb->atypes != NULL) {\n            fb->atypes[i] = atype;\n            /* exchange data size */\n            exchange_offset = ALIGN_ARG(exchange_offset);\n            cif_descr->exchange_offset_arg[1 + i] = exchange_offset;\n            exchange_offset += atype->size;\n        }\n    }\n\n    if (cif_descr != NULL) {\n        /* exchange data size */\n        cif_descr->exchange_size = exchange_offset;\n    }\n    return 0;\n}\n\n#undef ALIGN_ARG\n\nstatic void fb_cat_name(struct funcbuilder_s *fb, char *piece, int piecelen)\n{\n    if (fb->bufferp == NULL) {\n        fb->nb_bytes += piecelen;\n    }\n    else {\n        memcpy(fb->bufferp, piece, piecelen);\n        fb->bufferp += piecelen;\n    }\n}\n\nstatic int fb_build_name(struct funcbuilder_s *fb, PyObject *fargs,\n                         CTypeDescrObject *fresult, int ellipsis)\n{\n    Py_ssize_t i, nargs = PyTuple_GET_SIZE(fargs);\n    fb->nargs = nargs;\n\n    /* name: the function type name we build here is, like in C, made\n       as follows:\n\n         RESULT_TYPE_HEAD (*)(ARG_1_TYPE, ARG_2_TYPE, etc) RESULT_TYPE_TAIL\n    */\n    fb_cat_name(fb, fresult->ct_name, fresult->ct_name_position);\n    fb_cat_name(fb, \"(*)(\", 4);\n    if (fb->fct) {\n        i = fresult->ct_name_position + 2;  /* between '(*' and ')(' */\n        fb->fct->ct_name_position = i;\n    }\n\n    /* loop over the arguments */\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *farg;\n\n        farg = (CTypeDescrObject *)PyTuple_GET_ITEM(fargs, i);\n        if (!CTypeDescr_Check(farg)) {\n            PyErr_SetString(PyExc_TypeError, \"expected a tuple of ctypes\");\n            return -1;\n        }\n        /* name: concatenate the name of the i'th argument's type */\n        if (i > 0)\n            fb_cat_name(fb, \", \", 2);\n        fb_cat_name(fb, farg->ct_name, strlen(farg->ct_name));\n    }\n\n    /* name: add the '...' if needed */\n    if (ellipsis) {\n        if (nargs > 0)\n            fb_cat_name(fb, \", \", 2);\n        fb_cat_name(fb, \"...\", 3);\n    }\n\n    /* name: concatenate the tail of the result type */\n    fb_cat_name(fb, \")\", 1);\n    fb_cat_name(fb, fresult->ct_name + fresult->ct_name_position,\n                strlen(fresult->ct_name) - fresult->ct_name_position + 1);\n    return 0;\n}\n\nstatic CTypeDescrObject *fb_prepare_ctype(struct funcbuilder_s *fb,\n                                          PyObject *fargs,\n                                          CTypeDescrObject *fresult,\n                                          int ellipsis)\n{\n    CTypeDescrObject *fct;\n\n    fb->nb_bytes = 0;\n    fb->bufferp = NULL;\n    fb->fct = NULL;\n\n    /* compute the total size needed for the name */\n    if (fb_build_name(fb, fargs, fresult, ellipsis) < 0)\n        return NULL;\n\n    /* allocate the function type */\n    fct = ctypedescr_new(fb->nb_bytes);\n    if (fct == NULL)\n        return NULL;\n    fb->fct = fct;\n\n    /* call again fb_build_name() to really build the ct_name */\n    fb->bufferp = fct->ct_name;\n    if (fb_build_name(fb, fargs, fresult, ellipsis) < 0)\n        goto error;\n    assert(fb->bufferp == fct->ct_name + fb->nb_bytes);\n\n    fct->ct_extra = NULL;\n    fct->ct_size = sizeof(void(*)(void));\n    fct->ct_flags = CT_FUNCTIONPTR;\n    return fct;\n\n error:\n    Py_DECREF(fct);\n    return NULL;\n}\n\nstatic cif_description_t *fb_prepare_cif(PyObject *fargs,\n                                         CTypeDescrObject *fresult,\n                                         ffi_abi fabi)\n{\n    char *buffer;\n    cif_description_t *cif_descr;\n    struct funcbuilder_s funcbuffer;\n\n    funcbuffer.nb_bytes = 0;\n    funcbuffer.bufferp = NULL;\n\n    /* compute the total size needed in the buffer for libffi */\n    if (fb_build(&funcbuffer, fargs, fresult) < 0)\n        return NULL;\n\n    /* allocate the buffer */\n    buffer = PyObject_Malloc(funcbuffer.nb_bytes);\n    if (buffer == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    /* call again fb_build() to really build the libffi data structures */\n    funcbuffer.bufferp = buffer;\n    if (fb_build(&funcbuffer, fargs, fresult) < 0)\n        goto error;\n    assert(funcbuffer.bufferp == buffer + funcbuffer.nb_bytes);\n\n    cif_descr = (cif_description_t *)buffer;\n    if (ffi_prep_cif(&cif_descr->cif, fabi, funcbuffer.nargs,\n                     funcbuffer.rtype, funcbuffer.atypes) != FFI_OK) {\n        PyErr_SetString(PyExc_SystemError,\n                        \"libffi failed to build this function type\");\n        goto error;\n    }\n    return cif_descr;\n\n error:\n    PyObject_Free(buffer);\n    return NULL;\n}\n\nstatic PyObject *new_function_type(PyObject *fargs,   /* tuple */\n                                   CTypeDescrObject *fresult,\n                                   int ellipsis, int fabi)\n{\n    PyObject *fabiobj;\n    CTypeDescrObject *fct;\n    struct funcbuilder_s funcbuilder;\n    Py_ssize_t i;\n    const void **unique_key;\n\n    if ((fresult->ct_size < 0 && !(fresult->ct_flags & CT_VOID)) ||\n        (fresult->ct_flags & CT_ARRAY)) {\n        char *msg;\n        if (fresult->ct_flags & CT_IS_OPAQUE)\n            msg = \"result type '%s' is opaque\";\n        else\n            msg = \"invalid result type: '%s'\";\n        PyErr_Format(PyExc_TypeError, msg, fresult->ct_name);\n        return NULL;\n    }\n\n    fct = fb_prepare_ctype(&funcbuilder, fargs, fresult, ellipsis);\n    if (fct == NULL)\n        return NULL;\n\n    if (!ellipsis) {\n        /* Functions with '...' varargs are stored without a cif_descr\n           at all.  The cif is computed on every call from the actual\n           types passed in.  For all other functions, the cif_descr\n           is computed here. */\n        cif_description_t *cif_descr;\n\n        cif_descr = fb_prepare_cif(fargs, fresult, fabi);\n        if (cif_descr == NULL) {\n            if (PyErr_ExceptionMatches(PyExc_NotImplementedError)) {\n                PyErr_Clear();   /* will get the exception if we see an\n                                    actual call */\n            }\n            else\n                goto error;\n        }\n\n        fct->ct_extra = (char *)cif_descr;\n    }\n\n    /* build the signature, given by a tuple of ctype objects */\n    fct->ct_stuff = PyTuple_New(2 + funcbuilder.nargs);\n    if (fct->ct_stuff == NULL)\n        goto error;\n    fabiobj = PyInt_FromLong(fabi);\n    if (fabiobj == NULL)\n        goto error;\n    PyTuple_SET_ITEM(fct->ct_stuff, 0, fabiobj);\n\n    Py_INCREF(fresult);\n    PyTuple_SET_ITEM(fct->ct_stuff, 1, (PyObject *)fresult);\n    for (i=0; i<funcbuilder.nargs; i++) {\n        PyObject *o = PyTuple_GET_ITEM(fargs, i);\n        /* convert arrays into pointers */\n        if (((CTypeDescrObject *)o)->ct_flags & CT_ARRAY)\n            o = ((CTypeDescrObject *)o)->ct_stuff;\n        Py_INCREF(o);\n        PyTuple_SET_ITEM(fct->ct_stuff, 2 + i, o);\n    }\n\n    /* [ctresult, ellipsis+abi, num_args, ctargs...] */\n    unique_key = alloca((3 + funcbuilder.nargs) * sizeof(void *));\n    unique_key[0] = fresult;\n    unique_key[1] = (const void *)(Py_ssize_t)((fabi << 1) | !!ellipsis);\n    unique_key[2] = (const void *)(Py_ssize_t)(funcbuilder.nargs);\n    for (i=0; i<funcbuilder.nargs; i++)\n        unique_key[3 + i] = PyTuple_GET_ITEM(fct->ct_stuff, 2 + i);\n    return get_unique_type(fct, unique_key, 3 + funcbuilder.nargs);\n\n error:\n    Py_DECREF(fct);\n    return NULL;\n}\n\nstatic PyObject *b_new_function_type(PyObject *self, PyObject *args)\n{\n    PyObject *fargs;\n    CTypeDescrObject *fresult;\n    int ellipsis = 0, fabi = FFI_DEFAULT_ABI;\n\n    if (!PyArg_ParseTuple(args, \"O!O!|ii:new_function_type\",\n                          &PyTuple_Type, &fargs,\n                          &CTypeDescr_Type, &fresult,\n                          &ellipsis,\n                          &fabi))\n        return NULL;\n\n    return new_function_type(fargs, fresult, ellipsis, fabi);\n}\n\nstatic int convert_from_object_fficallback(char *result,\n                                           CTypeDescrObject *ctype,\n                                           PyObject *pyobj)\n{\n    /* work work work around a libffi irregularity: for integer return\n       types we have to fill at least a complete 'ffi_arg'-sized result\n       buffer. */\n    if (ctype->ct_size < (Py_ssize_t)sizeof(ffi_arg)) {\n        if (ctype->ct_flags & CT_VOID) {\n            if (pyobj == Py_None) {\n                return 0;\n            }\n            else {\n                PyErr_SetString(PyExc_TypeError,\n                    \"callback with the return type 'void' must return None\");\n                return -1;\n            }\n        }\n        if (ctype->ct_flags & CT_PRIMITIVE_SIGNED) {\n            PY_LONG_LONG value;\n            /* It's probably fine to always zero-extend, but you never\n               know: maybe some code somewhere expects a negative\n               'short' result to be returned into EAX as a 32-bit\n               negative number.  Better safe than sorry.  This code\n               is about that case.  Let's ignore this for enums.\n            */\n            /* do a first conversion only to detect overflows.  This\n               conversion produces stuff that is otherwise ignored. */\n            if (convert_from_object(result, ctype, pyobj) < 0)\n                return -1;\n            /* manual inlining and tweaking of convert_from_object()\n               in order to write a whole 'ffi_arg'. */\n            value = _my_PyLong_AsLongLong(pyobj);\n            if (value == -1 && PyErr_Occurred())\n                return -1;\n            write_raw_integer_data(result, value, sizeof(ffi_arg));\n            return 0;\n        }\n        else if (ctype->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_SIGNED |\n                                    CT_PRIMITIVE_UNSIGNED)) {\n            /* zero extension: fill the '*result' with zeros, and (on big-\n               endian machines) correct the 'result' pointer to write to */\n            memset(result, 0, sizeof(ffi_arg));\n#ifdef WORDS_BIGENDIAN\n            result += (sizeof(ffi_arg) - ctype->ct_size);\n#endif\n        }\n    }\n    return convert_from_object(result, ctype, pyobj);\n}\n\nstatic void _my_PyErr_WriteUnraisable(PyObject *obj, char *extra_error_line)\n{\n    /* like PyErr_WriteUnraisable(), but write a full traceback */\n    PyObject *f, *t, *v, *tb;\n    PyErr_Fetch(&t, &v, &tb);\n#if PY_MAJOR_VERSION >= 3\n    /* jump through hoops to ensure the tb is attached to v, on Python 3 */\n    PyErr_NormalizeException(&t, &v, &tb);\n    if (tb == NULL) {\n        tb = Py_None;\n        Py_INCREF(tb);\n    }\n    PyException_SetTraceback(v, tb);\n#endif\n    f = PySys_GetObject(\"stderr\");\n    if (f != NULL) {\n        PyFile_WriteString(\"From cffi callback \", f);\n        PyFile_WriteObject(obj, f, 0);\n        PyFile_WriteString(\":\\n\", f);\n        if (extra_error_line != NULL)\n            PyFile_WriteString(extra_error_line, f);\n        PyErr_Display(t, v, tb);\n    }\n    Py_XDECREF(t);\n    Py_XDECREF(v);\n    Py_XDECREF(tb);\n}\n\nstatic void invoke_callback(ffi_cif *cif, void *result, void **args,\n                            void *userdata)\n{\n    save_errno();\n    {\n#ifdef WITH_THREAD\n    PyGILState_STATE state = PyGILState_Ensure();\n#endif\n    PyObject *cb_args = (PyObject *)userdata;\n    CTypeDescrObject *ct = (CTypeDescrObject *)PyTuple_GET_ITEM(cb_args, 0);\n    PyObject *signature = ct->ct_stuff;\n    PyObject *py_ob = PyTuple_GET_ITEM(cb_args, 1);\n    PyObject *py_args = NULL;\n    PyObject *py_res = NULL;\n    PyObject *py_rawerr;\n    Py_ssize_t i, n;\n    char *extra_error_line = NULL;\n\n#define SIGNATURE(i)  ((CTypeDescrObject *)PyTuple_GET_ITEM(signature, i))\n\n    Py_INCREF(cb_args);\n\n    n = PyTuple_GET_SIZE(signature) - 2;\n    py_args = PyTuple_New(n);\n    if (py_args == NULL)\n        goto error;\n\n    for (i=0; i<n; i++) {\n        PyObject *a = convert_to_object(args[i], SIGNATURE(2 + i));\n        if (a == NULL)\n            goto error;\n        PyTuple_SET_ITEM(py_args, i, a);\n    }\n\n    py_res = PyEval_CallObject(py_ob, py_args);\n    if (py_res == NULL)\n        goto error;\n    if (convert_from_object_fficallback(result, SIGNATURE(1), py_res) < 0) {\n        extra_error_line = \"Trying to convert the result back to C:\\n\";\n        goto error;\n    }\n done:\n    Py_XDECREF(py_args);\n    Py_XDECREF(py_res);\n    Py_DECREF(cb_args);\n#ifdef WITH_THREAD\n    PyGILState_Release(state);\n#endif\n    restore_errno();\n    return;\n\n error:\n    _my_PyErr_WriteUnraisable(py_ob, extra_error_line);\n    if (SIGNATURE(1)->ct_size > 0) {\n        py_rawerr = PyTuple_GET_ITEM(cb_args, 2);\n        memcpy(result, PyBytes_AS_STRING(py_rawerr),\n                       PyBytes_GET_SIZE(py_rawerr));\n    }\n    goto done;\n    }\n\n#undef SIGNATURE\n}\n\nstatic PyObject *b_callback(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct, *ctresult;\n    CDataObject *cd;\n    PyObject *ob, *error_ob = Py_None;\n    PyObject *py_rawerr, *infotuple = NULL;\n    cif_description_t *cif_descr;\n    ffi_closure *closure;\n    Py_ssize_t size;\n\n    if (!PyArg_ParseTuple(args, \"O!O|O:callback\", &CTypeDescr_Type, &ct, &ob,\n                          &error_ob))\n        return NULL;\n\n    if (!(ct->ct_flags & CT_FUNCTIONPTR)) {\n        PyErr_Format(PyExc_TypeError, \"expected a function ctype, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n    if (!PyCallable_Check(ob)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a callable object, not %.200s\",\n                     Py_TYPE(ob)->tp_name);\n        return NULL;\n    }\n\n    ctresult = (CTypeDescrObject *)PyTuple_GET_ITEM(ct->ct_stuff, 1);\n    size = ctresult->ct_size;\n    if (size < (Py_ssize_t)sizeof(ffi_arg))\n        size = sizeof(ffi_arg);\n    py_rawerr = PyBytes_FromStringAndSize(NULL, size);\n    if (py_rawerr == NULL)\n        return NULL;\n    memset(PyBytes_AS_STRING(py_rawerr), 0, size);\n    if (error_ob != Py_None) {\n        if (convert_from_object_fficallback(\n                PyBytes_AS_STRING(py_rawerr), ctresult, error_ob) < 0) {\n            Py_DECREF(py_rawerr);\n            return NULL;\n        }\n    }\n    infotuple = Py_BuildValue(\"OOO\", ct, ob, py_rawerr);\n    Py_DECREF(py_rawerr);\n    if (infotuple == NULL)\n        return NULL;\n\n    closure = cffi_closure_alloc();\n\n    cd = PyObject_GC_New(CDataObject, &CDataOwningGC_Type);\n    if (cd == NULL)\n        goto error;\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_data = (char *)closure;\n    cd->c_weakreflist = NULL;\n    PyObject_GC_Track(cd);\n\n    cif_descr = (cif_description_t *)ct->ct_extra;\n    if (cif_descr == NULL) {\n        PyErr_Format(PyExc_NotImplementedError,\n                     \"%s: callback with unsupported argument or \"\n                     \"return type or with '...'\", ct->ct_name);\n        goto error;\n    }\n    if (ffi_prep_closure(closure, &cif_descr->cif,\n                         invoke_callback, infotuple) != FFI_OK) {\n        PyErr_SetString(PyExc_SystemError,\n                        \"libffi failed to build this callback\");\n        goto error;\n    }\n    assert(closure->user_data == infotuple);\n#ifdef WITH_THREAD\n    PyEval_InitThreads();\n#endif\n    return (PyObject *)cd;\n\n error:\n    closure->user_data = NULL;\n    if (cd == NULL)\n        cffi_closure_free(closure);\n    else\n        Py_DECREF(cd);\n    Py_XDECREF(infotuple);\n    return NULL;\n}\n\nstatic PyObject *b_new_enum_type(PyObject *self, PyObject *args)\n{\n    char *ename;\n    PyObject *enumerators, *enumvalues;\n    PyObject *dict1 = NULL, *dict2 = NULL, *combined = NULL, *tmpkey = NULL;\n    int name_size;\n    CTypeDescrObject *td, *basetd;\n    Py_ssize_t i, n;\n\n    if (!PyArg_ParseTuple(args, \"sO!O!O!:new_enum_type\",\n                          &ename,\n                          &PyTuple_Type, &enumerators,\n                          &PyTuple_Type, &enumvalues,\n                          &CTypeDescr_Type, &basetd))\n        return NULL;\n\n    n = PyTuple_GET_SIZE(enumerators);\n    if (n != PyTuple_GET_SIZE(enumvalues)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"tuple args must have the same size\");\n        return NULL;\n    }\n\n    if (!(basetd->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a primitive signed or unsigned base type\");\n        return NULL;\n    }\n\n    dict1 = PyDict_New();\n    if (dict1 == NULL)\n        goto error;\n    dict2 = PyDict_New();\n    if (dict2 == NULL)\n        goto error;\n\n    for (i=n; --i >= 0; ) {\n        long long lvalue;\n        PyObject *value = PyTuple_GET_ITEM(enumvalues, i);\n        tmpkey = PyTuple_GET_ITEM(enumerators, i);\n        Py_INCREF(tmpkey);\n        if (!PyText_Check(tmpkey)) {\n#if PY_MAJOR_VERSION < 3\n            if (PyUnicode_Check(tmpkey)) {\n                char *text = PyText_AsUTF8(tmpkey);\n                if (text == NULL)\n                    goto error;\n                Py_DECREF(tmpkey);\n                tmpkey = PyString_FromString(text);\n                if (tmpkey == NULL)\n                    goto error;\n            }\n            else\n#endif\n            {\n                PyErr_SetString(PyExc_TypeError,\n                                \"enumerators must be a list of strings\");\n                goto error;\n            }\n        }\n        if (convert_from_object((char*)&lvalue, basetd, value) < 0)\n            goto error;     /* out-of-range or badly typed 'value' */\n        if (PyDict_SetItem(dict1, tmpkey, value) < 0)\n            goto error;\n        if (PyDict_SetItem(dict2, value, tmpkey) < 0)\n            goto error;\n        Py_DECREF(tmpkey);\n        tmpkey = NULL;\n    }\n\n    combined = PyTuple_Pack(2, dict1, dict2);\n    if (combined == NULL)\n        goto error;\n\n    Py_CLEAR(dict2);\n    Py_CLEAR(dict1);\n\n    name_size = strlen(ename) + 1;\n    td = ctypedescr_new(name_size);\n    if (td == NULL)\n        goto error;\n\n    memcpy(td->ct_name, ename, name_size);\n    td->ct_stuff = combined;\n    td->ct_size = basetd->ct_size;\n    td->ct_length = basetd->ct_length;   /* alignment */\n    td->ct_extra = basetd->ct_extra;     /* ffi type  */\n    td->ct_flags = basetd->ct_flags | CT_IS_ENUM;\n    td->ct_name_position = name_size - 1;\n    return (PyObject *)td;\n\n error:\n    Py_XDECREF(tmpkey);\n    Py_XDECREF(combined);\n    Py_XDECREF(dict2);\n    Py_XDECREF(dict1);\n    return NULL;\n}\n\nstatic PyObject *b_alignof(PyObject *self, PyObject *arg)\n{\n    int align;\n    if (!CTypeDescr_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'ctype' object\");\n        return NULL;\n    }\n    align = get_alignment((CTypeDescrObject *)arg);\n    if (align < 0)\n        return NULL;\n    return PyInt_FromLong(align);\n}\n\nstatic PyObject *b_sizeof(PyObject *self, PyObject *arg)\n{\n    Py_ssize_t size;\n\n    if (CData_Check(arg)) {\n        CDataObject *cd = (CDataObject *)arg;\n\n        if (cd->c_type->ct_flags & CT_ARRAY)\n            size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n        else\n            size = cd->c_type->ct_size;\n    }\n    else if (CTypeDescr_Check(arg)) {\n        size = ((CTypeDescrObject *)arg)->ct_size;\n        if (size < 0) {\n            PyErr_Format(PyExc_ValueError, \"ctype '%s' is of unknown size\",\n                         ((CTypeDescrObject *)arg)->ct_name);\n            return NULL;\n        }\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a 'cdata' or 'ctype' object\");\n        return NULL;\n    }\n    return PyInt_FromSsize_t(size);\n}\n\nstatic PyObject *b_typeof(PyObject *self, PyObject *arg)\n{\n    PyObject *res;\n\n    if (!CData_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'cdata' object\");\n        return NULL;\n    }\n    res = (PyObject *)((CDataObject *)arg)->c_type;\n    Py_INCREF(res);\n    return res;\n}\n\nstatic CTypeDescrObject *direct_typeoffsetof(CTypeDescrObject *ct,\n                                             PyObject *fieldname,\n                                             int following, Py_ssize_t *offset)\n{\n    /* Does not return a new reference! */\n    CTypeDescrObject *res;\n    CFieldObject *cf;\n\n    if (PyTextAny_Check(fieldname)) {\n        if (!following && (ct->ct_flags & CT_POINTER))\n            ct = ct->ct_itemdescr;\n        if (!(ct->ct_flags & (CT_STRUCT|CT_UNION))) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"with a field name argument, expected a \"\n                            \"struct or union ctype\");\n            return NULL;\n        }\n        if (force_lazy_struct(ct) <= 0) {\n            if (!PyErr_Occurred())\n                PyErr_SetString(PyExc_TypeError, \"struct/union is opaque\");\n            return NULL;\n        }\n        cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, fieldname);\n        if (cf == NULL) {\n            PyErr_SetObject(PyExc_KeyError, fieldname);\n            return NULL;\n        }\n        if (cf->cf_bitshift >= 0) {\n            PyErr_SetString(PyExc_TypeError, \"not supported for bitfields\");\n            return NULL;\n        }\n        res = cf->cf_type;\n        *offset = cf->cf_offset;\n    }\n    else {\n        ssize_t index = PyInt_AsSsize_t(fieldname);\n        if (index < 0 && PyErr_Occurred()) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"field name or array index expected\");\n            return NULL;\n        }\n\n        if (!(ct->ct_flags & (CT_ARRAY|CT_POINTER)) ||\n                ct->ct_itemdescr->ct_size < 0) {\n            PyErr_SetString(PyExc_TypeError, \"with an integer argument, \"\n                                             \"expected an array ctype or a \"\n                                             \"pointer to non-opaque\");\n            return NULL;\n        }\n        res = ct->ct_itemdescr;\n        *offset = index * ct->ct_itemdescr->ct_size;\n        if ((*offset / ct->ct_itemdescr->ct_size) != index) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"array offset would overflow a Py_ssize_t\");\n            return NULL;\n        }\n    }\n    return res;\n}\n\nstatic PyObject *b_typeoffsetof(PyObject *self, PyObject *args)\n{\n    PyObject *res, *fieldname;\n    CTypeDescrObject *ct;\n    Py_ssize_t offset;\n    int following = 0;\n\n    if (!PyArg_ParseTuple(args, \"O!O|i:typeoffsetof\",\n                          &CTypeDescr_Type, &ct, &fieldname, &following))\n        return NULL;\n\n    res = (PyObject *)direct_typeoffsetof(ct, fieldname, following, &offset);\n    if (res == NULL)\n        return NULL;\n\n    return Py_BuildValue(\"(On)\", res, offset);\n}\n\nstatic PyObject *b_rawaddressof(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    CDataObject *cd;\n    Py_ssize_t offset;\n    int accepted_flags;\n\n    if (!PyArg_ParseTuple(args, \"O!O!n:rawaddressof\",\n                          &CTypeDescr_Type, &ct,\n                          &CData_Type, &cd,\n                          &offset))\n        return NULL;\n\n    accepted_flags = CT_STRUCT | CT_UNION | CT_ARRAY | CT_POINTER;\n    if ((cd->c_type->ct_flags & accepted_flags) == 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a cdata struct/union/array/pointer object\");\n        return NULL;\n    }\n    if ((ct->ct_flags & CT_POINTER) == 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a pointer ctype\");\n        return NULL;\n    }\n    return new_simple_cdata(cd->c_data + offset, ct);\n}\n\nstatic PyObject *b_getcname(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *replace_with, *p, *s;\n    Py_ssize_t namelen, replacelen;\n\n    if (!PyArg_ParseTuple(args, \"O!s:getcname\",\n                          &CTypeDescr_Type, &ct, &replace_with))\n        return NULL;\n\n    namelen = strlen(ct->ct_name);\n    replacelen = strlen(replace_with);\n    s = p = alloca(namelen + replacelen + 1);\n    memcpy(p, ct->ct_name, ct->ct_name_position);\n    p += ct->ct_name_position;\n    memcpy(p, replace_with, replacelen);\n    p += replacelen;\n    memcpy(p, ct->ct_name + ct->ct_name_position,\n           namelen - ct->ct_name_position);\n\n    return PyText_FromStringAndSize(s, namelen + replacelen);\n}\n\nstatic PyObject *b_string(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    CDataObject *cd;\n    Py_ssize_t maxlen = -1;\n    static char *keywords[] = {\"cdata\", \"maxlen\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!|n:string\", keywords,\n                                     &CData_Type, &cd, &maxlen))\n        return NULL;\n\n    if (cd->c_type->ct_itemdescr != NULL &&\n        cd->c_type->ct_itemdescr->ct_flags & (CT_PRIMITIVE_CHAR |\n                                              CT_PRIMITIVE_SIGNED |\n                                              CT_PRIMITIVE_UNSIGNED)) {\n        Py_ssize_t length = maxlen;\n        if (cd->c_data == NULL) {\n            PyObject *s = cdata_repr(cd);\n            if (s != NULL) {\n                PyErr_Format(PyExc_RuntimeError,\n                             \"cannot use string() on %s\",\n                             PyText_AS_UTF8(s));\n                Py_DECREF(s);\n            }\n            return NULL;\n        }\n        if (length < 0 && cd->c_type->ct_flags & CT_ARRAY) {\n            length = get_array_length(cd);\n        }\n        if (cd->c_type->ct_itemdescr->ct_size == sizeof(char)) {\n            const char *start = cd->c_data;\n            if (length < 0) {\n                /*READ(start, 1)*/\n                length = strlen(start);\n                /*READ(start, length)*/\n            }\n            else {\n                const char *end;\n                /*READ(start, length)*/\n                end = (const char *)memchr(start, 0, length);\n                if (end != NULL)\n                    length = end - start;\n            }\n            return PyBytes_FromStringAndSize(start, length);\n        }\n#ifdef HAVE_WCHAR_H\n        else if (cd->c_type->ct_itemdescr->ct_flags & CT_PRIMITIVE_CHAR) {\n            const wchar_t *start = (wchar_t *)cd->c_data;\n            assert(cd->c_type->ct_itemdescr->ct_size == sizeof(wchar_t));\n            if (length < 0) {\n                /*READ(start, sizeof(wchar_t))*/\n                length = 0;\n                while (start[length])\n                    length++;\n                /*READ(start, sizeof(wchar_t) * length)*/\n            }\n            else {\n                /*READ(start, sizeof(wchar_t) * length)*/\n                maxlen = length;\n                length = 0;\n                while (length < maxlen && start[length])\n                    length++;\n            }\n            return _my_PyUnicode_FromWideChar(start, length);\n        }\n#endif\n    }\n    else if (cd->c_type->ct_flags & CT_IS_ENUM) {\n        return convert_cdata_to_enum_string(cd, 0);\n    }\n    else if (cd->c_type->ct_flags & CT_IS_BOOL) {\n        /* fall through to TypeError */\n    }\n    else if (cd->c_type->ct_flags & (CT_PRIMITIVE_CHAR |\n                                     CT_PRIMITIVE_SIGNED |\n                                     CT_PRIMITIVE_UNSIGNED)) {\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        if (cd->c_type->ct_size == sizeof(char))\n            return PyBytes_FromStringAndSize(cd->c_data, 1);\n#ifdef HAVE_WCHAR_H\n        else if (cd->c_type->ct_flags & CT_PRIMITIVE_CHAR) {\n            assert(cd->c_type->ct_size == sizeof(wchar_t));\n            return _my_PyUnicode_FromWideChar((wchar_t *)cd->c_data, 1);\n        }\n#endif\n    }\n    PyErr_Format(PyExc_TypeError, \"string(): unexpected cdata '%s' argument\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\nstatic PyObject *b_buffer(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    CDataObject *cd;\n    Py_ssize_t size = -1;\n    static char *keywords[] = {\"cdata\", \"size\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!|n:buffer\", keywords,\n                                     &CData_Type, &cd, &size))\n        return NULL;\n\n    if (cd->c_type->ct_flags & CT_POINTER) {\n        if (size < 0)\n            size = cd->c_type->ct_itemdescr->ct_size;\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        if (size < 0)\n            size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array cdata, got '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (size < 0) {\n        PyErr_Format(PyExc_TypeError,\n                     \"don't know the size pointed to by '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    /*WRITE(cd->c_data, size)*/\n    return minibuffer_new(cd->c_data, size, (PyObject *)cd);\n}\n\nstatic PyObject *b_get_errno(PyObject *self, PyObject *noarg)\n{\n    int err;\n    restore_errno_only();\n    err = errno;\n    errno = 0;\n    return PyInt_FromLong(err);\n}\n\nstatic PyObject *b_set_errno(PyObject *self, PyObject *arg)\n{\n    long ival = PyInt_AsLong(arg);\n    if (ival == -1 && PyErr_Occurred())\n        return NULL;\n    else if (ival < INT_MIN || ival > INT_MAX) {\n        PyErr_SetString(PyExc_OverflowError, \"errno value too large\");\n        return NULL;\n    }\n    errno = (int)ival;\n    save_errno_only();\n    errno = 0;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *b_newp_handle(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    CDataObject *cd;\n    PyObject *x;\n    if (!PyArg_ParseTuple(args, \"O!O\", &CTypeDescr_Type, &ct, &x))\n        return NULL;\n\n    if (!(ct->ct_flags & CT_IS_VOID_PTR)) {\n        PyErr_Format(PyExc_TypeError, \"needs 'void *', got '%s'\", ct->ct_name);\n        return NULL;\n    }\n\n    cd = (CDataObject *)PyObject_GC_New(CDataObject, &CDataOwningGC_Type);\n    if (cd == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    Py_INCREF(x);\n    cd->c_data = ((char *)x) - 42;\n    cd->c_weakreflist = NULL;\n    PyObject_GC_Track(cd);\n    return (PyObject *)cd;\n}\n\nstatic PyObject *b_from_handle(PyObject *self, PyObject *arg)\n{\n    CTypeDescrObject *ct;\n    char *raw;\n    PyObject *x;\n    if (!CData_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'cdata' object\");\n        return NULL;\n    }\n    ct = ((CDataObject *)arg)->c_type;\n    raw = ((CDataObject *)arg)->c_data;\n    if (!(ct->ct_flags & CT_CAST_ANYTHING)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a 'cdata' object with a 'void *' out of \"\n                     \"new_handle(), got '%s'\", ct->ct_name);\n        return NULL;\n    }\n    if (!raw) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"cannot use from_handle() on NULL pointer\");\n        return NULL;\n    }\n    x = (PyObject *)(raw + 42);\n    if (Py_REFCNT(x) <= 0) {\n        Py_FatalError(\"ffi.from_handle() detected that the address passed \"\n                      \"points to garbage. If it is really the result of \"\n                      \"ffi.new_handle(), then the Python object has already \"\n                      \"been garbage collected\");\n    }\n    Py_INCREF(x);\n    return x;\n}\n\nstatic int _my_PyObject_GetContiguousBuffer(PyObject *x, Py_buffer *view)\n{\n#if PY_MAJOR_VERSION < 3\n    /* Some objects only support the buffer interface and CPython doesn't\n       translate it into the memoryview interface, mess.  Hack a very\n       minimal content for 'view'.  Don't care if the other fields are\n       uninitialized: we only call PyBuffer_Release(), which only reads\n       'view->obj'. */\n    PyBufferProcs *pb = x->ob_type->tp_as_buffer;\n    if (pb && !pb->bf_releasebuffer) {\n        /* we used to try all three in some vaguely sensible order,\n           i.e. first the write.  But trying to call the write on a\n           read-only buffer fails with TypeError.  So we use a less-\n           sensible order now.  See test_from_buffer_more_cases. */\n        readbufferproc proc = (readbufferproc)pb->bf_getreadbuffer;\n        if (!proc)     proc = (readbufferproc)pb->bf_getcharbuffer;\n        if (!proc)     proc = (readbufferproc)pb->bf_getwritebuffer;\n        if (proc && pb->bf_getsegcount) {\n            if ((*pb->bf_getsegcount)(x, NULL) != 1) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"expected a single-segment buffer object\");\n                return -1;\n            }\n            view->len = (*proc)(x, 0, &view->buf);\n            if (view->len < 0)\n                return -1;\n            view->obj = x;\n            Py_INCREF(x);\n            return 0;\n        }\n    }\n#endif\n\n    if (PyObject_GetBuffer(x, view, PyBUF_SIMPLE) < 0)\n        return -1;\n\n    if (!PyBuffer_IsContiguous(view, 'A')) {\n        PyBuffer_Release(view);\n        PyErr_SetString(PyExc_TypeError, \"contiguous buffer expected\");\n        return -1;\n    }\n    return 0;\n}\n\nstatic int invalid_input_buffer_type(PyObject *x)\n{\n#if PY_MAJOR_VERSION < 3\n    if (PyBuffer_Check(x)) {\n        /* XXX fish fish fish in an inofficial way */\n        typedef struct {\n            PyObject_HEAD\n            PyObject *b_base;\n        } _my_PyBufferObject;\n\n        _my_PyBufferObject *b = (_my_PyBufferObject *)x;\n        x = b->b_base;\n        if (x == NULL)\n            return 0;\n    }\n    else\n#endif\n#if PY_MAJOR_VERSION > 2 || PY_MINOR_VERSION > 6\n    if (PyMemoryView_Check(x)) {\n        x = PyMemoryView_GET_BASE(x);\n        if (x == NULL)\n            return 0;\n    }\n    else\n#endif\n        ;\n\n    if (PyBytes_Check(x) || PyUnicode_Check(x))\n        return 1;\n    if (PyByteArray_Check(x)) /* <= this one here for PyPy compatibility */\n        return 1;\n    return 0;\n}\n\nstatic PyObject *direct_from_buffer(CTypeDescrObject *ct, PyObject *x)\n{\n    CDataObject *cd;\n    Py_buffer *view;\n\n    if (invalid_input_buffer_type(x)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"from_buffer() cannot return the address of the \"\n                        \"raw string within a \"STR_OR_BYTES\" or unicode or \"\n                        \"bytearray object\");\n        return NULL;\n    }\n\n    view = PyObject_Malloc(sizeof(Py_buffer));\n    if (_my_PyObject_GetContiguousBuffer(x, view) < 0)\n        goto error1;\n\n    cd = (CDataObject *)PyObject_GC_New(CDataObject_owngc_frombuf,\n                                        &CDataOwningGC_Type);\n    if (cd == NULL)\n        goto error2;\n\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_data = view->buf;\n    cd->c_weakreflist = NULL;\n    ((CDataObject_owngc_frombuf *)cd)->length = view->len;\n    ((CDataObject_owngc_frombuf *)cd)->bufferview = view;\n    PyObject_GC_Track(cd);\n    return (PyObject *)cd;\n\n error2:\n    PyBuffer_Release(view);\n error1:\n    PyObject_Free(view);\n    return NULL;\n}\n\nstatic PyObject *b_from_buffer(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *x;\n\n    if (!PyArg_ParseTuple(args, \"O!O\", &CTypeDescr_Type, &ct, &x))\n        return NULL;\n\n    if (!(ct->ct_flags & CT_IS_UNSIZED_CHAR_A)) {\n        PyErr_Format(PyExc_TypeError, \"needs 'char[]', got '%s'\", ct->ct_name);\n        return NULL;\n    }\n    return direct_from_buffer(ct, x);\n}\n\nstatic PyObject *b__get_types(PyObject *self, PyObject *noarg)\n{\n    return PyTuple_Pack(2, (PyObject *)&CData_Type,\n                           (PyObject *)&CTypeDescr_Type);\n}\n\n/************************************************************/\n\nstatic char _testfunc0(char a, char b)\n{\n    return a + b;\n}\nstatic long _testfunc1(int a, long b)\n{\n    return (long)a + b;\n}\nstatic PY_LONG_LONG _testfunc2(PY_LONG_LONG a, PY_LONG_LONG b)\n{\n    return a + b;\n}\nstatic double _testfunc3(float a, double b)\n{\n    return a + b;\n}\nstatic float _testfunc4(float a, double b)\n{\n    return (float)(a + b);\n}\nstatic void _testfunc5(void)\n{\n    errno = errno + 15;\n}\nstatic int *_testfunc6(int *x)\n{\n    static int y;\n    y = *x - 1000;\n    return &y;\n}\nstruct _testfunc7_s { unsigned char a1; short a2; };\nstatic short _testfunc7(struct _testfunc7_s inlined)\n{\n    return inlined.a1 + inlined.a2;\n}\nstatic int _testfunc9(int num, ...)\n{\n    va_list vargs;\n    int i, total = 0;\n    va_start(vargs, num);\n    for (i=0; i<num; i++) {\n        int value = va_arg(vargs, int);\n        if (value == 0)\n            value = -66666666;\n        total += value;\n    }\n    va_end(vargs);\n    return total;\n}\n\nstatic struct _testfunc7_s _testfunc10(int n)\n{\n    struct _testfunc7_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc11_s { int a1, a2; };\nstatic struct _testfunc11_s _testfunc11(int n)\n{\n    struct _testfunc11_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc12_s { double a1; };\nstatic struct _testfunc12_s _testfunc12(int n)\n{\n    struct _testfunc12_s result;\n    result.a1 = n;\n    return result;\n}\n\nstruct _testfunc13_s { int a1, a2, a3; };\nstatic struct _testfunc13_s _testfunc13(int n)\n{\n    struct _testfunc13_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    result.a3 = n * n * n;\n    return result;\n}\n\nstruct _testfunc14_s { float a1; };\nstatic struct _testfunc14_s _testfunc14(int n)\n{\n    struct _testfunc14_s result;\n    result.a1 = (float)n;\n    return result;\n}\n\nstruct _testfunc15_s { float a1; int a2; };\nstatic struct _testfunc15_s _testfunc15(int n)\n{\n    struct _testfunc15_s result;\n    result.a1 = (float)n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc16_s { float a1, a2; };\nstatic struct _testfunc16_s _testfunc16(int n)\n{\n    struct _testfunc16_s result;\n    result.a1 = (float)n;\n    result.a2 = -(float)n;\n    return result;\n}\n\nstruct _testfunc17_s { int a1; float a2; };\nstatic struct _testfunc17_s _testfunc17(int n)\n{\n    struct _testfunc17_s result;\n    result.a1 = n;\n    result.a2 = (float)n * (float)n;\n    return result;\n}\n\nstatic int _testfunc18(struct _testfunc17_s *ptr)\n{\n    return ptr->a1 + (int)ptr->a2;\n}\n\nstatic long double _testfunc19(long double x, int count)\n{\n    int i;\n    for (i=0; i<count; i++) {\n        x = 4*x - x*x;\n    }\n    return x;\n}\n\nstatic short _testfunc20(struct _testfunc7_s *ptr)\n{\n    return ptr->a1 + ptr->a2;\n}\n\nstruct _testfunc21_s { int a, b, c, d, e, f, g, h, i, j; };\nstatic int _testfunc21(struct _testfunc21_s inlined)\n{\n    return ((inlined.a << 0) +\n            (inlined.b << 1) +\n            (inlined.c << 2) +\n            (inlined.d << 3) +\n            (inlined.e << 4) +\n            (inlined.f << 5) +\n            (inlined.g << 6) +\n            (inlined.h << 7) +\n            (inlined.i << 8) +\n            (inlined.j << 9));\n}\n\nstruct _testfunc22_s { int a[10]; };\nstatic struct _testfunc22_s _testfunc22(struct _testfunc22_s s1,\n                                        struct _testfunc22_s s2)\n{\n    struct _testfunc22_s result;\n    int i;\n    for (i=0; i<10; i++)\n        result.a[i] = s1.a[i] - s2.a[i];\n    return result;\n}\n\nstatic int _testfunc23(char *p)\n{\n    if (p)\n        return 1000 * p[0];\n    return -42;\n}\n\nstatic PyObject *b__testfunc(PyObject *self, PyObject *args)\n{\n    /* for testing only */\n    int i;\n    void *f;\n    if (!PyArg_ParseTuple(args, \"i:_testfunc\", &i))\n        return NULL;\n    switch (i) {\n    case 0: f = &_testfunc0; break;\n    case 1: f = &_testfunc1; break;\n    case 2: f = &_testfunc2; break;\n    case 3: f = &_testfunc3; break;\n    case 4: f = &_testfunc4; break;\n    case 5: f = &_testfunc5; break;\n    case 6: f = &_testfunc6; break;\n    case 7: f = &_testfunc7; break;\n    case 8: f = stderr; break;\n    case 9: f = &_testfunc9; break;\n    case 10: f = &_testfunc10; break;\n    case 11: f = &_testfunc11; break;\n    case 12: f = &_testfunc12; break;\n    case 13: f = &_testfunc13; break;\n    case 14: f = &_testfunc14; break;\n    case 15: f = &_testfunc15; break;\n    case 16: f = &_testfunc16; break;\n    case 17: f = &_testfunc17; break;\n    case 18: f = &_testfunc18; break;\n    case 19: f = &_testfunc19; break;\n    case 20: f = &_testfunc20; break;\n    case 21: f = &_testfunc21; break;\n    case 22: f = &_testfunc22; break;\n    case 23: f = &_testfunc23; break;\n    default:\n        PyErr_SetNone(PyExc_ValueError);\n        return NULL;\n    }\n    return PyLong_FromVoidPtr(f);\n}\n\n#if PY_MAJOR_VERSION < 3\nstatic Py_ssize_t _test_segcountproc(PyObject *o, Py_ssize_t *ignored)\n{\n    return 1;\n}\nstatic Py_ssize_t _test_getreadbuf(PyObject *o, Py_ssize_t i, void **r)\n{\n    static char buf[] = \"RDB\";\n    *r = buf;\n    return 3;\n}\nstatic Py_ssize_t _test_getwritebuf(PyObject *o, Py_ssize_t i, void **r)\n{\n    static char buf[] = \"WRB\";\n    *r = buf;\n    return 3;\n}\nstatic Py_ssize_t _test_getcharbuf(PyObject *o, Py_ssize_t i, char **r)\n{\n    static char buf[] = \"CHB\";\n    *r = buf;\n    return 3;\n}\n#endif\nstatic int _test_getbuf(PyObject *self, Py_buffer *view, int flags)\n{\n    static char buf[] = \"GTB\";\n    return PyBuffer_FillInfo(view, self, buf, 3, /*readonly=*/0, flags);\n}\nstatic int _test_getbuf_ro(PyObject *self, Py_buffer *view, int flags)\n{\n    static char buf[] = \"ROB\";\n    return PyBuffer_FillInfo(view, self, buf, 3, /*readonly=*/1, flags);\n}\n\n\nstatic PyObject *b__testbuff(PyObject *self, PyObject *args)\n{\n    /* for testing only */\n    int methods;\n    PyTypeObject *obj;\n    if (!PyArg_ParseTuple(args, \"O!i|_testbuff\", &PyType_Type, &obj, &methods))\n        return NULL;\n\n    assert(obj->tp_as_buffer != NULL);\n\n#if PY_MAJOR_VERSION < 3\n    obj->tp_as_buffer->bf_getsegcount = &_test_segcountproc;\n    obj->tp_flags |= Py_TPFLAGS_HAVE_GETCHARBUFFER;\n    obj->tp_flags |= Py_TPFLAGS_HAVE_NEWBUFFER;\n    if (methods & 1)  obj->tp_as_buffer->bf_getreadbuffer  = &_test_getreadbuf;\n    if (methods & 2)  obj->tp_as_buffer->bf_getwritebuffer = &_test_getwritebuf;\n    if (methods & 4)  obj->tp_as_buffer->bf_getcharbuffer  = &_test_getcharbuf;\n#endif\n    if (methods & 8)  obj->tp_as_buffer->bf_getbuffer      = &_test_getbuf;\n    if (methods & 16) obj->tp_as_buffer->bf_getbuffer      = &_test_getbuf_ro;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *b_init_cffi_1_0_external_module(PyObject *, PyObject *);\n/* forward, see cffi1_module.c */\n\n\nstatic PyMethodDef FFIBackendMethods[] = {\n    {\"load_library\", b_load_library, METH_VARARGS},\n    {\"new_primitive_type\", b_new_primitive_type, METH_VARARGS},\n    {\"new_pointer_type\", b_new_pointer_type, METH_VARARGS},\n    {\"new_array_type\", b_new_array_type, METH_VARARGS},\n    {\"new_void_type\", b_new_void_type, METH_NOARGS},\n    {\"new_struct_type\", b_new_struct_type, METH_VARARGS},\n    {\"new_union_type\", b_new_union_type, METH_VARARGS},\n    {\"complete_struct_or_union\", b_complete_struct_or_union, METH_VARARGS},\n    {\"new_function_type\", b_new_function_type, METH_VARARGS},\n    {\"new_enum_type\", b_new_enum_type, METH_VARARGS},\n    {\"newp\", b_newp, METH_VARARGS},\n    {\"cast\", b_cast, METH_VARARGS},\n    {\"callback\", b_callback, METH_VARARGS},\n    {\"alignof\", b_alignof, METH_O},\n    {\"sizeof\", b_sizeof, METH_O},\n    {\"typeof\", b_typeof, METH_O},\n    {\"typeoffsetof\", b_typeoffsetof, METH_VARARGS},\n    {\"rawaddressof\", b_rawaddressof, METH_VARARGS},\n    {\"getcname\", b_getcname, METH_VARARGS},\n    {\"string\", (PyCFunction)b_string, METH_VARARGS | METH_KEYWORDS},\n    {\"buffer\", (PyCFunction)b_buffer, METH_VARARGS | METH_KEYWORDS},\n    {\"get_errno\", b_get_errno, METH_NOARGS},\n    {\"set_errno\", b_set_errno, METH_O},\n    {\"newp_handle\", b_newp_handle, METH_VARARGS},\n    {\"from_handle\", b_from_handle, METH_O},\n    {\"from_buffer\", b_from_buffer, METH_VARARGS},\n#ifdef MS_WIN32\n    {\"getwinerror\", (PyCFunction)b_getwinerror, METH_VARARGS | METH_KEYWORDS},\n#endif\n    {\"_get_types\", b__get_types, METH_NOARGS},\n    {\"_testfunc\", b__testfunc, METH_VARARGS},\n    {\"_testbuff\", b__testbuff, METH_VARARGS},\n    {\"_init_cffi_1_0_external_module\", b_init_cffi_1_0_external_module, METH_O},\n    {NULL,     NULL}    /* Sentinel */\n};\n\n/************************************************************/\n/* Functions used by '_cffi_N.so', the generated modules    */\n\n#define _cffi_to_c_SIGNED_FN(RETURNTYPE, SIZE)                          \\\nstatic RETURNTYPE _cffi_to_c_i##SIZE(PyObject *obj) {                   \\\n    PY_LONG_LONG tmp = _my_PyLong_AsLongLong(obj);                      \\\n    if ((tmp > (PY_LONG_LONG)((1ULL<<(SIZE-1)) - 1)) ||                 \\\n        (tmp < (PY_LONG_LONG)(0ULL-(1ULL<<(SIZE-1)))))                  \\\n        if (!PyErr_Occurred())                                          \\\n            return (RETURNTYPE)_convert_overflow(obj, #SIZE \"-bit int\"); \\\n    return (RETURNTYPE)tmp;                                             \\\n}\n\n#define _cffi_to_c_UNSIGNED_FN(RETURNTYPE, SIZE)                        \\\nstatic RETURNTYPE _cffi_to_c_u##SIZE(PyObject *obj) {                   \\\n    unsigned PY_LONG_LONG tmp = _my_PyLong_AsUnsignedLongLong(obj, 1);  \\\n    if (tmp > ~(((unsigned PY_LONG_LONG)-2) << (SIZE-1)))               \\\n        if (!PyErr_Occurred())                                          \\\n            return (RETURNTYPE)_convert_overflow(obj,                   \\\n                                   #SIZE \"-bit unsigned int\");          \\\n    return (RETURNTYPE)tmp;                                             \\\n}\n\n_cffi_to_c_SIGNED_FN(int, 8)\n_cffi_to_c_SIGNED_FN(int, 16)\n_cffi_to_c_SIGNED_FN(int, 32)\n_cffi_to_c_SIGNED_FN(PY_LONG_LONG, 64)\n_cffi_to_c_UNSIGNED_FN(int, 8)\n_cffi_to_c_UNSIGNED_FN(int, 16)\n_cffi_to_c_UNSIGNED_FN(unsigned int, 32)\n_cffi_to_c_UNSIGNED_FN(unsigned PY_LONG_LONG, 64)\n\nstatic PyObject *_cffi_from_c_pointer(char *ptr, CTypeDescrObject *ct)\n{\n    return convert_to_object((char *)&ptr, ct);\n}\n\nstatic char *_cffi_to_c_pointer(PyObject *obj, CTypeDescrObject *ct)\n{\n    char *result;\n    if (convert_from_object((char *)&result, ct, obj) < 0) {\n        if ((ct->ct_flags & CT_POINTER) &&\n                (ct->ct_itemdescr->ct_flags & CT_IS_FILE) &&\n                PyFile_Check(obj)) {\n            PyErr_Clear();\n            return (char *)PyFile_AsFile(obj);\n        }\n        return NULL;\n    }\n    return result;\n}\n\nstatic long double _cffi_to_c_long_double(PyObject *obj)\n{\n    if (CData_Check(obj) &&\n            (((CDataObject *)obj)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n        char *data = ((CDataObject *)obj)->c_data;\n        /*READ(data, sizeof(long double))*/\n        return read_raw_longdouble_data(data);\n    }\n    else\n        return PyFloat_AsDouble(obj);\n}\n\nstatic _Bool _cffi_to_c__Bool(PyObject *obj)\n{\n    PY_LONG_LONG tmp = _my_PyLong_AsLongLong(obj);\n    if (tmp == 0)\n        return 0;\n    else if (tmp == 1)\n        return 1;\n    else if (PyErr_Occurred())\n        return (_Bool)-1;\n    else\n        return (_Bool)_convert_overflow(obj, \"_Bool\");\n}\n\nstatic PyObject *_cffi_get_struct_layout(Py_ssize_t nums[])\n{\n    PyObject *result;\n    int count = 0;\n    while (nums[count] >= 0)\n        count++;\n\n    result = PyList_New(count);\n    if (result == NULL)\n        return NULL;\n\n    while (--count >= 0) {\n        PyObject *o = PyInt_FromSsize_t(nums[count]);\n        if (o == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        PyList_SET_ITEM(result, count, o);\n    }\n    return result;\n}\n\nstatic PyObject *_cffi_from_c_char(char x) {\n    return PyBytes_FromStringAndSize(&x, 1);\n}\n\n#ifdef HAVE_WCHAR_H\nstatic PyObject *_cffi_from_c_wchar_t(wchar_t x) {\n    return _my_PyUnicode_FromWideChar(&x, 1);\n}\n#endif\n\nstatic void *cffi_exports[] = {\n    NULL,\n    _cffi_to_c_i8,\n    _cffi_to_c_u8,\n    _cffi_to_c_i16,\n    _cffi_to_c_u16,\n    _cffi_to_c_i32,\n    _cffi_to_c_u32,\n    _cffi_to_c_i64,\n    _cffi_to_c_u64,\n    _convert_to_char,\n    _cffi_from_c_pointer,\n    _cffi_to_c_pointer,\n    _cffi_get_struct_layout,\n    restore_errno,\n    save_errno,\n    _cffi_from_c_char,\n    convert_to_object,\n    convert_from_object,\n    convert_struct_to_owning_object,\n#ifdef HAVE_WCHAR_H\n    _convert_to_wchar_t,\n    _cffi_from_c_wchar_t,\n#else\n    0,\n    0,\n#endif\n    _cffi_to_c_long_double,\n    _cffi_to_c__Bool,\n    _prepare_pointer_call_argument,\n    convert_array_from_object,\n};\n\nstatic struct { const char *name; int value; } all_dlopen_flags[] = {\n    { \"RTLD_LAZY\",     RTLD_LAZY     },\n    { \"RTLD_NOW\",      RTLD_NOW      },\n    { \"RTLD_GLOBAL\",   RTLD_GLOBAL   },\n#ifdef RTLD_LOCAL\n    { \"RTLD_LOCAL\",    RTLD_LOCAL    },\n#else\n    { \"RTLD_LOCAL\",    0             },\n#endif\n#ifdef RTLD_NODELETE\n    { \"RTLD_NODELETE\", RTLD_NODELETE },\n#endif\n#ifdef RTLD_NOLOAD\n    { \"RTLD_NOLOAD\",   RTLD_NOLOAD   },\n#endif\n#ifdef RTLD_DEEPBIND\n    { \"RTLD_DEEPBIND\", RTLD_DEEPBIND },\n#endif\n    { NULL, 0 }\n};\n\n\n/************************************************************/\n\n#include \"cffi1_module.c\"\n\n/************************************************************/\n\n#if PY_MAJOR_VERSION >= 3\nstatic struct PyModuleDef FFIBackendModuleDef = {\n  PyModuleDef_HEAD_INIT,\n  \"_cffi_backend\",\n  NULL,\n  -1,\n  FFIBackendMethods,\n  NULL, NULL, NULL, NULL\n};\n#define INITERROR return NULL\n\nPyMODINIT_FUNC\nPyInit__cffi_backend(void)\n#else\n#define INITERROR return\n\nPyMODINIT_FUNC\ninit_cffi_backend(void)\n#endif\n{\n    PyObject *m, *v;\n    int i;\n\n    v = PySys_GetObject(\"version\");\n    if (v == NULL || !PyText_Check(v) ||\n            strncmp(PyText_AS_UTF8(v), PY_VERSION, 3) != 0) {\n        PyErr_Format(PyExc_ImportError,\n                     \"this module was compiled for Python %c%c%c\",\n                     PY_VERSION[0], PY_VERSION[1], PY_VERSION[2]);\n        INITERROR;\n    }\n\n#if PY_MAJOR_VERSION >= 3\n    m = PyModule_Create(&FFIBackendModuleDef);\n#else\n    m = Py_InitModule(\"_cffi_backend\", FFIBackendMethods);\n#endif\n\n    if (m == NULL)\n        INITERROR;\n\n    unique_cache = PyDict_New();\n    if (unique_cache == NULL)\n        INITERROR;\n\n    if (PyType_Ready(&dl_type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CTypeDescr_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CField_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CData_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataOwning_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataOwningGC_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataIter_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&MiniBuffer_Type) < 0)\n        INITERROR;\n\n    v = PyText_FromString(\"_cffi_backend\");\n    if (v == NULL || PyDict_SetItemString(CData_Type.tp_dict,\n                                          \"__module__\", v) < 0)\n        INITERROR;\n    v = PyText_FromString(\"<cdata>\");\n    if (v == NULL || PyDict_SetItemString(CData_Type.tp_dict,\n                                          \"__name__\", v) < 0)\n        INITERROR;\n\n    /* this is for backward compatibility only */\n    v = PyCapsule_New((void *)cffi_exports, \"cffi\", NULL);\n    if (v == NULL || PyModule_AddObject(m, \"_C_API\", v) < 0)\n        INITERROR;\n\n    v = PyText_FromString(\"1.1.2\");\n    if (v == NULL || PyModule_AddObject(m, \"__version__\", v) < 0)\n        INITERROR;\n\n    if (PyModule_AddIntConstant(m, \"FFI_DEFAULT_ABI\", FFI_DEFAULT_ABI) < 0 ||\n#if defined(MS_WIN32) && !defined(_WIN64)\n        PyModule_AddIntConstant(m, \"FFI_STDCALL\", FFI_STDCALL) < 0 ||\n#endif\n#ifdef FFI_CDECL\n        PyModule_AddIntConstant(m, \"FFI_CDECL\", FFI_CDECL) < 0 ||   /* win32 */\n#else\n        PyModule_AddIntConstant(m, \"FFI_CDECL\", FFI_DEFAULT_ABI) < 0 ||\n#endif\n\n#ifdef MS_WIN32\n#  ifdef _WIN64\n        PyModule_AddIntConstant(m, \"_WIN\", 64) < 0 ||   /* win64 */\n#  else\n        PyModule_AddIntConstant(m, \"_WIN\", 32) < 0 ||   /* win32 */\n#  endif\n#endif\n        0)\n      INITERROR;\n\n    for (i = 0; all_dlopen_flags[i].name != NULL; i++) {\n        if (PyModule_AddIntConstant(m,\n                                    all_dlopen_flags[i].name,\n                                    all_dlopen_flags[i].value) < 0)\n            INITERROR;\n    }\n\n    init_errno();\n\n    if (init_ffi_lib(m) < 0)\n        INITERROR;\n\n#if PY_MAJOR_VERSION >= 3\n    if (init_file_emulator() < 0)\n        INITERROR;\n    return m;\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-slie2xlghwqb34kwk6dwl34nztyqctdw/spack-src/c/lib_obj.c": "\n/* A Lib object is what is in the \"lib\" attribute of a C extension\n   module originally created by recompile().\n\n   A Lib object is special in the sense that it has a custom\n   __getattr__ which returns C globals, functions and constants.  It\n   raises AttributeError for anything else, even attrs like '__class__'.\n\n   A Lib object has got a reference to the _cffi_type_context_s\n   structure, which is used to create lazily the objects returned by\n   __getattr__.\n*/\n\nstruct CPyExtFunc_s {\n    PyMethodDef md;\n    void *direct_fn;\n    int type_index;\n};\nstatic const char cpyextfunc_doc[] =\n    \"direct call to the C function of the same name\";\n\nstruct LibObject_s {\n    PyObject_HEAD\n    builder_c_t *l_types_builder; /* same as the one on the ffi object */\n    PyObject *l_dict;           /* content, built lazily */\n    PyObject *l_libname;        /* some string that gives the name of the lib */\n    FFIObject *l_ffi;           /* reference back to the ffi object */\n    void *l_libhandle;          /* the dlopen()ed handle, if any */\n};\n\nstatic struct CPyExtFunc_s *_cpyextfunc_get(PyObject *x)\n{\n    struct CPyExtFunc_s *exf;\n\n    if (!PyCFunction_Check(x))\n        return NULL;\n    if (!LibObject_Check(PyCFunction_GET_SELF(x)))\n        return NULL;\n\n    exf = (struct CPyExtFunc_s *)(((PyCFunctionObject *)x) -> m_ml);\n    if (exf->md.ml_doc != cpyextfunc_doc)\n        return NULL;\n\n    return exf;\n}\n\nstatic PyObject *_cpyextfunc_type(LibObject *lib, struct CPyExtFunc_s *exf)\n{\n    PyObject *tuple, *result;\n    tuple = realize_c_type_or_func(lib->l_types_builder,\n                                   lib->l_types_builder->ctx.types,\n                                   exf->type_index);\n    if (tuple == NULL)\n        return NULL;\n\n    /* 'tuple' is a tuple of length 1 containing the real CT_FUNCTIONPTR\n       object */\n    result = PyTuple_GetItem(tuple, 0);\n    Py_XINCREF(result);\n    Py_DECREF(tuple);\n    return result;\n}\n\nstatic PyObject *_cpyextfunc_type_index(PyObject *x)\n{\n    struct CPyExtFunc_s *exf;\n    LibObject *lib;\n\n    assert(PyErr_Occurred());\n    exf = _cpyextfunc_get(x);\n    if (exf == NULL)\n        return NULL;    /* still the same exception is set */\n\n    PyErr_Clear();\n\n    lib = (LibObject *)PyCFunction_GET_SELF(x);\n    return _cpyextfunc_type(lib, exf);\n}\n\nstatic void cdlopen_close_ignore_errors(void *libhandle);  /* forward */\nstatic void *cdlopen_fetch(PyObject *libname, void *libhandle, char *symbol);\n\nstatic void lib_dealloc(LibObject *lib)\n{\n    cdlopen_close_ignore_errors(lib->l_libhandle);\n    Py_DECREF(lib->l_dict);\n    Py_DECREF(lib->l_libname);\n    Py_DECREF(lib->l_ffi);\n    PyObject_Del(lib);\n}\n\nstatic int lib_traverse(LibObject *lib, visitproc visit, void *arg)\n{\n    Py_VISIT(lib->l_dict);\n    Py_VISIT(lib->l_libname);\n    Py_VISIT(lib->l_ffi);\n    return 0;\n}\n\nstatic PyObject *lib_repr(LibObject *lib)\n{\n    return PyText_FromFormat(\"<Lib object for '%.200s'>\",\n                             PyText_AS_UTF8(lib->l_libname));\n}\n\nstatic PyObject *lib_build_cpython_func(LibObject *lib,\n                                        const struct _cffi_global_s *g,\n                                        const char *s, int flags)\n{\n    /* First make sure the argument types and return type are really\n       built.  The C extension code can then assume that they are,\n       by calling _cffi_type().\n    */\n    CTypeDescrObject *ct;\n    struct CPyExtFunc_s *xfunc;\n    int i, type_index = _CFFI_GETARG(g->type_op);\n    _cffi_opcode_t *opcodes = lib->l_types_builder->ctx.types;\n\n    if ((((uintptr_t)opcodes[type_index]) & 1) == 0) {\n        /* the function type was already built.  No need to force\n           the arg and return value to be built again. */\n    }\n    else {\n        assert(_CFFI_GETOP(opcodes[type_index]) == _CFFI_OP_FUNCTION);\n\n        /* return type: */\n        ct = realize_c_type(lib->l_types_builder, opcodes,\n                            _CFFI_GETARG(opcodes[type_index]));\n        if (ct == NULL)\n            return NULL;\n        Py_DECREF(ct);\n\n        /* argument types: */\n        i = type_index + 1;\n        while (_CFFI_GETOP(opcodes[i]) != _CFFI_OP_FUNCTION_END) {\n            ct = realize_c_type(lib->l_types_builder, opcodes, i);\n            if (ct == NULL)\n                return NULL;\n            Py_DECREF(ct);\n            i++;\n        }\n    }\n\n    /* xxx the few bytes of memory we allocate here leak, but it's a\n       minor concern because it should only occur for CPYTHON_BLTN.\n       There is one per real C function in a CFFI C extension module.\n       CPython never unloads its C extension modules anyway.\n    */\n    xfunc = PyMem_Malloc(sizeof(struct CPyExtFunc_s));\n    if (xfunc == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    memset((char *)xfunc, 0, sizeof(struct CPyExtFunc_s));\n    assert(g->address);\n    xfunc->md.ml_meth = (PyCFunction)g->address;\n    xfunc->md.ml_flags = flags;\n    xfunc->md.ml_name = g->name;\n    xfunc->md.ml_doc = cpyextfunc_doc;\n    xfunc->direct_fn = g->size_or_direct_fn;\n    xfunc->type_index = type_index;\n\n    return PyCFunction_NewEx(&xfunc->md, (PyObject *)lib, lib->l_libname);\n}\n\nstatic PyObject *lib_build_and_cache_attr(LibObject *lib, PyObject *name,\n                                          int recursion)\n{\n    /* does not return a new reference! */\n    PyObject *x;\n    int index;\n    const struct _cffi_global_s *g;\n    CTypeDescrObject *ct;\n    builder_c_t *types_builder = lib->l_types_builder;\n    char *s = PyText_AsUTF8(name);\n    if (s == NULL)\n        return NULL;\n\n    index = search_in_globals(&types_builder->ctx, s, strlen(s));\n    if (index < 0) {\n\n        if (types_builder->included_libs != NULL) {\n            Py_ssize_t i;\n            PyObject *included_ffis = types_builder->included_ffis;\n            PyObject *included_libs = types_builder->included_libs;\n\n            if (recursion > 100) {\n                PyErr_SetString(PyExc_RuntimeError,\n                    \"recursion overflow in ffi.include() delegations\");\n                return NULL;\n            }\n\n            for (i = 0; i < PyTuple_GET_SIZE(included_libs); i++) {\n                LibObject *lib1;\n\n                lib1 = (LibObject *)PyTuple_GET_ITEM(included_libs, i);\n                if (lib1 != NULL) {\n                    x = PyDict_GetItem(lib1->l_dict, name);\n                    if (x != NULL) {\n                        Py_INCREF(x);\n                        goto found;\n                    }\n                    x = lib_build_and_cache_attr(lib1, name, recursion + 1);\n                    if (x != NULL) {\n                        Py_INCREF(x);\n                        goto found;\n                    }\n                }\n                else {\n                    FFIObject *ffi1;\n\n                    ffi1 = (FFIObject *)PyTuple_GetItem(included_ffis, i);\n                    if (ffi1 == NULL)\n                        return NULL;\n                    x = ffi_fetch_int_constant(ffi1, s, recursion + 1);\n                    if (x != NULL)\n                        goto found;\n                }\n                if (PyErr_Occurred())\n                    return NULL;\n            }\n        }\n\n        if (recursion > 0)\n            return NULL;  /* no error set, continue looking elsewhere */\n\n        PyErr_Format(PyExc_AttributeError,\n                     \"cffi library '%.200s' has no function, constant \"\n                     \"or global variable named '%.200s'\",\n                     PyText_AS_UTF8(lib->l_libname), s);\n        return NULL;\n    }\n\n    g = &types_builder->ctx.globals[index];\n\n    switch (_CFFI_GETOP(g->type_op)) {\n\n    case _CFFI_OP_CPYTHON_BLTN_V:\n        x = lib_build_cpython_func(lib, g, s, METH_VARARGS);\n        break;\n\n    case _CFFI_OP_CPYTHON_BLTN_N:\n        x = lib_build_cpython_func(lib, g, s, METH_NOARGS);\n        break;\n\n    case _CFFI_OP_CPYTHON_BLTN_O:\n        x = lib_build_cpython_func(lib, g, s, METH_O);\n        break;\n\n    case _CFFI_OP_CONSTANT_INT:\n    case _CFFI_OP_ENUM:\n    {\n        /* a constant integer whose value, in an \"unsigned long long\",\n           is obtained by calling the function at g->address */\n        x = realize_global_int(types_builder, index);\n        break;\n    }\n\n    case _CFFI_OP_CONSTANT:\n    case _CFFI_OP_DLOPEN_CONST:\n    {\n        /* a constant which is not of integer type */\n        char *data;\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n\n        if (ct->ct_size <= 0) {\n            PyErr_SetString(PyExc_SystemError, \"constant has no known size\");\n            return NULL;\n        }\n        if (g->address == NULL) {\n            /* for dlopen() style */\n            assert(_CFFI_GETOP(g->type_op) == _CFFI_OP_DLOPEN_CONST);\n            data = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n            if (data == NULL)\n                return NULL;\n        }\n        else {\n            /* xxx the few bytes of memory we allocate here leak, but it's\n               a minor concern because it should only occur for\n               OP_CONSTANT.  There is one per real non-integer C constant\n               in a CFFI C extension module.  CPython never unloads its C\n               extension modules anyway.  Note that we used to do alloca(),\n               but see issue #198. */\n            assert(_CFFI_GETOP(g->type_op) == _CFFI_OP_CONSTANT);\n            data = PyMem_Malloc(ct->ct_size);\n            if (data == NULL) {\n                PyErr_NoMemory();\n                return NULL;\n            }\n            ((void(*)(char*))g->address)(data);\n        }\n        x = convert_to_object(data, ct);\n        Py_DECREF(ct);\n        break;\n    }\n\n    case _CFFI_OP_GLOBAL_VAR:\n    {\n        /* global variable of the exact type specified here */\n        Py_ssize_t g_size = (Py_ssize_t)g->size_or_direct_fn;\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n        if (g_size != ct->ct_size && g_size != 0 && ct->ct_size > 0) {\n            PyErr_Format(FFIError,\n                         \"global variable '%.200s' should be %zd bytes \"\n                         \"according to the cdef, but is actually %zd\",\n                         s, ct->ct_size, g_size);\n            x = NULL;\n        }\n        else {\n            void *address = g->address;\n            if (address == NULL) {\n                /* for dlopen() style */\n                address = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n                if (address == NULL)\n                    return NULL;\n            }\n            x = make_global_var(ct, address);\n        }\n        Py_DECREF(ct);\n        break;\n    }\n\n    case _CFFI_OP_DLOPEN_FUNC:\n    {\n        /* For dlopen(): the function of the given 'name'.  We use\n           dlsym() to get the address of something in the dynamic\n           library, which we interpret as being exactly a function of\n           the specified type.\n        */\n        PyObject *ct1;\n        void *address = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n        if (address == NULL)\n            return NULL;\n\n        ct1 = realize_c_type_or_func(types_builder,\n                                     types_builder->ctx.types,\n                                     _CFFI_GETARG(g->type_op));\n        if (ct1 == NULL)\n            return NULL;\n\n        assert(!CTypeDescr_Check(ct1));   /* must be a function */\n        x = new_simple_cdata(address, unwrap_fn_as_fnptr(ct1));\n\n        Py_DECREF(ct1);\n        break;\n    }\n\n    default:\n        PyErr_Format(PyExc_NotImplementedError, \"in lib_build_attr: op=%d\",\n                     (int)_CFFI_GETOP(g->type_op));\n        return NULL;\n    }\n\n found:\n    if (x != NULL) {\n        int err = PyDict_SetItem(lib->l_dict, name, x);\n        Py_DECREF(x);\n        if (err < 0)     /* else there is still one ref left in the dict */\n            return NULL;\n    }\n    return x;\n}\n\n#define LIB_GET_OR_CACHE_ADDR(x, lib, name, error)      \\\n    do {                                                \\\n        x = PyDict_GetItem(lib->l_dict, name);          \\\n        if (x == NULL) {                                \\\n            x = lib_build_and_cache_attr(lib, name, 0); \\\n            if (x == NULL) {                            \\\n                error;                                  \\\n            }                                           \\\n        }                                               \\\n    } while (0)\n\nstatic PyObject *lib_getattr(LibObject *lib, PyObject *name)\n{\n    PyObject *x;\n    LIB_GET_OR_CACHE_ADDR(x, lib, name, return NULL);\n\n    if (GlobSupport_Check(x)) {\n        return read_global_var((GlobSupportObject *)x);\n    }\n    Py_INCREF(x);\n    return x;\n}\n\nstatic int lib_setattr(LibObject *lib, PyObject *name, PyObject *val)\n{\n    PyObject *x;\n    LIB_GET_OR_CACHE_ADDR(x, lib, name, return -1);\n\n    if (val == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"C attribute cannot be deleted\");\n        return -1;\n    }\n\n    if (GlobSupport_Check(x)) {\n        return write_global_var((GlobSupportObject *)x, val);\n    }\n\n    PyErr_Format(PyExc_AttributeError,\n                 \"cannot write to function or constant '%.200s'\",\n                 PyText_Check(name) ? PyText_AS_UTF8(name) : \"?\");\n    return -1;\n}\n\nstatic PyObject *lib_dir(LibObject *lib, PyObject *noarg)\n{\n    const struct _cffi_global_s *g = lib->l_types_builder->ctx.globals;\n    int i, total = lib->l_types_builder->ctx.num_globals;\n    PyObject *lst = PyList_New(total);\n    if (lst == NULL)\n        return NULL;\n\n    for (i = 0; i < total; i++) {\n        PyObject *s = PyText_FromString(g[i].name);\n        if (s == NULL) {\n            Py_DECREF(lst);\n            return NULL;\n        }\n        PyList_SET_ITEM(lst, i, s);\n    }\n    return lst;\n}\n\nstatic PyMethodDef lib_methods[] = {\n    {\"__dir__\",   (PyCFunction)lib_dir,  METH_NOARGS},\n    {NULL,        NULL}           /* sentinel */\n};\n\nstatic PyTypeObject Lib_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"CompiledLib\",\n    sizeof(LibObject),\n    0,\n    (destructor)lib_dealloc,                    /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)lib_repr,                         /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    (getattrofunc)lib_getattr,                  /* tp_getattro */\n    (setattrofunc)lib_setattr,                  /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)lib_traverse,                 /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    lib_methods,                                /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    offsetof(LibObject, l_dict),                /* tp_dictoffset */\n};\n\nstatic LibObject *lib_internal_new(FFIObject *ffi, char *module_name,\n                                   void *dlopen_libhandle)\n{\n    LibObject *lib;\n    PyObject *libname, *dict;\n\n    libname = PyText_FromString(module_name);\n    if (libname == NULL)\n        goto err1;\n\n    dict = PyDict_New();\n    if (dict == NULL)\n        goto err2;\n\n    lib = PyObject_New(LibObject, &Lib_Type);\n    if (lib == NULL)\n        goto err3;\n\n    lib->l_types_builder = &ffi->types_builder;\n    lib->l_dict = dict;\n    lib->l_libname = libname;\n    Py_INCREF(ffi);\n    lib->l_ffi = ffi;\n    lib->l_libhandle = dlopen_libhandle;\n    return lib;\n\n err3:\n    Py_DECREF(dict);\n err2:\n    Py_DECREF(libname);\n err1:\n    cdlopen_close_ignore_errors(dlopen_libhandle);\n    return NULL;\n}\n\nstatic PyObject *address_of_global_var(PyObject *args)\n{\n    LibObject *lib;\n    PyObject *x, *o_varname;\n    char *varname;\n\n    if (!PyArg_ParseTuple(args, \"O!s\", &Lib_Type, &lib, &varname))\n        return NULL;\n\n    /* rebuild a string from 'varname', to do typechecks and to force\n       a unicode back to a plain string (on python 2) */\n    o_varname = PyText_FromString(varname);\n    if (o_varname == NULL)\n        return NULL;\n\n    LIB_GET_OR_CACHE_ADDR(x, lib, o_varname, goto error);\n    Py_DECREF(o_varname);\n    if (GlobSupport_Check(x)) {\n        return cg_addressof_global_var((GlobSupportObject *)x);\n    }\n    else {\n        struct CPyExtFunc_s *exf = _cpyextfunc_get(x);\n        if (exf != NULL) {  /* an OP_CPYTHON_BLTN: '&func' returns a cdata */\n            PyObject *ct;\n            if (exf->direct_fn == NULL) {\n                Py_INCREF(x);    /* backward compatibility */\n                return x;\n            }\n            ct = _cpyextfunc_type(lib, exf);\n            if (ct == NULL)\n                return NULL;\n            x = new_simple_cdata(exf->direct_fn, (CTypeDescrObject *)ct);\n            Py_DECREF(ct);\n            return x;\n        }\n        if (CData_Check(x) &&  /* a constant functionptr cdata: 'f == &f' */\n                (((CDataObject *)x)->c_type->ct_flags & CT_FUNCTIONPTR) != 0) {\n            Py_INCREF(x);\n            return x;\n        }\n        else {\n            PyErr_Format(PyExc_AttributeError,\n                         \"cannot take the address of the constant '%.200s'\",\n                         varname);\n            return NULL;\n        }\n    }\n\n error:\n    Py_DECREF(o_varname);\n    return NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-slie2xlghwqb34kwk6dwl34nztyqctdw/spack-src/c/cdlopen.c": "/* ffi.dlopen() interface with dlopen()/dlsym()/dlclose() */\n\nstatic void *cdlopen_fetch(PyObject *libname, void *libhandle, char *symbol)\n{\n    void *address;\n\n    if (libhandle == NULL) {\n        PyErr_Format(FFIError, \"library '%s' has been closed\",\n                     PyText_AS_UTF8(libname));\n        return NULL;\n    }\n\n    dlerror();   /* clear error condition */\n    address = dlsym(libhandle, symbol);\n    if (address == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(FFIError, \"symbol '%s' not found in library '%s': %s\",\n                     symbol, PyText_AS_UTF8(libname), error);\n    }\n    return address;\n}\n\nstatic void cdlopen_close_ignore_errors(void *libhandle)\n{\n    if (libhandle != NULL)\n        dlclose(libhandle);\n}\n\nstatic int cdlopen_close(PyObject *libname, void *libhandle)\n{\n    if (libhandle != NULL && dlclose(libhandle) != 0) {\n        const char *error = dlerror();\n        PyErr_Format(FFIError, \"closing library '%s': %s\",\n                     PyText_AS_UTF8(libname), error);\n        return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *ffi_dlopen(PyObject *self, PyObject *args)\n{\n    char *filename_or_null, *printable_filename;\n    void *handle;\n    int flags = 0;\n\n    if (PyTuple_GET_SIZE(args) == 0 || PyTuple_GET_ITEM(args, 0) == Py_None) {\n        PyObject *dummy;\n        if (!PyArg_ParseTuple(args, \"|Oi:load_library\",\n                              &dummy, &flags))\n            return NULL;\n        filename_or_null = NULL;\n    }\n    else if (!PyArg_ParseTuple(args, \"et|i:load_library\",\n                          Py_FileSystemDefaultEncoding, &filename_or_null,\n                          &flags))\n        return NULL;\n\n    if ((flags & (RTLD_NOW | RTLD_LAZY)) == 0)\n        flags |= RTLD_NOW;\n    printable_filename = filename_or_null ? filename_or_null : \"<None>\";\n\n    handle = dlopen(filename_or_null, flags);\n    if (handle == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_OSError, \"cannot load library '%s': %s\",\n                     printable_filename, error);\n        return NULL;\n    }\n    return (PyObject *)lib_internal_new((FFIObject *)self,\n                                        printable_filename, handle);\n}\n\nstatic PyObject *ffi_dlclose(PyObject *self, PyObject *args)\n{\n    LibObject *lib;\n    void *libhandle;\n    if (!PyArg_ParseTuple(args, \"O!\", &Lib_Type, &lib))\n        return NULL;\n\n    libhandle = lib->l_libhandle;\n    lib->l_libhandle = NULL;\n\n    if (libhandle == NULL) {\n        PyErr_Format(FFIError, \"library '%s' is already closed \"\n                     \"or was not created with ffi.dlopen()\",\n                     PyText_AS_UTF8(lib->l_libname));\n        return NULL;\n    }\n\n    /* Clear the dict to force further accesses to do cdlopen_fetch()\n       again, and fail because the library was closed. */\n    PyDict_Clear(lib->l_dict);\n\n    if (cdlopen_close(lib->l_libname, libhandle) < 0)\n        return NULL;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\n\nstatic Py_ssize_t cdl_4bytes(char *src)\n{\n    /* read 4 bytes in little-endian order; return it as a signed integer */\n    signed char *ssrc = (signed char *)src;\n    unsigned char *usrc = (unsigned char *)src;\n    return (ssrc[0] << 24) | (usrc[1] << 16) | (usrc[2] << 8) | usrc[3];\n}\n\nstatic _cffi_opcode_t cdl_opcode(char *src)\n{\n    return (_cffi_opcode_t)cdl_4bytes(src);\n}\n\ntypedef struct {\n    unsigned long long value;\n    int neg;\n} cdl_intconst_t;\n\nstatic int _cdl_realize_global_int(struct _cffi_getconst_s *gc)\n{\n    /* The 'address' field of 'struct _cffi_global_s' is set to point\n       to this function in case ffiobj_init() sees constant integers.\n       This fishes around after the 'ctx->globals' array, which is\n       initialized to contain another array, this time of\n       'cdl_intconst_t' structures.  We get the nth one and it tells\n       us what to return.\n    */\n    cdl_intconst_t *ic;\n    ic = (cdl_intconst_t *)(gc->ctx->globals + gc->ctx->num_globals);\n    ic += gc->gindex;\n    gc->value = ic->value;\n    return ic->neg;\n}\n\nstatic int ffiobj_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    FFIObject *ffi;\n    static char *keywords[] = {\"module_name\", \"_version\", \"_types\",\n                               \"_globals\", \"_struct_unions\", \"_enums\",\n                               \"_typenames\", \"_includes\", NULL};\n    char *ffiname = \"?\", *types = NULL, *building = NULL;\n    Py_ssize_t version = -1;\n    Py_ssize_t types_len = 0;\n    PyObject *globals = NULL, *struct_unions = NULL, *enums = NULL;\n    PyObject *typenames = NULL, *includes = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"|sns#O!O!O!O!O!:FFI\", keywords,\n                                     &ffiname, &version, &types, &types_len,\n                                     &PyTuple_Type, &globals,\n                                     &PyTuple_Type, &struct_unions,\n                                     &PyTuple_Type, &enums,\n                                     &PyTuple_Type, &typenames,\n                                     &PyTuple_Type, &includes))\n        return -1;\n\n    ffi = (FFIObject *)self;\n    if (ffi->ctx_is_nonempty) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"cannot call FFI.__init__() more than once\");\n        return -1;\n    }\n    ffi->ctx_is_nonempty = 1;\n\n    if (version == -1 && types_len == 0)\n        return 0;\n    if (version < CFFI_VERSION_MIN || version > CFFI_VERSION_MAX) {\n        PyErr_Format(PyExc_ImportError,\n                     \"cffi out-of-line Python module '%s' has unknown \"\n                     \"version %p\", ffiname, (void *)version);\n        return -1;\n    }\n\n    if (types_len > 0) {\n        /* unpack a string of 4-byte entries into an array of _cffi_opcode_t */\n        _cffi_opcode_t *ntypes;\n        Py_ssize_t i, n = types_len / 4;\n\n        building = PyMem_Malloc(n * sizeof(_cffi_opcode_t));\n        if (building == NULL)\n            goto error;\n        ntypes = (_cffi_opcode_t *)building;\n\n        for (i = 0; i < n; i++) {\n            ntypes[i] = cdl_opcode(types);\n            types += 4;\n        }\n        ffi->types_builder.ctx.types = ntypes;\n        ffi->types_builder.ctx.num_types = n;\n        building = NULL;\n    }\n\n    if (globals != NULL) {\n        /* unpack a tuple alternating strings and ints, each two together\n           describing one global_s entry with no specified address or size.\n           The int is only used with integer constants. */\n        struct _cffi_global_s *nglobs;\n        cdl_intconst_t *nintconsts;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(globals) / 2;\n\n        i = n * (sizeof(struct _cffi_global_s) + sizeof(cdl_intconst_t));\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nglobs = (struct _cffi_global_s *)building;\n        nintconsts = (cdl_intconst_t *)(nglobs + n);\n\n        for (i = 0; i < n; i++) {\n            char *g = PyBytes_AS_STRING(PyTuple_GET_ITEM(globals, i * 2));\n            nglobs[i].type_op = cdl_opcode(g); g += 4;\n            nglobs[i].name = g;\n            if (_CFFI_GETOP(nglobs[i].type_op) == _CFFI_OP_CONSTANT_INT ||\n                _CFFI_GETOP(nglobs[i].type_op) == _CFFI_OP_ENUM) {\n                PyObject *o = PyTuple_GET_ITEM(globals, i * 2 + 1);\n                nglobs[i].address = &_cdl_realize_global_int;\n#if PY_MAJOR_VERSION < 3\n                if (PyInt_Check(o)) {\n                    nintconsts[i].neg = PyInt_AS_LONG(o) <= 0;\n                    nintconsts[i].value = (long long)PyInt_AS_LONG(o);\n                }\n                else\n#endif\n                {\n                    nintconsts[i].neg = PyObject_RichCompareBool(o, Py_False,\n                                                                 Py_LE);\n                    nintconsts[i].value = PyLong_AsUnsignedLongLongMask(o);\n                    if (PyErr_Occurred())\n                        goto error;\n                }\n            }\n        }\n        ffi->types_builder.ctx.globals = nglobs;\n        ffi->types_builder.ctx.num_globals = n;\n        building = NULL;\n    }\n\n    if (struct_unions != NULL) {\n        /* unpack a tuple of struct/unions, each described as a sub-tuple;\n           the item 0 of each sub-tuple describes the struct/union, and\n           the items 1..N-1 describe the fields, if any */\n        struct _cffi_struct_union_s *nstructs;\n        struct _cffi_field_s *nfields;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(struct_unions);\n        Py_ssize_t nf = 0;   /* total number of fields */\n\n        for (i = 0; i < n; i++) {\n            nf += PyTuple_GET_SIZE(PyTuple_GET_ITEM(struct_unions, i)) - 1;\n        }\n        i = (n * sizeof(struct _cffi_struct_union_s) +\n             nf * sizeof(struct _cffi_field_s));\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nstructs = (struct _cffi_struct_union_s *)building;\n        nfields = (struct _cffi_field_s *)(nstructs + n);\n        nf = 0;\n\n        for (i = 0; i < n; i++) {\n            /* 'desc' is the tuple of strings (desc_struct, desc_field_1, ..) */\n            PyObject *desc = PyTuple_GET_ITEM(struct_unions, i);\n            Py_ssize_t j, nf1 = PyTuple_GET_SIZE(desc) - 1;\n            char *s = PyBytes_AS_STRING(PyTuple_GET_ITEM(desc, 0));\n            /* 's' is the first string, describing the struct/union */\n            nstructs[i].type_index = cdl_4bytes(s); s += 4;\n            nstructs[i].flags = cdl_4bytes(s); s += 4;\n            nstructs[i].name = s;\n            if (nstructs[i].flags & (_CFFI_F_OPAQUE | _CFFI_F_EXTERNAL)) {\n                nstructs[i].size = (size_t)-1;\n                nstructs[i].alignment = -1;\n                nstructs[i].first_field_index = -1;\n                nstructs[i].num_fields = 0;\n                assert(nf1 == 0);\n            }\n            else {\n                nstructs[i].size = (size_t)-2;\n                nstructs[i].alignment = -2;\n                nstructs[i].first_field_index = nf;\n                nstructs[i].num_fields = nf1;\n            }\n            for (j = 0; j < nf1; j++) {\n                char *f = PyBytes_AS_STRING(PyTuple_GET_ITEM(desc, j + 1));\n                /* 'f' is one of the other strings beyond the first one,\n                   describing one field each */\n                nfields[nf].field_type_op = cdl_opcode(f); f += 4;\n                nfields[nf].field_offset = (size_t)-1;\n                if (_CFFI_GETOP(nfields[nf].field_type_op) != _CFFI_OP_NOOP) {\n                    nfields[nf].field_size = cdl_4bytes(f); f += 4;\n                }\n                else {\n                    nfields[nf].field_size = (size_t)-1;\n                }\n                nfields[nf].name = f;\n                nf++;\n            }\n        }\n        ffi->types_builder.ctx.struct_unions = nstructs;\n        ffi->types_builder.ctx.fields = nfields;\n        ffi->types_builder.ctx.num_struct_unions = n;\n        building = NULL;\n    }\n\n    if (enums != NULL) {\n        /* unpack a tuple of strings, each of which describes one enum_s\n           entry */\n        struct _cffi_enum_s *nenums;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(enums);\n\n        i = n * sizeof(struct _cffi_enum_s);\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nenums = (struct _cffi_enum_s *)building;\n\n        for (i = 0; i < n; i++) {\n            char *e = PyBytes_AS_STRING(PyTuple_GET_ITEM(enums, i));\n            /* 'e' is a string describing the enum */\n            nenums[i].type_index = cdl_4bytes(e); e += 4;\n            nenums[i].type_prim = cdl_4bytes(e); e += 4;\n            nenums[i].name = e; e += strlen(e) + 1;\n            nenums[i].enumerators = e;\n        }\n        ffi->types_builder.ctx.enums = nenums;\n        ffi->types_builder.ctx.num_enums = n;\n        building = NULL;\n    }\n\n    if (typenames != NULL) {\n        /* unpack a tuple of strings, each of which describes one typename_s\n           entry */\n        struct _cffi_typename_s *ntypenames;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(typenames);\n\n        i = n * sizeof(struct _cffi_typename_s);\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        ntypenames = (struct _cffi_typename_s *)building;\n\n        for (i = 0; i < n; i++) {\n            char *t = PyBytes_AS_STRING(PyTuple_GET_ITEM(typenames, i));\n            /* 't' is a string describing the typename */\n            ntypenames[i].type_index = cdl_4bytes(t); t += 4;\n            ntypenames[i].name = t;\n        }\n        ffi->types_builder.ctx.typenames = ntypenames;\n        ffi->types_builder.ctx.num_typenames = n;\n        building = NULL;\n    }\n\n    if (includes != NULL) {\n        PyObject *included_libs;\n\n        included_libs = PyTuple_New(PyTuple_GET_SIZE(includes));\n        if (included_libs == NULL)\n            return -1;\n\n        Py_INCREF(includes);\n        ffi->types_builder.included_ffis = includes;\n        ffi->types_builder.included_libs = included_libs;\n    }\n\n    /* Above, we took directly some \"char *\" strings out of the strings,\n       typically from somewhere inside tuples.  Keep them alive by\n       incref'ing the whole input arguments. */\n    Py_INCREF(args);\n    Py_XINCREF(kwds);\n    ffi->types_builder._keepalive1 = args;\n    ffi->types_builder._keepalive2 = kwds;\n    return 0;\n\n error:\n    if (building != NULL)\n        PyMem_Free(building);\n    if (!PyErr_Occurred())\n        PyErr_NoMemory();\n    return -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-slie2xlghwqb34kwk6dwl34nztyqctdw/spack-src/c/misc_win32.h": "#include <malloc.h>   /* for alloca() */\n\n/************************************************************/\n/* errno and GetLastError support */\n\nstruct cffi_errno_s {\n    int saved_errno;\n    int saved_lasterror;\n};\n\nstatic DWORD cffi_tls_index;\n\nstatic void init_errno(void)\n{\n    cffi_tls_index = TlsAlloc();\n    if (cffi_tls_index == TLS_OUT_OF_INDEXES)\n        PyErr_SetString(PyExc_WindowsError, \"TlsAlloc() failed\");\n}\n\nstatic struct cffi_errno_s *_geterrno_object(void)\n{\n    LPVOID p = TlsGetValue(cffi_tls_index);\n\n    if (p == NULL) {\n        /* XXX this malloc() leaks */\n        p = malloc(sizeof(struct cffi_errno_s));\n        if (p == NULL)\n            return NULL;\n        memset(p, 0, sizeof(struct cffi_errno_s));\n        TlsSetValue(cffi_tls_index, p);\n    }\n    return (struct cffi_errno_s *)p;\n}\n\nstatic void save_errno(void)\n{\n    int current_err = errno;\n    int current_lasterr = GetLastError();\n    struct cffi_errno_s *p;\n\n    p = _geterrno_object();\n    if (p != NULL) {\n        p->saved_errno = current_err;\n        p->saved_lasterror = current_lasterr;\n    }\n    /* else: cannot report the error */\n}\n\nstatic void save_errno_only(void)\n{\n    int current_err = errno;\n    struct cffi_errno_s *p;\n\n    p = _geterrno_object();\n    if (p != NULL) {\n        p->saved_errno = current_err;\n    }\n    /* else: cannot report the error */\n}\n\nstatic void restore_errno(void)\n{\n    struct cffi_errno_s *p;\n\n    p = _geterrno_object();\n    if (p != NULL) {\n        SetLastError(p->saved_lasterror);\n        errno = p->saved_errno;\n    }\n    /* else: cannot report the error */\n}\n\nstatic void restore_errno_only(void)\n{\n    struct cffi_errno_s *p;\n\n    p = _geterrno_object();\n    if (p != NULL) {\n        errno = p->saved_errno;\n    }\n    /* else: cannot report the error */\n}\n\n#if PY_MAJOR_VERSION >= 3\nstatic PyObject *b_getwinerror(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    int err = -1;\n    int len;\n    WCHAR *s_buf = NULL; /* Free via LocalFree */\n    PyObject *v, *message;\n    static char *keywords[] = {\"code\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", keywords, &err))\n        return NULL;\n\n    if (err == -1) {\n        struct cffi_errno_s *p;\n        p = _geterrno_object();\n        if (p == NULL)\n            return PyErr_NoMemory();\n        err = p->saved_lasterror;\n    }\n\n    len = FormatMessageW(\n        /* Error API error */\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,           /* no message source */\n        err,\n        MAKELANGID(LANG_NEUTRAL,\n        SUBLANG_DEFAULT), /* Default language */\n        (LPWSTR) &s_buf,\n        0,              /* size not used */\n        NULL);          /* no args */\n    if (len==0) {\n        /* Only seen this in out of mem situations */\n        message = PyUnicode_FromFormat(\"Windows Error 0x%X\", err);\n    } else {\n        /* remove trailing cr/lf and dots */\n        while (len > 0 && (s_buf[len-1] <= L' ' || s_buf[len-1] == L'.'))\n            s_buf[--len] = L'\\0';\n        message = PyUnicode_FromWideChar(s_buf, len);\n    }\n    if (message != NULL)\n        v = Py_BuildValue(\"(iO)\", err, message);\n    else\n        v = NULL;\n    LocalFree(s_buf);\n    return v;\n}\n#else\nstatic PyObject *b_getwinerror(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    int err = -1;\n    int len;\n    char *s;\n    char *s_buf = NULL; /* Free via LocalFree */\n    char s_small_buf[28]; /* Room for \"Windows Error 0xFFFFFFFF\" */\n    PyObject *v;\n    static char *keywords[] = {\"code\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", keywords, &err))\n        return NULL;\n\n    if (err == -1) {\n        struct cffi_errno_s *p;\n        p = _geterrno_object();\n        if (p == NULL)\n            return PyErr_NoMemory();\n        err = p->saved_lasterror;\n    }\n\n    len = FormatMessage(\n        /* Error API error */\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,           /* no message source */\n        err,\n        MAKELANGID(LANG_NEUTRAL,\n        SUBLANG_DEFAULT), /* Default language */\n        (LPTSTR) &s_buf,\n        0,              /* size not used */\n        NULL);          /* no args */\n    if (len==0) {\n        /* Only seen this in out of mem situations */\n        sprintf(s_small_buf, \"Windows Error 0x%X\", err);\n        s = s_small_buf;\n        s_buf = NULL;\n    } else {\n        s = s_buf;\n        /* remove trailing cr/lf and dots */\n        while (len > 0 && (s[len-1] <= ' ' || s[len-1] == '.'))\n            s[--len] = '\\0';\n    }\n    v = Py_BuildValue(\"(is)\", err, s);\n    LocalFree(s_buf);\n    return v;\n}\n#endif\n\n/************************************************************/\n/* Emulate dlopen()&co. from the Windows API */\n\n#define RTLD_LAZY   0\n#define RTLD_NOW    0\n#define RTLD_GLOBAL 0\n#define RTLD_LOCAL  0\n\nstatic void *dlopen(const char *filename, int flag)\n{\n    return (void *)LoadLibrary(filename);\n}\n\nstatic void *dlsym(void *handle, const char *symbol)\n{\n    void *address = GetProcAddress((HMODULE)handle, symbol);\n#ifndef MS_WIN64\n    if (!address) {\n        /* If 'symbol' is not found, then try '_symbol@N' for N in\n           (0, 4, 8, 12, ..., 124).  Unlike ctypes, we try to do that\n           for any symbol, although in theory it should only be done\n           for __stdcall functions.\n        */\n        int i;\n        char *mangled_name = alloca(1 + strlen(symbol) + 1 + 3 + 1);\n        if (!mangled_name)\n            return NULL;\n        for (i = 0; i < 32; i++) {\n            sprintf(mangled_name, \"_%s@%d\", symbol, i * 4);\n            address = GetProcAddress((HMODULE)handle, mangled_name);\n            if (address)\n                break;\n        }\n    }\n#endif\n    return address;\n}\n\nstatic int dlclose(void *handle)\n{\n    return FreeLibrary((HMODULE)handle) ? 0 : -1;\n}\n\nstatic const char *dlerror(void)\n{\n    static char buf[32];\n    DWORD dw = GetLastError(); \n    if (dw == 0)\n        return NULL;\n    sprintf(buf, \"error 0x%x\", (unsigned int)dw);\n    return buf;\n}\n\n/************************************************************/\n/* obscure */\n\n#define ffi_prep_closure(a,b,c,d)  ffi_prep_closure_loc(a,b,c,d,a)\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.1.2-slie2xlghwqb34kwk6dwl34nztyqctdw/spack-src/c/libffi_msvc/win64.obj"
    ],
    "total_files": 141
}