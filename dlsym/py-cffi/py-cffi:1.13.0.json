{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-r7eyruhs753zj2t2iswwndobx22sf2dp/spack-src/c/_cffi_backend.c": "#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n#include \"structmember.h\"\n\n#define CFFI_VERSION  \"1.13.0\"\n\n#ifdef MS_WIN32\n#include <windows.h>\n#include \"misc_win32.h\"\n#else\n#include <stddef.h>\n#include <stdint.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <ffi.h>\n#include <sys/mman.h>\n#endif\n\n/* this block of #ifs should be kept exactly identical between\n   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py */\n#if defined(_MSC_VER)\n# include <malloc.h>   /* for alloca() */\n# if _MSC_VER < 1600   /* MSVC < 2010 */\n   typedef __int8 int8_t;\n   typedef __int16 int16_t;\n   typedef __int32 int32_t;\n   typedef __int64 int64_t;\n   typedef unsigned __int8 uint8_t;\n   typedef unsigned __int16 uint16_t;\n   typedef unsigned __int32 uint32_t;\n   typedef unsigned __int64 uint64_t;\n   typedef __int8 int_least8_t;\n   typedef __int16 int_least16_t;\n   typedef __int32 int_least32_t;\n   typedef __int64 int_least64_t;\n   typedef unsigned __int8 uint_least8_t;\n   typedef unsigned __int16 uint_least16_t;\n   typedef unsigned __int32 uint_least32_t;\n   typedef unsigned __int64 uint_least64_t;\n   typedef __int8 int_fast8_t;\n   typedef __int16 int_fast16_t;\n   typedef __int32 int_fast32_t;\n   typedef __int64 int_fast64_t;\n   typedef unsigned __int8 uint_fast8_t;\n   typedef unsigned __int16 uint_fast16_t;\n   typedef unsigned __int32 uint_fast32_t;\n   typedef unsigned __int64 uint_fast64_t;\n   typedef __int64 intmax_t;\n   typedef unsigned __int64 uintmax_t;\n# else\n#  include <stdint.h>\n# endif\n# if _MSC_VER < 1800   /* MSVC < 2013 */\n   typedef unsigned char _Bool;\n# endif\n#else\n# include <stdint.h>\n# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)\n#  include <alloca.h>\n# endif\n#endif\n\n\n/* Define the following macro ONLY if you trust libffi's version of\n * ffi_closure_alloc() more than the code in malloc_closure.h.\n * IMPORTANT: DO NOT ENABLE THIS ON LINUX, unless you understand exactly\n * why I recommend against it and decide that you trust it more than my\n * analysis below.\n *\n * There are two versions of this code: one inside libffi itself, and\n * one inside malloc_closure.h here.  Both should be fine as long as the\n * Linux distribution does _not_ enable extra security features.  If it\n * does, then the code in malloc_closure.h will cleanly crash because\n * there is no reasonable way to obtain a read-write-execute memory\n * page.  On the other hand, the code in libffi will appear to\n * work---but will actually randomly crash after a fork() if the child\n * does not immediately call exec().  This second crash is of the kind\n * that can be turned into an attack vector by a motivated attacker.\n * So, _enabling_ extra security features _opens_ an attack vector.\n * That sounds like a horribly bad idea to me, and is the reason for why\n * I prefer CFFI crashing cleanly.\n *\n * Currently, we use libffi's ffi_closure_alloc() only on NetBSD.  It is\n * known that on the NetBSD kernel, a different strategy is used which\n * should not be open to the fork() bug.\n */\n#ifdef __NetBSD__\n# define CFFI_TRUST_LIBFFI\n#endif\n\n#ifndef CFFI_TRUST_LIBFFI\n# include \"malloc_closure.h\"\n#endif\n\n\n#if PY_MAJOR_VERSION >= 3\n# define STR_OR_BYTES \"bytes\"\n# define PyText_Type PyUnicode_Type\n# define PyText_Check PyUnicode_Check\n# define PyTextAny_Check PyUnicode_Check\n# define PyText_FromFormat PyUnicode_FromFormat\n# define PyText_AsUTF8 _PyUnicode_AsString   /* PyUnicode_AsUTF8 in Py3.3 */\n# define PyText_AS_UTF8 _PyUnicode_AsString\n# if PY_VERSION_HEX >= 0x03030000\n#  define PyText_GetSize PyUnicode_GetLength\n# else\n#  define PyText_GetSize PyUnicode_GetSize\n# endif\n# define PyText_FromString PyUnicode_FromString\n# define PyText_FromStringAndSize PyUnicode_FromStringAndSize\n# define PyText_InternInPlace PyUnicode_InternInPlace\n# define PyText_InternFromString PyUnicode_InternFromString\n# define PyIntOrLong_Check PyLong_Check\n#else\n# define STR_OR_BYTES \"str\"\n# define PyText_Type PyString_Type\n# define PyText_Check PyString_Check\n# define PyTextAny_Check(op) (PyString_Check(op) || PyUnicode_Check(op))\n# define PyText_FromFormat PyString_FromFormat\n# define PyText_AsUTF8 PyString_AsString\n# define PyText_AS_UTF8 PyString_AS_STRING\n# define PyText_GetSize PyString_Size\n# define PyText_FromString PyString_FromString\n# define PyText_FromStringAndSize PyString_FromStringAndSize\n# define PyText_InternInPlace PyString_InternInPlace\n# define PyText_InternFromString PyString_InternFromString\n# define PyIntOrLong_Check(op) (PyInt_Check(op) || PyLong_Check(op))\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n# define PyInt_FromLong PyLong_FromLong\n# define PyInt_FromSsize_t PyLong_FromSsize_t\n# define PyInt_AsSsize_t PyLong_AsSsize_t\n# define PyInt_AsLong PyLong_AsLong\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n/* This is the default on Python3 and constant has been removed. */\n# define Py_TPFLAGS_CHECKTYPES 0\n#endif\n\n#if PY_MAJOR_VERSION < 3\n# undef PyCapsule_GetPointer\n# undef PyCapsule_New\n# define PyCapsule_GetPointer(capsule, name) \\\n    (PyCObject_AsVoidPtr(capsule))\n# define PyCapsule_New(pointer, name, destructor) \\\n    (PyCObject_FromVoidPtr(pointer, destructor))\n#endif\n\n/************************************************************/\n\n/* base type flag: exactly one of the following: */\n#define CT_PRIMITIVE_SIGNED   0x001   /* signed integer */\n#define CT_PRIMITIVE_UNSIGNED 0x002   /* unsigned integer */\n#define CT_PRIMITIVE_CHAR     0x004   /* char, wchar_t, charN_t */\n#define CT_PRIMITIVE_FLOAT    0x008   /* float, double, long double */\n#define CT_POINTER            0x010   /* pointer, excluding ptr-to-func */\n#define CT_ARRAY              0x020   /* array */\n#define CT_STRUCT             0x040   /* struct */\n#define CT_UNION              0x080   /* union */\n#define CT_FUNCTIONPTR        0x100   /* pointer to function */\n#define CT_VOID               0x200   /* void */\n#define CT_PRIMITIVE_COMPLEX  0x400   /* float _Complex, double _Complex */\n\n/* other flags that may also be set in addition to the base flag: */\n#define CT_IS_VOIDCHAR_PTR     0x00001000\n#define CT_PRIMITIVE_FITS_LONG 0x00002000\n#define CT_IS_OPAQUE           0x00004000\n#define CT_IS_ENUM             0x00008000\n#define CT_IS_PTR_TO_OWNED     0x00010000 /* only owned if CDataOwning_Type */\n#define CT_CUSTOM_FIELD_POS    0x00020000\n#define CT_IS_LONGDOUBLE       0x00040000\n#define CT_IS_BOOL             0x00080000\n#define CT_IS_FILE             0x00100000\n#define CT_IS_VOID_PTR         0x00200000\n#define CT_WITH_VAR_ARRAY      0x00400000 /* with open-ended array, anywhere */\n/* unused                      0x00800000 */\n#define CT_LAZY_FIELD_LIST     0x01000000\n#define CT_WITH_PACKED_CHANGE  0x02000000\n#define CT_IS_SIGNED_WCHAR     0x04000000\n#define CT_PRIMITIVE_ANY  (CT_PRIMITIVE_SIGNED |        \\\n                           CT_PRIMITIVE_UNSIGNED |      \\\n                           CT_PRIMITIVE_CHAR |          \\\n                           CT_PRIMITIVE_FLOAT |         \\\n                           CT_PRIMITIVE_COMPLEX)\n\ntypedef struct _ctypedescr {\n    PyObject_VAR_HEAD\n\n    struct _ctypedescr *ct_itemdescr;  /* ptrs and arrays: the item type */\n    PyObject *ct_stuff;                /* structs: dict of the fields\n                                          arrays: ctypedescr of the ptr type\n                                          function: tuple(abi, ctres, ctargs..)\n                                          enum: pair {\"name\":x},{x:\"name\"}\n                                          ptrs: lazily, ctypedescr of array */\n    void *ct_extra;                    /* structs: first field (not a ref!)\n                                          function types: cif_description\n                                          primitives: prebuilt \"cif\" object */\n\n    PyObject *ct_weakreflist;    /* weakref support */\n\n    PyObject *ct_unique_key;    /* key in unique_cache (a string, but not\n                                   human-readable) */\n\n    Py_ssize_t ct_size;     /* size of instances, or -1 if unknown */\n    Py_ssize_t ct_length;   /* length of arrays, or -1 if unknown;\n                               or alignment of primitive and struct types;\n                               always -1 for pointers */\n    int ct_flags;           /* CT_xxx flags */\n\n    int ct_name_position;   /* index in ct_name of where to put a var name */\n    char ct_name[1];        /* string, e.g. \"int *\" for pointers to ints */\n} CTypeDescrObject;\n\ntypedef struct {\n    PyObject_HEAD\n    CTypeDescrObject *c_type;\n    char *c_data;\n    PyObject *c_weakreflist;\n} CDataObject;\n\ntypedef struct cfieldobject_s {\n    PyObject_HEAD\n    CTypeDescrObject *cf_type;\n    Py_ssize_t cf_offset;\n    short cf_bitshift;   /* >= 0: bitshift; or BS_REGULAR or BS_EMPTY_ARRAY */\n    short cf_bitsize;\n    unsigned char cf_flags;   /* BF_... */\n    struct cfieldobject_s *cf_next;\n} CFieldObject;\n#define BS_REGULAR            (-1) /* a regular field, not with bitshift */\n#define BS_EMPTY_ARRAY        (-2) /* a field declared 'type[0]' or 'type[]' */\n#define BF_IGNORE_IN_CTOR     0x01 /* union field not in the first place */\n\nstatic PyTypeObject CTypeDescr_Type;\nstatic PyTypeObject CField_Type;\nstatic PyTypeObject CData_Type;\nstatic PyTypeObject CDataOwning_Type;\nstatic PyTypeObject CDataOwningGC_Type;\nstatic PyTypeObject CDataFromBuf_Type;\nstatic PyTypeObject CDataGCP_Type;\n\n#define CTypeDescr_Check(ob)  (Py_TYPE(ob) == &CTypeDescr_Type)\n#define CData_Check(ob)       (Py_TYPE(ob) == &CData_Type ||            \\\n                               Py_TYPE(ob) == &CDataOwning_Type ||      \\\n                               Py_TYPE(ob) == &CDataOwningGC_Type ||    \\\n                               Py_TYPE(ob) == &CDataFromBuf_Type ||     \\\n                               Py_TYPE(ob) == &CDataGCP_Type)\n#define CDataOwn_Check(ob)    (Py_TYPE(ob) == &CDataOwning_Type ||      \\\n                               Py_TYPE(ob) == &CDataOwningGC_Type)\n\ntypedef union {\n    unsigned char m_char;\n    unsigned short m_short;\n    unsigned int m_int;\n    unsigned long m_long;\n    unsigned long long m_longlong;\n    float m_float;\n    double m_double;\n    long double m_longdouble;\n} union_alignment;\n\ntypedef struct {\n    CDataObject head;\n    union_alignment alignment;\n} CDataObject_casted_primitive;\n\ntypedef struct {\n    CDataObject head;\n    union_alignment alignment;\n} CDataObject_own_nolength;\n\ntypedef struct {\n    CDataObject head;\n    Py_ssize_t length;\n    union_alignment alignment;\n} CDataObject_own_length;\n\ntypedef struct {\n    CDataObject head;\n    PyObject *structobj;   /* for ffi.new_handle() or ffi.new(\"struct *\") */\n} CDataObject_own_structptr;\n\ntypedef struct {\n    CDataObject head;\n    Py_ssize_t length;     /* same as CDataObject_own_length up to here */\n    Py_buffer *bufferview;\n} CDataObject_frombuf;\n\ntypedef struct {\n    CDataObject head;\n    Py_ssize_t length;     /* same as CDataObject_own_length up to here */\n    PyObject *origobj;\n    PyObject *destructor;\n} CDataObject_gcp;\n\ntypedef struct {\n    CDataObject head;\n    ffi_closure *closure;\n} CDataObject_closure;\n\ntypedef struct {\n    ffi_cif cif;\n    /* the following information is used when doing the call:\n       - a buffer of size 'exchange_size' is malloced\n       - the arguments are converted from Python objects to raw data\n       - the i'th raw data is stored at 'buffer + exchange_offset_arg[1+i]'\n       - the call is done\n       - the result is read back from 'buffer + exchange_offset_arg[0]' */\n    Py_ssize_t exchange_size;\n    Py_ssize_t exchange_offset_arg[1];\n} cif_description_t;\n\n#define ADD_WRAPAROUND(x, y)  ((Py_ssize_t)(((size_t)(x)) + ((size_t)(y))))\n#define MUL_WRAPAROUND(x, y)  ((Py_ssize_t)(((size_t)(x)) * ((size_t)(y))))\n\n\n/* whenever running Python code, the errno is saved in this thread-local\n   variable */\n#ifndef MS_WIN32\n# include \"misc_thread_posix.h\"\n#endif\n\n#include \"minibuffer.h\"\n\n#if PY_MAJOR_VERSION >= 3\n# include \"file_emulator.h\"\n#endif\n\n#ifdef PyUnicode_KIND     /* Python >= 3.3 */\n# include \"wchar_helper_3.h\"\n#else\n# include \"wchar_helper.h\"\n#endif\n\n#include \"../cffi/_cffi_errors.h\"\n\ntypedef struct _cffi_allocator_s {\n    PyObject *ca_alloc, *ca_free;\n    int ca_dont_clear;\n} cffi_allocator_t;\nstatic const cffi_allocator_t default_allocator = { NULL, NULL, 0 };\nstatic PyObject *FFIError;\nstatic PyObject *unique_cache;\n\n/************************************************************/\n\nstatic CTypeDescrObject *\nctypedescr_new(int name_size)\n{\n    CTypeDescrObject *ct = PyObject_GC_NewVar(CTypeDescrObject,\n                                              &CTypeDescr_Type,\n                                              name_size);\n    if (ct == NULL)\n        return NULL;\n\n    ct->ct_itemdescr = NULL;\n    ct->ct_stuff = NULL;\n    ct->ct_weakreflist = NULL;\n    ct->ct_unique_key = NULL;\n    PyObject_GC_Track(ct);\n    return ct;\n}\n\nstatic CTypeDescrObject *\nctypedescr_new_on_top(CTypeDescrObject *ct_base, const char *extra_text,\n                      int extra_position)\n{\n    int base_name_len = strlen(ct_base->ct_name);\n    int extra_name_len = strlen(extra_text);\n    CTypeDescrObject *ct = ctypedescr_new(base_name_len + extra_name_len + 1);\n    char *p;\n    if (ct == NULL)\n        return NULL;\n\n    Py_INCREF(ct_base);\n    ct->ct_itemdescr = ct_base;\n    ct->ct_name_position = ct_base->ct_name_position + extra_position;\n\n    p = ct->ct_name;\n    memcpy(p, ct_base->ct_name, ct_base->ct_name_position);\n    p += ct_base->ct_name_position;\n    memcpy(p, extra_text, extra_name_len);\n    p += extra_name_len;\n    memcpy(p, ct_base->ct_name + ct_base->ct_name_position,\n           base_name_len - ct_base->ct_name_position + 1);\n\n    return ct;\n}\n\nstatic PyObject *\nctypedescr_repr(CTypeDescrObject *ct)\n{\n    return PyText_FromFormat(\"<ctype '%s'>\", ct->ct_name);\n}\n\nstatic void\nctypedescr_dealloc(CTypeDescrObject *ct)\n{\n    PyObject_GC_UnTrack(ct);\n    if (ct->ct_weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) ct);\n\n    if (ct->ct_unique_key != NULL) {\n        /* revive dead object temporarily for DelItem */\n        Py_REFCNT(ct) = 43;\n        PyDict_DelItem(unique_cache, ct->ct_unique_key);\n        assert(Py_REFCNT(ct) == 42);\n        Py_REFCNT(ct) = 0;\n        Py_DECREF(ct->ct_unique_key);\n    }\n    Py_XDECREF(ct->ct_itemdescr);\n    Py_XDECREF(ct->ct_stuff);\n    if (ct->ct_flags & CT_FUNCTIONPTR)\n        PyObject_Free(ct->ct_extra);\n    Py_TYPE(ct)->tp_free((PyObject *)ct);\n}\n\nstatic int\nctypedescr_traverse(CTypeDescrObject *ct, visitproc visit, void *arg)\n{\n    Py_VISIT(ct->ct_itemdescr);\n    Py_VISIT(ct->ct_stuff);\n    return 0;\n}\n\nstatic int\nctypedescr_clear(CTypeDescrObject *ct)\n{\n    Py_CLEAR(ct->ct_itemdescr);\n    Py_CLEAR(ct->ct_stuff);\n    return 0;\n}\n\n\nstatic PyObject *nosuchattr(const char *attr)\n{\n    PyErr_SetString(PyExc_AttributeError, attr);\n    return NULL;\n}\n\nstatic PyObject *ctypeget_kind(CTypeDescrObject *ct, void *context)\n{\n    char *result;\n    if (ct->ct_flags & CT_PRIMITIVE_ANY) {\n        if (ct->ct_flags & CT_IS_ENUM)\n            result = \"enum\";\n        else\n            result = \"primitive\";\n    }\n    else if (ct->ct_flags & CT_POINTER) {\n        result = \"pointer\";\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        result = \"array\";\n    }\n    else if (ct->ct_flags & CT_VOID) {\n        result = \"void\";\n    }\n    else if (ct->ct_flags & CT_STRUCT) {\n        result = \"struct\";\n    }\n    else if (ct->ct_flags & CT_UNION) {\n        result = \"union\";\n    }\n    else if (ct->ct_flags & CT_FUNCTIONPTR) {\n        result = \"function\";\n    }\n    else\n        result = \"?\";\n\n    return PyText_FromString(result);\n}\n\nstatic PyObject *ctypeget_cname(CTypeDescrObject *ct, void *context)\n{\n    return PyText_FromString(ct->ct_name);\n}\n\nstatic PyObject *ctypeget_item(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & (CT_POINTER | CT_ARRAY)) {\n        Py_INCREF(ct->ct_itemdescr);\n        return (PyObject *)ct->ct_itemdescr;\n    }\n    return nosuchattr(\"item\");\n}\n\nstatic PyObject *ctypeget_length(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_ARRAY) {\n        if (ct->ct_length >= 0) {\n            return PyInt_FromSsize_t(ct->ct_length);\n        }\n        else {\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n    return nosuchattr(\"length\");\n}\n\nstatic PyObject *\nget_field_name(CTypeDescrObject *ct, CFieldObject *cf);   /* forward */\n\n/* returns 0 if the struct ctype is opaque, 1 if it is not, or -1 if\n   an exception occurs */\n#define force_lazy_struct(ct)                                           \\\n    ((ct)->ct_stuff != NULL ? 1 : do_realize_lazy_struct(ct))\n\nstatic int do_realize_lazy_struct(CTypeDescrObject *ct);\n/* forward, implemented in realize_c_type.c */\n\nstatic PyObject *ctypeget_fields(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & (CT_STRUCT | CT_UNION)) {\n        if (!(ct->ct_flags & CT_IS_OPAQUE)) {\n            CFieldObject *cf;\n            PyObject *res;\n            if (force_lazy_struct(ct) < 0)\n                return NULL;\n            res = PyList_New(0);\n            if (res == NULL)\n                return NULL;\n            for (cf = (CFieldObject *)ct->ct_extra;\n                 cf != NULL; cf = cf->cf_next) {\n                PyObject *o = PyTuple_Pack(2, get_field_name(ct, cf),\n                                           (PyObject *)cf);\n                int err = (o != NULL) ? PyList_Append(res, o) : -1;\n                Py_XDECREF(o);\n                if (err < 0) {\n                    Py_DECREF(res);\n                    return NULL;\n                }\n            }\n            return res;\n        }\n        else {\n            Py_INCREF(Py_None);\n            return Py_None;\n        }\n    }\n    return nosuchattr(\"fields\");\n}\n\nstatic PyObject *ctypeget_args(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *t = ct->ct_stuff;\n        return PyTuple_GetSlice(t, 2, PyTuple_GET_SIZE(t));\n    }\n    return nosuchattr(\"args\");\n}\n\nstatic PyObject *ctypeget_result(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 1);\n        Py_XINCREF(res);\n        return res;\n    }\n    return nosuchattr(\"result\");\n}\n\nstatic PyObject *ctypeget_ellipsis(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = ct->ct_extra ? Py_False : Py_True;\n        Py_INCREF(res);\n        return res;\n    }\n    return nosuchattr(\"ellipsis\");\n}\n\nstatic PyObject *ctypeget_abi(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_FUNCTIONPTR) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 0);\n        Py_XINCREF(res);\n        return res;\n    }\n    return nosuchattr(\"abi\");\n}\n\nstatic PyObject *ctypeget_elements(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_IS_ENUM) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 1);\n        if (res) res = PyDict_Copy(res);\n        return res;\n    }\n    return nosuchattr(\"elements\");\n}\n\nstatic PyObject *ctypeget_relements(CTypeDescrObject *ct, void *context)\n{\n    if (ct->ct_flags & CT_IS_ENUM) {\n        PyObject *res = PyTuple_GetItem(ct->ct_stuff, 0);\n        if (res) res = PyDict_Copy(res);\n        return res;\n    }\n    return nosuchattr(\"relements\");\n}\n\nstatic PyGetSetDef ctypedescr_getsets[] = {\n    {\"kind\", (getter)ctypeget_kind, NULL, \"kind\"},\n    {\"cname\", (getter)ctypeget_cname, NULL, \"C name\"},\n    {\"item\", (getter)ctypeget_item, NULL, \"pointer to, or array of\"},\n    {\"length\", (getter)ctypeget_length, NULL, \"array length or None\"},\n    {\"fields\", (getter)ctypeget_fields, NULL, \"struct or union fields\"},\n    {\"args\", (getter)ctypeget_args, NULL, \"function argument types\"},\n    {\"result\", (getter)ctypeget_result, NULL, \"function result type\"},\n    {\"ellipsis\", (getter)ctypeget_ellipsis, NULL, \"function has '...'\"},\n    {\"abi\", (getter)ctypeget_abi, NULL, \"function ABI\"},\n    {\"elements\", (getter)ctypeget_elements, NULL, \"enum elements\"},\n    {\"relements\", (getter)ctypeget_relements, NULL, \"enum elements, reverse\"},\n    {NULL}                        /* sentinel */\n};\n\nstatic PyObject *\nctypedescr_dir(PyObject *ct, PyObject *noarg)\n{\n    int err;\n    struct PyGetSetDef *gsdef;\n    PyObject *res = PyList_New(0);\n    if (res == NULL)\n        return NULL;\n\n    for (gsdef = ctypedescr_getsets; gsdef->name; gsdef++) {\n        PyObject *x = PyObject_GetAttrString(ct, gsdef->name);\n        if (x == NULL) {\n            PyErr_Clear();\n        }\n        else {\n            Py_DECREF(x);\n            x = PyText_FromString(gsdef->name);\n            err = (x != NULL) ? PyList_Append(res, x) : -1;\n            Py_XDECREF(x);\n            if (err < 0) {\n                Py_DECREF(res);\n                return NULL;\n            }\n        }\n    }\n    return res;\n}\n\nstatic PyMethodDef ctypedescr_methods[] = {\n    {\"__dir__\",   ctypedescr_dir,  METH_NOARGS},\n    {NULL,        NULL}           /* sentinel */\n};\n\nstatic PyTypeObject CTypeDescr_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CTypeDescr\",\n    offsetof(CTypeDescrObject, ct_name),\n    sizeof(char),\n    (destructor)ctypedescr_dealloc,             /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)ctypedescr_repr,                  /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,    /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)ctypedescr_traverse,          /* tp_traverse */\n    (inquiry)ctypedescr_clear,                  /* tp_clear */\n    0,                                          /* tp_richcompare */\n    offsetof(CTypeDescrObject, ct_weakreflist), /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    ctypedescr_methods,                         /* tp_methods */\n    0,                                          /* tp_members */\n    ctypedescr_getsets,                         /* tp_getset */\n};\n\n/************************************************************/\n\nstatic PyObject *\nget_field_name(CTypeDescrObject *ct, CFieldObject *cf)\n{\n    Py_ssize_t i = 0;\n    PyObject *d_key, *d_value;\n    while (PyDict_Next(ct->ct_stuff, &i, &d_key, &d_value)) {\n        if (d_value == (PyObject *)cf)\n            return d_key;\n    }\n    Py_FatalError(\"_cffi_backend: get_field_name()\");\n    return NULL;\n}\n\nstatic void\ncfield_dealloc(CFieldObject *cf)\n{\n    Py_DECREF(cf->cf_type);\n    PyObject_Del(cf);\n}\n\n#undef OFF\n#define OFF(x) offsetof(CFieldObject, x)\n\nstatic PyMemberDef cfield_members[] = {\n    {\"type\", T_OBJECT, OFF(cf_type), READONLY},\n    {\"offset\", T_PYSSIZET, OFF(cf_offset), READONLY},\n    {\"bitshift\", T_SHORT, OFF(cf_bitshift), READONLY},\n    {\"bitsize\", T_SHORT, OFF(cf_bitsize), READONLY},\n    {\"flags\", T_UBYTE, OFF(cf_flags), READONLY},\n    {NULL}      /* Sentinel */\n};\n#undef OFF\n\nstatic PyTypeObject CField_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CField\",\n    sizeof(CFieldObject),\n    0,\n    (destructor)cfield_dealloc,                 /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    PyObject_GenericGetAttr,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    cfield_members,                             /* tp_members */\n};\n\n/************************************************************/\n\nstatic int\nCDataObject_Or_PyFloat_Check(PyObject *ob)\n{\n    return (PyFloat_Check(ob) ||\n            (CData_Check(ob) &&\n             (((CDataObject *)ob)->c_type->ct_flags & CT_PRIMITIVE_FLOAT)));\n}\n\nstatic PY_LONG_LONG\n_my_PyLong_AsLongLong(PyObject *ob)\n{\n    /* (possibly) convert and cast a Python object to a long long.\n       Like PyLong_AsLongLong(), this version accepts a Python int too, and\n       does convertions from other types of objects.  The difference is that\n       this version refuses floats. */\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        return PyInt_AS_LONG(ob);\n    }\n    else \n#endif\n    if (PyLong_Check(ob)) {\n        return PyLong_AsLongLong(ob);\n    }\n    else {\n        PyObject *io;\n        PY_LONG_LONG res;\n        PyNumberMethods *nb = ob->ob_type->tp_as_number;\n\n        if (CDataObject_Or_PyFloat_Check(ob) ||\n                nb == NULL || nb->nb_int == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"an integer is required\");\n            return -1;\n        }\n        io = (*nb->nb_int) (ob);\n        if (io == NULL)\n            return -1;\n\n        if (PyIntOrLong_Check(io)) {\n            res = _my_PyLong_AsLongLong(io);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError, \"integer conversion failed\");\n            res = -1;\n        }\n        Py_DECREF(io);\n        return res;\n    }\n}\n\nstatic unsigned PY_LONG_LONG\n_my_PyLong_AsUnsignedLongLong(PyObject *ob, int strict)\n{\n    /* (possibly) convert and cast a Python object to an unsigned long long.\n       Like PyLong_AsLongLong(), this version accepts a Python int too, and\n       does convertions from other types of objects.  If 'strict', complains\n       with OverflowError and refuses floats.  If '!strict', rounds floats\n       and masks the result. */\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        long value1 = PyInt_AS_LONG(ob);\n        if (strict && value1 < 0)\n            goto negative;\n        return (unsigned PY_LONG_LONG)(PY_LONG_LONG)value1;\n    }\n    else\n#endif\n    if (PyLong_Check(ob)) {\n        if (strict) {\n            if (_PyLong_Sign(ob) < 0)\n                goto negative;\n            return PyLong_AsUnsignedLongLong(ob);\n        }\n        else {\n            return PyLong_AsUnsignedLongLongMask(ob);\n        }\n    }\n    else {\n        PyObject *io;\n        unsigned PY_LONG_LONG res;\n        PyNumberMethods *nb = ob->ob_type->tp_as_number;\n\n        if ((strict && CDataObject_Or_PyFloat_Check(ob)) ||\n                nb == NULL || nb->nb_int == NULL) {\n            PyErr_SetString(PyExc_TypeError, \"an integer is required\");\n            return (unsigned PY_LONG_LONG)-1;\n        }\n        io = (*nb->nb_int) (ob);\n        if (io == NULL)\n            return (unsigned PY_LONG_LONG)-1;\n\n        if (PyIntOrLong_Check(io)) {\n            res = _my_PyLong_AsUnsignedLongLong(io, strict);\n        }\n        else {\n            PyErr_SetString(PyExc_TypeError, \"integer conversion failed\");\n            res = (unsigned PY_LONG_LONG)-1;\n        }\n        Py_DECREF(io);\n        return res;\n    }\n\n negative:\n    PyErr_SetString(PyExc_OverflowError,\n                    \"can't convert negative number to unsigned\");\n    return (unsigned PY_LONG_LONG)-1;\n}\n\n#define _read_raw_data(type)                    \\\n    do {                                        \\\n        if (size == sizeof(type)) {             \\\n            type r;                             \\\n            memcpy(&r, target, sizeof(type));   \\\n            return r;                           \\\n        }                                       \\\n    } while(0)\n\nstatic PY_LONG_LONG\nread_raw_signed_data(char *target, int size)\n{\n    _read_raw_data(signed char);\n    _read_raw_data(short);\n    _read_raw_data(int);\n    _read_raw_data(long);\n    _read_raw_data(PY_LONG_LONG);\n    Py_FatalError(\"read_raw_signed_data: bad integer size\");\n    return 0;\n}\n\nstatic unsigned PY_LONG_LONG\nread_raw_unsigned_data(char *target, int size)\n{\n    _read_raw_data(unsigned char);\n    _read_raw_data(unsigned short);\n    _read_raw_data(unsigned int);\n    _read_raw_data(unsigned long);\n    _read_raw_data(unsigned PY_LONG_LONG);\n    Py_FatalError(\"read_raw_unsigned_data: bad integer size\");\n    return 0;\n}\n\n#ifdef __GNUC__\n/* This is a workaround for what I think is a GCC bug on several\n   platforms.  See issue #378. */\n__attribute__((noinline))\n#endif\nvoid _cffi_memcpy(char *target, const void *src, size_t size)\n{\n    memcpy(target, src, size);\n}\n\n#define _write_raw_data(type)                           \\\n    do {                                                \\\n        if (size == sizeof(type)) {                     \\\n            type r = (type)source;                      \\\n            _cffi_memcpy(target, &r, sizeof(type));           \\\n            return;                                     \\\n        }                                               \\\n    } while(0)\n\nstatic void\nwrite_raw_integer_data(char *target, unsigned PY_LONG_LONG source, int size)\n{\n    _write_raw_data(unsigned char);\n    _write_raw_data(unsigned short);\n    _write_raw_data(unsigned int);\n    _write_raw_data(unsigned long);\n    _write_raw_data(unsigned PY_LONG_LONG);\n    Py_FatalError(\"write_raw_integer_data: bad integer size\");\n}\n\nstatic double\nread_raw_float_data(char *target, int size)\n{\n    _read_raw_data(float);\n    _read_raw_data(double);\n    Py_FatalError(\"read_raw_float_data: bad float size\");\n    return 0;\n}\n\nstatic long double\nread_raw_longdouble_data(char *target)\n{\n    int size = sizeof(long double);\n    _read_raw_data(long double);\n    Py_FatalError(\"read_raw_longdouble_data: bad long double size\");\n    return 0;\n}\n\nstatic Py_complex\nread_raw_complex_data(char *target, int size)\n{\n    Py_complex r = {0.0, 0.0};\n    if (size == 2*sizeof(float)) {\n        float real_part, imag_part;\n        memcpy(&real_part, target + 0,             sizeof(float));\n        memcpy(&imag_part, target + sizeof(float), sizeof(float));\n        r.real = real_part;\n        r.imag = imag_part;\n        return r;\n    }\n    if (size == 2*sizeof(double)) {\n        memcpy(&r, target, 2*sizeof(double));\n        return r;\n    }\n    Py_FatalError(\"read_raw_complex_data: bad complex size\");\n    return r;\n}\n\nstatic void\nwrite_raw_float_data(char *target, double source, int size)\n{\n    _write_raw_data(float);\n    _write_raw_data(double);\n    Py_FatalError(\"write_raw_float_data: bad float size\");\n}\n\nstatic void\nwrite_raw_longdouble_data(char *target, long double source)\n{\n    int size = sizeof(long double);\n    _write_raw_data(long double);\n}\n\n#define _write_raw_complex_data(type)                      \\\n    do {                                                   \\\n        if (size == 2*sizeof(type)) {                      \\\n            type r = (type)source.real;                    \\\n            type i = (type)source.imag;                    \\\n            _cffi_memcpy(target, &r, sizeof(type));              \\\n            _cffi_memcpy(target+sizeof(type), &i, sizeof(type)); \\\n            return;                                        \\\n        }                                                  \\\n    } while(0)\n\nstatic void\nwrite_raw_complex_data(char *target, Py_complex source, int size)\n{\n    _write_raw_complex_data(float);\n    _write_raw_complex_data(double);\n    Py_FatalError(\"write_raw_complex_data: bad complex size\");\n}\n\nstatic PyObject *\nnew_simple_cdata(char *data, CTypeDescrObject *ct)\n{\n    CDataObject *cd = PyObject_New(CDataObject, &CData_Type);\n    if (cd == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    cd->c_data = data;\n    cd->c_type = ct;\n    cd->c_weakreflist = NULL;\n    return (PyObject *)cd;\n}\n\nstatic PyObject *\nnew_sized_cdata(char *data, CTypeDescrObject *ct, Py_ssize_t length)\n{\n    CDataObject_own_length *scd;\n\n    scd = (CDataObject_own_length *)PyObject_Malloc(\n        offsetof(CDataObject_own_length, alignment));\n    if (PyObject_Init((PyObject *)scd, &CData_Type) == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    scd->head.c_type = ct;\n    scd->head.c_data = data;\n    scd->head.c_weakreflist = NULL;\n    scd->length = length;\n    return (PyObject *)scd;\n}\n\nstatic CDataObject *_new_casted_primitive(CTypeDescrObject *ct);  /*forward*/\n\nstatic PyObject *\nconvert_to_object(char *data, CTypeDescrObject *ct)\n{\n    if (!(ct->ct_flags & CT_PRIMITIVE_ANY)) {\n        /* non-primitive types (check done just for performance) */\n        if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n            char *ptrdata = *(char **)data;\n            /*READ(data, sizeof(char *))*/\n            return new_simple_cdata(ptrdata, ct);\n        }\n        else if (ct->ct_flags & CT_IS_OPAQUE) {\n            PyErr_Format(PyExc_TypeError, \"cdata '%s' is opaque\",\n                         ct->ct_name);\n            return NULL;\n        }\n        else if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n            return new_simple_cdata(data, ct);\n        }\n        else if (ct->ct_flags & CT_ARRAY) {\n            if (ct->ct_length < 0) {\n                /* we can't return a <cdata 'int[]'> here, because we don't\n                   know the length to give it.  As a compromize, returns\n                   <cdata 'int *'> in this case. */\n                ct = (CTypeDescrObject *)ct->ct_stuff;\n            }\n            return new_simple_cdata(data, ct);\n        }\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        PY_LONG_LONG value;\n        /*READ(data, ct->ct_size)*/\n        value = read_raw_signed_data(data, ct->ct_size);\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)value);\n        else\n            return PyLong_FromLongLong(value);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        unsigned PY_LONG_LONG value;\n        /*READ(data, ct->ct_size)*/\n        value = read_raw_unsigned_data(data, ct->ct_size);\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG) {\n            if (ct->ct_flags & CT_IS_BOOL) {\n                PyObject *x;\n                switch ((int)value) {\n                case 0: x = Py_False; break;\n                case 1: x = Py_True; break;\n                default:\n                    PyErr_Format(PyExc_ValueError,\n                                 \"got a _Bool of value %d, expected 0 or 1\",\n                                 (int)value);\n                    return NULL;\n                }\n                Py_INCREF(x);\n                return x;\n            }\n            return PyInt_FromLong((long)value);\n        }\n        else\n            return PyLong_FromUnsignedLongLong(value);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        /*READ(data, ct->ct_size)*/\n        if (!(ct->ct_flags & CT_IS_LONGDOUBLE)) {\n            double value = read_raw_float_data(data, ct->ct_size);\n            return PyFloat_FromDouble(value);\n        }\n        else {\n            long double value = read_raw_longdouble_data(data);\n            CDataObject *cd = _new_casted_primitive(ct);\n            if (cd != NULL)\n                write_raw_longdouble_data(cd->c_data, value);\n            return (PyObject *)cd;\n        }\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_CHAR) {\n        /*READ(data, ct->ct_size)*/\n        switch (ct->ct_size) {\n        case sizeof(char):\n            return PyBytes_FromStringAndSize(data, 1);\n        case 2:\n            return _my_PyUnicode_FromChar16((cffi_char16_t *)data, 1);\n        case 4:\n            return _my_PyUnicode_FromChar32((cffi_char32_t *)data, 1);\n        }\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_COMPLEX) {\n        Py_complex value = read_raw_complex_data(data, ct->ct_size);\n        return PyComplex_FromCComplex(value);\n    }\n\n    PyErr_Format(PyExc_SystemError,\n                 \"convert_to_object: '%s'\", ct->ct_name);\n    return NULL;\n}\n\nstatic PyObject *\nconvert_to_object_bitfield(char *data, CFieldObject *cf)\n{\n    CTypeDescrObject *ct = cf->cf_type;\n    /*READ(data, ct->ct_size)*/\n\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        unsigned PY_LONG_LONG value, valuemask, shiftforsign;\n        PY_LONG_LONG result;\n\n        value = (unsigned PY_LONG_LONG)read_raw_signed_data(data, ct->ct_size);\n        valuemask = (1ULL << cf->cf_bitsize) - 1ULL;\n        shiftforsign = 1ULL << (cf->cf_bitsize - 1);\n        value = ((value >> cf->cf_bitshift) + shiftforsign) & valuemask;\n        result = ((PY_LONG_LONG)value) - (PY_LONG_LONG)shiftforsign;\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)result);\n        else\n            return PyLong_FromLongLong(result);\n    }\n    else {\n        unsigned PY_LONG_LONG value, valuemask;\n\n        value = read_raw_unsigned_data(data, ct->ct_size);\n        valuemask = (1ULL << cf->cf_bitsize) - 1ULL;\n        value = (value >> cf->cf_bitshift) & valuemask;\n\n        if (ct->ct_flags & CT_PRIMITIVE_FITS_LONG)\n            return PyInt_FromLong((long)value);\n        else\n            return PyLong_FromUnsignedLongLong(value);\n    }\n}\n\nstatic int _convert_overflow(PyObject *init, const char *ct_name)\n{\n    PyObject *s;\n    if (PyErr_Occurred())   /* already an exception pending */\n        return -1;\n    s = PyObject_Str(init);\n    if (s == NULL)\n        return -1;\n    PyErr_Format(PyExc_OverflowError, \"integer %s does not fit '%s'\",\n                 PyText_AS_UTF8(s), ct_name);\n    Py_DECREF(s);\n    return -1;\n}\n\nstatic int _convert_to_char(PyObject *init)\n{\n    if (PyBytes_Check(init) && PyBytes_GET_SIZE(init) == 1) {\n        return (unsigned char)(PyBytes_AS_STRING(init)[0]);\n    }\n    if (CData_Check(init) &&\n           (((CDataObject *)init)->c_type->ct_flags & CT_PRIMITIVE_CHAR) &&\n           (((CDataObject *)init)->c_type->ct_size == sizeof(char))) {\n        char *data = ((CDataObject *)init)->c_data;\n        /*READ(data, 1)*/\n        return *(unsigned char *)data;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"initializer for ctype 'char' must be a \"STR_OR_BYTES\n                 \" of length 1, not %.200s\", Py_TYPE(init)->tp_name);\n    return -1;\n}\n\nstatic cffi_char16_t _convert_to_char16_t(PyObject *init)\n{\n    char err_got[80];\n    err_got[0] = 0;\n\n    if (PyUnicode_Check(init)) {\n        cffi_char16_t ordinal;\n        if (_my_PyUnicode_AsSingleChar16(init, &ordinal, err_got) == 0)\n            return ordinal;\n    }\n    if (CData_Check(init) &&\n           (((CDataObject *)init)->c_type->ct_flags & CT_PRIMITIVE_CHAR) &&\n           (((CDataObject *)init)->c_type->ct_size == 2)) {\n        char *data = ((CDataObject *)init)->c_data;\n        /*READ(data, 2)*/\n        return *(cffi_char16_t *)data;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"initializer for ctype 'char16_t' must be a unicode string \"\n                 \"of length 1, not %.200s\",\n                 err_got[0] == 0 ? Py_TYPE(init)->tp_name : err_got);\n    return (cffi_char16_t)-1;\n}\n\nstatic cffi_char32_t _convert_to_char32_t(PyObject *init)\n{\n    char err_got[80];\n    err_got[0] = 0;\n\n    if (PyUnicode_Check(init)) {\n        cffi_char32_t ordinal;\n        if (_my_PyUnicode_AsSingleChar32(init, &ordinal, err_got) == 0)\n            return ordinal;\n    }\n    if (CData_Check(init) &&\n           (((CDataObject *)init)->c_type->ct_flags & CT_PRIMITIVE_CHAR) &&\n           (((CDataObject *)init)->c_type->ct_size == 4)) {\n        char *data = ((CDataObject *)init)->c_data;\n        /*READ(data, 4)*/\n        return *(cffi_char32_t *)data;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"initializer for ctype 'char32_t' must be a unicode string \"\n                 \"of length 1, not %.200s\",\n                 err_got[0] == 0 ? Py_TYPE(init)->tp_name : err_got);\n    return (cffi_char32_t)-1;\n}\n\nstatic int _convert_error(PyObject *init, CTypeDescrObject *ct,\n                          const char *expected)\n{\n    if (CData_Check(init)) {\n        CTypeDescrObject *ct2 = ((CDataObject *)init)->c_type;\n        if (strcmp(ct->ct_name, ct2->ct_name) != 0)\n            PyErr_Format(PyExc_TypeError,\n                         \"initializer for ctype '%s' must be a %s, \"\n                         \"not cdata '%s'\",\n                         ct->ct_name, expected, ct2->ct_name);\n        else if (ct != ct2) {\n            /* in case we'd give the error message \"initializer for\n               ctype 'A' must be a pointer to same type, not cdata\n               'B'\", but with A=B, then give instead a different error\n               message to try to clear up the confusion */\n            PyErr_Format(PyExc_TypeError,\n                         \"initializer for ctype '%s' appears indeed to be '%s',\"\n                         \" but the types are different (check that you are not\"\n                         \" e.g. mixing up different ffi instances)\",\n                         ct->ct_name, ct2->ct_name);\n        }\n        else\n        {\n            PyErr_Format(PyExc_SystemError,\n                         \"initializer for ctype '%s' is correct, but we get \"\n                         \"an internal mismatch--please report a bug\",\n                         ct->ct_name);\n        }\n    }\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"initializer for ctype '%s' must be a %s, \"\n                     \"not %.200s\",\n                     ct->ct_name, expected, Py_TYPE(init)->tp_name);\n    return -1;\n}\n\nstatic int    /* forward */\nconvert_from_object(char *data, CTypeDescrObject *ct, PyObject *init);\nstatic int    /* forward */\nconvert_from_object_bitfield(char *data, CFieldObject *cf, PyObject *init);\n\nstatic Py_ssize_t\nget_new_array_length(CTypeDescrObject *ctitem, PyObject **pvalue)\n{\n    PyObject *value = *pvalue;\n\n    if (PyList_Check(value) || PyTuple_Check(value)) {\n        return PySequence_Fast_GET_SIZE(value);\n    }\n    else if (PyBytes_Check(value)) {\n        /* from a string, we add the null terminator */\n        return PyBytes_GET_SIZE(value) + 1;\n    }\n    else if (PyUnicode_Check(value)) {\n        /* from a unicode, we add the null terminator */\n        int length;\n        if (ctitem->ct_size == 2)\n            length = _my_PyUnicode_SizeAsChar16(value);\n        else\n            length = _my_PyUnicode_SizeAsChar32(value);\n        return length + 1;\n    }\n    else {\n        Py_ssize_t explicitlength;\n        explicitlength = PyNumber_AsSsize_t(value, PyExc_OverflowError);\n        if (explicitlength < 0) {\n            if (PyErr_Occurred()) {\n                if (PyErr_ExceptionMatches(PyExc_TypeError))\n                    PyErr_Format(PyExc_TypeError,\n                        \"expected new array length or list/tuple/str, \"\n                        \"not %.200s\", Py_TYPE(value)->tp_name);\n            }\n            else\n                PyErr_SetString(PyExc_ValueError, \"negative array length\");\n            return -1;\n        }\n        *pvalue = Py_None;\n        return explicitlength;\n    }\n}\n\nstatic int\nconvert_field_from_object(char *data, CFieldObject *cf, PyObject *value)\n{\n    data += cf->cf_offset;\n    if (cf->cf_bitshift >= 0)\n        return convert_from_object_bitfield(data, cf, value);\n    else\n        return convert_from_object(data, cf->cf_type, value);\n}\n\nstatic int\nadd_varsize_length(Py_ssize_t offset, Py_ssize_t itemsize,\n                   Py_ssize_t varsizelength, Py_ssize_t *optvarsize)\n{\n    /* update '*optvarsize' to account for an array of 'varsizelength'\n       elements, each of size 'itemsize', that starts at 'offset'. */\n    Py_ssize_t size = ADD_WRAPAROUND(offset,\n                              MUL_WRAPAROUND(itemsize, varsizelength));\n    if (size < 0 ||\n        ((size - offset) / itemsize) != varsizelength) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"array size would overflow a Py_ssize_t\");\n        return -1;\n    }\n    if (size > *optvarsize)\n        *optvarsize = size;\n    return 0;\n}\n\nstatic int\nconvert_struct_from_object(char *data, CTypeDescrObject *ct, PyObject *init,\n                           Py_ssize_t *optvarsize);  /* forward */\n\nstatic int\nconvert_vfield_from_object(char *data, CFieldObject *cf, PyObject *value,\n                           Py_ssize_t *optvarsize)\n{\n    /* a special case for var-sized C99 arrays */\n    if ((cf->cf_type->ct_flags & CT_ARRAY) && cf->cf_type->ct_size < 0) {\n        Py_ssize_t varsizelength = get_new_array_length(\n                                      cf->cf_type->ct_itemdescr, &value);\n        if (varsizelength < 0)\n            return -1;\n        if (optvarsize != NULL) {\n            /* in this mode, the only purpose of this function is to compute\n               the real size of the structure from a var-sized C99 array */\n            assert(data == NULL);\n            return add_varsize_length(cf->cf_offset,\n                cf->cf_type->ct_itemdescr->ct_size,\n                varsizelength,\n                optvarsize);\n        }\n        /* if 'value' was only an integer, get_new_array_length() returns\n           it and convert 'value' to be None.  Detect if this was the case,\n           and if so, stop here, leaving the content uninitialized\n           (it should be zero-initialized from somewhere else). */\n        if (value == Py_None)\n            return 0;\n    }\n    if (optvarsize == NULL) {\n        return convert_field_from_object(data, cf, value);\n    }\n    else if ((cf->cf_type->ct_flags & CT_WITH_VAR_ARRAY) != 0 &&\n             !CData_Check(value)) {\n        Py_ssize_t subsize = cf->cf_type->ct_size;\n        if (convert_struct_from_object(NULL, cf->cf_type, value, &subsize) < 0)\n            return -1;\n        return add_varsize_length(cf->cf_offset, 1, subsize, optvarsize);\n    }\n    else\n        return 0;\n}\n\nstatic int\nmust_be_array_of_zero_or_one(const char *data, Py_ssize_t n)\n{\n    Py_ssize_t i;\n    for (i = 0; i < n; i++) {\n        if (((unsigned char)data[i]) > 1) {\n            PyErr_SetString(PyExc_ValueError,\n                \"an array of _Bool can only contain \\\\x00 or \\\\x01\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic Py_ssize_t\nget_array_length(CDataObject *cd)\n{\n    if (cd->c_type->ct_length < 0)\n        return ((CDataObject_own_length *)cd)->length;\n    else\n        return cd->c_type->ct_length;\n}\n\nstatic int\nconvert_array_from_object(char *data, CTypeDescrObject *ct, PyObject *init)\n{\n    /* used by convert_from_object(), and also to decode lists/tuples/unicodes\n       passed as function arguments.  'ct' is an CT_ARRAY in the first case\n       and a CT_POINTER in the second case. */\n    const char *expected;\n    CTypeDescrObject *ctitem = ct->ct_itemdescr;\n\n    if (PyList_Check(init) || PyTuple_Check(init)) {\n        PyObject **items;\n        Py_ssize_t i, n;\n        n = PySequence_Fast_GET_SIZE(init);\n        if (ct->ct_length >= 0 && n > ct->ct_length) {\n            PyErr_Format(PyExc_IndexError,\n                         \"too many initializers for '%s' (got %zd)\",\n                         ct->ct_name, n);\n            return -1;\n        }\n        items = PySequence_Fast_ITEMS(init);\n        for (i=0; i<n; i++) {\n            if (convert_from_object(data, ctitem, items[i]) < 0)\n                return -1;\n            data += ctitem->ct_size;\n        }\n        return 0;\n    }\n    else if ((ctitem->ct_flags & CT_PRIMITIVE_CHAR) ||\n             ((ctitem->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))\n              && (ctitem->ct_size == sizeof(char)))) {\n        if (ctitem->ct_size == sizeof(char)) {\n            char *srcdata;\n            Py_ssize_t n;\n            if (!PyBytes_Check(init)) {\n                expected = STR_OR_BYTES\" or list or tuple\";\n                goto cannot_convert;\n            }\n            n = PyBytes_GET_SIZE(init);\n            if (ct->ct_length >= 0 && n > ct->ct_length) {\n                PyErr_Format(PyExc_IndexError,\n                             \"initializer \"STR_OR_BYTES\" is too long for '%s' \"\n                             \"(got %zd characters)\", ct->ct_name, n);\n                return -1;\n            }\n            if (n != ct->ct_length)\n                n++;\n            srcdata = PyBytes_AS_STRING(init);\n            if (ctitem->ct_flags & CT_IS_BOOL)\n                if (must_be_array_of_zero_or_one(srcdata, n) < 0)\n                    return -1;\n            memcpy(data, srcdata, n);\n            return 0;\n        }\n        else {\n            Py_ssize_t n;\n            if (!PyUnicode_Check(init)) {\n                expected = \"unicode or list or tuple\";\n                goto cannot_convert;\n            }\n\n            if (ctitem->ct_size == 4)\n                n = _my_PyUnicode_SizeAsChar32(init);\n            else\n                n = _my_PyUnicode_SizeAsChar16(init);\n\n            if (ct->ct_length >= 0 && n > ct->ct_length) {\n                PyErr_Format(PyExc_IndexError,\n                             \"initializer unicode is too long for '%s' \"\n                             \"(got %zd characters)\", ct->ct_name, n);\n                return -1;\n            }\n            if (n != ct->ct_length)\n                n++;\n            if (ctitem->ct_size == 4)\n                return _my_PyUnicode_AsChar32(init, (cffi_char32_t *)data, n);\n            else\n                return _my_PyUnicode_AsChar16(init, (cffi_char16_t *)data, n);\n        }\n    }\n    else {\n        expected = \"list or tuple\";\n        goto cannot_convert;\n    }\n\n cannot_convert:\n    if ((ct->ct_flags & CT_ARRAY) && CData_Check(init))\n    {\n        CDataObject *cd = (CDataObject *)init;\n        if (cd->c_type == ct)\n        {\n            Py_ssize_t n = get_array_length(cd);\n            memcpy(data, cd->c_data, n * ctitem->ct_size);\n            return 0;\n        }\n    }\n    return _convert_error(init, ct, expected);\n}\n\nstatic int\nconvert_struct_from_object(char *data, CTypeDescrObject *ct, PyObject *init,\n                           Py_ssize_t *optvarsize)\n{\n    /* does not accept 'init' being already a CData */\n    const char *expected;\n\n    if (force_lazy_struct(ct) <= 0) {\n        if (!PyErr_Occurred())\n            PyErr_Format(PyExc_TypeError, \"'%s' is opaque\", ct->ct_name);\n        return -1;\n    }\n\n    if (PyList_Check(init) || PyTuple_Check(init)) {\n        PyObject **items = PySequence_Fast_ITEMS(init);\n        Py_ssize_t i, n = PySequence_Fast_GET_SIZE(init);\n        CFieldObject *cf = (CFieldObject *)ct->ct_extra;\n\n        for (i=0; i<n; i++) {\n            while (cf != NULL && (cf->cf_flags & BF_IGNORE_IN_CTOR))\n                cf = cf->cf_next;\n            if (cf == NULL) {\n                PyErr_Format(PyExc_ValueError,\n                             \"too many initializers for '%s' (got %zd)\",\n                             ct->ct_name, n);\n                return -1;\n            }\n            if (convert_vfield_from_object(data, cf, items[i], optvarsize) < 0)\n                return -1;\n            cf = cf->cf_next;\n        }\n        return 0;\n    }\n    if (PyDict_Check(init)) {\n        PyObject *d_key, *d_value;\n        Py_ssize_t i = 0;\n        CFieldObject *cf;\n\n        while (PyDict_Next(init, &i, &d_key, &d_value)) {\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, d_key);\n            if (cf == NULL) {\n                PyErr_SetObject(PyExc_KeyError, d_key);\n                return -1;\n            }\n            if (convert_vfield_from_object(data, cf, d_value, optvarsize) < 0)\n                return -1;\n        }\n        return 0;\n    }\n    expected = optvarsize == NULL ? \"list or tuple or dict or struct-cdata\"\n                                  : \"list or tuple or dict\";\n    return _convert_error(init, ct, expected);\n}\n\n#ifdef __GNUC__\n# if __GNUC__ >= 4\n/* Don't go inlining this huge function.  Needed because occasionally\n   it gets inlined in places where is causes a warning: call to\n   __builtin___memcpy_chk will always overflow destination buffer\n   (which is places where the 'ct' should never represent such a large\n   primitive type anyway). */\n__attribute__((noinline))\n# endif\n#endif\nstatic int\nconvert_from_object(char *data, CTypeDescrObject *ct, PyObject *init)\n{\n    const char *expected;\n    char buf[sizeof(PY_LONG_LONG)];\n\n    /*if (ct->ct_size > 0)*/\n        /*WRITE(data, ct->ct_size)*/\n\n    if (ct->ct_flags & CT_ARRAY) {\n        return convert_array_from_object(data, ct, init);\n    }\n    if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        char *ptrdata;\n        CTypeDescrObject *ctinit;\n\n        if (!CData_Check(init)) {\n            expected = \"cdata pointer\";\n            goto cannot_convert;\n        }\n        ctinit = ((CDataObject *)init)->c_type;\n        if (!(ctinit->ct_flags & (CT_POINTER|CT_FUNCTIONPTR))) {\n            if (ctinit->ct_flags & CT_ARRAY)\n                ctinit = (CTypeDescrObject *)ctinit->ct_stuff;\n            else {\n                expected = \"pointer or array\";\n                goto cannot_convert;\n            }\n        }\n        if (ctinit != ct) {\n            int combined_flags = ct->ct_flags | ctinit->ct_flags;\n            if (combined_flags & CT_IS_VOID_PTR)\n                ;   /* accept \"void *\" as either source or target */\n            else if (combined_flags & CT_IS_VOIDCHAR_PTR) {\n                /* for backward compatibility, accept \"char *\" as either\n                   source of target.  This is not what C does, though,\n                   so emit a warning that will eventually turn into an\n                   error.  The warning is turned off if both types are\n                   pointers to single bytes. */\n                char *msg = (ct->ct_flags & CT_IS_VOIDCHAR_PTR ?\n                    \"implicit cast to 'char *' from a different pointer type: \"\n                    \"will be forbidden in the future (check that the types \"\n                    \"are as you expect; use an explicit ffi.cast() if they \"\n                    \"are correct)\" :\n                    \"implicit cast from 'char *' to a different pointer type: \"\n                    \"will be forbidden in the future (check that the types \"\n                    \"are as you expect; use an explicit ffi.cast() if they \"\n                    \"are correct)\");\n                if ((ct->ct_flags & ctinit->ct_flags & CT_POINTER) &&\n                    ct->ct_itemdescr->ct_size == 1 &&\n                    ctinit->ct_itemdescr->ct_size == 1) {\n                    /* no warning */\n                }\n                else if (PyErr_WarnEx(PyExc_UserWarning, msg, 1))\n                    return -1;\n            }\n            else {\n                expected = \"pointer to same type\";\n                goto cannot_convert;\n            }\n        }\n        ptrdata = ((CDataObject *)init)->c_data;\n\n        *(char **)data = ptrdata;\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        PY_LONG_LONG value = _my_PyLong_AsLongLong(init);\n        if (value == -1 && PyErr_Occurred())\n            return -1;\n        write_raw_integer_data(buf, value, ct->ct_size);\n        if (value != read_raw_signed_data(buf, ct->ct_size))\n            goto overflow;\n        write_raw_integer_data(data, value, ct->ct_size);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        unsigned PY_LONG_LONG value = _my_PyLong_AsUnsignedLongLong(init, 1);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return -1;\n        if (ct->ct_flags & CT_IS_BOOL) {\n            if (value > 1ULL)      /* value != 0 && value != 1 */\n                goto overflow;\n        }\n        else {\n            write_raw_integer_data(buf, value, ct->ct_size);\n            if (value != read_raw_unsigned_data(buf, ct->ct_size))\n                goto overflow;\n        }\n        write_raw_integer_data(data, value, ct->ct_size);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        double value;\n        if ((ct->ct_flags & CT_IS_LONGDOUBLE) &&\n                CData_Check(init) &&\n                (((CDataObject *)init)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n            long double lvalue;\n            char *initdata = ((CDataObject *)init)->c_data;\n            /*READ(initdata, sizeof(long double))*/\n            lvalue = read_raw_longdouble_data(initdata);\n            write_raw_longdouble_data(data, lvalue);\n            return 0;\n        }\n        value = PyFloat_AsDouble(init);\n        if (value == -1.0 && PyErr_Occurred())\n            return -1;\n        if (!(ct->ct_flags & CT_IS_LONGDOUBLE))\n            write_raw_float_data(data, value, ct->ct_size);\n        else\n            write_raw_longdouble_data(data, (long double)value);\n        return 0;\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_CHAR) {\n        switch (ct->ct_size) {\n        case sizeof(char): {\n            int res = _convert_to_char(init);\n            if (res < 0)\n                return -1;\n            data[0] = res;\n            return 0;\n        }\n        case 2: {\n            cffi_char16_t res = _convert_to_char16_t(init);\n            if (res == (cffi_char16_t)-1 && PyErr_Occurred())\n                return -1;\n            *(cffi_char16_t *)data = res;\n            return 0;\n        }\n        case 4: {\n            cffi_char32_t res = _convert_to_char32_t(init);\n            if (res == (cffi_char32_t)-1 && PyErr_Occurred())\n                return -1;\n            *(cffi_char32_t *)data = res;\n            return 0;\n        }\n        }\n    }\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n\n        if (CData_Check(init)) {\n            if (((CDataObject *)init)->c_type == ct && ct->ct_size >= 0) {\n                memcpy(data, ((CDataObject *)init)->c_data, ct->ct_size);\n                return 0;\n            }\n        }\n        return convert_struct_from_object(data, ct, init, NULL);\n    }\n    if (ct->ct_flags & CT_PRIMITIVE_COMPLEX) {\n        Py_complex value = PyComplex_AsCComplex(init);\n        if (PyErr_Occurred())\n            return -1;\n        write_raw_complex_data(data, value, ct->ct_size);\n        return 0;\n    }\n    PyErr_Format(PyExc_SystemError,\n                 \"convert_from_object: '%s'\", ct->ct_name);\n    return -1;\n\n overflow:\n    return _convert_overflow(init, ct->ct_name);\n\n cannot_convert:\n    return _convert_error(init, ct, expected);\n}\n\nstatic int\nconvert_from_object_bitfield(char *data, CFieldObject *cf, PyObject *init)\n{\n    CTypeDescrObject *ct = cf->cf_type;\n    PY_LONG_LONG fmin, fmax, value = PyLong_AsLongLong(init);\n    unsigned PY_LONG_LONG rawfielddata, rawvalue, rawmask;\n    if (value == -1 && PyErr_Occurred())\n        return -1;\n\n    if (ct->ct_flags & CT_PRIMITIVE_SIGNED) {\n        fmin = -(1LL << (cf->cf_bitsize-1));\n        fmax = (1LL << (cf->cf_bitsize-1)) - 1LL;\n        if (fmax == 0)\n            fmax = 1;    /* special case to let \"int x:1\" receive \"1\" */\n    }\n    else {\n        fmin = 0LL;\n        fmax = (PY_LONG_LONG)((1ULL << cf->cf_bitsize) - 1ULL);\n    }\n    if (value < fmin || value > fmax) {\n        /* phew, PyErr_Format does not support \"%lld\" in Python 2.6 */\n        PyObject *svalue = NULL, *sfmin = NULL, *sfmax = NULL;\n        PyObject *lfmin = NULL, *lfmax = NULL;\n        svalue = PyObject_Str(init);\n        if (svalue == NULL) goto skip;\n        lfmin = PyLong_FromLongLong(fmin);\n        if (lfmin == NULL) goto skip;\n        sfmin = PyObject_Str(lfmin);\n        if (sfmin == NULL) goto skip;\n        lfmax = PyLong_FromLongLong(fmax);\n        if (lfmax == NULL) goto skip;\n        sfmax = PyObject_Str(lfmax);\n        if (sfmax == NULL) goto skip;\n        PyErr_Format(PyExc_OverflowError,\n                     \"value %s outside the range allowed by the \"\n                     \"bit field width: %s <= x <= %s\",\n                     PyText_AS_UTF8(svalue),\n                     PyText_AS_UTF8(sfmin),\n                     PyText_AS_UTF8(sfmax));\n       skip:\n        Py_XDECREF(svalue);\n        Py_XDECREF(sfmin);\n        Py_XDECREF(sfmax);\n        Py_XDECREF(lfmin);\n        Py_XDECREF(lfmax);\n        return -1;\n    }\n\n    rawmask = ((1ULL << cf->cf_bitsize) - 1ULL) << cf->cf_bitshift;\n    rawvalue = ((unsigned PY_LONG_LONG)value) << cf->cf_bitshift;\n    /*WRITE(data, ct->ct_size)*/\n    rawfielddata = read_raw_unsigned_data(data, ct->ct_size);\n    rawfielddata = (rawfielddata & ~rawmask) | (rawvalue & rawmask);\n    write_raw_integer_data(data, rawfielddata, ct->ct_size);\n    return 0;\n}\n\nstatic int\nget_alignment(CTypeDescrObject *ct)\n{\n    int align;\n retry:\n    if ((ct->ct_flags & (CT_PRIMITIVE_ANY|CT_STRUCT|CT_UNION)) &&\n        !(ct->ct_flags & CT_IS_OPAQUE)) {\n        align = ct->ct_length;\n        if (align == -1 && (ct->ct_flags & CT_LAZY_FIELD_LIST)) {\n            force_lazy_struct(ct);\n            align = ct->ct_length;\n        }\n    }\n    else if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        struct aligncheck_ptr { char x; char *y; };\n        align = offsetof(struct aligncheck_ptr, y);\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        ct = ct->ct_itemdescr;\n        goto retry;\n    }\n    else {\n        PyErr_Format(PyExc_ValueError, \"ctype '%s' is of unknown alignment\",\n                     ct->ct_name);\n        return -1;\n    }\n\n    if ((align < 1) || (align & (align-1))) {\n        PyErr_Format(PyExc_SystemError,\n                     \"found for ctype '%s' bogus alignment '%d'\",\n                     ct->ct_name, align);\n        return -1;\n    }\n    return align;\n}\n\nstatic void cdata_dealloc(CDataObject *cd)\n{\n    if (cd->c_weakreflist != NULL)\n        PyObject_ClearWeakRefs((PyObject *) cd);\n\n    Py_DECREF(cd->c_type);\n#ifndef CFFI_MEM_LEAK     /* never release anything, tests only */\n    Py_TYPE(cd)->tp_free((PyObject *)cd);\n#endif\n}\n\nstatic void cdataowning_dealloc(CDataObject *cd)\n{\n    assert(!(cd->c_type->ct_flags & (CT_IS_VOID_PTR | CT_FUNCTIONPTR)));\n\n    if (cd->c_type->ct_flags & CT_IS_PTR_TO_OWNED) {\n        /* for ffi.new(\"struct *\") */\n        Py_DECREF(((CDataObject_own_structptr *)cd)->structobj);\n    }\n#if defined(CFFI_MEM_DEBUG) || defined(CFFI_MEM_LEAK)\n    if (cd->c_type->ct_flags & (CT_PRIMITIVE_ANY | CT_STRUCT | CT_UNION)) {\n        assert(cd->c_type->ct_size >= 0);\n        memset(cd->c_data, 0xDD, cd->c_type->ct_size);\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        Py_ssize_t x = get_array_length(cd);\n        assert(x >= 0);\n        x *= cd->c_type->ct_itemdescr->ct_size;\n        assert(x >= 0);\n        memset(cd->c_data, 0xDD, x);\n    }\n#endif\n    cdata_dealloc(cd);\n}\n\nstatic void cdataowninggc_dealloc(CDataObject *cd)\n{\n    PyObject_GC_UnTrack(cd);\n\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = ((CDataObject_own_structptr *)cd)->structobj;\n        Py_DECREF(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = ((CDataObject_closure *)cd)->closure;\n        PyObject *args = (PyObject *)(closure->user_data);\n        Py_XDECREF(args);\n#ifdef CFFI_TRUST_LIBFFI\n        ffi_closure_free(closure);\n#else\n        cffi_closure_free(closure);\n#endif\n    }\n    else {\n        Py_FatalError(\"cdata CDataOwningGC_Type with unexpected type flags\");\n    }\n    cdata_dealloc(cd);\n}\n\nstatic void cdatafrombuf_dealloc(CDataObject *cd)\n{\n    Py_buffer *view = ((CDataObject_frombuf *)cd)->bufferview;\n    cdata_dealloc(cd);\n\n    PyBuffer_Release(view);\n    PyObject_Free(view);\n}\n\nstatic int cdataowninggc_traverse(CDataObject *cd, visitproc visit, void *arg)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = ((CDataObject_own_structptr *)cd)->structobj;\n        Py_VISIT(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = ((CDataObject_closure *)cd)->closure;\n        PyObject *args = (PyObject *)(closure->user_data);\n        Py_VISIT(args);\n    }\n    return 0;\n}\n\nstatic int cdatafrombuf_traverse(CDataObject *cd, visitproc visit, void *arg)\n{\n    Py_buffer *view = ((CDataObject_frombuf *)cd)->bufferview;\n    Py_VISIT(view->obj);\n    return 0;\n}\n\nstatic int cdataowninggc_clear(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        CDataObject_own_structptr *cd1 = (CDataObject_own_structptr *)cd;\n        PyObject *x = cd1->structobj;\n        Py_INCREF(Py_None);\n        cd1->structobj = Py_None;\n        Py_DECREF(x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = ((CDataObject_closure *)cd)->closure;\n        PyObject *args = (PyObject *)(closure->user_data);\n        closure->user_data = NULL;\n        Py_XDECREF(args);\n    }\n    return 0;\n}\n\nstatic int cdatafrombuf_clear(CDataObject *cd)\n{\n    Py_buffer *view = ((CDataObject_frombuf *)cd)->bufferview;\n    PyBuffer_Release(view);\n    return 0;\n}\n\n/* forward */\nstatic void _my_PyErr_WriteUnraisable(PyObject *t, PyObject *v, PyObject *tb,\n                                      char *objdescr, PyObject *obj,\n                                      char *extra_error_line);\n\n\nstatic void gcp_finalize(PyObject *destructor, PyObject *origobj)\n{\n    /* NOTE: this decrements the reference count of the two arguments */\n\n    if (destructor != NULL) {\n        PyObject *result;\n        PyObject *error_type, *error_value, *error_traceback;\n\n        /* Save the current exception */\n        PyErr_Fetch(&error_type, &error_value, &error_traceback);\n\n        result = PyObject_CallFunctionObjArgs(destructor, origobj, NULL);\n        if (result != NULL) {\n            Py_DECREF(result);\n        }\n        else {\n            PyObject *t, *v, *tb;\n            PyErr_Fetch(&t, &v, &tb);\n            /* Don't use error capture here, because it is very much\n             * like errors at __del__(), and these ones are not captured\n             * either */\n            /* ecap = _cffi_start_error_capture(); */\n            _my_PyErr_WriteUnraisable(t, v, tb, \"From callback for ffi.gc \",\n                                      origobj, NULL);\n            /* _cffi_stop_error_capture(ecap); */\n        }\n        Py_DECREF(destructor);\n\n        /* Restore the saved exception */\n        PyErr_Restore(error_type, error_value, error_traceback);\n    }\n    Py_XDECREF(origobj);\n}\n\nstatic void cdatagcp_finalize(CDataObject_gcp *cd)\n{\n    PyObject *destructor = cd->destructor;\n    PyObject *origobj = cd->origobj;\n    cd->destructor = NULL;\n    cd->origobj = NULL;\n    gcp_finalize(destructor, origobj);\n}\n\nstatic void cdatagcp_dealloc(CDataObject_gcp *cd)\n{\n    PyObject *destructor = cd->destructor;\n    PyObject *origobj = cd->origobj;\n    cdata_dealloc((CDataObject *)cd);\n\n    gcp_finalize(destructor, origobj);\n}\n\nstatic int cdatagcp_traverse(CDataObject_gcp *cd, visitproc visit, void *arg)\n{\n    Py_VISIT(cd->destructor);\n    Py_VISIT(cd->origobj);\n    return 0;\n}\n\nstatic PyObject *cdata_float(CDataObject *cd);  /*forward*/\n\nstatic PyObject *convert_cdata_to_enum_string(CDataObject *cd, int both)\n{\n    PyObject *d_key, *d_value;\n    CTypeDescrObject *ct = cd->c_type;\n\n    assert(ct->ct_flags & CT_IS_ENUM);\n    d_key = convert_to_object(cd->c_data, ct);\n    if (d_key == NULL)\n        return NULL;\n\n    d_value = PyDict_GetItem(PyTuple_GET_ITEM(ct->ct_stuff, 1), d_key);\n    if (d_value != NULL) {\n        if (both) {\n            PyObject *o = PyObject_Str(d_key);\n            if (o == NULL)\n                d_value = NULL;\n            else {\n                d_value = PyText_FromFormat(\"%s: %s\",\n                                            PyText_AS_UTF8(o),\n                                            PyText_AS_UTF8(d_value));\n                Py_DECREF(o);\n            }\n        }\n        else\n            Py_INCREF(d_value);\n    }\n    else\n        d_value = PyObject_Str(d_key);\n    Py_DECREF(d_key);\n    return d_value;\n}\n\nstatic PyObject *cdata_repr(CDataObject *cd)\n{\n    char *extra;\n    PyObject *result, *s;\n\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_ANY) {\n        if (cd->c_type->ct_flags & CT_IS_ENUM) {\n            s = convert_cdata_to_enum_string(cd, 1);\n        }\n        else if (cd->c_type->ct_flags & CT_IS_LONGDOUBLE) {\n            long double lvalue;\n            char buffer[128];   /* big enough */\n            /*READ(cd->c_data, sizeof(long double)*/\n            lvalue = read_raw_longdouble_data(cd->c_data);\n            sprintf(buffer, \"%LE\", lvalue);\n            s = PyText_FromString(buffer);\n        }\n        else {\n            PyObject *o = convert_to_object(cd->c_data, cd->c_type);\n            if (o == NULL)\n                return NULL;\n            s = PyObject_Repr(o);\n            Py_DECREF(o);\n        }\n    }\n    else if ((cd->c_type->ct_flags & CT_ARRAY) && cd->c_type->ct_length < 0) {\n        s = PyText_FromFormat(\"sliced length %zd\", get_array_length(cd));\n    }\n    else {\n        if (cd->c_data != NULL) {\n            s = PyText_FromFormat(\"%p\", cd->c_data);\n        }\n        else\n            s = PyText_FromString(\"NULL\");\n    }\n    if (s == NULL)\n        return NULL;\n    /* it's slightly confusing to get \"<cdata 'struct foo' 0x...>\" because the\n       struct foo is not owned.  Trying to make it clearer, write in this\n       case \"<cdata 'struct foo &' 0x...>\". */\n    if (cd->c_type->ct_flags & (CT_STRUCT|CT_UNION))\n        extra = \" &\";\n    else\n        extra = \"\";\n    result = PyText_FromFormat(\"<cdata '%s%s' %s>\",\n                               cd->c_type->ct_name, extra,\n                               PyText_AsUTF8(s));\n    Py_DECREF(s);\n    return result;\n}\n\nstatic PyObject *_cdata_repr2(CDataObject *cd, char *text, PyObject *x)\n{\n    PyObject *res, *s = PyObject_Repr(x);\n    if (s == NULL)\n        return NULL;\n    res = PyText_FromFormat(\"<cdata '%s' %s %s>\",\n                            cd->c_type->ct_name, text, PyText_AsUTF8(s));\n    Py_DECREF(s);\n    return res;\n}\n\nstatic Py_ssize_t _cdata_var_byte_size(CDataObject *cd)\n{\n    /* If 'cd' is a 'struct foo' or 'struct foo *' allocated with\n       ffi.new(), and if the struct foo contains a varsize array,\n       then return the real allocated size.  Otherwise, return -1. */\n    if (!CDataOwn_Check(cd))\n        return -1;\n\n    if (cd->c_type->ct_flags & CT_IS_PTR_TO_OWNED) {\n        cd = (CDataObject *)((CDataObject_own_structptr *)cd)->structobj;\n    }\n    if (cd->c_type->ct_flags & CT_WITH_VAR_ARRAY) {\n        return ((CDataObject_own_length *)cd)->length;\n    }\n    return -1;\n}\n\nstatic PyObject *_frombuf_repr(CDataObject *cd, const char *cd_type_name)\n{\n    Py_buffer *view = ((CDataObject_frombuf *)cd)->bufferview;\n    const char *obj_tp_name;\n    if (view->obj == NULL) {\n        return PyText_FromFormat(\n            \"<cdata '%s' buffer RELEASED>\",\n            cd_type_name);\n    }\n\n    obj_tp_name = Py_TYPE(view->obj)->tp_name;\n    if (cd->c_type->ct_flags & CT_ARRAY)\n    {\n        Py_ssize_t buflen = get_array_length(cd);\n        return PyText_FromFormat(\n            \"<cdata '%s' buffer len %zd from '%.200s' object>\",\n            cd_type_name,\n            buflen,\n            obj_tp_name);\n    }\n    else\n    {\n        return PyText_FromFormat(\n            \"<cdata '%s' buffer from '%.200s' object>\",\n            cd_type_name,\n            obj_tp_name);\n    }\n}\n\nstatic PyObject *cdataowning_repr(CDataObject *cd)\n{\n    Py_ssize_t size = _cdata_var_byte_size(cd);\n    if (size < 0) {\n        if (cd->c_type->ct_flags & CT_POINTER)\n            size = cd->c_type->ct_itemdescr->ct_size;\n        else if (cd->c_type->ct_flags & CT_ARRAY)\n            size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n        else\n            size = cd->c_type->ct_size;\n    }\n    return PyText_FromFormat(\"<cdata '%s' owning %zd bytes>\",\n                             cd->c_type->ct_name, size);\n}\n\nstatic PyObject *cdataowninggc_repr(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_IS_VOID_PTR) {        /* a handle */\n        PyObject *x = ((CDataObject_own_structptr *)cd)->structobj;\n        return _cdata_repr2(cd, \"handle to\", x);\n    }\n    else if (cd->c_type->ct_flags & CT_FUNCTIONPTR) {   /* a callback */\n        ffi_closure *closure = ((CDataObject_closure *)cd)->closure;\n        PyObject *args = (PyObject *)closure->user_data;\n        if (args == NULL)\n            return cdata_repr(cd);\n        else\n            return _cdata_repr2(cd, \"calling\", PyTuple_GET_ITEM(args, 1));\n    }\n    return cdataowning_repr(cd);   /* but should be unreachable */\n}\n\nstatic PyObject *cdatafrombuf_repr(CDataObject *cd)\n{\n    return _frombuf_repr(cd, cd->c_type->ct_name);\n}\n\nstatic int cdata_nonzero(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_ANY) {\n        if (cd->c_type->ct_flags & (CT_PRIMITIVE_SIGNED |\n                                    CT_PRIMITIVE_UNSIGNED |\n                                    CT_PRIMITIVE_CHAR))\n            return read_raw_unsigned_data(cd->c_data, cd->c_type->ct_size) != 0;\n\n        if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n            if (cd->c_type->ct_flags & CT_IS_LONGDOUBLE)\n                return read_raw_longdouble_data(cd->c_data) != 0.0;\n            return read_raw_float_data(cd->c_data, cd->c_type->ct_size) != 0.0;\n        }\n        if (cd->c_type->ct_flags & CT_PRIMITIVE_COMPLEX) {\n            Py_complex value = read_raw_complex_data(cd->c_data,\n                                                     cd->c_type->ct_size);\n            return value.real != 0.0 || value.imag != 0.0;\n        }\n    }\n    return cd->c_data != NULL;\n}\n\nstatic PyObject *cdata_int(CDataObject *cd)\n{\n    if ((cd->c_type->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_FITS_LONG))\n                             == (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_FITS_LONG)) {\n        /* this case is to handle enums, but also serves as a slight\n           performance improvement for some other primitive types */\n        long value;\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        value = (long)read_raw_signed_data(cd->c_data, cd->c_type->ct_size);\n        return PyInt_FromLong(value);\n    }\n    if (cd->c_type->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED)) {\n        PyObject *result = convert_to_object(cd->c_data, cd->c_type);\n        if (result != NULL && PyBool_Check(result))\n            result = PyInt_FromLong(PyInt_AsLong(result));\n        return result;\n    }\n    else if (cd->c_type->ct_flags & CT_PRIMITIVE_CHAR) {\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        switch (cd->c_type->ct_size) {\n        case sizeof(char):\n            return PyInt_FromLong((unsigned char)cd->c_data[0]);\n        case 2:\n            return PyInt_FromLong((long)*(cffi_char16_t *)cd->c_data);\n        case 4:\n            if (cd->c_type->ct_flags & CT_IS_SIGNED_WCHAR)\n                return PyInt_FromLong((long)*(int32_t *)cd->c_data);\n            else if (sizeof(long) > 4)\n                return PyInt_FromLong(*(uint32_t *)cd->c_data);\n            else\n                return PyLong_FromUnsignedLong(*(uint32_t *)cd->c_data);\n        }\n    }\n    else if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n        PyObject *o = cdata_float(cd);\n#if PY_MAJOR_VERSION < 3\n        PyObject *r = o ? PyNumber_Int(o) : NULL;\n#else\n        PyObject *r = o ? PyNumber_Long(o) : NULL;\n#endif\n        Py_XDECREF(o);\n        return r;\n    }\n    PyErr_Format(PyExc_TypeError, \"int() not supported on cdata '%s'\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\n#if PY_MAJOR_VERSION < 3\nstatic PyObject *cdata_long(CDataObject *cd)\n{\n    PyObject *res = cdata_int(cd);\n    if (res != NULL && PyInt_CheckExact(res)) {\n        PyObject *o = PyLong_FromLong(PyInt_AS_LONG(res));\n        Py_DECREF(res);\n        res = o;\n    }\n    return res;\n}\n#endif\n\nstatic PyObject *cdata_float(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n        double value;\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        if (!(cd->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n            value = read_raw_float_data(cd->c_data, cd->c_type->ct_size);\n        }\n        else {\n            value = (double)read_raw_longdouble_data(cd->c_data);\n        }\n        return PyFloat_FromDouble(value);\n    }\n    PyErr_Format(PyExc_TypeError, \"float() not supported on cdata '%s'\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\nstatic PyObject *cdata_richcompare(PyObject *v, PyObject *w, int op)\n{\n    int v_is_ptr, w_is_ptr;\n    PyObject *pyres;\n\n    assert(CData_Check(v));\n\n    /* Comparisons involving a primitive cdata work differently than\n     * comparisons involving a struct/array/pointer.\n     *\n     * If v or w is a struct/array/pointer, then the other must be too\n     * (otherwise we return NotImplemented and leave the case to\n     * Python).  If both are, then we compare the addresses.\n     *\n     * If v and/or w is a primitive cdata, then we convert the cdata(s)\n     * to regular Python objects and redo the comparison there.\n     */\n\n    v_is_ptr = !(((CDataObject *)v)->c_type->ct_flags & CT_PRIMITIVE_ANY);\n    w_is_ptr = CData_Check(w) &&\n                  !(((CDataObject *)w)->c_type->ct_flags & CT_PRIMITIVE_ANY);\n\n    if (v_is_ptr && w_is_ptr) {\n        int res;\n        char *v_cdata = ((CDataObject *)v)->c_data;\n        char *w_cdata = ((CDataObject *)w)->c_data;\n\n        switch (op) {\n        case Py_EQ: res = (v_cdata == w_cdata); break;\n        case Py_NE: res = (v_cdata != w_cdata); break;\n        case Py_LT: res = (v_cdata <  w_cdata); break;\n        case Py_LE: res = (v_cdata <= w_cdata); break;\n        case Py_GT: res = (v_cdata >  w_cdata); break;\n        case Py_GE: res = (v_cdata >= w_cdata); break;\n        default: res = -1;\n        }\n        pyres = res ? Py_True : Py_False;\n    }\n    else if (v_is_ptr || w_is_ptr) {\n        pyres = Py_NotImplemented;\n    }\n    else {\n        PyObject *aa[2];\n        int i;\n\n        aa[0] = v; Py_INCREF(v);\n        aa[1] = w; Py_INCREF(w);\n        pyres = NULL;\n\n        for (i = 0; i < 2; i++) {\n            v = aa[i];\n            if (!CData_Check(v))\n                continue;\n            w = convert_to_object(((CDataObject *)v)->c_data,\n                                  ((CDataObject *)v)->c_type);\n            if (w == NULL)\n                goto error;\n            if (CData_Check(w)) {\n                Py_DECREF(w);\n                PyErr_Format(PyExc_NotImplementedError,\n                             \"cannot use <cdata '%s'> in a comparison\",\n                             ((CDataObject *)v)->c_type->ct_name);\n                goto error;\n            }\n            aa[i] = w;\n            Py_DECREF(v);\n        }\n        pyres = PyObject_RichCompare(aa[0], aa[1], op);\n     error:\n        Py_DECREF(aa[1]);\n        Py_DECREF(aa[0]);\n        return pyres;\n    }\n\n    Py_INCREF(pyres);\n    return pyres;\n}\n\n#if PY_MAJOR_VERSION < 3\ntypedef long Py_hash_t;\n#endif\n\nstatic Py_hash_t cdata_hash(PyObject *v)\n{\n    if (((CDataObject *)v)->c_type->ct_flags & CT_PRIMITIVE_ANY) {\n        PyObject *vv = convert_to_object(((CDataObject *)v)->c_data,\n                                         ((CDataObject *)v)->c_type);\n        if (vv == NULL)\n            return -1;\n        if (!CData_Check(vv)) {\n            Py_hash_t hash = PyObject_Hash(vv);\n            Py_DECREF(vv);\n            return hash;\n        }\n        Py_DECREF(vv);\n    }\n    return _Py_HashPointer(((CDataObject *)v)->c_data);\n}\n\nstatic Py_ssize_t\ncdata_length(CDataObject *cd)\n{\n    if (cd->c_type->ct_flags & CT_ARRAY) {\n        return get_array_length(cd);\n    }\n    PyErr_Format(PyExc_TypeError, \"cdata of type '%s' has no len()\",\n                 cd->c_type->ct_name);\n    return -1;\n}\n\nstatic char *\n_cdata_get_indexed_ptr(CDataObject *cd, PyObject *key)\n{\n    Py_ssize_t i = PyNumber_AsSsize_t(key, PyExc_IndexError);\n    if (i == -1 && PyErr_Occurred())\n        return NULL;\n\n    if (cd->c_type->ct_flags & CT_POINTER) {\n        if (CDataOwn_Check(cd)) {\n            if (i != 0) {\n                PyErr_Format(PyExc_IndexError,\n                             \"cdata '%s' can only be indexed by 0\",\n                             cd->c_type->ct_name);\n                return NULL;\n            }\n        }\n        else {\n            if (cd->c_data == NULL) {\n                PyErr_Format(PyExc_RuntimeError,\n                             \"cannot dereference null pointer from cdata '%s'\",\n                             cd->c_type->ct_name);\n                return NULL;\n            }\n        }\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        if (i < 0) {\n            PyErr_SetString(PyExc_IndexError,\n                            \"negative index\");\n            return NULL;\n        }\n        if (i >= get_array_length(cd)) {\n            PyErr_Format(PyExc_IndexError,\n                         \"index too large for cdata '%s' (expected %zd < %zd)\",\n                         cd->c_type->ct_name,\n                         i, get_array_length(cd));\n            return NULL;\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cdata of type '%s' cannot be indexed\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    return cd->c_data + i * cd->c_type->ct_itemdescr->ct_size;\n}\n\nstatic PyObject *\nnew_array_type(CTypeDescrObject *ctptr, Py_ssize_t length);   /* forward */\n\nstatic CTypeDescrObject *\n_cdata_getslicearg(CDataObject *cd, PySliceObject *slice, Py_ssize_t bounds[])\n{\n    Py_ssize_t start, stop;\n    CTypeDescrObject *ct;\n\n    start = PyInt_AsSsize_t(slice->start);\n    if (start == -1 && PyErr_Occurred()) {\n        if (slice->start == Py_None)\n            PyErr_SetString(PyExc_IndexError, \"slice start must be specified\");\n        return NULL;\n    }\n    stop = PyInt_AsSsize_t(slice->stop);\n    if (stop == -1 && PyErr_Occurred()) {\n        if (slice->stop == Py_None)\n            PyErr_SetString(PyExc_IndexError, \"slice stop must be specified\");\n        return NULL;\n    }\n    if (slice->step != Py_None) {\n        PyErr_SetString(PyExc_IndexError, \"slice with step not supported\");\n        return NULL;\n    }\n    if (start > stop) {\n        PyErr_SetString(PyExc_IndexError, \"slice start > stop\");\n        return NULL;\n    }\n\n    ct = cd->c_type;\n    if (ct->ct_flags & CT_ARRAY) {\n        if (start < 0) {\n            PyErr_SetString(PyExc_IndexError,\n                            \"negative index\");\n            return NULL;\n        }\n        if (stop > get_array_length(cd)) {\n            PyErr_Format(PyExc_IndexError,\n                         \"index too large (expected %zd <= %zd)\",\n                         stop, get_array_length(cd));\n            return NULL;\n        }\n        ct = (CTypeDescrObject *)ct->ct_stuff;\n    }\n    else if (!(ct->ct_flags & CT_POINTER)) {\n        PyErr_Format(PyExc_TypeError, \"cdata of type '%s' cannot be indexed\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n    bounds[0] = start;\n    bounds[1] = stop - start;\n    return ct;\n}\n\nstatic PyObject *\ncdata_slice(CDataObject *cd, PySliceObject *slice)\n{\n    char *cdata;\n    Py_ssize_t bounds[2];\n    CTypeDescrObject *ct = _cdata_getslicearg(cd, slice, bounds);\n    if (ct == NULL)\n        return NULL;\n\n    if (ct->ct_stuff == NULL) {\n        ct->ct_stuff = new_array_type(ct, -1);\n        if (ct->ct_stuff == NULL)\n            return NULL;\n    }\n    ct = (CTypeDescrObject *)ct->ct_stuff;\n\n    cdata = cd->c_data + ct->ct_itemdescr->ct_size * bounds[0];\n    return new_sized_cdata(cdata, ct, bounds[1]);\n}\n\nstatic int\ncdata_ass_slice(CDataObject *cd, PySliceObject *slice, PyObject *v)\n{\n    Py_ssize_t bounds[2], i, length, itemsize;\n    PyObject *it, *item;\n    PyObject *(*iternext)(PyObject *);\n    char *cdata;\n    int err;\n    CTypeDescrObject *ct = _cdata_getslicearg(cd, slice, bounds);\n    if (ct == NULL)\n        return -1;\n    ct = ct->ct_itemdescr;\n    itemsize = ct->ct_size;\n    cdata = cd->c_data + itemsize * bounds[0];\n    length = bounds[1];\n\n    if (CData_Check(v)) {\n        CTypeDescrObject *ctv = ((CDataObject *)v)->c_type;\n        if ((ctv->ct_flags & CT_ARRAY) && (ctv->ct_itemdescr == ct) &&\n            (get_array_length((CDataObject *)v) == length)) {\n            /* fast path: copying from exactly the correct type */\n            memmove(cdata, ((CDataObject *)v)->c_data, itemsize * length);\n            return 0;\n        }\n    }\n\n    /* A fast path for <char[]>[0:N] = b\"somestring\" or bytearray, which\n       also adds support for Python 3: otherwise, you get integers while\n       enumerating the string, and you can't set them to characters :-/\n    */\n    if ((ct->ct_flags & CT_PRIMITIVE_CHAR) && itemsize == sizeof(char)) {\n        char *src;\n        Py_ssize_t srclen;\n        if (PyBytes_Check(v)) {\n            srclen = PyBytes_GET_SIZE(v);\n            src = PyBytes_AS_STRING(v);\n        }\n        else if (PyByteArray_Check(v)) {\n            srclen = PyByteArray_GET_SIZE(v);\n            src = PyByteArray_AS_STRING(v);\n        }\n        else\n            goto other_types;\n\n        if (srclen != length) {\n            PyErr_Format(PyExc_ValueError,\n                         \"need a string of length %zd, got %zd\",\n                         length, srclen);\n            return -1;\n        }\n        memcpy(cdata, src, length);\n        return 0;\n    }\n   other_types:\n\n    it = PyObject_GetIter(v);\n    if (it == NULL)\n        return -1;\n    iternext = *it->ob_type->tp_iternext;\n\n    for (i = 0; i < length; i++) {\n        item = iternext(it);\n        if (item == NULL) {\n            if (!PyErr_Occurred())\n                PyErr_Format(PyExc_ValueError,\n                             \"need %zd values to unpack, got %zd\",\n                             length, i);\n            goto error;\n        }\n        err = convert_from_object(cdata, ct, item);\n        Py_DECREF(item);\n        if (err < 0)\n            goto error;\n\n        cdata += itemsize;\n    }\n    item = iternext(it);\n    if (item != NULL) {\n        Py_DECREF(item);\n        PyErr_Format(PyExc_ValueError,\n                     \"got more than %zd values to unpack\", length);\n    }\n error:\n    Py_DECREF(it);\n    return PyErr_Occurred() ? -1 : 0;\n}\n\nstatic PyObject *\ncdataowning_subscript(CDataObject *cd, PyObject *key)\n{\n    char *c;\n    if (PySlice_Check(key))\n        return cdata_slice(cd, (PySliceObject *)key);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    /* use 'mp_subscript' instead of 'sq_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return NULL;\n\n    if (cd->c_type->ct_flags & CT_IS_PTR_TO_OWNED) {\n        PyObject *res = ((CDataObject_own_structptr *)cd)->structobj;\n        Py_INCREF(res);\n        return res;\n    }\n    else {\n        return convert_to_object(c, cd->c_type->ct_itemdescr);\n    }\n}\n\nstatic PyObject *\ncdata_subscript(CDataObject *cd, PyObject *key)\n{\n    char *c;\n    if (PySlice_Check(key))\n        return cdata_slice(cd, (PySliceObject *)key);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    /* use 'mp_subscript' instead of 'sq_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return NULL;\n    return convert_to_object(c, cd->c_type->ct_itemdescr);\n}\n\nstatic int\ncdata_ass_sub(CDataObject *cd, PyObject *key, PyObject *v)\n{\n    char *c;\n    CTypeDescrObject *ctitem;\n    if (PySlice_Check(key))\n        return cdata_ass_slice(cd, (PySliceObject *)key, v);\n\n    c = _cdata_get_indexed_ptr(cd, key);\n    ctitem = cd->c_type->ct_itemdescr;\n    /* use 'mp_ass_subscript' instead of 'sq_ass_item' because we don't want\n       negative indexes to be corrected automatically */\n    if (c == NULL && PyErr_Occurred())\n        return -1;\n    if (v == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"'del x[n]' not supported for cdata objects\");\n        return -1;\n    }\n    return convert_from_object(c, ctitem, v);\n}\n\nstatic PyObject *\n_cdata_add_or_sub(PyObject *v, PyObject *w, int sign)\n{\n    Py_ssize_t i, itemsize;\n    CDataObject *cd;\n    CTypeDescrObject *ctptr;\n\n    if (!CData_Check(v)) {\n        PyObject *swap;\n        assert(CData_Check(w));\n        if (sign != 1)\n            goto not_implemented;\n        swap = v;\n        v = w;\n        w = swap;\n    }\n\n    i = PyNumber_AsSsize_t(w, PyExc_OverflowError);\n    if (i == -1 && PyErr_Occurred())\n        return NULL;\n    i *= sign;\n\n    cd = (CDataObject *)v;\n    if (cd->c_type->ct_flags & CT_POINTER)\n        ctptr = cd->c_type;\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        ctptr = (CTypeDescrObject *)cd->c_type->ct_stuff;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cannot add a cdata '%s' and a number\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    itemsize = ctptr->ct_itemdescr->ct_size;\n    if (itemsize < 0) {\n        if (ctptr->ct_flags & CT_IS_VOID_PTR) {\n            itemsize = 1;\n        }\n        else {\n            PyErr_Format(PyExc_TypeError,\n                         \"ctype '%s' points to items of unknown size\",\n                         cd->c_type->ct_name);\n            return NULL;\n        }\n    }\n    return new_simple_cdata(cd->c_data + i * itemsize, ctptr);\n\n not_implemented:\n    Py_INCREF(Py_NotImplemented);\n    return Py_NotImplemented;\n}\n\nstatic PyObject *\ncdata_add(PyObject *v, PyObject *w)\n{\n    return _cdata_add_or_sub(v, w, +1);\n}\n\nstatic PyObject *\ncdata_sub(PyObject *v, PyObject *w)\n{\n    if (CData_Check(v) && CData_Check(w)) {\n        CDataObject *cdv = (CDataObject *)v;\n        CDataObject *cdw = (CDataObject *)w;\n        CTypeDescrObject *ct = cdw->c_type;\n        Py_ssize_t diff, itemsize;\n\n        if (ct->ct_flags & CT_ARRAY)     /* ptr_to_T - array_of_T: ok */\n            ct = (CTypeDescrObject *)ct->ct_stuff;\n\n        if (ct != cdv->c_type || !(ct->ct_flags & CT_POINTER) ||\n                (ct->ct_itemdescr->ct_size <= 0 &&\n                 !(ct->ct_flags & CT_IS_VOID_PTR))) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot subtract cdata '%s' and cdata '%s'\",\n                         cdv->c_type->ct_name, ct->ct_name);\n            return NULL;\n        }\n        itemsize = ct->ct_itemdescr->ct_size;\n        diff = cdv->c_data - cdw->c_data;\n        if (itemsize > 1) {\n            if (diff % itemsize) {\n                PyErr_SetString(PyExc_ValueError,\n                     \"pointer subtraction: the distance between the two \"\n                     \"pointers is not a multiple of the item size\");\n                return NULL;\n            }\n            diff = diff / itemsize;\n        }\n#if PY_MAJOR_VERSION < 3\n        return PyInt_FromSsize_t(diff);\n#else\n        return PyLong_FromSsize_t(diff);\n#endif\n    }\n\n    return _cdata_add_or_sub(v, w, -1);\n}\n\nstatic void\n_cdata_attr_errmsg(char *errmsg, CDataObject *cd, PyObject *attr)\n{\n    const char *text;\n    if (!PyErr_ExceptionMatches(PyExc_AttributeError))\n        return;\n    PyErr_Clear();\n    text = PyText_AsUTF8(attr);\n    if (text == NULL)\n        return;\n    PyErr_Format(PyExc_AttributeError, errmsg, cd->c_type->ct_name, text);\n}\n\nstatic PyObject *\ncdata_getattro(CDataObject *cd, PyObject *attr)\n{\n    CFieldObject *cf;\n    CTypeDescrObject *ct = cd->c_type;\n    char *errmsg = \"cdata '%s' has no attribute '%s'\";\n    PyObject *x;\n\n    if (ct->ct_flags & CT_POINTER)\n        ct = ct->ct_itemdescr;\n\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n        switch (force_lazy_struct(ct)) {\n        case 1:\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, attr);\n            if (cf != NULL) {\n                /* read the field 'cf' */\n                char *data = cd->c_data + cf->cf_offset;\n                Py_ssize_t array_len, size;\n\n                if (cf->cf_bitshift == BS_REGULAR) {\n                    return convert_to_object(data, cf->cf_type);\n                }\n                else if (cf->cf_bitshift != BS_EMPTY_ARRAY) {\n                    return convert_to_object_bitfield(data, cf);\n                }\n\n                /* variable-length array: */\n                /* if reading variable length array from variable length\n                   struct, calculate array type from allocated length */\n                size = _cdata_var_byte_size(cd) - cf->cf_offset;\n                if (size >= 0) {\n                    array_len = size / cf->cf_type->ct_itemdescr->ct_size;\n                    return new_sized_cdata(data, cf->cf_type, array_len);\n                }\n                return new_simple_cdata(data,\n                    (CTypeDescrObject *)cf->cf_type->ct_stuff);\n            }\n            errmsg = \"cdata '%s' has no field '%s'\";\n            break;\n        case -1:\n            return NULL;\n        default:\n            errmsg = \"cdata '%s' points to an opaque type: cannot read fields\";\n            break;\n        }\n    }\n    x = PyObject_GenericGetAttr((PyObject *)cd, attr);\n    if (x == NULL)\n        _cdata_attr_errmsg(errmsg, cd, attr);\n    return x;\n}\n\nstatic int\ncdata_setattro(CDataObject *cd, PyObject *attr, PyObject *value)\n{\n    CFieldObject *cf;\n    CTypeDescrObject *ct = cd->c_type;\n    char *errmsg = \"cdata '%s' has no attribute '%s'\";\n    int x;\n\n    if (ct->ct_flags & CT_POINTER)\n        ct = ct->ct_itemdescr;\n\n    if (ct->ct_flags & (CT_STRUCT|CT_UNION)) {\n        switch (force_lazy_struct(ct)) {\n        case 1:\n            cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, attr);\n            if (cf != NULL) {\n                /* write the field 'cf' */\n                if (value != NULL) {\n                    return convert_field_from_object(cd->c_data, cf, value);\n                }\n                else {\n                    PyErr_SetString(PyExc_AttributeError,\n                                    \"cannot delete struct field\");\n                    return -1;\n                }\n            }\n            errmsg = \"cdata '%s' has no field '%s'\";\n            break;\n        case -1:\n            return -1;\n        default:\n            errmsg = \"cdata '%s' points to an opaque type: cannot write fields\";\n            break;\n        }\n    }\n    x = PyObject_GenericSetAttr((PyObject *)cd, attr, value);\n    if (x < 0)\n        _cdata_attr_errmsg(errmsg, cd, attr);\n    return x;\n}\n\nstatic PyObject *\nconvert_struct_to_owning_object(char *data, CTypeDescrObject *ct); /*forward*/\n\nstatic cif_description_t *\nfb_prepare_cif(PyObject *fargs, CTypeDescrObject *, ffi_abi);      /*forward*/\n\nstatic PyObject *new_primitive_type(const char *name);             /*forward*/\n\nstatic CTypeDescrObject *_get_ct_int(void)\n{\n    static CTypeDescrObject *ct_int = NULL;\n    if (ct_int == NULL) {\n        ct_int = (CTypeDescrObject *)new_primitive_type(\"int\");\n    }\n    return ct_int;\n}\n\nstatic Py_ssize_t\n_prepare_pointer_call_argument(CTypeDescrObject *ctptr, PyObject *init,\n                               char **output_data)\n{\n    /* 'ctptr' is here a pointer type 'ITEM *'.  Accept as argument an\n       initializer for an array 'ITEM[]'.  This includes the case of\n       passing a Python byte string to a 'char *' argument.\n\n       This function returns -1 if an error occurred,\n       0 if conversion succeeded (into *output_data),\n       or N > 0 if conversion would require N bytes of storage.\n    */\n    Py_ssize_t length, datasize;\n    CTypeDescrObject *ctitem;\n\n    if (CData_Check(init))\n        goto convert_default;\n\n    ctitem = ctptr->ct_itemdescr;\n    /* XXX some code duplication, how to avoid it? */\n    if (PyBytes_Check(init)) {\n        /* from a string: just returning the string here is fine.\n           We assume that the C code won't modify the 'char *' data. */\n        if ((ctptr->ct_flags & CT_IS_VOIDCHAR_PTR) ||\n            ((ctitem->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))\n             && (ctitem->ct_size == sizeof(char)))) {\n#if defined(CFFI_MEM_DEBUG) || defined(CFFI_MEM_LEAK)\n            length = PyBytes_GET_SIZE(init) + 1;\n#else\n            *output_data = PyBytes_AS_STRING(init);\n            if (ctitem->ct_flags & CT_IS_BOOL)\n                if (must_be_array_of_zero_or_one(*output_data,\n                                                 PyBytes_GET_SIZE(init)) < 0)\n                    return -1;\n            return 0;\n#endif\n        }\n        else\n            goto convert_default;\n    }\n    else if (PyList_Check(init) || PyTuple_Check(init)) {\n        length = PySequence_Fast_GET_SIZE(init);\n    }\n    else if (PyUnicode_Check(init)) {\n        /* from a unicode, we add the null terminator */\n        if (ctitem->ct_size == 2)\n            length = _my_PyUnicode_SizeAsChar16(init);\n        else\n            length = _my_PyUnicode_SizeAsChar32(init);\n        length += 1;\n    }\n    else if ((ctitem->ct_flags & CT_IS_FILE) && PyFile_Check(init)) {\n        *output_data = (char *)PyFile_AsFile(init);\n        if (*output_data == NULL && PyErr_Occurred())\n            return -1;\n        return 0;\n    }\n    else {\n        /* refuse to receive just an integer (and interpret it\n           as the array size) */\n        goto convert_default;\n    }\n\n    if (ctitem->ct_size <= 0)\n        goto convert_default;\n    datasize = MUL_WRAPAROUND(length, ctitem->ct_size);\n    if ((datasize / ctitem->ct_size) != length) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"array size would overflow a Py_ssize_t\");\n        return -1;\n    }\n    if (datasize <= 0)\n        datasize = 1;\n    return datasize;\n\n convert_default:\n    return convert_from_object((char *)output_data, ctptr, init);\n}\n\nstatic PyObject*\ncdata_call(CDataObject *cd, PyObject *args, PyObject *kwds)\n{\n    char *buffer;\n    void** buffer_array;\n    cif_description_t *cif_descr;\n    Py_ssize_t i, nargs, nargs_declared;\n    PyObject *signature, *res = NULL, *fvarargs;\n    CTypeDescrObject *fresult;\n    char *resultdata;\n    char *errormsg;\n\n    if (!(cd->c_type->ct_flags & CT_FUNCTIONPTR)) {\n        PyErr_Format(PyExc_TypeError, \"cdata '%s' is not callable\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (cd->c_data == NULL) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"cannot call null pointer pointer from cdata '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (kwds != NULL && PyDict_Size(kwds) != 0) {\n        PyErr_SetString(PyExc_TypeError,\n                \"a cdata function cannot be called with keyword arguments\");\n        return NULL;\n    }\n    signature = cd->c_type->ct_stuff;\n    nargs = PyTuple_Size(args);\n    if (nargs < 0)\n        return NULL;\n    nargs_declared = PyTuple_GET_SIZE(signature) - 2;\n    fresult = (CTypeDescrObject *)PyTuple_GET_ITEM(signature, 1);\n    fvarargs = NULL;\n    buffer = NULL;\n\n    cif_descr = (cif_description_t *)cd->c_type->ct_extra;\n\n    if (cif_descr != NULL) {\n        /* regular case: this function does not take '...' arguments */\n        if (nargs != nargs_declared) {\n            errormsg = \"'%s' expects %zd arguments, got %zd\";\n          bad_number_of_arguments:\n            PyErr_Format(PyExc_TypeError, errormsg,\n                         cd->c_type->ct_name, nargs_declared, nargs);\n            goto error;\n        }\n    }\n    else {\n        /* call of a variadic function */\n        ffi_abi fabi;\n        if (nargs < nargs_declared) {\n            errormsg = \"'%s' expects at least %zd arguments, got %zd\";\n            goto bad_number_of_arguments;\n        }\n        fvarargs = PyTuple_New(nargs);\n        if (fvarargs == NULL)\n            goto error;\n        for (i = 0; i < nargs_declared; i++) {\n            PyObject *o = PyTuple_GET_ITEM(signature, 2 + i);\n            Py_INCREF(o);\n            PyTuple_SET_ITEM(fvarargs, i, o);\n        }\n        for (i = nargs_declared; i < nargs; i++) {\n            PyObject *obj = PyTuple_GET_ITEM(args, i);\n            CTypeDescrObject *ct;\n\n            if (CData_Check(obj)) {\n                ct = ((CDataObject *)obj)->c_type;\n                if (ct->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_UNSIGNED |\n                                    CT_PRIMITIVE_SIGNED)) {\n                    if (ct->ct_size < (Py_ssize_t)sizeof(int)) {\n                        ct = _get_ct_int();\n                        if (ct == NULL)\n                            goto error;\n                    }\n                }\n                else if (ct->ct_flags & CT_ARRAY) {\n                    ct = (CTypeDescrObject *)ct->ct_stuff;\n                }\n                Py_INCREF(ct);\n            }\n            else {\n                PyErr_Format(PyExc_TypeError,\n                             \"argument %zd passed in the variadic part \"\n                             \"needs to be a cdata object (got %.200s)\",\n                             i + 1, Py_TYPE(obj)->tp_name);\n                goto error;\n            }\n            PyTuple_SET_ITEM(fvarargs, i, (PyObject *)ct);\n        }\n#if PY_MAJOR_VERSION < 3\n        fabi = PyInt_AS_LONG(PyTuple_GET_ITEM(signature, 0));\n#else\n        fabi = PyLong_AS_LONG(PyTuple_GET_ITEM(signature, 0));\n#endif\n        cif_descr = fb_prepare_cif(fvarargs, fresult, fabi);\n        if (cif_descr == NULL)\n            goto error;\n    }\n\n    buffer = PyObject_Malloc(cif_descr->exchange_size);\n    if (buffer == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n\n    buffer_array = (void **)buffer;\n\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *argtype;\n        char *data = buffer + cif_descr->exchange_offset_arg[1 + i];\n        PyObject *obj = PyTuple_GET_ITEM(args, i);\n\n        buffer_array[i] = data;\n\n        if (i < nargs_declared)\n            argtype = (CTypeDescrObject *)PyTuple_GET_ITEM(signature, 2 + i);\n        else\n            argtype = (CTypeDescrObject *)PyTuple_GET_ITEM(fvarargs, i);\n\n        if (argtype->ct_flags & CT_POINTER) {\n            char *tmpbuf;\n            Py_ssize_t datasize = _prepare_pointer_call_argument(\n                                            argtype, obj, (char **)data);\n            if (datasize == 0)\n                ;    /* successfully filled '*data' */\n            else if (datasize < 0)\n                goto error;\n            else {\n                tmpbuf = alloca(datasize);\n                memset(tmpbuf, 0, datasize);\n                *(char **)data = tmpbuf;\n                if (convert_array_from_object(tmpbuf, argtype, obj) < 0)\n                    goto error;\n            }\n        }\n        else if (convert_from_object(data, argtype, obj) < 0)\n            goto error;\n    }\n\n    resultdata = buffer + cif_descr->exchange_offset_arg[0];\n    /*READ(cd->c_data, sizeof(void(*)(void)))*/\n\n    Py_BEGIN_ALLOW_THREADS\n    restore_errno();\n    ffi_call(&cif_descr->cif, (void (*)(void))(cd->c_data),\n             resultdata, buffer_array);\n    save_errno();\n    Py_END_ALLOW_THREADS\n\n    if (fresult->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_SIGNED |\n                             CT_PRIMITIVE_UNSIGNED)) {\n#ifdef WORDS_BIGENDIAN\n        /* For results of precisely these types, libffi has a strange\n           rule that they will be returned as a whole 'ffi_arg' if they\n           are smaller.  The difference only matters on big-endian. */\n        if (fresult->ct_size < sizeof(ffi_arg))\n            resultdata += (sizeof(ffi_arg) - fresult->ct_size);\n#endif\n        res = convert_to_object(resultdata, fresult);\n    }\n    else if (fresult->ct_flags & CT_VOID) {\n        res = Py_None;\n        Py_INCREF(res);\n    }\n    else if (fresult->ct_flags & CT_STRUCT) {\n        res = convert_struct_to_owning_object(resultdata, fresult);\n    }\n    else {\n        res = convert_to_object(resultdata, fresult);\n    }\n    /* fall-through */\n\n error:\n    if (buffer)\n        PyObject_Free(buffer);\n    if (fvarargs != NULL) {\n        Py_DECREF(fvarargs);\n        if (cif_descr != NULL)  /* but only if fvarargs != NULL, if variadic */\n            PyObject_Free(cif_descr);\n    }\n    return res;\n}\n\nstatic PyObject *cdata_dir(PyObject *cd, PyObject *noarg)\n{\n    CTypeDescrObject *ct = ((CDataObject *)cd)->c_type;\n\n    /* replace the type 'pointer-to-t' with just 't' */\n    if (ct->ct_flags & CT_POINTER) {\n        ct = ct->ct_itemdescr;\n    }\n    if ((ct->ct_flags & (CT_STRUCT | CT_UNION)) &&\n        !(ct->ct_flags & CT_IS_OPAQUE)) {\n\n        /* for non-opaque structs or unions */\n        if (force_lazy_struct(ct) < 0)\n            return NULL;\n        return PyDict_Keys(ct->ct_stuff);\n    }\n    else {\n        return PyList_New(0);   /* empty list for the other cases */\n    }\n}\n\nstatic PyObject *cdata_complex(PyObject *cd_, PyObject *noarg)\n{\n    CDataObject *cd = (CDataObject *)cd_;\n\n    if (cd->c_type->ct_flags & CT_PRIMITIVE_COMPLEX) {\n        Py_complex value = read_raw_complex_data(cd->c_data, cd->c_type->ct_size);\n        PyObject *op = PyComplex_FromCComplex(value);\n        return op;\n    }\n    /* <cdata 'float'> or <cdata 'int'> cannot be directly converted by\n       calling complex(), just like <cdata 'int'> cannot be directly\n       converted by calling float() */\n\n    PyErr_Format(PyExc_TypeError, \"complex() not supported on cdata '%s'\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\nstatic int explicit_release_case(PyObject *cd)\n{\n    CTypeDescrObject *ct = ((CDataObject *)cd)->c_type;\n    if (Py_TYPE(cd) == &CDataOwning_Type) {\n        if ((ct->ct_flags & (CT_POINTER | CT_ARRAY)) != 0)   /* ffi.new() */\n            return 0;\n    }\n    else if (Py_TYPE(cd) == &CDataFromBuf_Type) {\n        return 1;    /* ffi.from_buffer() */\n    }\n    else if (Py_TYPE(cd) == &CDataGCP_Type) {\n        return 2;    /* ffi.gc() */\n    }\n    PyErr_SetString(PyExc_ValueError,\n        \"only 'cdata' object from ffi.new(), ffi.gc(), ffi.from_buffer() \"\n        \"or ffi.new_allocator()() can be used with the 'with' keyword or \"\n        \"ffi.release()\");\n    return -1;\n}\n\nstatic PyObject *cdata_enter(PyObject *cd, PyObject *noarg)\n{\n    if (explicit_release_case(cd) < 0)   /* only to check the ctype */\n        return NULL;\n    Py_INCREF(cd);\n    return cd;\n}\n\nstatic PyObject *cdata_exit(PyObject *cd, PyObject *args)\n{\n    /* 'args' ignored */\n    CTypeDescrObject *ct;\n    Py_buffer *view;\n    switch (explicit_release_case(cd))\n    {\n        case 0:    /* ffi.new() */\n            /* no effect on CPython: raw memory is allocated with the\n               same malloc() as the object itself, so it can't be\n               released independently.  If we use a custom allocator,\n               then it's implemented with ffi.gc(). */\n            ct = ((CDataObject *)cd)->c_type;\n            if (ct->ct_flags & CT_IS_PTR_TO_OWNED) {\n                PyObject *x = ((CDataObject_own_structptr *)cd)->structobj;\n                if (Py_TYPE(x) == &CDataGCP_Type) {\n                    /* this is a special case for\n                       ffi.new_allocator()(\"struct-or-union *\") */\n                    cdatagcp_finalize((CDataObject_gcp *)x);\n                }\n            }\n            break;\n\n        case 1:    /* ffi.from_buffer() */\n            view = ((CDataObject_frombuf *)cd)->bufferview;\n            PyBuffer_Release(view);\n            break;\n\n        case 2:    /* ffi.gc() or ffi.new_allocator()(\"not-struct-nor-union\") */\n            /* call the destructor immediately */\n            cdatagcp_finalize((CDataObject_gcp *)cd);\n            break;\n\n        default:\n            return NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *cdata_iter(CDataObject *);\n\nstatic PyNumberMethods CData_as_number = {\n    (binaryfunc)cdata_add,      /*nb_add*/\n    (binaryfunc)cdata_sub,      /*nb_subtract*/\n    0,                          /*nb_multiply*/\n#if PY_MAJOR_VERSION < 3\n    0,                          /*nb_divide*/\n#endif\n    0,                          /*nb_remainder*/\n    0,                          /*nb_divmod*/\n    0,                          /*nb_power*/\n    0,                          /*nb_negative*/\n    0,                          /*nb_positive*/\n    0,                          /*nb_absolute*/\n    (inquiry)cdata_nonzero,     /*nb_nonzero*/\n    0,                          /*nb_invert*/\n    0,                          /*nb_lshift*/\n    0,                          /*nb_rshift*/\n    0,                          /*nb_and*/\n    0,                          /*nb_xor*/\n    0,                          /*nb_or*/\n#if PY_MAJOR_VERSION < 3\n    0,                          /*nb_coerce*/\n#endif\n    (unaryfunc)cdata_int,       /*nb_int*/\n#if PY_MAJOR_VERSION < 3\n    (unaryfunc)cdata_long,      /*nb_long*/\n#else\n    0,\n#endif\n    (unaryfunc)cdata_float,     /*nb_float*/\n    0,                          /*nb_oct*/\n    0,                          /*nb_hex*/\n};\n\nstatic PyMappingMethods CData_as_mapping = {\n    (lenfunc)cdata_length, /*mp_length*/\n    (binaryfunc)cdata_subscript, /*mp_subscript*/\n    (objobjargproc)cdata_ass_sub, /*mp_ass_subscript*/\n};\n\nstatic PyMappingMethods CDataOwn_as_mapping = {\n    (lenfunc)cdata_length, /*mp_length*/\n    (binaryfunc)cdataowning_subscript, /*mp_subscript*/\n    (objobjargproc)cdata_ass_sub, /*mp_ass_subscript*/\n};\n\nstatic PyMethodDef cdata_methods[] = {\n    {\"__dir__\",     cdata_dir,      METH_NOARGS},\n    {\"__complex__\", cdata_complex,  METH_NOARGS},\n    {\"__enter__\",   cdata_enter,    METH_NOARGS},\n    {\"__exit__\",    cdata_exit,     METH_VARARGS},\n    {NULL,          NULL}           /* sentinel */\n};\n\nstatic PyTypeObject CData_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CData\",\n    sizeof(CDataObject),\n    0,\n    (destructor)cdata_dealloc,                  /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdata_repr,                       /* tp_repr */\n    &CData_as_number,                           /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    &CData_as_mapping,                          /* tp_as_mapping */\n    cdata_hash,                                 /* tp_hash */\n    (ternaryfunc)cdata_call,                    /* tp_call */\n    0,                                          /* tp_str */\n    (getattrofunc)cdata_getattro,               /* tp_getattro */\n    (setattrofunc)cdata_setattro,               /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES, /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    cdata_richcompare,                          /* tp_richcompare */\n    offsetof(CDataObject, c_weakreflist),       /* tp_weaklistoffset */\n    (getiterfunc)cdata_iter,                    /* tp_iter */\n    0,                                          /* tp_iternext */\n    cdata_methods,                              /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    PyObject_Del,                               /* tp_free */\n};\n\nstatic PyTypeObject CDataOwning_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataOwn\",\n    sizeof(CDataObject),\n    0,\n    (destructor)cdataowning_dealloc,            /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdataowning_repr,                 /* tp_repr */\n    0,  /* inherited */                         /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    &CDataOwn_as_mapping,                       /* tp_as_mapping */\n    0,  /* inherited */                         /* tp_hash */\n    0,  /* inherited */                         /* tp_call */\n    0,                                          /* tp_str */\n    0,  /* inherited */                         /* tp_getattro */\n    0,  /* inherited */                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES, /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,  /* inherited */                         /* tp_richcompare */\n    0,  /* inherited */                         /* tp_weaklistoffset */\n    0,  /* inherited */                         /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,  /* inherited */                         /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CData_Type,                                /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    free,                                       /* tp_free */\n};\n\nstatic PyTypeObject CDataOwningGC_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataOwnGC\",\n    sizeof(CDataObject_own_structptr),\n    0,\n    (destructor)cdataowninggc_dealloc,          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdataowninggc_repr,               /* tp_repr */\n    0,  /* inherited */                         /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,  /* inherited */                         /* tp_as_mapping */\n    0,  /* inherited */                         /* tp_hash */\n    0,  /* inherited */                         /* tp_call */\n    0,                                          /* tp_str */\n    0,  /* inherited */                         /* tp_getattro */\n    0,  /* inherited */                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES  /* tp_flags */\n                       | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)cdataowninggc_traverse,       /* tp_traverse */\n    (inquiry)cdataowninggc_clear,               /* tp_clear */\n    0,  /* inherited */                         /* tp_richcompare */\n    0,  /* inherited */                         /* tp_weaklistoffset */\n    0,  /* inherited */                         /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,  /* inherited */                         /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CDataOwning_Type,                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    PyObject_GC_Del,                            /* tp_free */\n};\n\nstatic PyTypeObject CDataFromBuf_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataFromBuf\",\n    sizeof(CDataObject_frombuf),\n    0,\n    (destructor)cdatafrombuf_dealloc,           /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)cdatafrombuf_repr,                /* tp_repr */\n    0,  /* inherited */                         /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,  /* inherited */                         /* tp_as_mapping */\n    0,  /* inherited */                         /* tp_hash */\n    0,  /* inherited */                         /* tp_call */\n    0,                                          /* tp_str */\n    0,  /* inherited */                         /* tp_getattro */\n    0,  /* inherited */                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES  /* tp_flags */\n                       | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)cdatafrombuf_traverse,        /* tp_traverse */\n    (inquiry)cdatafrombuf_clear,                /* tp_clear */\n    0,  /* inherited */                         /* tp_richcompare */\n    0,  /* inherited */                         /* tp_weaklistoffset */\n    0,  /* inherited */                         /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,  /* inherited */                         /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CData_Type,                                /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    PyObject_GC_Del,                            /* tp_free */\n};\n\nstatic PyTypeObject CDataGCP_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataGCP\",\n    sizeof(CDataObject_gcp),\n    0,\n    (destructor)cdatagcp_dealloc,               /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,  /* inherited */                         /* tp_repr */\n    0,  /* inherited */                         /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,  /* inherited */                         /* tp_as_mapping */\n    0,  /* inherited */                         /* tp_hash */\n    0,  /* inherited */                         /* tp_call */\n    0,                                          /* tp_str */\n    0,  /* inherited */                         /* tp_getattro */\n    0,  /* inherited */                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES  /* tp_flags */\n#ifdef Py_TPFLAGS_HAVE_FINALIZE\n                       | Py_TPFLAGS_HAVE_FINALIZE\n#endif\n                       | Py_TPFLAGS_HAVE_GC,\n    0,                                          /* tp_doc */\n    (traverseproc)cdatagcp_traverse,            /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,  /* inherited */                         /* tp_richcompare */\n    0,  /* inherited */                         /* tp_weaklistoffset */\n    0,  /* inherited */                         /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,  /* inherited */                         /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    &CData_Type,                                /* tp_base */\n#ifdef Py_TPFLAGS_HAVE_FINALIZE  /* CPython >= 3.4 */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    0,  /* inherited */                         /* tp_free */\n    0,                                          /* tp_is_gc */\n    0,                                          /* tp_bases */\n    0,                                          /* tp_mro */\n    0,                                          /* tp_cache */\n    0,                                          /* tp_subclasses */\n    0,                                          /* tp_weaklist */\n    0,                                          /* tp_del */\n    0,                                          /* version_tag */\n    (destructor)cdatagcp_finalize,              /* tp_finalize */\n#endif\n};\n\n/************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    char *di_next, *di_stop;\n    CDataObject *di_object;\n    CTypeDescrObject *di_itemtype;\n} CDataIterObject;\n\nstatic PyObject *\ncdataiter_next(CDataIterObject *it)\n{\n    char *result = it->di_next;\n    if (result != it->di_stop) {\n        it->di_next = result + it->di_itemtype->ct_size;\n        return convert_to_object(result, it->di_itemtype);\n    }\n    return NULL;\n}\n\nstatic void\ncdataiter_dealloc(CDataIterObject *it)\n{\n    Py_DECREF(it->di_object);\n    PyObject_Del(it);\n}\n\nstatic PyTypeObject CDataIter_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.CDataIter\",              /* tp_name */\n    sizeof(CDataIterObject),                /* tp_basicsize */\n    0,                                      /* tp_itemsize */\n    /* methods */\n    (destructor)cdataiter_dealloc,          /* tp_dealloc */\n    0,                                      /* tp_print */\n    0,                                      /* tp_getattr */\n    0,                                      /* tp_setattr */\n    0,                                      /* tp_compare */\n    0,                                      /* tp_repr */\n    0,                                      /* tp_as_number */\n    0,                                      /* tp_as_sequence */\n    0,                                      /* tp_as_mapping */\n    0,                                      /* tp_hash */\n    0,                                      /* tp_call */\n    0,                                      /* tp_str */\n    PyObject_GenericGetAttr,                /* tp_getattro */\n    0,                                      /* tp_setattro */\n    0,                                      /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                     /* tp_flags */\n    0,                                      /* tp_doc */\n    0,                                      /* tp_traverse */\n    0,                                      /* tp_clear */\n    0,                                      /* tp_richcompare */\n    0,                                      /* tp_weaklistoffset */\n    PyObject_SelfIter,                      /* tp_iter */\n    (iternextfunc)cdataiter_next,           /* tp_iternext */\n};\n\nstatic PyObject *\ncdata_iter(CDataObject *cd)\n{\n    CDataIterObject *it;\n\n    if (!(cd->c_type->ct_flags & CT_ARRAY)) {\n        PyErr_Format(PyExc_TypeError, \"cdata '%s' does not support iteration\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n\n    it = PyObject_New(CDataIterObject, &CDataIter_Type);\n    if (it == NULL)\n        return NULL;\n\n    Py_INCREF(cd);\n    it->di_object = cd;\n    it->di_itemtype = cd->c_type->ct_itemdescr;\n    it->di_next = cd->c_data;\n    it->di_stop = cd->c_data + get_array_length(cd) * it->di_itemtype->ct_size;\n    return (PyObject *)it;\n}\n\n/************************************************************/\n\nstatic CDataObject *allocate_owning_object(Py_ssize_t size,\n                                           CTypeDescrObject *ct,\n                                           int dont_clear)\n{\n    /* note: objects with &CDataOwning_Type are always allocated with\n       either a plain malloc() or calloc(), and freed with free(). */\n    CDataObject *cd;\n    if (dont_clear)\n        cd = malloc(size);\n    else\n        cd = calloc(size, 1);\n    if (PyObject_Init((PyObject *)cd, &CDataOwning_Type) == NULL)\n        return NULL;\n\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_weakreflist = NULL;\n    return cd;\n}\n\nstatic PyObject *\nconvert_struct_to_owning_object(char *data, CTypeDescrObject *ct)\n{\n    /* also accepts unions, for the API mode */\n    CDataObject *cd;\n    Py_ssize_t dataoffset = offsetof(CDataObject_own_nolength, alignment);\n    Py_ssize_t datasize = ct->ct_size;\n\n    if (datasize < 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"return type is an opaque structure or union\");\n        return NULL;\n    }\n    if (ct->ct_flags & CT_WITH_VAR_ARRAY) {\n        PyErr_SetString(PyExc_TypeError,\n                  \"return type is a struct/union with a varsize array member\");\n        return NULL;\n    }\n    cd = allocate_owning_object(dataoffset + datasize, ct, /*dont_clear=*/1);\n    if (cd == NULL)\n        return NULL;\n    cd->c_data = ((char *)cd) + dataoffset;\n\n    memcpy(cd->c_data, data, datasize);\n    return (PyObject *)cd;\n}\n\nstatic CDataObject *allocate_gcp_object(CDataObject *origobj,\n                                        CTypeDescrObject *ct,\n                                        PyObject *destructor)\n{\n    CDataObject_gcp *cd = PyObject_GC_New(CDataObject_gcp, &CDataGCP_Type);\n    if (cd == NULL)\n        return NULL;\n\n    Py_XINCREF(destructor);\n    Py_INCREF(origobj);\n    Py_INCREF(ct);\n    cd->head.c_data = origobj->c_data;\n    cd->head.c_type = ct;\n    cd->head.c_weakreflist = NULL;\n    cd->origobj = (PyObject *)origobj;\n    cd->destructor = destructor;\n\n    PyObject_GC_Track(cd);\n    return (CDataObject *)cd;\n}\n\nstatic CDataObject *allocate_with_allocator(Py_ssize_t basesize,\n                                            Py_ssize_t datasize,\n                                            CTypeDescrObject *ct,\n                                            const cffi_allocator_t *allocator)\n{\n    CDataObject *cd;\n\n    if (allocator->ca_alloc == NULL) {\n        cd = allocate_owning_object(basesize + datasize, ct,\n                                    allocator->ca_dont_clear);\n        if (cd == NULL)\n            return NULL;\n        cd->c_data = ((char *)cd) + basesize;\n    }\n    else {\n        PyObject *res = PyObject_CallFunction(allocator->ca_alloc, \"n\", datasize);\n        if (res == NULL)\n            return NULL;\n\n        if (!CData_Check(res)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"alloc() must return a cdata object (got %.200s)\",\n                         Py_TYPE(res)->tp_name);\n            Py_DECREF(res);\n            return NULL;\n        }\n        cd = (CDataObject *)res;\n        if (!(cd->c_type->ct_flags & (CT_POINTER|CT_ARRAY))) {\n            PyErr_Format(PyExc_TypeError,\n                         \"alloc() must return a cdata pointer, not '%s'\",\n                         cd->c_type->ct_name);\n            Py_DECREF(res);\n            return NULL;\n        }\n        if (!cd->c_data) {\n            PyErr_SetString(PyExc_MemoryError, \"alloc() returned NULL\");\n            Py_DECREF(res);\n            return NULL;\n        }\n\n        cd = allocate_gcp_object(cd, ct, allocator->ca_free);\n        Py_DECREF(res);\n        if (!allocator->ca_dont_clear)\n            memset(cd->c_data, 0, datasize);\n    }\n    return cd;\n}\n\nstatic PyObject *direct_newp(CTypeDescrObject *ct, PyObject *init,\n                             const cffi_allocator_t *allocator)\n{\n    CTypeDescrObject *ctitem;\n    CDataObject *cd;\n    Py_ssize_t dataoffset, datasize, explicitlength;\n\n    explicitlength = -1;\n    if (ct->ct_flags & CT_POINTER) {\n        dataoffset = offsetof(CDataObject_own_nolength, alignment);\n        ctitem = ct->ct_itemdescr;\n        datasize = ctitem->ct_size;\n        if (datasize < 0) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot instantiate ctype '%s' of unknown size\",\n                         ctitem->ct_name);\n            return NULL;\n        }\n        if (ctitem->ct_flags & CT_PRIMITIVE_CHAR)\n            datasize *= 2;   /* forcefully add another character: a null */\n\n        if (ctitem->ct_flags & (CT_STRUCT | CT_UNION)) {\n            if (force_lazy_struct(ctitem) < 0)   /* for CT_WITH_VAR_ARRAY */\n                return NULL;\n\n            if (ctitem->ct_flags & CT_WITH_VAR_ARRAY) {\n                assert(ct->ct_flags & CT_IS_PTR_TO_OWNED);\n                dataoffset = offsetof(CDataObject_own_length, alignment);\n\n                if (init != Py_None) {\n                    Py_ssize_t optvarsize = datasize;\n                    if (convert_struct_from_object(NULL, ctitem, init,\n                                                   &optvarsize) < 0)\n                        return NULL;\n                    datasize = optvarsize;\n                }\n            }\n        }\n    }\n    else if (ct->ct_flags & CT_ARRAY) {\n        dataoffset = offsetof(CDataObject_own_nolength, alignment);\n        datasize = ct->ct_size;\n        if (datasize < 0) {\n            explicitlength = get_new_array_length(ct->ct_itemdescr, &init);\n            if (explicitlength < 0)\n                return NULL;\n            ctitem = ct->ct_itemdescr;\n            dataoffset = offsetof(CDataObject_own_length, alignment);\n            datasize = MUL_WRAPAROUND(explicitlength, ctitem->ct_size);\n            if (explicitlength > 0 &&\n                    (datasize / explicitlength) != ctitem->ct_size) {\n                PyErr_SetString(PyExc_OverflowError,\n                                \"array size would overflow a Py_ssize_t\");\n                return NULL;\n            }\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array ctype, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n    if (ct->ct_flags & CT_IS_PTR_TO_OWNED) {\n        /* common case of ptr-to-struct (or ptr-to-union): for this case\n           we build two objects instead of one, with the memory-owning\n           one being really the struct (or union) and the returned one\n           having a strong reference to it */\n        CDataObject *cds;\n\n        cds = allocate_with_allocator(dataoffset, datasize, ct->ct_itemdescr,\n                                      allocator);\n        if (cds == NULL)\n            return NULL;\n\n        cd = allocate_owning_object(sizeof(CDataObject_own_structptr), ct,\n                                    /*dont_clear=*/1);\n        if (cd == NULL) {\n            Py_DECREF(cds);\n            return NULL;\n        }\n        /* store the only reference to cds into cd */\n        ((CDataObject_own_structptr *)cd)->structobj = (PyObject *)cds;\n        /* store information about the allocated size of the struct */\n        if (dataoffset == offsetof(CDataObject_own_length, alignment)) {\n            ((CDataObject_own_length *)cds)->length = datasize;\n        }\n        assert(explicitlength < 0);\n\n        cd->c_data = cds->c_data;\n    }\n    else {\n        cd = allocate_with_allocator(dataoffset, datasize, ct, allocator);\n        if (cd == NULL)\n            return NULL;\n\n        if (explicitlength >= 0)\n            ((CDataObject_own_length*)cd)->length = explicitlength;\n    }\n\n    if (init != Py_None) {\n        if (convert_from_object(cd->c_data,\n              (ct->ct_flags & CT_POINTER) ? ct->ct_itemdescr : ct, init) < 0) {\n            Py_DECREF(cd);\n            return NULL;\n        }\n    }\n    return (PyObject *)cd;\n}\n\nstatic PyObject *b_newp(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *init = Py_None;\n    if (!PyArg_ParseTuple(args, \"O!|O:newp\", &CTypeDescr_Type, &ct, &init))\n        return NULL;\n    return direct_newp(ct, init, &default_allocator);\n}\n\nstatic int\n_my_PyObject_AsBool(PyObject *ob)\n{\n    /* convert and cast a Python object to a boolean.  Accept an integer\n       or a float object, up to a CData 'long double'. */\n    PyObject *io;\n    PyNumberMethods *nb;\n    int res;\n\n#if PY_MAJOR_VERSION < 3\n    if (PyInt_Check(ob)) {\n        return PyInt_AS_LONG(ob) != 0;\n    }\n    else\n#endif\n    if (PyLong_Check(ob)) {\n        return _PyLong_Sign(ob) != 0;\n    }\n    else if (PyFloat_Check(ob)) {\n        return PyFloat_AS_DOUBLE(ob) != 0.0;\n    }\n    else if (CData_Check(ob)) {\n        CDataObject *cd = (CDataObject *)ob;\n        if (cd->c_type->ct_flags & CT_PRIMITIVE_FLOAT) {\n            /*READ(cd->c_data, cd->c_type->ct_size)*/\n            if (cd->c_type->ct_flags & CT_IS_LONGDOUBLE) {\n                /* 'long double' objects: return the answer directly */\n                return read_raw_longdouble_data(cd->c_data) != 0.0;\n            }\n            else {\n                /* 'float'/'double' objects: return the answer directly */\n                return read_raw_float_data(cd->c_data,\n                                           cd->c_type->ct_size) != 0.0;\n            }\n        }\n    }\n    nb = ob->ob_type->tp_as_number;\n    if (nb == NULL || (nb->nb_float == NULL && nb->nb_int == NULL)) {\n        PyErr_SetString(PyExc_TypeError, \"integer/float expected\");\n        return -1;\n    }\n    if (nb->nb_float && !CData_Check(ob))\n        io = (*nb->nb_float) (ob);\n    else\n        io = (*nb->nb_int) (ob);\n    if (io == NULL)\n        return -1;\n\n    if (PyIntOrLong_Check(io) || PyFloat_Check(io)) {\n        res = _my_PyObject_AsBool(io);\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError, \"integer/float conversion failed\");\n        res = -1;\n    }\n    Py_DECREF(io);\n    return res;\n}\n\nstatic CDataObject *_new_casted_primitive(CTypeDescrObject *ct)\n{\n    int dataoffset = offsetof(CDataObject_casted_primitive, alignment);\n    CDataObject *cd = (CDataObject *)PyObject_Malloc(dataoffset + ct->ct_size);\n    if (PyObject_Init((PyObject *)cd, &CData_Type) == NULL)\n        return NULL;\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_data = ((char*)cd) + dataoffset;\n    cd->c_weakreflist = NULL;\n    return cd;\n}\n\nstatic CDataObject *cast_to_integer_or_char(CTypeDescrObject *ct, PyObject *ob)\n{\n    unsigned PY_LONG_LONG value;\n    CDataObject *cd;\n\n    if (CData_Check(ob) &&\n        ((CDataObject *)ob)->c_type->ct_flags &\n                                 (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY)) {\n        value = (Py_intptr_t)((CDataObject *)ob)->c_data;\n    }\n#if PY_MAJOR_VERSION < 3\n    else if (PyString_Check(ob)) {\n        if (PyString_GET_SIZE(ob) != 1) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot cast string of length %zd to ctype '%s'\",\n                         PyString_GET_SIZE(ob), ct->ct_name);\n            return NULL;\n        }\n        value = (unsigned char)PyString_AS_STRING(ob)[0];\n    }\n#endif\n    else if (PyUnicode_Check(ob)) {\n        char err_buf[80];\n        cffi_char32_t ordinal;\n        if (_my_PyUnicode_AsSingleChar32(ob, &ordinal, err_buf) < 0) {\n            PyErr_Format(PyExc_TypeError,\n                         \"cannot cast %s to ctype '%s'\", err_buf, ct->ct_name);\n            return NULL;\n        }\n        /* the types char16_t and char32_t are both unsigned.  However,\n           wchar_t might be signed.  In theory it does not matter,\n           because 'ordinal' comes from a regular Python unicode. */\n#ifdef HAVE_WCHAR_H\n        if (ct->ct_flags & CT_IS_SIGNED_WCHAR)\n            value = (wchar_t)ordinal;\n        else\n#endif\n            value = ordinal;\n    }\n    else if (PyBytes_Check(ob)) {\n        int res = _convert_to_char(ob);\n        if (res < 0)\n            return NULL;\n        value = (unsigned char)res;\n    }\n    else if (ct->ct_flags & CT_IS_BOOL) {\n        int res = _my_PyObject_AsBool(ob);\n        if (res < 0)\n            return NULL;\n        value = res;\n    }\n    else {\n        value = _my_PyLong_AsUnsignedLongLong(ob, 0);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return NULL;\n    }\n    if (ct->ct_flags & CT_IS_BOOL)\n        value = !!value;\n    cd = _new_casted_primitive(ct);\n    if (cd != NULL)\n        write_raw_integer_data(cd->c_data, value, ct->ct_size);\n    return cd;\n}\n\n/* returns -1 if cannot cast, 0 if we don't get a value, 1 if we do */\nstatic int check_bytes_for_float_compatible(PyObject *io, double *out_value)\n{\n    if (PyBytes_Check(io)) {\n        if (PyBytes_GET_SIZE(io) != 1)\n            goto error;\n        *out_value = (unsigned char)PyBytes_AS_STRING(io)[0];\n        return 1;\n    }\n    else if (PyUnicode_Check(io)) {\n        char ignored[80];\n        cffi_char32_t ordinal;\n        if (_my_PyUnicode_AsSingleChar32(io, &ordinal, ignored) < 0)\n            goto error;\n        /* the signness of the 32-bit version of wide chars should not\n         * matter here, because 'ordinal' comes from a normal Python\n         * unicode string */\n        *out_value = ordinal;\n        return 1;\n    }\n    *out_value = 0;   /* silence a gcc warning if this function is inlined */\n    return 0;\n\n error:\n    Py_DECREF(io);\n    *out_value = 0;   /* silence a gcc warning if this function is inlined */\n    return -1;\n}\n\nstatic PyObject *do_cast(CTypeDescrObject *ct, PyObject *ob)\n{\n    CDataObject *cd;\n\n    if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY) &&\n        ct->ct_size >= 0) {\n        /* cast to a pointer, to a funcptr, or to an array.\n           Note that casting to an array is an extension to the C language,\n           which seems to be necessary in order to sanely get a\n           <cdata 'int[3]'> at some address. */\n        unsigned PY_LONG_LONG value;\n\n        if (CData_Check(ob)) {\n            CDataObject *cdsrc = (CDataObject *)ob;\n            if (cdsrc->c_type->ct_flags &\n                    (CT_POINTER|CT_FUNCTIONPTR|CT_ARRAY)) {\n                return new_simple_cdata(cdsrc->c_data, ct);\n            }\n        }\n        if ((ct->ct_flags & CT_POINTER) &&\n                (ct->ct_itemdescr->ct_flags & CT_IS_FILE) &&\n                PyFile_Check(ob)) {\n            FILE *f = PyFile_AsFile(ob);\n            if (f == NULL && PyErr_Occurred())\n                return NULL;\n            return new_simple_cdata((char *)f, ct);\n        }\n        value = _my_PyLong_AsUnsignedLongLong(ob, 0);\n        if (value == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())\n            return NULL;\n        return new_simple_cdata((char *)(Py_intptr_t)value, ct);\n    }\n    else if (ct->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED\n                             |CT_PRIMITIVE_CHAR)) {\n        /* cast to an integer type or a char */\n        return (PyObject *)cast_to_integer_or_char(ct, ob);\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_FLOAT) {\n        /* cast to a float */\n        double value;\n        PyObject *io;\n        int res;\n\n        if (CData_Check(ob)) {\n            CDataObject *cdsrc = (CDataObject *)ob;\n\n            if (!(cdsrc->c_type->ct_flags & CT_PRIMITIVE_ANY))\n                goto cannot_cast;\n            io = convert_to_object(cdsrc->c_data, cdsrc->c_type);\n            if (io == NULL)\n                return NULL;\n        }\n        else {\n            io = ob;\n            Py_INCREF(io);\n        }\n\n        res = check_bytes_for_float_compatible(io, &value);\n        if (res == -1)\n            goto cannot_cast;\n        if (res == 0) {\n            if ((ct->ct_flags & CT_IS_LONGDOUBLE) &&\n                 CData_Check(io) &&\n                 (((CDataObject *)io)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n                long double lvalue;\n                char *data = ((CDataObject *)io)->c_data;\n                /*READ(data, sizeof(long double)*/\n                lvalue = read_raw_longdouble_data(data);\n                Py_DECREF(io);\n                cd = _new_casted_primitive(ct);\n                if (cd != NULL)\n                    write_raw_longdouble_data(cd->c_data, lvalue);\n                return (PyObject *)cd;\n            }\n            value = PyFloat_AsDouble(io);\n        }\n        Py_DECREF(io);\n        if (value == -1.0 && PyErr_Occurred())\n            return NULL;\n\n        cd = _new_casted_primitive(ct);\n        if (cd != NULL) {\n            if (!(ct->ct_flags & CT_IS_LONGDOUBLE))\n                write_raw_float_data(cd->c_data, value, ct->ct_size);\n            else\n                write_raw_longdouble_data(cd->c_data, (long double)value);\n        }\n        return (PyObject *)cd;\n    }\n    else if (ct->ct_flags & CT_PRIMITIVE_COMPLEX) {\n        /* cast to a complex */\n        Py_complex value;\n        PyObject *io;\n        int res;\n\n        if (CData_Check(ob)) {\n            CDataObject *cdsrc = (CDataObject *)ob;\n\n            if (!(cdsrc->c_type->ct_flags & CT_PRIMITIVE_ANY))\n                goto cannot_cast;\n            io = convert_to_object(cdsrc->c_data, cdsrc->c_type);\n            if (io == NULL)\n                return NULL;\n        }\n        else {\n            io = ob;\n            Py_INCREF(io);\n        }\n\n        res = check_bytes_for_float_compatible(io, &value.real);\n        if (res == -1)\n            goto cannot_cast;\n        if (res == 1) {\n            // got it from string\n            value.imag = 0.0;\n        } else {\n            value = PyComplex_AsCComplex(io);\n        }\n        Py_DECREF(io);\n        if (PyErr_Occurred()) {\n            return NULL;\n        }\n        cd = _new_casted_primitive(ct);\n        if (cd != NULL) {\n            write_raw_complex_data(cd->c_data, value, ct->ct_size);\n        }\n        return (PyObject *)cd;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError, \"cannot cast to ctype '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n cannot_cast:\n    if (CData_Check(ob))\n        PyErr_Format(PyExc_TypeError, \"cannot cast ctype '%s' to ctype '%s'\",\n                     ((CDataObject *)ob)->c_type->ct_name, ct->ct_name);\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"cannot cast %.200s object to ctype '%s'\",\n                     Py_TYPE(ob)->tp_name, ct->ct_name);\n    return NULL;\n}\n\nstatic PyObject *b_cast(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *ob;\n    if (!PyArg_ParseTuple(args, \"O!O:cast\", &CTypeDescr_Type, &ct, &ob))\n        return NULL;\n\n    return do_cast(ct, ob);\n}\n\n/************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    void *dl_handle;\n    char *dl_name;\n} DynLibObject;\n\nstatic void dl_dealloc(DynLibObject *dlobj)\n{\n    if (dlobj->dl_handle != NULL)\n        dlclose(dlobj->dl_handle);\n    free(dlobj->dl_name);\n    PyObject_Del(dlobj);\n}\n\nstatic PyObject *dl_repr(DynLibObject *dlobj)\n{\n    return PyText_FromFormat(\"<clibrary '%s'>\", dlobj->dl_name);\n}\n\nstatic int dl_check_closed(DynLibObject *dlobj)\n{\n    if (dlobj->dl_handle == NULL)\n    {\n        PyErr_Format(PyExc_ValueError, \"library '%s' has already been closed\",\n                     dlobj->dl_name);\n        return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *dl_load_function(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *funcname;\n    void *funcptr;\n\n    if (!PyArg_ParseTuple(args, \"O!s:load_function\",\n                          &CTypeDescr_Type, &ct, &funcname))\n        return NULL;\n\n    if (dl_check_closed(dlobj) < 0)\n        return NULL;\n\n    if (!(ct->ct_flags & (CT_FUNCTIONPTR | CT_POINTER | CT_ARRAY))) {\n        PyErr_Format(PyExc_TypeError,\n                     \"function or pointer or array cdata expected, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n    dlerror();   /* clear error condition */\n    funcptr = dlsym(dlobj->dl_handle, funcname);\n    if (funcptr == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_AttributeError,\n                     \"function/symbol '%s' not found in library '%s': %s\",\n                     funcname, dlobj->dl_name, error);\n        return NULL;\n    }\n\n    if ((ct->ct_flags & CT_ARRAY) && ct->ct_length < 0) {\n        ct = (CTypeDescrObject *)ct->ct_stuff;\n    }\n    return new_simple_cdata(funcptr, ct);\n}\n\nstatic PyObject *dl_read_variable(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *varname;\n    char *data;\n\n    if (!PyArg_ParseTuple(args, \"O!s:read_variable\",\n                          &CTypeDescr_Type, &ct, &varname))\n        return NULL;\n\n    if (dl_check_closed(dlobj) < 0)\n        return NULL;\n\n    dlerror();   /* clear error condition */\n    data = dlsym(dlobj->dl_handle, varname);\n    if (data == NULL) {\n        const char *error = dlerror();\n        if (error != NULL) {\n            PyErr_Format(PyExc_KeyError,\n                         \"variable '%s' not found in library '%s': %s\",\n                         varname, dlobj->dl_name, error);\n            return NULL;\n        }\n    }\n    return convert_to_object(data, ct);\n}\n\nstatic PyObject *dl_write_variable(DynLibObject *dlobj, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *value;\n    char *varname;\n    char *data;\n\n    if (!PyArg_ParseTuple(args, \"O!sO:write_variable\",\n                          &CTypeDescr_Type, &ct, &varname, &value))\n        return NULL;\n\n    if (dl_check_closed(dlobj) < 0)\n        return NULL;\n\n    dlerror();   /* clear error condition */\n    data = dlsym(dlobj->dl_handle, varname);\n    if (data == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_KeyError,\n                     \"variable '%s' not found in library '%s': %s\",\n                     varname, dlobj->dl_name, error);\n        return NULL;\n    }\n    if (convert_from_object(data, ct, value) < 0)\n        return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *dl_close_lib(DynLibObject *dlobj, PyObject *no_args)\n{\n    if (dlobj->dl_handle != NULL)\n    {\n        dlclose(dlobj->dl_handle);\n        dlobj->dl_handle = NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyMethodDef dl_methods[] = {\n    {\"load_function\",   (PyCFunction)dl_load_function,  METH_VARARGS},\n    {\"read_variable\",   (PyCFunction)dl_read_variable,  METH_VARARGS},\n    {\"write_variable\",  (PyCFunction)dl_write_variable, METH_VARARGS},\n    {\"close_lib\",       (PyCFunction)dl_close_lib,      METH_NOARGS},\n    {NULL,              NULL}           /* sentinel */\n};\n\nstatic PyTypeObject dl_type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_cffi_backend.Library\",            /* tp_name */\n    sizeof(DynLibObject),               /* tp_basicsize */\n    0,                                  /* tp_itemsize */\n    /* methods */\n    (destructor)dl_dealloc,             /* tp_dealloc */\n    0,                                  /* tp_print */\n    0,                                  /* tp_getattr */\n    0,                                  /* tp_setattr */\n    0,                                  /* tp_compare */\n    (reprfunc)dl_repr,                  /* tp_repr */\n    0,                                  /* tp_as_number */\n    0,                                  /* tp_as_sequence */\n    0,                                  /* tp_as_mapping */\n    0,                                  /* tp_hash */\n    0,                                  /* tp_call */\n    0,                                  /* tp_str */\n    PyObject_GenericGetAttr,            /* tp_getattro */\n    0,                                  /* tp_setattro */\n    0,                                  /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                 /* tp_flags */\n    0,                                  /* tp_doc */\n    0,                                  /* tp_traverse */\n    0,                                  /* tp_clear */\n    0,                                  /* tp_richcompare */\n    0,                                  /* tp_weaklistoffset */\n    0,                                  /* tp_iter */\n    0,                                  /* tp_iternext */\n    dl_methods,                         /* tp_methods */\n};\n\nstatic void *b_do_dlopen(PyObject *args, const char **p_printable_filename,\n                         PyObject **p_temp)\n{\n    /* Logic to call the correct version of dlopen().  Returns NULL in case of error.\n       Otherwise, '*p_printable_filename' will point to a printable char version of\n       the filename (maybe utf-8-encoded).  '*p_temp' will be set either to NULL or\n       to a temporary object that must be freed after looking at printable_filename.\n    */\n    void *handle;\n    char *filename_or_null;\n    int flags = 0;\n    *p_temp = NULL;\n    \n    if (PyTuple_GET_SIZE(args) == 0 || PyTuple_GET_ITEM(args, 0) == Py_None) {\n        PyObject *dummy;\n        if (!PyArg_ParseTuple(args, \"|Oi:load_library\",\n                              &dummy, &flags))\n            return NULL;\n        filename_or_null = NULL;\n        *p_printable_filename = \"<None>\";\n    }\n    else\n    {\n        PyObject *s = PyTuple_GET_ITEM(args, 0);\n#ifdef MS_WIN32\n        Py_UNICODE *filenameW;\n        if (PyArg_ParseTuple(args, \"u|i:load_library\", &filenameW, &flags))\n        {\n#if PY_MAJOR_VERSION < 3\n            s = PyUnicode_AsUTF8String(s);\n            if (s == NULL)\n                return NULL;\n            *p_temp = s;\n#endif\n            *p_printable_filename = PyText_AsUTF8(s);\n            if (*p_printable_filename == NULL)\n                return NULL;\n\n            handle = dlopenW(filenameW);\n            goto got_handle;\n        }\n        PyErr_Clear();\n#endif\n        if (!PyArg_ParseTuple(args, \"et|i:load_library\",\n                     Py_FileSystemDefaultEncoding, &filename_or_null, &flags))\n            return NULL;\n#if PY_MAJOR_VERSION < 3\n        if (PyUnicode_Check(s))\n        {\n            s = PyUnicode_AsUTF8String(s);\n            if (s == NULL)\n                return NULL;\n            *p_temp = s;\n        }\n#endif\n        *p_printable_filename = PyText_AsUTF8(s);\n        if (*p_printable_filename == NULL)\n            return NULL;\n    }\n    if ((flags & (RTLD_NOW | RTLD_LAZY)) == 0)\n        flags |= RTLD_NOW;\n\n    handle = dlopen(filename_or_null, flags);\n\n#ifdef MS_WIN32\n  got_handle:\n#endif\n    if (handle == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(PyExc_OSError, \"cannot load library '%s': %s\",\n                     *p_printable_filename, error);\n        return NULL;\n    }\n    return handle;\n}\n\nstatic PyObject *b_load_library(PyObject *self, PyObject *args)\n{\n    const char *printable_filename;\n    PyObject *temp;\n    void *handle;\n    DynLibObject *dlobj = NULL;\n\n    handle = b_do_dlopen(args, &printable_filename, &temp);\n    if (handle == NULL)\n        goto error;\n\n    dlobj = PyObject_New(DynLibObject, &dl_type);\n    if (dlobj == NULL) {\n        dlclose(handle);\n        goto error;\n    }\n    dlobj->dl_handle = handle;\n    dlobj->dl_name = strdup(printable_filename);\n \n error:\n    Py_XDECREF(temp);\n    return (PyObject *)dlobj;\n}\n\n/************************************************************/\n\nstatic PyObject *get_unique_type(CTypeDescrObject *x,\n                                 const void *unique_key[], long keylength)\n{\n    /* Replace the CTypeDescrObject 'x' with a standardized one.\n       This either just returns x, or x is decrefed and a new reference\n       to the already-existing equivalent is returned.\n\n       In this function, 'x' always contains a reference that must be\n       either decrefed or returned.\n\n       Keys:\n           void       [\"void\"]\n           primitive  [&static_struct]\n           pointer    [ctype]\n           array      [ctype, length]\n           funcptr    [ctresult, ellipsis+abi, num_args, ctargs...]\n    */\n    PyObject *key, *y;\n    void *pkey;\n\n    key = PyBytes_FromStringAndSize(NULL, keylength * sizeof(void *));\n    if (key == NULL)\n        goto error;\n\n    pkey = PyBytes_AS_STRING(key);\n    memcpy(pkey, unique_key, keylength * sizeof(void *));\n\n    y = PyDict_GetItem(unique_cache, key);\n    if (y != NULL) {\n        Py_DECREF(key);\n        Py_INCREF(y);\n        Py_DECREF(x);\n        return y;\n    }\n    if (PyDict_SetItem(unique_cache, key, (PyObject *)x) < 0) {\n        Py_DECREF(key);\n        goto error;\n    }\n    /* Haaaack for our reference count hack: gcmodule.c must not see this\n       dictionary.  The problem is that any PyDict_SetItem() notices that\n       'x' is tracked and re-tracks the unique_cache dictionary.  So here\n       we re-untrack it again... */\n    PyObject_GC_UnTrack(unique_cache);\n\n    assert(x->ct_unique_key == NULL);\n    x->ct_unique_key = key; /* the key will be freed in ctypedescr_dealloc() */\n    /* the 'value' in unique_cache doesn't count as 1, but don't use\n       Py_DECREF(x) here because it will confuse debug builds into thinking\n       there was an extra DECREF in total. */\n    ((PyObject *)x)->ob_refcnt--;\n    return (PyObject *)x;\n\n error:\n    Py_DECREF(x);\n    return NULL;\n}\n\n/* according to the C standard, these types should be equivalent to the\n   _Complex types for the purposes of storage (not arguments in calls!) */\ntypedef float cffi_float_complex_t[2];\ntypedef double cffi_double_complex_t[2];\n\nstatic PyObject *new_primitive_type(const char *name)\n{\n#define ENUM_PRIMITIVE_TYPES                                    \\\n       EPTYPE(c, char, CT_PRIMITIVE_CHAR)                       \\\n       EPTYPE(s, short, CT_PRIMITIVE_SIGNED )                   \\\n       EPTYPE(i, int, CT_PRIMITIVE_SIGNED )                     \\\n       EPTYPE(l, long, CT_PRIMITIVE_SIGNED )                    \\\n       EPTYPE(ll, long long, CT_PRIMITIVE_SIGNED )              \\\n       EPTYPE(sc, signed char, CT_PRIMITIVE_SIGNED )            \\\n       EPTYPE(uc, unsigned char, CT_PRIMITIVE_UNSIGNED )        \\\n       EPTYPE(us, unsigned short, CT_PRIMITIVE_UNSIGNED )       \\\n       EPTYPE(ui, unsigned int, CT_PRIMITIVE_UNSIGNED )         \\\n       EPTYPE(ul, unsigned long, CT_PRIMITIVE_UNSIGNED )        \\\n       EPTYPE(ull, unsigned long long, CT_PRIMITIVE_UNSIGNED )  \\\n       EPTYPE(f, float, CT_PRIMITIVE_FLOAT )                    \\\n       EPTYPE(d, double, CT_PRIMITIVE_FLOAT )                   \\\n       EPTYPE(ld, long double, CT_PRIMITIVE_FLOAT | CT_IS_LONGDOUBLE ) \\\n       EPTYPE2(fc, \"float _Complex\", cffi_float_complex_t, CT_PRIMITIVE_COMPLEX ) \\\n       EPTYPE2(dc, \"double _Complex\", cffi_double_complex_t, CT_PRIMITIVE_COMPLEX ) \\\n       ENUM_PRIMITIVE_TYPES_WCHAR                               \\\n       EPTYPE2(c16, \"char16_t\", cffi_char16_t, CT_PRIMITIVE_CHAR ) \\\n       EPTYPE2(c32, \"char32_t\", cffi_char32_t, CT_PRIMITIVE_CHAR ) \\\n       EPTYPE(b, _Bool, CT_PRIMITIVE_UNSIGNED | CT_IS_BOOL )    \\\n     /* the following types are not primitive in the C sense */ \\\n       EPTYPE(i8, int8_t, CT_PRIMITIVE_SIGNED)                  \\\n       EPTYPE(u8, uint8_t, CT_PRIMITIVE_UNSIGNED)               \\\n       EPTYPE(i16, int16_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u16, uint16_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(i32, int32_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u32, uint32_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(i64, int64_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(u64, uint64_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(il8, int_least8_t, CT_PRIMITIVE_SIGNED)           \\\n       EPTYPE(ul8, uint_least8_t, CT_PRIMITIVE_UNSIGNED)        \\\n       EPTYPE(il16, int_least16_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul16, uint_least16_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(il32, int_least32_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul32, uint_least32_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(il64, int_least64_t, CT_PRIMITIVE_SIGNED)         \\\n       EPTYPE(ul64, uint_least64_t, CT_PRIMITIVE_UNSIGNED)      \\\n       EPTYPE(if8, int_fast8_t, CT_PRIMITIVE_SIGNED)            \\\n       EPTYPE(uf8, uint_fast8_t, CT_PRIMITIVE_UNSIGNED)         \\\n       EPTYPE(if16, int_fast16_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf16, uint_fast16_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(if32, int_fast32_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf32, uint_fast32_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(if64, int_fast64_t, CT_PRIMITIVE_SIGNED)          \\\n       EPTYPE(uf64, uint_fast64_t, CT_PRIMITIVE_UNSIGNED)       \\\n       EPTYPE(ip, intptr_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(up, uintptr_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(im, intmax_t, CT_PRIMITIVE_SIGNED)                \\\n       EPTYPE(um, uintmax_t, CT_PRIMITIVE_UNSIGNED)             \\\n       EPTYPE(pd, ptrdiff_t, CT_PRIMITIVE_SIGNED)               \\\n       EPTYPE(sz, size_t, CT_PRIMITIVE_UNSIGNED)                \\\n       EPTYPE2(ssz, \"ssize_t\", Py_ssize_t, CT_PRIMITIVE_SIGNED)\n\n#ifdef HAVE_WCHAR_H\n# define ENUM_PRIMITIVE_TYPES_WCHAR                             \\\n       EPTYPE(wc, wchar_t, CT_PRIMITIVE_CHAR |                  \\\n                           (((wchar_t)-1) > 0 ? 0 : CT_IS_SIGNED_WCHAR))\n#else\n# define ENUM_PRIMITIVE_TYPES_WCHAR   /* nothing */\n#endif\n\n#define EPTYPE(code, typename, flags)  EPTYPE2(code, #typename, typename, flags)\n\n#define EPTYPE2(code, export_name, typename, flags)     \\\n    struct aligncheck_##code { char x; typename y; };\n    ENUM_PRIMITIVE_TYPES\n#undef EPTYPE2\n\n    CTypeDescrObject *td;\n    static const struct descr_s { const char *name; int size, align, flags; }\n    types[] = {\n#define EPTYPE2(code, export_name, typename, flags)     \\\n        { export_name,                                  \\\n          sizeof(typename),                             \\\n          offsetof(struct aligncheck_##code, y),        \\\n          flags                                         \\\n        },\n    ENUM_PRIMITIVE_TYPES\n#undef EPTYPE2\n#undef EPTYPE\n#undef ENUM_PRIMITIVE_TYPES_WCHAR\n#undef ENUM_PRIMITIVE_TYPES\n        { NULL }\n    };\n    const struct descr_s *ptypes;\n    const void *unique_key[1];\n    int name_size;\n    ffi_type *ffitype;\n\n    for (ptypes=types; ; ptypes++) {\n        if (ptypes->name == NULL) {\n#ifndef HAVE_WCHAR_H\n            if (strcmp(name, \"wchar_t\"))\n                PyErr_SetString(PyExc_NotImplementedError, name);\n            else\n#endif\n            PyErr_SetString(PyExc_KeyError, name);\n            return NULL;\n        }\n        if (strcmp(name, ptypes->name) == 0)\n            break;\n    }\n\n    if (ptypes->flags & CT_PRIMITIVE_SIGNED) {\n        switch (ptypes->size) {\n        case 1: ffitype = &ffi_type_sint8; break;\n        case 2: ffitype = &ffi_type_sint16; break;\n        case 4: ffitype = &ffi_type_sint32; break;\n        case 8: ffitype = &ffi_type_sint64; break;\n        default: goto bad_ffi_type;\n        }\n    }\n    else if (ptypes->flags & CT_PRIMITIVE_FLOAT) {\n        if (strcmp(ptypes->name, \"float\") == 0)\n            ffitype = &ffi_type_float;\n        else if (strcmp(ptypes->name, \"double\") == 0)\n            ffitype = &ffi_type_double;\n        else if (strcmp(ptypes->name, \"long double\") == 0) {\n            /* assume that if sizeof(double) == sizeof(long double), then\n               the two types are equivalent for C.  libffi bugs on Win64\n               if a function's return type is ffi_type_longdouble... */\n            if (sizeof(double) == sizeof(long double))\n                ffitype = &ffi_type_double;\n            else\n                ffitype = &ffi_type_longdouble;\n        }\n        else\n            goto bad_ffi_type;\n    }\n    else if (ptypes->flags & CT_PRIMITIVE_COMPLEX) {\n        /* As of March 2017, still no libffi support for complex.\n           It fails silently if we try to use ffi_type_complex_float\n           or ffi_type_complex_double.  Better not use it at all.\n         */\n        ffitype = NULL;\n    }\n    else {\n        switch (ptypes->size) {\n        case 1: ffitype = &ffi_type_uint8; break;\n        case 2: ffitype = &ffi_type_uint16; break;\n        case 4: ffitype = &ffi_type_uint32; break;\n        case 8: ffitype = &ffi_type_uint64; break;\n        default: goto bad_ffi_type;\n        }\n    }\n\n    name_size = strlen(ptypes->name) + 1;\n    td = ctypedescr_new(name_size);\n    if (td == NULL)\n        return NULL;\n\n    memcpy(td->ct_name, name, name_size);\n    td->ct_size = ptypes->size;\n    td->ct_length = ptypes->align;\n    td->ct_extra = ffitype;\n    td->ct_flags = ptypes->flags;\n    if (td->ct_flags & (CT_PRIMITIVE_SIGNED | CT_PRIMITIVE_CHAR)) {\n        if (td->ct_size <= (Py_ssize_t)sizeof(long))\n            td->ct_flags |= CT_PRIMITIVE_FITS_LONG;\n    }\n    else if (td->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n        if (td->ct_size < (Py_ssize_t)sizeof(long))\n            td->ct_flags |= CT_PRIMITIVE_FITS_LONG;\n    }\n    td->ct_name_position = strlen(td->ct_name);\n    unique_key[0] = ptypes;\n    return get_unique_type(td, unique_key, 1);\n\n bad_ffi_type:\n    PyErr_Format(PyExc_NotImplementedError,\n                 \"primitive type '%s' has size %d; \"\n                 \"the supported sizes are 1, 2, 4, 8\",\n                 name, (int)ptypes->size);\n    return NULL;\n}\n\nstatic PyObject *b_new_primitive_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    if (!PyArg_ParseTuple(args, \"s:new_primitive_type\", &name))\n        return NULL;\n    return new_primitive_type(name);\n}\n\nstatic PyObject *new_pointer_type(CTypeDescrObject *ctitem)\n{\n    CTypeDescrObject *td;\n    const char *extra;\n    const void *unique_key[1];\n\n    if (ctitem->ct_flags & CT_ARRAY)\n        extra = \"(*)\";   /* obscure case: see test_array_add */\n    else\n        extra = \" *\";\n    td = ctypedescr_new_on_top(ctitem, extra, 2);\n    if (td == NULL)\n        return NULL;\n\n    td->ct_size = sizeof(void *);\n    td->ct_length = -1;\n    td->ct_flags = CT_POINTER;\n    if (ctitem->ct_flags & (CT_STRUCT|CT_UNION))\n        td->ct_flags |= CT_IS_PTR_TO_OWNED;\n    if (ctitem->ct_flags & CT_VOID)\n        td->ct_flags |= CT_IS_VOID_PTR;\n    if ((ctitem->ct_flags & CT_VOID) ||\n        ((ctitem->ct_flags & CT_PRIMITIVE_CHAR) &&\n         ctitem->ct_size == sizeof(char)))\n        td->ct_flags |= CT_IS_VOIDCHAR_PTR;   /* 'void *' or 'char *' only */\n    unique_key[0] = ctitem;\n    return get_unique_type(td, unique_key, 1);\n}\n\nstatic PyObject *b_new_pointer_type(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ctitem;\n    if (!PyArg_ParseTuple(args, \"O!:new_pointer_type\",\n                          &CTypeDescr_Type, &ctitem))\n        return NULL;\n    return new_pointer_type(ctitem);\n}\n\nstatic PyObject *b_new_array_type(PyObject *self, PyObject *args)\n{\n    PyObject *lengthobj;\n    Py_ssize_t length;\n    CTypeDescrObject *ctptr;\n\n    if (!PyArg_ParseTuple(args, \"O!O:new_array_type\",\n                          &CTypeDescr_Type, &ctptr, &lengthobj))\n        return NULL;\n\n    if (lengthobj == Py_None) {\n        length = -1;\n    }\n    else {\n        length = PyNumber_AsSsize_t(lengthobj, PyExc_OverflowError);\n        if (length < 0) {\n            if (!PyErr_Occurred())\n                PyErr_SetString(PyExc_ValueError, \"negative array length\");\n            return NULL;\n        }\n    }\n    return new_array_type(ctptr, length);\n}\n\nstatic PyObject *\nnew_array_type(CTypeDescrObject *ctptr, Py_ssize_t length)\n{\n    CTypeDescrObject *td, *ctitem;\n    char extra_text[32];\n    Py_ssize_t arraysize;\n    int flags = CT_ARRAY;\n    const void *unique_key[2];\n\n    if (!(ctptr->ct_flags & CT_POINTER)) {\n        PyErr_SetString(PyExc_TypeError, \"first arg must be a pointer ctype\");\n        return NULL;\n    }\n    ctitem = ctptr->ct_itemdescr;\n    if (ctitem->ct_size < 0) {\n        PyErr_Format(PyExc_ValueError, \"array item of unknown size: '%s'\",\n                     ctitem->ct_name);\n        return NULL;\n    }\n\n    if (length < 0) {\n        sprintf(extra_text, \"[]\");\n        length = -1;\n        arraysize = -1;\n    }\n    else {\n        sprintf(extra_text, \"[%llu]\", (unsigned PY_LONG_LONG)length);\n        arraysize = MUL_WRAPAROUND(length, ctitem->ct_size);\n        if (length > 0 && (arraysize / length) != ctitem->ct_size) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"array size would overflow a Py_ssize_t\");\n            return NULL;\n        }\n    }\n    td = ctypedescr_new_on_top(ctitem, extra_text, 0);\n    if (td == NULL)\n        return NULL;\n\n    Py_INCREF(ctptr);\n    td->ct_stuff = (PyObject *)ctptr;\n    td->ct_size = arraysize;\n    td->ct_length = length;\n    td->ct_flags = flags;\n    unique_key[0] = ctptr;\n    unique_key[1] = (void *)length;\n    return get_unique_type(td, unique_key, 2);\n}\n\nstatic PyObject *new_void_type(void)\n{\n    int name_size = strlen(\"void\") + 1;\n    const void *unique_key[1];\n    CTypeDescrObject *td = ctypedescr_new(name_size);\n    if (td == NULL)\n        return NULL;\n\n    memcpy(td->ct_name, \"void\", name_size);\n    td->ct_size = -1;\n    td->ct_flags = CT_VOID | CT_IS_OPAQUE;\n    td->ct_name_position = strlen(\"void\");\n    unique_key[0] = \"void\";\n    return get_unique_type(td, unique_key, 1);\n}\n\nstatic PyObject *b_new_void_type(PyObject *self, PyObject *args)\n{\n    return new_void_type();\n}\n\nstatic PyObject *new_struct_or_union_type(const char *name, int flag)\n{\n    int namelen = strlen(name);\n    CTypeDescrObject *td = ctypedescr_new(namelen + 1);\n    if (td == NULL)\n        return NULL;\n\n    td->ct_size = -1;\n    td->ct_length = -1;\n    td->ct_flags = flag | CT_IS_OPAQUE;\n    td->ct_extra = NULL;\n    memcpy(td->ct_name, name, namelen + 1);\n    td->ct_name_position = namelen;\n    return (PyObject *)td;\n}\n\nstatic PyObject *b_new_struct_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    int flag;\n    if (!PyArg_ParseTuple(args, \"s:new_struct_type\", &name))\n        return NULL;\n\n    flag = CT_STRUCT;\n    if (strcmp(name, \"struct _IO_FILE\") == 0 || strcmp(name, \"FILE\") == 0)\n        flag |= CT_IS_FILE;\n    return new_struct_or_union_type(name, flag);\n}\n\nstatic PyObject *b_new_union_type(PyObject *self, PyObject *args)\n{\n    char *name;\n    if (!PyArg_ParseTuple(args, \"s:new_union_type\", &name))\n        return NULL;\n    return new_struct_or_union_type(name, CT_UNION);\n}\n\nstatic CFieldObject *\n_add_field(PyObject *interned_fields, PyObject *fname, CTypeDescrObject *ftype,\n           Py_ssize_t offset, int bitshift, int fbitsize, int flags)\n{\n    int err;\n    Py_ssize_t prev_size;\n    CFieldObject *cf = PyObject_New(CFieldObject, &CField_Type);\n    if (cf == NULL)\n        return NULL;\n\n    Py_INCREF(ftype);\n    cf->cf_type = ftype;\n    cf->cf_offset = offset;\n    cf->cf_bitshift = bitshift;\n    cf->cf_bitsize = fbitsize;\n    cf->cf_flags = flags;\n\n    Py_INCREF(fname);\n    PyText_InternInPlace(&fname);\n    prev_size = PyDict_Size(interned_fields);\n    err = PyDict_SetItem(interned_fields, fname, (PyObject *)cf);\n    Py_DECREF(fname);\n    Py_DECREF(cf);\n    if (err < 0)\n        return NULL;\n\n    if (PyDict_Size(interned_fields) != prev_size + 1) {\n        PyErr_Format(PyExc_KeyError, \"duplicate field name '%s'\",\n                     PyText_AS_UTF8(fname));\n        return NULL;\n    }\n    return cf;   /* borrowed reference */\n}\n\n#define SF_MSVC_BITFIELDS     0x01\n#define SF_GCC_ARM_BITFIELDS  0x02\n#define SF_GCC_X86_BITFIELDS  0x10\n\n#define SF_GCC_BIG_ENDIAN     0x04\n#define SF_GCC_LITTLE_ENDIAN  0x40\n\n#define SF_PACKED             0x08\n#define SF_STD_FIELD_POS      0x80\n\n#ifdef MS_WIN32\n#  define SF_DEFAULT_PACKING     8\n#else\n#  define SF_DEFAULT_PACKING   0x40000000   /* a huge power of two */\n#endif\n\nstatic int complete_sflags(int sflags)\n{\n    /* add one of the SF_xxx_BITFIELDS flags if none is specified */\n    if (!(sflags & (SF_MSVC_BITFIELDS | SF_GCC_ARM_BITFIELDS |\n                    SF_GCC_X86_BITFIELDS))) {\n#ifdef MS_WIN32\n        sflags |= SF_MSVC_BITFIELDS;\n#else\n# if defined(__arm__) || defined(__aarch64__)\n        sflags |= SF_GCC_ARM_BITFIELDS;\n# else\n        sflags |= SF_GCC_X86_BITFIELDS;\n# endif\n#endif\n    }\n    /* add one of SF_GCC_xx_ENDIAN if none is specified */\n    if (!(sflags & (SF_GCC_BIG_ENDIAN | SF_GCC_LITTLE_ENDIAN))) {\n        int _check_endian = 1;\n        if (*(char *)&_check_endian == 0)\n            sflags |= SF_GCC_BIG_ENDIAN;\n        else\n            sflags |= SF_GCC_LITTLE_ENDIAN;\n    }\n    return sflags;\n}\n\nstatic int detect_custom_layout(CTypeDescrObject *ct, int sflags,\n                                Py_ssize_t cdef_value,\n                                Py_ssize_t compiler_value,\n                                const char *msg1, const char *txt,\n                                const char *msg2)\n{\n    if (compiler_value != cdef_value) {\n        if (sflags & SF_STD_FIELD_POS) {\n            PyErr_Format(FFIError,\n                         \"%s: %s%s%s (cdef says %zd, but C compiler says %zd).\"\n                         \" fix it or use \\\"...;\\\" in the cdef for %s to \"\n                         \"make it flexible\",\n                         ct->ct_name, msg1, txt, msg2,\n                         cdef_value, compiler_value,\n                         ct->ct_name);\n            return -1;\n        }\n        ct->ct_flags |= CT_CUSTOM_FIELD_POS;\n    }\n    return 0;\n}\n\n#define ROUNDUP_BYTES(bytes, bits)    ((bytes) + ((bits) > 0))\n\nstatic PyObject *b_complete_struct_or_union(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *fields, *interned_fields, *ignored;\n    int is_union, alignment;\n    Py_ssize_t byteoffset, i, nb_fields, byteoffsetmax, alignedsize;\n    int bitoffset;\n    Py_ssize_t byteoffsetorg;\n    Py_ssize_t totalsize = -1;\n    int totalalignment = -1;\n    CFieldObject **previous;\n    int prev_bitfield_size, prev_bitfield_free;\n    int sflags = 0, fflags;\n    int pack = 0;\n\n    if (!PyArg_ParseTuple(args, \"O!O!|Oniii:complete_struct_or_union\",\n                          &CTypeDescr_Type, &ct,\n                          &PyList_Type, &fields,\n                          &ignored, &totalsize, &totalalignment, &sflags,\n                          &pack))\n        return NULL;\n\n    sflags = complete_sflags(sflags);\n    if (sflags & SF_PACKED)\n        pack = 1;\n    else if (pack <= 0)\n        pack = SF_DEFAULT_PACKING;\n    else\n        sflags |= SF_PACKED;\n\n    if ((ct->ct_flags & (CT_STRUCT|CT_IS_OPAQUE)) ==\n                        (CT_STRUCT|CT_IS_OPAQUE)) {\n        is_union = 0;\n    }\n    else if ((ct->ct_flags & (CT_UNION|CT_IS_OPAQUE)) ==\n                             (CT_UNION|CT_IS_OPAQUE)) {\n        is_union = 1;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                  \"first arg must be a non-initialized struct or union ctype\");\n        return NULL;\n    }\n    ct->ct_flags &= ~(CT_CUSTOM_FIELD_POS | CT_WITH_PACKED_CHANGE);\n\n    alignment = 1;\n    byteoffset = 0;     /* the real value is 'byteoffset+bitoffset*8', which */\n    bitoffset = 0;      /* counts the offset in bits */\n    byteoffsetmax = 0; /* the maximum value of byteoffset-rounded-up-to-byte */\n    prev_bitfield_size = 0;\n    prev_bitfield_free = 0;\n    nb_fields = PyList_GET_SIZE(fields);\n    interned_fields = PyDict_New();\n    if (interned_fields == NULL)\n        return NULL;\n\n    previous = (CFieldObject **)&ct->ct_extra;\n\n    for (i=0; i<nb_fields; i++) {\n        PyObject *fname;\n        CTypeDescrObject *ftype;\n        int fbitsize = -1, falign, falignorg, do_align;\n        Py_ssize_t foffset = -1;\n\n        if (!PyArg_ParseTuple(PyList_GET_ITEM(fields, i), \"O!O!|in:list item\",\n                              &PyText_Type, &fname,\n                              &CTypeDescr_Type, &ftype,\n                              &fbitsize, &foffset))\n            goto error;\n\n        if (ftype->ct_size < 0) {\n            if ((ftype->ct_flags & CT_ARRAY) && fbitsize < 0\n                    && (i == nb_fields - 1 || foffset != -1)) {\n                ct->ct_flags |= CT_WITH_VAR_ARRAY;\n            }\n            else {\n                PyErr_Format(PyExc_TypeError,\n                             \"field '%s.%s' has ctype '%s' of unknown size\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name);\n                goto error;\n            }\n        }\n        else if (ftype->ct_flags & (CT_STRUCT|CT_UNION)) {\n            if (force_lazy_struct(ftype) < 0)   /* for CT_WITH_VAR_ARRAY */\n                return NULL;\n\n            /* GCC (or maybe C99) accepts var-sized struct fields that are not\n               the last field of a larger struct.  That's why there is no\n               check here for \"last field\": we propagate the flag\n               CT_WITH_VAR_ARRAY to any struct that contains either an open-\n               ended array or another struct that recursively contains an\n               open-ended array. */\n            if (ftype->ct_flags & CT_WITH_VAR_ARRAY)\n                ct->ct_flags |= CT_WITH_VAR_ARRAY;\n        }\n\n        if (is_union)\n            byteoffset = bitoffset = 0;   /* reset each field at offset 0 */\n\n        /* update the total alignment requirement, but skip it if the\n           field is an anonymous bitfield or if SF_PACKED */\n        falignorg = get_alignment(ftype);\n        if (falignorg < 0)\n            goto error;\n        falign = (pack < falignorg) ? pack : falignorg;\n\n        do_align = 1;\n        if (!(sflags & SF_GCC_ARM_BITFIELDS) && fbitsize >= 0) {\n            if (!(sflags & SF_MSVC_BITFIELDS)) {\n                /* GCC: anonymous bitfields (of any size) don't cause alignment */\n                do_align = PyText_GetSize(fname) > 0;\n            }\n            else {\n                /* MSVC: zero-sized bitfields don't cause alignment */\n                do_align = fbitsize > 0;\n            }\n        }\n        if (alignment < falign && do_align)\n            alignment = falign;\n\n        fflags = (is_union && i > 0) ? BF_IGNORE_IN_CTOR : 0;\n\n        if (fbitsize < 0) {\n            /* not a bitfield: common case */\n            int bs_flag;\n\n            if ((ftype->ct_flags & CT_ARRAY) && ftype->ct_length <= 0)\n                bs_flag = BS_EMPTY_ARRAY;\n            else\n                bs_flag = BS_REGULAR;\n\n            /* align this field to its own 'falign' by inserting padding */\n\n            /* first, pad to the next byte,\n             * then pad to 'falign' or 'falignorg' bytes */\n            byteoffset = ROUNDUP_BYTES(byteoffset, bitoffset);\n            bitoffset = 0;\n            byteoffsetorg = (byteoffset + falignorg-1) & ~(falignorg-1);\n            byteoffset = (byteoffset + falign-1) & ~(falign-1);\n\n            if (byteoffsetorg != byteoffset) {\n                ct->ct_flags |= CT_WITH_PACKED_CHANGE;\n            }\n\n            if (foffset >= 0) {\n                /* a forced field position: ignore the offset just computed,\n                   except to know if we must set CT_CUSTOM_FIELD_POS */\n                if (detect_custom_layout(ct, sflags, byteoffset, foffset,\n                                         \"wrong offset for field '\",\n                                         PyText_AS_UTF8(fname), \"'\") < 0)\n                    goto error;\n                byteoffset = foffset;\n            }\n\n            if (PyText_GetSize(fname) == 0 &&\n                    ftype->ct_flags & (CT_STRUCT|CT_UNION)) {\n                /* a nested anonymous struct or union */\n                CFieldObject *cfsrc = (CFieldObject *)ftype->ct_extra;\n                for (; cfsrc != NULL; cfsrc = cfsrc->cf_next) {\n                    /* broken complexity in the call to get_field_name(),\n                       but we'll assume you never do that with nested\n                       anonymous structures with thousand of fields */\n                    *previous = _add_field(interned_fields,\n                                           get_field_name(ftype, cfsrc),\n                                           cfsrc->cf_type,\n                                           byteoffset + cfsrc->cf_offset,\n                                           cfsrc->cf_bitshift,\n                                           cfsrc->cf_bitsize,\n                                           cfsrc->cf_flags | fflags);\n                    if (*previous == NULL)\n                        goto error;\n                    previous = &(*previous)->cf_next;\n                }\n                /* always forbid such structures from being passed by value */\n                ct->ct_flags |= CT_CUSTOM_FIELD_POS;\n            }\n            else {\n                *previous = _add_field(interned_fields, fname, ftype,\n                                       byteoffset, bs_flag, -1, fflags);\n                if (*previous == NULL)\n                    goto error;\n                previous = &(*previous)->cf_next;\n            }\n            if (ftype->ct_size >= 0)\n                byteoffset += ftype->ct_size;\n            prev_bitfield_size = 0;\n        }\n        else {\n            /* this is the case of a bitfield */\n            Py_ssize_t field_offset_bytes;\n            int bits_already_occupied, bitshift;\n\n            if (foffset >= 0) {\n                PyErr_Format(PyExc_TypeError,\n                             \"field '%s.%s' is a bitfield, \"\n                             \"but a fixed offset is specified\",\n                             ct->ct_name, PyText_AS_UTF8(fname));\n                goto error;\n            }\n\n            if (!(ftype->ct_flags & (CT_PRIMITIVE_SIGNED |\n                                     CT_PRIMITIVE_UNSIGNED |\n                                     CT_PRIMITIVE_CHAR))) {\n                PyErr_Format(PyExc_TypeError,\n                        \"field '%s.%s' declared as '%s' cannot be a bit field\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name);\n                goto error;\n            }\n            if (fbitsize > 8 * ftype->ct_size) {\n                PyErr_Format(PyExc_TypeError,\n                             \"bit field '%s.%s' is declared '%s:%d', which \"\n                             \"exceeds the width of the type\",\n                             ct->ct_name, PyText_AS_UTF8(fname),\n                             ftype->ct_name, fbitsize);\n                goto error;\n            }\n\n            /* compute the starting position of the theoretical field\n               that covers a complete 'ftype', inside of which we will\n               locate the real bitfield */\n            field_offset_bytes = byteoffset;\n            field_offset_bytes &= ~(falign - 1);\n\n            if (fbitsize == 0) {\n                if (PyText_GetSize(fname) > 0) {\n                    PyErr_Format(PyExc_TypeError,\n                                 \"field '%s.%s' is declared with :0\",\n                                 ct->ct_name, PyText_AS_UTF8(fname));\n                    goto error;\n                }\n                if (!(sflags & SF_MSVC_BITFIELDS)) {\n                    /* GCC's notion of \"ftype :0;\" */\n\n                    /* pad byteoffset to a value aligned for \"ftype\" */\n                    if (ROUNDUP_BYTES(byteoffset, bitoffset) > field_offset_bytes) {\n                        field_offset_bytes += falign;\n                        assert(byteoffset < field_offset_bytes);\n                    }\n                    byteoffset = field_offset_bytes;\n                    bitoffset = 0;\n                }\n                else {\n                    /* MSVC's notion of \"ftype :0;\" */\n\n                    /* Mostly ignored.  It seems they only serve as\n                       separator between other bitfields, to force them\n                       into separate words. */\n                }\n                prev_bitfield_size = 0;\n            }\n            else {\n                if (!(sflags & SF_MSVC_BITFIELDS)) {\n                    /* GCC's algorithm */\n\n                    /* Can the field start at the offset given by 'boffset'?  It\n                       can if it would entirely fit into an aligned ftype field. */\n                    bits_already_occupied = (byteoffset-field_offset_bytes) * 8\n                        + bitoffset;\n\n                    if (bits_already_occupied + fbitsize > 8 * ftype->ct_size) {\n                        /* it would not fit, we need to start at the next\n                           allowed position */\n                        if ((sflags & SF_PACKED) &&\n                            (bits_already_occupied & 7)) {\n                            PyErr_Format(PyExc_NotImplementedError,\n                                \"with 'packed', gcc would compile field \"\n                                \"'%s.%s' to reuse some bits in the previous \"\n                                \"field\", ct->ct_name, PyText_AS_UTF8(fname));\n                            goto error;\n                        }\n                        field_offset_bytes += falign;\n                        assert(byteoffset < field_offset_bytes);\n                        byteoffset = field_offset_bytes;\n                        bitoffset = 0;\n                        bitshift = 0;\n                    }\n                    else {\n                        bitshift = bits_already_occupied;\n                        assert(bitshift >= 0);\n                    }\n                    bitoffset += fbitsize;\n                    byteoffset += (bitoffset >> 3);\n                    bitoffset &= 7;\n                }\n                else {\n                    /* MSVC's algorithm */\n\n                    /* A bitfield is considered as taking the full width\n                       of their declared type.  It can share some bits\n                       with the previous field only if it was also a\n                       bitfield and used a type of the same size. */\n                    if (prev_bitfield_size == ftype->ct_size &&\n                        prev_bitfield_free >= fbitsize) {\n                        /* yes: reuse */\n                        bitshift = 8 * prev_bitfield_size - prev_bitfield_free;\n                    }\n                    else {\n                        /* no: start a new full field */\n                        byteoffset = ROUNDUP_BYTES(byteoffset, bitoffset);\n                        bitoffset = 0;\n                        /* align */\n                        byteoffset = (byteoffset + falign-1) & ~(falign-1);\n                        byteoffset += ftype->ct_size;\n                        bitshift = 0;\n                        prev_bitfield_size = ftype->ct_size;\n                        prev_bitfield_free = 8 * prev_bitfield_size;\n                    }\n                    prev_bitfield_free -= fbitsize;\n                    field_offset_bytes = byteoffset - ftype->ct_size;\n                }\n                if (sflags & SF_GCC_BIG_ENDIAN)\n                    bitshift = 8 * ftype->ct_size - fbitsize - bitshift;\n\n                if (PyText_GetSize(fname) > 0) {\n\n                    *previous = _add_field(interned_fields, fname, ftype,\n                                       field_offset_bytes, bitshift, fbitsize,\n                                       fflags);\n                    if (*previous == NULL)\n                        goto error;\n                    previous = &(*previous)->cf_next;\n                }\n            }\n        }\n\n        assert(bitoffset == (bitoffset & 7));\n        if (ROUNDUP_BYTES(byteoffset, bitoffset) > byteoffsetmax)\n            byteoffsetmax = ROUNDUP_BYTES(byteoffset, bitoffset);\n    }\n    *previous = NULL;\n\n    /* Like C, if the size of this structure would be zero, we compute it\n       as 1 instead.  But for ctypes support, we allow the manually-\n       specified totalsize to be zero in this case. */\n    alignedsize = (byteoffsetmax + alignment - 1) & ~(alignment-1);\n    if (alignedsize == 0)\n        alignedsize = 1;\n\n    if (totalsize < 0) {\n        totalsize = alignedsize;\n    }\n    else {\n        if (detect_custom_layout(ct, sflags, alignedsize,\n                                 totalsize, \"wrong total size\", \"\", \"\") < 0)\n            goto error;\n        if (totalsize < byteoffsetmax) {\n            PyErr_Format(PyExc_TypeError,\n                         \"%s cannot be of size %zd: there are fields at least \"\n                         \"up to %zd\", ct->ct_name, totalsize, byteoffsetmax);\n            goto error;\n        }\n    }\n    if (totalalignment < 0) {\n        totalalignment = alignment;\n    }\n    else {\n        if (detect_custom_layout(ct, sflags, alignment, totalalignment,\n                                 \"wrong total alignment\", \"\", \"\") < 0)\n            goto error;\n    }\n\n    ct->ct_size = totalsize;\n    ct->ct_length = totalalignment;\n    ct->ct_stuff = interned_fields;\n    ct->ct_flags &= ~CT_IS_OPAQUE;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n\n error:\n    ct->ct_extra = NULL;\n    Py_DECREF(interned_fields);\n    return NULL;\n}\n\nstruct funcbuilder_s {\n    Py_ssize_t nb_bytes;\n    char *bufferp;\n    ffi_type **atypes;\n    ffi_type *rtype;\n    Py_ssize_t nargs;\n    CTypeDescrObject *fct;\n};\n\nstatic void *fb_alloc(struct funcbuilder_s *fb, Py_ssize_t size)\n{\n    if (fb->bufferp == NULL) {\n        fb->nb_bytes += size;\n        return NULL;\n    }\n    else {\n        char *result = fb->bufferp;\n        fb->bufferp += size;\n        return result;\n    }\n}\n\n#define SUPPORTED_IN_API_MODE                                            \\\n        \" are only supported as %s if the function is \"                  \\\n        \"'API mode' and non-variadic (i.e. declared inside ffibuilder\"   \\\n        \".cdef()+ffibuilder.set_source() and not taking a final '...' \"  \\\n        \"argument)\"\n\nstatic ffi_type *fb_unsupported(CTypeDescrObject *ct, const char *place,\n                                const char *detail)\n{\n    PyErr_Format(PyExc_NotImplementedError,\n        \"ctype '%s' not supported as %s.  %s.  \"\n        \"Such structs\" SUPPORTED_IN_API_MODE,\n        ct->ct_name, place, detail, place);\n    return NULL;\n}\n\nstatic ffi_type *fb_fill_type(struct funcbuilder_s *fb, CTypeDescrObject *ct,\n                              int is_result_type)\n{\n    const char *place = is_result_type ? \"return value\" : \"argument\";\n\n    if (ct->ct_flags & (CT_PRIMITIVE_ANY & ~CT_PRIMITIVE_COMPLEX)) {\n        return (ffi_type *)ct->ct_extra;\n    }\n    else if (ct->ct_flags & (CT_POINTER|CT_FUNCTIONPTR)) {\n        return &ffi_type_pointer;\n    }\n    else if ((ct->ct_flags & CT_VOID) && is_result_type) {\n        return &ffi_type_void;\n    }\n\n    if (ct->ct_size <= 0) {\n        PyErr_Format(PyExc_TypeError,\n                     ct->ct_size < 0 ? \"ctype '%s' has incomplete type\"\n                                     : \"ctype '%s' has size 0\",\n                     ct->ct_name);\n        return NULL;\n    }\n    if (ct->ct_flags & CT_STRUCT) {\n        ffi_type *ffistruct, *ffifield;\n        ffi_type **elements;\n        Py_ssize_t i, n, nflat;\n        CFieldObject *cf;\n\n        /* We can't pass a struct that was completed by verify().\n           Issue: assume verify() is given \"struct { long b; ...; }\".\n           Then it will complete it in the same way whether it is actually\n           \"struct { long a, b; }\" or \"struct { double a; long b; }\".\n           But on 64-bit UNIX, these two structs are passed by value\n           differently: e.g. on x86-64, \"b\" ends up in register \"rsi\" in\n           the first case and \"rdi\" in the second case.\n\n           Another reason for CT_CUSTOM_FIELD_POS would be anonymous\n           nested structures: we lost the information about having it\n           here, so better safe (and forbid it) than sorry (and maybe\n           crash).  Note: it seems we only get in this case with\n           ffi.verify().\n        */\n        if (force_lazy_struct(ct) < 0)\n            return NULL;\n        if (ct->ct_flags & CT_CUSTOM_FIELD_POS) {\n            /* these NotImplementedErrors may be caught and ignored until\n               a real call is made to a function of this type */\n            return fb_unsupported(ct, place,\n                \"It is a struct declared with \\\"...;\\\", but the C \"\n                \"calling convention may depend on the missing fields; \"\n                \"or, it contains anonymous struct/unions\");\n        }\n        /* Another reason: __attribute__((packed)) is not supported by libffi.\n        */\n        if (ct->ct_flags & CT_WITH_PACKED_CHANGE) {\n            return fb_unsupported(ct, place,\n                \"It is a 'packed' structure, with a different layout than \"\n                \"expected by libffi\");\n        }\n\n        n = PyDict_Size(ct->ct_stuff);\n        nflat = 0;\n\n        /* walk the fields, expanding arrays into repetitions; first,\n           only count how many flattened fields there are */\n        cf = (CFieldObject *)ct->ct_extra;\n        for (i=0; i<n; i++) {\n            Py_ssize_t flat;\n            CTypeDescrObject *ct1;\n            assert(cf != NULL);\n            if (cf->cf_bitshift >= 0) {\n                return fb_unsupported(ct, place,\n                    \"It is a struct with bit fields, which libffi does not \"\n                    \"support\");\n            }\n            flat = 1;\n            ct1 = cf->cf_type;\n            while (ct1->ct_flags & CT_ARRAY) {\n                flat *= ct1->ct_length;\n                ct1 = ct1->ct_itemdescr;\n            }\n            if (flat <= 0) {\n                return fb_unsupported(ct, place,\n                    \"It is a struct with a zero-length array, which libffi \"\n                    \"does not support\");\n            }\n            nflat += flat;\n            cf = cf->cf_next;\n        }\n        assert(cf == NULL);\n\n        /* next, allocate and fill the flattened list */\n        elements = fb_alloc(fb, (nflat + 1) * sizeof(ffi_type*));\n        nflat = 0;\n        cf = (CFieldObject *)ct->ct_extra;\n        for (i=0; i<n; i++) {\n            Py_ssize_t j, flat = 1;\n            CTypeDescrObject *ct = cf->cf_type;\n            while (ct->ct_flags & CT_ARRAY) {\n                flat *= ct->ct_length;\n                ct = ct->ct_itemdescr;\n            }\n            ffifield = fb_fill_type(fb, ct, 0);\n            if (PyErr_Occurred())\n                return NULL;\n            if (elements != NULL) {\n                for (j=0; j<flat; j++)\n                    elements[nflat++] = ffifield;\n            }\n            cf = cf->cf_next;\n        }\n\n        /* finally, allocate the FFI_TYPE_STRUCT */\n        ffistruct = fb_alloc(fb, sizeof(ffi_type));\n        if (ffistruct != NULL) {\n            elements[nflat] = NULL;\n            ffistruct->size = ct->ct_size;\n            ffistruct->alignment = ct->ct_length;\n            ffistruct->type = FFI_TYPE_STRUCT;\n            ffistruct->elements = elements;\n        }\n        return ffistruct;\n    }\n    else if (ct->ct_flags & CT_UNION) {\n        PyErr_Format(PyExc_NotImplementedError,\n                     \"ctype '%s' not supported as %s by libffi.  \"\n                     \"Unions\" SUPPORTED_IN_API_MODE,\n                     ct->ct_name, place, place);\n        return NULL;\n    }\n    else {\n        char *extra = \"\";\n        if (ct->ct_flags & CT_PRIMITIVE_COMPLEX)\n            extra = \" (the support for complex types inside libffi \"\n                    \"is mostly missing at this point, so CFFI only \"\n                    \"supports complex types as arguments or return \"\n                    \"value in API-mode functions)\";\n\n        PyErr_Format(PyExc_NotImplementedError,\n                     \"ctype '%s' (size %zd) not supported as %s%s\",\n                     ct->ct_name, ct->ct_size, place, extra);\n        return NULL;\n    }\n}\n\n#define ALIGN_ARG(n)  ((n) + 7) & ~7\n\nstatic int fb_build(struct funcbuilder_s *fb, PyObject *fargs,\n                    CTypeDescrObject *fresult)\n{\n    Py_ssize_t i, nargs = PyTuple_GET_SIZE(fargs);\n    Py_ssize_t exchange_offset;\n    cif_description_t *cif_descr;\n\n    /* ffi buffer: start with a cif_description */\n    cif_descr = fb_alloc(fb, sizeof(cif_description_t) +\n                             nargs * sizeof(Py_ssize_t));\n\n    /* ffi buffer: next comes an array of 'ffi_type*', one per argument */\n    fb->atypes = fb_alloc(fb, nargs * sizeof(ffi_type*));\n    fb->nargs = nargs;\n\n    /* ffi buffer: next comes the result type */\n    fb->rtype = fb_fill_type(fb, fresult, 1);\n    if (PyErr_Occurred())\n        return -1;\n    if (cif_descr != NULL) {\n        /* exchange data size */\n        /* first, enough room for an array of 'nargs' pointers */\n        exchange_offset = nargs * sizeof(void*);\n        exchange_offset = ALIGN_ARG(exchange_offset);\n        cif_descr->exchange_offset_arg[0] = exchange_offset;\n        /* then enough room for the result --- which means at least\n           sizeof(ffi_arg), according to the ffi docs */\n        i = fb->rtype->size;\n        if (i < (Py_ssize_t)sizeof(ffi_arg))\n            i = sizeof(ffi_arg);\n        exchange_offset += i;\n    }\n    else\n        exchange_offset = 0;   /* not used */\n\n    /* loop over the arguments */\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *farg;\n        ffi_type *atype;\n\n        farg = (CTypeDescrObject *)PyTuple_GET_ITEM(fargs, i);\n        /* convert arrays to pointers */\n        if (farg->ct_flags & CT_ARRAY)\n            farg = (CTypeDescrObject *)farg->ct_stuff;\n\n        /* ffi buffer: fill in the ffi for the i'th argument */\n        assert(farg != NULL);\n        atype = fb_fill_type(fb, farg, 0);\n        if (PyErr_Occurred())\n            return -1;\n\n        if (fb->atypes != NULL) {\n            fb->atypes[i] = atype;\n            /* exchange data size */\n            exchange_offset = ALIGN_ARG(exchange_offset);\n            cif_descr->exchange_offset_arg[1 + i] = exchange_offset;\n            exchange_offset += atype->size;\n        }\n    }\n\n    if (cif_descr != NULL) {\n        /* exchange data size */\n        /* we also align it to the next multiple of 8, in an attempt to\n           work around bugs(?) of libffi like #241 */\n        cif_descr->exchange_size = ALIGN_ARG(exchange_offset);\n    }\n    return 0;\n}\n\n#undef ALIGN_ARG\n\nstatic void fb_cat_name(struct funcbuilder_s *fb, const char *piece,\n                        int piecelen)\n{\n    if (fb->bufferp == NULL) {\n        fb->nb_bytes += piecelen;\n    }\n    else {\n        memcpy(fb->bufferp, piece, piecelen);\n        fb->bufferp += piecelen;\n    }\n}\n\nstatic int fb_build_name(struct funcbuilder_s *fb, const char *repl,\n                         CTypeDescrObject **pfargs, Py_ssize_t nargs,\n                         CTypeDescrObject *fresult, int ellipsis)\n{\n    Py_ssize_t i;\n    fb->nargs = nargs;\n\n    /* name: the function type name we build here is, like in C, made\n       as follows:\n\n         RESULT_TYPE_HEAD (*)(ARG_1_TYPE, ARG_2_TYPE, etc) RESULT_TYPE_TAIL\n    */\n    fb_cat_name(fb, fresult->ct_name, fresult->ct_name_position);\n    if (repl[0] != '(' &&\n        fresult->ct_name[fresult->ct_name_position - 1] != '*')\n        fb_cat_name(fb, \" \", 1);   /* add a space */\n    fb_cat_name(fb, repl, strlen(repl));\n    if (fb->fct) {\n        i = strlen(repl) - 1;      /* between '(*' and ')' */\n        assert(repl[i] == ')');\n        fb->fct->ct_name_position = fresult->ct_name_position + i;\n    }\n    fb_cat_name(fb, \"(\", 1);\n\n    /* loop over the arguments */\n    for (i=0; i<nargs; i++) {\n        CTypeDescrObject *farg;\n\n        farg = pfargs[i];\n        if (!CTypeDescr_Check(farg)) {\n            PyErr_SetString(PyExc_TypeError, \"expected a tuple of ctypes\");\n            return -1;\n        }\n        /* name: concatenate the name of the i'th argument's type */\n        if (i > 0)\n            fb_cat_name(fb, \", \", 2);\n        fb_cat_name(fb, farg->ct_name, strlen(farg->ct_name));\n    }\n\n    /* name: add the '...' if needed */\n    if (ellipsis) {\n        if (nargs > 0)\n            fb_cat_name(fb, \", \", 2);\n        fb_cat_name(fb, \"...\", 3);\n    }\n\n    /* name: concatenate the tail of the result type */\n    fb_cat_name(fb, \")\", 1);\n    fb_cat_name(fb, fresult->ct_name + fresult->ct_name_position,\n                strlen(fresult->ct_name) - fresult->ct_name_position + 1);\n    return 0;\n}\n\nstatic CTypeDescrObject *fb_prepare_ctype(struct funcbuilder_s *fb,\n                                          PyObject *fargs,\n                                          CTypeDescrObject *fresult,\n                                          int ellipsis, int fabi)\n{\n    CTypeDescrObject *fct, **pfargs;\n    Py_ssize_t nargs;\n    char *repl = \"(*)\";\n\n    fb->nb_bytes = 0;\n    fb->bufferp = NULL;\n    fb->fct = NULL;\n\n    pfargs = (CTypeDescrObject **)&PyTuple_GET_ITEM(fargs, 0);\n    nargs = PyTuple_GET_SIZE(fargs);\n#if defined(MS_WIN32) && !defined(_WIN64)\n    if (fabi == FFI_STDCALL)\n        repl = \"(__stdcall *)\";\n#endif\n\n    /* compute the total size needed for the name */\n    if (fb_build_name(fb, repl, pfargs, nargs, fresult, ellipsis) < 0)\n        return NULL;\n\n    /* allocate the function type */\n    fct = ctypedescr_new(fb->nb_bytes);\n    if (fct == NULL)\n        return NULL;\n    fb->fct = fct;\n\n    /* call again fb_build_name() to really build the ct_name */\n    fb->bufferp = fct->ct_name;\n    if (fb_build_name(fb, repl, pfargs, nargs, fresult, ellipsis) < 0)\n        goto error;\n    assert(fb->bufferp == fct->ct_name + fb->nb_bytes);\n\n    fct->ct_extra = NULL;\n    fct->ct_size = sizeof(void(*)(void));\n    fct->ct_flags = CT_FUNCTIONPTR;\n    return fct;\n\n error:\n    Py_DECREF(fct);\n    return NULL;\n}\n\nstatic cif_description_t *fb_prepare_cif(PyObject *fargs,\n                                         CTypeDescrObject *fresult,\n                                         ffi_abi fabi)\n{\n    char *buffer;\n    cif_description_t *cif_descr;\n    struct funcbuilder_s funcbuffer;\n\n    funcbuffer.nb_bytes = 0;\n    funcbuffer.bufferp = NULL;\n\n    /* compute the total size needed in the buffer for libffi */\n    if (fb_build(&funcbuffer, fargs, fresult) < 0)\n        return NULL;\n\n    /* allocate the buffer */\n    buffer = PyObject_Malloc(funcbuffer.nb_bytes);\n    if (buffer == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    /* call again fb_build() to really build the libffi data structures */\n    funcbuffer.bufferp = buffer;\n    if (fb_build(&funcbuffer, fargs, fresult) < 0)\n        goto error;\n    assert(funcbuffer.bufferp == buffer + funcbuffer.nb_bytes);\n\n    cif_descr = (cif_description_t *)buffer;\n    if (ffi_prep_cif(&cif_descr->cif, fabi, funcbuffer.nargs,\n                     funcbuffer.rtype, funcbuffer.atypes) != FFI_OK) {\n        PyErr_SetString(PyExc_SystemError,\n                        \"libffi failed to build this function type\");\n        goto error;\n    }\n    return cif_descr;\n\n error:\n    PyObject_Free(buffer);\n    return NULL;\n}\n\nstatic PyObject *new_function_type(PyObject *fargs,   /* tuple */\n                                   CTypeDescrObject *fresult,\n                                   int ellipsis, int fabi)\n{\n    PyObject *fabiobj;\n    CTypeDescrObject *fct;\n    struct funcbuilder_s funcbuilder;\n    Py_ssize_t i;\n    const void **unique_key;\n\n    if ((fresult->ct_size < 0 && !(fresult->ct_flags & CT_VOID)) ||\n        (fresult->ct_flags & CT_ARRAY)) {\n        char *msg;\n        if (fresult->ct_flags & CT_IS_OPAQUE)\n            msg = \"result type '%s' is opaque\";\n        else\n            msg = \"invalid result type: '%s'\";\n        PyErr_Format(PyExc_TypeError, msg, fresult->ct_name);\n        return NULL;\n    }\n\n    fct = fb_prepare_ctype(&funcbuilder, fargs, fresult, ellipsis, fabi);\n    if (fct == NULL)\n        return NULL;\n\n    if (!ellipsis) {\n        /* Functions with '...' varargs are stored without a cif_descr\n           at all.  The cif is computed on every call from the actual\n           types passed in.  For all other functions, the cif_descr\n           is computed here. */\n        cif_description_t *cif_descr;\n\n        cif_descr = fb_prepare_cif(fargs, fresult, fabi);\n        if (cif_descr == NULL) {\n            if (PyErr_ExceptionMatches(PyExc_NotImplementedError)) {\n                PyErr_Clear();   /* will get the exception if we see an\n                                    actual call */\n            }\n            else\n                goto error;\n        }\n\n        fct->ct_extra = (char *)cif_descr;\n    }\n\n    /* build the signature, given by a tuple of ctype objects */\n    fct->ct_stuff = PyTuple_New(2 + funcbuilder.nargs);\n    if (fct->ct_stuff == NULL)\n        goto error;\n    fabiobj = PyInt_FromLong(fabi);\n    if (fabiobj == NULL)\n        goto error;\n    PyTuple_SET_ITEM(fct->ct_stuff, 0, fabiobj);\n\n    Py_INCREF(fresult);\n    PyTuple_SET_ITEM(fct->ct_stuff, 1, (PyObject *)fresult);\n    for (i=0; i<funcbuilder.nargs; i++) {\n        PyObject *o = PyTuple_GET_ITEM(fargs, i);\n        /* convert arrays into pointers */\n        if (((CTypeDescrObject *)o)->ct_flags & CT_ARRAY)\n            o = ((CTypeDescrObject *)o)->ct_stuff;\n        Py_INCREF(o);\n        PyTuple_SET_ITEM(fct->ct_stuff, 2 + i, o);\n    }\n\n    /* [ctresult, ellipsis+abi, num_args, ctargs...] */\n    unique_key = alloca((3 + funcbuilder.nargs) * sizeof(void *));\n    unique_key[0] = fresult;\n    unique_key[1] = (const void *)(Py_ssize_t)((fabi << 1) | !!ellipsis);\n    unique_key[2] = (const void *)(Py_ssize_t)(funcbuilder.nargs);\n    for (i=0; i<funcbuilder.nargs; i++)\n        unique_key[3 + i] = PyTuple_GET_ITEM(fct->ct_stuff, 2 + i);\n    return get_unique_type(fct, unique_key, 3 + funcbuilder.nargs);\n\n error:\n    Py_DECREF(fct);\n    return NULL;\n}\n\nstatic PyObject *b_new_function_type(PyObject *self, PyObject *args)\n{\n    PyObject *fargs;\n    CTypeDescrObject *fresult;\n    int ellipsis = 0, fabi = FFI_DEFAULT_ABI;\n\n    if (!PyArg_ParseTuple(args, \"O!O!|ii:new_function_type\",\n                          &PyTuple_Type, &fargs,\n                          &CTypeDescr_Type, &fresult,\n                          &ellipsis,\n                          &fabi))\n        return NULL;\n\n    return new_function_type(fargs, fresult, ellipsis, fabi);\n}\n\nstatic int convert_from_object_fficallback(char *result,\n                                           CTypeDescrObject *ctype,\n                                           PyObject *pyobj,\n                                           int encode_result_for_libffi)\n{\n    /* work work work around a libffi irregularity: for integer return\n       types we have to fill at least a complete 'ffi_arg'-sized result\n       buffer. */\n    if (ctype->ct_size < (Py_ssize_t)sizeof(ffi_arg)) {\n        if (ctype->ct_flags & CT_VOID) {\n            if (pyobj == Py_None) {\n                return 0;\n            }\n            else {\n                PyErr_SetString(PyExc_TypeError,\n                    \"callback with the return type 'void' must return None\");\n                return -1;\n            }\n        }\n        if (!encode_result_for_libffi)\n            goto skip;\n        if (ctype->ct_flags & CT_PRIMITIVE_SIGNED) {\n            PY_LONG_LONG value;\n            /* It's probably fine to always zero-extend, but you never\n               know: maybe some code somewhere expects a negative\n               'short' result to be returned into EAX as a 32-bit\n               negative number.  Better safe than sorry.  This code\n               is about that case.  Let's ignore this for enums.\n            */\n            /* do a first conversion only to detect overflows.  This\n               conversion produces stuff that is otherwise ignored. */\n            if (convert_from_object(result, ctype, pyobj) < 0)\n                return -1;\n            /* manual inlining and tweaking of convert_from_object()\n               in order to write a whole 'ffi_arg'. */\n            value = _my_PyLong_AsLongLong(pyobj);\n            if (value == -1 && PyErr_Occurred())\n                return -1;\n            write_raw_integer_data(result, value, sizeof(ffi_arg));\n            return 0;\n        }\n        else if (ctype->ct_flags & (CT_PRIMITIVE_CHAR | CT_PRIMITIVE_SIGNED |\n                                    CT_PRIMITIVE_UNSIGNED |\n                                    CT_POINTER | CT_FUNCTIONPTR)) {\n            /* zero extension: fill the '*result' with zeros, and (on big-\n               endian machines) correct the 'result' pointer to write to.\n               We also do that for pointers, even though we're normally not\n               in this branch because ctype->ct_size == sizeof(ffi_arg) for\n               pointers---except on some architectures like x32 (issue #372).\n             */\n            memset(result, 0, sizeof(ffi_arg));\n#ifdef WORDS_BIGENDIAN\n            result += (sizeof(ffi_arg) - ctype->ct_size);\n#endif\n        }\n    }\n skip:\n    return convert_from_object(result, ctype, pyobj);\n}\n\nstatic void _my_PyErr_WriteUnraisable(PyObject *t, PyObject *v, PyObject *tb,\n                                      char *objdescr, PyObject *obj,\n                                      char *extra_error_line)\n{\n    /* like PyErr_WriteUnraisable(), but write a full traceback */\n    PyObject *f;\n#if PY_MAJOR_VERSION >= 3\n    /* jump through hoops to ensure the tb is attached to v, on Python 3 */\n    PyErr_NormalizeException(&t, &v, &tb);\n    if (tb == NULL) {\n        tb = Py_None;\n        Py_INCREF(tb);\n    }\n    PyException_SetTraceback(v, tb);\n#endif\n    f = PySys_GetObject(\"stderr\");\n    if (f != NULL) {\n        if (obj != NULL) {\n            PyFile_WriteString(objdescr, f);\n            PyFile_WriteObject(obj, f, 0);\n            PyFile_WriteString(\":\\n\", f);\n        }\n        if (extra_error_line != NULL)\n            PyFile_WriteString(extra_error_line, f);\n        PyErr_Display(t, v, tb);\n    }\n    Py_XDECREF(t);\n    Py_XDECREF(v);\n    Py_XDECREF(tb);\n}\n\nstatic void general_invoke_callback(int decode_args_from_libffi,\n                                    void *result, char *args, void *userdata)\n{\n    PyObject *cb_args = (PyObject *)userdata;\n    CTypeDescrObject *ct = (CTypeDescrObject *)PyTuple_GET_ITEM(cb_args, 0);\n    PyObject *signature = ct->ct_stuff;\n    PyObject *py_ob = PyTuple_GET_ITEM(cb_args, 1);\n    PyObject *py_args = NULL;\n    PyObject *py_res = NULL;\n    PyObject *py_rawerr;\n    PyObject *onerror_cb;\n    Py_ssize_t i, n;\n    char *extra_error_line = NULL;\n\n#define SIGNATURE(i)  ((CTypeDescrObject *)PyTuple_GET_ITEM(signature, i))\n\n    Py_INCREF(cb_args);\n\n    n = PyTuple_GET_SIZE(signature) - 2;\n    py_args = PyTuple_New(n);\n    if (py_args == NULL)\n        goto error;\n\n    for (i=0; i<n; i++) {\n        char *a_src;\n        PyObject *a;\n        CTypeDescrObject *a_ct = SIGNATURE(2 + i);\n\n        if (decode_args_from_libffi) {\n            a_src = ((void **)args)[i];\n        }\n        else {\n            a_src = args + i * 8;\n            if (a_ct->ct_flags & (CT_IS_LONGDOUBLE | CT_STRUCT | CT_UNION))\n                a_src = *(char **)a_src;\n        }\n        a = convert_to_object(a_src, a_ct);\n        if (a == NULL)\n            goto error;\n        PyTuple_SET_ITEM(py_args, i, a);\n    }\n\n    py_res = PyObject_Call(py_ob, py_args, NULL);\n    if (py_res == NULL)\n        goto error;\n    if (convert_from_object_fficallback(result, SIGNATURE(1), py_res,\n                                        decode_args_from_libffi) < 0) {\n        extra_error_line = \"Trying to convert the result back to C:\\n\";\n        goto error;\n    }\n done:\n    Py_XDECREF(py_args);\n    Py_XDECREF(py_res);\n    Py_DECREF(cb_args);\n    return;\n\n error:\n    if (SIGNATURE(1)->ct_size > 0) {\n        py_rawerr = PyTuple_GET_ITEM(cb_args, 2);\n        memcpy(result, PyBytes_AS_STRING(py_rawerr),\n                       PyBytes_GET_SIZE(py_rawerr));\n    }\n    onerror_cb = PyTuple_GET_ITEM(cb_args, 3);\n    if (onerror_cb == Py_None) {\n        PyObject *ecap, *t, *v, *tb;\n        PyErr_Fetch(&t, &v, &tb);\n        ecap = _cffi_start_error_capture();\n        _my_PyErr_WriteUnraisable(t, v, tb, \"From cffi callback \", py_ob,\n                                  extra_error_line);\n        _cffi_stop_error_capture(ecap);\n    }\n    else {\n        PyObject *exc1, *val1, *tb1, *res1, *exc2, *val2, *tb2;\n        PyErr_Fetch(&exc1, &val1, &tb1);\n        PyErr_NormalizeException(&exc1, &val1, &tb1);\n        res1 = PyObject_CallFunctionObjArgs(onerror_cb,\n                                            exc1 ? exc1 : Py_None,\n                                            val1 ? val1 : Py_None,\n                                            tb1  ? tb1  : Py_None,\n                                            NULL);\n        if (res1 != NULL) {\n            if (res1 != Py_None)\n                convert_from_object_fficallback(result, SIGNATURE(1), res1,\n                                                decode_args_from_libffi);\n            Py_DECREF(res1);\n        }\n        if (!PyErr_Occurred()) {\n            Py_XDECREF(exc1);\n            Py_XDECREF(val1);\n            Py_XDECREF(tb1);\n        }\n        else {\n            /* double exception! print a double-traceback... */\n            PyObject *ecap;\n            PyErr_Fetch(&exc2, &val2, &tb2);\n            ecap = _cffi_start_error_capture();\n            _my_PyErr_WriteUnraisable(exc1, val1, tb1,\n                                      \"From cffi callback \", py_ob,\n                                      extra_error_line);\n            extra_error_line = (\"\\nDuring the call to 'onerror', \"\n                                \"another exception occurred:\\n\\n\");\n            _my_PyErr_WriteUnraisable(exc2, val2, tb2,\n                                      NULL, NULL, extra_error_line);\n            _cffi_stop_error_capture(ecap);\n        }\n    }\n    goto done;\n\n#undef SIGNATURE\n}\n\nstatic void invoke_callback(ffi_cif *cif, void *result, void **args,\n                            void *userdata)\n{\n    save_errno();\n    {\n        PyGILState_STATE state = gil_ensure();\n        general_invoke_callback(1, result, (char *)args, userdata);\n        gil_release(state);\n    }\n    restore_errno();\n}\n\nstatic PyObject *prepare_callback_info_tuple(CTypeDescrObject *ct,\n                                             PyObject *ob,\n                                             PyObject *error_ob,\n                                             PyObject *onerror_ob,\n                                             int decode_args_from_libffi)\n{\n    CTypeDescrObject *ctresult;\n    PyObject *py_rawerr, *infotuple;\n    Py_ssize_t size;\n\n    if (!(ct->ct_flags & CT_FUNCTIONPTR)) {\n        PyErr_Format(PyExc_TypeError, \"expected a function ctype, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n    if (!PyCallable_Check(ob)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a callable object, not %.200s\",\n                     Py_TYPE(ob)->tp_name);\n        return NULL;\n    }\n    if (onerror_ob != Py_None && !PyCallable_Check(onerror_ob)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a callable object for 'onerror', not %.200s\",\n                     Py_TYPE(onerror_ob)->tp_name);\n        return NULL;\n    }\n\n    ctresult = (CTypeDescrObject *)PyTuple_GET_ITEM(ct->ct_stuff, 1);\n    size = ctresult->ct_size;\n    if (size < (Py_ssize_t)sizeof(ffi_arg))\n        size = sizeof(ffi_arg);\n    py_rawerr = PyBytes_FromStringAndSize(NULL, size);\n    if (py_rawerr == NULL)\n        return NULL;\n    memset(PyBytes_AS_STRING(py_rawerr), 0, size);\n    if (error_ob != Py_None) {\n        if (convert_from_object_fficallback(\n                PyBytes_AS_STRING(py_rawerr), ctresult, error_ob,\n                decode_args_from_libffi) < 0) {\n            Py_DECREF(py_rawerr);\n            return NULL;\n        }\n    }\n    infotuple = Py_BuildValue(\"OOOO\", ct, ob, py_rawerr, onerror_ob);\n    Py_DECREF(py_rawerr);\n\n#ifdef WITH_THREAD\n    /* We must setup the GIL here, in case the callback is invoked in\n       some other non-Pythonic thread.  This is the same as ctypes. */\n    PyEval_InitThreads();\n#endif\n\n    return infotuple;\n}\n\nstatic PyObject *b_callback(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    CDataObject_closure *cd;\n    PyObject *ob, *error_ob = Py_None, *onerror_ob = Py_None;\n    PyObject *infotuple;\n    cif_description_t *cif_descr;\n    ffi_closure *closure;\n    void *closure_exec;\n\n    if (!PyArg_ParseTuple(args, \"O!O|OO:callback\", &CTypeDescr_Type, &ct, &ob,\n                          &error_ob, &onerror_ob))\n        return NULL;\n\n    infotuple = prepare_callback_info_tuple(ct, ob, error_ob, onerror_ob, 1);\n    if (infotuple == NULL)\n        return NULL;\n\n#ifdef CFFI_TRUST_LIBFFI\n    closure = ffi_closure_alloc(sizeof(ffi_closure), &closure_exec);\n#else\n    closure = cffi_closure_alloc();\n    closure_exec = closure;\n#endif\n    if (closure == NULL) {\n        Py_DECREF(infotuple);\n        PyErr_SetString(PyExc_MemoryError,\n            \"Cannot allocate write+execute memory for ffi.callback(). \"\n            \"You might be running on a system that prevents this. \"\n            \"For more information, see \"\n            \"https://cffi.readthedocs.io/en/latest/using.html#callbacks\");\n        return NULL;\n    }\n    cd = PyObject_GC_New(CDataObject_closure, &CDataOwningGC_Type);\n    if (cd == NULL)\n        goto error;\n    Py_INCREF(ct);\n    cd->head.c_type = ct;\n    cd->head.c_data = (char *)closure_exec;\n    cd->head.c_weakreflist = NULL;\n    cd->closure = closure;\n    PyObject_GC_Track(cd);\n\n    cif_descr = (cif_description_t *)ct->ct_extra;\n    if (cif_descr == NULL) {\n        PyErr_Format(PyExc_NotImplementedError,\n                     \"%s: callback with unsupported argument or \"\n                     \"return type or with '...'\", ct->ct_name);\n        goto error;\n    }\n#ifdef CFFI_TRUST_LIBFFI\n    if (ffi_prep_closure_loc(closure, &cif_descr->cif,\n                         invoke_callback, infotuple, closure_exec) != FFI_OK) {\n#else\n    if (ffi_prep_closure(closure, &cif_descr->cif,\n                         invoke_callback, infotuple) != FFI_OK) {\n#endif\n        PyErr_SetString(PyExc_SystemError,\n                        \"libffi failed to build this callback\");\n        goto error;\n    }\n    if (closure->user_data != infotuple) {\n        /* Issue #266.  Should not occur, but could, if we are using\n           at runtime a version of libffi compiled with a different\n           'ffi_closure' structure than the one we expect from ffi.h\n           (e.g. difference in details of the platform): a difference\n           in FFI_TRAMPOLINE_SIZE means that the 'user_data' field\n           ends up somewhere else, and so the test above fails.\n        */\n        PyErr_SetString(PyExc_SystemError,\n            \"ffi_prep_closure(): bad user_data (it seems that the \"\n            \"version of the libffi library seen at runtime is \"\n            \"different from the 'ffi.h' file seen at compile-time)\");\n        goto error;\n    }\n    return (PyObject *)cd;\n\n error:\n    closure->user_data = NULL;\n    if (cd == NULL) {\n#ifdef CFFI_TRUST_LIBFFI\n        ffi_closure_free(closure);\n#else\n        cffi_closure_free(closure);\n#endif\n    }\n    else\n        Py_DECREF(cd);\n    Py_XDECREF(infotuple);\n    return NULL;\n}\n\nstatic PyObject *b_new_enum_type(PyObject *self, PyObject *args)\n{\n    char *ename;\n    PyObject *enumerators, *enumvalues;\n    PyObject *dict1 = NULL, *dict2 = NULL, *combined = NULL, *tmpkey = NULL;\n    int name_size;\n    CTypeDescrObject *td, *basetd;\n    Py_ssize_t i, n;\n\n    if (!PyArg_ParseTuple(args, \"sO!O!O!:new_enum_type\",\n                          &ename,\n                          &PyTuple_Type, &enumerators,\n                          &PyTuple_Type, &enumvalues,\n                          &CTypeDescr_Type, &basetd))\n        return NULL;\n\n    n = PyTuple_GET_SIZE(enumerators);\n    if (n != PyTuple_GET_SIZE(enumvalues)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"tuple args must have the same size\");\n        return NULL;\n    }\n\n    if (!(basetd->ct_flags & (CT_PRIMITIVE_SIGNED|CT_PRIMITIVE_UNSIGNED))) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a primitive signed or unsigned base type\");\n        return NULL;\n    }\n\n    dict1 = PyDict_New();\n    if (dict1 == NULL)\n        goto error;\n    dict2 = PyDict_New();\n    if (dict2 == NULL)\n        goto error;\n\n    for (i=n; --i >= 0; ) {\n        long long lvalue;\n        PyObject *value = PyTuple_GET_ITEM(enumvalues, i);\n        tmpkey = PyTuple_GET_ITEM(enumerators, i);\n        Py_INCREF(tmpkey);\n        if (!PyText_Check(tmpkey)) {\n#if PY_MAJOR_VERSION < 3\n            if (PyUnicode_Check(tmpkey)) {\n                const char *text = PyText_AsUTF8(tmpkey);\n                if (text == NULL)\n                    goto error;\n                Py_DECREF(tmpkey);\n                tmpkey = PyString_FromString(text);\n                if (tmpkey == NULL)\n                    goto error;\n            }\n            else\n#endif\n            {\n                PyErr_SetString(PyExc_TypeError,\n                                \"enumerators must be a list of strings\");\n                goto error;\n            }\n        }\n        if (convert_from_object((char*)&lvalue, basetd, value) < 0)\n            goto error;     /* out-of-range or badly typed 'value' */\n        if (PyDict_SetItem(dict1, tmpkey, value) < 0)\n            goto error;\n        if (PyDict_SetItem(dict2, value, tmpkey) < 0)\n            goto error;\n        Py_DECREF(tmpkey);\n        tmpkey = NULL;\n    }\n\n    combined = PyTuple_Pack(2, dict1, dict2);\n    if (combined == NULL)\n        goto error;\n\n    Py_CLEAR(dict2);\n    Py_CLEAR(dict1);\n\n    name_size = strlen(ename) + 1;\n    td = ctypedescr_new(name_size);\n    if (td == NULL)\n        goto error;\n\n    memcpy(td->ct_name, ename, name_size);\n    td->ct_stuff = combined;\n    td->ct_size = basetd->ct_size;\n    td->ct_length = basetd->ct_length;   /* alignment */\n    td->ct_extra = basetd->ct_extra;     /* ffi type  */\n    td->ct_flags = basetd->ct_flags | CT_IS_ENUM;\n    td->ct_name_position = name_size - 1;\n    return (PyObject *)td;\n\n error:\n    Py_XDECREF(tmpkey);\n    Py_XDECREF(combined);\n    Py_XDECREF(dict2);\n    Py_XDECREF(dict1);\n    return NULL;\n}\n\nstatic PyObject *b_alignof(PyObject *self, PyObject *arg)\n{\n    int align;\n    if (!CTypeDescr_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'ctype' object\");\n        return NULL;\n    }\n    align = get_alignment((CTypeDescrObject *)arg);\n    if (align < 0)\n        return NULL;\n    return PyInt_FromLong(align);\n}\n\nstatic Py_ssize_t direct_sizeof_cdata(CDataObject *cd)\n{\n    Py_ssize_t size;\n    if (cd->c_type->ct_flags & CT_ARRAY)\n        size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n    else {\n        size = -1;\n        if (cd->c_type->ct_flags & (CT_STRUCT | CT_UNION))\n            size = _cdata_var_byte_size(cd);\n        if (size < 0)\n            size = cd->c_type->ct_size;\n    }\n    return size;\n}\n\nstatic PyObject *b_sizeof(PyObject *self, PyObject *arg)\n{\n    Py_ssize_t size;\n\n    if (CData_Check(arg)) {\n        size = direct_sizeof_cdata((CDataObject *)arg);\n    }\n    else if (CTypeDescr_Check(arg)) {\n        size = ((CTypeDescrObject *)arg)->ct_size;\n        if (size < 0) {\n            PyErr_Format(PyExc_ValueError, \"ctype '%s' is of unknown size\",\n                         ((CTypeDescrObject *)arg)->ct_name);\n            return NULL;\n        }\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a 'cdata' or 'ctype' object\");\n        return NULL;\n    }\n    return PyInt_FromSsize_t(size);\n}\n\nstatic PyObject *b_typeof(PyObject *self, PyObject *arg)\n{\n    PyObject *res;\n\n    if (!CData_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'cdata' object\");\n        return NULL;\n    }\n    res = (PyObject *)((CDataObject *)arg)->c_type;\n    Py_INCREF(res);\n    return res;\n}\n\nstatic CTypeDescrObject *direct_typeoffsetof(CTypeDescrObject *ct,\n                                             PyObject *fieldname,\n                                             int following, Py_ssize_t *offset)\n{\n    /* Does not return a new reference! */\n    CTypeDescrObject *res;\n    CFieldObject *cf;\n\n    if (PyTextAny_Check(fieldname)) {\n        if (!following && (ct->ct_flags & CT_POINTER))\n            ct = ct->ct_itemdescr;\n        if (!(ct->ct_flags & (CT_STRUCT|CT_UNION))) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"with a field name argument, expected a \"\n                            \"struct or union ctype\");\n            return NULL;\n        }\n        if (force_lazy_struct(ct) <= 0) {\n            if (!PyErr_Occurred())\n                PyErr_SetString(PyExc_TypeError, \"struct/union is opaque\");\n            return NULL;\n        }\n        cf = (CFieldObject *)PyDict_GetItem(ct->ct_stuff, fieldname);\n        if (cf == NULL) {\n            PyErr_SetObject(PyExc_KeyError, fieldname);\n            return NULL;\n        }\n        if (cf->cf_bitshift >= 0) {\n            PyErr_SetString(PyExc_TypeError, \"not supported for bitfields\");\n            return NULL;\n        }\n        res = cf->cf_type;\n        *offset = cf->cf_offset;\n    }\n    else {\n        Py_ssize_t index = PyInt_AsSsize_t(fieldname);\n        if (index < 0 && PyErr_Occurred()) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"field name or array index expected\");\n            return NULL;\n        }\n\n        if (!(ct->ct_flags & (CT_ARRAY|CT_POINTER)) ||\n                ct->ct_itemdescr->ct_size < 0) {\n            PyErr_SetString(PyExc_TypeError, \"with an integer argument, \"\n                                             \"expected an array ctype or a \"\n                                             \"pointer to non-opaque\");\n            return NULL;\n        }\n        res = ct->ct_itemdescr;\n        *offset = MUL_WRAPAROUND(index, ct->ct_itemdescr->ct_size);\n        if ((*offset / ct->ct_itemdescr->ct_size) != index) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"array offset would overflow a Py_ssize_t\");\n            return NULL;\n        }\n    }\n    return res;\n}\n\nstatic PyObject *b_typeoffsetof(PyObject *self, PyObject *args)\n{\n    PyObject *res, *fieldname;\n    CTypeDescrObject *ct;\n    Py_ssize_t offset;\n    int following = 0;\n\n    if (!PyArg_ParseTuple(args, \"O!O|i:typeoffsetof\",\n                          &CTypeDescr_Type, &ct, &fieldname, &following))\n        return NULL;\n\n    res = (PyObject *)direct_typeoffsetof(ct, fieldname, following, &offset);\n    if (res == NULL)\n        return NULL;\n\n    return Py_BuildValue(\"(On)\", res, offset);\n}\n\nstatic PyObject *b_rawaddressof(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    CDataObject *cd;\n    Py_ssize_t offset;\n    int accepted_flags;\n\n    if (!PyArg_ParseTuple(args, \"O!O!n:rawaddressof\",\n                          &CTypeDescr_Type, &ct,\n                          &CData_Type, &cd,\n                          &offset))\n        return NULL;\n\n    accepted_flags = CT_STRUCT | CT_UNION | CT_ARRAY | CT_POINTER;\n    if ((cd->c_type->ct_flags & accepted_flags) == 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a cdata struct/union/array/pointer object\");\n        return NULL;\n    }\n    if ((ct->ct_flags & CT_POINTER) == 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected a pointer ctype\");\n        return NULL;\n    }\n    return new_simple_cdata(cd->c_data + offset, ct);\n}\n\nstatic PyObject *b_getcname(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    char *replace_with, *p, *s;\n    Py_ssize_t namelen, replacelen;\n\n    if (!PyArg_ParseTuple(args, \"O!s:getcname\",\n                          &CTypeDescr_Type, &ct, &replace_with))\n        return NULL;\n\n    namelen = strlen(ct->ct_name);\n    replacelen = strlen(replace_with);\n    s = p = alloca(namelen + replacelen + 1);\n    memcpy(p, ct->ct_name, ct->ct_name_position);\n    p += ct->ct_name_position;\n    memcpy(p, replace_with, replacelen);\n    p += replacelen;\n    memcpy(p, ct->ct_name + ct->ct_name_position,\n           namelen - ct->ct_name_position);\n\n    return PyText_FromStringAndSize(s, namelen + replacelen);\n}\n\nstatic PyObject *b_string(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    CDataObject *cd;\n    Py_ssize_t maxlen = -1;\n    static char *keywords[] = {\"cdata\", \"maxlen\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!|n:string\", keywords,\n                                     &CData_Type, &cd, &maxlen))\n        return NULL;\n\n    if (cd->c_type->ct_itemdescr != NULL &&\n        cd->c_type->ct_itemdescr->ct_flags & (CT_PRIMITIVE_CHAR |\n                                              CT_PRIMITIVE_SIGNED |\n                                              CT_PRIMITIVE_UNSIGNED) &&\n        !(cd->c_type->ct_itemdescr->ct_flags & CT_IS_BOOL)) {\n        Py_ssize_t length = maxlen;\n        if (cd->c_data == NULL) {\n            PyObject *s = cdata_repr(cd);\n            if (s != NULL) {\n                PyErr_Format(PyExc_RuntimeError,\n                             \"cannot use string() on %s\",\n                             PyText_AS_UTF8(s));\n                Py_DECREF(s);\n            }\n            return NULL;\n        }\n        if (length < 0 && cd->c_type->ct_flags & CT_ARRAY) {\n            length = get_array_length(cd);\n        }\n        if (cd->c_type->ct_itemdescr->ct_size == sizeof(char)) {\n            const char *start = cd->c_data;\n            if (length < 0) {\n                /*READ(start, 1)*/\n                length = strlen(start);\n                /*READ(start, length)*/\n            }\n            else {\n                const char *end;\n                /*READ(start, length)*/\n                end = (const char *)memchr(start, 0, length);\n                if (end != NULL)\n                    length = end - start;\n            }\n            return PyBytes_FromStringAndSize(start, length);\n        }\n        else if (cd->c_type->ct_itemdescr->ct_flags & CT_PRIMITIVE_CHAR) {\n            switch (cd->c_type->ct_itemdescr->ct_size) {\n            case 2: {\n                const cffi_char16_t *start = (cffi_char16_t *)cd->c_data;\n                if (length < 0) {\n                    /*READ(start, 2)*/\n                    length = 0;\n                    while (start[length])\n                        length++;\n                    /*READ(start, 2 * length)*/\n                }\n                else {\n                    /*READ(start, 2 * length)*/\n                    maxlen = length;\n                    length = 0;\n                    while (length < maxlen && start[length])\n                        length++;\n                }\n                return _my_PyUnicode_FromChar16(start, length);\n            }\n            case 4: {\n                const cffi_char32_t *start = (cffi_char32_t *)cd->c_data;\n                if (length < 0) {\n                    /*READ(start, 4)*/\n                    length = 0;\n                    while (start[length])\n                        length++;\n                    /*READ(start, 4 * length)*/\n                }\n                else {\n                    /*READ(start, 4 * length)*/\n                    maxlen = length;\n                    length = 0;\n                    while (length < maxlen && start[length])\n                        length++;\n                }\n                return _my_PyUnicode_FromChar32(start, length);\n            }\n            }\n        }\n    }\n    else if (cd->c_type->ct_flags & CT_IS_ENUM) {\n        return convert_cdata_to_enum_string(cd, 0);\n    }\n    else if (cd->c_type->ct_flags & CT_IS_BOOL) {\n        /* fall through to TypeError */\n    }\n    else if (cd->c_type->ct_flags & (CT_PRIMITIVE_CHAR |\n                                     CT_PRIMITIVE_SIGNED |\n                                     CT_PRIMITIVE_UNSIGNED)) {\n        /*READ(cd->c_data, cd->c_type->ct_size)*/\n        if (cd->c_type->ct_size == sizeof(char))\n            return PyBytes_FromStringAndSize(cd->c_data, 1);\n        else if (cd->c_type->ct_flags & CT_PRIMITIVE_CHAR) {\n            switch (cd->c_type->ct_size) {\n            case 2:\n                return _my_PyUnicode_FromChar16((cffi_char16_t *)cd->c_data, 1);\n            case 4:\n                return _my_PyUnicode_FromChar32((cffi_char32_t *)cd->c_data, 1);\n            }\n        }\n    }\n    PyErr_Format(PyExc_TypeError, \"string(): unexpected cdata '%s' argument\",\n                 cd->c_type->ct_name);\n    return NULL;\n}\n\nstatic PyObject *b_unpack(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    CDataObject *cd;\n    CTypeDescrObject *ctitem;\n    Py_ssize_t i, length, itemsize;\n    PyObject *result;\n    char *src;\n    int casenum;\n    static char *keywords[] = {\"cdata\", \"length\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!n:unpack\", keywords,\n                                     &CData_Type, &cd, &length))\n        return NULL;\n\n    if (!(cd->c_type->ct_flags & (CT_ARRAY|CT_POINTER))) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array, got '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (length < 0) {\n        PyErr_SetString(PyExc_ValueError, \"'length' cannot be negative\");\n        return NULL;\n    }\n    if (cd->c_data == NULL) {\n        PyObject *s = cdata_repr(cd);\n        if (s != NULL) {\n            PyErr_Format(PyExc_RuntimeError,\n                         \"cannot use unpack() on %s\",\n                         PyText_AS_UTF8(s));\n            Py_DECREF(s);\n        }\n        return NULL;\n    }\n\n    /* byte- and unicode strings */\n    ctitem = cd->c_type->ct_itemdescr;\n    if (ctitem->ct_flags & CT_PRIMITIVE_CHAR) {\n        switch (ctitem->ct_size) {\n        case sizeof(char):\n            return PyBytes_FromStringAndSize(cd->c_data, length);\n        case 2:\n            return _my_PyUnicode_FromChar16((cffi_char16_t *)cd->c_data,length);\n        case 4:\n            return _my_PyUnicode_FromChar32((cffi_char32_t *)cd->c_data,length);\n        }\n    }\n\n    /* else, the result is a list.  This implementation should be\n       equivalent to but much faster than '[p[i] for i in range(length)]'.\n       (Note that on PyPy, 'list(p[0:length])' should be equally fast,\n       but arguably, finding out that there *is* such an unexpected way\n       to write things down is the real problem.)\n    */\n    result = PyList_New(length);\n    if (result == NULL)\n        return NULL;\n\n    src = cd->c_data;\n    itemsize = ctitem->ct_size;\n    if (itemsize < 0) {\n        Py_DECREF(result);\n        PyErr_Format(PyExc_ValueError, \"'%s' points to items of unknown size\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n\n    /* Determine some common fast-paths for the loop below.  The case -1\n       is the fall-back, which always gives the right answer. */\n\n#define ALIGNMENT_CHECK(align)                          \\\n        (((align) & ((align) - 1)) == 0 &&              \\\n         (((uintptr_t)src) & ((align) - 1)) == 0)\n\n    casenum = -1;\n\n    if ((ctitem->ct_flags & CT_PRIMITIVE_ANY) &&\n            ALIGNMENT_CHECK(ctitem->ct_length)) {\n        /* Source data is fully aligned; we can directly read without\n           memcpy().  The unaligned case is expected to be rare; in\n           this situation it is ok to fall back to the general\n           convert_to_object() in the loop.  For now we also use this\n           fall-back for types that are too large.\n        */\n        if (ctitem->ct_flags & CT_PRIMITIVE_SIGNED) {\n            if (itemsize == sizeof(long))             casenum = 3;\n            else if (itemsize == sizeof(int))         casenum = 2;\n            else if (itemsize == sizeof(short))       casenum = 1;\n            else if (itemsize == sizeof(signed char)) casenum = 0;\n        }\n        else if (ctitem->ct_flags & CT_PRIMITIVE_UNSIGNED) {\n            /* Note: we never pick case 6 if sizeof(int) == sizeof(long),\n               so that case 6 below can assume that the 'unsigned int' result\n               would always fit in a 'signed long'. */\n            if (ctitem->ct_flags & CT_IS_BOOL)           casenum = 11;\n            else if (itemsize == sizeof(unsigned long))  casenum = 7;\n            else if (itemsize == sizeof(unsigned int))   casenum = 6;\n            else if (itemsize == sizeof(unsigned short)) casenum = 5;\n            else if (itemsize == sizeof(unsigned char))  casenum = 4;\n        }\n        else if (ctitem->ct_flags & CT_PRIMITIVE_FLOAT) {\n            if      (itemsize == sizeof(double)) casenum = 9;\n            else if (itemsize == sizeof(float))  casenum = 8;\n        }\n    }\n    else if (ctitem->ct_flags & (CT_POINTER | CT_FUNCTIONPTR)) {\n        casenum = 10;    /* any pointer */\n    }\n#undef ALIGNMENT_CHECK\n\n    for (i = 0; i < length; i++) {\n        PyObject *x;\n        switch (casenum) {\n            /* general case */\n        default: x = convert_to_object(src, ctitem); break;\n\n            /* special cases for performance only */\n        case 0: x = PyInt_FromLong(*(signed char *)src); break;\n        case 1: x = PyInt_FromLong(*(short *)src); break;\n        case 2: x = PyInt_FromLong(*(int *)src); break;\n        case 3: x = PyInt_FromLong(*(long *)src); break;\n        case 4: x = PyInt_FromLong(*(unsigned char *)src); break;\n        case 5: x = PyInt_FromLong(*(unsigned short *)src); break;\n        case 6: x = PyInt_FromLong((long)*(unsigned int *)src); break;\n        case 7: x = PyLong_FromUnsignedLong(*(unsigned long *)src); break;\n        case 8: x = PyFloat_FromDouble(*(float *)src); break;\n        case 9: x = PyFloat_FromDouble(*(double *)src); break;\n        case 10: x = new_simple_cdata(*(char **)src, ctitem); break;\n        case 11:\n            switch (*(unsigned char *)src) {\n            case 0: x = Py_False; Py_INCREF(x); break;\n            case 1: x = Py_True;  Py_INCREF(x); break;\n            default: x = convert_to_object(src, ctitem); /* error */\n            }\n            break;\n        }\n        if (x == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        PyList_SET_ITEM(result, i, x);\n        src += itemsize;\n    }\n    return result;\n}\n\nstatic PyObject *\nb_buffer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    /* this is the constructor of the type implemented in minibuffer.h */\n    CDataObject *cd;\n    Py_ssize_t size = -1;\n    static char *keywords[] = {\"cdata\", \"size\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!|n:buffer\", keywords,\n                                     &CData_Type, &cd, &size))\n        return NULL;\n\n    if (size < 0)\n        size = _cdata_var_byte_size(cd);\n\n    if (cd->c_type->ct_flags & CT_POINTER) {\n        if (size < 0)\n            size = cd->c_type->ct_itemdescr->ct_size;\n    }\n    else if (cd->c_type->ct_flags & CT_ARRAY) {\n        if (size < 0)\n            size = get_array_length(cd) * cd->c_type->ct_itemdescr->ct_size;\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array cdata, got '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    if (size < 0) {\n        PyErr_Format(PyExc_TypeError,\n                     \"don't know the size pointed to by '%s'\",\n                     cd->c_type->ct_name);\n        return NULL;\n    }\n    /*WRITE(cd->c_data, size)*/\n    return minibuffer_new(cd->c_data, size, (PyObject *)cd);\n}\n\nstatic PyObject *b_get_errno(PyObject *self, PyObject *noarg)\n{\n    int err;\n    restore_errno_only();\n    err = errno;\n    errno = 0;\n    return PyInt_FromLong(err);\n}\n\nstatic PyObject *b_set_errno(PyObject *self, PyObject *arg)\n{\n    long ival = PyInt_AsLong(arg);\n    if (ival == -1 && PyErr_Occurred())\n        return NULL;\n    else if (ival < INT_MIN || ival > INT_MAX) {\n        PyErr_SetString(PyExc_OverflowError, \"errno value too large\");\n        return NULL;\n    }\n    errno = (int)ival;\n    save_errno_only();\n    errno = 0;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *newp_handle(CTypeDescrObject *ct_voidp, PyObject *x)\n{\n    CDataObject_own_structptr *cd;\n    cd = (CDataObject_own_structptr *)PyObject_GC_New(CDataObject_own_structptr,\n                                                      &CDataOwningGC_Type);\n    if (cd == NULL)\n        return NULL;\n    Py_INCREF(ct_voidp);        /* must be \"void *\" */\n    cd->head.c_type = ct_voidp;\n    cd->head.c_data = (char *)cd;\n    cd->head.c_weakreflist = NULL;\n    Py_INCREF(x);\n    cd->structobj = x;\n    PyObject_GC_Track(cd);\n    return (PyObject *)cd;\n}\n\nstatic PyObject *b_newp_handle(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *x;\n    if (!PyArg_ParseTuple(args, \"O!O\", &CTypeDescr_Type, &ct, &x))\n        return NULL;\n\n    if (!(ct->ct_flags & CT_IS_VOID_PTR)) {\n        PyErr_Format(PyExc_TypeError, \"needs 'void *', got '%s'\", ct->ct_name);\n        return NULL;\n    }\n\n    return newp_handle(ct, x);\n}\n\nstatic PyObject *b_from_handle(PyObject *self, PyObject *arg)\n{\n    CTypeDescrObject *ct;\n    CDataObject_own_structptr *orgcd;\n    PyObject *x;\n    if (!CData_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'cdata' object\");\n        return NULL;\n    }\n    ct = ((CDataObject *)arg)->c_type;\n    if (!(ct->ct_flags & CT_IS_VOIDCHAR_PTR)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a 'cdata' object with a 'void *' out of \"\n                     \"new_handle(), got '%s'\", ct->ct_name);\n        return NULL;\n    }\n    orgcd = (CDataObject_own_structptr *)((CDataObject *)arg)->c_data;\n    if (!orgcd) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"cannot use from_handle() on NULL pointer\");\n        return NULL;\n    }\n    if (Py_REFCNT(orgcd) <= 0 || Py_TYPE(orgcd) != &CDataOwningGC_Type) {\n        Py_FatalError(\"ffi.from_handle() detected that the address passed \"\n                      \"points to garbage. If it is really the result of \"\n                      \"ffi.new_handle(), then the Python object has already \"\n                      \"been garbage collected\");\n    }\n    x = orgcd->structobj;\n    Py_INCREF(x);\n    return x;\n}\n\nstatic int _my_PyObject_GetContiguousBuffer(PyObject *x, Py_buffer *view,\n                                            int writable_only)\n{\n#if PY_MAJOR_VERSION < 3\n    /* Some objects only support the buffer interface and CPython doesn't\n       translate it into the memoryview interface, mess.  Hack a very\n       minimal content for 'view'.  Don't care if the other fields are\n       uninitialized: we only call PyBuffer_Release(), which only reads\n       'view->obj'. */\n    PyBufferProcs *pb = x->ob_type->tp_as_buffer;\n    if (pb && !pb->bf_releasebuffer) {\n        /* we used to try all three in some vaguely sensible order,\n           i.e. first the write.  But trying to call the write on a\n           read-only buffer fails with TypeError.  So we use a less-\n           sensible order now.  See test_from_buffer_more_cases.\n\n           If 'writable_only', we only try bf_getwritebuffer.\n        */\n        readbufferproc proc = NULL;\n        if (!writable_only) {\n            proc = (readbufferproc)pb->bf_getreadbuffer;\n            if (!proc)\n                proc = (readbufferproc)pb->bf_getcharbuffer;\n        }\n        if (!proc)\n            proc = (readbufferproc)pb->bf_getwritebuffer;\n\n        if (proc && pb->bf_getsegcount) {\n            if ((*pb->bf_getsegcount)(x, NULL) != 1) {\n                PyErr_SetString(PyExc_TypeError,\n                                \"expected a single-segment buffer object\");\n                return -1;\n            }\n            view->len = (*proc)(x, 0, &view->buf);\n            if (view->len < 0)\n                return -1;\n            view->obj = x;\n            Py_INCREF(x);\n            return 0;\n        }\n    }\n#endif\n\n    if (PyObject_GetBuffer(x, view, writable_only ? PyBUF_WRITABLE\n                                                  : PyBUF_SIMPLE) < 0)\n        return -1;\n\n    if (!PyBuffer_IsContiguous(view, 'A')) {\n        PyBuffer_Release(view);\n        PyErr_SetString(PyExc_TypeError, \"contiguous buffer expected\");\n        return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *direct_from_buffer(CTypeDescrObject *ct, PyObject *x,\n                                    int require_writable)\n{\n    CDataObject *cd;\n    Py_buffer *view;\n    Py_ssize_t arraylength, minimumlength = 0;\n\n    if (!(ct->ct_flags & (CT_ARRAY | CT_POINTER))) {\n        PyErr_Format(PyExc_TypeError,\n                     \"expected a pointer or array ctype, got '%s'\",\n                     ct->ct_name);\n        return NULL;\n    }\n\n    /* PyPy 5.7 can obtain buffers for string (python 2)\n       or bytes (python 3). from_buffer(u\"foo\") is disallowed.\n     */\n    if (PyUnicode_Check(x)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"from_buffer() cannot return the address \"\n                        \"of a unicode object\");\n        return NULL;\n    }\n\n    view = PyObject_Malloc(sizeof(Py_buffer));\n    if (view == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    if (_my_PyObject_GetContiguousBuffer(x, view, require_writable) < 0)\n        goto error1;\n\n    if (ct->ct_flags & CT_POINTER)\n    {\n        arraylength = view->len;   /* number of bytes, not used so far */\n    }\n    else {\n        /* ct->ct_flags & CT_ARRAY */\n        if (ct->ct_length >= 0) {\n            /* it's an array with a fixed length; make sure that the\n               buffer contains enough bytes. */\n            minimumlength = ct->ct_size;\n            arraylength = ct->ct_length;\n        }\n        else {\n            /* it's an open 'array[]' */\n            if (ct->ct_itemdescr->ct_size == 1) {\n                /* fast path, performance only */\n                arraylength = view->len;\n            }\n            else if (ct->ct_itemdescr->ct_size > 0) {\n                /* give it as many items as fit the buffer.  Ignore a\n                   partial last element. */\n                arraylength = view->len / ct->ct_itemdescr->ct_size;\n            }\n            else {\n                /* it's an array 'empty[]'.  Unsupported obscure case:\n                   the problem is that setting the length of the result\n                   to anything large (like SSIZE_T_MAX) is dangerous,\n                   because if someone tries to loop over it, it will\n                   turn effectively into an infinite loop. */\n                PyErr_Format(PyExc_ZeroDivisionError,\n                    \"from_buffer('%s', ..): the actual length of the array \"\n                    \"cannot be computed\", ct->ct_name);\n                goto error2;\n            }\n        }\n    }\n    if (view->len < minimumlength) {\n        PyErr_Format(PyExc_ValueError,\n            \"buffer is too small (%zd bytes) for '%s' (%zd bytes)\",\n            view->len, ct->ct_name, minimumlength);\n        goto error2;\n    }\n\n    cd = (CDataObject *)PyObject_GC_New(CDataObject_frombuf,\n                                        &CDataFromBuf_Type);\n    if (cd == NULL)\n        goto error2;\n\n    Py_INCREF(ct);\n    cd->c_type = ct;\n    cd->c_data = view->buf;\n    cd->c_weakreflist = NULL;\n    ((CDataObject_frombuf *)cd)->length = arraylength;\n    ((CDataObject_frombuf *)cd)->bufferview = view;\n    PyObject_GC_Track(cd);\n    return (PyObject *)cd;\n\n error2:\n    PyBuffer_Release(view);\n error1:\n    PyObject_Free(view);\n    return NULL;\n}\n\nstatic PyObject *b_from_buffer(PyObject *self, PyObject *args)\n{\n    CTypeDescrObject *ct;\n    PyObject *x;\n    int require_writable = 0;\n\n    if (!PyArg_ParseTuple(args, \"O!O|i\", &CTypeDescr_Type, &ct, &x,\n                          &require_writable))\n        return NULL;\n\n    return direct_from_buffer(ct, x, require_writable);\n}\n\nstatic int _fetch_as_buffer(PyObject *x, Py_buffer *view, int writable_only)\n{\n    if (CData_Check(x)) {\n        CTypeDescrObject *ct = ((CDataObject *)x)->c_type;\n        if (!(ct->ct_flags & (CT_POINTER|CT_ARRAY))) {\n            PyErr_Format(PyExc_TypeError,\n                         \"expected a pointer or array ctype, got '%s'\",\n                         ct->ct_name);\n            return -1;\n        }\n        view->buf = ((CDataObject *)x)->c_data;\n        view->obj = NULL;\n        return 0;\n    }\n    else {\n        return _my_PyObject_GetContiguousBuffer(x, view, writable_only);\n    }\n}\n\nstatic PyObject *b_memmove(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *dest_obj, *src_obj;\n    Py_buffer dest_view, src_view;\n    Py_ssize_t n;\n    static char *keywords[] = {\"dest\", \"src\", \"n\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"OOn\", keywords,\n                                     &dest_obj, &src_obj, &n))\n        return NULL;\n    if (n < 0) {\n        PyErr_SetString(PyExc_ValueError, \"negative size\");\n        return NULL;\n    }\n\n    if (_fetch_as_buffer(src_obj, &src_view, 0) < 0) {\n        return NULL;\n    }\n    if (_fetch_as_buffer(dest_obj, &dest_view, 1) < 0) {\n        PyBuffer_Release(&src_view);\n        return NULL;\n    }\n\n    memmove(dest_view.buf, src_view.buf, n);\n\n    PyBuffer_Release(&dest_view);\n    PyBuffer_Release(&src_view);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *b__get_types(PyObject *self, PyObject *noarg)\n{\n    return PyTuple_Pack(2, (PyObject *)&CData_Type,\n                           (PyObject *)&CTypeDescr_Type);\n}\n\n/* forward, in commontypes.c */\nstatic PyObject *b__get_common_types(PyObject *self, PyObject *arg);\n\nstatic PyObject *b_gcp(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    CDataObject *cd;\n    CDataObject *origobj;\n    PyObject *destructor;\n    Py_ssize_t ignored;   /* for pypy */\n    static char *keywords[] = {\"cdata\", \"destructor\", \"size\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"O!O|n:gc\", keywords,\n                                     &CData_Type, &origobj, &destructor,\n                                     &ignored))\n        return NULL;\n\n    if (destructor == Py_None) {\n\tif (!PyObject_TypeCheck(origobj, &CDataGCP_Type)) {\n\t    PyErr_SetString(PyExc_TypeError,\n\t\t\t    \"Can remove destructor only on a object \"\n\t\t\t    \"previously returned by ffi.gc()\");\n\t    return NULL;\n\t}\n\tPy_CLEAR(((CDataObject_gcp *)origobj)->destructor);\n\tPy_RETURN_NONE;\n    }\n\n    cd = allocate_gcp_object(origobj, origobj->c_type, destructor);\n    return (PyObject *)cd;\n}\n\nstatic PyObject *b_release(PyObject *self, PyObject *arg)\n{\n    if (!CData_Check(arg)) {\n        PyErr_SetString(PyExc_TypeError, \"expected a 'cdata' object\");\n        return NULL;\n    }\n    return cdata_exit(arg, NULL);\n}\n\n/************************************************************/\n\nstatic char _testfunc0(char a, char b)\n{\n    return a + b;\n}\nstatic long _testfunc1(int a, long b)\n{\n    return (long)a + b;\n}\nstatic PY_LONG_LONG _testfunc2(PY_LONG_LONG a, PY_LONG_LONG b)\n{\n    return a + b;\n}\nstatic double _testfunc3(float a, double b)\n{\n    return a + b;\n}\nstatic float _testfunc4(float a, double b)\n{\n    return (float)(a + b);\n}\nstatic void _testfunc5(void)\n{\n    errno = errno + 15;\n}\nstatic int *_testfunc6(int *x)\n{\n    static int y;\n    y = *x - 1000;\n    return &y;\n}\nstruct _testfunc7_s { unsigned char a1; short a2; };\nstatic short _testfunc7(struct _testfunc7_s inlined)\n{\n    return inlined.a1 + inlined.a2;\n}\nstatic int _testfunc9(int num, ...)\n{\n    va_list vargs;\n    int i, total = 0;\n    va_start(vargs, num);\n    for (i=0; i<num; i++) {\n        int value = va_arg(vargs, int);\n        if (value == 0)\n            value = -66666666;\n        total += value;\n    }\n    va_end(vargs);\n    return total;\n}\n\nstatic struct _testfunc7_s _testfunc10(int n)\n{\n    struct _testfunc7_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc11_s { int a1, a2; };\nstatic struct _testfunc11_s _testfunc11(int n)\n{\n    struct _testfunc11_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc12_s { double a1; };\nstatic struct _testfunc12_s _testfunc12(int n)\n{\n    struct _testfunc12_s result;\n    result.a1 = n;\n    return result;\n}\n\nstruct _testfunc13_s { int a1, a2, a3; };\nstatic struct _testfunc13_s _testfunc13(int n)\n{\n    struct _testfunc13_s result;\n    result.a1 = n;\n    result.a2 = n * n;\n    result.a3 = n * n * n;\n    return result;\n}\n\nstruct _testfunc14_s { float a1; };\nstatic struct _testfunc14_s _testfunc14(int n)\n{\n    struct _testfunc14_s result;\n    result.a1 = (float)n;\n    return result;\n}\n\nstruct _testfunc15_s { float a1; int a2; };\nstatic struct _testfunc15_s _testfunc15(int n)\n{\n    struct _testfunc15_s result;\n    result.a1 = (float)n;\n    result.a2 = n * n;\n    return result;\n}\n\nstruct _testfunc16_s { float a1, a2; };\nstatic struct _testfunc16_s _testfunc16(int n)\n{\n    struct _testfunc16_s result;\n    result.a1 = (float)n;\n    result.a2 = -(float)n;\n    return result;\n}\n\nstruct _testfunc17_s { int a1; float a2; };\nstatic struct _testfunc17_s _testfunc17(int n)\n{\n    struct _testfunc17_s result;\n    result.a1 = n;\n    result.a2 = (float)n * (float)n;\n    return result;\n}\n\nstatic int _testfunc18(struct _testfunc17_s *ptr)\n{\n    return ptr->a1 + (int)ptr->a2;\n}\n\nstatic long double _testfunc19(long double x, int count)\n{\n    int i;\n    for (i=0; i<count; i++) {\n        x = 4*x - x*x;\n    }\n    return x;\n}\n\nstatic short _testfunc20(struct _testfunc7_s *ptr)\n{\n    return ptr->a1 + ptr->a2;\n}\n\nstruct _testfunc21_s { int a, b, c, d, e, f, g, h, i, j; };\nstatic int _testfunc21(struct _testfunc21_s inlined)\n{\n    return ((inlined.a << 0) +\n            (inlined.b << 1) +\n            (inlined.c << 2) +\n            (inlined.d << 3) +\n            (inlined.e << 4) +\n            (inlined.f << 5) +\n            (inlined.g << 6) +\n            (inlined.h << 7) +\n            (inlined.i << 8) +\n            (inlined.j << 9));\n}\n\nstruct _testfunc22_s { int a[10]; };\nstatic struct _testfunc22_s _testfunc22(struct _testfunc22_s s1,\n                                        struct _testfunc22_s s2)\n{\n    struct _testfunc22_s result;\n    int i;\n    for (i=0; i<10; i++)\n        result.a[i] = s1.a[i] - s2.a[i];\n    return result;\n}\n\nstatic int _testfunc23(char *p)\n{\n    if (p)\n        return 1000 * p[0];\n    return -42;\n}\n\n#if 0   /* libffi doesn't properly support complexes currently */\n        /* also, MSVC might not support _Complex... */\n        /* if this is enabled one day, remember to also add _Complex\n         * arguments in addition to return values. */\nstatic float _Complex _testfunc24(float a, float b)\n{\n    return a + I*2.0*b;\n}\nstatic double _Complex _testfunc25(double a, double b)\n{\n    return a + I*2.0*b;\n}\n#endif\n\nstatic PyObject *b__testfunc(PyObject *self, PyObject *args)\n{\n    /* for testing only */\n    int i;\n    void *f;\n    if (!PyArg_ParseTuple(args, \"i:_testfunc\", &i))\n        return NULL;\n    switch (i) {\n    case 0: f = &_testfunc0; break;\n    case 1: f = &_testfunc1; break;\n    case 2: f = &_testfunc2; break;\n    case 3: f = &_testfunc3; break;\n    case 4: f = &_testfunc4; break;\n    case 5: f = &_testfunc5; break;\n    case 6: f = &_testfunc6; break;\n    case 7: f = &_testfunc7; break;\n    case 8: f = stderr; break;\n    case 9: f = &_testfunc9; break;\n    case 10: f = &_testfunc10; break;\n    case 11: f = &_testfunc11; break;\n    case 12: f = &_testfunc12; break;\n    case 13: f = &_testfunc13; break;\n    case 14: f = &_testfunc14; break;\n    case 15: f = &_testfunc15; break;\n    case 16: f = &_testfunc16; break;\n    case 17: f = &_testfunc17; break;\n    case 18: f = &_testfunc18; break;\n    case 19: f = &_testfunc19; break;\n    case 20: f = &_testfunc20; break;\n    case 21: f = &_testfunc21; break;\n    case 22: f = &_testfunc22; break;\n    case 23: f = &_testfunc23; break;\n#if 0\n    case 24: f = &_testfunc24; break;\n    case 25: f = &_testfunc25; break;\n#endif\n    default:\n        PyErr_SetNone(PyExc_ValueError);\n        return NULL;\n    }\n    return PyLong_FromVoidPtr(f);\n}\n\n#if PY_MAJOR_VERSION < 3\nstatic Py_ssize_t _test_segcountproc(PyObject *o, Py_ssize_t *ignored)\n{\n    return 1;\n}\nstatic Py_ssize_t _test_getreadbuf(PyObject *o, Py_ssize_t i, void **r)\n{\n    static char buf[] = \"RDB\";\n    *r = buf;\n    return 3;\n}\nstatic Py_ssize_t _test_getwritebuf(PyObject *o, Py_ssize_t i, void **r)\n{\n    static char buf[] = \"WRB\";\n    *r = buf;\n    return 3;\n}\nstatic Py_ssize_t _test_getcharbuf(PyObject *o, Py_ssize_t i, char **r)\n{\n    static char buf[] = \"CHB\";\n    *r = buf;\n    return 3;\n}\n#endif\nstatic int _test_getbuf(PyObject *self, Py_buffer *view, int flags)\n{\n    static char buf[] = \"GTB\";\n    return PyBuffer_FillInfo(view, self, buf, 3, /*readonly=*/0, flags);\n}\nstatic int _test_getbuf_ro(PyObject *self, Py_buffer *view, int flags)\n{\n    static char buf[] = \"ROB\";\n    return PyBuffer_FillInfo(view, self, buf, 3, /*readonly=*/1, flags);\n}\n\n\nstatic PyObject *b__testbuff(PyObject *self, PyObject *args)\n{\n    /* for testing only */\n    int methods;\n    PyTypeObject *obj;\n    if (!PyArg_ParseTuple(args, \"O!i|_testbuff\", &PyType_Type, &obj, &methods))\n        return NULL;\n\n    assert(obj->tp_as_buffer != NULL);\n\n#if PY_MAJOR_VERSION < 3\n    obj->tp_as_buffer->bf_getsegcount = &_test_segcountproc;\n    obj->tp_flags |= Py_TPFLAGS_HAVE_GETCHARBUFFER;\n    obj->tp_flags |= Py_TPFLAGS_HAVE_NEWBUFFER;\n    if (methods & 1)  obj->tp_as_buffer->bf_getreadbuffer  = &_test_getreadbuf;\n    if (methods & 2)  obj->tp_as_buffer->bf_getwritebuffer = &_test_getwritebuf;\n    if (methods & 4)  obj->tp_as_buffer->bf_getcharbuffer  = &_test_getcharbuf;\n#endif\n    if (methods & 8)  obj->tp_as_buffer->bf_getbuffer      = &_test_getbuf;\n    if (methods & 16) obj->tp_as_buffer->bf_getbuffer      = &_test_getbuf_ro;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *b_init_cffi_1_0_external_module(PyObject *, PyObject *);\n/* forward, see cffi1_module.c */\n\n\nstatic PyMethodDef FFIBackendMethods[] = {\n    {\"load_library\", b_load_library, METH_VARARGS},\n    {\"new_primitive_type\", b_new_primitive_type, METH_VARARGS},\n    {\"new_pointer_type\", b_new_pointer_type, METH_VARARGS},\n    {\"new_array_type\", b_new_array_type, METH_VARARGS},\n    {\"new_void_type\", b_new_void_type, METH_NOARGS},\n    {\"new_struct_type\", b_new_struct_type, METH_VARARGS},\n    {\"new_union_type\", b_new_union_type, METH_VARARGS},\n    {\"complete_struct_or_union\", b_complete_struct_or_union, METH_VARARGS},\n    {\"new_function_type\", b_new_function_type, METH_VARARGS},\n    {\"new_enum_type\", b_new_enum_type, METH_VARARGS},\n    {\"newp\", b_newp, METH_VARARGS},\n    {\"cast\", b_cast, METH_VARARGS},\n    {\"callback\", b_callback, METH_VARARGS},\n    {\"alignof\", b_alignof, METH_O},\n    {\"sizeof\", b_sizeof, METH_O},\n    {\"typeof\", b_typeof, METH_O},\n    {\"typeoffsetof\", b_typeoffsetof, METH_VARARGS},\n    {\"rawaddressof\", b_rawaddressof, METH_VARARGS},\n    {\"getcname\", b_getcname, METH_VARARGS},\n    {\"string\", (PyCFunction)b_string, METH_VARARGS | METH_KEYWORDS},\n    {\"unpack\", (PyCFunction)b_unpack, METH_VARARGS | METH_KEYWORDS},\n    {\"get_errno\", b_get_errno, METH_NOARGS},\n    {\"set_errno\", b_set_errno, METH_O},\n    {\"newp_handle\", b_newp_handle, METH_VARARGS},\n    {\"from_handle\", b_from_handle, METH_O},\n    {\"from_buffer\", b_from_buffer, METH_VARARGS},\n    {\"memmove\", (PyCFunction)b_memmove, METH_VARARGS | METH_KEYWORDS},\n    {\"gcp\", (PyCFunction)b_gcp, METH_VARARGS | METH_KEYWORDS},\n    {\"release\", b_release, METH_O},\n#ifdef MS_WIN32\n    {\"getwinerror\", (PyCFunction)b_getwinerror, METH_VARARGS | METH_KEYWORDS},\n#endif\n    {\"_get_types\", b__get_types, METH_NOARGS},\n    {\"_get_common_types\", b__get_common_types, METH_O},\n    {\"_testfunc\", b__testfunc, METH_VARARGS},\n    {\"_testbuff\", b__testbuff, METH_VARARGS},\n    {\"_init_cffi_1_0_external_module\", b_init_cffi_1_0_external_module, METH_O},\n    {NULL,     NULL}    /* Sentinel */\n};\n\n/************************************************************/\n/* Functions used by '_cffi_N.so', the generated modules    */\n\n#define _cffi_to_c_SIGNED_FN(RETURNTYPE, SIZE)                          \\\nstatic RETURNTYPE _cffi_to_c_i##SIZE(PyObject *obj) {                   \\\n    PY_LONG_LONG tmp = _my_PyLong_AsLongLong(obj);                      \\\n    if ((tmp > (PY_LONG_LONG)((1ULL<<(SIZE-1)) - 1)) ||                 \\\n        (tmp < (PY_LONG_LONG)(0ULL-(1ULL<<(SIZE-1)))))                  \\\n        if (!PyErr_Occurred())                                          \\\n            return (RETURNTYPE)_convert_overflow(obj, #SIZE \"-bit int\"); \\\n    return (RETURNTYPE)tmp;                                             \\\n}\n\n#define _cffi_to_c_UNSIGNED_FN(RETURNTYPE, SIZE)                        \\\nstatic RETURNTYPE _cffi_to_c_u##SIZE(PyObject *obj) {                   \\\n    unsigned PY_LONG_LONG tmp = _my_PyLong_AsUnsignedLongLong(obj, 1);  \\\n    if (tmp > ~(((unsigned PY_LONG_LONG)-2) << (SIZE-1)))               \\\n        if (!PyErr_Occurred())                                          \\\n            return (RETURNTYPE)_convert_overflow(obj,                   \\\n                                   #SIZE \"-bit unsigned int\");          \\\n    return (RETURNTYPE)tmp;                                             \\\n}\n\n_cffi_to_c_SIGNED_FN(int, 8)\n_cffi_to_c_SIGNED_FN(int, 16)\n_cffi_to_c_SIGNED_FN(int, 32)\n_cffi_to_c_SIGNED_FN(PY_LONG_LONG, 64)\n_cffi_to_c_UNSIGNED_FN(int, 8)\n_cffi_to_c_UNSIGNED_FN(int, 16)\n_cffi_to_c_UNSIGNED_FN(unsigned int, 32)\n_cffi_to_c_UNSIGNED_FN(unsigned PY_LONG_LONG, 64)\n\nstatic PyObject *_cffi_from_c_pointer(char *ptr, CTypeDescrObject *ct)\n{\n    return convert_to_object((char *)&ptr, ct);\n}\n\nstatic char *_cffi_to_c_pointer(PyObject *obj, CTypeDescrObject *ct)\n{\n    char *result;\n    if (convert_from_object((char *)&result, ct, obj) < 0) {\n        if ((ct->ct_flags & CT_POINTER) &&\n                (ct->ct_itemdescr->ct_flags & CT_IS_FILE) &&\n                PyFile_Check(obj)) {\n            PyErr_Clear();\n            return (char *)PyFile_AsFile(obj);\n        }\n        return NULL;\n    }\n    return result;\n}\n\nstatic long double _cffi_to_c_long_double(PyObject *obj)\n{\n    if (CData_Check(obj) &&\n            (((CDataObject *)obj)->c_type->ct_flags & CT_IS_LONGDOUBLE)) {\n        char *data = ((CDataObject *)obj)->c_data;\n        /*READ(data, sizeof(long double))*/\n        return read_raw_longdouble_data(data);\n    }\n    else\n        return PyFloat_AsDouble(obj);\n}\n\nstatic _Bool _cffi_to_c__Bool(PyObject *obj)\n{\n    PY_LONG_LONG tmp = _my_PyLong_AsLongLong(obj);\n    if (tmp == 0)\n        return 0;\n    else if (tmp == 1)\n        return 1;\n    else if (PyErr_Occurred())\n        return (_Bool)-1;\n    else\n        return (_Bool)_convert_overflow(obj, \"_Bool\");\n}\n\nstatic PyObject *_cffi_get_struct_layout(Py_ssize_t nums[])\n{\n    PyObject *result;\n    int count = 0;\n    while (nums[count] >= 0)\n        count++;\n\n    result = PyList_New(count);\n    if (result == NULL)\n        return NULL;\n\n    while (--count >= 0) {\n        PyObject *o = PyInt_FromSsize_t(nums[count]);\n        if (o == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        PyList_SET_ITEM(result, count, o);\n    }\n    return result;\n}\n\nstatic PyObject *_cffi_from_c_char(char x) {\n    return PyBytes_FromStringAndSize(&x, 1);\n}\n\n/* backward-compatibility hack: instead of _cffi_to_c_char16_t() and\n * _cffi_to_c_char32_t(), we have _cffi_to_c_wchar_t() handling whatever\n * size is wchar_t, and _cffi_to_c_wchar3216_t() handling the opposite.\n */\n#ifdef HAVE_WCHAR_H\ntypedef wchar_t cffi_wchar_t;\n#else\ntypedef uint16_t cffi_wchar_t;   /* random pick... */\n#endif\n\nstatic cffi_wchar_t _cffi_to_c_wchar_t(PyObject *init)\n{\n    if (sizeof(cffi_wchar_t) == 2)\n        return (cffi_wchar_t)_convert_to_char16_t(init);\n    else\n        return (cffi_wchar_t)_convert_to_char32_t(init);\n}\nstatic PyObject *_cffi_from_c_wchar_t(cffi_wchar_t x) {\n    if (sizeof(cffi_wchar_t) == 2) {\n        cffi_char16_t input = x;\n        return _my_PyUnicode_FromChar16(&input, 1);\n    }\n    else {\n        cffi_char32_t input = x;\n        return _my_PyUnicode_FromChar32(&input, 1);\n    }\n}\nstatic int _cffi_to_c_wchar3216_t(PyObject *init)\n{\n    if (sizeof(cffi_wchar_t) == 4)\n        return (int)_convert_to_char16_t(init);\n    else\n        return (int)_convert_to_char32_t(init);\n}\nstatic PyObject *_cffi_from_c_wchar3216_t(int x) {\n    if (sizeof(cffi_wchar_t) == 4) {\n        cffi_char16_t input = x;\n        return _my_PyUnicode_FromChar16(&input, 1);\n    }\n    else {\n        cffi_char32_t input = x;\n        return _my_PyUnicode_FromChar32(&input, 1);\n    }\n}\n\nstruct _cffi_externpy_s;      /* forward declaration */\nstatic void cffi_call_python(struct _cffi_externpy_s *, char *args);\n\nstatic void *cffi_exports[] = {\n    NULL,\n    _cffi_to_c_i8,\n    _cffi_to_c_u8,\n    _cffi_to_c_i16,\n    _cffi_to_c_u16,\n    _cffi_to_c_i32,\n    _cffi_to_c_u32,\n    _cffi_to_c_i64,\n    _cffi_to_c_u64,\n    _convert_to_char,\n    _cffi_from_c_pointer,\n    _cffi_to_c_pointer,\n    _cffi_get_struct_layout,\n    restore_errno,\n    save_errno,\n    _cffi_from_c_char,\n    convert_to_object,\n    convert_from_object,\n    convert_struct_to_owning_object,\n    _cffi_to_c_wchar_t,\n    _cffi_from_c_wchar_t,\n    _cffi_to_c_long_double,\n    _cffi_to_c__Bool,\n    _prepare_pointer_call_argument,\n    convert_array_from_object,\n    cffi_call_python,\n    _cffi_to_c_wchar3216_t,\n    _cffi_from_c_wchar3216_t,\n};\n\nstatic struct { const char *name; int value; } all_dlopen_flags[] = {\n    { \"RTLD_LAZY\",     RTLD_LAZY     },\n    { \"RTLD_NOW\",      RTLD_NOW      },\n    { \"RTLD_GLOBAL\",   RTLD_GLOBAL   },\n#ifdef RTLD_LOCAL\n    { \"RTLD_LOCAL\",    RTLD_LOCAL    },\n#else\n    { \"RTLD_LOCAL\",    0             },\n#endif\n#ifdef RTLD_NODELETE\n    { \"RTLD_NODELETE\", RTLD_NODELETE },\n#endif\n#ifdef RTLD_NOLOAD\n    { \"RTLD_NOLOAD\",   RTLD_NOLOAD   },\n#endif\n#ifdef RTLD_DEEPBIND\n    { \"RTLD_DEEPBIND\", RTLD_DEEPBIND },\n#endif\n    { NULL, 0 }\n};\n\n\n/************************************************************/\n\n#include \"cffi1_module.c\"\n\n/************************************************************/\n\n#if PY_MAJOR_VERSION >= 3\nstatic struct PyModuleDef FFIBackendModuleDef = {\n  PyModuleDef_HEAD_INIT,\n  \"_cffi_backend\",\n  NULL,\n  -1,\n  FFIBackendMethods,\n  NULL, NULL, NULL, NULL\n};\n#define INITERROR return NULL\n\nPyMODINIT_FUNC\nPyInit__cffi_backend(void)\n#else\n#define INITERROR return\n\nPyMODINIT_FUNC\ninit_cffi_backend(void)\n#endif\n{\n    PyObject *m, *v;\n    int i;\n    static char init_done = 0;\n\n    v = PySys_GetObject(\"version\");\n    if (v == NULL || !PyText_Check(v) ||\n            strncmp(PyText_AS_UTF8(v), PY_VERSION, 3) != 0) {\n        PyErr_Format(PyExc_ImportError,\n                     \"this module was compiled for Python %c%c%c\",\n                     PY_VERSION[0], PY_VERSION[1], PY_VERSION[2]);\n        INITERROR;\n    }\n\n#if PY_MAJOR_VERSION >= 3\n    m = PyModule_Create(&FFIBackendModuleDef);\n#else\n    m = Py_InitModule(\"_cffi_backend\", FFIBackendMethods);\n#endif\n\n    if (m == NULL)\n        INITERROR;\n\n    if (unique_cache == NULL) {\n        unique_cache = PyDict_New();\n        if (unique_cache == NULL)\n            INITERROR;\n    }\n\n    if (PyType_Ready(&dl_type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CTypeDescr_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CField_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CData_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataOwning_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataOwningGC_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataFromBuf_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataGCP_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&CDataIter_Type) < 0)\n        INITERROR;\n    if (PyType_Ready(&MiniBuffer_Type) < 0)\n        INITERROR;\n\n    if (!init_done) {\n        v = PyText_FromString(\"_cffi_backend\");\n        if (v == NULL || PyDict_SetItemString(CData_Type.tp_dict,\n                                              \"__module__\", v) < 0)\n            INITERROR;\n        v = PyText_FromString(\"<cdata>\");\n        if (v == NULL || PyDict_SetItemString(CData_Type.tp_dict,\n                                              \"__name__\", v) < 0)\n            INITERROR;\n        init_done = 1;\n    }\n\n    /* this is for backward compatibility only */\n    v = PyCapsule_New((void *)cffi_exports, \"cffi\", NULL);\n    if (v == NULL || PyModule_AddObject(m, \"_C_API\", v) < 0)\n        INITERROR;\n\n    v = PyText_FromString(CFFI_VERSION);\n    if (v == NULL || PyModule_AddObject(m, \"__version__\", v) < 0)\n        INITERROR;\n\n    if (PyModule_AddIntConstant(m, \"FFI_DEFAULT_ABI\", FFI_DEFAULT_ABI) < 0 ||\n#if defined(MS_WIN32) && !defined(_WIN64)\n        PyModule_AddIntConstant(m, \"FFI_STDCALL\", FFI_STDCALL) < 0 ||\n#endif\n        PyModule_AddIntConstant(m, \"FFI_CDECL\", FFI_DEFAULT_ABI) < 0 ||\n\n#ifdef MS_WIN32\n#  ifdef _WIN64\n        PyModule_AddIntConstant(m, \"_WIN\", 64) < 0 ||   /* win64 */\n#  else\n        PyModule_AddIntConstant(m, \"_WIN\", 32) < 0 ||   /* win32 */\n#  endif\n#endif\n        0)\n      INITERROR;\n\n    for (i = 0; all_dlopen_flags[i].name != NULL; i++) {\n        if (PyModule_AddIntConstant(m,\n                                    all_dlopen_flags[i].name,\n                                    all_dlopen_flags[i].value) < 0)\n            INITERROR;\n    }\n\n    Py_INCREF(&MiniBuffer_Type);\n    if (PyModule_AddObject(m, \"buffer\", (PyObject *)&MiniBuffer_Type) < 0)\n        INITERROR;\n\n    init_cffi_tls();\n    if (PyErr_Occurred())\n        INITERROR;\n    init_cffi_tls_zombie();\n    if (PyErr_Occurred())\n        INITERROR;\n\n    if (init_ffi_lib(m) < 0)\n        INITERROR;\n\n#if PY_MAJOR_VERSION >= 3\n    if (init_file_emulator() < 0)\n        INITERROR;\n    return m;\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-r7eyruhs753zj2t2iswwndobx22sf2dp/spack-src/c/lib_obj.c": "\n/* A Lib object is what is in the \"lib\" attribute of a C extension\n   module originally created by recompile().\n\n   A Lib object is special in the sense that it has a custom\n   __getattr__ which returns C globals, functions and constants.  The\n   original idea was to raise AttributeError for anything else, even\n   attrs like '__class__', but it breaks various things; now, standard\n   attrs are returned, but in the unlikely case where a user cdef()s\n   the same name, then the standard attr is hidden (and the various\n   things like introspection might break).\n\n   A Lib object has got a reference to the _cffi_type_context_s\n   structure, which is used to create lazily the objects returned by\n   __getattr__.\n*/\n\nstruct CPyExtFunc_s {\n    PyMethodDef md;\n    void *direct_fn;\n    int type_index;\n    char doc[1];\n};\n\nstruct LibObject_s {\n    PyObject_HEAD\n    builder_c_t *l_types_builder; /* same as the one on the ffi object */\n    PyObject *l_dict;           /* content, built lazily */\n    PyObject *l_libname;        /* some string that gives the name of the lib */\n    FFIObject *l_ffi;           /* reference back to the ffi object */\n    void *l_libhandle;          /* the dlopen()ed handle, if any */\n};\n\nstatic struct CPyExtFunc_s *_cpyextfunc_get(PyObject *x)\n{\n    PyObject *y;\n    LibObject *lo;\n    PyCFunctionObject *fo;\n\n    if (!PyCFunction_Check(x))\n        return NULL;\n    y = PyCFunction_GET_SELF(x);\n    if (!LibObject_Check(y))\n        return NULL;\n\n    fo = (PyCFunctionObject *)x;\n    lo = (LibObject *)y;\n    if (lo->l_libname != fo->m_module)\n        return NULL;\n\n    return (struct CPyExtFunc_s *)(fo->m_ml);\n}\n\nstatic PyObject *_cpyextfunc_type(LibObject *lib, struct CPyExtFunc_s *exf)\n{\n    PyObject *tuple, *result;\n    tuple = realize_c_type_or_func(lib->l_types_builder,\n                                   lib->l_types_builder->ctx.types,\n                                   exf->type_index);\n    if (tuple == NULL)\n        return NULL;\n\n    /* 'tuple' is a tuple of length 1 containing the real CT_FUNCTIONPTR\n       object */\n    result = PyTuple_GetItem(tuple, 0);\n    Py_XINCREF(result);\n    Py_DECREF(tuple);\n    return result;\n}\n\nstatic PyObject *_cpyextfunc_type_index(PyObject *x)\n{\n    struct CPyExtFunc_s *exf;\n    LibObject *lib;\n\n    assert(PyErr_Occurred());\n    exf = _cpyextfunc_get(x);\n    if (exf == NULL)\n        return NULL;    /* still the same exception is set */\n\n    PyErr_Clear();\n\n    lib = (LibObject *)PyCFunction_GET_SELF(x);\n    return _cpyextfunc_type(lib, exf);\n}\n\nstatic void cdlopen_close_ignore_errors(void *libhandle);  /* forward */\nstatic void *cdlopen_fetch(PyObject *libname, void *libhandle,\n                           const char *symbol);\n\nstatic void lib_dealloc(LibObject *lib)\n{\n    PyObject_GC_UnTrack(lib);\n    cdlopen_close_ignore_errors(lib->l_libhandle);\n    Py_DECREF(lib->l_dict);\n    Py_DECREF(lib->l_libname);\n    Py_DECREF(lib->l_ffi);\n    PyObject_GC_Del(lib);\n}\n\nstatic int lib_traverse(LibObject *lib, visitproc visit, void *arg)\n{\n    Py_VISIT(lib->l_dict);\n    Py_VISIT(lib->l_libname);\n    Py_VISIT(lib->l_ffi);\n    return 0;\n}\n\nstatic PyObject *lib_repr(LibObject *lib)\n{\n    return PyText_FromFormat(\"<Lib object for '%.200s'>\",\n                             PyText_AS_UTF8(lib->l_libname));\n}\n\nstatic PyObject *lib_build_cpython_func(LibObject *lib,\n                                        const struct _cffi_global_s *g,\n                                        const char *s, int flags)\n{\n    /* First make sure the argument types and return type are really\n       built.  The C extension code can then assume that they are,\n       by calling _cffi_type().\n    */\n    PyObject *result = NULL;\n    CTypeDescrObject **pfargs = NULL;\n    CTypeDescrObject *fresult;\n    Py_ssize_t nargs = 0;\n    struct CPyExtFunc_s *xfunc;\n    int i, type_index = _CFFI_GETARG(g->type_op);\n    _cffi_opcode_t *opcodes = lib->l_types_builder->ctx.types;\n    static const char *const format = \";\\n\\nCFFI C function from %s.lib\";\n    const char *libname = PyText_AS_UTF8(lib->l_libname);\n    struct funcbuilder_s funcbuilder;\n\n    /* return type: */\n    fresult = realize_c_func_return_type(lib->l_types_builder, opcodes,\n                                       type_index);\n    if (fresult == NULL)\n        goto error;\n\n    /* argument types: */\n    /* note that if the arguments are already built, they have a\n       pointer in the 'opcodes' array, and GETOP() returns a\n       random even value.  But OP_FUNCTION_END is odd, so the\n       condition below still works correctly. */\n    i = type_index + 1;\n    while (_CFFI_GETOP(opcodes[i]) != _CFFI_OP_FUNCTION_END)\n        i++;\n    pfargs = alloca(sizeof(CTypeDescrObject *) * (i - type_index - 1));\n    i = type_index + 1;\n    while (_CFFI_GETOP(opcodes[i]) != _CFFI_OP_FUNCTION_END) {\n        CTypeDescrObject *ct = realize_c_type(lib->l_types_builder, opcodes, i);\n        if (ct == NULL)\n            goto error;\n        pfargs[nargs++] = ct;\n        i++;\n    }\n\n    memset(&funcbuilder, 0, sizeof(funcbuilder));\n    if (fb_build_name(&funcbuilder, g->name, pfargs, nargs, fresult, 0) < 0)\n        goto error;\n\n    /* The few bytes of memory we allocate here appear to leak, but\n       this is not a real leak.  Indeed, CPython never unloads its C\n       extension modules.  There is only one PyMem_Malloc() per real\n       C function in a CFFI C extension module.  That means that this\n       PyMem_Malloc() could also have been written with a static\n       global variable generated for each CPYTHON_BLTN defined in the\n       C extension, and the effect would be the same (but a bit more\n       complicated).\n    */\n    xfunc = PyMem_Malloc(sizeof(struct CPyExtFunc_s) +\n                         funcbuilder.nb_bytes +\n                         strlen(format) + strlen(libname));\n    if (xfunc == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n    memset((char *)xfunc, 0, sizeof(struct CPyExtFunc_s));\n    assert(g->address);\n    xfunc->md.ml_meth = (PyCFunction)g->address;\n    xfunc->md.ml_flags = flags;\n    xfunc->md.ml_name = g->name;\n    xfunc->md.ml_doc = xfunc->doc;\n    xfunc->direct_fn = g->size_or_direct_fn;\n    xfunc->type_index = type_index;\n\n    /* build the docstring */\n    funcbuilder.bufferp = xfunc->doc;\n    if (fb_build_name(&funcbuilder, g->name, pfargs, nargs, fresult, 0) < 0)\n        goto error;\n    sprintf(funcbuilder.bufferp - 1, format, libname);\n    /* done building the docstring */\n\n    result = PyCFunction_NewEx(&xfunc->md, (PyObject *)lib, lib->l_libname);\n    /* fall-through */\n error:\n    Py_XDECREF(fresult);\n    while (nargs > 0) {\n        --nargs;\n        Py_DECREF(pfargs[nargs]);\n    }\n    return result;\n}\n\nstatic PyObject *lib_build_and_cache_attr(LibObject *lib, PyObject *name,\n                                          int recursion)\n{\n    /* does not return a new reference! */\n    PyObject *x;\n    int index;\n    const struct _cffi_global_s *g;\n    CTypeDescrObject *ct;\n    builder_c_t *types_builder = lib->l_types_builder;\n    const char *s = PyText_AsUTF8(name);\n    if (s == NULL)\n        return NULL;\n\n    index = search_in_globals(&types_builder->ctx, s, strlen(s));\n    if (index < 0) {\n\n        if (types_builder->included_libs != NULL) {\n            Py_ssize_t i;\n            PyObject *included_ffis = types_builder->included_ffis;\n            PyObject *included_libs = types_builder->included_libs;\n\n            if (recursion > 100) {\n                PyErr_SetString(PyExc_RuntimeError,\n                    \"recursion overflow in ffi.include() delegations\");\n                return NULL;\n            }\n\n            for (i = 0; i < PyTuple_GET_SIZE(included_libs); i++) {\n                LibObject *lib1;\n\n                lib1 = (LibObject *)PyTuple_GET_ITEM(included_libs, i);\n                if (lib1 != NULL) {\n                    x = PyDict_GetItem(lib1->l_dict, name);\n                    if (x != NULL) {\n                        Py_INCREF(x);\n                        goto found;\n                    }\n                    x = lib_build_and_cache_attr(lib1, name, recursion + 1);\n                    if (x != NULL) {\n                        Py_INCREF(x);\n                        goto found;\n                    }\n                }\n                else {\n                    FFIObject *ffi1;\n\n                    ffi1 = (FFIObject *)PyTuple_GetItem(included_ffis, i);\n                    if (ffi1 == NULL)\n                        return NULL;\n                    x = ffi_fetch_int_constant(ffi1, s, recursion + 1);\n                    if (x != NULL)\n                        goto found;\n                }\n                if (PyErr_Occurred())\n                    return NULL;\n            }\n        }\n\n        if (recursion > 0)\n            return NULL;  /* no error set, continue looking elsewhere */\n\n        PyErr_Format(PyExc_AttributeError,\n                     \"cffi library '%.200s' has no function, constant \"\n                     \"or global variable named '%.200s'\",\n                     PyText_AS_UTF8(lib->l_libname), s);\n        return NULL;\n    }\n\n    g = &types_builder->ctx.globals[index];\n\n    switch (_CFFI_GETOP(g->type_op)) {\n\n    case _CFFI_OP_CPYTHON_BLTN_V:\n        x = lib_build_cpython_func(lib, g, s, METH_VARARGS);\n        break;\n\n    case _CFFI_OP_CPYTHON_BLTN_N:\n        x = lib_build_cpython_func(lib, g, s, METH_NOARGS);\n        break;\n\n    case _CFFI_OP_CPYTHON_BLTN_O:\n        x = lib_build_cpython_func(lib, g, s, METH_O);\n        break;\n\n    case _CFFI_OP_CONSTANT_INT:\n    case _CFFI_OP_ENUM:\n    {\n        /* a constant integer whose value, in an \"unsigned long long\",\n           is obtained by calling the function at g->address */\n        x = realize_global_int(types_builder, index);\n        break;\n    }\n\n    case _CFFI_OP_CONSTANT:\n    case _CFFI_OP_DLOPEN_CONST:\n    {\n        /* a constant which is not of integer type */\n        char *data;\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n\n        if (ct->ct_size <= 0) {\n            PyErr_Format(FFIError, \"constant '%s' is of type '%s', \"\n                         \"whose size is not known\", s, ct->ct_name);\n            return NULL;\n        }\n        if (g->address == NULL) {\n            /* for dlopen() style */\n            assert(_CFFI_GETOP(g->type_op) == _CFFI_OP_DLOPEN_CONST);\n            data = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n            if (data == NULL)\n                return NULL;\n        }\n        else {\n            /* The few bytes of memory we allocate here appear to leak, but\n               this is not a real leak.  Indeed, CPython never unloads its C\n               extension modules.  There is only one PyMem_Malloc() per real\n               non-integer C constant in a CFFI C extension module.  That\n               means that this PyMem_Malloc() could also have been written\n               with a static global variable generated for each OP_CONSTANT\n               defined in the C extension, and the effect would be the same\n               (but a bit more complicated).\n\n               Note that we used to do alloca(), but see issue #198.  We\n               could still do alloca(), or explicit PyMem_Free(), in some\n               cases; but there is no point and it only makes the remaining\n               less-common cases more suspicious.\n            */\n            assert(_CFFI_GETOP(g->type_op) == _CFFI_OP_CONSTANT);\n            data = PyMem_Malloc(ct->ct_size);\n            if (data == NULL) {\n                PyErr_NoMemory();\n                return NULL;\n            }\n            ((void(*)(char*))g->address)(data);\n        }\n        x = convert_to_object(data, ct);\n        Py_DECREF(ct);\n        break;\n    }\n\n    case _CFFI_OP_GLOBAL_VAR:\n    {\n        /* global variable of the exact type specified here\n           (nowadays, only used by the ABI mode or backward\n           compatibility; see _CFFI_OP_GLOBAL_VAR_F for the API mode)\n         */\n        Py_ssize_t g_size = (Py_ssize_t)g->size_or_direct_fn;\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n        if (g_size != ct->ct_size && g_size != 0 && ct->ct_size > 0) {\n            PyErr_Format(FFIError,\n                         \"global variable '%.200s' should be %zd bytes \"\n                         \"according to the cdef, but is actually %zd\",\n                         s, ct->ct_size, g_size);\n            x = NULL;\n        }\n        else {\n            void *address = g->address;\n            if (address == NULL) {\n                /* for dlopen() style */\n                address = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n                if (address == NULL)\n                    return NULL;\n            }\n            x = make_global_var(name, ct, address, NULL);\n        }\n        Py_DECREF(ct);\n        break;\n    }\n\n    case _CFFI_OP_GLOBAL_VAR_F:\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n        x = make_global_var(name, ct, NULL, (gs_fetch_addr_fn)g->address);\n        Py_DECREF(ct);\n        break;\n\n    case _CFFI_OP_DLOPEN_FUNC:\n    {\n        /* For dlopen(): the function of the given 'name'.  We use\n           dlsym() to get the address of something in the dynamic\n           library, which we interpret as being exactly a function of\n           the specified type.\n        */\n        PyObject *ct1;\n        void *address = cdlopen_fetch(lib->l_libname, lib->l_libhandle, s);\n        if (address == NULL)\n            return NULL;\n\n        ct1 = realize_c_type_or_func(types_builder,\n                                     types_builder->ctx.types,\n                                     _CFFI_GETARG(g->type_op));\n        if (ct1 == NULL)\n            return NULL;\n\n        assert(!CTypeDescr_Check(ct1));   /* must be a function */\n        x = new_simple_cdata(address, unwrap_fn_as_fnptr(ct1));\n\n        Py_DECREF(ct1);\n        break;\n    }\n\n    case _CFFI_OP_EXTERN_PYTHON:\n        /* for reading 'lib.bar' where bar is declared with extern \"Python\" */\n        ct = realize_c_type(types_builder, types_builder->ctx.types,\n                            _CFFI_GETARG(g->type_op));\n        if (ct == NULL)\n            return NULL;\n        x = convert_to_object((char *)&g->size_or_direct_fn, ct);\n        Py_DECREF(ct);\n        break;\n\n    default:\n        PyErr_Format(PyExc_NotImplementedError, \"in lib_build_attr: op=%d\",\n                     (int)_CFFI_GETOP(g->type_op));\n        return NULL;\n    }\n\n found:\n    if (x != NULL) {\n        int err = PyDict_SetItem(lib->l_dict, name, x);\n        Py_DECREF(x);\n        if (err < 0)     /* else there is still one ref left in the dict */\n            return NULL;\n    }\n    return x;\n}\n\n#define LIB_GET_OR_CACHE_ADDR(x, lib, name, error)      \\\n    do {                                                \\\n        x = PyDict_GetItem(lib->l_dict, name);          \\\n        if (x == NULL) {                                \\\n            x = lib_build_and_cache_attr(lib, name, 0); \\\n            if (x == NULL) {                            \\\n                error;                                  \\\n            }                                           \\\n        }                                               \\\n    } while (0)\n\nstatic PyObject *_lib_dir1(LibObject *lib, int ignore_global_vars)\n{\n    const struct _cffi_global_s *g = lib->l_types_builder->ctx.globals;\n    int i, count = 0, total = lib->l_types_builder->ctx.num_globals;\n    PyObject *s, *lst = PyList_New(total);\n    if (lst == NULL)\n        return NULL;\n\n    for (i = 0; i < total; i++) {\n        if (ignore_global_vars) {\n            int op = _CFFI_GETOP(g[i].type_op);\n            if (op == _CFFI_OP_GLOBAL_VAR || op == _CFFI_OP_GLOBAL_VAR_F)\n                continue;\n        }\n        s = PyText_FromString(g[i].name);\n        if (s == NULL)\n            goto error;\n        PyList_SET_ITEM(lst, count, s);\n        count++;\n    }\n    if (PyList_SetSlice(lst, count, total, NULL) < 0)\n        goto error;\n    return lst;\n\n error:\n    Py_DECREF(lst);\n    return NULL;\n}\n\nstatic PyObject *_lib_dict(LibObject *lib)\n{\n    const struct _cffi_global_s *g = lib->l_types_builder->ctx.globals;\n    int i, total = lib->l_types_builder->ctx.num_globals;\n    PyObject *name, *x, *d = PyDict_New();\n    if (d == NULL)\n        return NULL;\n\n    for (i = 0; i < total; i++) {\n        name = PyText_FromString(g[i].name);\n        if (name == NULL)\n            goto error;\n\n        LIB_GET_OR_CACHE_ADDR(x, lib, name, goto error);\n\n        if (PyDict_SetItem(d, name, x) < 0)\n            goto error;\n        Py_DECREF(name);\n    }\n    return d;\n\n error:\n    Py_XDECREF(name);\n    Py_DECREF(d);\n    return NULL;\n}\n\nstatic PyObject *lib_getattr(LibObject *lib, PyObject *name)\n{\n    const char *p;\n    PyObject *x;\n    LIB_GET_OR_CACHE_ADDR(x, lib, name, goto missing);\n\n    if (GlobSupport_Check(x)) {\n        return read_global_var((GlobSupportObject *)x);\n    }\n    Py_INCREF(x);\n    return x;\n\n missing:\n    /*** ATTRIBUTEERROR IS SET HERE ***/\n    p = PyText_AsUTF8(name);\n    if (p == NULL)\n        return NULL;\n    if (strcmp(p, \"__all__\") == 0) {\n        PyErr_Clear();\n        return _lib_dir1(lib, 1);\n    }\n    if (strcmp(p, \"__dict__\") == 0) {\n        PyErr_Clear();\n        return _lib_dict(lib);\n    }\n    if (strcmp(p, \"__class__\") == 0) {\n        PyErr_Clear();\n        x = (PyObject *)&PyModule_Type;\n        /* ^^^ used to be Py_TYPE(lib).  But HAAAAAACK!  That makes\n           help() behave correctly.  I couldn't find a more reasonable\n           way.  Urgh. */\n        Py_INCREF(x);\n        return x;\n    }\n    /* this hack is for Python 3.5, and also to give a more \n       module-like behavior */\n    if (strcmp(p, \"__name__\") == 0) {\n        PyErr_Clear();\n        return PyText_FromFormat(\"%s.lib\", PyText_AS_UTF8(lib->l_libname));\n    }\n#if PY_MAJOR_VERSION >= 3\n    if (strcmp(p, \"__loader__\") == 0 || strcmp(p, \"__spec__\") == 0) {\n        /* some more module-like behavior hacks */\n        PyErr_Clear();\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n#endif\n    return NULL;\n}\n\nstatic int lib_setattr(LibObject *lib, PyObject *name, PyObject *val)\n{\n    PyObject *x;\n    LIB_GET_OR_CACHE_ADDR(x, lib, name, return -1);\n\n    if (val == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"C attribute cannot be deleted\");\n        return -1;\n    }\n\n    if (GlobSupport_Check(x)) {\n        return write_global_var((GlobSupportObject *)x, val);\n    }\n\n    PyErr_Format(PyExc_AttributeError,\n                 \"cannot write to function or constant '%.200s'\",\n                 PyText_Check(name) ? PyText_AS_UTF8(name) : \"?\");\n    return -1;\n}\n\nstatic PyObject *lib_dir(PyObject *self, PyObject *noarg)\n{\n    return _lib_dir1((LibObject *)self, 0);\n}\n\nstatic PyMethodDef lib_methods[] = {\n    {\"__dir__\",   lib_dir,  METH_NOARGS},\n    {NULL,        NULL}           /* sentinel */\n};\n\nstatic PyTypeObject Lib_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"CompiledLib\",\n    sizeof(LibObject),\n    0,\n    (destructor)lib_dealloc,                    /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    (reprfunc)lib_repr,                         /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    (getattrofunc)lib_getattr,                  /* tp_getattro */\n    (setattrofunc)lib_setattr,                  /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,    /* tp_flags */\n    0,                                          /* tp_doc */\n    (traverseproc)lib_traverse,                 /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    lib_methods,                                /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    offsetof(LibObject, l_dict),                /* tp_dictoffset */\n};\n\nstatic LibObject *lib_internal_new(FFIObject *ffi, const char *module_name,\n                                   void *dlopen_libhandle)\n{\n    LibObject *lib;\n    PyObject *libname, *dict;\n\n    libname = PyText_FromString(module_name);\n    if (libname == NULL)\n        goto err1;\n\n    dict = PyDict_New();\n    if (dict == NULL)\n        goto err2;\n\n    lib = (LibObject *)PyType_GenericAlloc(&Lib_Type, 0);\n    if (lib == NULL)\n        goto err3;\n\n    lib->l_types_builder = &ffi->types_builder;\n    lib->l_dict = dict;\n    lib->l_libname = libname;\n    Py_INCREF(ffi);\n    lib->l_ffi = ffi;\n    lib->l_libhandle = dlopen_libhandle;\n    return lib;\n\n err3:\n    Py_DECREF(dict);\n err2:\n    Py_DECREF(libname);\n err1:\n    cdlopen_close_ignore_errors(dlopen_libhandle);\n    return NULL;\n}\n\nstatic PyObject *address_of_global_var(PyObject *args)\n{\n    LibObject *lib;\n    PyObject *x, *o_varname;\n    char *varname;\n\n    if (!PyArg_ParseTuple(args, \"O!s\", &Lib_Type, &lib, &varname))\n        return NULL;\n\n    /* rebuild a string from 'varname', to do typechecks and to force\n       a unicode back to a plain string (on python 2) */\n    o_varname = PyText_FromString(varname);\n    if (o_varname == NULL)\n        return NULL;\n\n    LIB_GET_OR_CACHE_ADDR(x, lib, o_varname, goto error);\n    Py_DECREF(o_varname);\n    if (GlobSupport_Check(x)) {\n        return cg_addressof_global_var((GlobSupportObject *)x);\n    }\n    else {\n        struct CPyExtFunc_s *exf = _cpyextfunc_get(x);\n        if (exf != NULL) {  /* an OP_CPYTHON_BLTN: '&func' returns a cdata */\n            PyObject *ct;\n            if (exf->direct_fn == NULL) {\n                Py_INCREF(x);    /* backward compatibility */\n                return x;\n            }\n            ct = _cpyextfunc_type(lib, exf);\n            if (ct == NULL)\n                return NULL;\n            x = new_simple_cdata(exf->direct_fn, (CTypeDescrObject *)ct);\n            Py_DECREF(ct);\n            return x;\n        }\n        if (CData_Check(x) &&  /* a constant functionptr cdata: 'f == &f' */\n                (((CDataObject *)x)->c_type->ct_flags & CT_FUNCTIONPTR) != 0) {\n            Py_INCREF(x);\n            return x;\n        }\n        else {\n            PyErr_Format(PyExc_AttributeError,\n                         \"cannot take the address of the constant '%.200s'\",\n                         varname);\n            return NULL;\n        }\n    }\n\n error:\n    Py_DECREF(o_varname);\n    return NULL;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-r7eyruhs753zj2t2iswwndobx22sf2dp/spack-src/c/cdlopen.c": "/* ffi.dlopen() interface with dlopen()/dlsym()/dlclose() */\n\nstatic void *cdlopen_fetch(PyObject *libname, void *libhandle,\n                           const char *symbol)\n{\n    void *address;\n\n    if (libhandle == NULL) {\n        PyErr_Format(FFIError, \"library '%s' has been closed\",\n                     PyText_AS_UTF8(libname));\n        return NULL;\n    }\n\n    dlerror();   /* clear error condition */\n    address = dlsym(libhandle, symbol);\n    if (address == NULL) {\n        const char *error = dlerror();\n        PyErr_Format(FFIError, \"symbol '%s' not found in library '%s': %s\",\n                     symbol, PyText_AS_UTF8(libname), error);\n    }\n    return address;\n}\n\nstatic void cdlopen_close_ignore_errors(void *libhandle)\n{\n    if (libhandle != NULL)\n        dlclose(libhandle);\n}\n\nstatic int cdlopen_close(PyObject *libname, void *libhandle)\n{\n    if (libhandle != NULL && dlclose(libhandle) != 0) {\n        const char *error = dlerror();\n        PyErr_Format(FFIError, \"closing library '%s': %s\",\n                     PyText_AS_UTF8(libname), error);\n        return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *ffi_dlopen(PyObject *self, PyObject *args)\n{\n    const char *modname;\n    PyObject *temp, *result = NULL;\n    void *handle;\n\n    handle = b_do_dlopen(args, &modname, &temp);\n    if (handle != NULL)\n    {\n        result = (PyObject *)lib_internal_new((FFIObject *)self,\n                                              modname, handle);\n    }\n    Py_XDECREF(temp);\n    return result;\n}\n\nstatic PyObject *ffi_dlclose(PyObject *self, PyObject *args)\n{\n    LibObject *lib;\n    void *libhandle;\n    if (!PyArg_ParseTuple(args, \"O!\", &Lib_Type, &lib))\n        return NULL;\n\n    libhandle = lib->l_libhandle;\n    if (libhandle != NULL)\n    {\n        lib->l_libhandle = NULL;\n\n        /* Clear the dict to force further accesses to do cdlopen_fetch()\n           again, and fail because the library was closed. */\n        PyDict_Clear(lib->l_dict);\n\n        if (cdlopen_close(lib->l_libname, libhandle) < 0)\n            return NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\n\nstatic Py_ssize_t cdl_4bytes(char *src)\n{\n    /* read 4 bytes in little-endian order; return it as a signed integer */\n    signed char *ssrc = (signed char *)src;\n    unsigned char *usrc = (unsigned char *)src;\n    return (ssrc[0] << 24) | (usrc[1] << 16) | (usrc[2] << 8) | usrc[3];\n}\n\nstatic _cffi_opcode_t cdl_opcode(char *src)\n{\n    return (_cffi_opcode_t)cdl_4bytes(src);\n}\n\ntypedef struct {\n    unsigned long long value;\n    int neg;\n} cdl_intconst_t;\n\nstatic int _cdl_realize_global_int(struct _cffi_getconst_s *gc)\n{\n    /* The 'address' field of 'struct _cffi_global_s' is set to point\n       to this function in case ffiobj_init() sees constant integers.\n       This fishes around after the 'ctx->globals' array, which is\n       initialized to contain another array, this time of\n       'cdl_intconst_t' structures.  We get the nth one and it tells\n       us what to return.\n    */\n    cdl_intconst_t *ic;\n    ic = (cdl_intconst_t *)(gc->ctx->globals + gc->ctx->num_globals);\n    ic += gc->gindex;\n    gc->value = ic->value;\n    return ic->neg;\n}\n\nstatic int ffiobj_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    FFIObject *ffi;\n    static char *keywords[] = {\"module_name\", \"_version\", \"_types\",\n                               \"_globals\", \"_struct_unions\", \"_enums\",\n                               \"_typenames\", \"_includes\", NULL};\n    char *ffiname = \"?\", *types = NULL, *building = NULL;\n    Py_ssize_t version = -1;\n    Py_ssize_t types_len = 0;\n    PyObject *globals = NULL, *struct_unions = NULL, *enums = NULL;\n    PyObject *typenames = NULL, *includes = NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds,\n                                     \"|sns#O!O!O!O!O!:FFI\", keywords,\n                                     &ffiname, &version, &types, &types_len,\n                                     &PyTuple_Type, &globals,\n                                     &PyTuple_Type, &struct_unions,\n                                     &PyTuple_Type, &enums,\n                                     &PyTuple_Type, &typenames,\n                                     &PyTuple_Type, &includes))\n        return -1;\n\n    ffi = (FFIObject *)self;\n    if (ffi->ctx_is_nonempty) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"cannot call FFI.__init__() more than once\");\n        return -1;\n    }\n    ffi->ctx_is_nonempty = 1;\n\n    if (version == -1 && types_len == 0)\n        return 0;\n    if (version < CFFI_VERSION_MIN || version > CFFI_VERSION_MAX) {\n        PyErr_Format(PyExc_ImportError,\n                     \"cffi out-of-line Python module '%s' has unknown \"\n                     \"version %p\", ffiname, (void *)version);\n        return -1;\n    }\n\n    if (types_len > 0) {\n        /* unpack a string of 4-byte entries into an array of _cffi_opcode_t */\n        _cffi_opcode_t *ntypes;\n        Py_ssize_t i, n = types_len / 4;\n\n        building = PyMem_Malloc(n * sizeof(_cffi_opcode_t));\n        if (building == NULL)\n            goto error;\n        ntypes = (_cffi_opcode_t *)building;\n\n        for (i = 0; i < n; i++) {\n            ntypes[i] = cdl_opcode(types);\n            types += 4;\n        }\n        ffi->types_builder.ctx.types = ntypes;\n        ffi->types_builder.ctx.num_types = n;\n        building = NULL;\n    }\n\n    if (globals != NULL) {\n        /* unpack a tuple alternating strings and ints, each two together\n           describing one global_s entry with no specified address or size.\n           The int is only used with integer constants. */\n        struct _cffi_global_s *nglobs;\n        cdl_intconst_t *nintconsts;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(globals) / 2;\n\n        i = n * (sizeof(struct _cffi_global_s) + sizeof(cdl_intconst_t));\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nglobs = (struct _cffi_global_s *)building;\n        nintconsts = (cdl_intconst_t *)(nglobs + n);\n\n        for (i = 0; i < n; i++) {\n            char *g = PyBytes_AS_STRING(PyTuple_GET_ITEM(globals, i * 2));\n            nglobs[i].type_op = cdl_opcode(g); g += 4;\n            nglobs[i].name = g;\n            if (_CFFI_GETOP(nglobs[i].type_op) == _CFFI_OP_CONSTANT_INT ||\n                _CFFI_GETOP(nglobs[i].type_op) == _CFFI_OP_ENUM) {\n                PyObject *o = PyTuple_GET_ITEM(globals, i * 2 + 1);\n                nglobs[i].address = &_cdl_realize_global_int;\n#if PY_MAJOR_VERSION < 3\n                if (PyInt_Check(o)) {\n                    nintconsts[i].neg = PyInt_AS_LONG(o) <= 0;\n                    nintconsts[i].value = (long long)PyInt_AS_LONG(o);\n                }\n                else\n#endif\n                {\n                    nintconsts[i].neg = PyObject_RichCompareBool(o, Py_False,\n                                                                 Py_LE);\n                    nintconsts[i].value = PyLong_AsUnsignedLongLongMask(o);\n                    if (PyErr_Occurred())\n                        goto error;\n                }\n            }\n        }\n        ffi->types_builder.ctx.globals = nglobs;\n        ffi->types_builder.ctx.num_globals = n;\n        building = NULL;\n    }\n\n    if (struct_unions != NULL) {\n        /* unpack a tuple of struct/unions, each described as a sub-tuple;\n           the item 0 of each sub-tuple describes the struct/union, and\n           the items 1..N-1 describe the fields, if any */\n        struct _cffi_struct_union_s *nstructs;\n        struct _cffi_field_s *nfields;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(struct_unions);\n        Py_ssize_t nf = 0;   /* total number of fields */\n\n        for (i = 0; i < n; i++) {\n            nf += PyTuple_GET_SIZE(PyTuple_GET_ITEM(struct_unions, i)) - 1;\n        }\n        i = (n * sizeof(struct _cffi_struct_union_s) +\n             nf * sizeof(struct _cffi_field_s));\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nstructs = (struct _cffi_struct_union_s *)building;\n        nfields = (struct _cffi_field_s *)(nstructs + n);\n        nf = 0;\n\n        for (i = 0; i < n; i++) {\n            /* 'desc' is the tuple of strings (desc_struct, desc_field_1, ..) */\n            PyObject *desc = PyTuple_GET_ITEM(struct_unions, i);\n            Py_ssize_t j, nf1 = PyTuple_GET_SIZE(desc) - 1;\n            char *s = PyBytes_AS_STRING(PyTuple_GET_ITEM(desc, 0));\n            /* 's' is the first string, describing the struct/union */\n            nstructs[i].type_index = cdl_4bytes(s); s += 4;\n            nstructs[i].flags = cdl_4bytes(s); s += 4;\n            nstructs[i].name = s;\n            if (nstructs[i].flags & (_CFFI_F_OPAQUE | _CFFI_F_EXTERNAL)) {\n                nstructs[i].size = (size_t)-1;\n                nstructs[i].alignment = -1;\n                nstructs[i].first_field_index = -1;\n                nstructs[i].num_fields = 0;\n                assert(nf1 == 0);\n            }\n            else {\n                nstructs[i].size = (size_t)-2;\n                nstructs[i].alignment = -2;\n                nstructs[i].first_field_index = nf;\n                nstructs[i].num_fields = nf1;\n            }\n            for (j = 0; j < nf1; j++) {\n                char *f = PyBytes_AS_STRING(PyTuple_GET_ITEM(desc, j + 1));\n                /* 'f' is one of the other strings beyond the first one,\n                   describing one field each */\n                nfields[nf].field_type_op = cdl_opcode(f); f += 4;\n                nfields[nf].field_offset = (size_t)-1;\n                if (_CFFI_GETOP(nfields[nf].field_type_op) != _CFFI_OP_NOOP) {\n                    nfields[nf].field_size = cdl_4bytes(f); f += 4;\n                }\n                else {\n                    nfields[nf].field_size = (size_t)-1;\n                }\n                nfields[nf].name = f;\n                nf++;\n            }\n        }\n        ffi->types_builder.ctx.struct_unions = nstructs;\n        ffi->types_builder.ctx.fields = nfields;\n        ffi->types_builder.ctx.num_struct_unions = n;\n        building = NULL;\n    }\n\n    if (enums != NULL) {\n        /* unpack a tuple of strings, each of which describes one enum_s\n           entry */\n        struct _cffi_enum_s *nenums;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(enums);\n\n        i = n * sizeof(struct _cffi_enum_s);\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        nenums = (struct _cffi_enum_s *)building;\n\n        for (i = 0; i < n; i++) {\n            char *e = PyBytes_AS_STRING(PyTuple_GET_ITEM(enums, i));\n            /* 'e' is a string describing the enum */\n            nenums[i].type_index = cdl_4bytes(e); e += 4;\n            nenums[i].type_prim = cdl_4bytes(e); e += 4;\n            nenums[i].name = e; e += strlen(e) + 1;\n            nenums[i].enumerators = e;\n        }\n        ffi->types_builder.ctx.enums = nenums;\n        ffi->types_builder.ctx.num_enums = n;\n        building = NULL;\n    }\n\n    if (typenames != NULL) {\n        /* unpack a tuple of strings, each of which describes one typename_s\n           entry */\n        struct _cffi_typename_s *ntypenames;\n        Py_ssize_t i, n = PyTuple_GET_SIZE(typenames);\n\n        i = n * sizeof(struct _cffi_typename_s);\n        building = PyMem_Malloc(i);\n        if (building == NULL)\n            goto error;\n        memset(building, 0, i);\n        ntypenames = (struct _cffi_typename_s *)building;\n\n        for (i = 0; i < n; i++) {\n            char *t = PyBytes_AS_STRING(PyTuple_GET_ITEM(typenames, i));\n            /* 't' is a string describing the typename */\n            ntypenames[i].type_index = cdl_4bytes(t); t += 4;\n            ntypenames[i].name = t;\n        }\n        ffi->types_builder.ctx.typenames = ntypenames;\n        ffi->types_builder.ctx.num_typenames = n;\n        building = NULL;\n    }\n\n    if (includes != NULL) {\n        PyObject *included_libs;\n\n        included_libs = PyTuple_New(PyTuple_GET_SIZE(includes));\n        if (included_libs == NULL)\n            return -1;\n\n        Py_INCREF(includes);\n        ffi->types_builder.included_ffis = includes;\n        ffi->types_builder.included_libs = included_libs;\n    }\n\n    /* Above, we took directly some \"char *\" strings out of the strings,\n       typically from somewhere inside tuples.  Keep them alive by\n       incref'ing the whole input arguments. */\n    Py_INCREF(args);\n    Py_XINCREF(kwds);\n    ffi->types_builder._keepalive1 = args;\n    ffi->types_builder._keepalive2 = kwds;\n    return 0;\n\n error:\n    if (building != NULL)\n        PyMem_Free(building);\n    if (!PyErr_Occurred())\n        PyErr_NoMemory();\n    return -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-r7eyruhs753zj2t2iswwndobx22sf2dp/spack-src/c/misc_win32.h": "#include <malloc.h>   /* for alloca() */\n\n\n/************************************************************/\n/* errno and GetLastError support */\n\n#include \"misc_thread_common.h\"\n\nstatic DWORD cffi_tls_index = TLS_OUT_OF_INDEXES;\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL,\n                    DWORD     reason_for_call,\n                    LPVOID    reserved)\n{\n    LPVOID p;\n\n    switch (reason_for_call) {\n\n    case DLL_THREAD_DETACH:\n        if (cffi_tls_index != TLS_OUT_OF_INDEXES) {\n            p = TlsGetValue(cffi_tls_index);\n            if (p != NULL) {\n                TlsSetValue(cffi_tls_index, NULL);\n                cffi_thread_shutdown(p);\n            }\n        }\n        break;\n\n    default:\n        break;\n    }\n    return TRUE;\n}\n\nstatic void init_cffi_tls(void)\n{\n    if (cffi_tls_index == TLS_OUT_OF_INDEXES) {\n        cffi_tls_index = TlsAlloc();\n        if (cffi_tls_index == TLS_OUT_OF_INDEXES)\n            PyErr_SetString(PyExc_WindowsError, \"TlsAlloc() failed\");\n    }\n}\n\nstatic struct cffi_tls_s *get_cffi_tls(void)\n{\n    LPVOID p = TlsGetValue(cffi_tls_index);\n\n    if (p == NULL) {\n        p = malloc(sizeof(struct cffi_tls_s));\n        if (p == NULL)\n            return NULL;\n        memset(p, 0, sizeof(struct cffi_tls_s));\n        TlsSetValue(cffi_tls_index, p);\n    }\n    return (struct cffi_tls_s *)p;\n}\n\n#ifdef USE__THREAD\n# error \"unexpected USE__THREAD on Windows\"\n#endif\n\nstatic void save_errno(void)\n{\n    int current_err = errno;\n    int current_lasterr = GetLastError();\n    struct cffi_tls_s *p = get_cffi_tls();\n    if (p != NULL) {\n        p->saved_errno = current_err;\n        p->saved_lasterror = current_lasterr;\n    }\n    /* else: cannot report the error */\n}\n\nstatic void restore_errno(void)\n{\n    struct cffi_tls_s *p = get_cffi_tls();\n    if (p != NULL) {\n        SetLastError(p->saved_lasterror);\n        errno = p->saved_errno;\n    }\n    /* else: cannot report the error */\n}\n\n/************************************************************/\n\n\n#if PY_MAJOR_VERSION >= 3\nstatic PyObject *b_getwinerror(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    int err = -1;\n    int len;\n    WCHAR *s_buf = NULL; /* Free via LocalFree */\n    PyObject *v, *message;\n    static char *keywords[] = {\"code\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", keywords, &err))\n        return NULL;\n\n    if (err == -1) {\n        struct cffi_tls_s *p = get_cffi_tls();\n        if (p == NULL)\n            return PyErr_NoMemory();\n        err = p->saved_lasterror;\n    }\n\n    len = FormatMessageW(\n        /* Error API error */\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,           /* no message source */\n        err,\n        MAKELANGID(LANG_NEUTRAL,\n        SUBLANG_DEFAULT), /* Default language */\n        (LPWSTR) &s_buf,\n        0,              /* size not used */\n        NULL);          /* no args */\n    if (len==0) {\n        /* Only seen this in out of mem situations */\n        message = PyUnicode_FromFormat(\"Windows Error 0x%X\", err);\n    } else {\n        /* remove trailing cr/lf and dots */\n        while (len > 0 && (s_buf[len-1] <= L' ' || s_buf[len-1] == L'.'))\n            s_buf[--len] = L'\\0';\n        message = PyUnicode_FromWideChar(s_buf, len);\n    }\n    if (message != NULL)\n        v = Py_BuildValue(\"(iO)\", err, message);\n    else\n        v = NULL;\n    LocalFree(s_buf);\n    return v;\n}\n#else\nstatic PyObject *b_getwinerror(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    int err = -1;\n    int len;\n    char *s;\n    char *s_buf = NULL; /* Free via LocalFree */\n    char s_small_buf[40]; /* Room for \"Windows Error 0xFFFFFFFFFFFFFFFF\" */\n    PyObject *v;\n    static char *keywords[] = {\"code\", NULL};\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|i\", keywords, &err))\n        return NULL;\n\n    if (err == -1) {\n        struct cffi_tls_s *p = get_cffi_tls();\n        if (p == NULL)\n            return PyErr_NoMemory();\n        err = p->saved_lasterror;\n    }\n\n    len = FormatMessage(\n        /* Error API error */\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,           /* no message source */\n        err,\n        MAKELANGID(LANG_NEUTRAL,\n        SUBLANG_DEFAULT), /* Default language */\n        (LPTSTR) &s_buf,\n        0,              /* size not used */\n        NULL);          /* no args */\n    if (len==0) {\n        /* Only seen this in out of mem situations */\n        sprintf(s_small_buf, \"Windows Error 0x%X\", err);\n        s = s_small_buf;\n        s_buf = NULL;\n    } else {\n        s = s_buf;\n        /* remove trailing cr/lf and dots */\n        while (len > 0 && (s[len-1] <= ' ' || s[len-1] == '.'))\n            s[--len] = '\\0';\n    }\n    v = Py_BuildValue(\"(is)\", err, s);\n    LocalFree(s_buf);\n    return v;\n}\n#endif\n\n\n/************************************************************/\n/* Emulate dlopen()&co. from the Windows API */\n\n#define RTLD_LAZY   0\n#define RTLD_NOW    0\n#define RTLD_GLOBAL 0\n#define RTLD_LOCAL  0\n\nstatic void *dlopen(const char *filename, int flag)\n{\n    return (void *)LoadLibraryA(filename);\n}\n\nstatic void *dlopenW(const wchar_t *filename)\n{\n    return (void *)LoadLibraryW(filename);\n}\n\nstatic void *dlsym(void *handle, const char *symbol)\n{\n    void *address = GetProcAddress((HMODULE)handle, symbol);\n#ifndef MS_WIN64\n    if (!address) {\n        /* If 'symbol' is not found, then try '_symbol@N' for N in\n           (0, 4, 8, 12, ..., 124).  Unlike ctypes, we try to do that\n           for any symbol, although in theory it should only be done\n           for __stdcall functions.\n        */\n        int i;\n        char *mangled_name = alloca(1 + strlen(symbol) + 1 + 3 + 1);\n        if (!mangled_name)\n            return NULL;\n        for (i = 0; i < 32; i++) {\n            sprintf(mangled_name, \"_%s@%d\", symbol, i * 4);\n            address = GetProcAddress((HMODULE)handle, mangled_name);\n            if (address)\n                break;\n        }\n    }\n#endif\n    return address;\n}\n\nstatic int dlclose(void *handle)\n{\n    return FreeLibrary((HMODULE)handle) ? 0 : -1;\n}\n\nstatic const char *dlerror(void)\n{\n    static char buf[32];\n    DWORD dw = GetLastError(); \n    if (dw == 0)\n        return NULL;\n    sprintf(buf, \"error 0x%x\", (unsigned int)dw);\n    return buf;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-cffi-1.13.0-r7eyruhs753zj2t2iswwndobx22sf2dp/spack-src/c/libffi_msvc/win64.obj"
    ],
    "total_files": 183
}