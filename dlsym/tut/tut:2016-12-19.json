{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-tut-2016-12-19-y4sytj55bhs4rjvbwknl7u3vncxsi2nl/spack-src/doc/htdocs/_xml/design.xml": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<tut>\n\t<section>Documentation</section>\n\t<chapter>TUT Design</chapter>\n\t<annotation>what's hidden under the hood of tut.h, and why things are such as they\n\t\tare</annotation>\n\t<content>\n\t\t\n\t\t<p>In this document I attempt to explain the decisions made while developing\n\t\t\tTUT.</p>\n\t\t\n\t\t<p class=\"subheader\">Requirements</p>\n\t\t\n\t\t<p> One day I ran into need of unit test framework for C++. So, I've made a small research\n\t\t\tand discovered C++Unit, boost::test and a bunch of similar libraries.. Though\n\t\t\tthey were usable, I was not satisfied with the approach they offered; so I\n\t\t\tdesigned my own variant of unit test framework based on the following\n\t\t\trestrictions: </p>\n\t\t\n\t\t<ul>\n\t\t\t<li>No C-style macros</li>\n\t\t\t<li>No manual registration for test groups and methods</li>\n\t\t\t<li>No libraries of any kind</li>\n\t\t\t<li>Neutrality to user interface</li>\n\t\t\t<li>No Javisms</li>\n\t\t</ul>\n\t\t\n\t\t<p class=\"subheader\">C-style macros and what's wrong with them</p>\n\t\t\n\t\t<p> Usually C++ Unit test frameworks define a lot of macroses to achieve the goals\n\t\t\tother languages have as built-in features: for example, Java is able to show you\n\t\t\tthe whole exception stack; and C++ cannot. So, to achieve the same (or similar)\n\t\t\tresults, C++ frameworks often declare a macro to catch any exception and trace\n\t\t\t__FILE__ and __LINE__ variables. </p>\n\t\t\n\t\t<p> The problem is that it turns the C++ code into something that is hard to read, where\n\t\t\t\"hard to read\" actually means \"hard to maintain\". </p>\n\t\t\n\t\t<p> Macros don't recognize namespace borders, so a simple macro can expand in the user\n\t\t\tcode into something unexpected. To avoid this, we have to give macros unique\n\t\t\tprefixes, and this, in turn, reduces code readability even more. </p>\n\t\t\n\t\t<p> From bad to worse, C-style macros can't handle modern C++ templates, so comma\n\t\t\tseparated template arguments will break the macro, since preprocessor will\n\t\t\thandle the template as two arguments (separated by the comma used in the\n\t\t\ttemplate) to this macro. </p>\n\t\t\n\t\t<p> And the final contra for macros is that even if used they cannot achieve the same\n\t\t\tusability level as the native language tools; for example, macros cannot\n\t\t\tgenerate a full stack trace (at least, in a platform-independent manner). So it\n\t\t\tlooks like we loose readability and get almost nothing for this. </p>\n\t\t\n\t\t<p> See also Bjarne Stroustrup notices about macros harmness:\n\t\t\t<a href=\"http://www.research.att.com/~bs/bs_faq2.html#macro\"> So,\n\t\t\t\twhat's wrong with using macros?</a> </p>\n\t\t\n\t\t<p class=\"subheader\">Manual registration and why it annoys me</p>\n\t\t\n\t\t<p> In JUnit (Java-based Unit Tests framework) reflection is used to recognize\n\t\t\tuser-written test methods. C++ has no reflection or similar mechanism, so user\n\t\t\tmust somehow tell the framework that \"this, this and that\" methods should be\n\t\t\tconsidered as test methods, and others are just helpers for them. </p>\n\t\t\n\t\t<p> The same can be said about test groups, which have to be registered in test runner\n\t\t\tobject. </p>\n\t\t\n\t\t<p> Again, most C++ frameworks introduce macros or at least methods to register a\n\t\t\tfreestanding function or method as a test instance. I find writing redundant\n\t\t\tcode rather annoying: I have to write test itself and then I have to write more code\n\t\t\tto mark that my test is a test. Even more, if I forget to register the method,\n\t\t\tnothing will warn me or somehow indicate that I have not done what I should. </p>\n\t\t\n\t\t<p class=\"subheader\">Library and integration problems</p>\n\t\t\n\t\t<p> Most of C++ frameworks require building a library that user must link to test\n\t\t\tapplication to be able to run tests. The problem is that various platforms imply\n\t\t\tdifferent ways for building libraries. One popular C++ framework has more than\n\t\t\t60% bugs in their bug database that sound like \"cannot build library on platform\n\t\t\tXXX\" or \"built library doesn't work on platform YYY\". </p>\n\t\t\n\t\t<p> Besides, some platforms has complexities in library memory management (e.g.\n\t\t\tWin32). </p>\n\t\t\n\t\t<p class=\"subheader\">User interface</p>\n\t\t\n\t\t<p> Some frameworks provide predefined formatters for output results, for example\n\t\t\tCSV or XML. This restricts users in test results presentation options. What if a\n\t\t\tuser wants some completely different format? Of course, he can implement his own\n\t\t\tformatter, but why frameworks provide useless formatters then? </p>\n\t\t\n\t\t<p> The ideal test framework must do only one thing: run tests. Anything beyond that is\n\t\t\tthe responsibility of the user code. Framework provides the test results, and\n\t\t\tthe user code then represents them in any desired form. </p>\n\t\t\n\t\t<p class=\"subheader\">Javisms</p>\n\t\t\n\t\t<p>Most implementors of C++ test frameworks know about JUnit and inspired by\n\t\t\tthis exciting tool. But, carelessly copying a Java implementation to C++, we can\n\t\t\tget strange and ugly design.</p>\n\t\t\n\t\t<p>Rather obvious example: JUnit has methods for setting up a test (setUp) and for\n\t\t\tcleaning after it (tearDown). I know at least two C++ frameworks that have these\n\t\t\tmethods with the same semantics and names. But in C++ the job these methods do is\n\t\t\tthe responsibility of constructor and destructor! In Java we don't have\n\t\t\tguaranteed destruction, so JUnit authors had to invent their own replacement\n\t\t\tfor it - tearDown(); and it was natural then to introduce constructing\n\t\t\tcounterpart - setUp(). Doing the same in C++ is absolutely redundant\n\t\t</p>\n\t\t\n\t\t<p>C++ has its own way of working, and whenever possible, I am going to stay at the C++\n\t\t\troads, and will not repeat Java implementation just because it is really good for\n\t\t\tJava. </p>\n\t\t\n\t\t<p class=\"subheader\">Decisions</p>\n\t\t\n\t\t<p class=\"subheader\">No C-style macros</p>\n\t\t\n\t\t<p>The solution is that simple: just\n\t\t\t<b>do not</b> use any macros. I personally never needed a macro during\n\t\t\tdevelopment. </p>\n\t\t\n\t\t<p class=\"subheader\">No manual registration</p>\n\t\t\n\t\t<p>Since C++ has no reflection, the only way to mark a method as a test is to give it a kind\n\t\t\tof predefined name.</p>\n\t\t\n\t\t<p>There would be a simple solution: create a set of virtual methods in test object base\n\t\t\tclass, and allow user to overwrite them. The code might look like:</p>\n\t\t\n\t\t<pre> struct a_test_group : public test_group { virtual void test1() { ... } virtual\n\t\t\tvoid test2() { ... } }; </pre>\n\t\t\n\t\t<p>Unfortunately, this approach has major drawbacks:</p>\n\t\t\n\t\t<ul>\n\t\t\t<li>It scales badly. Consider, we have created 100 virtual test methods in a test\n\t\t\t\tgroup, but user needs 200. How can he achieve that? There is no proper way.\n\t\t\t\tFrankly speaking, such a demand will arise rarely (mostly in\n\t\t\t\tscript-generated tests), but even the possibility of it makes this kind of\n\t\t\t\tdesign seemingly poor. </li>\n\t\t\t\n\t\t\t<li>There is no way to iterate virtual methods automatically. We\n\t\t\t\twould end up writing code that calls test1(), then test2(), and so on, each\n\t\t\t\twith its own exception handling and reporting.</li>\n\t\t</ul>\n\t\t\n\t\t<p>Another possible solution is to substitute reflection with a dynamic loading.\n\t\t\tUser then would write static functions with predefined names, and TUT would use\n\t\t\tdlsym()/GetProcAddress() to find out the implemented tests. </p>\n\t\t\n\t\t<p>But I rejected the solution due to its platform and library operations\n\t\t\tdependencies. As I described above, the library operations are quite different\n\t\t\ton various platform. </p>\n\t\t\n\t\t<p>There was also an idea to have a small parser, that can scan the user code and\n\t\t\tgenerate registration procedure. This solution only looks simple; parsing\n\t\t\tfree-standing user code can be a tricky procedure, and might easily overgrow twelve TUTs\n\t\t\tin complexity.</p>\n\t\t\n\t\t<p>Fortunately, modern C++ compilers already have a tool that can parse the user code\n\t\t\tand iterate methods. It is compiler template processing engine. To be more\n\t\t\tprecise, it is template specialization technique.</p>\n\t\t\n\t\t<p>The following code iterates all methods named test&lt;N&gt; ranging from n to 0,\n\t\t\tand takes the address of each:</p>\n\t\t\n\t\t<pre> \ntemplate &lt;class Test,class Group,int n&gt; \nstruct tests_registerer \n{\n\tstatic void reg(Group&amp; group) \n\t{ \n\t\tgroup.reg(n,&amp;Test::template\ttest&lt;n&gt;); \n\t\ttests_registerer&lt;Test,Group,n-1&gt;::reg(group); \n\t}\n}; \n\t\t\t\ntemplate&lt;class Test,class Group&gt; \nstruct tests_registerer&lt;Test,Group,0&gt; \n{ \n\tstatic void reg(Group&amp;){}; \n};\n... \ntest_registerer&lt;test,group,100&gt;.reg(grp); \n\t\t</pre>\n\t\t\n\t\t<p>This code generates recursive template instantiations until it reaches\n\t\t\ttests_registerer&lt;Test,Group,0&gt; which has empty specialization.\n\t\t\tThere the recursion stops.</p>\n\t\t\n\t\t<p>The code is suitable for our needs because in the specialization preference is\n\t\t\tgiven to the user-written code, not to the generic one. Suppose we have a default\n\t\t\tmethod test&lt;N&gt; in our test group, and the user-written specialization\n\t\t\tfor test&lt;1&gt;. So while iterating, compiler will get the address of the\n\t\t\tdefault method for all N, except 1, since user has supplied a special version of\n\t\t\tthat method. </p>\n\t\t\n\t\t<pre> \ntemplate&lt;int N&gt; \nvoid test() { }; \n... \ntemplate&lt;&gt; \nvoid test_group::test&lt;1&gt;() { // user code here } \n\t\t</pre>\n\t\t\n\t\t<p>This approach can be regarded as kind of compile-time virtual functions, since\n\t\t\tthe user-written methods replace the default implementation. At the same time,\n\t\t\tit scales well - one just has to specify another test number upper bound at compile\n\t\t\ttime. The method also allows iteration of methods, keeping code compact.</p>\n\t\t\n\t\t<p class=\"subheader\">Library</p>\n\t\t\n\t\t<p>Since we dig into the template processing, it is natural to not build any\n\t\t\tlibraries, therefor this problem mostly disappeares. Unfortunately, not\n\t\t\tcompletely: our code still needs some central point where it could register\n\t\t\titself. But that point (singleton) is so small that it would be an overkill to\n\t\t\tcreate library just to put there one single object. Instead, we assume that the\n\t\t\tuser code will contain our singleton somewhere in the main module of test\n\t\t\tapplication.</p>\n\t\t\n\t\t<p class=\"subheader\">User interface. Callbacks.</p>\n\t\t\n\t\t<p>Our code will perform only minimamum set of tasks: TUT shall run tests. But we still\n\t\t\tneed a way to adapt the end-user presentation requirements. For some of users it\n\t\t\twould be enough to see only failed tests in listing; others would like to see the\n\t\t\tcomplete plain-text report; some would prefer to get XML reports, and some would\n\t\t\tnot want to get any reports at all since they draw their test execution log in GUI\n\t\t\tplugin for an IDE. </p>\n\t\t\n\t\t<p>\"Many users\" means \"many demands\", and satisfying all of them is quite a hard task.\n\t\t\tAttempt to use a kind of silver bullet (like XML) is not the right solution, since\n\t\t\tuser would lack XML parser in his environment, or just would not want to put it into\n\t\t\this project due to integration complexities.</p>\n\t\t\n\t\t<p>The decision was made to allow users to form their reports by themselfs. TUT will\n\t\t\treport an event, and the user code will form some kind of an artefact based on this\n\t\t\tevent.</p>\n\t\t\n\t\t<p>The implementation of this decision is interface tut::callback. The user code\n\t\t\tcreates a callback object, and passes it to the runner. When an appropriate event\n\t\t\toccures, the test runner invokes callback methods. User code can do anything,\n\t\t\tfrom dumping test results to std::cout to drawing 3D images, if desired. </p>\n\t\t\n\t\t<p class=\"subheader\">STL</p>\n\t\t\n\t\t<p>Initially, there were plans to make TUT traits-based in order not to restrict\n\t\t\tit with STL only, but have a possibility to use other kinds of strings\n\t\t\t(TString, CString), containers and intercepted exceptions. </p>\n\t\t\n\t\t<p>In the current version, these plans are not implemented due to relative\n\t\t\tcomplexity of the task. For example, the actual set of operations can be quite\n\t\t\tdifferent for various map implementations and this makes writing generic code\n\t\t\tmuch harder. </p>\n\t\t\n\t\t<p>Thus so far TUT is completely STL-based, since STL is the only library existing\n\t\t\tvirtually on every platform. </p>\n\t</content>\n</tut>"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-tut-2016-12-19-y4sytj55bhs4rjvbwknl7u3vncxsi2nl/spack-src/doc/webgen/src/tut.png",
        "/tmp/vanessa/spack-stage/spack-stage-tut-2016-12-19-y4sytj55bhs4rjvbwknl7u3vncxsi2nl/spack-src/doc/webgen/src/tut.ico",
        "/tmp/vanessa/spack-stage/spack-stage-tut-2016-12-19-y4sytj55bhs4rjvbwknl7u3vncxsi2nl/spack-src/doc/htdocs/_etc/skin.php"
    ],
    "total_files": 107
}