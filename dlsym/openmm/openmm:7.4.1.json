{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/olla/src/Platform.cpp": "/* -------------------------------------------------------------------------- *\n *                                   OpenMM                                   *\n * -------------------------------------------------------------------------- *\n * This is part of the OpenMM molecular simulation toolkit originating from   *\n * Simbios, the NIH National Center for Physics-Based Simulation of           *\n * Biological Structures at Stanford, funded under the NIH Roadmap for        *\n * Medical Research, grant U54 GM072970. See https://simtk.org.               *\n *                                                                            *\n * Portions copyright (c) 2008-2016 Stanford University and the Authors.      *\n * Authors: Peter Eastman                                                     *\n * Contributors:                                                              *\n *                                                                            *\n * Permission is hereby granted, free of charge, to any person obtaining a    *\n * copy of this software and associated documentation files (the \"Software\"), *\n * to deal in the Software without restriction, including without limitation  *\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,   *\n * and/or sell copies of the Software, and to permit persons to whom the      *\n * Software is furnished to do so, subject to the following conditions:       *\n *                                                                            *\n * The above copyright notice and this permission notice shall be included in *\n * all copies or substantial portions of the Software.                        *\n *                                                                            *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   *\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    *\n * THE AUTHORS, CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,    *\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR      *\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE  *\n * USE OR OTHER DEALINGS IN THE SOFTWARE.                                     *\n * -------------------------------------------------------------------------- */\n\n#include \"openmm/Platform.h\"\n#include \"openmm/Context.h\"\n#include \"openmm/OpenMMException.h\"\n#include \"openmm/Kernel.h\"\n#include \"openmm/KernelFactory.h\"\n#include \"openmm/internal/ContextImpl.h\"\n#ifdef WIN32\n#include <windows.h>\n#else\n#ifndef __PNACL__\n    #include <dlfcn.h>\n#endif\n#include <dirent.h>\n#include <cstdlib>\n#endif\n#include <sstream>\n#include <set>\n#include <algorithm>\n\n#include \"ReferencePlatform.h\"\n\nusing namespace OpenMM;\nusing namespace std;\n\nstd::vector<std::string> Platform::pluginLoadFailures;\nstatic bool stringLengthComparator(string i, string j) {\n  return (i.size() < j.size());\n}\n\nstatic int registerPlatforms() {\n\n    // Register the Platforms built into the main library.  This should eventually be moved elsewhere.\n    \n    ReferencePlatform* platform = new ReferencePlatform();\n    Platform::registerPlatform(platform);\n    return 0;\n}\n\nstatic int platformInitializer = registerPlatforms();\n\nPlatform::~Platform() {\n    set<KernelFactory*> uniqueKernelFactories;\n    for (auto& factory : kernelFactories)\n        uniqueKernelFactories.insert(factory.second);\n    for (auto factory : uniqueKernelFactories)\n        delete factory;\n}\n\nconst vector<string>& Platform::getPropertyNames() const {\n    return platformProperties;\n}\n\nconst string& Platform::getPropertyValue(const Context& context, const string& property) const {\n    throw OpenMMException(\"getPropertyValue: Illegal property name\");\n}\n\nvoid Platform::setPropertyValue(Context& context, const string& property, const string& value) const {\n    throw OpenMMException(\"setPropertyValue: Illegal property name\");\n}\n\nconst string& Platform::getPropertyDefaultValue(const string& property) const {\n    string propertyName = property;\n    if (deprecatedPropertyReplacements.find(property) != deprecatedPropertyReplacements.end())\n        propertyName = deprecatedPropertyReplacements.find(property)->second;\n    map<string, string>::const_iterator value = defaultProperties.find(propertyName);\n    if (value == defaultProperties.end())\n        throw OpenMMException(\"getPropertyDefaultValue: Illegal property name\");\n    return value->second;\n}\n\nvoid Platform::setPropertyDefaultValue(const string& property, const string& value) {\n    string propertyName = property;\n    if (deprecatedPropertyReplacements.find(property) != deprecatedPropertyReplacements.end())\n        propertyName = deprecatedPropertyReplacements.find(property)->second;\n    for (auto& prop : platformProperties)\n        if (prop == propertyName) {\n            defaultProperties[propertyName] = value;\n            return;\n        }\n    throw OpenMMException(\"setPropertyDefaultValue: Illegal property name\");\n}\n\nvoid Platform::contextCreated(ContextImpl& context, const map<string, string>& properties) const {\n}\n\nvoid Platform::linkedContextCreated(ContextImpl& context, ContextImpl& originalContext) const {\n    // The default implementation just copies over the properties and calls contextCreated().\n    // Subclasses may override this to do something different.\n    \n    map<string, string> properties;\n    for (auto& name : getPropertyNames())\n        properties[name] = getPropertyValue(originalContext.getOwner(), name);\n    contextCreated(context, properties);\n}\n\nvoid Platform::contextDestroyed(ContextImpl& context) const {\n}\n\nvoid Platform::registerKernelFactory(const string& name, KernelFactory* factory) {\n    kernelFactories[name] = factory;\n}\n\nbool Platform::supportsKernels(const vector<string>& kernelNames) const {\n    for (auto& name : kernelNames)\n        if (kernelFactories.find(name) == kernelFactories.end())\n            return false;\n    return true;\n}\n\nKernel Platform::createKernel(const string& name, ContextImpl& context) const {\n    if (kernelFactories.find(name) == kernelFactories.end())\n        throw OpenMMException(\"Called createKernel() on a Platform which does not support the requested kernel\");\n    return Kernel(kernelFactories.find(name)->second->createKernelImpl(name, *this, context));\n}\nvector<Platform*>& Platform::getPlatforms() {\n    static vector<Platform*> platforms;\n    return platforms;\n}\n\nvoid Platform::registerPlatform(Platform* platform) {\n    getPlatforms().push_back(platform);\n}\n\nint Platform::getNumPlatforms() {\n    return getPlatforms().size();\n}\n\nPlatform& Platform::getPlatform(int index) {\n    if (index >= 0 && index < getNumPlatforms()) {\n        return *getPlatforms()[index];\n    }\n    throw OpenMMException(\"Invalid platform index\");\n}\n\nstd::vector<std::string> Platform::getPluginLoadFailures() {\n  return pluginLoadFailures;\n}\n\nPlatform& Platform::getPlatformByName(const string& name) {\n    for (int i = 0; i < getNumPlatforms(); i++)\n        if (getPlatform(i).getName() == name)\n            return getPlatform(i);\n    throw OpenMMException(\"There is no registered Platform called \\\"\"+name+\"\\\"\");\n}\n\nPlatform& Platform::findPlatform(const vector<string>& kernelNames) {\n    Platform* best = 0;\n    vector<Platform*>& platforms = getPlatforms();\n    double speed = 0.0;\n    for (auto platform : platforms) {\n        if (platform->supportsKernels(kernelNames) && platform->getSpeed() > speed) {\n            best = platform;\n            speed = best->getSpeed();\n        }\n    }\n    if (best == 0)\n        throw OpenMMException(\"No Platform supports all the requested kernels\");\n    return *best;\n}\n\n#ifdef WIN32\nstatic HMODULE loadOneLibrary(const string& file) {\n    // Tell Windows not to bother the user with ugly error boxes.\n    const UINT oldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);\n    HMODULE handle = LoadLibrary(file.c_str());\n    SetErrorMode(oldErrorMode); // Restore previous error mode.\n    if (handle == NULL) {\n        stringstream message;\n        message << \"Error loading library \" << file << \": \" << GetLastError();\n        throw OpenMMException(message.str());\n    }\n    return handle;\n}\n\nstatic void initializePlugins(vector<HMODULE>& plugins) {\n    for (auto plugin : plugins) {\n        void (*init)();\n        *(void **)(&init) = (void *) GetProcAddress(plugin, \"registerPlatforms\");\n        if (init != NULL)\n            (*init)();\n    }\n    for (auto plugin : plugins) {\n        void (*init)();\n        *(void **)(&init) = (void *) GetProcAddress(plugin, \"registerKernelFactories\");\n        if (init != NULL)\n            (*init)();\n    }\n}\n#else\nstatic void* loadOneLibrary(const string& file) {\n#ifdef __PNACL__\n    throw OpenMMException(\"Loading dynamic libraries is not supported on PNaCl\");\n#else    \n    void *handle = dlopen(file.c_str(), RTLD_LAZY | RTLD_GLOBAL);\n    if (handle == NULL) {\n        throw OpenMMException(\"Error loading library \"+file+\": \"+dlerror());\n    }\n    return handle;\n#endif\n}\n\nstatic void initializePlugins(vector<void*>& plugins) {\n#ifndef __PNACL__\n    for (auto plugin : plugins) {\n        void (*init)();\n        *(void **)(&init) = dlsym(plugin, \"registerPlatforms\");\n        if (init != NULL)\n            (*init)();\n    }\n    for (auto plugin : plugins) {\n        void (*init)();\n        *(void **)(&init) = dlsym(plugin, \"registerKernelFactories\");\n        if (init != NULL)\n            (*init)();\n    }\n#endif\n}\n#endif\n\nvoid Platform::loadPluginLibrary(const string& file) {\n#ifdef WIN32\n    vector<HMODULE> plugins;\n#else\n    vector<void*> plugins;\n#endif\n    plugins.push_back(loadOneLibrary(file));\n    initializePlugins(plugins);\n}\n\nvector<string> Platform::loadPluginsFromDirectory(const string& directory) {\n    vector<string> files;\n    char dirSeparator;\n    char pathSeparator;\n    stringstream sdirectory(directory);\n#ifdef WIN32\n    dirSeparator = '\\\\';\n    pathSeparator = ';';\n    WIN32_FIND_DATA fileInfo;\n\n    for (string path; std::getline(sdirectory, path, pathSeparator);) {\n        string filePattern(path + dirSeparator + \"*.dll\");\n        HANDLE findHandle = FindFirstFile(filePattern.c_str(), &fileInfo);\n        if (findHandle != INVALID_HANDLE_VALUE) {\n            do {\n                if (fileInfo.cFileName[0] != '.')\n                    files.push_back(path+dirSeparator+string(fileInfo.cFileName));\n            } while (FindNextFile(findHandle, &fileInfo));\n            FindClose(findHandle);\n        }\n    }\n    vector<HMODULE> plugins;\n#else\n    DIR* dir;\n    dirSeparator = '/';\n    pathSeparator = ':';\n    struct dirent *entry;\n\n    for (string path; std::getline(sdirectory, path, pathSeparator);) {\n        dir = opendir(path.c_str());\n        if (dir != NULL) {\n            while ((entry = readdir(dir)) != NULL) {\n                if (entry->d_name[0] != '.')\n                    files.push_back(path+dirSeparator+string(entry->d_name));\n            }\n            closedir(dir);\n        }\n    }\n\n    vector<void*> plugins;\n#endif\n    vector<string> loadedLibraries;\n    pluginLoadFailures.resize(0);\n    std::sort (files.begin(), files.end(), stringLengthComparator);\n\n    for (unsigned int i = 0; i < files.size(); ++i) {\n        try {\n            plugins.push_back(loadOneLibrary(files[i]));\n            loadedLibraries.push_back(files[i]);\n        } catch (OpenMMException& ex) {\n\t    pluginLoadFailures.push_back(ex.what());\n        }\n    }\n    initializePlugins(plugins);\n    return loadedLibraries;\n}\n\nconst string& Platform::getDefaultPluginsDirectory() {\n    char* dir = getenv(\"OPENMM_PLUGIN_DIR\");\n    static string directory;\n#ifdef _MSC_VER\n    if (dir != NULL)\n        directory = string(dir);\n    else {\n        dir = getenv(\"PROGRAMFILES\");\n        if (dir == NULL)\n            directory = \"C:\\\\\\\\Program Files\\\\OpenMM\\\\lib\\\\plugins\";\n        else\n            directory = string(dir)+\"\\\\OpenMM\\\\lib\\\\plugins\";\n    }\n#else\n    if (dir == NULL)\n        directory = \"/usr/local/openmm/lib/plugins\";\n    else\n        directory = string(dir);\n#endif\n    return directory;\n}\n\n// Some bizarre preprocessor magic required to convert a macro to a string...\n#define STRING1(x) #x\n#define STRING(x) STRING1(x)\n\nconst string& Platform::getOpenMMVersion() {\n#if OPENMM_BUILD_VERSION == 0\n    static const string version = STRING(OPENMM_MAJOR_VERSION) \".\" STRING(OPENMM_MINOR_VERSION);\n#else\n    static const string version = STRING(OPENMM_MAJOR_VERSION) \".\" STRING(OPENMM_MINOR_VERSION) \".\" STRING(OPENMM_BUILD_VERSION);\n#endif\n    return version;\n}\n\nContextImpl& Platform::getContextImpl(Context& context) const {\n    return *context.impl;\n}\n\nconst ContextImpl& Platform::getContextImpl(const Context& context) const {\n    return *context.impl;\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/libraries/irrxml/changes.txt",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/libraries/irrxml/example/irrXML.dsw",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/libraries/irrxml/example/irrXML.dsp",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/libraries/irrxml/include/irrString.h",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/libraries/irrxml/doc/irrXML.chm",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/wrappers/python/tests/systems/bcd-nabumetone_lig.dms",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/wrappers/python/tests/systems/alanine-dipeptide-explicit-amber99SBILDN-tip3p.dms",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/wrappers/python/tests/systems/bcd-nabumetone_rcpt.dms",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/wrappers/python/tests/systems/amber.ncrst",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/docs-source/Lepton User's Manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/docs-source/Lepton User's Manual.doc",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/docs-source/images/VisualStudioLaunch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/docs-source/images/SystemContextRelationships.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/docs-source/images/ArchitectureLayers.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/docs-source/images/VisualStudioSetConfiguration.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/docs-source/images/Argon.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/docs-source/images/OpenMMSetup.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/docs-source/images/EnergyDrift.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/docs-source/api-c++/_static/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/docs-source/api-python/_static/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/examples/input-charmm36.dms",
        "/tmp/vanessa/spack-stage/spack-stage-openmm-7.4.1-x2kxe2weul33v3s6vmhvwxrrfshes2zu/spack-src/examples/input-charmm36-tip5p.dms"
    ],
    "total_files": 1666
}