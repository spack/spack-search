{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/plugins/rack/rack_plugin.c": "#include \"uwsgi_rack.h\"\n\nextern struct uwsgi_server uwsgi;\n\nstruct uwsgi_rack ur;\nstruct uwsgi_plugin rack_plugin;\n\nstatic void uwsgi_opt_rbshell(char *opt, char *value, void *foobar) {\n\n        uwsgi.honour_stdin = 1;\n        if (value) {\n                ur.rbshell = value;\n        }\n        else {\n                ur.rbshell = \"\";\n        }\n\n        if (!strcmp(\"rbshell-oneshot\", opt)) {\n                ur.rb_shell_oneshot = 1;\n        }\n}\n\n\nstruct uwsgi_option uwsgi_rack_options[] = {\n\n        {\"rails\", required_argument, 0, \"load a rails <= 2.x app\", uwsgi_opt_set_str, &ur.rails, UWSGI_OPT_POST_BUFFERING},\n        {\"rack\", required_argument, 0, \"load a rack app\", uwsgi_opt_set_str, &ur.rack, UWSGI_OPT_POST_BUFFERING},\n        {\"ruby-gc-freq\", required_argument, 0, \"set ruby GC frequency\", uwsgi_opt_set_int, &ur.gc_freq, 0},\n        {\"rb-gc-freq\", required_argument, 0, \"set ruby GC frequency\", uwsgi_opt_set_int, &ur.gc_freq, 0},\n\n#ifdef RUBY19\n\t{\"rb-lib\", required_argument, 0, \"add a directory to the ruby libdir search path\", uwsgi_opt_add_string_list, &ur.libdir, 0},\n\t{\"ruby-lib\", required_argument, 0, \"add a directory to the ruby libdir search path\", uwsgi_opt_add_string_list, &ur.libdir, 0},\n#endif\n\n        {\"rb-require\", required_argument, 0, \"import/require a ruby module/script\", uwsgi_opt_add_string_list, &ur.rbrequire, 0},\n        {\"ruby-require\", required_argument, 0, \"import/require a ruby module/script\", uwsgi_opt_add_string_list, &ur.rbrequire, 0},\n        {\"rbrequire\", required_argument, 0, \"import/require a ruby module/script\", uwsgi_opt_add_string_list, &ur.rbrequire, 0},\n        {\"rubyrequire\", required_argument, 0, \"import/require a ruby module/script\", uwsgi_opt_add_string_list, &ur.rbrequire, 0},\n        {\"require\", required_argument, 0, \"import/require a ruby module/script\", uwsgi_opt_add_string_list, &ur.rbrequire, 0},\n\n        {\"shared-rb-require\", required_argument, 0, \"import/require a ruby module/script (shared)\", uwsgi_opt_add_string_list, &ur.shared_rbrequire, 0},\n        {\"shared-ruby-require\", required_argument, 0, \"import/require a ruby module/script (shared)\", uwsgi_opt_add_string_list, &ur.shared_rbrequire, 0},\n        {\"shared-rbrequire\", required_argument, 0, \"import/require a ruby module/script (shared)\", uwsgi_opt_add_string_list, &ur.shared_rbrequire, 0},\n        {\"shared-rubyrequire\", required_argument, 0, \"import/require a ruby module/script (shared)\", uwsgi_opt_add_string_list, &ur.shared_rbrequire, 0},\n        {\"shared-require\", required_argument, 0, \"import/require a ruby module/script (shared)\", uwsgi_opt_add_string_list, &ur.shared_rbrequire, 0},\n\n        {\"gemset\", required_argument, 0, \"load the specified gemset (rvm)\", uwsgi_opt_set_str, &ur.gemset, 0},\n        {\"rvm\", required_argument, 0, \"load the specified gemset (rvm)\", uwsgi_opt_set_str, &ur.gemset, 0},\n\n        {\"rvm-path\", required_argument, 0, \"search for rvm in the specified directory\", uwsgi_opt_add_string_list, &ur.rvm_path, 0},\n\n        {\"rbshell\", optional_argument, 0, \"run  a ruby/irb shell\", uwsgi_opt_rbshell, NULL, 0},\n        {\"rbshell-oneshot\", no_argument, 0, \"set ruby/irb shell (one shot)\", uwsgi_opt_rbshell, NULL, 0},\n\n        {0, 0, 0, 0, 0, 0 ,0},\n\n};\n\nstatic struct uwsgi_buffer *uwsgi_ruby_exception_class(struct wsgi_request *wsgi_req) {\n\tVALUE err = rb_errinfo();\n        VALUE e = rb_class_name(rb_class_of(err));\n        struct uwsgi_buffer *ub = uwsgi_buffer_new(RSTRING_LEN(e));\n        if (uwsgi_buffer_append(ub, RSTRING_PTR(e), RSTRING_LEN(e))) {\n                uwsgi_buffer_destroy(ub);\n                return NULL;\n        }\n        return ub;\n}\n\n\nstatic struct uwsgi_buffer *uwsgi_ruby_exception_msg(struct wsgi_request *wsgi_req) {\n\tVALUE err = rb_errinfo();\n\tVALUE e = rb_funcall(err, rb_intern(\"message\"), 0, 0);\n\tstruct uwsgi_buffer *ub = uwsgi_buffer_new(RSTRING_LEN(e));\n\tif (uwsgi_buffer_append(ub, RSTRING_PTR(e), RSTRING_LEN(e))) {\n\t\tuwsgi_buffer_destroy(ub);\n\t\treturn NULL;\n\t}\n\treturn ub;\n}\n\nstatic struct uwsgi_buffer *uwsgi_ruby_exception_repr(struct wsgi_request *wsgi_req) {\n\tstruct uwsgi_buffer *ub_class = uwsgi_ruby_exception_class(wsgi_req);\n\tif (!ub_class) return NULL;\n\n\tstruct uwsgi_buffer *ub_msg = uwsgi_ruby_exception_msg(wsgi_req);\n\tif (!ub_msg) {\n\t\tuwsgi_buffer_destroy(ub_class);\n\t\treturn NULL;\n\t}\n\n\tstruct uwsgi_buffer *ub = uwsgi_buffer_new(ub_class->pos + 3 + ub_msg->pos);\n\tif (uwsgi_buffer_append(ub, ub_msg->buf, ub_msg->pos)) goto error;\n\tif (uwsgi_buffer_append(ub, \" (\", 2)) goto error;\n\tif (uwsgi_buffer_append(ub, ub_class->buf, ub_class->pos)) goto error;\n\tif (uwsgi_buffer_append(ub, \")\", 1)) goto error;\n\n\tuwsgi_buffer_destroy(ub_class);\n\tuwsgi_buffer_destroy(ub_msg);\n\n\treturn ub;\n\n\nerror:\n\tuwsgi_buffer_destroy(ub_class);\n\tuwsgi_buffer_destroy(ub_msg);\n\tuwsgi_buffer_destroy(ub);\n\treturn NULL;\n\n}\n\n// simulate ruby_error_print (this is sad... but it works well)\nstatic void uwsgi_ruby_exception_log(struct wsgi_request *wsgi_req) {\n\tVALUE err = rb_errinfo();\n\tVALUE eclass = rb_class_name(rb_class_of(err));\n\tVALUE msg = rb_funcall(err, rb_intern(\"message\"), 0, 0);\n\t\n\tVALUE ary = rb_funcall(err, rb_intern(\"backtrace\"), 0);\n        int i;\n        for (i=0; i<RARRAY_LEN(ary); i++) {\n\t\tif (i == 0) {\n\t\t\tuwsgi_log(\"%s: %s (%s)\\n\", RSTRING_PTR(RARRAY_PTR(ary)[i]), RSTRING_PTR(msg), RSTRING_PTR(eclass));\n\t\t}\n\t\telse {\n        \t\tuwsgi_log(\"\\tfrom %s\\n\", RSTRING_PTR(RARRAY_PTR(ary)[i]));\n\t\t}\n        }\n}\n\nstatic struct uwsgi_buffer *uwsgi_ruby_backtrace(struct wsgi_request *wsgi_req) {\n\tVALUE err = rb_errinfo();\n\tVALUE ary = rb_funcall(err, rb_intern(\"backtrace\"), 0);\n\tint i;\n\tstruct uwsgi_buffer *ub = uwsgi_buffer_new(4096);\n\tchar *filename = NULL;\n\tchar *function = NULL;\n\tfor (i=0; i<RARRAY_LEN(ary); i++) {\n\t\tchar *bt = RSTRING_PTR(RARRAY_PTR(ary)[i]);\n\t\t// ok let's start the C dance to parse the backtrace\n\t\tchar *colon = strchr(bt, ':');\n\t\tif (!colon) continue;\n\t\tfilename = uwsgi_concat2n(bt, (int) (colon-bt), \"\", 0);\n\t\tuint16_t filename_len = colon-bt;\n\t\tcolon++; if (*colon == 0) goto error;\n\t\tchar *lineno_ptr = colon;\n\t\tcolon = strchr(lineno_ptr, ':');\n\t\tif (!colon) goto error;\n\t\tint64_t lineno = uwsgi_str_num(lineno_ptr, (int) (colon-lineno_ptr));\n\t\tcolon++; if (*colon == 0) goto error;\n\t\tcolon = strchr(lineno_ptr, '`');\n\t\tif (!colon) goto error;\n\t\tcolon++; if (*colon == 0) goto error;\n\t\tchar *function_ptr = colon;\n\t\tchar *function_end = strchr(function_ptr, '\\'');\n\t\tif (!function_end) goto error;\n\t\tfunction = uwsgi_concat2n(function_ptr, (int) (function_end-function_ptr), \"\", 0);\n\t\tuint16_t function_len = function_end-function_ptr;\n\n\t\tif (uwsgi_buffer_u16le(ub, filename_len)) goto error;\n\t\tif (uwsgi_buffer_append(ub, filename, filename_len)) goto error;\n\t\tif (uwsgi_buffer_append_valnum(ub, lineno)) goto error;\n\t\tif (uwsgi_buffer_u16le(ub, function_len)) goto error;\n\t\tif (uwsgi_buffer_append(ub, function, function_len)) goto error;\n\n\t\t// in ruby we do not have text/code nor custom\n\t\tif (uwsgi_buffer_u16le(ub, 0)) goto error;\n\t\tif (uwsgi_buffer_append(ub, \"\", 0)) goto error;\n\t\tif (uwsgi_buffer_u16le(ub, 0)) goto error;\n\t\tif (uwsgi_buffer_append(ub, \"\", 0)) goto error;\n\n\t\tfree(filename);\n\t\tfilename = NULL;\n\t\tfree(function);\n\t\tfunction = NULL;\n\t}\n\n\treturn ub;\n\nerror:\n\tuwsgi_buffer_destroy(ub);\n\n\tif (filename) {\n\t\tfree(filename);\n\t}\n\n\tif (function) {\n\t\tfree(function);\n\t}\n\n\treturn NULL;\n}\n\nVALUE rb_uwsgi_io_new(VALUE class, VALUE wr) {\n\n\tstruct wsgi_request *wsgi_req;\n\tData_Get_Struct(wr, struct wsgi_request, wsgi_req);\n\tVALUE self = Data_Wrap_Struct(class , 0, 0, wsgi_req);\n\n\trb_obj_call_init(self, 0, NULL);\n\n\treturn self;\n\n}\n\nVALUE rb_uwsgi_io_init(int argc, VALUE *argv, VALUE self) {\n\n\treturn self;\n}\n\nVALUE rb_uwsgi_io_gets(VALUE obj, VALUE args) {\n\n\tstruct wsgi_request *wsgi_req;\n\tData_Get_Struct(obj, struct wsgi_request, wsgi_req);\n\n\tssize_t rlen = 0;\n\n\tchar *buf = uwsgi_request_body_readline(wsgi_req, 0, &rlen);\n\tif (buf) {\n\t\treturn rb_str_new(buf, rlen);\n\t}\n\treturn Qnil;\n}\n\nVALUE rb_uwsgi_io_each(VALUE obj, VALUE args) {\n\n\tif (!rb_block_given_p())\n\t\trb_raise(rb_eArgError, \"Expected block on rack.input 'each' method\");\n\n\t// yield strings chunks\n\tfor(;;) {\n\t\tVALUE chunk = rb_uwsgi_io_gets(obj, Qnil);\n\t\tif (chunk == Qnil) {\n\t\t\treturn Qnil;\n\t\t}\n\t\trb_yield(chunk);\n\t}\n\t// never here\n\treturn Qnil;\n}\n\nVALUE rb_uwsgi_io_read(VALUE obj, VALUE args) {\n\n\tstruct wsgi_request *wsgi_req;\n\tData_Get_Struct(obj, struct wsgi_request, wsgi_req);\n\tlong hint = 0;\n\tint length_given = 0;\n\n/*\n\tWhen EOF is reached, this method returns nil if length is given and not nil, or \"\" if length is not given or is nil.\n\tIf buffer is given, then the read data will be placed into buffer instead of a newly created String object.\n*/\n\n\tif (RARRAY_LEN(args) > 0) {\n\t\tif (RARRAY_PTR(args)[0] != Qnil) {\n\t\t\thint = NUM2LONG(RARRAY_PTR(args)[0]); \n\t\t\tlength_given = 1;\n\t\t}\n\t}\n\n\tssize_t rlen = 0;\n\tchar *buf = uwsgi_request_body_read(wsgi_req, hint, &rlen);\n\tif (buf) {\n\t\tif (length_given && buf == uwsgi.empty) {\n\t\t\treturn Qnil;\n\t\t}\n\t\tif (RARRAY_LEN(args) > 1) {\n                        rb_str_cat(RARRAY_PTR(args)[1], buf, rlen);\n                }\n\t\treturn rb_str_new(buf, rlen);\n\t}\n\n\treturn Qnil;\n}\n\nVALUE rb_uwsgi_io_rewind(VALUE obj, VALUE args) {\n\n\tstruct wsgi_request *wsgi_req;\n\tData_Get_Struct(obj, struct wsgi_request, wsgi_req);\n\tuwsgi_request_body_seek(wsgi_req, 0);\n\treturn Qnil;\n}\n\n#ifdef RUBY19\n#ifdef RUBY_GLOBAL_SETUP\nRUBY_GLOBAL_SETUP\n#endif\n#endif\n\nVALUE uwsgi_require_file(VALUE arg) {\n    return rb_funcall(rb_cObject, rb_intern(\"require\"), 1, arg);\n}\n\nVALUE require_rack(VALUE arg) {\n    return rb_funcall(rb_cObject, rb_intern(\"require\"), 1, rb_str_new2(\"rack\"));\n}\n\nVALUE require_rails(VALUE arg) {\n#ifdef RUBY19\n    return rb_require(\"./config/environment\");\n#else\n    return rb_require(\"config/environment\");\n#endif\n}\n\nVALUE require_thin(VALUE arg) {\n    return rb_funcall(rb_cObject, rb_intern(\"require\"), 1, rb_str_new2(\"thin\"));\n}\n\nVALUE init_rack_app(VALUE);\n\nVALUE rack_call_rpc_handler(VALUE args) {\n        VALUE rpc_args = rb_ary_entry(args, 1);\n        return rb_funcall2(rb_ary_entry(args, 0), rb_intern(\"call\"), (int) RARRAY_LEN(rpc_args), RARRAY_PTR(rpc_args));\n}\n\n\nuint64_t uwsgi_ruby_rpc(void *func, uint8_t argc, char **argv, uint16_t argvs[], char **buffer) {\n\n        uint8_t i;\n\tVALUE rb_args = rb_ary_new2(2);\n        VALUE rb_rpc_args = rb_ary_new2(argc);\n        VALUE ret;\n\tint error = 0;\n        char *rv;\n        size_t rl;\n\n\trb_ary_store(rb_args, 0, (VALUE) func);\n\n        for (i = 0; i < argc; i++) {\n                rb_ary_store(rb_rpc_args, i, rb_str_new(argv[i], argvs[i]));\n        }\n\trb_ary_store(rb_args, 1, rb_rpc_args);\n\n\n\tret = rb_protect(rack_call_rpc_handler, rb_args, &error);\n\n        if (error) {\n\t\tuwsgi_ruby_exception_log(NULL);\n\t\treturn 0;\n\t}\n\n\tif (TYPE(ret) == T_STRING) {\n        \trv = RSTRING_PTR(ret);\n                rl = RSTRING_LEN(ret);\n                if (rl > 0) {\n\t\t\t*buffer = uwsgi_malloc(rl);\n                \tmemcpy(*buffer, rv, rl);\n                        return rl;\n                }\n        }\n\n        return 0;\n\n}\n\nvoid uwsgi_ruby_gem_set_apply(char *gemset) {\n\n\tint in_pipe[2];\n\tint out_pipe[2];\n\tsize_t size;\n\tint waitpid_status;\n\tsize_t i;\n\n        if (pipe(in_pipe)) {\n        \tuwsgi_error(\"pipe()\");\n                exit(1);\n        }\n\n        if (pipe(out_pipe)) {\n        \tuwsgi_error(\"pipe()\");\n                exit(1);\n        }\n\n        pid_t pid = uwsgi_run_command(\"bash\", in_pipe, out_pipe[1] );\n\n\tchar *gemset_code = uwsgi_open_and_read(gemset, &size, 0, NULL);\n\n\tif (write(in_pipe[1], gemset_code, size) != (ssize_t) size ) {\n\t\tuwsgi_error(\"write()\");\n\t}\n\n\tfree(gemset_code);\n\n\tif (write(in_pipe[1], \"printenv\\n\", 9) != 9 ) {\n\t\tuwsgi_error(\"write()\");\n\t}\n\n        close(in_pipe[1]);\n\n\tsize = 0;\n        char *buffer = uwsgi_read_fd(out_pipe[0], &size, 0);\n\n        close(out_pipe[0]);\n\n\tchar *ptr = buffer;\n\n\n\tfor(i=0;i<size;i++) {\n\t\tif (buffer[i] == '\\n') {\n\t\t\tbuffer[i] = 0;\n\t\t\tif (putenv(ptr)) {\n\t\t\t\tuwsgi_error(\"putenv()\");\n\t\t\t}\n\t\t\tptr = buffer + i + 1;\n\t\t}\n\t}\n\n\t// do not free the buffer\n        // environ will reuse it !!!\n\t//free(buffer);\n\n\tif (waitpid(pid, &waitpid_status, 0) <0) {\n\t\tuwsgi_error(\"waitpid()\");\n\t}\n}\n\nvoid uwsgi_ruby_gemset(char *gemset) {\n\n\tstruct uwsgi_string_list *rvm_paths = ur.rvm_path;\n\twhile(rvm_paths) {\n\t\tchar *filename = uwsgi_concat3(rvm_paths->value, \"/environments/\", gemset);\n                if (uwsgi_file_exists(filename)) {\n\t\t\tuwsgi_ruby_gem_set_apply(filename);\n                        free(filename);\n                        return;\n                }\n                free(filename);\n\t\trvm_paths = rvm_paths->next;\n\t}\n\n\tchar *home = getenv(\"HOME\");\n\n\tif (home) {\n\t\tchar *filename = uwsgi_concat3(home, \"/.rvm/environments/\", gemset);\n\t\tif (uwsgi_file_exists(filename)) {\n\t\t\tuwsgi_ruby_gem_set_apply(filename);\n\t\t\tfree(filename);\n\t\t\treturn;\n\t\t}\n\t\tfree(filename);\n\t}\n\n\tchar *filename = uwsgi_concat2(\"/usr/local/rvm/environments/\", gemset);\n\tif (uwsgi_file_exists(filename)) {\n\t\tuwsgi_ruby_gem_set_apply(filename);\n                free(filename);\n                return;\n        }\n        free(filename);\n\n\tuwsgi_log(\"ERROR: unable to load gemset %s !!!\\n\", gemset);\n\texit(1);\n\t\n}\n\nstatic void rack_hack_dollar_zero(VALUE name, ID id) {\n\tur.dollar_zero = rb_obj_as_string(name);\n\trb_obj_taint(ur.dollar_zero);\n}\n\n#ifndef RUBY19\nvoid Init_stack(VALUE*);\n#endif\n\nint uwsgi_rack_init(){\n\n#ifdef RUBY19\n        int argc = 2;\n        char *sargv[] = { (char *) \"uwsgi\", (char *) \"-e0\" };\n        char **argv = sargv;\n#endif\n\n\tif (ur.gemset) {\n\t\tuwsgi_ruby_gemset(ur.gemset);\n\t}\n\n#ifdef RUBY19\n\truby_sysinit(&argc, &argv);\n        RUBY_INIT_STACK\n#ifdef UWSGI_RUBY_HEROKU\n\tuwsgi_log(\"*** Heroku system detected ***\\n\");\n#endif\n#ifdef RUBY_EXEC_PREFIX\n\tif (!strcmp(RUBY_EXEC_PREFIX, \"\")) {\n\t\tuwsgi_log(\"*** detected a ruby vm built with --enable-load-relative ***\\n\");\n\t\tuwsgi_log(\"*** if you get errors about rubygems.rb, you can:\\n\");\n\t\tuwsgi_log(\"*** 1) add a directory to the libdir search path using --ruby-libdir ***\\n\");\n\t\tuwsgi_log(\"*** 2) force the RUBY_EXEC_PREFIX with --chdir ***\\n\");\n\t}\n#endif\n\n#ifdef UWSGI_RUBY_LIBDIR\n\tuwsgi_string_new_list(&ur.libdir, UWSGI_RUBY_LIBDIR);\n#endif\n#ifdef UWSGI_RUBY_ARCHDIR\n\tuwsgi_string_new_list(&ur.libdir, UWSGI_RUBY_ARCHDIR);\n#endif\n\n\truby_init();\n\tstruct uwsgi_string_list *usl = ur.libdir;\n\twhile(usl) {\n\t\truby_incpush(usl->value);\n\t\tuwsgi_log(\"[ruby-libdir] pushed %s\\n\", usl->value);\n\t\tusl = usl->next;\n\t}\n\truby_options(argc, argv);\n#else\n\truby_init();\n\tVALUE dummy;\n\tInit_stack(&dummy);\n\truby_init_loadpath();\n#endif\n\n\truby_show_version();\n\n\truby_script(\"uwsgi\");\n\n\tur.dollar_zero = rb_str_new2(\"uwsgi\");\n\trb_define_hooked_variable(\"$0\", &ur.dollar_zero, 0, rack_hack_dollar_zero);\n\trb_define_hooked_variable(\"$PROGRAM_NAME\", &ur.dollar_zero, 0, rack_hack_dollar_zero);\n\n\tur.signals_protector = rb_ary_new();\n\tur.rpc_protector = rb_ary_new();\n\trb_gc_register_address(&ur.signals_protector);\n\trb_gc_register_address(&ur.rpc_protector);\n\n\tuwsgi_rack_init_api();\t\n\n\treturn 0;\n}\n\nvoid uwsgi_rack_preinit_apps() {\n\n\tstruct uwsgi_string_list *usl = ur.shared_rbrequire;\n        while(usl) {\n                int error = 0;\n                rb_protect( uwsgi_require_file, rb_str_new2(usl->value), &error ) ;\n                if (error) {\n\t\t\tuwsgi_ruby_exception_log(NULL);\n                }\n                usl = usl->next;\n        }\n\n}\n\nVALUE uwsgi_rb_call_new(VALUE obj) {\n    return rb_funcall(obj, rb_intern(\"new\"), 0);\n}\n\nvoid uwsgi_rack_init_apps(void) {\n\n\tint error;\n\n\tif (uwsgi_apps_cnt >= uwsgi.max_apps) {\n                uwsgi_log(\"ERROR: you cannot load more than %d apps in a worker\\n\", uwsgi.max_apps);\n\t\treturn;\n        }\n\n\n\tur.app_id = uwsgi_apps_cnt;\n\tstruct uwsgi_string_list *usl = ur.rbrequire;\n\n\ttime_t now = uwsgi_now();\n\n\twhile(usl) {\n\t\terror = 0;\n\t\trb_protect( uwsgi_require_file, rb_str_new2(usl->value), &error ) ;\n                if (error) {\n\t\t\tuwsgi_ruby_exception_log(NULL);\n\t\t}\n\t\tusl = usl->next;\n\t}\n\n\tif (ur.rack) {\n\t\tur.dispatcher = rb_protect(init_rack_app, rb_str_new2(ur.rack), &error);\n\t\tif (error) {\n\t\t\tuwsgi_ruby_exception_log(NULL);\n                        exit(1);\n                }\n\t\tif (ur.dispatcher == Qnil) {\n\t\t\tuwsgi_log(\"unable to find RACK entry point\\n\");\n\t\t\texit(1);\n\t\t}\n\t\trb_gc_register_address(&ur.dispatcher);\n\n\t\tgoto ready;\n\t}\n\telse if (ur.rails) {\n\t\tif (chdir(ur.rails)) {\n\t\t\tuwsgi_error(\"chdir()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!access(\"config.ru\", R_OK)) {\n\t\t\tuwsgi_log(\"!!! a config.ru file has been found in yor rails app, please use --rack <configfile> instead of the old --rails <app> !!!\\n\");\n\t\t}\n\n\t\tuwsgi_log(\"loading rails app %s\\n\", ur.rails);\n\t\trb_protect( require_rails, 0, &error ) ;\n\t\tif (error) {\n\t\t\tuwsgi_ruby_exception_log(NULL);\n\t\t\texit(1);\n                }\n\t\tuwsgi_log(\"rails app %s ready\\n\", ur.rails);\n\t\tVALUE ac = rb_const_get(rb_cObject, rb_intern(\"ActionController\"));\n\n\t\tur.dispatcher = Qnil;\n\t\tif (rb_funcall(ac, rb_intern(\"const_defined?\"), 1, ID2SYM(rb_intern(\"Dispatcher\"))) == Qtrue) {\n\n\t\t\tVALUE ac_dispatcher = rb_const_get(ac, rb_intern(\"Dispatcher\"));\n\n\t\t\tVALUE acd_instance_methods = rb_funcall( ac_dispatcher, rb_intern(\"instance_methods\"), 0);\n\n\t\t\tVALUE acim_call = rb_funcall( acd_instance_methods, rb_intern(\"include?\"), 1, ID2SYM(rb_intern(\"call\")));\n\n\t\t\tif (acim_call == Qfalse) {\n\t\t\t\tacim_call = rb_funcall( acd_instance_methods, rb_intern(\"include?\"), 1, rb_str_new2(\"call\"));\n\t\t\t}\n\n\t\t\tif (acim_call == Qtrue) {\n                        \tur.dispatcher = rb_protect(uwsgi_rb_call_new, ac_dispatcher, &error);\n\t\t\t\tif (error) {\n\t\t\t\t\tuwsgi_ruby_exception_log(NULL);\n                        \t\texit(1);\n\t\t\t\t}\n\t\t\t}\n                }\n\n                if (ur.dispatcher == Qnil)  {\n                        uwsgi_log(\"non-rack rails version detected...loading thin adapter...\\n\");\n\t\t\trb_protect( require_thin, 0, &error ) ;\n                \tif (error) {\n\t\t\t\tuwsgi_ruby_exception_log(NULL);\n                        \texit(1);\n                \t}\n\t\t\tVALUE thin_rack = rb_const_get(rb_cObject, rb_intern(\"Rack\"));\n\t\t\tVALUE thin_rack_adapter = rb_const_get(thin_rack, rb_intern(\"Adapter\"));\n\t\t\tVALUE thin_rack_adapter_rails = rb_const_get(thin_rack_adapter, rb_intern(\"Rails\"));\n\t\t\tur.dispatcher = rb_protect( uwsgi_rb_call_new, thin_rack_adapter_rails, &error);\n\t\t\tif (error) {\n\t\t\t\tuwsgi_ruby_exception_log(NULL);\n                        \texit(1);\n\t\t\t}\n                }\n\n\n\t\tif (ur.dispatcher == Qnil) {\n\t\t\tuwsgi_log(\"unable to load rails dispatcher\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\trb_gc_register_address(&ur.dispatcher);\n\n\t\tgoto ready;\n\t}\n\n\treturn;\n\nready:\n\tur.call = rb_intern(\"call\");\n\tif (!ur.call) {\n\t\tuwsgi_log(\"unable to find RACK entry point\\n\");\n\t\treturn;\n\t}\n\trb_gc_register_address(&ur.call);\n\n\n\tur.rb_uwsgi_io_class = rb_define_class(\"Uwsgi_IO\", rb_cObject);\n\n\trb_gc_register_address(&ur.rb_uwsgi_io_class);\n\n\trb_define_singleton_method(ur.rb_uwsgi_io_class, \"new\", rb_uwsgi_io_new, 1);\n\trb_define_method(ur.rb_uwsgi_io_class, \"initialize\", rb_uwsgi_io_init, -1);\n\trb_define_method(ur.rb_uwsgi_io_class, \"gets\", rb_uwsgi_io_gets, 0);\n\trb_define_method(ur.rb_uwsgi_io_class, \"each\", rb_uwsgi_io_each, 0);\n\trb_define_method(ur.rb_uwsgi_io_class, \"read\", rb_uwsgi_io_read, -2);\n\trb_define_method(ur.rb_uwsgi_io_class, \"rewind\", rb_uwsgi_io_rewind, 0);\n\n\tstruct uwsgi_app *ua = uwsgi_add_app(ur.app_id, rack_plugin.modifier1, (char*)\"\", 0, NULL, NULL);\n\tua->started_at = now;\n\tua->startup_time = uwsgi_now() - now;\n\n\tuwsgi_emulate_cow_for_apps(ur.app_id);\n\t\n\tif (ur.gc_freq <= 1) {\n        \tuwsgi_log(\"RACK app %d loaded in %d seconds at %p (GC frequency: AGGRESSIVE)\\n\", ur.app_id, (int) ua->startup_time, ur.call);\n\t}\n\telse {\n        \tuwsgi_log(\"RACK app %d loaded in %d seconds at %p (GC frequency: %d)\\n\", ur.app_id, (int) ua->startup_time, ur.call, ur.gc_freq);\n\t}\n\n}\n\nVALUE call_dispatch(VALUE env) {\n\n\treturn rb_funcall(ur.dispatcher, ur.call, 1, env);\n\n}\n\nstatic VALUE send_body(VALUE obj) {\n\n\tstruct wsgi_request *wsgi_req = current_wsgi_req();\n\n\t//uwsgi_log(\"sending body\\n\");\n\tif (TYPE(obj) == T_STRING) {\n\t\tuwsgi_response_write_body_do(wsgi_req, RSTRING_PTR(obj), RSTRING_LEN(obj));\n\t}\n\telse {\n\t\tuwsgi_log(\"UNMANAGED BODY TYPE %d\\n\", TYPE(obj));\n\t}\n\n\treturn Qnil;\n}\n\nVALUE body_to_path(VALUE body) {\n        return rb_funcall( body, rb_intern(\"to_path\"), 0);\n}\n\n\nVALUE close_body(VALUE body) {\n\treturn rb_funcall( body, rb_intern(\"close\"), 0);\n}\n\nVALUE iterate_body(VALUE body) {\n\n#ifdef RUBY19\n\treturn rb_block_call(body, rb_intern(\"each\"), 0, 0, send_body, 0);\n#else\n\treturn rb_iterate(rb_each, body, send_body, 0);\n#endif\n}\n\nVALUE send_header(VALUE obj, VALUE headers) {\n\n\tstruct wsgi_request *wsgi_req = current_wsgi_req();\n\n\tVALUE hkey, hval;\n\t\n\t//uwsgi_log(\"HEADERS %d\\n\", TYPE(obj));\n\tif (TYPE(obj) == T_ARRAY) {\n\t\tif (RARRAY_LEN(obj) >= 2) {\n\t\t\thkey = rb_obj_as_string( RARRAY_PTR(obj)[0]);\n\t\t\thval = rb_obj_as_string( RARRAY_PTR(obj)[1]);\n\n\t\t}\n\t\telse {\n\t\t\tgoto clear;\n\t\t}\n\t}\n\telse if (TYPE(obj) == T_STRING) {\n\t\thkey = obj;\n#ifdef RUBY19\n\t\thval = rb_hash_lookup(headers, obj);\n#else\n\t\thval = rb_hash_aref(headers, obj);\n#endif\n\t}\n\telse {\n\t\tgoto clear;\n\t}\n\n\tif (TYPE(hkey) != T_STRING || TYPE(hval) != T_STRING) {\n\t\tgoto clear;\n\t}\n\n\tchar *header_value = RSTRING_PTR(hval);\n\tsize_t header_value_len = RSTRING_LEN(hval);\n\tsize_t i,cnt=0;\n\tchar *this_header = header_value;\n\n\tfor(i=0;i<header_value_len;i++) {\n\t\t// multiline header, send it !!!\n\t\tif (header_value[i] == '\\n') {\n\t\t\tuwsgi_response_add_header(wsgi_req, RSTRING_PTR(hkey), RSTRING_LEN(hkey), this_header, cnt);\n\t\t\tthis_header += cnt+1;\n\t\t\tcnt = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tcnt++;\t\n\t}\n\n\tif (cnt > 0) {\n\t\tuwsgi_response_add_header(wsgi_req, RSTRING_PTR(hkey), RSTRING_LEN(hkey), this_header, cnt);\n\t}\n\nclear:\n\n\treturn Qnil;\n}\n\nVALUE iterate_headers(VALUE headers) {\n\n#ifdef RUBY19\n        return rb_block_call(headers, rb_intern(\"each\"), 0, 0, send_header, headers );\n#else\n        return rb_iterate(rb_each, headers, send_header, headers);\n#endif\n\n}\n\n\n\nint uwsgi_rack_request(struct wsgi_request *wsgi_req) {\n\n\tint error = 0;\n\tint i;\n\tVALUE env, ret, status, headers, body;\n\n\tif (!ur.call) {\n\t\tuwsgi_500(wsgi_req);\n\t\tuwsgi_log(\"--- ruby application not found ---\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Standard RACK request */\n        if (!wsgi_req->uh->pktsize) {\n                uwsgi_log(\"Empty RACK request. skip.\\n\");\n                return -1;\n        }\n\n        if (uwsgi_parse_vars(wsgi_req)) {\n                return -1;\n        }\n\n\twsgi_req->app_id = ur.app_id;\n\tuwsgi_apps[wsgi_req->app_id].requests++;\n\n        env = rb_hash_new();\n\t// the following vars have to always been defined (we skip REQUEST_METHOD and PATH_INFO as they should always be available)\n\trb_hash_aset(env, rb_str_new2(\"SCRIPT_NAME\"), rb_str_new2(\"\"));\n\trb_hash_aset(env, rb_str_new2(\"QUERY_STRING\"), rb_str_new2(\"\"));\n\trb_hash_aset(env, rb_str_new2(\"SERVER_NAME\"), rb_str_new2(uwsgi.hostname));\n\t// SERVER_PORT\n        char *server_port = strchr(wsgi_req->socket->name, ':');\n        if (server_port) {\n\t\trb_hash_aset(env, rb_str_new2(\"SERVER_PORT\"), rb_str_new(server_port+1, strlen(server_port+1)));\n        }\n        else {\n\t\trb_hash_aset(env, rb_str_new2(\"SERVER_PORT\"), rb_str_new2(\"80\"));\n        }\n\n        // fill ruby hash\n        for(i=0;i<wsgi_req->var_cnt;i++) {\n\n\t\t// put the var only if it is not 0 size or required (rack requirement... very inefficient)\n\t\tif (wsgi_req->hvec[i+1].iov_len > 0 || \n\t\t\t\t\t!uwsgi_strncmp((char *)\"REQUEST_METHOD\", 14, wsgi_req->hvec[i].iov_base, (int) wsgi_req->hvec[i].iov_len) ||\n\t\t\t\t\t!uwsgi_strncmp((char *)\"SCRIPT_NAME\", 11, wsgi_req->hvec[i].iov_base, (int) wsgi_req->hvec[i].iov_len) ||\n\t\t\t\t\t!uwsgi_strncmp((char *)\"PATH_INFO\", 10, wsgi_req->hvec[i].iov_base, (int) wsgi_req->hvec[i].iov_len) ||\n\t\t\t\t\t!uwsgi_strncmp((char *)\"QUERY_STRING\", 12, wsgi_req->hvec[i].iov_base, (int) wsgi_req->hvec[i].iov_len) ||\n\t\t\t\t\t!uwsgi_strncmp((char *)\"SERVER_NAME\", 11, wsgi_req->hvec[i].iov_base, (int) wsgi_req->hvec[i].iov_len) ||\n\t\t\t\t\t!uwsgi_strncmp((char *)\"SERVER_PORT\", 11, wsgi_req->hvec[i].iov_base, (int) wsgi_req->hvec[i].iov_len)\n\t\t\t\t\t\t\t) {\n\t\t\trb_hash_aset(env, rb_str_new(wsgi_req->hvec[i].iov_base, wsgi_req->hvec[i].iov_len),\n\t\t\t\t\trb_str_new(wsgi_req->hvec[i+1].iov_base, wsgi_req->hvec[i+1].iov_len));\n\n\t\t\t//uwsgi_log(\"%.*s = %.*s\\n\", wsgi_req->hvec[i].iov_len, wsgi_req->hvec[i].iov_base, wsgi_req->hvec[i+1].iov_len, wsgi_req->hvec[i+1].iov_base);\n\t\t}\n                i++;\n        }\n\n\n\tVALUE rbv = rb_ary_new();\n\trb_ary_store(rbv, 0, INT2NUM(1));\n\trb_ary_store(rbv, 1, INT2NUM(1));\n\trb_hash_aset(env, rb_str_new2(\"rack.version\"), rbv);\n\n\tif (wsgi_req->scheme_len > 0) {\n\t\trb_hash_aset(env, rb_str_new2(\"rack.url_scheme\"), rb_str_new(wsgi_req->scheme, wsgi_req->scheme_len));\n        }\n        else if (wsgi_req->https_len > 0) {\n                if (!strncasecmp(wsgi_req->https, \"on\", 2) || wsgi_req->https[0] == '1') {\n\t\t\trb_hash_aset(env, rb_str_new2(\"rack.url_scheme\"), rb_str_new2(\"https\"));\n                }\n                else {\n\t\t\trb_hash_aset(env, rb_str_new2(\"rack.url_scheme\"), rb_str_new2(\"http\"));\n                }\n        }\n        else {\n\t\trb_hash_aset(env, rb_str_new2(\"rack.url_scheme\"), rb_str_new2(\"http\"));\n        }\n\n\n\tif (uwsgi.threads > 1) {\n\t\trb_hash_aset(env, rb_str_new2(\"rack.multithread\"), Qtrue);\n\t}\n\telse {\n\t\trb_hash_aset(env, rb_str_new2(\"rack.multithread\"), Qfalse);\n\t}\n\n\tif (uwsgi.numproc > 1) {\n\t\trb_hash_aset(env, rb_str_new2(\"rack.multiprocess\"), Qtrue);\n\t}\n\telse {\n\t\trb_hash_aset(env, rb_str_new2(\"rack.multiprocess\"), Qfalse);\n\t}\n\n\trb_hash_aset(env, rb_str_new2(\"rack.run_once\"), Qfalse);\n\n\tVALUE dws_wr = Data_Wrap_Struct(ur.rb_uwsgi_io_class, 0, 0, wsgi_req);\n\n\trb_hash_aset(env, rb_str_new2(\"rack.input\"), rb_funcall(ur.rb_uwsgi_io_class, rb_intern(\"new\"), 1, dws_wr ));\n\n\trb_hash_aset(env, rb_str_new2(\"rack.errors\"), rb_funcall( rb_const_get(rb_cObject, rb_intern(\"IO\")), rb_intern(\"new\"), 2, INT2NUM(2), rb_str_new(\"w\",1) ));\n\n\trb_hash_aset(env, rb_str_new2(\"uwsgi.core\"), INT2NUM(wsgi_req->async_id));\n\trb_hash_aset(env, rb_str_new2(\"uwsgi.version\"), rb_str_new2(UWSGI_VERSION));\n\trb_hash_aset(env, rb_str_new2(\"uwsgi.node\"), rb_str_new2(uwsgi.hostname));\n\n\t// remove HTTP_CONTENT_LENGTH and HTTP_CONTENT_TYPE\n\trb_hash_delete(env, rb_str_new2(\"HTTP_CONTENT_LENGTH\"));\n\trb_hash_delete(env, rb_str_new2(\"HTTP_CONTENT_TYPE\"));\n\n\tif (ur.unprotected) {\n\t\tret = call_dispatch(env);\n\t}\n\telse {\n\t\tret = rb_protect( call_dispatch, env, &error);\n\t\tif (error) {\n\t\t\tuwsgi_manage_exception(wsgi_req, uwsgi.catch_exceptions);\n\t\t\tgoto clear;\n\t\t}\n\t}\n\n\n\tif (TYPE(ret) == T_ARRAY) {\n\t\tif (RARRAY_LEN(ret) != 3) {\n\t\t\tuwsgi_log(\"Invalid RACK response size: %ld\\n\", RARRAY_LEN(ret));\n\t\t\treturn -1;\n\t\t}\n\n\t\t// manage Status\n\n\t\tstatus = rb_obj_as_string(RARRAY_PTR(ret)[0]);\n\t\t// get the status code\n\n\t\tif (uwsgi_response_prepare_headers(wsgi_req, RSTRING_PTR(status), RSTRING_LEN(status))) {\n\t\t\tgoto clear;\n\t\t}\n\n\t\theaders = RARRAY_PTR(ret)[1] ;\n\t\tif (rb_respond_to( headers, rb_intern(\"each\") )) {\n\t\t\trb_protect( iterate_headers, headers, &error);\n\t\t\tif (error) {\n\t\t\t\tuwsgi_manage_exception(wsgi_req, uwsgi.catch_exceptions);\n\t\t\t\tgoto clear;\n\t\t\t}\n\t\t}\n\n\t\tbody = RARRAY_PTR(ret)[2] ;\n\n\t\tif (rb_respond_to( body, rb_intern(\"to_path\") )) {\n\t\t\tVALUE sendfile_path = rb_protect( body_to_path, body, &error);\n\t\t\tif (error) {\n\t\t\t\tuwsgi_manage_exception(wsgi_req, uwsgi.catch_exceptions);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint fd = open(RSTRING_PTR(sendfile_path), O_RDONLY);\n\t\t\t\tif (fd < 0) goto clear;\n\t\t\t\t// the following function will close the descriptor\n\t\t\t\tuwsgi_response_sendfile_do(wsgi_req, fd, 0, 0);\n\t\t\t}\n\t\t}\n\t\telse if (rb_respond_to( body, rb_intern(\"each\") )) {\n\t\t\tif (ur.unprotected) {\n\t\t\t\titerate_body(body);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trb_protect( iterate_body, body, &error);\n\t\t\t\tif (error) {\n\t\t\t\t\tuwsgi_manage_exception(wsgi_req, uwsgi.catch_exceptions);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (rb_respond_to( body, rb_intern(\"close\") )) {\n\t\t\t//uwsgi_log(\"calling close\\n\");\n\t\t\trb_protect( close_body, body, &error);\n\t\t\tif (error) {\n\t\t\t\tuwsgi_manage_exception(wsgi_req, uwsgi.catch_exceptions);\n                        }\n\t\t}\n\n\t}\n\telse {\n\t\tuwsgi_500(wsgi_req);\n\t\tuwsgi_log(\"invalid RACK response\\n\");\n\t}\n\nclear:\n\n\tif (ur.gc_freq <= 1 || ur.cycles%ur.gc_freq == 0) {\n#ifdef UWSGI_DEBUG\n\t\t\tuwsgi_log(\"calling ruby GC\\n\");\n#endif\n\t\t\t// try to limit damanges if threads are enabled...\n\t\t\tif (wsgi_req->async_id == 0) {\n\t\t\t\trb_gc();\n\t\t\t}\n\t}\n\n\tur.cycles++;\n\n\treturn 0;\n}\n\nvoid uwsgi_rack_after_request(struct wsgi_request *wsgi_req) {\n\tlog_request(wsgi_req);\n}\n\nvoid uwsgi_rack_suspend(struct wsgi_request *wsgi_req) {\n\t//uwsgi_log(\"SUSPENDING RUBY\\n\");\n}\n\nvoid uwsgi_rack_resume(struct wsgi_request *wsgi_req) {\n\t//uwsgi_log(\"RESUMING RUBY\\n\");\n}\n\nVALUE init_rack_app( VALUE script ) {\n\n\tint error;\n\n#ifndef RUBY19\n\trb_require(\"rubygems\");\n#endif\n        rb_protect( require_rack, 0, &error ) ;\n        if (error) {\n\t\tuwsgi_ruby_exception_log(NULL);\n\t\treturn Qnil;\n        }\n\n        VALUE rack = rb_const_get(rb_cObject, rb_intern(\"Rack\"));\n\n#ifdef RUBY19\n\tif (rb_funcall(rack, rb_intern(\"const_defined?\"), 1, ID2SYM(rb_intern(\"BodyProxy\"))) == Qtrue) {\n\t\tVALUE bodyproxy = rb_const_get(rack, rb_intern(\"BodyProxy\"));\n\t\t// get the list of available instance_methods\n\t\tVALUE argv = Qfalse;\n\t\tVALUE methods_list = rb_class_instance_methods(1, &argv, bodyproxy);\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"%s\\n\", RSTRING_PTR(rb_inspect(methods_list)));\n#endif\n\t\tif (rb_ary_includes(methods_list, ID2SYM(rb_intern(\"each\"))) == Qfalse) {\n\t\t\tif (rb_eval_string(\"module Rack;class BodyProxy;def each(&block);@body.each(&block);end;end;end\")) {\n\t\t\t\tif (uwsgi.mywid <= 1) {\n\t\t\t\t\tuwsgi_log(\"Rack::BodyProxy successfully patched for ruby 1.9.x\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n        VALUE rackup = rb_funcall( rb_const_get(rack, rb_intern(\"Builder\")), rb_intern(\"parse_file\"), 1, script);\n        if (TYPE(rackup) != T_ARRAY) {\n        \tuwsgi_log(\"unable to parse %s file\\n\", RSTRING_PTR(script));\n                return Qnil;\n        }\n\n        if (RARRAY_LEN(rackup) < 1) {\n        \tuwsgi_log(\"invalid rack config file: %s\\n\", RSTRING_PTR(script));\n\t\treturn Qnil;\n        }\n\n        return RARRAY_PTR(rackup)[0] ;\n}\n\nint uwsgi_rack_magic(char *mountpoint, char *lazy) {\n\n\tif (!strcmp(lazy+strlen(lazy)-3, \".ru\")) {\n                ur.rack = lazy;\n                return 1;\n        }\n        else if (!strcmp(lazy+strlen(lazy)-3, \".rb\")) {\n                ur.rack = lazy;\n                return 1;\n        }\n\n\n\treturn 0;\n}\n\nint uwsgi_rack_mount_app(char *mountpoint, char *app) {\n\n\t\n\tif (uwsgi_endswith(app, \".ru\") || uwsgi_endswith(app, \".rb\")) {\n                ur.rack = app;\n\t\tuwsgi_rack_init_apps();\n\t\treturn 0;\n        }\n\n        return -1;\n}\n\nVALUE run_irb(VALUE arg) {\n \trb_funcall(rb_cObject, rb_intern(\"require\"), 1, rb_str_new2(\"irb\"));\n\tVALUE irb = rb_const_get(rb_cObject, rb_intern(\"IRB\"));\n        return rb_funcall(irb, rb_intern(\"start\"), 0);\t\n}\n\nstatic void uwsgi_rack_hijack(void) {\n\tif (ur.rb_shell_oneshot && uwsgi.workers[uwsgi.mywid].hijacked_count > 0) {\n                uwsgi.workers[uwsgi.mywid].hijacked = 0;\n                return;\n        }\n        if (ur.rbshell && uwsgi.mywid == 1) {\n                uwsgi.workers[uwsgi.mywid].hijacked = 1;\n                uwsgi.workers[uwsgi.mywid].hijacked_count++;\n                // re-map stdin to stdout and stderr if we are logging to a file\n                if (uwsgi.logfile) {\n                        if (dup2(0, 1) < 0) {\n                                uwsgi_error(\"dup2()\");\n                        }\n                        if (dup2(0, 2) < 0) {\n                                uwsgi_error(\"dup2()\");\n                        }\n                }\n\t\tint error = 0;\n                if (ur.rbshell[0] != 0) {\n\t\t\trb_eval_string(ur.rbshell);\n                }\n                else {\n\t\t\trb_protect( run_irb, 0, &error ) ;\n                \tif (error) {\n                        \tuwsgi_ruby_exception_log(NULL);\n                        \texit(1);\n                \t}\n                }\n                if (ur.rb_shell_oneshot) {\n                        exit(UWSGI_DE_HIJACKED_CODE);\n                }\n\n                exit(0);\n        }\n\n}\n\nint uwsgi_rack_mule(char *opt) {\n\tint error = 0;\n\n        if (uwsgi_endswith(opt, (char *)\".rb\")) {\n\t\trb_protect( uwsgi_require_file, rb_str_new2(opt), &error ) ;\n                if (error) {\n\t\t\tuwsgi_ruby_exception_log(NULL);\n\t\t\treturn 0;\n                }\n                return 1;\n        }\n\n        return 0;\n\n}\n\nVALUE uwsgi_rb_pfh(VALUE args) {\n\t\n\tVALUE uwsgi_rb_embedded = rb_const_get(rb_cObject, rb_intern(\"UWSGI\"));\n\tif (rb_respond_to(uwsgi_rb_embedded, rb_intern(\"post_fork_hook\"))) {\n\t\treturn rb_funcall(uwsgi_rb_embedded, rb_intern(\"post_fork_hook\"), 0);\n\t}\n\treturn Qnil;\n}\n\nvoid uwsgi_rb_post_fork() {\n\tint error = 0;\n\n        // call the post_fork_hook\n\trb_protect(uwsgi_rb_pfh, 0, &error);\n\tif (error) {\n\t\tuwsgi_ruby_exception_log(NULL);\n\t}\n}\n\nVALUE uwsgi_rb_mmh(VALUE args) {\n\tVALUE uwsgi_rb_embedded = rb_const_get(rb_cObject, rb_intern(\"UWSGI\"));\n\treturn rb_funcall(uwsgi_rb_embedded, rb_intern(\"mule_msg_hook\"), 1, args);\n}\n\nint uwsgi_rack_mule_msg(char *message, size_t len) {\n\n\tint error = 0;\n\t\n\tVALUE uwsgi_rb_embedded = rb_const_get(rb_cObject, rb_intern(\"UWSGI\"));\n        if (rb_respond_to(uwsgi_rb_embedded, rb_intern(\"mule_msg_hook\"))) {\n\t\tVALUE arg = rb_str_new(message, len);\n\t\trb_protect(uwsgi_rb_mmh, arg, &error);\n\t\tif (error) {\n\t\t\tuwsgi_ruby_exception_log(NULL);\n\t\t}\n        \treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nVALUE rack_call_signal_handler(VALUE args) {\n\n        return rb_funcall(rb_ary_entry(args, 0), rb_intern(\"call\"), 1, rb_ary_entry(args, 1));\n}\n\nint uwsgi_rack_signal_handler(uint8_t sig, void *handler) {\n\n        int error = 0;\n\n\n        VALUE rbhandler = (VALUE) handler;\n        VALUE args = rb_ary_new2(2);\n        rb_ary_store(args, 0, rbhandler);\n        VALUE rbsig = INT2NUM(sig);\n        rb_ary_store(args, 1, rbsig);\n        rb_protect(rack_call_signal_handler, args, &error);\n        if (error) {\n\t\tuwsgi_ruby_exception_log(NULL);\n                rb_gc();\n                return -1;\n        }\n\n        rb_gc();\n        return 0;\n}\n\nVALUE uwsgi_rb_do_spooler(VALUE args) {\n        VALUE uwsgi_rb_embedded = rb_const_get(rb_cObject, rb_intern(\"UWSGI\"));\n        return rb_funcall(uwsgi_rb_embedded, rb_intern(\"spooler\"), 1, args);\n}\n\nvoid uwsgi_ruby_add_item(char *key, uint16_t keylen, char *val, uint16_t vallen, void *data) {\n\n\tVALUE *spool_dict = (VALUE*) data;\n\t\n\trb_hash_aset(*spool_dict, rb_str_new(key, keylen), rb_str_new(val, vallen));\n}\n\n\nint uwsgi_rack_spooler(char *filename, char *buf, uint16_t len, char *body, size_t body_len) {\n\n\tint error = 0;\n\n        VALUE uwsgi_rb_embedded = rb_const_get(rb_cObject, rb_intern(\"UWSGI\"));\n        if (!rb_respond_to(uwsgi_rb_embedded, rb_intern(\"spooler\"))) {\n\t\trb_gc();\n\t\treturn 0;\n\t}\n\n\tVALUE spool_dict = rb_hash_new();\n\n        if (uwsgi_hooked_parse(buf, len, uwsgi_ruby_add_item, (void *) &spool_dict)) {\n\t\trb_gc();\n                // malformed packet, destroy it\n                return 0;\n        }\n\n        rb_hash_aset(spool_dict, rb_str_new2(\"spooler_task_name\"), rb_str_new2(filename));\n\n        if (body && body_len > 0) {\n                rb_hash_aset(spool_dict, rb_str_new2(\"body\"), rb_str_new(body, body_len));\n        }\n\n        VALUE ret = rb_protect(uwsgi_rb_do_spooler, spool_dict, &error);\n\tif (error) {\n\t\tuwsgi_ruby_exception_log(NULL);\n\t\trb_gc();\n\t\treturn -1;\n\t}\n\n        if (TYPE(ret) == T_FIXNUM) {\n\t\trb_gc();\n                return NUM2INT(ret);\n        }\n\n        // error, retry\n\trb_gc();\n        return -1;\n}\n\n\nvoid uwsgi_ruby_enable_native_threads() {\n\tuwsgi_log(\"DANGER: native threads do not work under ruby !!!\\n\");\n}\n\nvoid uwsgi_ruby_init_thread(int core_id) {\n\tuwsgi_log(\"DANGER: native threads do not work under ruby !!!\\n\");\n}\n\nvoid uwsgi_rack_postinit_apps(void) {\n}\n\n/*\n\tIf the ruby VM has rb_reserved_fd_p, we avoid closign the filedescriptor needed by\n\tmodern ruby (the Matz ones) releases.\n*/\nstatic void uwsgi_ruby_cleanup() {\n\tint (*uptr_rb_reserved_fd_p)(int) = dlsym(RTLD_DEFAULT, \"rb_reserved_fd_p\");\n\tif (!uptr_rb_reserved_fd_p) return;\n\tint i;\n\tfor (i = 3; i < (int) uwsgi.max_fd; i++) {\n\t\tif (uptr_rb_reserved_fd_p(i)) {\n\t\t\tuwsgi_add_safe_fd(i);\n\t\t}\n\t}\n}\n\nstruct uwsgi_plugin rack_plugin = {\n\n\t.name = \"rack\",\n\t.modifier1 = 7,\n\t.init = uwsgi_rack_init,\n\t.options = uwsgi_rack_options,\n\n\t.request = uwsgi_rack_request,\n\t.after_request = uwsgi_rack_after_request,\n\n\t.signal_handler = uwsgi_rack_signal_handler,\n\n\t.hijack_worker = uwsgi_rack_hijack,\n\t.post_fork = uwsgi_rb_post_fork,\n\n\t.spooler = uwsgi_rack_spooler,\n\n\t.preinit_apps = uwsgi_rack_preinit_apps,\n\n\t.init_apps = uwsgi_rack_init_apps,\n\t.mount_app = uwsgi_rack_mount_app,\n\t\n\t.postinit_apps = uwsgi_rack_postinit_apps,\n\n\t.magic = uwsgi_rack_magic,\n\n\t.mule = uwsgi_rack_mule,\n\t.mule_msg = uwsgi_rack_mule_msg,\n\t.rpc = uwsgi_ruby_rpc,\n\n\t.enable_threads = uwsgi_ruby_enable_native_threads,\n\t.init_thread = uwsgi_ruby_init_thread,\n\n\t.suspend = uwsgi_rack_suspend,\n\t.resume = uwsgi_rack_resume,\n\n\t.exception_class = uwsgi_ruby_exception_class,\n\t.exception_msg = uwsgi_ruby_exception_msg,\n\t.exception_repr = uwsgi_ruby_exception_repr,\n\t.exception_log = uwsgi_ruby_exception_log,\n\t.backtrace = uwsgi_ruby_backtrace,\n\n\t.master_cleanup = uwsgi_ruby_cleanup,\n};\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/plugins/rrdtool/rrdtool.c": "#include <uwsgi.h>\n\nextern struct uwsgi_server uwsgi;\n\nstatic struct uwsgi_rrdtool {\n\tvoid *lib;\n\tchar *lib_name;\n\n\tint (*create)(int, char **);\n\tint (*update)(int, char **);\n\n\tint freq;\n\n\tchar *update_area;\n\tstruct uwsgi_string_list *directory;\n\n\tstruct uwsgi_stats_pusher *pusher;\n} u_rrd;\n\nstatic struct uwsgi_option rrdtool_options[] = {\n\t{\"rrdtool\", required_argument, 0, \"store rrd files in the specified directory\", uwsgi_opt_add_string_list, &u_rrd.directory, UWSGI_OPT_MASTER|UWSGI_OPT_METRICS},\n\t{\"rrdtool-freq\", required_argument, 0, \"set collect frequency\", uwsgi_opt_set_int, &u_rrd.freq, 0},\n\t{\"rrdtool-lib\", required_argument, 0, \"set the name of rrd library (default: librrd.so)\", uwsgi_opt_set_str, &u_rrd.lib_name, 0},\n\t{0, 0, 0, 0, 0, 0, 0},\n\n};\n\n\nstatic int rrdtool_init() {\n\n\tif (!u_rrd.lib_name) {\n\t\tu_rrd.lib_name = \"librrd.so\";\n\t}\n\n\tu_rrd.lib = dlopen(u_rrd.lib_name, RTLD_LAZY);\n\tif (!u_rrd.lib) return -1;\n\n\tu_rrd.create = dlsym(u_rrd.lib, \"rrd_create\");\n\tif (!u_rrd.create) {\n\t\tdlclose(u_rrd.lib);\n\t\treturn -1;\n\t}\n\n\tu_rrd.update = dlsym(u_rrd.lib, \"rrd_update\");\n\tif (!u_rrd.update) {\n\t\tdlclose(u_rrd.lib);\n\t\treturn -1;\n\t}\n\n\tuwsgi_log_initial(\"*** RRDtool library available at %p ***\\n\", u_rrd.lib);\n\n\treturn 0;\n}\n\n/*\n\n\tcreate .rrd files if needed\n\n*/\nstatic void rrdtool_post_init() {\n\n\tif (!u_rrd.create) return;\n\n\t// do not waste time if no --rrdtool option is defined\n\tif (!u_rrd.directory) return;\n\n\tif (!u_rrd.freq) u_rrd.freq = 300;\n\n\tchar *argv[7];\n\targv[0] = \"create\";\n\n\n\t// create RRA\n\targv[3] = \"RRA:AVERAGE:0.5:1:288\" ;\n\targv[4] = \"RRA:AVERAGE:0.5:12:168\" ;\n\targv[5] = \"RRA:AVERAGE:0.5:288:31\" ;\n\targv[6] = \"RRA:AVERAGE:0.5:2016:52\";\n\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, u_rrd.directory) {\n\t\tchar *dir = uwsgi_expand_path(usl->value, strlen(usl->value), NULL);\n                if (!dir) {\n                        uwsgi_error(\"rrdtool_post_init()/uwsgi_expand_path()\");\n                        exit(1);\n                }\n\t\tstruct uwsgi_metric *um = uwsgi.metrics;\n\t\t// here locking is useless, but maybe in the future we could move this part\n\t\t// somewhere else\n\t\tint created = 0;\n\t\tuwsgi_rlock(uwsgi.metrics_lock);\n\t\twhile(um) {\n\t\t\tchar *filename = uwsgi_concat4(dir, \"/\", um->name, \".rrd\");\n\t\t\tif (!uwsgi_file_exists(filename)) {\n\t\t\t\targv[1] = filename;\n\t\t\t\tif (um->type == UWSGI_METRIC_GAUGE) {\n\t\t\t\t\targv[2] = \"DS:metric:GAUGE:600:0:U\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targv[2] = \"DS:metric:DERIVE:600:0:U\";\n\t\t\t\t}\n\t\t\t\tif (u_rrd.create(7, argv)) {\n\t\t\t\t\tuwsgi_log(\"unable to create rrd file for metric \\\"%s\\\"\\n\", um->name);\n\t\t\t\t\tuwsgi_error(\"rrd_create()\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tcreated++;\n\t\t\t}\n\t\t\tfree(filename);\n\t\t\tum = um->next;\n\t\t}\n\t\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\t\n\t\tuwsgi_log(\"created %d new rrd files in %s\\n\", created, dir);\n\n\t\tstruct uwsgi_stats_pusher_instance *uspi = uwsgi_stats_pusher_add(u_rrd.pusher, NULL);\n        \tuspi->freq = u_rrd.freq;\n\t\tuspi->data = dir;\n        \t// no need to generate the json\n        \tuspi->raw=1;\n\t}\n\n}\n\nstatic void rrdtool_push(struct uwsgi_stats_pusher_instance *uspi, time_t now, char *json, size_t json_len) {\n\n\tif (!u_rrd.update) return ;\n\n\t// standard stats pusher\n\tif (!uspi->data) {\n\t\tif (!uspi->arg) {\n\t\t\tuwsgi_log(\"invalid rrdtool stats pusher syntax\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tuspi->data = uwsgi_expand_path(uspi->arg, strlen(uspi->arg), NULL);\n\t\tif (!uspi->data) {\n\t\t\tuwsgi_error(\"rrdtool_push()/uwsgi_expand_path()\");\n                        exit(1);\n\t\t}\n\t\tif (!u_rrd.freq) u_rrd.freq = 300;\n\t\tuspi->freq = u_rrd.freq;\n\t}\n\n\t// 1k will be more than enough\n\tchar buf[1024];\n\tchar *argv[3];\n\targv[0] = \"update\";\n\n\tstruct uwsgi_metric *um = uwsgi.metrics;\n\twhile(um) {\n\t\tuwsgi_rlock(uwsgi.metrics_lock);\n\t\tint ret = snprintf(buf, 1024, \"N:%lld\", (long long) (*um->value));\n\t\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\t\tif (um->reset_after_push){\n\t\t\tuwsgi_wlock(uwsgi.metrics_lock);\n\t\t\t*um->value = um->initial_value;\n\t\t\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\t\t}\n\t\tif (ret < 3 || ret >= 1024) {\n\t\t\tuwsgi_log(\"unable to update rrdtool metric for %s\\n\", um->name);\n\t\t\tgoto next;\n\t\t}\t\t\n\t\tchar *filename = uwsgi_concat4(uspi->data, \"/\", um->name, \".rrd\");\n\t\targv[1] = filename;\n                argv[2] = buf;\n                if (u_rrd.update(3, argv)) {\n                \tuwsgi_log_verbose(\"ERROR: rrd_update(\\\"%s\\\", \\\"%s\\\")\\n\", argv[1], argv[2]);\n                }\n\t\tfree(filename);\nnext:\n\t\tum = um->next;\n\t}\n\n}\n\nstatic void rrdtool_register() {\n\tu_rrd.pusher = uwsgi_register_stats_pusher(\"rrdtool\", rrdtool_push);\n\tu_rrd.pusher->raw = 1;\n}\n\nstruct uwsgi_plugin rrdtool_plugin = {\n\n\t.name = \"rrdtool\",\n\t.options = rrdtool_options,\n\t\n\t.on_load = rrdtool_register,\n\n\t// this is the best phase to create rrd files (if needed)\n\t.preinit_apps = rrdtool_post_init,\n\t// here we get pointers to rrdtool functions\n\t.init = rrdtool_init,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/plugins/tuntap/tuntap.c": "#include \"common.h\"\n\nextern struct uwsgi_server uwsgi;\nstruct uwsgi_tuntap utt;\n\n/*\n\n\tThe tuntap router is a non-blocking highly optimized ip router\n\ttranslating from tuntap device to socket streams.\n\n\tIt is meant as a replacement for the currently available networking namespaces\n\tapproaches. Compared to veth or macvlan it is really simple and allows total control\n\tover the routing subsystem (in addition to a simple customizable firewalling engine)\n\n\tGenerally you spawn the tuntap router in the Emperor instance\n\n\t[uwsgi]\n\tmaster = true\n\temperor = /etc/uwsgi\n\temperor-use-clone = fs,uts,ipc,pid,net\n\ttuntap-router = emperor0 /tmp/tuntap.socket\n\texec-as-root = ifconfig emperor0 192.168.0.1 netmask 255.255.255.0 up\n\texec-as-root = iptables -t nat -F\n\texec-as-root = iptables -t nat -A POSTROUTING -o eth0 -s 192.168.0.0/24 -j MASQUERADE\n\texec-as-root = echo 1 > /proc/sys/net/ipv4/ip_forward\n\n\tvassals will run in new namespaces in which they create a tuntap device attached to\n\tthe tuntap router. UNIX sockets are the only way to connect to the tuntap router\n\tafter jailing.\n\n\tFirewalling is based on 2 chains (in and out), and each rule is formed by 3 parameters: <action> <src> <dst>\n\tThe firewall is applied to traffic from the clients to the tuntap device (out) and the opposite (in)\n\n\n\tThe first matching rule stop the chain, if no rule applies, the policy is \"allow\"\n\n\tthe following rules allows access from vassals to the internet, but block\n\tvassals intercommunication\n\n\t--tuntap-router-firewall-out = allow 192.168.0.0/24 192.168.0.1\n\t--tuntap-router-firewall-out = deny 192.168.0.0/24 192.168.0.0/24\n\t--tuntap-router-firewall-out = allow 192.168.0.0/24 0.0.0.0\n\t--tuntap-router-firewall-out = deny\n\t--tuntap-router-firewall-in = allow 192.168.0.1 192.168.0.0/24\n\t--tuntap-router-firewall-in = deny 192.168.0.0/24 192.168.0.0/24\n\t--tuntap-router-firewall-in = allow 0.0.0.0 192.168.0.0/24\n\t--tuntap-router-firewall-in = deny\n\n\tAuthor: Roberto De Ioris\n\n\tTODO:\n\n\t- some form of security to disallow raw access to the tuntap router unix socket\n\t- stats server\n\t- port to other platforms ?\n\n*/\n\nstatic struct uwsgi_option uwsgi_tuntap_options[] = {\n\t{\"tuntap-router\", required_argument, 0, \"run the tuntap router (syntax: <device> <socket> [stats] [gateway])\", uwsgi_opt_add_string_list, &utt.routers, 0},\n\t{\"tuntap-device\", required_argument, 0, \"add a tuntap device to the instance (syntax: <device>[ <socket>])\", uwsgi_opt_add_string_list, &utt.devices, 0},\n\t{\"tuntap-use-credentials\", optional_argument, 0, \"enable check of SCM_CREDENTIALS for tuntap client/server\", uwsgi_opt_set_str, &utt.use_credentials, 0},\n\t{\"tuntap-router-firewall-in\", required_argument, 0, \"add a firewall rule to the tuntap router (syntax: <action> <src/mask> <dst/mask>)\", uwsgi_tuntap_opt_firewall, &utt.fw_in, 0},\n\t{\"tuntap-router-firewall-out\", required_argument, 0, \"add a firewall rule to the tuntap router (syntax: <action> <src/mask> <dst/mask>)\", uwsgi_tuntap_opt_firewall, &utt.fw_out, 0},\n\t{\"tuntap-router-route\", required_argument, 0, \"add a routing rule to the tuntap router (syntax: <src/mask> <dst/mask> <gateway>)\", uwsgi_tuntap_opt_route, &utt.routes, 0},\n\t{\"tuntap-router-stats\", required_argument, 0, \"run the tuntap router stats server\", uwsgi_opt_set_str, &utt.stats_server, 0},\n\t{\"tuntap-device-rule\", required_argument, 0, \"add a tuntap device rule (syntax: <direction> <src/mask> <dst/mask> <action> [target])\", uwsgi_opt_add_string_list, &utt.device_rules, 0},\n\t{NULL, 0, 0, NULL, NULL, NULL, 0},\n};\n\nstatic void *uwsgi_tuntap_loop(void *arg) {\n\n\t// block signals on this thread\n\tsigset_t smask;\n\tsigfillset(&smask);\n#ifndef UWSGI_DEBUG\n\tsigdelset(&smask, SIGSEGV);\n#endif\n\tpthread_sigmask(SIG_BLOCK, &smask, NULL);\n\n\tstruct uwsgi_tuntap_router *uttr = (struct uwsgi_tuntap_router *) arg;\n\n\tuwsgi_socket_nb(uttr->fd);\n\n\tif (!utt.buffer_size)\n\t\tutt.buffer_size = 8192;\n\tuttr->buf = uwsgi_malloc(utt.buffer_size);\n\tuttr->write_buf = uwsgi_malloc(utt.buffer_size);\n\n\tuttr->queue = event_queue_init();\n\n\tif (event_queue_add_fd_read(uttr->queue, uttr->fd)) {\n\t\texit(1);\n\t}\n\tif (event_queue_add_fd_read(uttr->queue, uttr->server_fd)) {\n\t\texit(1);\n\t}\n\n\tuwsgi_socket_nb(uttr->server_fd);\n\n\tstruct uwsgi_tuntap_peer *uttp = uwsgi_tuntap_peer_create(uttr, uttr->server_fd, 0);\n\n\tfor (;;) {\n\t\tint interesting_fd = -1;\n\t\tint ret = event_queue_wait(uttr->queue, -1, &interesting_fd);\n\n\t\tif (ret <= 0)\n\t\t\tcontinue;\n\n\t\tif (interesting_fd == uttr->fd) {\n\t\t\tif (uttr->wait_for_write) {\n\t\t\t\tuwsgi_tuntap_enqueue(uttr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tssize_t rlen = read(uttr->fd, uttr->buf, utt.buffer_size);\n\t\t\tif (rlen <= 0) {\n\t\t\t\tuwsgi_error(\"uwsgi_tuntap_loop()/read()\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\t// check for full write buffer\n                        if (uttp->write_buf_pktsize + 4 + rlen > utt.buffer_size) {\n                        \tuttp->dropped++;\n                                continue;\n                        }\n\n\t\t\tuint16_t pktsize = rlen;\n\t\t\tchar *ptr = uttp->write_buf + uttp->write_buf_pktsize;\n\t\t\tmemcpy(ptr + 4, uttr->buf, rlen);\n\t\t\tptr[0] = 0;\n\t\t\tptr[1] = (uint8_t) (pktsize & 0xff);\n\t\t\tptr[2] = (uint8_t) ((pktsize >> 8) & 0xff);\n\t\t\tptr[3] = 0;\n\t\t\tuttp->write_buf_pktsize+= pktsize+4;\n\t\t\tif (uwsgi_tuntap_peer_enqueue(uttr, uttp)) {\n\t\t\t\tuwsgi_log_verbose(\"tuntap server disconnected...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (interesting_fd == uttr->server_fd) {\n\t\t\t// read from the client\n\t\t\tif (!uttp->wait_for_write) {\n\t\t\t\tif (uwsgi_tuntap_peer_dequeue(uttr, uttp, 0)) {\n\t\t\t\t\tuwsgi_log_verbose(\"tuntap server disconnected...\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// something is wrong (the tuntap device is blocked)\n\t\t\t\tif (uttr->wait_for_write) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// write to the client\n\t\t\t\tif (uwsgi_tuntap_peer_enqueue(uttr, uttp)) {\n\t\t\t\t\tuwsgi_log_verbose(\"tuntap server disconnected...\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\treturn NULL;\n}\n\nstatic void uwsgi_tuntap_client() {\n\n\tif (!utt.devices) return;\n\n\tstruct uwsgi_string_list *usl;\n\tuwsgi_foreach(usl, utt.devices) {\n\t\tchar *space = strchr(usl->value, ' ');\n\t\tif (space) {\n\t\t\t*space = 0;\n\t\t\tstruct uwsgi_tuntap_router *uttr = uwsgi_calloc(sizeof(struct uwsgi_tuntap_router));\n\t\t\tuttr->fd = uwsgi_tuntap_device(usl->value);\n\n\t\t\tuttr->server_fd = uwsgi_connect(space+1, 30, 0);\n        \t\tif (uttr->server_fd < 0) {\n                \t\tuwsgi_error(\"uwsgi_tuntap_client()/uwsgi_connect()\");\n                \t\texit(1);\n        \t\t}\n\t\t\t*space = ' ';\n\n\t\t\tpthread_t t;\n\t\t\tpthread_create(&t, NULL, uwsgi_tuntap_loop, uttr);\n\t\t}\n\t\telse {\n\t\t\tif (uwsgi_tuntap_device(usl->value) < 0) {\n\t\t\t\t// foo\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid tuntaprouter_send_stats(struct uwsgi_tuntap_router *);\n\nvoid uwsgi_tuntap_router_loop(int id, void *arg) {\n\tint i;\n\n\tstruct uwsgi_tuntap_router *uttr = (struct uwsgi_tuntap_router *) arg;\n\tuttr->buf = uwsgi_malloc(utt.buffer_size);\n\tuttr->write_buf = uwsgi_malloc(utt.buffer_size);\n\tuttr->queue = event_queue_init();\n\n\tuttr->stats_server_fd = -1;\n\tuttr->gateway_fd = -1;\n\n\tvoid *events = event_queue_alloc(64);\n\tif (event_queue_add_fd_read(uttr->queue, uttr->server_fd))\n\t\texit(1);\n\tif (event_queue_add_fd_read(uttr->queue, uttr->fd))\n\t\texit(1);\n\n\tchar *stats_server = utt.stats_server;\n\tif (uttr->stats_server) stats_server = uttr->stats_server;\n\tif (stats_server) {\n                char *tcp_port = strchr(stats_server, ':');\n                if (tcp_port) {\n                        // disable deferred accept for this socket\n                        int current_defer_accept = uwsgi.no_defer_accept;\n                        uwsgi.no_defer_accept = 1;\n                        uttr->stats_server_fd = bind_to_tcp(stats_server, uwsgi.listen_queue, tcp_port);\n                        uwsgi.no_defer_accept = current_defer_accept;\n                }\n                else {\n                        uttr->stats_server_fd = bind_to_unix(stats_server, uwsgi.listen_queue, uwsgi.chmod_socket, uwsgi.abstract_socket);\n                }\n\n                if (event_queue_add_fd_read(uttr->queue, uttr->stats_server_fd)) exit(1);\n                uwsgi_log(\"*** tuntap stats server enabled on %s fd: %d ***\\n\", stats_server, uttr->stats_server_fd);\n\t\tuwsgi_socket_nb(uttr->stats_server_fd);\n        }\n\n\tif (uttr->gateway) {\n\t\tuttr->gateway_fd = bind_to_udp(uttr->gateway, 0, 0);\t\n\t\tif (uttr->gateway_fd < 0) exit(1);\n                if (event_queue_add_fd_read(uttr->queue, uttr->gateway_fd)) exit(1);\n\t\tuwsgi_log(\"*** tuntap gateway address enabled on %s\\n\", uttr->gateway);\n\t\tuttr->gateway_buf = uwsgi_malloc(utt.buffer_size);\n\t\tuwsgi_socket_nb(uttr->gateway_fd);\n\t}\n\n\tfor (;;) {\n\t\tint nevents = event_queue_wait_multi(uttr->queue, -1, events, 64);\n\t\tfor (i = 0; i < nevents; i++) {\n\t\t\tint interesting_fd = event_queue_interesting_fd(events, i);\n\t\t\tif (interesting_fd == uttr->fd) {\n\t\t\t\t// if writing, continue enqueuing\n\t\t\t\tif (uttr->wait_for_write) {\n\t\t\t\t\tuwsgi_tuntap_enqueue(uttr);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tssize_t rlen = read(uttr->fd, uttr->buf, utt.buffer_size);\n\t\t\t\tif (rlen <= 0) {\n\t\t\t\t\tuwsgi_error(\"uwsgi_tuntap_router_loop()/read()\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tif (rlen < 20) continue;\n\n\t\t\t\tif (uwsgi_tuntap_firewall_check(utt.fw_in, uttr->buf, rlen)) continue;\n\n\n\t\t\t\tuint32_t *dst_ip = (uint32_t *) & uttr->buf[16];\n\t\t\t\tstruct uwsgi_tuntap_peer *uttp = uwsgi_tuntap_peer_get_by_addr(uttr, *dst_ip);\n\t\t\t\tif (!uttp)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (uwsgi_tuntap_peer_rules_check(uttr, uttp, uttr->buf, rlen, 0)) continue;\n\n\t\t\t\t// check for full write buffer\n\t\t\t\tif (uttp->write_buf_pktsize + 4 + rlen > utt.buffer_size) {\n\t\t\t\t\tuttp->dropped++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tuint16_t pktsize = rlen;\n                        \tchar *ptr = uttp->write_buf + uttp->write_buf_pktsize;\n                        \tmemcpy(ptr + 4, uttr->buf, rlen);\n                        \tptr[0] = 0;\n                        \tptr[1] = (uint8_t) (pktsize & 0xff);\n                        \tptr[2] = (uint8_t) ((pktsize >> 8) & 0xff);\n                        \tptr[3] = 0;\n                        \tuttp->write_buf_pktsize+= pktsize+4;\n\t\t\t\tif (uwsgi_tuntap_peer_enqueue(uttr, uttp)) {\n\t\t\t\t\tuwsgi_tuntap_peer_destroy(uttr, uttp);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (interesting_fd == uttr->server_fd) {\n\t\t\t\tint client_fd = uwsgi_accept(uttr->server_fd);\n\t\t\t\tif (client_fd < 0) {\n\t\t\t\t\tuwsgi_error(\"uwsgi_tuntap_server_loop()/accept()\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (utt.use_credentials) {\n\t\t\t\t\tif (uwsgi_socket_passcred(client_fd)) {\n\t\t\t\t\t\tclose(client_fd);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstruct uwsgi_tuntap_peer *uttp = uwsgi_tuntap_peer_create(uttr, client_fd, 1);\n\t\t\t\tif (event_queue_add_fd_read(uttr->queue, uttp->fd)) {\n\t\t\t\t\tuwsgi_tuntap_peer_destroy(uttr, uttp);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (uttr->stats_server_fd > -1 && interesting_fd == uttr->stats_server_fd) {\n\t\t\t\ttuntaprouter_send_stats(uttr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (uttr->gateway_fd > -1 && interesting_fd == uttr->gateway_fd) {\n\t\t\t\tssize_t rlen = read(uttr->gateway_fd, uttr->gateway_buf, utt.buffer_size);\t\n\t\t\t\tif (rlen <= 0) {\n                                        uwsgi_error(\"uwsgi_tuntap_router_loop()/read()\");\n\t\t\t\t\tcontinue;\n                                }\n\t\t\t\tif (rlen < 20) continue;\n\t\t\t\tif (uwsgi_tuntap_firewall_check(utt.fw_in, uttr->gateway_buf, rlen)) continue;\n\t\t\t\tuint32_t *dst_ip = (uint32_t *) & uttr->gateway_buf[16];\n                                struct uwsgi_tuntap_peer *uttp = uwsgi_tuntap_peer_get_by_addr(uttr, *dst_ip);\n                                if (!uttp)\n                                        continue;\n\n                                // check for full write buffer\n                                if (uttp->write_buf_pktsize + 4 + rlen > utt.buffer_size) {\n                                        uttp->dropped++;\n                                        continue;\n                                }\n\n                                uint16_t pktsize = rlen;\n                                char *ptr = uttp->write_buf + uttp->write_buf_pktsize;\n                                memcpy(ptr + 4, uttr->gateway_buf, rlen);\n                                ptr[0] = 0;\n                                ptr[1] = (uint8_t) (pktsize & 0xff);\n                                ptr[2] = (uint8_t) ((pktsize >> 8) & 0xff);\n                                ptr[3] = 0;\n                                uttp->write_buf_pktsize+= pktsize+4;\n                                if (uwsgi_tuntap_peer_enqueue(uttr, uttp)) {\n                                        uwsgi_tuntap_peer_destroy(uttr, uttp);\n                                }\n                                continue;\n\t\t\t}\n\n\t\t\tstruct uwsgi_tuntap_peer *uttp = uttr->peers_head;\n\t\t\twhile (uttp) {\n\t\t\t\tif (interesting_fd == uttp->fd) {\n\t\t\t\t\t// read from the client\n\t\t\t\t\tif (event_queue_interesting_fd_is_read(events, i)) {\n\t\t\t\t\t\tif (utt.use_credentials) {\n\t\t\t\t\t\t\tif (uttp->addr == 0) {\n\t\t\t\t\t\t\t\tif (!uttp->sent_credentials) {\n\t\t\t\t\t\t\t\t\tif (uwsgi_recv_cred(uttp->fd, \"uwsgi-tuntap\", 12, &uttp->pid, &uttp->uid, &uttp->gid)) {\n\t\t\t\t\t\t\t\t\t\tuwsgi_tuntap_peer_destroy(uttr, uttp);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (utt.addr_by_credentials) {\n\t\t\t\t\t\t\t\t\t\tuttp->addr = utt.addr_by_credentials(uttp->pid, uttp->uid, uttp->gid);\n\t\t\t\t\t\t\t\t\t\tif (!uttp->addr) {\n\t\t\t\t\t\t\t\t\t\t\tuwsgi_tuntap_peer_destroy(uttr, uttp);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (uwsgi_tuntap_register_addr(uttr, uttp)) {\n\t\t\t\t\t\t\t\t\t\t\tuwsgi_tuntap_peer_destroy(uttr, uttp);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tuttp->sent_credentials = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// if credentials are sent and a function is available, destroy the peer (if addr is 0)\n\t\t\t\t\t\t\t\t\tif (utt.addr_by_credentials) {\n\t\t\t\t\t\t\t\t\t\tuwsgi_tuntap_peer_destroy(uttr, uttp);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (uwsgi_tuntap_peer_dequeue(uttr, uttp, 1)) {\n\t\t\t\t\t\t\tuwsgi_tuntap_peer_destroy(uttr, uttp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (event_queue_interesting_fd_is_write(events, i)) {\n\t\t\t\t\t\t// something is wrong (the tuntap device is blocked)\n\t\t\t\t\t\tif (uttr->wait_for_write)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// write to the client\n\t\t\t\t\t\tif (uwsgi_tuntap_peer_enqueue(uttr, uttp)) {\n\t\t\t\t\t\t\tuwsgi_tuntap_peer_destroy(uttr, uttp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tuttp = uttp->next;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void uwsgi_tuntap_router() {\n\n\tif (!utt.routers) return;\n\n\tif (!utt.buffer_size)\n\t\tutt.buffer_size = 8192;\n\n\tif (utt.use_credentials) {\n\t\tif (utt.use_credentials[0] != 0 && strcmp(utt.use_credentials, \"true\")) {\n\t\t\tutt.addr_by_credentials = (uint32_t (*)(pid_t, uid_t, gid_t)) dlsym(RTLD_DEFAULT, utt.use_credentials);\n\t\t\tif (!utt.addr_by_credentials) {\n\t\t\t\tuwsgi_log(\"[uwsgi-tuntap] unable to find symbol %s\\n\", utt.use_credentials);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstruct uwsgi_string_list *usl;\n\tuwsgi_foreach(usl, utt.routers) {\n\t\tsize_t rlen = 0;\n\t\tchar **args = uwsgi_split_quoted(usl->value, usl->len, \" \\t\", &rlen);\n\t\tif (rlen < 2) {\n\t\t\tuwsgi_log(\"invalid tuntap router syntax, must be <device> <socket> [stats] [gateway]\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tstruct uwsgi_tuntap_router *uttr = uwsgi_calloc(sizeof(struct uwsgi_tuntap_router));\n\n\t\tuttr->server_fd = bind_to_unix(args[1], uwsgi.listen_queue, uwsgi.chmod_socket, uwsgi.abstract_socket);\n\n\t\tuttr->fd = uwsgi_tuntap_device(args[0]);\n\n\t\tif (rlen > 2) uttr->stats_server = args[2];\n\t\tif (rlen > 3) uttr->gateway = args[3];\n\n\t\tif (register_gateway(\"uWSGI tuntap router\", uwsgi_tuntap_router_loop, uttr) == NULL) {\n\t\t\tuwsgi_log(\"unable to register the tuntap server gateway\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n}\n\nvoid tuntaprouter_send_stats(struct uwsgi_tuntap_router *uttr) {\n\n        struct sockaddr_un client_src;\n        socklen_t client_src_len = 0;\n\n        int client_fd = accept(uttr->stats_server_fd, (struct sockaddr *) &client_src, &client_src_len);\n        if (client_fd < 0) {\n                uwsgi_error(\"tuntaprouter_send_stats()/accept()\");\n                return;\n        }\n\n        if (uwsgi.stats_http) {\n                if (uwsgi_send_http_stats(client_fd)) {\n                        close(client_fd);\n                        return;\n                }\n        }\n\n        struct uwsgi_stats *us = uwsgi_stats_new(8192);\n\n        if (uwsgi_stats_keyval_comma(us, \"version\", UWSGI_VERSION)) goto end;\n        if (uwsgi_stats_keylong_comma(us, \"pid\", (unsigned long long) getpid())) goto end;\n        if (uwsgi_stats_keylong_comma(us, \"uid\", (unsigned long long) getuid())) goto end;\n        if (uwsgi_stats_keylong_comma(us, \"gid\", (unsigned long long) getgid())) goto end;\n\n        char *cwd = uwsgi_get_cwd();\n        if (uwsgi_stats_keyval_comma(us, \"cwd\", cwd)) goto end0;\n\n\tif (uwsgi_stats_key(us , \"peers\")) goto end0;\n                if (uwsgi_stats_list_open(us)) goto end0;\n\tstruct uwsgi_tuntap_peer *uttp = uttr->peers_head;\n\t\n        while (uttp) {\n                if (uwsgi_stats_object_open(us)) goto end0;\n\t\tif (uwsgi_stats_keyval_comma(us, \"addr\", uttp->ip)) goto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"addr_32\", uttp->addr)) goto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"uid\", uttp->uid)) goto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"gid\", uttp->gid)) goto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"pid\", uttp->pid)) goto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"tx\", uttp->tx)) goto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"rx\", uttp->rx)) goto end0;\n\t\tif (uwsgi_stats_keylong(us, \"dropped\", uttp->dropped)) goto end0;\n\t\tif (uwsgi_stats_object_close(us)) goto end0;\n                uttp = uttp->next;\n\t\tif (uttp) {\n\t\t\tif (uwsgi_stats_comma(us)) goto end0;\n\t\t}\n        }\n\n        if (uwsgi_stats_list_close(us)) goto end0;\n\n\tif (uwsgi_stats_object_close(us)) goto end0;\t\n\n        size_t remains = us->pos;\n        off_t pos = 0;\n        while(remains > 0) {\n                int ret = uwsgi_waitfd_write(client_fd, uwsgi.socket_timeout);\n                if (ret <= 0) {\n                        goto end0;\n                }\n                ssize_t res = write(client_fd, us->base + pos, remains);\n                if (res <= 0) {\n                        if (res < 0) {\n                                uwsgi_error(\"tuntaprouter_send_stats()/write()\");\n                        }\n                        goto end0;\n                }\n                pos += res;\n                remains -= res;\n        }\n\nend0:\n        free(cwd);\nend:\n        free(us->base);\n        free(us);\n        close(client_fd);\n}\n\n\nstruct uwsgi_plugin tuntap_plugin = {\n\t.name = \"tuntap\",\n\t.options = uwsgi_tuntap_options,\n\t.post_jail = uwsgi_tuntap_client,\n\t.jail = uwsgi_tuntap_router,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/plugins/symcall/symcall_plugin.c": "#include <uwsgi.h>\n\nextern struct uwsgi_server uwsgi;\n\nstruct uwsgi_symcall {\n\tstruct uwsgi_string_list *symcall_function_name;\n\tint (*symcall_function)(struct wsgi_request *);\n\tstruct uwsgi_string_list *rpc;\n\tstruct uwsgi_string_list *post_fork;\n\tint use_rtld_next;\n\tvoid *dlsym_handle;\n} usym;\n\nstruct uwsgi_plugin symcall_plugin;\n\nstatic struct uwsgi_option uwsgi_symcall_options[] = {\n        {\"symcall\", required_argument, 0, \"load the specified C symbol as the symcall request handler (supports <mountpoint=func> too)\", uwsgi_opt_add_string_list, &usym.symcall_function_name, 0},\n#ifdef RTLD_NEXT\n        {\"symcall-use-next\", no_argument, 0, \"use RTLD_NEXT when searching for symbols\", uwsgi_opt_true, &usym.use_rtld_next, 0},\n#endif\n        {\"symcall-register-rpc\", required_argument, 0, \"load the specified C symbol as an RPC function (syntax: name function)\", uwsgi_opt_add_string_list, &usym.rpc, 0},\n        {\"symcall-post-fork\", required_argument, 0, \"call the specified C symbol after each fork()\", uwsgi_opt_add_string_list, &usym.post_fork, 0},\n        {0, 0, 0, 0},\n};\n\nstatic void uwsgi_symcall_init(){\n#ifdef RTLD_NEXT\n\tif (usym.use_rtld_next) {\n\t\tusym.dlsym_handle = RTLD_NEXT;\n\t}\n#endif\n\tstruct uwsgi_string_list *usl = NULL;\n\tint has_mountpoints = 0;\n\tuwsgi_foreach(usl, usym.symcall_function_name) {\n\t\tchar *func = usl->value, *mountpoint = \"\";\n\t\tchar *equal = strchr(usl->value, '=');\n\t\tif (equal) {\n\t\t\t*equal = 0;\n\t\t\tfunc = equal+1;\n\t\t\tmountpoint = usl->value;\n\t\t\thas_mountpoints = 1;\n\t\t}\n\t\tusl->custom_ptr = dlsym(usym.dlsym_handle, func);\n\t\tif (!usl->custom_ptr) {\n\t\t\tuwsgi_log(\"unable to find symbol \\\"%s\\\" in process address space\\n\", func);\n\t\t\texit(1);\n\t\t}\n\t\tint id = uwsgi_apps_cnt;\n\t\tstruct uwsgi_app *ua = uwsgi_add_app(id, symcall_plugin.modifier1, mountpoint, strlen(mountpoint), usl->custom_ptr, NULL);\n\t\tuwsgi_log(\"symcall app %d (mountpoint: \\\"%.*s\\\") mapped to function ptr: %p\\n\", id, ua->mountpoint_len, ua->mountpoint, usl->custom_ptr);\n\t\tif (equal) *equal = '=';\n\t}\n\n\tif (!has_mountpoints && usym.symcall_function_name) {\n\t\tusym.symcall_function = usym.symcall_function_name->custom_ptr;\n\t}\n\n\tuwsgi_foreach(usl, usym.rpc) {\n\t\tchar *space = strchr(usl->value, ' ');\n\t\tif (!space) {\n\t\t\tuwsgi_log(\"invalid symcall RPC syntax, must be: rpcname symbol\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t*space = 0;\n\t\tvoid *func = dlsym(usym.dlsym_handle, space+1);\n\t\tif (!func) {\n\t\t\tuwsgi_log(\"unable to find symbol \\\"%s\\\" in process address space\\n\", space+1);\n\t\t\texit(1);\n\t\t}\n\t\tif (uwsgi_register_rpc(usl->value, &symcall_plugin, 0, func)) {\n                \tuwsgi_log(\"unable to register rpc function\");\n\t\t\texit(1);\n        \t}\n\t\t*space = ' ';\n\t}\n}\n\nstatic int uwsgi_symcall_request(struct wsgi_request *wsgi_req) {\n\tif (usym.symcall_function) {\n\t\treturn usym.symcall_function(wsgi_req);\n\t}\n\n\tif (uwsgi_parse_vars(wsgi_req)) return -1;\n\n        wsgi_req->app_id = uwsgi_get_app_id(wsgi_req, wsgi_req->appid, wsgi_req->appid_len, symcall_plugin.modifier1);\n        if (wsgi_req->app_id == -1 && !uwsgi.no_default_app && uwsgi.default_app > -1) {\n                if (uwsgi_apps[uwsgi.default_app].modifier1 == symcall_plugin.modifier1) {\n                        wsgi_req->app_id = uwsgi.default_app;\n                }\n        }\n\n        if (wsgi_req->app_id == -1) {\n                uwsgi_404(wsgi_req);\n                return UWSGI_OK;\n        }\n\n        struct uwsgi_app *ua = &uwsgi_apps[wsgi_req->app_id];\n\tif (ua->interpreter) {\n\t\tint (*func)(struct wsgi_request *) = (int (*)(struct wsgi_request *)) ua->interpreter;\n\t\treturn func(wsgi_req);\n\t}\n\treturn UWSGI_OK;\n}\n\n\nstatic void uwsgi_symcall_after_request(struct wsgi_request *wsgi_req) {\n\tlog_request(wsgi_req);\n}\n\nstatic uint64_t uwsgi_symcall_rpc(void *func, uint8_t argc, char **argv, uint16_t argvs[], char **buffer) {\n\tuint64_t (*casted_func)(uint8_t, char **, uint16_t *, char **) = (uint64_t (*)(uint8_t, char **, uint16_t *, char **)) func;\n\treturn casted_func(argc, argv, argvs, buffer);\n}\n\nstatic void uwsgi_symcall_post_fork() {\n\tvoid (*func)(void);\n\tstruct uwsgi_string_list *usl = usym.post_fork;\n        while(usl) {\n                func = dlsym(usym.dlsym_handle, usl->value);\n                if (!func) {\n                        uwsgi_log(\"unable to find symbol \\\"%s\\\" in process address space\\n\", usl->value);\n                        exit(1);\n                }\n\t\tfunc();\n                usl = usl->next;\n        }\n}\n\nstatic int uwsgi_symcall_mule(char *opt) {\n\tif (uwsgi_endswith(opt, \"()\")) {\n\t\tchar *func_name = uwsgi_concat2n(opt, strlen(opt)-2, \"\", 0);\n\t\tvoid (*func)() = dlsym(usym.dlsym_handle, func_name);\n\t\tif (!func) {\n\t\t\tuwsgi_log(\"unable to find symbol \\\"%s\\\" in process address space\\n\", func_name);\n                        exit(1);\t\t\t\n\t\t}\n\t\tfree(func_name);\n\t\tfunc();\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#ifdef UWSGI_ROUTING\nstatic int symcall_route(struct wsgi_request *wsgi_req, struct uwsgi_route *ur) {\n\tchar **subject = (char **) (((char *)(wsgi_req))+ur->subject);\n        uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);\n\n        struct uwsgi_buffer *ub = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, ur->data, ur->data_len);\n        if (!ub) return UWSGI_ROUTE_BREAK;\n\n\tint (*func)(struct wsgi_request *) = (int (*)(struct wsgi_request *)) dlsym(usym.dlsym_handle, ub->buf);\n\tuwsgi_buffer_destroy(ub);\n\n\tif (func) {\n\t\twsgi_req->async_status = func(wsgi_req);\n\t}\n\telse {\n\t\tif (ur->custom) return UWSGI_ROUTE_NEXT;\n\t\tuwsgi_404(wsgi_req);\n\t}\n\n\treturn UWSGI_ROUTE_BREAK;\n}\n\nstatic int uwsgi_router_symcall(struct uwsgi_route *ur, char *args) {\n        ur->func = symcall_route;\n        ur->data = args;\n        ur->data_len = strlen(args);\n        return 0;\n}\n\nstatic int uwsgi_router_symcall_next(struct uwsgi_route *ur, char *args) {\n\tur->custom = 1;\n\treturn uwsgi_router_symcall(ur, args);\n}\n#endif\n\nstatic void uwsgi_symcall_register() {\n\tusym.dlsym_handle = RTLD_DEFAULT;\n#ifdef UWSGI_ROUTING\n\tuwsgi_register_router(\"symcall\", uwsgi_router_symcall);\n\tuwsgi_register_router(\"symcall-next\", uwsgi_router_symcall_next);\n#endif\n}\n\nstruct uwsgi_plugin symcall_plugin = {\n\n        .name = \"symcall\",\n        .modifier1 = 18,\n\t.options = uwsgi_symcall_options,\n        .init_apps = uwsgi_symcall_init,\n        .request = uwsgi_symcall_request,\n        .after_request = uwsgi_symcall_after_request,\n\t.rpc = uwsgi_symcall_rpc,\n\t.post_fork = uwsgi_symcall_post_fork,\n\t.mule = uwsgi_symcall_mule,\n\t.on_load = uwsgi_symcall_register,\n};\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/plugins/python/symimporter.c": "#include \"uwsgi_python.h\"\n\nextern struct uwsgi_server uwsgi;\nextern struct uwsgi_python up;\n\n\nstruct _symimporter {\n\tPyObject_HEAD;\n} uwsgi_symbol_importer_object;\n\nstruct _symzipimporter {\n\tPyObject_HEAD;\n\tchar *prefix;\n\tPyObject *zip;\n        PyObject *items;\n} uwsgi_symbol_zip_importer_object;\n\n\nstatic char *symbolize(char *name) {\n\n\tchar *base = uwsgi_concat2(name, \"\");\n\tchar *ptr = base;\n\twhile(*ptr != 0) {\n\t\tif (*ptr == '.') {\n\t\t\t*ptr = '_';\n\t\t}\n\t\tptr++;\n\t}\n\n\treturn base;\n}\n\nstatic char *name_to_py(char *prefix, char *name) {\n\n\tchar *base;\n\tchar *ptr;\n\n\tif (prefix) {\n\t\tif (prefix[strlen(prefix)-1] == '/') { \n        \t\tbase = uwsgi_concat3(prefix, name, \".py\");\n\t\t\tptr = base + strlen(prefix);\n\t\t}\n\t\telse {\n        \t\tbase = uwsgi_concat4(prefix, \"/\", name, \".py\");\n\t\t\tptr = base + strlen(prefix) + 1;\n\t\t}\n\t}\n\telse {\n        \tbase = uwsgi_concat2(name, \".py\");\n\t\tptr = base;\n\t}\n        while(*ptr != 0) {\n                if (*ptr == '.') {\n                        *ptr = '/';\n                }\n                ptr++;\n        }\n\n\t// fix .py\n\tptr-=3;\n\t*ptr = '.';\n        return base;\n}\n\nstatic char *name_to_init_py(char *prefix, char *name) {\n\n\tchar *base;\n\tchar *ptr;\n\n\tif (prefix) {\n\t\tif (prefix[strlen(prefix)-1] == '/') { \n        \t\tbase = uwsgi_concat3(prefix, name, \"/__init__.py\");\n\t\t\tptr = base + strlen(prefix);\n\t\t}\n\t\telse {\n        \t\tbase = uwsgi_concat4(prefix, \"/\", name, \"/__init__.py\");\n\t\t\tptr = base + strlen(prefix) + 1;\n\t\t}\n\t}\n\telse {\n        \tbase = uwsgi_concat2(name, \"/__init__.py\");\n\t\tptr = base;\n\t}\n\n        while(*ptr != 0) {\n                if (*ptr == '.') {\n                        *ptr = '/';\n                }\n                ptr++;\n        }\n\n        // fix .py\n        ptr-=3;\n        *ptr = '.';\n\n        return base;\n}\n\n\n\n\nstatic char *name_to_symbol(char *name, char *what) {\n\n        char *symbol = uwsgi_concat4(\"_binary_\", name, \"_\", what);\n        char *sym_ptr_start = dlsym(RTLD_DEFAULT, symbol);\n        free(symbol);\n        return sym_ptr_start;\n}\n\n\nstatic char *name_to_symbol_module(char *name, char *what) {\n\n\tchar *symbol = uwsgi_concat4(\"_binary_\", name, \"_py_\", what);\n        char *sym_ptr_start = dlsym(RTLD_DEFAULT, symbol);\n\tfree(symbol);\n\treturn sym_ptr_start;\n}\n\nstatic char *name_to_symbol_pkg(char *name, char *what) {\n\n\tchar *symbol = uwsgi_concat4(\"_binary_\", name, \"___init___py_\", what);\n        char *sym_ptr_start = dlsym(RTLD_DEFAULT, symbol);\n\tfree(symbol);\n\treturn sym_ptr_start;\n}\n\nint py_list_has_string(PyObject *obj, char *name) {\n\n\tPy_ssize_t i, len = PyList_Size(obj);\n\tint found = 0;\n\tfor(i=0;i<len;i++) {\n\t\tPyObject *current = PyList_GetItem(obj, i);\n\t\tchar *filename = PyString_AsString(current);\n\t\tif (!strcmp(filename, name)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic PyObject* symzipimporter_find_module(PyObject *self, PyObject *args) {\n\n\tchar *fullname;\n\tPyObject *path = NULL;\n\tstruct _symzipimporter *this = (struct _symzipimporter *) self;\n\n\tif (!PyArg_ParseTuple(args, \"s|O:find_module\", &fullname, &path)) {\n\t\treturn NULL;\n\t}\n\n\tchar *filename = name_to_py(this->prefix, fullname);\n\n\tif (py_list_has_string(this->items, filename)) {\n\t\tfree(filename);\n\t\treturn self;\n\t}\n\n\tPyErr_Clear();\n\tfree(filename);\n\n\tfilename = name_to_init_py(this->prefix, fullname);\n\n\tif (py_list_has_string(this->items, filename)) {\n\t\tfree(filename);\n\t\treturn self;\n\t}\n\n\tPyErr_Clear();\n\tfree(filename);\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nstatic PyObject* symzipimporter_load_module(PyObject *self, PyObject *args) {\n\n\tchar *fullname;\n\tchar *modname;\n        struct _symzipimporter *this = (struct _symzipimporter *) self;\n\n        if (!PyArg_ParseTuple(args, \"s:load_module\", &fullname)) {\n                return NULL;\n        }\n\n        char *filename = name_to_py(this->prefix, fullname);\n\n        if (py_list_has_string(this->items, filename)) {\n\t\tPyObject *mod = PyImport_AddModule(fullname);\n                if (!mod) goto clear;\n                PyObject *dict = PyModule_GetDict(mod);\n                if (!dict) goto clear;\n\n                PyDict_SetItemString(dict, \"__loader__\", self);\n\n                modname = uwsgi_concat2(\"symzip://\", fullname);\n\n\t\tPyObject *source = PyObject_CallMethod(this->zip, \"read\", \"(s)\", filename);\n                free(filename);\n                PyObject *code = Py_CompileString(PyString_AsString(source), modname, Py_file_input);\n\t\tif (!code) {\n\t\t\tPyErr_Print();\n\t\t\tgoto shit;\n\t\t}\n                mod = PyImport_ExecCodeModuleEx(fullname, code, modname);\n\n                Py_DECREF(code);\nshit:\n                Py_DECREF(source);\n                free(modname);\n                return mod;\n        }\n\n        PyErr_Clear();\n        free(filename);\n\n        filename = name_to_init_py(this->prefix, fullname);\n\n        if (py_list_has_string(this->items, filename)) {\n\t\tPyObject *mod = PyImport_AddModule(fullname);\n                if (!mod) goto clear;\n                PyObject *dict = PyModule_GetDict(mod);\n                if (!dict) goto clear;\n\n                modname = uwsgi_concat2(\"symzip://\", fullname);\n\n\t\tPyObject *pkgpath = Py_BuildValue(\"[O]\", PyString_FromString(modname));\n\n                PyDict_SetItemString(dict, \"__path__\", pkgpath);\n                PyDict_SetItemString(dict, \"__loader__\", self);\n\n\n                PyObject *source = PyObject_CallMethod(this->zip, \"read\", \"(s)\", filename);\n                free(filename);\n                PyObject *code = Py_CompileString(PyString_AsString(source), modname, Py_file_input);\n\t\tif (!code) {\n\t\t\tPyErr_Print();\n\t\t\tgoto shit2;\n\t\t}\n                mod = PyImport_ExecCodeModuleEx(fullname, code, modname);\n\n                Py_DECREF(code);\nshit2:\n                Py_DECREF(source);\n                free(modname);\n                return mod;\n        }\n\nclear:\n        PyErr_Clear();\n        free(filename);\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nstatic PyObject* symimporter_find_module(PyObject *self, PyObject *args) {\n\n\tchar *fullname;\n\tPyObject *path = NULL;\n\n\tif (!PyArg_ParseTuple(args, \"s|O:find_module\", &fullname, &path)) {\n\t\treturn NULL;\n\t}\n\n\tchar *fullname2 = symbolize(fullname);\n\n\tchar *code_start = name_to_symbol_module(fullname2, \"start\");\n\tif (code_start) {\n\t\tfree(fullname2);\n\t\tPy_INCREF(self);\n\t\treturn self;\n\t}\n\tcode_start = name_to_symbol_pkg(fullname2, \"start\");\n\tif (code_start) {\n\t\tfree(fullname2);\n\t\tPy_INCREF(self);\n\t\treturn self;\n\t}\n\t\n\t\n\tfree(fullname2);\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nstatic PyObject* symimporter_load_module(PyObject *self, PyObject *args) {\n\n\tchar *code_start;\n\tchar *code_end;\n\tchar *fullname;\n\tchar *source;\n\tchar *modname;\n\tPyObject *code;\n\tif (!PyArg_ParseTuple(args, \"s:load_module\", &fullname)) {\n                return NULL;\n        }\n\n\tchar *fullname2 = symbolize(fullname);\n\n\tcode_start = name_to_symbol_module(fullname2, \"start\");\n\tif (code_start) {\n\t\tcode_end = name_to_symbol_module(fullname2, \"end\");\n\t\tif (code_end) {\n\t\t\tPyObject *mod = PyImport_AddModule(fullname);\n\t\t\tif (!mod) goto clear;\n\t\t\tPyObject *dict = PyModule_GetDict(mod);\n\t\t\tif (!dict) goto clear;\n\n\t\t\tPyDict_SetItemString(dict, \"__loader__\", self);\n\n\t\t\tsource = uwsgi_concat2n(code_start, code_end-code_start, \"\", 0);\n\t\t\tmodname = uwsgi_concat3(\"sym://\", fullname2, \"_py\");\n\n\t\t\tcode = Py_CompileString(source, modname, Py_file_input);\n\t\tif (!code) {\n\t\t\tPyErr_Print();\n\t\t\tgoto shit;\n\t\t}\n\t\t\tmod = PyImport_ExecCodeModuleEx(fullname, code, modname);\n\n\t\t\tPy_DECREF(code);\nshit:\n\t\t\tfree(source);\n\t\t\tfree(modname);\n\t\t\tfree(fullname2);\n\t\t\treturn mod;\t\n\t\t}\n\t}\n\n\tcode_start = name_to_symbol_pkg(fullname2, \"start\");\n        if (code_start) {\n                code_end = name_to_symbol_pkg(fullname2, \"end\");\n                if (code_end) {\n\t\t\tchar *symbolized;\n                        PyObject *mod = PyImport_AddModule(fullname);\n\t\t\tif (!mod) goto clear;\n                        PyObject *dict = PyModule_GetDict(mod);\n\t\t\tif (!dict) goto clear;\n\n                        source = uwsgi_concat2n(code_start, code_end-code_start, \"\", 0);\n\t\t\tsymbolized = symbolize(fullname);\n\t\t\tmodname = uwsgi_concat3(\"sym://\", symbolized, \"___init___py\");\n\n\t\t\tPyObject *pkgpath = Py_BuildValue(\"[O]\", PyString_FromString(modname));\n\n\t\t\tPyDict_SetItemString(dict, \"__path__\", pkgpath);\n\t\t\tPyDict_SetItemString(dict, \"__loader__\", self);\n\n\t\t\tcode = Py_CompileString(source, modname, Py_file_input);\n\t\t\tif (!code) {\n\t\t\t\tPyErr_Print();\n\t\t\t\tgoto shit2;\n\t\t\t}\n                        mod = PyImport_ExecCodeModuleEx(fullname, code, modname);\n\n\t\t\tPy_DECREF(code);\nshit2:\n\t\t\tfree(symbolized);\n\t\t\tfree(source);\n\t\t\tfree(modname);\n\t\t\tfree(fullname2);\n                        return mod;\n                }\n        }\n\nclear:\n\tfree(fullname2);\n\tPy_INCREF(Py_None);\n        return Py_None;\n}\n\nstatic PyMethodDef symimporter_methods[] = {\n\t{\"find_module\", symimporter_find_module, METH_VARARGS},\n \t{\"load_module\", symimporter_load_module, METH_VARARGS},\n\t{ NULL, NULL },\n};\n\nstatic PyMethodDef symzipimporter_methods[] = {\n\t{\"find_module\", symzipimporter_find_module, METH_VARARGS},\n\t{\"load_module\", symzipimporter_load_module, METH_VARARGS},\n\t{ NULL, NULL },\n};\n\nstatic void uwsgi_symimporter_free(struct _symimporter *self) {\n\tPyObject_Del(self);\n}\n\n\nstatic PyTypeObject SymImporter_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"uwsgi.SymbolsImporter\",\n    sizeof(struct _symimporter),\n    0,                                          /* tp_itemsize */\n    (destructor) uwsgi_symimporter_free,            /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,\n    \"uwsgi symbols importer\",                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    symimporter_methods,                        /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                 /* tp_init */\n    PyType_GenericAlloc,                        /* tp_alloc */\n    PyType_GenericNew,                          /* tp_new */\n    0,                            /* tp_free */\n};\n\nstatic int\nzipimporter_init(struct _symzipimporter *self, PyObject *args, PyObject *kwds)\n{\n\n\n        char *name;\n        char *prefix = NULL;\n\tsize_t len = 0;\n\n        if (!PyArg_ParseTuple(args, \"s\", &name))\n                return -1;\n\n        // avoid GC !!!\n        name = uwsgi_concat2(name, \"\");\n\n\tif (uwsgi_check_scheme(name)) {\n                prefix = uwsgi_get_last_char(name, '/');\n                prefix = uwsgi_get_last_char(prefix, ':');\n        }\n        else {\n                prefix = uwsgi_get_last_char(name, ':');\n        }\n\n\tif (prefix) {\n\t\tprefix[0] = 0;\n\t}\n\n\n\tchar *body = uwsgi_open_and_read(name, &len, 0, NULL);\n\tif (!body) {\n\t\treturn -1;\n\t}\n\n\n\n\tPyObject *stringio = PyImport_ImportModule(\"StringIO\");\n        if (!stringio) {\n\t\tfree(body);\n                return -1;\n        }\n\n\n#ifdef PYTHREE\n        PyObject *source_code = PyObject_CallMethodObjArgs(stringio, PyString_FromString(\"StringIO\"), PyString_FromStringAndSize(body, len));\n#else\n\tPyObject *stringio_dict = PyModule_GetDict(stringio);\n        if (!stringio_dict) {\n                return -1;\n        }\n\n\n        PyObject *stringio_stringio = PyDict_GetItemString(stringio_dict, \"StringIO\");\n        if (!stringio_stringio) {\n                return -1;\n        }\n\n\n        PyObject *stringio_args = PyTuple_New(1);\n        PyTuple_SetItem(stringio_args, 0, PyString_FromStringAndSize(body, len));\n\n\n\n        PyObject *source_code = PyInstance_New(stringio_stringio, stringio_args, NULL);\n#endif\n        if (!source_code) {\n                return -1;\n        }\n\n\n        PyObject *zipfile = PyImport_ImportModule(\"zipfile\");\n\n        if (!zipfile) {\n\t\tPyErr_Print();\n                return -1;\n        }\n\n\n#ifdef PYTHREE\n\tself->zip = PyObject_CallMethodObjArgs(zipfile, PyString_FromString(\"ZipFile\"), source_code);\n#else\n\tPyObject *zipfile_dict = PyModule_GetDict(zipfile);\n        if (!zipfile_dict) {\n                return -1;\n        }\n\n        PyObject *zipfile_zipfile = PyDict_GetItemString(zipfile_dict, \"ZipFile\");\n        if (!zipfile_zipfile) {\n                return -1;\n        }\n\n\n        PyObject *zipfile_args = PyTuple_New(1);\n        PyTuple_SetItem(zipfile_args, 0, source_code);\n\n\n        self->zip = PyInstance_New(zipfile_zipfile, zipfile_args, NULL);\n#endif\n        if (!self->zip) {\n                return -1;\n        }\n\n        Py_INCREF(self->zip);\n\n        self->items = PyObject_CallMethod(self->zip, \"namelist\", NULL);\n        if (!self->items) {\n                return -1;\n        }\n\n        Py_INCREF(self->items);\n\n        self->prefix = NULL;\n        if (prefix) {\n                self->prefix = prefix+1;\n                prefix[0] = ':';\n        }\n\n\n        return 0;\n}\n\n\n\nstatic int\nsymzipimporter_init(struct _symzipimporter *self, PyObject *args, PyObject *kwds)\n{\n\n\n\tchar *name;\n\tchar *prefix = NULL;\n\n\tif (!PyArg_ParseTuple(args, \"s\", &name))\n        \treturn -1; \n\n\t// avoid GC !!!\n\tname = uwsgi_concat2(name, \"\");\n\n\tprefix = strchr(name, ':');\n\tif (prefix) {\n\t\tprefix[0] = 0;\n\t}\n\n\tchar *code_start = name_to_symbol(name, \"start\");\n\tif (!code_start) {\n\t\tPyErr_Format(PyExc_ValueError, \"unable to find symbol\");\n\t\tgoto error;\n\t}\n\n\tchar *code_end = name_to_symbol(name, \"end\");\n\tif (!code_end) {\n\t\tPyErr_Format(PyExc_ValueError, \"unable to find symbol\");\n\t\tgoto error;\n\t}\n\n\tPyObject *stringio = PyImport_ImportModule(\"StringIO\");\n\tif (!stringio) {\n\t\tgoto error;\n\t}\n\n#ifdef PYTHREE\n\tPyObject *source_code = PyObject_CallMethodObjArgs(stringio, PyString_FromString(\"StringIO\"), PyString_FromStringAndSize(code_start, code_end-code_start));\n#else\n\tPyObject *stringio_dict = PyModule_GetDict(stringio);\n\tif (!stringio_dict) {\n\t\tgoto error;\n\t}\n\n\tPyObject *stringio_stringio = PyDict_GetItemString(stringio_dict, \"StringIO\");\n\tif (!stringio_stringio) {\n\t\tgoto error;\n\t}\n\n\tPyObject *stringio_args = PyTuple_New(1);\n\tPyTuple_SetItem(stringio_args, 0, PyString_FromStringAndSize(code_start, code_end-code_start));\n\n\n\tPyObject *source_code = PyInstance_New(stringio_stringio, stringio_args, NULL);\n#endif\n\tif (!source_code) {\n\t\tgoto error;\n\t}\n\n\tPyObject *zipfile = PyImport_ImportModule(\"zipfile\");\n\tif (!zipfile) {\n\t\tgoto error;\n\t}\n\t\n#ifdef PYTHREE\n\tself->zip = PyObject_CallMethodObjArgs(zipfile, PyString_FromString(\"ZipFile\"), source_code);\n#else\n\tPyObject *zipfile_dict = PyModule_GetDict(zipfile);\n        if (!zipfile_dict) {\n\t\tgoto error;\n        }\n\n        PyObject *zipfile_zipfile = PyDict_GetItemString(zipfile_dict, \"ZipFile\");\n        if (!zipfile_zipfile) {\n\t\tgoto error;\n        }\n\n        PyObject *zipfile_args = PyTuple_New(1);\n        PyTuple_SetItem(zipfile_args, 0, source_code);\n\n\n\tself->zip = PyInstance_New(zipfile_zipfile, zipfile_args, NULL);\n#endif\n        if (!self->zip) {\n\t\tgoto error;\n        }\n\n\tPy_INCREF(self->zip);\n\n\tself->items = PyObject_CallMethod(self->zip, \"namelist\", NULL);\n        if (!self->items) {\n\t\tgoto error;\n        }\n\n\tPy_INCREF(self->items);\n\n\tself->prefix = NULL;\n\tif (prefix) {\n\t\tself->prefix = prefix+1;\n\t\tprefix[0] = ':';\n\t}\n\n\n\treturn 0;\n\nerror:\n\tfree(name);\n\treturn -1;\n}\n\nstatic PyTypeObject SymZipImporter_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"uwsgi.SymbolsZipImporter\",\n    sizeof(struct _symzipimporter),\n    0,                                          /* tp_itemsize */\n    (destructor) uwsgi_symimporter_free,            /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,\n    \"uwsgi symbols zip importer\",                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    symzipimporter_methods,                        /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc) symzipimporter_init,                 /* tp_init */\n    PyType_GenericAlloc,                        /* tp_alloc */\n    PyType_GenericNew,                          /* tp_new */\n    0,                            /* tp_free */\n};\n\nstatic PyTypeObject ZipImporter_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"uwsgi.ZipImporter\",\n    sizeof(struct _symzipimporter),\n    0,                                          /* tp_itemsize */\n    (destructor) uwsgi_symimporter_free,            /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_compare */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                    /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,\n    \"uwsgi zip importer\",                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    symzipimporter_methods,                        /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc) zipimporter_init,                 /* tp_init */\n    PyType_GenericAlloc,                        /* tp_alloc */\n    PyType_GenericNew,                          /* tp_new */\n    0,                            /* tp_free */\n};\n\n\n\nint uwsgi_init_symbol_import() {\n\n\n\tif (PyType_Ready(&SymImporter_Type) < 0) {\n\t\tPyErr_Print();\n\t\tuwsgi_log(\"unable to initialize symbols importer module\\n\");\n\t\texit(1);\n\t}\n\n\tif (PyType_Ready(&ZipImporter_Type) < 0) {\n\t\tPyErr_Print();\n\t\tuwsgi_log(\"unable to initialize zip importer module\\n\");\n\t\texit(1);\n\t}\n\n\tif (PyType_Ready(&SymZipImporter_Type) < 0) {\n\t\tPyErr_Print();\n\t\tuwsgi_log(\"unable to initialize symbols zip importer module\\n\");\n\t\texit(1);\n\t}\n\n\tPyObject *uwsgi_em = PyImport_ImportModule(\"uwsgi\");\n\tif (!uwsgi_em) {\n\t\tPyErr_Print();\n\t\tuwsgi_log(\"unable to get uwsgi module\\n\");\n\t\texit(1);\n\t}\n\n\tPy_INCREF((PyObject *)&SymImporter_Type);\n\tif (PyModule_AddObject(uwsgi_em, \"SymbolsImporter\",\n                           (PyObject *)&SymImporter_Type) < 0) {\n\t\tPyErr_Print();\n\t\tuwsgi_log(\"unable to initialize symbols importer object\\n\");\n\t\texit(1);\n\t}\n\n\tPy_INCREF((PyObject *)&ZipImporter_Type);\n\tif (PyModule_AddObject(uwsgi_em, \"ZipImporter\",\n                           (PyObject *)&ZipImporter_Type) < 0) {\n\t\tPyErr_Print();\n\t\tuwsgi_log(\"unable to initialize zip importer object\\n\");\n\t\texit(1);\n\t}\n\n\tPy_INCREF((PyObject *)&SymZipImporter_Type);\n\tif (PyModule_AddObject(uwsgi_em, \"SymbolsZipImporter\",\n                           (PyObject *)&SymZipImporter_Type) < 0) {\n\t\tPyErr_Print();\n\t\tuwsgi_log(\"unable to initialize symbols zip importer object\\n\");\n\t\texit(1);\n\t}\n\n\n        return 0;\n\t\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/plugins/python/uwsgi_pymodule.c": "#include \"uwsgi_python.h\"\n\nextern struct uwsgi_server uwsgi;\nextern struct uwsgi_python up;\nextern struct uwsgi_plugin python_plugin;\n\nstatic PyObject *py_uwsgi_add_var(PyObject * self, PyObject * args) {\n\t char *key = NULL;\n        Py_ssize_t keylen = 0;\n        char *val = NULL;\n        Py_ssize_t vallen = 0;\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n\tif (!PyArg_ParseTuple(args, \"s#s#\", &key, &keylen, &val, &vallen)) {\n        \treturn NULL;\n        }\n\n\tif (!uwsgi_req_append(wsgi_req, key, keylen, val, vallen)) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"unable to add request var, check your buffer size\");\n\t}\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n}\n\nstatic PyObject *py_uwsgi_micros(PyObject * self, PyObject * args) {\n        return PyLong_FromUnsignedLongLong(uwsgi_micros());\n}\n\nstatic PyObject *py_uwsgi_signal_wait(PyObject * self, PyObject * args) {\n\n        struct wsgi_request *wsgi_req = py_current_wsgi_req();\n\tint wait_for_specific_signal = 0;\n\tuint8_t uwsgi_signal = 0;\n\tint received_signal;\n\n\twsgi_req->signal_received = -1;\n\n\tif (PyTuple_Size(args) > 0) {\n\t\tif (!PyArg_ParseTuple(args, \"|B:\", &uwsgi_signal)) {\n                \treturn NULL;\n        \t}\n\t\twait_for_specific_signal = 1;\t\n\t}\n\n\tUWSGI_RELEASE_GIL;\n\n\tif (wait_for_specific_signal) {\n\t\treceived_signal = uwsgi_signal_wait(uwsgi_signal);\n\t}\n\telse {\n\t\treceived_signal = uwsgi_signal_wait(-1);\n\t}\n\n\tif (received_signal < 0) {\n\t\tUWSGI_GET_GIL;\n\t\treturn PyErr_Format(PyExc_SystemError, \"error waiting for signal\");\n\t}\n\n        wsgi_req->signal_received = received_signal;\n\n\tUWSGI_GET_GIL;\n\n        return PyString_FromString(\"\");\n}\n\nstatic PyObject *py_uwsgi_signal_received(PyObject * self, PyObject * args) {\n\n        struct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n        return PyInt_FromLong(wsgi_req->signal_received);\n}\n\n\nchar *uwsgi_encode_pydict(PyObject * pydict, uint16_t * size) {\n\n\tint i;\n\tPyObject *zero, *key, *val;\n\tuint16_t keysize, valsize;\n\n\n\tchar *buf, *bufptr;\n\n\tPyObject *vars = PyDict_Items(pydict);\n\n\tif (!vars) {\n\t\tPyErr_Print();\n\t\treturn NULL;\n\t}\n\n\t*size = 0;\n\n\t// calc the packet size\n\t// try to fallback whenever possible\n\tfor (i = 0; i < PyList_Size(vars); i++) {\n\t\tzero = PyList_GetItem(vars, i);\n\t\tif (!zero) {\n\t\t\tPyErr_Print();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!PyTuple_Check(zero)) {\n\t\t\tuwsgi_log(\"invalid python dictionary item\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PyTuple_Size(zero) < 2) {\n\t\t\tuwsgi_log(\"invalid python dictionary item\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tkey = PyTuple_GetItem(zero, 0);\n\t\tval = PyTuple_GetItem(zero, 1);\n\n\t\tif (!PyString_Check(key) || !PyString_Check(val)) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tkeysize = PyString_Size(key);\n\t\tvalsize = PyString_Size(val);\n\n\t\t*size += (keysize + 2 + valsize + 2);\n\n\t\t// do not DECREF here !!!\n\t\t//Py_DECREF(zero);\n\t}\n\n\tif (*size <= 4) {\n\t\tuwsgi_log(\"empty python dictionary\\n\");\n\t\treturn NULL;\n\t}\n\n\t// remember to free this memory !!!\n\tbuf = malloc(*size);\n\tif (!buf) {\n\t\tuwsgi_error(\"malloc()\");\n\t\treturn NULL;\n\t}\n\n\tbufptr = buf;\n\n\tfor (i = 0; i < PyList_Size(vars); i++) {\n\t\tzero = PyList_GetItem(vars, i);\n\t\tif (!zero) {\n\t\t\tPyErr_Print();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!PyTuple_Check(zero)) {\n\t\t\tuwsgi_log(\"invalid python dictionary item\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PyTuple_Size(zero) < 2) {\n\t\t\tuwsgi_log(\"invalid python dictionary item\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tkey = PyTuple_GetItem(zero, 0);\n\t\tval = PyTuple_GetItem(zero, 1);\n\n\n\t\tif (!key || !val) {\n\t\t\tPyErr_Print();\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!PyString_Check(key) || !PyString_Check(val)) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tkeysize = PyString_Size(key);\n\t\tvalsize = PyString_Size(val);\n\t\tif (bufptr + keysize + 2 + valsize + 2 <= buf + *size) {\n\n\t\t\t*bufptr++ = (uint8_t) (keysize & 0xff);\n        \t\t*bufptr++ = (uint8_t) ((keysize >> 8) & 0xff);\n\t\t\tmemcpy(bufptr, PyString_AsString(key), keysize);\n\t\t\tbufptr += keysize;\n\n\t\t\t*bufptr++ = (uint8_t) (valsize & 0xff);\n        \t\t*bufptr++ = (uint8_t) ((valsize >> 8) & 0xff);\n\t\t\tmemcpy(bufptr, PyString_AsString(val), valsize);\n\t\t\tbufptr += valsize;\n\t\t}\n\n\t}\n\n\treturn buf;\n\n}\n\nstatic PyObject *py_uwsgi_listen_queue(PyObject * self, PyObject * args) {\n\n\tint id = 0;\n\n\tif (!PyArg_ParseTuple(args, \"|i:listen_queue\", &id)) {\n                return NULL;\n        }\n\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi_get_socket_by_num(id);\n\tif (!uwsgi_sock) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"unable to find socket %d\", id);\n\t}\n\n\treturn PyInt_FromLong(uwsgi_sock->queue);\n}\n\nstatic PyObject *py_uwsgi_close(PyObject * self, PyObject * args) {\n\n\tint fd;\n\n\tif (!PyArg_ParseTuple(args, \"i:close\", &fd)) {\n\t\treturn NULL;\n\t}\n\n\tclose(fd);\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n\n}\n\nstatic PyObject *py_uwsgi_add_cron(PyObject * self, PyObject * args) {\n\n\tuint8_t uwsgi_signal;\n\tint minute, hour, day, month, week;\n\n\tif (!PyArg_ParseTuple(args, \"Biiiii:add_cron\", &uwsgi_signal, &minute, &hour, &day, &month, &week)) {\n                return NULL;\n        }\n\n\tif (uwsgi_signal_add_cron(uwsgi_signal, minute, hour, day, month, week)) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"unable to add cron\");\n\t}\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n}\n\n\nstatic PyObject *py_uwsgi_add_timer(PyObject * self, PyObject * args) {\n\n\tuint8_t uwsgi_signal;\n\tint secs;\n\n\tif (!PyArg_ParseTuple(args, \"Bi:add_timer\", &uwsgi_signal, &secs)) {\n\t\treturn NULL;\n\t}\n\n\tif (uwsgi_add_timer(uwsgi_signal, secs))\n\t\treturn PyErr_Format(PyExc_ValueError, \"unable to add timer\");\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_add_rb_timer(PyObject * self, PyObject * args) {\n\n        uint8_t uwsgi_signal;\n        int secs;\n\tint iterations = 0;\n\n        if (!PyArg_ParseTuple(args, \"Bi|i:add_rb_timer\", &uwsgi_signal, &secs, &iterations)) {\n                return NULL;\n        }\n\n        if (uwsgi_signal_add_rb_timer(uwsgi_signal, secs, iterations))\n                return PyErr_Format(PyExc_ValueError, \"unable to add rb_timer\");\n\n        Py_INCREF(Py_None);\n        return Py_None;\n}\n\n\n\nPyObject *py_uwsgi_add_file_monitor(PyObject * self, PyObject * args) {\n\n\tuint8_t uwsgi_signal;\n\tchar *filename;\n\n\tif (!PyArg_ParseTuple(args, \"Bs:add_file_monitor\", &uwsgi_signal, &filename)) {\n\t\treturn NULL;\n\t}\n\n\tif (uwsgi_add_file_monitor(uwsgi_signal, filename))\n\t\treturn PyErr_Format(PyExc_ValueError, \"unable to add file monitor\");\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_call(PyObject * self, PyObject * args) {\n\n\tchar *func;\n\tuint64_t size = 0;\n\tPyObject *py_func;\n\tint argc = PyTuple_Size(args);\n\tint i;\n\tchar *argv[256];\n\tuint16_t argvs[256];\n\n\t// TODO better error reporting\n\tif (argc < 1)\n\t\tgoto clear;\n\n\tpy_func = PyTuple_GetItem(args, 0);\n\n\tif (!PyString_Check(py_func))\n\t\tgoto clear;\n\n\tfunc = PyString_AsString(py_func);\n\n\tfor (i = 0; i < (argc - 1); i++) {\n\t\tPyObject *py_str = PyTuple_GetItem(args, i + 1);\n\t\tif (!PyString_Check(py_str)) {\n\t\t\tgoto clear;\n\t\t}\n\t\targv[i] = PyString_AsString(py_str);\n\t\targvs[i] = PyString_Size(py_str);\n\t}\n\n\tUWSGI_RELEASE_GIL;\n\t// response must always be freed\n\tchar *response = uwsgi_do_rpc(NULL, func, argc - 1, argv, argvs, &size);\n\tUWSGI_GET_GIL;\n\n\tif (response) {\n\t\tPyObject *ret = PyString_FromStringAndSize(response, size);\n\t\tfree(response);\n\t\treturn ret;\n\t}\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n\n      clear:\n\n\treturn PyErr_Format(PyExc_ValueError, \"unable to call rpc function\");\n\n}\n\nPyObject *py_uwsgi_rpc_list(PyObject * self, PyObject * args) {\n\n\tuint64_t i;\n\tPyObject *rpc_list = PyTuple_New(uwsgi.shared->rpc_count[uwsgi.mywid]);\n\n\tint pos = (uwsgi.mywid * uwsgi.rpc_max);\n\tfor (i = 0; i < uwsgi.shared->rpc_count[uwsgi.mywid]; i++) {\n\t\tif (uwsgi.rpc_table[pos + i].name[0] != 0) {\n\t\t\tPyTuple_SetItem(rpc_list, i, PyString_FromString(uwsgi.rpc_table[pos + i].name));\n\t\t}\n\t}\n\n\treturn rpc_list;\n\n}\n\nPyObject *py_uwsgi_rpc(PyObject * self, PyObject * args) {\n\n\tchar *node = NULL, *func;\n\tuint64_t size = 0;\n\tPyObject *py_node, *py_func;\n\n\tint argc = PyTuple_Size(args);\n\tchar *argv[256];\n\tuint16_t argvs[256];\n\n\tint i;\n\n\t// TODO better error reporting\n\tif (argc < 2)\n\t\tgoto clear;\n\n\tpy_node = PyTuple_GetItem(args, 0);\n\n\tif (PyString_Check(py_node)) {\n\t\tnode = PyString_AsString(py_node);\n\t}\n#ifdef PYTHREE\n        else if (PyUnicode_Check(py_node)) {\n                node = PyBytes_AsString(PyUnicode_AsLatin1String(py_node));\n\t}\n#endif\n\n\tpy_func = PyTuple_GetItem(args, 1);\n\n\tif (!PyString_Check(py_func))\n\t\tgoto clear;\n\n\tfunc = PyString_AsString(py_func);\n\n\tfor (i = 0; i < (argc - 2); i++) {\n\t\tPyObject *py_str = PyTuple_GetItem(args, i + 2);\n\t\tif (!PyString_Check(py_str))\n\t\t\tgoto clear;\n\t\targv[i] = PyString_AsString(py_str);\n\t\targvs[i] = PyString_Size(py_str);\n\t}\n\n\tUWSGI_RELEASE_GIL;\n\tchar *response = uwsgi_do_rpc(node, func, argc - 2, argv, argvs, &size);\n\tUWSGI_GET_GIL;\n\n\tif (response) {\n                PyObject *ret = PyString_FromStringAndSize(response, size);\n                free(response);\n                return ret;\n        }\n\n\tPy_INCREF(Py_None);\n        return Py_None;\n\n      clear:\n\n        return PyErr_Format(PyExc_ValueError, \"unable to call rpc function\");\n\n}\n\nPyObject *py_uwsgi_register_rpc(PyObject * self, PyObject * args) {\n\n\tuint8_t argc = 0;\n\tchar *name;\n\tPyObject *func;\n\n\tif (!PyArg_ParseTuple(args, \"sO|B:register_rpc\", &name, &func, &argc)) {\n\t\treturn NULL;\n\t}\n\n\tPy_INCREF(func);\n\n\tif (uwsgi_register_rpc(name, &python_plugin, argc, func)) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"unable to register rpc function\");\n\t}\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n}\n\nPyObject *py_uwsgi_signal_registered(PyObject * self, PyObject * args) {\n\tuint8_t uwsgi_signal;\n\n\tif (!PyArg_ParseTuple(args, \"B:signal_registered\", &uwsgi_signal)) {\n                return NULL;\n        }\n\n\tif (uwsgi_signal_registered(uwsgi_signal)) {\n\t\tPy_INCREF(Py_True);\n\t\treturn Py_True;\n\t}\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\n#ifdef UWSGI_SSL\nPyObject *py_uwsgi_i_am_the_lord(PyObject * self, PyObject * args) {\n\tchar *legion_name = NULL;\n\n        if (!PyArg_ParseTuple(args, \"s:i_am_the_lord\", &legion_name)) {\n                return NULL;\n        }\n\n        if (uwsgi_legion_i_am_the_lord(legion_name)) {\n                Py_INCREF(Py_True);\n                return Py_True;\n        }\n\n        Py_INCREF(Py_False);\n        return Py_False;\n}\n\nPyObject *py_uwsgi_lord_scroll(PyObject * self, PyObject * args) {\n        char *legion_name = NULL;\n\n        if (!PyArg_ParseTuple(args, \"s:lord_scroll\", &legion_name)) {\n                return NULL;\n        }\n\n\tuint16_t rlen = 0;\n\tchar *buf = uwsgi_legion_lord_scroll(legion_name, &rlen);\n\tif (!buf) {\n        \tPy_INCREF(Py_None);\n        \treturn Py_None;\n\t}\n\n\tPyObject *ret = PyString_FromStringAndSize(buf, rlen);\n\tfree(buf);\n        return ret;\n}\n\nstatic void scrolls_items(uint16_t pos, char *key, uint16_t keylen, void *data) {\n\tPyObject *list = (PyObject *) data;\n\tPyObject *zero = PyString_FromStringAndSize(key, keylen);\n\tPyList_Append(list, zero);\n\tPy_DECREF(zero);\n}\n\nPyObject *py_uwsgi_scrolls(PyObject * self, PyObject * args) {\n        char *legion_name = NULL;\n\n        if (!PyArg_ParseTuple(args, \"s:scrolls\", &legion_name)) {\n                return NULL;\n        }\n\n\tuint64_t rlen = 0;\n        char *buf = uwsgi_legion_scrolls(legion_name, &rlen);\n\tif (!buf) goto end;\n\tPyObject *list = PyList_New(0);\n\tif (uwsgi_hooked_parse_array(buf, rlen, scrolls_items, list)) {\n\t\tgoto error;\n\t}\n\tfree(buf);\n\treturn list;\nerror:\n\tfree(buf);\nend:\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\n\n#endif\n\nPyObject *py_uwsgi_register_signal(PyObject * self, PyObject * args) {\n\n\tuint8_t uwsgi_signal;\n\tchar *signal_kind;\n\tPyObject *handler;\n\n\tif (!PyArg_ParseTuple(args, \"BsO:register_signal\", &uwsgi_signal, &signal_kind, &handler)) {\n\t\treturn NULL;\n\t}\n\n\tPy_INCREF(handler);\n\n\tif (uwsgi_register_signal(uwsgi_signal, signal_kind, handler, 0)) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"unable to register signal\");\n\t}\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_signal(PyObject * self, PyObject * args) {\n\n\tuint8_t uwsgi_signal;\n\tchar *remote = NULL;\n\n\tif (!PyArg_ParseTuple(args, \"B|s:signal\", &uwsgi_signal, &remote)) {\n\t\treturn NULL;\n\t}\n\n\tif (remote) {\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"sending signal %d to node %s\\n\", uwsgi_signal, remote);\n#endif\n\t\tint ret = uwsgi_remote_signal_send(remote, uwsgi_signal);\n\t\tif (ret == 1) goto clear;\n\t\tif (ret == -1)\n\t\t\treturn PyErr_Format(PyExc_IOError, \"unable to deliver signal %d to node %s\", uwsgi_signal, remote);\n\t\tif (ret == 0)\n\t\t\treturn PyErr_Format(PyExc_ValueError, \"node %s rejected signal %d\", remote, uwsgi_signal);\n\t}\n\telse {\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"sending signal %d to master\\n\", uwsgi_signal);\n#endif\n\t\tuwsgi_signal_send(uwsgi.signal_socket, uwsgi_signal);\n\t}\n\nclear:\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n\n}\n\nPyObject *py_uwsgi_log_this(PyObject * self, PyObject * args) {\n\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n\twsgi_req->log_this = 1;\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_alarm(PyObject * self, PyObject * args) {\n\tchar *alarm = NULL;\n\tchar *msg = NULL;\n\tPy_ssize_t msg_len = 0;\n\tif (!PyArg_ParseTuple(args, \"ss#:alarm\", &alarm, &msg, &msg_len)) {\n                return NULL;\n        }\t\n\n\tuwsgi_alarm_trigger(alarm, msg, msg_len);\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_get_logvar(PyObject * self, PyObject * args) {\n\n\tchar *key = NULL;\n        Py_ssize_t keylen = 0;\n        struct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n\tif (!PyArg_ParseTuple(args, \"s#:get_logvar\", &key, &keylen)) {\n                return NULL;\n        }\n\n\tstruct uwsgi_logvar *lv = uwsgi_logvar_get(wsgi_req, key, keylen);\n\n\tif (lv) {\n\t\treturn PyString_FromStringAndSize(lv->val, lv->vallen);\n\t}\n\n        Py_INCREF(Py_None);\n        return Py_None;\n}\n\nPyObject *py_uwsgi_set_logvar(PyObject * self, PyObject * args) {\n\n        char *key = NULL;\n        Py_ssize_t keylen = 0;\n        char *val = NULL;\n        Py_ssize_t vallen = 0;\n        struct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n        if (!PyArg_ParseTuple(args, \"s#s#:set_logvar\", &key, &keylen, &val, &vallen)) {\n                return NULL;\n        }\n\n        uwsgi_logvar_add(wsgi_req, key, keylen, val, vallen);\n\n        Py_INCREF(Py_None);\n        return Py_None;\n}\n\nPyObject *py_uwsgi_recv(PyObject * self, PyObject * args) {\n\n\tint fd, max_size = 4096;\n\tchar buf[4096];\n\tssize_t rlen;\n\n\n\tif (!PyArg_ParseTuple(args, \"i|i:recv\", &fd, &max_size)) {\n\t\treturn NULL;\n\t}\n\n\tUWSGI_RELEASE_GIL\n\t\t// security check\n\t\tif (max_size > 4096)\n\t\tmax_size = 4096;\n\n\trlen = read(fd, buf, max_size);\n\n\tUWSGI_GET_GIL if (rlen > 0) {\n\t\treturn PyString_FromStringAndSize(buf, rlen);\n\t}\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_is_connected(PyObject * self, PyObject * args) {\n\n\tint fd = -1;\n\n\tif (!PyArg_ParseTuple(args, \"i:is_connected\", &fd)) {\n\t\treturn NULL;\n\t}\n\n\tif (uwsgi_is_connected(fd)) {\n\t\tPy_INCREF(Py_True);\n\t\treturn Py_True;\n\t}\n\n\tPy_INCREF(Py_False);\n\treturn Py_False;\n}\n\n\nPyObject *py_uwsgi_send(PyObject * self, PyObject * args) {\n\n\tPyObject *data;\n\tPyObject *arg1, *arg2;\n\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n\tint uwsgi_fd = wsgi_req->fd;\n\n\tif (!PyArg_ParseTuple(args, \"O|O:send\", &arg1, &arg2)) {\n\t\treturn NULL;\n\t}\n\n\tif (PyTuple_Size(args) > 1) {\n\t\tuwsgi_fd = PyInt_AsLong(arg1);\n\t\tdata = arg2;\n\t}\n\telse {\n\t\tdata = arg1;\n\t}\n\n\tUWSGI_RELEASE_GIL if (write(uwsgi_fd, PyString_AsString(data), PyString_Size(data)) < 0) {\n\t\tuwsgi_error(\"write()\");\n\t\tUWSGI_GET_GIL Py_INCREF(Py_None);\n\t\treturn Py_None;\n\t}\n\n\tUWSGI_GET_GIL Py_INCREF(Py_True);\n\treturn Py_True;\n\n}\n\n#ifdef UWSGI_ROUTING\nstatic PyObject *py_uwsgi_route(PyObject * self, PyObject * args) {\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\tchar *router_name = NULL;\n\tchar *router_args = NULL;\n\n\tif (!PyArg_ParseTuple(args, \"ss:route\", &router_name, &router_args)) {\n                return NULL;\n        }\n\n\tint ret = uwsgi_route_api_func(wsgi_req, router_name, uwsgi_str(router_args));\n\treturn PyInt_FromLong(ret);\n}\n#endif\n\nPyObject *py_uwsgi_offload(PyObject * self, PyObject * args) {\n/*\n\tsize_t len = 0;\n\tchar *filename = NULL;\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n\tif (!PyArg_ParseTuple(args, \"s|i:offload_transfer\", &filename, &len)) {\n                return NULL;\n        }\n\n\tif (!wsgi_req->socket->can_offload) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"The current socket does not support offloading\");\n\t}\n\n\tif (!wsgi_req->headers_sent) {\n\t\tUWSGI_RELEASE_GIL\n        \tif (uwsgi_response_write_headers_do(wsgi_req)) {\n\t\t\tUWSGI_GET_GIL\n\t\t\treturn PyErr_Format(PyExc_ValueError, \"unable to send headers before offload transfer\");\n\t\t}\n\t\tUWSGI_GET_GIL\n\t}\n\n\n\tUWSGI_RELEASE_GIL\n        if (uwsgi_offload_request_sendfile_do(wsgi_req, filename, -1, len)) {\n\t\tUWSGI_GET_GIL\n\t\treturn PyErr_Format(PyExc_ValueError, \"unable to offload the request\");\n\t}\n\tUWSGI_GET_GIL\n\n*/\n\n\treturn PyString_FromString(\"\");\n}\n\nPyObject *py_uwsgi_advanced_sendfile(PyObject * self, PyObject * args) {\n\n\tPyObject *what;\n\tchar *filename;\n\tsize_t chunk = 0;\n\toff_t pos = 0;\n\tsize_t filesize = 0;\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n\tint fd = -1;\n\n\tif (!PyArg_ParseTuple(args, \"O|iii:sendfile\", &what, &chunk, &pos, &filesize)) {\n\t\treturn NULL;\n\t}\n\n\n\tif (PyString_Check(what)) {\n\n\t\tfilename = PyString_AsString(what);\n\n\t\tfd = open(filename, O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\tuwsgi_error_open(filename);\n\t\t\tgoto clear;\n\t\t}\n\n\t}\n#ifdef PYTHREE\n\telse if (PyUnicode_Check(what)) {\n\t\tfilename = PyBytes_AsString(PyUnicode_AsLatin1String(what));\n\n\t\tfd = open(filename, O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\tuwsgi_error_open(filename);\n\t\t\tgoto clear;\n\t\t}\n\t}\n#endif\n\telse {\n\t\tfd = PyObject_AsFileDescriptor(what);\n\t\tif (fd < 0)\n\t\t\tgoto clear;\n\n\t\t// check for mixing file_wrapper and sendfile\n\t\tif (fd == wsgi_req->sendfile_fd) {\n\t\t\tPy_INCREF(what);\n\t\t}\n\t}\n\n\tUWSGI_RELEASE_GIL\n\t// fd is closed by the following function\n\tuwsgi_response_sendfile_do(wsgi_req, fd, pos, filesize);\n\tUWSGI_GET_GIL\n\t// revert to old values\n\tuwsgi_py_check_write_errors {\n        \tuwsgi_py_write_exception(wsgi_req);\n\t\treturn NULL;\n        }\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\n      clear:\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n\n}\n\n\nPyObject *py_uwsgi_async_sleep(PyObject * self, PyObject * args) {\n\n\tfloat timeout;\n\tint sec_timeout;\n\n\tif (!PyArg_ParseTuple(args, \"f:async_sleep\", &timeout)) {\n\t\treturn NULL;\n\t}\n\n\tsec_timeout = (int) timeout;\n\n\tif (sec_timeout > 0) {\n\t\tasync_add_timeout(uwsgi.wsgi_req, sec_timeout);\n\t}\n\n\treturn PyString_FromString(\"\");\n}\n\nPyObject *py_uwsgi_warning(PyObject * self, PyObject * args) {\n\tchar *message;\n\tint len;\n\n\tif (!PyArg_ParseTuple(args, \"s:set_warning_message\", &message)) {\n\t\treturn NULL;\n\t}\n\n\tlen = strlen(message);\n\tif (len > 80) {\n\t\tuwsgi_log(\"- warning message must be max 80 chars, it will be truncated -\");\n\t\tmemcpy(uwsgi.shared->warning_message, message, 80);\n\t\tuwsgi.shared->warning_message[80] = 0;\n\t}\n\telse {\n\t\tmemcpy(uwsgi.shared->warning_message, message, len);\n\t\tuwsgi.shared->warning_message[len] = 0;\n\t}\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n}\n\nPyObject *py_uwsgi_log(PyObject * self, PyObject * args) {\n\tchar *logline;\n\n\tif (!PyArg_ParseTuple(args, \"s:log\", &logline)) {\n\t\treturn NULL;\n\t}\n\n\tuwsgi_log(\"%s\\n\", logline);\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n}\n\nPyObject *py_uwsgi_set_user_harakiri(PyObject * self, PyObject * args) {\n\tint sec = 0;\n\tif (!PyArg_ParseTuple(args, \"i:set_user_harakiri\", &sec)) {\n                return NULL;\n        }\n\n\tset_user_harakiri(sec);\n\n        Py_INCREF(Py_None);\n        return Py_None;\n}\n\nPyObject *py_uwsgi_i_am_the_spooler(PyObject * self, PyObject * args) {\n\tif (uwsgi.i_am_a_spooler) {\n\t\tPy_INCREF(Py_True);\n\t\treturn Py_True;\n\t}\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_is_locked(PyObject * self, PyObject * args) {\n\n        int lock_num = 0;\n\n        // the spooler cannot lock resources\n        if (uwsgi.i_am_a_spooler) {\n                return PyErr_Format(PyExc_ValueError, \"The spooler cannot lock/unlock resources\");\n        }\n\n        if (!PyArg_ParseTuple(args, \"|i:is_locked\", &lock_num)) {\n                return NULL;\n        }\n\n        if (lock_num < 0 || lock_num > uwsgi.locks) {\n                return PyErr_Format(PyExc_ValueError, \"Invalid lock number\");\n        }\n\n\tUWSGI_RELEASE_GIL\n\n        if (uwsgi_lock_check(uwsgi.user_lock[lock_num]) == 0) {\n\t\tUWSGI_GET_GIL\n\t\tPy_INCREF(Py_False);\n\t\treturn Py_False;\n\t}\n\n\tUWSGI_GET_GIL\n\n        Py_INCREF(Py_True);\n        return Py_True;\n}\n\n\nPyObject *py_uwsgi_lock(PyObject * self, PyObject * args) {\n\n\tint lock_num = 0;\n\n\t// the spooler cannot lock resources\n\tif (uwsgi.i_am_a_spooler) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"The spooler cannot lock/unlock resources\");\n\t}\n\n\tif (!PyArg_ParseTuple(args, \"|i:lock\", &lock_num)) {\n                return NULL;\n        }\n\n\tif (lock_num < 0 || lock_num > uwsgi.locks) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"Invalid lock number\");\n\t}\n\n\tUWSGI_RELEASE_GIL\n\tuwsgi_lock(uwsgi.user_lock[lock_num]);\n\tUWSGI_GET_GIL\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_unlock(PyObject * self, PyObject * args) {\n\n\tint lock_num = 0;\n\n\tif (uwsgi.i_am_a_spooler) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"The spooler cannot lock/unlock resources\");\n\t}\n\n\tif (!PyArg_ParseTuple(args, \"|i:unlock\", &lock_num)) {\n                return NULL;\n        }\n\n        if (lock_num < 0 || lock_num > uwsgi.locks) {\n                return PyErr_Format(PyExc_ValueError, \"Invalid lock number\");\n        }\n\n\tuwsgi_unlock(uwsgi.user_lock[lock_num]);\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_connection_fd(PyObject * self, PyObject * args) {\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\treturn PyInt_FromLong(wsgi_req->fd);\n}\n\nPyObject *py_uwsgi_websocket_handshake(PyObject * self, PyObject * args) {\n        char *key = NULL;\n        Py_ssize_t key_len = 0;\n\n        char *origin = NULL;\n        Py_ssize_t origin_len = 0;\n\n        char *proto = NULL;\n        Py_ssize_t proto_len = 0;\n\n        if (!PyArg_ParseTuple(args, \"|s#s#s#:websocket_handshake\", &key, &key_len, &origin, &origin_len, &proto, &proto_len)) {\n                return NULL;\n        }\n\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n\tUWSGI_RELEASE_GIL\n\tint ret = uwsgi_websocket_handshake(wsgi_req, key, key_len, origin, origin_len, proto, proto_len);\n\tUWSGI_GET_GIL\n\n\tif (ret) {\n\t\treturn PyErr_Format(PyExc_IOError, \"unable to complete websocket handshake\");\n\t}\n\n\tPy_INCREF(Py_None);\n        return Py_None;\n}\n\nPyObject *py_uwsgi_websocket_send(PyObject * self, PyObject * args) {\n\tchar *message = NULL;\n        Py_ssize_t message_len = 0;\n\n        if (!PyArg_ParseTuple(args, \"s#:websocket_send\", &message, &message_len)) {\n                return NULL;\n        }\n\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n\tUWSGI_RELEASE_GIL\t\n\tint ret  = uwsgi_websocket_send(wsgi_req, message, message_len);\n\tUWSGI_GET_GIL\t\n\tif (ret < 0) {\n\t\treturn PyErr_Format(PyExc_IOError, \"unable to send websocket message\");\n\t}\n\tPy_INCREF(Py_None);\n        return Py_None;\n}\n\nPyObject *py_uwsgi_websocket_send_binary(PyObject * self, PyObject * args) {\n        char *message = NULL;\n        Py_ssize_t message_len = 0;\n\n        if (!PyArg_ParseTuple(args, \"s#:websocket_send_binary\", &message, &message_len)) {\n                return NULL;\n        }\n\n        struct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n        UWSGI_RELEASE_GIL\n        int ret  = uwsgi_websocket_send_binary(wsgi_req, message, message_len);\n        UWSGI_GET_GIL\n        if (ret < 0) {\n                return PyErr_Format(PyExc_IOError, \"unable to send websocket binary message\");\n        }\n        Py_INCREF(Py_None);\n        return Py_None;\n}\n\n\nPyObject *py_uwsgi_chunked_read(PyObject * self, PyObject * args) {\n\tint timeout = 0; \n\tif (!PyArg_ParseTuple(args, \"|i:chunked_read\", &timeout)) {\n                return NULL;\n        }\n\tsize_t len = 0;\n        struct wsgi_request *wsgi_req = py_current_wsgi_req();\n        UWSGI_RELEASE_GIL\n        char *chunk = uwsgi_chunked_read(wsgi_req, &len, timeout, 0);\n        UWSGI_GET_GIL\n        if (!chunk) {\n                return PyErr_Format(PyExc_IOError, \"unable to receive chunked part\");\n        }\n\n        return PyString_FromStringAndSize(chunk, len);\n}\n\nPyObject *py_uwsgi_chunked_read_nb(PyObject * self, PyObject * args) {\n        size_t len = 0;\n        struct wsgi_request *wsgi_req = py_current_wsgi_req();\n        UWSGI_RELEASE_GIL\n        char *chunk = uwsgi_chunked_read(wsgi_req, &len, 0, 1);\n        UWSGI_GET_GIL\n        if (!chunk) {\n\t\tif (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINPROGRESS) {\n\t\t\tPy_INCREF(Py_None);\n\t\t\treturn Py_None;\n\t\t}\n                return PyErr_Format(PyExc_IOError, \"unable to receive chunked part\");\n        }\n\n        return PyString_FromStringAndSize(chunk, len);\n}\n\n\n\nPyObject *py_uwsgi_websocket_recv(PyObject * self, PyObject * args) {\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\tUWSGI_RELEASE_GIL\t\n\tstruct uwsgi_buffer *ub = uwsgi_websocket_recv(wsgi_req);\n\tUWSGI_GET_GIL\t\n\tif (!ub) {\n\t\treturn PyErr_Format(PyExc_IOError, \"unable to receive websocket message\");\n\t}\n\n\tPyObject *ret = PyString_FromStringAndSize(ub->buf, ub->pos);\n\tuwsgi_buffer_destroy(ub);\n\treturn ret;\n}\n\nPyObject *py_uwsgi_websocket_recv_nb(PyObject * self, PyObject * args) {\n        struct wsgi_request *wsgi_req = py_current_wsgi_req();\n        UWSGI_RELEASE_GIL\n        struct uwsgi_buffer *ub = uwsgi_websocket_recv_nb(wsgi_req);\n        UWSGI_GET_GIL\n        if (!ub) {\n                return PyErr_Format(PyExc_IOError, \"unable to receive websocket message\");\n        }\n\n        PyObject *ret = PyString_FromStringAndSize(ub->buf, ub->pos);\n        uwsgi_buffer_destroy(ub);\n        return ret;\n}\n\n\nPyObject *py_uwsgi_embedded_data(PyObject * self, PyObject * args) {\n\n\tchar *name;\n\tchar *symbol;\n\tvoid *sym_ptr_start = NULL;\n\tvoid *sym_ptr_end = NULL;\n\n\tif (!PyArg_ParseTuple(args, \"s:embedded_data\", &name)) {\n\t\treturn NULL;\n\t}\n\n\tsymbol = uwsgi_concat3(\"_binary_\", name, \"_start\");\n\tsym_ptr_start = dlsym(RTLD_DEFAULT, symbol);\n\tfree(symbol);\n\tif (!sym_ptr_start)\n\t\treturn PyErr_Format(PyExc_ValueError, \"unable to find symbol %s\", name);\n\n\n\n\tsymbol = uwsgi_concat3(\"_binary_\", name, \"_end\");\n\tsym_ptr_end = dlsym(RTLD_DEFAULT, symbol);\n\tfree(symbol);\n\tif (!sym_ptr_end)\n\t\treturn PyErr_Format(PyExc_ValueError, \"unable to find symbol %s\", name);\n\n\treturn PyString_FromStringAndSize(sym_ptr_start, sym_ptr_end - sym_ptr_start);\n\n}\n\nPyObject *py_uwsgi_setprocname(PyObject * self, PyObject * args) {\n\tchar *name = NULL;\n\n\tif (!PyArg_ParseTuple(args, \"s:setprocname\", &name)) {\n                return NULL;\n        }\n\n\tuwsgi_set_processname(name);\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_ready(PyObject * self, PyObject * args) {\n\n\tif (ushared->ready) {\n\t\tPy_INCREF(Py_True);\n\t\treturn Py_True;\n\t}\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_in_farm(PyObject * self, PyObject * args) {\n\n\tchar *farm_name = NULL;\n\tint i;\n\n\tif (!PyArg_ParseTuple(args, \"|s:in_farm\", &farm_name)) {\n                return NULL;\n        }\n\n\tif (uwsgi.muleid == 0) goto none;\n\n\tfor(i=0;i<uwsgi.farms_cnt;i++) {\n\t\tif (!farm_name) {\n\t\t\tif (uwsgi_farm_has_mule(&uwsgi.farms[i], uwsgi.muleid)) {\n\t\t\t\tPy_INCREF(Py_True);\n\t\t\t\treturn Py_True;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!strcmp(farm_name, uwsgi.farms[i].name)) {\n\t\t\t\tif (uwsgi_farm_has_mule(&uwsgi.farms[i], uwsgi.muleid)) {\n\t\t\t\t\tPy_INCREF(Py_True);\n\t\t\t\t\treturn Py_True;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nnone:\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n   \n}\n\nPyObject *py_uwsgi_farm_msg(PyObject * self, PyObject * args) {\n\n        char *message = NULL;\n        Py_ssize_t message_len = 0;\n\tchar *farm_name = NULL;\n        ssize_t len;\n\tint i;\n\n        if (!PyArg_ParseTuple(args, \"ss#:farm_msg\", &farm_name, &message, &message_len)) {\n                return NULL;\n        }\n\n\tfor(i=0;i<uwsgi.farms_cnt;i++) {\n\t\n\t\tif (!strcmp(farm_name, uwsgi.farms[i].name)) {\n\t\t\tUWSGI_RELEASE_GIL\n                \tlen = write(uwsgi.farms[i].queue_pipe[0], message, message_len);\n\t\t\tUWSGI_GET_GIL\n                \tif (len <= 0) {\n                        \tuwsgi_error(\"write()\");\n                \t}\n\t\t\tbreak;\n\t\t}\n\t\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n}\n\n\nPyObject *py_uwsgi_mule_msg(PyObject * self, PyObject * args) {\n\n\tchar *message = NULL;\n\tPy_ssize_t message_len = 0;\n\tPyObject *mule_obj = NULL;\n\tint fd = -1;\n\tint mule_id = -1;\n\tint resp = -1;\n\n\tif (!PyArg_ParseTuple(args, \"s#|O:mule_msg\", &message, &message_len, &mule_obj)) {\n                return NULL;\n        }\n\n\tif (uwsgi.mules_cnt < 1)\n\t\treturn PyErr_Format(PyExc_ValueError, \"no mule configured\");\n\n\tif (mule_obj == NULL) {\n\t\tUWSGI_RELEASE_GIL\n\t\tresp = mule_send_msg(uwsgi.shared->mule_queue_pipe[0], message, message_len);\n\t\tUWSGI_GET_GIL\n\t}\n\telse {\n\t\tif (PyString_Check(mule_obj)) {\n\t\t\tstruct uwsgi_farm *uf = get_farm_by_name(PyString_AsString(mule_obj));\n\t\t\tif (uf == NULL) {\n\t\t\t\treturn PyErr_Format(PyExc_ValueError, \"unknown farm\");\n\t\t\t}\n\t\t\tfd = uf->queue_pipe[0];\n\t\t}\n\t\telse if (PyInt_Check(mule_obj)) {\n\t\t\tmule_id = PyInt_AsLong(mule_obj);\n\t\t\tif (mule_id < 0 && mule_id > uwsgi.mules_cnt) {\n\t\t\t\treturn PyErr_Format(PyExc_ValueError, \"invalid mule number\");\n\t\t\t}\n\t\t\tif (mule_id == 0) {\n\t\t\t\tfd = uwsgi.shared->mule_queue_pipe[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfd = uwsgi.mules[mule_id-1].queue_pipe[0];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn PyErr_Format(PyExc_ValueError, \"invalid mule\");\n\t\t}\n\n\t\tif (fd > -1) {\n\t\t\tUWSGI_RELEASE_GIL\n\t\t\tresp = mule_send_msg(fd, message, message_len);\n\t\t\tUWSGI_GET_GIL\n\t\t}\n\t}\n\n\tif(!resp) {\n\t\tPy_INCREF(Py_True);\n\t\treturn Py_True;\n\t}\n\n\tPy_INCREF(Py_False);\n\treturn Py_False;\n\n}\n\nPyObject *py_uwsgi_mule_get_msg(PyObject * self, PyObject * args, PyObject *kwargs) {\n\n\tssize_t len = 0;\n\t// this buffer is configurable (default 64k)\n\tchar *message;\n\tPyObject *py_manage_signals = NULL;\n\tPyObject *py_manage_farms = NULL;\n\tsize_t buffer_size = 65536;\n\tint timeout = -1;\n\tint manage_signals = 1, manage_farms = 1;\n\n\tstatic char *kwlist[] = {\"signals\", \"farms\", \"buffer_size\", \"timeout\", NULL};\n\n\tif (uwsgi.muleid == 0) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"you can receive mule messages only in a mule !!!\");\n\t}\n\n\tif (!PyArg_ParseTupleAndKeywords(args, kwargs, \"|OOii:mule_get_msg\", kwlist, &py_manage_signals, &py_manage_farms, &buffer_size, &timeout)) {\n\t\treturn NULL;\n\t}\n\n\t// signals and farms are managed by default\n\tif (py_manage_signals == Py_None || py_manage_signals == Py_False) {\n\t\tmanage_signals = 0;\n\t}\n\n\tif (py_manage_farms == Py_None || py_manage_farms == Py_False) {\n\t\tmanage_farms = 0;\n\t}\n\n\tmessage = uwsgi_malloc(buffer_size);\n\t\n\tUWSGI_RELEASE_GIL;\n\tlen = uwsgi_mule_get_msg(manage_signals, manage_farms, message, buffer_size, timeout) ;\n\tUWSGI_GET_GIL;\n\n\tif (len < 0) {\n\t\tfree(message);\n\t\tPy_INCREF(Py_None);\n        \treturn Py_None;\n\t}\n\n\tPyObject *msg = PyString_FromStringAndSize(message, len);\n\tfree(message);\n\treturn msg;\n}\n\nPyObject *py_uwsgi_farm_get_msg(PyObject * self, PyObject * args) {\n\n        ssize_t len = 0;\n        // this buffer will be configurable\n        char message[65536];\n\tint i, count = 0, pos = 0, ret;\n\tstruct pollfd *farmpoll;\n\n        if (uwsgi.muleid == 0) {\n                return PyErr_Format(PyExc_ValueError, \"you can receive farm messages only in a mule !!!\");\n        }\n        UWSGI_RELEASE_GIL;\n\tfor(i=0;i<uwsgi.farms_cnt;i++) {\t\n\t\tif (uwsgi_farm_has_mule(&uwsgi.farms[i], uwsgi.muleid)) count++;\n\t}\n\tfarmpoll = uwsgi_malloc( sizeof(struct pollfd) * count);\n\tfor(i=0;i<uwsgi.farms_cnt;i++) {\n\t\tif (uwsgi_farm_has_mule(&uwsgi.farms[i], uwsgi.muleid)) {\n\t\t\tfarmpoll[pos].fd = uwsgi.farms[i].queue_pipe[1];\n\t\t\tfarmpoll[pos].events = POLLIN;\n\t\t\tpos++;\n\t\t}\n\t}\n\n\tret = poll(farmpoll, count, -1);\n\tif (ret <= 0) {\n        \tUWSGI_GET_GIL;\n\t\tuwsgi_error(\"poll()\");\n\t\tfree(farmpoll);\n\t\tPy_INCREF(Py_None);\n\t\treturn Py_None;\n\t}\n\n\tfor(i=0;i<count;i++) {\n\t\tif (farmpoll[i].revents & POLLIN) {\n        \t\tlen = read(farmpoll[i].fd, message, 65536);\n\t\t\tbreak;\n\t\t}\n\t}\n        UWSGI_GET_GIL;\n        if (len <= 0) {\n                uwsgi_error(\"read()\");\n\t\tfree(farmpoll);\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n\n\tfree(farmpoll);\n        return PyString_FromStringAndSize(message, len);\n}\n\n\nPyObject *py_uwsgi_extract(PyObject * self, PyObject * args) {\n\n        char *name;\n\tsize_t len;\n\tchar *buf;\n\n        if (!PyArg_ParseTuple(args, \"s:extract\", &name)) {\n                return NULL;\n        }\n\n\tbuf = uwsgi_open_and_read(name, &len, 0, NULL);\n\tif (buf && len > 0) {\n        \treturn PyString_FromStringAndSize(buf, len);\n\t}\n\tif (buf)\n\t\tfree(buf);\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n\n}\n\n\nPyObject *py_uwsgi_sharedarea_inc64(PyObject * self, PyObject * args) {\n\tint id;\n\tuint64_t pos = 0;\n\tint64_t value = 1;\n\n\tif (!PyArg_ParseTuple(args, \"iL|l:sharedarea_inc64\", &id, &pos, &value)) {\n\t\treturn NULL;\n\t}\n\n\tUWSGI_RELEASE_GIL\n\tint ret = uwsgi_sharedarea_inc64(id, pos, value);\n\tUWSGI_GET_GIL\n\t\n\tif (ret) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_inc64()\");\n\t}\n\n\tPy_INCREF(Py_None);\n        return Py_None;\n\n}\n\nPyObject *py_uwsgi_sharedarea_inc32(PyObject * self, PyObject * args) {\n        int id;\n        uint64_t pos = 0;\n        int32_t value = 1;\n\n        if (!PyArg_ParseTuple(args, \"iL|i:sharedarea_inc32\", &id, &pos, &value)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_inc32(id, pos, value);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_inc32()\");\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n}\n\nPyObject *py_uwsgi_sharedarea_dec64(PyObject * self, PyObject * args) {\n        int id;\n        uint64_t pos = 0;\n        int64_t value = 1;\n\n        if (!PyArg_ParseTuple(args, \"iL|l:sharedarea_dec64\", &id, &pos, &value)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_dec64(id, pos, value);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_dec64()\");\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n}\n\nPyObject *py_uwsgi_sharedarea_dec32(PyObject * self, PyObject * args) {\n        int id;\n        uint64_t pos = 0;\n        int32_t value = 1;\n\n        if (!PyArg_ParseTuple(args, \"iL|i:sharedarea_dec32\", &id, &pos, &value)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_dec32(id, pos, value);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_dec32()\");\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n}\n\nPyObject *py_uwsgi_sharedarea_write32(PyObject * self, PyObject * args) {\n        int id;\n        uint64_t pos = 0;\n        int32_t value = 0;\n\n        if (!PyArg_ParseTuple(args, \"iLI:sharedarea_write32\", &id, &pos, &value)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_write32(id, pos, &value);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_write32()\");\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n}\n\nPyObject *py_uwsgi_sharedarea_write16(PyObject * self, PyObject * args) {\n        int id;\n        uint64_t pos = 0;\n        int16_t value = 0;\n\n        if (!PyArg_ParseTuple(args, \"iLI:sharedarea_write16\", &id, &pos, &value)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_write16(id, pos, &value);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_write16()\");\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n}\n\n\n\nPyObject *py_uwsgi_sharedarea_write64(PyObject * self, PyObject * args) {\n\tint id;\n\tuint64_t pos = 0;\n\tint64_t value = 0;\n\n\tif (!PyArg_ParseTuple(args, \"iLL:sharedarea_write64\", &id, &pos, &value)) {\n\t\treturn NULL;\n\t}\n\n\tUWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_write64(id, pos, &value);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_write64()\");\n        }\n\n\tPy_INCREF(Py_None);\n        return Py_None;\n}\n\nPyObject *py_uwsgi_sharedarea_write(PyObject * self, PyObject * args) {\n\tint id;\n\tuint64_t pos = 0;\n\tchar *value;\n\tPy_ssize_t value_len = 0;\n\n\tif (!PyArg_ParseTuple(args, \"iLs#:sharedarea_write\", &id, &pos, &value, &value_len)) {\n\t\treturn NULL;\n\t}\n\n\tUWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_write(id, pos, value, value_len);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_write()\");\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n}\n\nPyObject *py_uwsgi_sharedarea_update(PyObject * self, PyObject * args) {\n        int id;\n\n        if (!PyArg_ParseTuple(args, \"i:sharedarea_update\", &id)) {\n                return NULL;\n        }\n\n        if (uwsgi_sharedarea_update(id)) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_update()\");\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n}\n\nPyObject *py_uwsgi_sharedarea_rlock(PyObject * self, PyObject * args) {\n        int id;\n\n        if (!PyArg_ParseTuple(args, \"i:sharedarea_rlock\", &id)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_rlock(id);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_rlock()\");\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n}\n\nPyObject *py_uwsgi_sharedarea_wlock(PyObject * self, PyObject * args) {\n        int id;\n\n        if (!PyArg_ParseTuple(args, \"i:sharedarea_wlock\", &id)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_wlock(id);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_wlock()\");\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n}\n\nPyObject *py_uwsgi_sharedarea_unlock(PyObject * self, PyObject * args) {\n        int id;\n\n        if (!PyArg_ParseTuple(args, \"i:sharedarea_unlock\", &id)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_unlock(id);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_unlock()\");\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n}\n\n\n\n\nPyObject *py_uwsgi_sharedarea_write8(PyObject * self, PyObject * args) {\n\tint id;\n\tuint64_t pos = 0;\n\tint8_t value;\n\n\tif (!PyArg_ParseTuple(args, \"iLb:sharedarea_write8\", &id, &pos, &value)) {\n\t\treturn NULL;\n\t}\n\n\tUWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_write8(id, pos, &value);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_write8()\");\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n}\n\nPyObject *py_uwsgi_sharedarea_read64(PyObject * self, PyObject * args) {\n\tint id;\n\tuint64_t pos = 0;\n\tint64_t value;\n\n\tif (!PyArg_ParseTuple(args, \"iL:sharedarea_read64\", &id, &pos)) {\n\t\treturn NULL;\n\t}\n\n\tUWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_read64(id, pos, &value);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_read64()\");\n        }\n\n\treturn PyLong_FromLongLong(value);\n\n}\n\nPyObject *py_uwsgi_sharedarea_read32(PyObject * self, PyObject * args) {\n        int id;\n        uint64_t pos = 0;\n        int32_t value;\n\n        if (!PyArg_ParseTuple(args, \"iL:sharedarea_read32\", &id, &pos)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_read32(id, pos, &value);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_read32()\");\n        }\n\n        return PyInt_FromLong(value);\n\n}\n\nPyObject *py_uwsgi_sharedarea_read16(PyObject * self, PyObject * args) {\n        int id;\n        uint64_t pos = 0;\n        int16_t value;\n\n        if (!PyArg_ParseTuple(args, \"iL:sharedarea_read16\", &id, &pos)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_read16(id, pos, &value);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_read16()\");\n        }\n\n        return PyInt_FromLong(value);\n\n}\n\n\nPyObject *py_uwsgi_sharedarea_read8(PyObject * self, PyObject * args) {\n\tint id;\n\tuint64_t pos = 0;\n\tint8_t byte;\n\n\tif (!PyArg_ParseTuple(args, \"iL:sharedarea_read8\", &id, &pos)) {\n\t\treturn NULL;\n\t}\n\n\tUWSGI_RELEASE_GIL\n        int ret = uwsgi_sharedarea_read8(id, pos, &byte);\n        UWSGI_GET_GIL\n\n        if (ret) {\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_read8()\");\n        }\n\n\treturn PyInt_FromLong(byte);\n}\n\nPyObject *py_uwsgi_sharedarea_read(PyObject * self, PyObject * args) {\n\tint id;\n\tuint64_t pos = 0;\n\tuint64_t len = 0;\n\n\tif (!PyArg_ParseTuple(args, \"iL|L:sharedarea_read\", &id, &pos, &len)) {\n\t\treturn NULL;\n\t}\n\n\tif (!len) {\n\t\tstruct uwsgi_sharedarea *sa = uwsgi_sharedarea_get_by_id(id, pos);\n                if (!sa) {\n\t\t\treturn PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_read()\");\t\n                }\n                len = (sa->max_pos+1)-pos;\n\t}\n\n\tPyObject *ret = PyString_FromStringAndSize(NULL, len);\n#ifdef PYTHREE\n\tchar *storage = PyBytes_AsString(ret);\n#else\n\tchar *storage = PyString_AS_STRING(ret);\n#endif\n\n\tUWSGI_RELEASE_GIL\n        int64_t rlen = uwsgi_sharedarea_read(id, pos, storage, len);\n        UWSGI_GET_GIL\n\n        if (rlen < 0) {\n\t\tPy_DECREF(ret);\n                return PyErr_Format(PyExc_ValueError, \"error calling uwsgi_sharedarea_read()\");\n        }\n\n\t// HACK: we are safe as rlen can only be lower or equal to len\n\tPy_SIZE(ret) = rlen;\n\n\treturn ret;\n}\n\n#if defined(PYTHREE) || defined(Py_TPFLAGS_HAVE_NEWBUFFER)\n#ifndef HAS_NOT_PyMemoryView_FromBuffer\nPyObject *py_uwsgi_sharedarea_memoryview(PyObject * self, PyObject * args) {\n        int id;\n\tif (!PyArg_ParseTuple(args, \"i:sharedarea_memoryview\", &id)) {\n                return NULL;\n        }\n\tstruct uwsgi_sharedarea *sa = uwsgi_sharedarea_get_by_id(id, 0);\n\tif (!sa) {\n        \treturn PyErr_Format(PyExc_ValueError, \"cannot get a memoryview object from sharedarea %d\", id);\n        }\n\tPy_buffer info;\n\tif (PyBuffer_FillInfo(&info, NULL, sa->area, sa->max_pos+1, 0, PyBUF_CONTIG) < 0)\n        \treturn PyErr_Format(PyExc_ValueError, \"cannot get a memoryview object from sharedarea %d\", id);\n\treturn PyMemoryView_FromBuffer(&info);\n}\n#endif\n\nPyObject *py_uwsgi_sharedarea_object(PyObject * self, PyObject * args) {\n\tint id;\n        if (!PyArg_ParseTuple(args, \"i:sharedarea_object\", &id)) {\n                return NULL;\n        }\n        struct uwsgi_sharedarea *sa = uwsgi_sharedarea_get_by_id(id, 0);\n        if (!sa) {\n                return PyErr_Format(PyExc_ValueError, \"cannot get an object from sharedarea %d\", id);\n        }\n\treturn (PyObject *) sa->obj;\n}\n#endif\n\nPyObject *py_uwsgi_spooler_freq(PyObject * self, PyObject * args) {\n\n\tif (!PyArg_ParseTuple(args, \"i\", &uwsgi.shared->spooler_frequency)) {\n\t\treturn NULL;\n\t}\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\n}\n\nPyObject *py_uwsgi_spooler_jobs(PyObject * self, PyObject * args) {\n\n\tDIR *sdir;\n\tstruct dirent *dp;\n\tchar *abs_path;\n\tstruct stat sf_lstat;\n\n\tPyObject *jobslist = PyList_New(0);\n\n\tstruct uwsgi_spooler *uspool = uwsgi.spoolers;\n\n\tsdir = opendir(uspool->dir);\n\n\tif (sdir) {\n\t\twhile ((dp = readdir(sdir)) != NULL) {\n\t\t\tif (!strncmp(\"uwsgi_spoolfile_on_\", dp->d_name, 19)) {\n\t\t\t\tabs_path = malloc(strlen(uspool->dir) + 1 + strlen(dp->d_name) + 1);\n\t\t\t\tif (!abs_path) {\n\t\t\t\t\tuwsgi_error(\"malloc()\");\n\t\t\t\t\tclosedir(sdir);\n\t\t\t\t\tgoto clear;\n\t\t\t\t}\n\n\t\t\t\tmemset(abs_path, 0, strlen(uspool->dir) + 1 + strlen(dp->d_name) + 1);\n\n\t\t\t\tmemcpy(abs_path, uspool->dir, strlen(uspool->dir));\n\t\t\t\tmemcpy(abs_path + strlen(uspool->dir), \"/\", 1);\n\t\t\t\tmemcpy(abs_path + strlen(uspool->dir) + 1, dp->d_name, strlen(dp->d_name));\n\n\n\t\t\t\tif (lstat(abs_path, &sf_lstat)) {\n\t\t\t\t\tfree(abs_path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!S_ISREG(sf_lstat.st_mode)) {\n\t\t\t\t\tfree(abs_path);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!access(abs_path, R_OK | W_OK)) {\n\t\t\t\t\tif (PyList_Append(jobslist, PyString_FromString(abs_path))) {\n\t\t\t\t\t\tPyErr_Print();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(abs_path);\n\t\t\t}\n\t\t}\n\t\tclosedir(sdir);\n\t}\n\n      clear:\n\treturn jobslist;\n\n}\n\n\nPyObject *py_uwsgi_send_spool(PyObject * self, PyObject * args, PyObject *kw) {\n\tPyObject *spool_dict, *spool_vars;\n\tPyObject *zero, *key, *val;\n\tuint16_t keysize, valsize;\n\tchar *body = NULL;\n\tsize_t body_len= 0;\n\n\tspool_dict = PyTuple_GetItem(args, 0);\n\n\tif (spool_dict) {\n\t\tif (!PyDict_Check(spool_dict)) {\n\t\t\treturn PyErr_Format(PyExc_ValueError, \"The argument of spooler callable must be a dictionary\");\n\t\t}\n\t}\n\telse {\n\t\t// clear the error\n\t\tPyErr_Clear();\n\t\tspool_dict = kw;\n\t}\n\n\tif (!spool_dict) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"The argument of spooler callable must be a dictionary\");\n\t}\n\n\tPyObject *pybody = uwsgi_py_dict_get(spool_dict, \"body\");\n\tif (pybody) {\n\t\tif (PyString_Check(pybody)) {\n\t\t\tbody = PyString_AsString(pybody);\n\t\t\tbody_len = PyString_Size(pybody);\n\t\t\tPy_INCREF(pybody);\n\t\t\tuwsgi_py_dict_del(spool_dict, \"body\");\n\t\t}\n\t}\n\n\tspool_vars = PyDict_Items(spool_dict);\n\tif (!spool_vars) {\n\t\tPy_INCREF(Py_None);\n\t\treturn Py_None;\n\t}\n\n\tint i;\n\tstruct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);\n\n\tfor (i = 0; i < PyList_Size(spool_vars); i++) {\n\t\tzero = PyList_GetItem(spool_vars, i);\n\t\tif (zero) {\n\t\t\tif (PyTuple_Check(zero)) {\n\t\t\t\tkey = PyTuple_GetItem(zero, 0);\n\t\t\t\tval = PyTuple_GetItem(zero, 1);\n\n\t\t\t\tif (PyString_Check(key)) {\n\n\t\t\t\t\tkeysize = PyString_Size(key);\n\t\t\n\t\t\t\t\tif (PyString_Check(val)) {\n\t\t\t\t\t\tvalsize = PyString_Size(val);\n\t\t\t\t\t\tif (uwsgi_buffer_append_keyval(ub, PyString_AsString(key), keysize, PyString_AsString(val), valsize)) {\n\t\t\t\t\t\t\tuwsgi_buffer_destroy(ub);\n\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n#ifdef PYTHREE\n\t\t\t\t\t\tPyObject *str = PyObject_Bytes(val);\n#else\n\t\t\t\t\t\tPyObject *str = PyObject_Str(val);\n#endif\n\t\t\t\t\t\tif (!str) {\n\t\t\t\t\t\t\tuwsgi_buffer_destroy(ub);\n\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (uwsgi_buffer_append_keyval(ub, PyString_AsString(key), keysize, PyString_AsString(str), PyString_Size(str))) {\n\t\t\t\t\t\t\tPy_DECREF(str);\n\t\t\t\t\t\t\tuwsgi_buffer_destroy(ub);\n\t\t\t\t\t\t\tgoto error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPy_DECREF(str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_buffer_destroy(ub);\n                                        goto error;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_buffer_destroy(ub);\n                                goto error;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tuwsgi_buffer_destroy(ub);\n                        goto error;\n\t\t}\n\t}\n\n\n\tUWSGI_RELEASE_GIL\n\n\t// current_wsgi_req can be NULL, in such a case a non-thread-safe counter will be used\n\tchar *filename = uwsgi_spool_request(NULL, ub->buf, ub->pos, body, body_len);\n\tuwsgi_buffer_destroy(ub);\n\n\tUWSGI_GET_GIL\n\n\n\tif (pybody) {\n\t\tif (PyString_Check(pybody)) {\n\t\t\tPy_DECREF(pybody);\n\t\t}\n\t}\n\t\n\tPy_DECREF(spool_vars);\n\n\tif (filename) {\n\t\tPyObject *ret = PyString_FromString(filename);\n\t\tfree(filename);\n\t\treturn ret;\n\t}\n\treturn PyErr_Format(PyExc_ValueError, \"unable to spool job\");\nerror:\n#ifdef PYTHREE\n\treturn PyErr_Format(PyExc_ValueError, \"spooler callable dictionary must contains only bytes\");\n#else\n\treturn PyErr_Format(PyExc_ValueError, \"spooler callable dictionary must contains only strings\");\n#endif\n}\n\nPyObject *py_uwsgi_spooler_pid(PyObject * self, PyObject * args) {\n\tstruct uwsgi_spooler *uspool = uwsgi.spoolers;\n\tif (!uwsgi.spoolers) return PyInt_FromLong(0);\n\treturn PyInt_FromLong(uspool->pid);\n}\n\nPyObject *py_uwsgi_spooler_pids(PyObject * self, PyObject * args) {\n    PyObject *ret = PyList_New(0);\n    struct uwsgi_spooler *uspool = uwsgi.spoolers;\n    while (uspool) {\n        PyList_Append(ret, PyInt_FromLong(uspool->pid));\n        uspool = uspool->next;\n    }\n    return ret;\n}\n\nPyObject *py_uwsgi_spooler_get_task(PyObject * self, PyObject * args) {\n\n\tchar spool_buf[0xffff];\n\tstruct uwsgi_header uh;\n\tchar *body = NULL;\n\tsize_t body_len = 0;\n\n\tint spool_fd;\n\n\tchar *task_path = NULL;\n\n\tstruct stat task_stat;\n\n\tif (!PyArg_ParseTuple(args, \"s:spooler_get_task\", &task_path)) {\n\t\treturn NULL;\n\t}\n\n\tif (lstat(task_path, &task_stat)) {\n\t\tPy_INCREF(Py_None);\n\t\treturn Py_None;\n\t}\n\n\tif (access(task_path, R_OK | W_OK)) {\n\t\tPy_INCREF(Py_None);\n\t\treturn Py_None;\n\t}\n\n\tspool_fd = open(task_path, O_RDWR);\n\n\tif (spool_fd < 0) {\n\t\tPy_INCREF(Py_None);\n\t\treturn Py_None;\n\t}\n\n\tif (uwsgi_spooler_read_header(task_path, spool_fd, &uh) ||\n\t\tuwsgi_spooler_read_content(spool_fd, spool_buf, &body, &body_len, &uh, &task_stat)) {\n\t\tPy_INCREF(Py_None);\n\t\treturn Py_None;\n\t}\n\n\tuwsgi_protected_close(spool_fd);\n\n\tPyObject *spool_dict = uwsgi_python_dict_from_spooler_content(task_path, spool_buf, uh.pktsize, body, body_len);\n\n\tif (!spool_dict) {\n\t\tPy_INCREF(Py_None);\n\t\treturn Py_None;\n\t}\n\n\treturn spool_dict;\n}\n\n\nPyObject *py_uwsgi_connect(PyObject * self, PyObject * args) {\n\n\tchar *socket_name = NULL;\n\tint timeout = 0;\n\tif (!PyArg_ParseTuple(args, \"s|i:connect\", &socket_name, &timeout)) {\n\t\treturn NULL;\n\t}\n\n\treturn PyInt_FromLong(uwsgi_connect(socket_name, timeout, 0));\n}\n\nPyObject *py_uwsgi_async_connect(PyObject * self, PyObject * args) {\n\n\tchar *socket_name = NULL;\n\tif (!PyArg_ParseTuple(args, \"s:async_connect\", &socket_name)) {\n\t\treturn NULL;\n\t}\n\n\treturn PyInt_FromLong(uwsgi_connect(socket_name, 0, 1));\n}\n\n/* uWSGI masterpid */\nPyObject *py_uwsgi_masterpid(PyObject * self, PyObject * args) {\n\tif (uwsgi.master_process) {\n\t\treturn PyInt_FromLong(uwsgi.workers[0].pid);\n\t}\n\treturn PyInt_FromLong(0);\n}\n\n\t/* uWSGI total_requests */\nPyObject *py_uwsgi_total_requests(PyObject * self, PyObject * args) {\n\treturn PyLong_FromUnsignedLongLong(uwsgi.workers[0].requests);\n}\n\n\t/* uWSGI workers */\nPyObject *py_uwsgi_workers(PyObject * self, PyObject * args) {\n\n\tPyObject *worker_dict, *apps_dict, *apps_tuple, *zero;\n\tint i, j;\n\tstruct uwsgi_app *ua;\n\n\tfor (i = 0; i < uwsgi.numproc; i++) {\n\t\tworker_dict = PyTuple_GetItem(up.workers_tuple, i);\n\t\tif (!worker_dict) {\n\t\t\tgoto clear;\n\t\t}\n\n\t\tapps_tuple = PyDict_GetItemString(worker_dict, \"apps\");\n\n\t\tPyDict_Clear(worker_dict);\n\n\t\tzero = PyInt_FromLong(uwsgi.workers[i + 1].id);\n\t\tif (PyDict_SetItemString(worker_dict, \"id\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\n\t\tzero = PyInt_FromLong(uwsgi.workers[i + 1].pid);\n\t\tif (PyDict_SetItemString(worker_dict, \"pid\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tzero = PyLong_FromUnsignedLongLong(uwsgi.workers[i + 1].requests);\n\t\tif (PyDict_SetItemString(worker_dict, \"requests\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tzero = PyLong_FromUnsignedLongLong(uwsgi.workers[i + 1].delta_requests);\n\t\tif (PyDict_SetItemString(worker_dict, \"delta_requests\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tzero = PyLong_FromUnsignedLongLong(uwsgi.workers[i + 1].signals);\n\t\tif (PyDict_SetItemString(worker_dict, \"signals\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tzero = PyLong_FromUnsignedLongLong(uwsgi_worker_exceptions(i+1));\n\t\tif (PyDict_SetItemString(worker_dict, \"exceptions\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tif (uwsgi.workers[i + 1].cheaped) {\n\t\t\tzero = PyString_FromString(\"cheap\");\n\t\t}\n\t\telse if (uwsgi.workers[i + 1].suspended && !uwsgi_worker_is_busy(i+1)) {\n\t\t\tzero = PyString_FromString(\"pause\");\n\t\t}\n\t\telse {\n\t\t\tif (uwsgi.workers[i + 1].sig) {\n\t\t\t\tzero = PyString_FromFormat(\"sig%d\",uwsgi.workers[i + 1].signum);\n\t\t\t}\n\t\t\telse if (uwsgi_worker_is_busy(i+1)) {\n\t\t\t\tzero = PyString_FromString(\"busy\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tzero = PyString_FromString(\"idle\");\n\t\t\t}\n\t\t}\n\t\tif (PyDict_SetItemString(worker_dict, \"status\", zero)) {\n                        goto clear;\n                }\n\n\t\tPy_DECREF(zero);\n\n\t\tzero = PyLong_FromUnsignedLongLong(uwsgi.workers[i + 1].rss_size);\n\t\tif (PyDict_SetItemString(worker_dict, \"rss\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tzero = PyLong_FromUnsignedLongLong(uwsgi.workers[i + 1].vsz_size);\n\t\tif (PyDict_SetItemString(worker_dict, \"vsz\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tzero = PyLong_FromUnsignedLongLong(uwsgi.workers[i + 1].running_time);\n\t\tif (PyDict_SetItemString(worker_dict, \"running_time\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tzero = PyLong_FromLong(uwsgi.workers[i + 1].last_spawn);\n\t\tif (PyDict_SetItemString(worker_dict, \"last_spawn\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tzero = PyLong_FromUnsignedLongLong(uwsgi.workers[i + 1].respawn_count-1);\n\t\tif (PyDict_SetItemString(worker_dict, \"respawn_count\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tzero = PyLong_FromUnsignedLongLong(uwsgi.workers[i + 1].tx);\n\t\tif (PyDict_SetItemString(worker_dict, \"tx\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tzero = PyLong_FromUnsignedLongLong(uwsgi.workers[i + 1].avg_response_time);\n\t\tif (PyDict_SetItemString(worker_dict, \"avg_rt\", zero)) {\n\t\t\tgoto clear;\n\t\t}\n\t\tPy_DECREF(zero);\n\n\t\tapps_tuple = PyTuple_New(uwsgi.workers[i+1].apps_cnt);\n\n\t\tfor(j=0;j<uwsgi.workers[i+1].apps_cnt;j++) {\n\t\t\tapps_dict = PyDict_New();\n\t\t\tua = &uwsgi.workers[i+1].apps[j];\n\n\t\t\tzero = PyInt_FromLong(j);\n\t\t\tPyDict_SetItemString(apps_dict, \"id\", zero);\n\t\t\tPy_DECREF(zero);\n\n\t\t\tzero = PyInt_FromLong(ua->modifier1);\n\t\t\tPyDict_SetItemString(apps_dict, \"modifier1\", zero);\n\t\t\tPy_DECREF(zero);\n\n\t\t\tzero = PyString_FromStringAndSize(ua->mountpoint, ua->mountpoint_len);\n\t\t\tPyDict_SetItemString(apps_dict, \"mountpoint\", zero);\n\t\t\tPy_DECREF(zero);\n\n\t\t\tzero = PyInt_FromLong((long) ua->startup_time);\n\t\t\tPyDict_SetItemString(apps_dict, \"startup_time\", zero);\n\t\t\tPy_DECREF(zero);\n\n\t\t\tzero = PyInt_FromLong((long)ua->interpreter);\n\t\t\tPyDict_SetItemString(apps_dict, \"interpreter\", zero);\n\t\t\tPy_DECREF(zero);\n\n\t\t\tzero = PyInt_FromLong((long)ua->callable);\n\t\t\tPyDict_SetItemString(apps_dict, \"callable\", zero);\n\t\t\tPy_DECREF(zero);\n\n\t\t\tzero = PyLong_FromUnsignedLongLong(ua->requests);\n\t\t\tPyDict_SetItemString(apps_dict, \"requests\", zero);\n\t\t\tPy_DECREF(zero);\n\n\t\t\tzero = PyLong_FromUnsignedLongLong(ua->exceptions);\n\t\t\tPyDict_SetItemString(apps_dict, \"exceptions\", zero);\n\t\t\tPy_DECREF(zero);\n\n\t\t\tif (*ua->chdir) {\n\t\t\t\tzero = PyString_FromString(ua->chdir);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tzero = PyString_FromString(\"\");\n\t\t\t}\n\t\t\tPyDict_SetItemString(apps_dict, \"chdir\", zero);\n\t\t\tPy_DECREF(zero);\n\n\t\t\tPyTuple_SetItem(apps_tuple, j, apps_dict);\n\t\t}\n\t\n\n\t\tPyDict_SetItemString(worker_dict, \"apps\", apps_tuple);\n\n\t}\n\n\n\tPy_INCREF(up.workers_tuple);\n\treturn up.workers_tuple;\n\n      clear:\n\tPyErr_Print();\n\tPyErr_Clear();\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n\n}\n\n\n\t/* uWSGI reload */\nPyObject *py_uwsgi_reload(PyObject * self, PyObject * args) {\n\n\tif (kill(uwsgi.workers[0].pid, SIGHUP)) {\n\t\tuwsgi_error(\"kill()\");\n\t\tPy_INCREF(Py_None);\n\t\treturn Py_None;\n\t}\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n}\n\n/* uWSGI stop */\nPyObject *py_uwsgi_stop(PyObject * self, PyObject * args) {\n\n        if (kill(uwsgi.workers[0].pid, SIGQUIT)) {\n                uwsgi_error(\"kill()\");\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n\n        Py_INCREF(Py_True);\n        return Py_True;\n}\n\nPyObject *py_uwsgi_request_id(PyObject * self, PyObject * args) {\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\treturn PyLong_FromUnsignedLongLong(uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].requests);\n}\n\nPyObject *py_uwsgi_worker_id(PyObject * self, PyObject * args) {\n\treturn PyInt_FromLong(uwsgi.mywid);\n}\n\nPyObject *py_uwsgi_mule_id(PyObject * self, PyObject * args) {\n\treturn PyInt_FromLong(uwsgi.muleid);\n}\n\nPyObject *py_uwsgi_logsize(PyObject * self, PyObject * args) {\n\treturn PyLong_FromUnsignedLongLong(uwsgi.shared->logsize);\n}\n\nPyObject *py_uwsgi_mem(PyObject * self, PyObject * args) {\n\n\tuint64_t rss=0, vsz = 0;\n\tPyObject *ml = PyTuple_New(2);\n\n\tget_memusage(&rss, &vsz);\n\n\tPyTuple_SetItem(ml, 0, PyLong_FromUnsignedLongLong(rss));\n\tPyTuple_SetItem(ml, 1, PyLong_FromUnsignedLongLong(vsz));\n\n\treturn ml;\n\n}\n\nPyObject *py_uwsgi_cl(PyObject * self, PyObject * args) {\n\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n\treturn PyLong_FromUnsignedLongLong(wsgi_req->post_cl);\n\n}\n\nPyObject *py_uwsgi_disconnect(PyObject * self, PyObject * args) {\n\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n\tuwsgi_disconnect(wsgi_req);\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_ready_fd(PyObject * self, PyObject * args) {\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\treturn PyInt_FromLong(uwsgi_ready_fd(wsgi_req));\n}\n\nPyObject *py_uwsgi_accepting(PyObject * self, PyObject * args) {\n\tint accepting = 1;\n\tif (!PyArg_ParseTuple(args, \"|i\", &accepting)) {\n\t\treturn NULL;\n\t}\n\tuwsgi.workers[uwsgi.mywid].accepting = !!accepting;\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_parse_file(PyObject * self, PyObject * args) {\n\n\tchar *filename;\n\tint fd;\n\tssize_t len;\n\tchar *buffer, *ptrbuf, *bufferend, *keybuf;\n\tuint16_t strsize = 0, keysize = 0;\n\n\tstruct uwsgi_header uh;\n\tPyObject *zero;\n\n\tif (!PyArg_ParseTuple(args, \"s:parsefile\", &filename)) {\n\t\treturn NULL;\n\t}\n\n\tUWSGI_RELEASE_GIL\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(filename);\n\t\tUWSGI_GET_GIL\n\t\tgoto clear;\n\t}\n\n\tlen = read(fd, &uh, 4);\n\tif (len != 4) {\n\t\tuwsgi_error(\"read()\");\n\t\tUWSGI_GET_GIL\n\t\tgoto clear2;\n\t}\n\n\tbuffer = malloc(uh.pktsize);\n\tif (!buffer) {\n\t\tuwsgi_error(\"malloc()\");\n\t\tUWSGI_GET_GIL\n\t\tgoto clear2;\n\t}\n\tlen = read(fd, buffer, uh.pktsize);\n\tif (len != uh.pktsize) {\n\t\tuwsgi_error(\"read()\");\n\t\tfree(buffer);\n\t\tUWSGI_GET_GIL\n\t\tgoto clear2;\n\t}\n\n\tUWSGI_GET_GIL\n\n\tptrbuf = buffer;\n\tbufferend = ptrbuf + uh.pktsize;\n\n\tif (!uh.modifier1 || uh.modifier1 == UWSGI_MODIFIER_SPOOL_REQUEST) {\n\t\tzero = PyDict_New();\n\n\t\twhile (ptrbuf < bufferend) {\n\t\t\tif (ptrbuf + 2 < bufferend) {\n\t\t\t\tmemcpy(&strsize, ptrbuf, 2);\n#ifdef __BIG_ENDIAN__\n\t\t\t\tstrsize = uwsgi_swap16(strsize);\n#endif\n\t\t\t\t/* key cannot be null */\n\t\t\t\tif (!strsize) {\n\t\t\t\t\tuwsgi_log(\"uwsgi key cannot be null.\\n\");\n\t\t\t\t\tgoto clear3;\n\t\t\t\t}\n\n\t\t\t\tptrbuf += 2;\n\t\t\t\tif (ptrbuf + strsize < bufferend) {\n\t\t\t\t\t// var key\n\t\t\t\t\tkeybuf = ptrbuf;\n\t\t\t\t\tkeysize = strsize;\n\t\t\t\t\tptrbuf += strsize;\n\t\t\t\t\t// value can be null (even at the end) so use <=\n\t\t\t\t\tif (ptrbuf + 2 <= bufferend) {\n\t\t\t\t\t\tmemcpy(&strsize, ptrbuf, 2);\n#ifdef __BIG_ENDIAN__\n\t\t\t\t\t\tstrsize = uwsgi_swap16(strsize);\n#endif\n\t\t\t\t\t\tptrbuf += 2;\n\t\t\t\t\t\tif (ptrbuf + strsize <= bufferend) {\n\t\t\t\t\t\t\tPyDict_SetItem(zero, PyString_FromStringAndSize(keybuf, keysize), PyString_FromStringAndSize(ptrbuf, strsize));\n\t\t\t\t\t\t\tptrbuf += strsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tgoto clear3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tgoto clear3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgoto clear3;\n\t\t\t}\n\t\t}\n\n\t\tclose(fd);\n\t\tfree(buffer);\n\t\treturn zero;\n\n\t}\n\n\tfree(buffer);\n\tgoto clear2;\n\n      clear3:\n\tPy_DECREF(zero);\n\tfree(buffer);\n      clear2:\n\tclose(fd);\n      clear:\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n\n}\n\nstatic PyMethodDef uwsgi_spooler_methods[] = {\n#ifdef PYTHREE\n\t{\"send_to_spooler\", (PyCFunction)(void *)py_uwsgi_send_spool, METH_VARARGS|METH_KEYWORDS, \"\"},\n\t{\"spool\", (PyCFunction)(void *)py_uwsgi_send_spool, METH_VARARGS|METH_KEYWORDS, \"\"},\n#else\n\t{\"send_to_spooler\", (PyCFunction)(void *)py_uwsgi_send_spool, METH_KEYWORDS, \"\"},\n\t{\"spool\", (PyCFunction)(void *)py_uwsgi_send_spool, METH_KEYWORDS, \"\"},\n#endif\n\t{\"set_spooler_frequency\", py_uwsgi_spooler_freq, METH_VARARGS, \"\"},\n\t{\"spooler_jobs\", py_uwsgi_spooler_jobs, METH_VARARGS, \"\"},\n\t{\"spooler_pid\", py_uwsgi_spooler_pid, METH_VARARGS, \"\"},\n\t{\"spooler_pids\", py_uwsgi_spooler_pids, METH_VARARGS, \"\"},\n\n\t{\"spooler_get_task\", py_uwsgi_spooler_get_task, METH_VARARGS, \"\"},\n\t{NULL, NULL},\n};\n\n\nPyObject *py_uwsgi_suspend(PyObject * self, PyObject * args) {\n\n\tstruct wsgi_request *wsgi_req = py_current_wsgi_req();\n\n\tif (uwsgi.schedule_to_main) uwsgi.schedule_to_main(wsgi_req);\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\n}\n\nstatic PyMethodDef uwsgi_advanced_methods[] = {\n\t{\"reload\", py_uwsgi_reload, METH_VARARGS, \"\"},\n\t{\"stop\", py_uwsgi_stop, METH_VARARGS, \"\"},\n\t{\"workers\", py_uwsgi_workers, METH_VARARGS, \"\"},\n\t{\"masterpid\", py_uwsgi_masterpid, METH_VARARGS, \"\"},\n\t{\"total_requests\", py_uwsgi_total_requests, METH_VARARGS, \"\"},\n\t{\"request_id\", py_uwsgi_request_id, METH_VARARGS, \"\"},\n\t{\"worker_id\", py_uwsgi_worker_id, METH_VARARGS, \"\"},\n\t{\"mule_id\", py_uwsgi_mule_id, METH_VARARGS, \"\"},\n\t{\"log\", py_uwsgi_log, METH_VARARGS, \"\"},\n\t{\"log_this_request\", py_uwsgi_log_this, METH_VARARGS, \"\"},\n\t{\"set_logvar\", py_uwsgi_set_logvar, METH_VARARGS, \"\"},\n\t{\"get_logvar\", py_uwsgi_get_logvar, METH_VARARGS, \"\"},\n\t{\"alarm\", py_uwsgi_alarm, METH_VARARGS, \"\"},\n\t{\"disconnect\", py_uwsgi_disconnect, METH_VARARGS, \"\"},\n\t{\"lock\", py_uwsgi_lock, METH_VARARGS, \"\"},\n\t{\"is_locked\", py_uwsgi_is_locked, METH_VARARGS, \"\"},\n\t{\"unlock\", py_uwsgi_unlock, METH_VARARGS, \"\"},\n\t{\"cl\", py_uwsgi_cl, METH_VARARGS, \"\"},\n\t{\"accepting\", py_uwsgi_accepting, METH_VARARGS, \"\"},\n\n\t{\"setprocname\", py_uwsgi_setprocname, METH_VARARGS, \"\"},\n\n\t{\"listen_queue\", py_uwsgi_listen_queue, METH_VARARGS, \"\"},\n\n\t{\"register_signal\", py_uwsgi_register_signal, METH_VARARGS, \"\"},\n\t{\"signal\", py_uwsgi_signal, METH_VARARGS, \"\"},\n\t{\"signal_wait\", py_uwsgi_signal_wait, METH_VARARGS, \"\"},\n\t{\"signal_registered\", py_uwsgi_signal_registered, METH_VARARGS, \"\"},\n\t{\"signal_received\", py_uwsgi_signal_received, METH_VARARGS, \"\"},\n\t{\"add_file_monitor\", py_uwsgi_add_file_monitor, METH_VARARGS, \"\"},\n\t{\"add_timer\", py_uwsgi_add_timer, METH_VARARGS, \"\"},\n\t{\"add_rb_timer\", py_uwsgi_add_rb_timer, METH_VARARGS, \"\"},\n\t{\"add_cron\", py_uwsgi_add_cron, METH_VARARGS, \"\"},\n\n#ifdef UWSGI_ROUTING\n\t{\"route\", py_uwsgi_route, METH_VARARGS, \"\"},\n#endif\n\n\t{\"register_rpc\", py_uwsgi_register_rpc, METH_VARARGS, \"\"},\n\t{\"rpc\", py_uwsgi_rpc, METH_VARARGS, \"\"},\n\t{\"rpc_list\", py_uwsgi_rpc_list, METH_VARARGS, \"\"},\n\t{\"call\", py_uwsgi_call, METH_VARARGS, \"\"},\n\t{\"sendfile\", py_uwsgi_advanced_sendfile, METH_VARARGS, \"\"},\n\t{\"offload\", py_uwsgi_offload, METH_VARARGS, \"\"},\n\t{\"set_warning_message\", py_uwsgi_warning, METH_VARARGS, \"\"},\n\t{\"mem\", py_uwsgi_mem, METH_VARARGS, \"\"},\n\t{\"logsize\", py_uwsgi_logsize, METH_VARARGS, \"\"},\n#ifdef UWSGI_SSL\n\t{\"i_am_the_lord\", py_uwsgi_i_am_the_lord, METH_VARARGS, \"\"},\n\t{\"lord_scroll\", py_uwsgi_lord_scroll, METH_VARARGS, \"\"},\n\t{\"scrolls\", py_uwsgi_scrolls, METH_VARARGS, \"\"},\n#endif\n\t{\"async_sleep\", py_uwsgi_async_sleep, METH_VARARGS, \"\"},\n\t{\"async_connect\", py_uwsgi_async_connect, METH_VARARGS, \"\"},\n\n\t{\"green_schedule\", py_uwsgi_suspend, METH_VARARGS, \"\"},\n\t{\"suspend\", py_uwsgi_suspend, METH_VARARGS, \"\"},\n\t{\"wait_fd_read\", py_eventfd_read, METH_VARARGS, \"\"},\n\t{\"wait_fd_write\", py_eventfd_write, METH_VARARGS, \"\"},\n\n\t{\"connect\", py_uwsgi_connect, METH_VARARGS, \"\"},\n\t{\"connection_fd\", py_uwsgi_connection_fd, METH_VARARGS, \"\"},\n\t{\"is_connected\", py_uwsgi_is_connected, METH_VARARGS, \"\"},\n\t{\"send\", py_uwsgi_send, METH_VARARGS, \"\"},\n\t{\"recv\", py_uwsgi_recv, METH_VARARGS, \"\"},\n\t{\"close\", py_uwsgi_close, METH_VARARGS, \"\"},\n\t{\"i_am_the_spooler\", py_uwsgi_i_am_the_spooler, METH_VARARGS, \"\"},\n\n\t{\"parsefile\", py_uwsgi_parse_file, METH_VARARGS, \"\"},\n\t{\"embedded_data\", py_uwsgi_embedded_data, METH_VARARGS, \"\"},\n\t{\"extract\", py_uwsgi_extract, METH_VARARGS, \"\"},\n\n\t{\"mule_msg\", py_uwsgi_mule_msg, METH_VARARGS, \"\"},\n\t{\"farm_msg\", py_uwsgi_farm_msg, METH_VARARGS, \"\"},\n\t{\"mule_get_msg\", (PyCFunction)(void *)py_uwsgi_mule_get_msg, METH_VARARGS|METH_KEYWORDS, \"\"},\n\t{\"farm_get_msg\", py_uwsgi_farm_get_msg, METH_VARARGS, \"\"},\n\t{\"in_farm\", py_uwsgi_in_farm, METH_VARARGS, \"\"},\n\n\t{\"ready\", py_uwsgi_ready, METH_VARARGS, \"\"},\n\n\t{\"set_user_harakiri\", py_uwsgi_set_user_harakiri, METH_VARARGS, \"\"},\n\n\t{\"websocket_recv\", py_uwsgi_websocket_recv, METH_VARARGS, \"\"},\n\t{\"websocket_recv_nb\", py_uwsgi_websocket_recv_nb, METH_VARARGS, \"\"},\n\t{\"websocket_send\", py_uwsgi_websocket_send, METH_VARARGS, \"\"},\n\t{\"websocket_send_binary\", py_uwsgi_websocket_send_binary, METH_VARARGS, \"\"},\n\t{\"websocket_handshake\", py_uwsgi_websocket_handshake, METH_VARARGS, \"\"},\n\n\t{\"chunked_read\", py_uwsgi_chunked_read, METH_VARARGS, \"\"},\n\t{\"chunked_read_nb\", py_uwsgi_chunked_read_nb, METH_VARARGS, \"\"},\n\n\t{\"ready_fd\", py_uwsgi_ready_fd, METH_VARARGS, \"\"},\n\n\t{\"add_var\", py_uwsgi_add_var, METH_VARARGS, \"\"},\n\n\t{\"micros\", py_uwsgi_micros, METH_VARARGS, \"\"},\n\n\t{NULL, NULL},\n};\n\n\nstatic PyMethodDef uwsgi_sa_methods[] = {\n\t{\"sharedarea_read\", py_uwsgi_sharedarea_read, METH_VARARGS, \"\"},\n\t{\"sharedarea_write\", py_uwsgi_sharedarea_write, METH_VARARGS, \"\"},\n\t{\"sharedarea_readbyte\", py_uwsgi_sharedarea_read8, METH_VARARGS, \"\"},\n\t{\"sharedarea_writebyte\", py_uwsgi_sharedarea_write8, METH_VARARGS, \"\"},\n\t{\"sharedarea_read8\", py_uwsgi_sharedarea_read8, METH_VARARGS, \"\"},\n\t{\"sharedarea_write8\", py_uwsgi_sharedarea_write8, METH_VARARGS, \"\"},\n\t{\"sharedarea_readlong\", py_uwsgi_sharedarea_read64, METH_VARARGS, \"\"},\n\t{\"sharedarea_writelong\", py_uwsgi_sharedarea_write64, METH_VARARGS, \"\"},\n\t{\"sharedarea_read64\", py_uwsgi_sharedarea_read64, METH_VARARGS, \"\"},\n\t{\"sharedarea_write64\", py_uwsgi_sharedarea_write64, METH_VARARGS, \"\"},\n\t{\"sharedarea_read32\", py_uwsgi_sharedarea_read32, METH_VARARGS, \"\"},\n\t{\"sharedarea_write32\", py_uwsgi_sharedarea_write32, METH_VARARGS, \"\"},\n\t{\"sharedarea_read16\", py_uwsgi_sharedarea_read16, METH_VARARGS, \"\"},\n\t{\"sharedarea_write16\", py_uwsgi_sharedarea_write16, METH_VARARGS, \"\"},\n\t{\"sharedarea_inclong\", py_uwsgi_sharedarea_inc64, METH_VARARGS, \"\"},\n\t{\"sharedarea_inc64\", py_uwsgi_sharedarea_inc64, METH_VARARGS, \"\"},\n\t{\"sharedarea_inc32\", py_uwsgi_sharedarea_inc32, METH_VARARGS, \"\"},\n\t{\"sharedarea_dec64\", py_uwsgi_sharedarea_dec64, METH_VARARGS, \"\"},\n\t{\"sharedarea_dec32\", py_uwsgi_sharedarea_dec32, METH_VARARGS, \"\"},\n\t{\"sharedarea_rlock\", py_uwsgi_sharedarea_rlock, METH_VARARGS, \"\"},\n\t{\"sharedarea_wlock\", py_uwsgi_sharedarea_wlock, METH_VARARGS, \"\"},\n\t{\"sharedarea_unlock\", py_uwsgi_sharedarea_unlock, METH_VARARGS, \"\"},\n#if defined(PYTHREE) || defined(Py_TPFLAGS_HAVE_NEWBUFFER)\n#ifndef HAS_NOT_PyMemoryView_FromBuffer\n\t{\"sharedarea_memoryview\", py_uwsgi_sharedarea_memoryview, METH_VARARGS, \"\"},\n#endif\n\t{\"sharedarea_object\", py_uwsgi_sharedarea_object, METH_VARARGS, \"\"},\n#endif\n\t{NULL, NULL},\n};\n\nPyObject *py_uwsgi_cache_clear(PyObject * self, PyObject * args) {\n\n        char *cache = NULL;\n\n        if (!PyArg_ParseTuple(args, \"|s:cache_clear\", &cache)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        if (!uwsgi_cache_magic_clear(cache)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_True);\n                return Py_True;\n        }\n        UWSGI_GET_GIL\n\n        Py_INCREF(Py_None);\n        return Py_None;\n}\n\n\nPyObject *py_uwsgi_cache_del(PyObject * self, PyObject * args) {\n\n\tchar *key;\n        Py_ssize_t keylen = 0;\n        char *cache = NULL;\n\n        if (!PyArg_ParseTuple(args, \"s#|s:cache_del\", &key, &keylen, &cache)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        if (!uwsgi_cache_magic_del(key, keylen, cache)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_True);\n                return Py_True;\n        }\n        UWSGI_GET_GIL\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n\n}\n\n\nPyObject *py_uwsgi_cache_set(PyObject * self, PyObject * args) {\n\n\tchar *key;\n\tchar *value;\n\tPy_ssize_t vallen = 0;\n\tPy_ssize_t keylen = 0;\n\tchar *remote = NULL;\n\n\tuint64_t expires = 0;\n\n\tif (!PyArg_ParseTuple(args, \"s#s#|ls:cache_set\", &key, &keylen, &value, &vallen, &expires, &remote)) {\n\t\treturn NULL;\n\t}\n\n\tUWSGI_RELEASE_GIL\n\tif (uwsgi_cache_magic_set(key, keylen, value, vallen, expires, 0, remote)) {\n\t\tUWSGI_GET_GIL\n\t\tPy_INCREF(Py_None);\n\t\treturn Py_None;\n\t}\n\tUWSGI_GET_GIL\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\n}\n\nPyObject *py_uwsgi_cache_update(PyObject * self, PyObject * args) {\n\n\tchar *key;\n        char *value;\n        Py_ssize_t vallen = 0;\n        Py_ssize_t keylen = 0;\n        char *remote = NULL;\n\n        uint64_t expires = 0;\n\n        if (!PyArg_ParseTuple(args, \"s#s#|ls:cache_update\", &key, &keylen, &value, &vallen, &expires, &remote)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_cache_magic_set(key, keylen, value, vallen, expires, UWSGI_CACHE_FLAG_UPDATE, remote)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\nPyObject *py_uwsgi_cache_inc(PyObject * self, PyObject * args) {\n\n        char *key;\n        Py_ssize_t keylen = 0;\n        char *remote = NULL;\n\tint64_t value = 1;\n        uint64_t expires = 0;\n\n        if (!PyArg_ParseTuple(args, \"s#|lls:cache_inc\", &key, &keylen, &value, &expires, &remote)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_cache_magic_set(key, keylen, (char *) &value, 8, expires, UWSGI_CACHE_FLAG_UPDATE|UWSGI_CACHE_FLAG_MATH|UWSGI_CACHE_FLAG_FIXEXPIRE|UWSGI_CACHE_FLAG_INC, remote)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\nPyObject *py_uwsgi_cache_dec(PyObject * self, PyObject * args) {\n\n        char *key;\n        Py_ssize_t keylen = 0;\n        char *remote = NULL;\n        int64_t value = 1;\n        uint64_t expires = 0;\n\n        if (!PyArg_ParseTuple(args, \"s#|lls:cache_dec\", &key, &keylen, &value, &expires, &remote)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_cache_magic_set(key, keylen, (char *) &value, 8, expires, UWSGI_CACHE_FLAG_UPDATE|UWSGI_CACHE_FLAG_MATH|UWSGI_CACHE_FLAG_FIXEXPIRE|UWSGI_CACHE_FLAG_DEC, remote)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\nPyObject *py_uwsgi_cache_mul(PyObject * self, PyObject * args) {\n\n        char *key;\n        Py_ssize_t keylen = 0;\n        char *remote = NULL;\n        int64_t value = 2;\n        uint64_t expires = 0;\n\n        if (!PyArg_ParseTuple(args, \"s#|lls:cache_mul\", &key, &keylen, &value, &expires, &remote)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_cache_magic_set(key, keylen, (char *) &value, 8, expires, UWSGI_CACHE_FLAG_UPDATE|UWSGI_CACHE_FLAG_MATH|UWSGI_CACHE_FLAG_FIXEXPIRE|UWSGI_CACHE_FLAG_MUL, remote)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\nPyObject *py_uwsgi_cache_div(PyObject * self, PyObject * args) {\n\n        char *key;\n        Py_ssize_t keylen = 0;\n        char *remote = NULL;\n        int64_t value = 2;\n        uint64_t expires = 0;\n\n        if (!PyArg_ParseTuple(args, \"s#|lls:cache_div\", &key, &keylen, &value, &expires, &remote)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_cache_magic_set(key, keylen, (char *) &value, 8, expires, UWSGI_CACHE_FLAG_UPDATE|UWSGI_CACHE_FLAG_MATH|UWSGI_CACHE_FLAG_FIXEXPIRE|UWSGI_CACHE_FLAG_DIV, remote)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\n\n\nPyObject *py_uwsgi_cache_exists(PyObject * self, PyObject * args) {\n\n\tchar *key;\n        Py_ssize_t keylen = 0;\n        char *cache = NULL;\n\n        if (!PyArg_ParseTuple(args, \"s#|s:cache_exists\", &key, &keylen, &cache)) {\n                return NULL;\n        }\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_cache_magic_exists(key, keylen, cache)) {\n\t\tUWSGI_GET_GIL\n\t\tPy_INCREF(Py_True);\n\t\treturn Py_True;\n\t}\n        UWSGI_GET_GIL\n\n        Py_INCREF(Py_None);\n        return Py_None;\n}\n\nPyObject *py_uwsgi_queue_push(PyObject * self, PyObject * args) {\n\n\tPy_ssize_t msglen = 0;\n\tchar *message ;\n\tPyObject *res;\n\n\tif (!PyArg_ParseTuple(args, \"s#:queue_push\", &message, &msglen)) {\n                return NULL;\n        }\n\t\n\tif (uwsgi.queue_size) {\n\t\tUWSGI_RELEASE_GIL\n                uwsgi_wlock(uwsgi.queue_lock);\n                if (uwsgi_queue_push(message, msglen)) {\n                \tuwsgi_rwunlock(uwsgi.queue_lock);\n\t\t\tUWSGI_GET_GIL\n\t\t\tPy_INCREF(Py_True);\n                        res = Py_True;\n                }\n                else {\n                \tuwsgi_rwunlock(uwsgi.queue_lock);\n\t\t\tUWSGI_GET_GIL\n                        Py_INCREF(Py_None);\n                        res = Py_None;\n                }\n                return res;\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\t\n}\n\nPyObject *py_uwsgi_queue_set(PyObject * self, PyObject * args) {\n\n        Py_ssize_t msglen = 0;\n\tuint64_t pos = 0;\n        char *message ;\n        PyObject *res;\n\n        if (!PyArg_ParseTuple(args, \"ls#:queue_set\", &pos, &message, &msglen)) {\n                return NULL;\n        }\n\n        if (uwsgi.queue_size) {\n\t\tUWSGI_RELEASE_GIL\n                uwsgi_wlock(uwsgi.queue_lock);\n                if (uwsgi_queue_set(pos, message, msglen)) {\n                \tuwsgi_rwunlock(uwsgi.queue_lock);\n\t\t\tUWSGI_GET_GIL\n                        Py_INCREF(Py_True);\n                        res = Py_True;\n                }\n                else {\n                \tuwsgi_rwunlock(uwsgi.queue_lock);\n\t\t\tUWSGI_GET_GIL\n                        Py_INCREF(Py_None);\n                        res = Py_None;\n                }\n                return res;\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n}\n\n\nPyObject *py_uwsgi_queue_slot(PyObject * self, PyObject * args) {\n\n\treturn PyLong_FromUnsignedLongLong(uwsgi.queue_header->pos);\n}\n\nPyObject *py_uwsgi_queue_pull_slot(PyObject * self, PyObject * args) {\n\n\treturn PyLong_FromUnsignedLongLong(uwsgi.queue_header->pull_pos);\n}\n\n\nPyObject *py_uwsgi_queue_pull(PyObject * self, PyObject * args) {\n\n\tchar *message;\n\tuint64_t size;\n\tPyObject *res;\n\tchar *storage;\n\n\tif (uwsgi.queue_size) {\n\t\tUWSGI_RELEASE_GIL\n\t\tuwsgi_wlock(uwsgi.queue_lock);\n\n\t\tmessage = uwsgi_queue_pull(&size);\n\n                if (!message || size == 0) {\n                \tuwsgi_rwunlock(uwsgi.queue_lock);\n\t\t\tUWSGI_GET_GIL\n                        Py_INCREF(Py_None);\n                        return Py_None;\n                }\n\n                storage = uwsgi_malloc(size);\n\t\tmemcpy(storage, message, size);\n\n                uwsgi_rwunlock(uwsgi.queue_lock);\n\t\tUWSGI_GET_GIL\n\n\t\tres = PyString_FromStringAndSize(storage, size);\n\t\tfree(storage);\n                return res;\n\t}\n\n\tPy_INCREF(Py_None);     \n        return Py_None;\n\n}\n\nPyObject *py_uwsgi_queue_pop(PyObject * self, PyObject * args) {\n\n        char *message;\n        uint64_t size;\n        PyObject *res;\n\tchar *storage;\n\n        if (uwsgi.queue_size) {\n\n\t\tUWSGI_RELEASE_GIL\n                uwsgi_wlock(uwsgi.queue_lock);\n\n                message = uwsgi_queue_pop(&size);\n\t\tif (!message || size == 0) {\n                \tuwsgi_rwunlock(uwsgi.queue_lock);\n\t\t\tUWSGI_GET_GIL\n                        Py_INCREF(Py_None);\n\t\t\treturn Py_None;\n\t\t}\n\n\t\tstorage = uwsgi_malloc(size);\n                memcpy(storage, message, size);\n\n                uwsgi_rwunlock(uwsgi.queue_lock);\n\t\tUWSGI_GET_GIL\n\n\t\tres = PyString_FromStringAndSize(storage, size);\n\t\tfree(storage);\n                return res;\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n\n}\n\n\nPyObject *py_uwsgi_queue_get(PyObject * self, PyObject * args) {\n\n\tlong index = 0;\n\tuint64_t size = 0;\n\tchar *message;\n\tPyObject *res;\n\tchar *storage;\n\n\tif (!PyArg_ParseTuple(args, \"l:queue_get\", &index)) {\n                return NULL;\n        }\n\n\tif (uwsgi.queue_size) {\n\t\tUWSGI_RELEASE_GIL\n\t\tuwsgi_rlock(uwsgi.queue_lock);\n\n\t\tmessage = uwsgi_queue_get(index, &size);\n                if (!message || size == 0) {\n\t\t\tuwsgi_rwunlock(uwsgi.queue_lock);\n\t\t\tUWSGI_GET_GIL\n                        Py_INCREF(Py_None);\n\t\t\treturn Py_None;\n\t\t}\n\n\t\tstorage = uwsgi_malloc(size);\n                memcpy(storage, message, size);\n\n\t\tuwsgi_rwunlock(uwsgi.queue_lock);\n\t\tUWSGI_GET_GIL\n\n                res = PyString_FromStringAndSize(storage, size);\n\t\tfree(storage);\n\t\treturn res;\n\t}\t\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_uwsgi_queue_last(PyObject * self, PyObject * args) {\n\n        long i, num = 0;\n        uint64_t size = 0;\n        char *message;\n        PyObject *res = NULL;\n\tuint64_t base;\n\tchar *storage;\n\n        if (!PyArg_ParseTuple(args, \"|l:queue_last\", &num)) {\n                return NULL;\n        }\n\n        if (uwsgi.queue_size) {\n\n\t\tif (num > 0) {\n\t\t\tres = PyList_New(0);\n\t\t}\n\n\t\tUWSGI_RELEASE_GIL\n                uwsgi_rlock(uwsgi.queue_lock);\n\n\t\tif (uwsgi.queue_header->pos > 0) {\n\t\t\tbase = uwsgi.queue_header->pos-1;\n\t\t}\n\t\telse {\n\t\t\tbase = uwsgi.queue_size-1;\n\t\t}\n\n\t\tif (num == 0) {\n                \tmessage = uwsgi_queue_get(base, &size);\n                \tif (!message || size == 0) {\n                \t\tuwsgi_rwunlock(uwsgi.queue_lock);\n\t\t\t\tUWSGI_GET_GIL\n                        \tPy_INCREF(Py_None);\n\t\t\t\treturn Py_None;\n\t\t\t}\n\n\t\t\tstorage = uwsgi_malloc(size);\n                        memcpy(storage, message, size);\n\n                \tuwsgi_rwunlock(uwsgi.queue_lock);\n\t\t\tUWSGI_GET_GIL\n\n\t\t\tres = PyString_FromStringAndSize(storage, size);\n\t\t\tfree(storage);\n\t\t\treturn res;\n\t\t}\n\n\t\tif (num > (long)uwsgi.queue_size) num = uwsgi.queue_size;\n\n\t\tchar **queue_items = uwsgi_malloc(sizeof(char *) * num);\n\t\tuint64_t *queue_items_size = uwsgi_malloc(sizeof(uint64_t) * num);\n\t\tlong item_pos = 0;\n\t\twhile(num) {\n                \tmessage = uwsgi_queue_get(base, &size);\n                \tif (!message || size == 0) {\n\t\t\t\tqueue_items[item_pos] = NULL;\n\t\t\t\tqueue_items_size[item_pos] = 0;\n                \t}\n\t\t\telse {\n\t\t\t\tqueue_items[item_pos] = uwsgi_malloc(size);\n\t\t\t\tmemcpy(queue_items[item_pos], message, size);\n\t\t\t\tqueue_items_size[item_pos] = size;\n\t\t\t}\n\t\t\titem_pos++;\n\t\t\tif (base > 0) {\n\t\t\t\tbase--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbase = uwsgi.queue_size-1;\n\t\t\t}\n\t\t\tnum--;\n\t\t}\n\n                uwsgi_rwunlock(uwsgi.queue_lock);\n\t\tUWSGI_GET_GIL\n\n\t\tfor(i=0;i<item_pos;i++) {\n\t\t\tif (queue_items[i]) {\n\t\t\t\tPyObject *zero = PyString_FromStringAndSize(queue_items[i], queue_items_size[i]);\n\t\t\t\tPyList_Append(res, zero);\n\t\t\t\tPy_DECREF(zero);\n\t\t\t\tfree(queue_items[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPy_INCREF(Py_None);\n\t\t\t\tPyList_Append(res, Py_None);\n\t\t\t}\n\t\t}\n\t\tfree(queue_items);\n\t\tfree(queue_items_size);\n                return res;\n        }\n\n        Py_INCREF(Py_None);\n        return Py_None;\n}\n\n\nPyObject *py_uwsgi_cache_get(PyObject * self, PyObject * args) {\n\n\tchar *key;\n\tPy_ssize_t keylen = 0;\n\tchar *cache = NULL;\n\n\tif (!PyArg_ParseTuple(args, \"s#|s:cache_get\", &key, &keylen, &cache)) {\n\t\treturn NULL;\n\t}\n\n\tuint64_t vallen = 0;\n\tUWSGI_RELEASE_GIL\n\tchar *value = uwsgi_cache_magic_get(key, keylen, &vallen, NULL, cache);\n\tUWSGI_GET_GIL\n\tif (value) {\n\t\t// in python 3.x we return bytes\n\t\tPyObject *ret = PyString_FromStringAndSize(value, vallen);\n\t\tfree(value);\n\t\treturn ret;\n\t}\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n\n}\n\nPyObject *py_uwsgi_cache_num(PyObject * self, PyObject * args) {\n\n        char *key;\n        Py_ssize_t keylen = 0;\n        char *cache = NULL;\n\n        if (!PyArg_ParseTuple(args, \"s#|s:cache_num\", &key, &keylen, &cache)) {\n                return NULL;\n        }\n\n        uint64_t vallen = 0;\n        UWSGI_RELEASE_GIL\n        char *value = uwsgi_cache_magic_get(key, keylen, &vallen, NULL, cache);\n        UWSGI_GET_GIL\n        if (value && vallen == 8) {\n\t\tint64_t *num = (int64_t *) value;\n                PyObject *ret = PyLong_FromLong(*num);\n                free(value);\n                return ret;\n        }\n\n        return PyLong_FromLong(0);\n\n}\n\nPyObject *py_uwsgi_cache_keys(PyObject * self, PyObject * args) {\n\tchar *cache = NULL;\n        struct uwsgi_cache_item *uci = NULL;\n        uint64_t pos = 0;\n\n        if (!PyArg_ParseTuple(args, \"|s:cache_keys\", &cache)) {\n                return NULL;\n        }\n\n\tstruct uwsgi_cache *uc = uwsgi_cache_by_name(cache);\n\tif (!uc) {\n\t\treturn PyErr_Format(PyExc_ValueError, \"no local uWSGI cache available\");\n\t}\n\n\tPyObject *l = PyList_New(0);\n\n\tuwsgi_rlock(uc->lock);\n        for(;;) {\n                uci = uwsgi_cache_keys(uc, &pos, &uci);\n                if (!uci) break;\n\t\tPyObject *ci = PyString_FromStringAndSize(uci->key, uci->keysize);\n\t\tPyList_Append(l, ci);\n\t\tPy_DECREF(ci);\n        }\n\tuwsgi_rwunlock(uc->lock);\n\treturn l;\n}\n\n\nstatic PyMethodDef uwsgi_cache_methods[] = {\n\t{\"cache_get\", py_uwsgi_cache_get, METH_VARARGS, \"\"},\n\t{\"cache_set\", py_uwsgi_cache_set, METH_VARARGS, \"\"},\n\t{\"cache_update\", py_uwsgi_cache_update, METH_VARARGS, \"\"},\n\t{\"cache_del\", py_uwsgi_cache_del, METH_VARARGS, \"\"},\n\t{\"cache_exists\", py_uwsgi_cache_exists, METH_VARARGS, \"\"},\n\t{\"cache_clear\", py_uwsgi_cache_clear, METH_VARARGS, \"\"},\n\t{\"cache_inc\", py_uwsgi_cache_inc, METH_VARARGS, \"\"},\n\t{\"cache_dec\", py_uwsgi_cache_dec, METH_VARARGS, \"\"},\n\t{\"cache_mul\", py_uwsgi_cache_mul, METH_VARARGS, \"\"},\n\t{\"cache_div\", py_uwsgi_cache_div, METH_VARARGS, \"\"},\n\t{\"cache_num\", py_uwsgi_cache_num, METH_VARARGS, \"\"},\n\t{\"cache_keys\", py_uwsgi_cache_keys, METH_VARARGS, \"\"},\n\t{NULL, NULL},\n};\n\nstatic PyMethodDef uwsgi_queue_methods[] = {\n\t{\"queue_get\", py_uwsgi_queue_get, METH_VARARGS, \"\"},\n\t{\"queue_set\", py_uwsgi_queue_set, METH_VARARGS, \"\"},\n\t{\"queue_last\", py_uwsgi_queue_last, METH_VARARGS, \"\"},\n\t{\"queue_push\", py_uwsgi_queue_push, METH_VARARGS, \"\"},\n\t{\"queue_pull\", py_uwsgi_queue_pull, METH_VARARGS, \"\"},\n\t{\"queue_pop\", py_uwsgi_queue_pop, METH_VARARGS, \"\"},\n\t{\"queue_slot\", py_uwsgi_queue_slot, METH_VARARGS, \"\"},\n\t{\"queue_pull_slot\", py_uwsgi_queue_pull_slot, METH_VARARGS, \"\"},\n\t{NULL, NULL},\n};\n\nPyObject *py_uwsgi_metric_inc(PyObject * self, PyObject * args) {\n        char *key;\n        int64_t value = 1;\n        if (!PyArg_ParseTuple(args, \"s|l:metric_inc\", &key, &value)) return NULL;\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_metric_inc(key, NULL, value)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\nPyObject *py_uwsgi_metric_dec(PyObject * self, PyObject * args) {\n        char *key;\n        int64_t value = 1;\n        if (!PyArg_ParseTuple(args, \"s|l:metric_dec\", &key, &value)) return NULL;\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_metric_dec(key, NULL, value)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\nPyObject *py_uwsgi_metric_mul(PyObject * self, PyObject * args) {\n        char *key;\n        int64_t value = 1;\n        if (!PyArg_ParseTuple(args, \"s|l:metric_mul\", &key, &value)) return NULL;\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_metric_mul(key, NULL, value)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\nPyObject *py_uwsgi_metric_div(PyObject * self, PyObject * args) {\n        char *key;\n        int64_t value = 1;\n        if (!PyArg_ParseTuple(args, \"s|l:metric_div\", &key, &value)) return NULL;\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_metric_div(key, NULL, value)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\nPyObject *py_uwsgi_metric_set(PyObject * self, PyObject * args) {\n        char *key;\n        int64_t value = 1;\n        if (!PyArg_ParseTuple(args, \"s|l:metric_set\", &key, &value)) return NULL;\n        \n        UWSGI_RELEASE_GIL\n        if (uwsgi_metric_set(key, NULL, value)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\nPyObject *py_uwsgi_metric_get(PyObject * self, PyObject * args) {\n        char *key;\n        if (!PyArg_ParseTuple(args, \"s:metric_get\", &key)) return NULL;\n\n        UWSGI_RELEASE_GIL\n        int64_t value = uwsgi_metric_get(key, NULL);\n        UWSGI_GET_GIL\n        return PyLong_FromLongLong(value);\n}\n\nPyObject *py_uwsgi_metric_set_max(PyObject * self, PyObject * args) {\n        char *key;\n        int64_t value = 1;\n        if (!PyArg_ParseTuple(args, \"s|l:metric_set_max\", &key, &value)) return NULL;\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_metric_set_max(key, NULL, value)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\nPyObject *py_uwsgi_metric_set_min(PyObject * self, PyObject * args) {\n        char *key;\n        int64_t value = 1;\n        if (!PyArg_ParseTuple(args, \"s|l:metric_set_min\", &key, &value)) return NULL;\n\n        UWSGI_RELEASE_GIL\n        if (uwsgi_metric_set_min(key, NULL, value)) {\n                UWSGI_GET_GIL\n                Py_INCREF(Py_None);\n                return Py_None;\n        }\n        UWSGI_GET_GIL\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\n\nstatic PyMethodDef uwsgi_metrics_methods[] = {\n\t{\"metric_inc\", py_uwsgi_metric_inc, METH_VARARGS, \"\"},\n\t{\"metric_dec\", py_uwsgi_metric_dec, METH_VARARGS, \"\"},\n\t{\"metric_mul\", py_uwsgi_metric_mul, METH_VARARGS, \"\"},\n\t{\"metric_div\", py_uwsgi_metric_div, METH_VARARGS, \"\"},\n\t{\"metric_get\", py_uwsgi_metric_get, METH_VARARGS, \"\"},\n\t{\"metric_set\", py_uwsgi_metric_set, METH_VARARGS, \"\"},\n\t{\"metric_set_max\", py_uwsgi_metric_set_max, METH_VARARGS, \"\"},\n\t{\"metric_set_min\", py_uwsgi_metric_set_min, METH_VARARGS, \"\"},\n\t{NULL, NULL},\n};\n\n\nvoid init_uwsgi_module_spooler(PyObject * current_uwsgi_module) {\n\tPyMethodDef *uwsgi_function;\n\tPyObject *uwsgi_module_dict;\n\n\tuwsgi_module_dict = PyModule_GetDict(current_uwsgi_module);\n\tif (!uwsgi_module_dict) {\n\t\tuwsgi_log(\"could not get uwsgi module __dict__\\n\");\n\t\texit(1);\n\t}\n\n\tfor (uwsgi_function = uwsgi_spooler_methods; uwsgi_function->ml_name != NULL; uwsgi_function++) {\n\t\tPyObject *func = PyCFunction_New(uwsgi_function, NULL);\n\t\tPyDict_SetItemString(uwsgi_module_dict, uwsgi_function->ml_name, func);\n\t\tPy_DECREF(func);\n\t}\n}\n\nvoid init_uwsgi_module_advanced(PyObject * current_uwsgi_module) {\n\tPyMethodDef *uwsgi_function;\n\tPyObject *uwsgi_module_dict;\n\n\tuwsgi_module_dict = PyModule_GetDict(current_uwsgi_module);\n\tif (!uwsgi_module_dict) {\n\t\tuwsgi_log(\"could not get uwsgi module __dict__\\n\");\n\t\texit(1);\n\t}\n\n\tfor (uwsgi_function = uwsgi_advanced_methods; uwsgi_function->ml_name != NULL; uwsgi_function++) {\n\t\tPyObject *func = PyCFunction_New(uwsgi_function, NULL);\n\t\tPyDict_SetItemString(uwsgi_module_dict, uwsgi_function->ml_name, func);\n\t\tPy_DECREF(func);\n\t}\n\n\tfor (uwsgi_function = uwsgi_metrics_methods; uwsgi_function->ml_name != NULL; uwsgi_function++) {\n                PyObject *func = PyCFunction_New(uwsgi_function, NULL);\n                PyDict_SetItemString(uwsgi_module_dict, uwsgi_function->ml_name, func);\n                Py_DECREF(func);\n        }\n\n}\n\nvoid init_uwsgi_module_cache(PyObject * current_uwsgi_module) {\n\tPyMethodDef *uwsgi_function;\n\tPyObject *uwsgi_module_dict;\n\n\tuwsgi_module_dict = PyModule_GetDict(current_uwsgi_module);\n\tif (!uwsgi_module_dict) {\n\t\tuwsgi_log(\"could not get uwsgi module __dict__\\n\");\n\t\texit(1);\n\t}\n\n\tfor (uwsgi_function = uwsgi_cache_methods; uwsgi_function->ml_name != NULL; uwsgi_function++) {\n\t\tPyObject *func = PyCFunction_New(uwsgi_function, NULL);\n\t\tPyDict_SetItemString(uwsgi_module_dict, uwsgi_function->ml_name, func);\n\t\tPy_DECREF(func);\n\t}\n}\n\nvoid init_uwsgi_module_queue(PyObject * current_uwsgi_module) {\n        PyMethodDef *uwsgi_function;\n        PyObject *uwsgi_module_dict;\n\n        uwsgi_module_dict = PyModule_GetDict(current_uwsgi_module);\n        if (!uwsgi_module_dict) {\n                uwsgi_log(\"could not get uwsgi module __dict__\\n\");\n                exit(1);\n        }\n\n        for (uwsgi_function = uwsgi_queue_methods; uwsgi_function->ml_name != NULL; uwsgi_function++) {\n                PyObject *func = PyCFunction_New(uwsgi_function, NULL);\n                PyDict_SetItemString(uwsgi_module_dict, uwsgi_function->ml_name, func);\n                Py_DECREF(func);\n        }\n\n\tPyDict_SetItemString(uwsgi_module_dict, \"queue_size\", PyLong_FromUnsignedLongLong(uwsgi.queue_size));\n}\n\n\nvoid init_uwsgi_module_sharedarea(PyObject * current_uwsgi_module) {\n\tPyMethodDef *uwsgi_function;\n\tPyObject *uwsgi_module_dict;\n\n\tuwsgi_module_dict = PyModule_GetDict(current_uwsgi_module);\n\tif (!uwsgi_module_dict) {\n\t\tuwsgi_log(\"could not get uwsgi module __dict__\\n\");\n\t\texit(1);\n\t}\n\n\tfor (uwsgi_function = uwsgi_sa_methods; uwsgi_function->ml_name != NULL; uwsgi_function++) {\n\t\tPyObject *func = PyCFunction_New(uwsgi_function, NULL);\n\t\tPyDict_SetItemString(uwsgi_module_dict, uwsgi_function->ml_name, func);\n\t\tPy_DECREF(func);\n\t}\n}\n\nPyObject *py_snmp_set_counter32(PyObject * self, PyObject * args) {\n\n                   uint8_t oid_num;\n                   uint32_t oid_val = 0;\n\n                   if (!PyArg_ParseTuple(args, \"bI:snmp_set_counter32\", &oid_num, &oid_val)) {\n                   return NULL;\n                   }\n\n                   if (oid_num > 100 || oid_num < 1)\n                   goto clear;\n\n                   UWSGI_RELEASE_GIL\n                   uwsgi_wlock(uwsgi.snmp_lock);\n\n                   uwsgi.shared->snmp_value[oid_num - 1].type = SNMP_COUNTER32;\n                   uwsgi.shared->snmp_value[oid_num - 1].val = oid_val;\n\n                   uwsgi_rwunlock(uwsgi.snmp_lock);\n                   UWSGI_GET_GIL\n\n                   Py_INCREF(Py_True);\n                   return Py_True;\n\nclear:\n\n\t\tPy_INCREF(Py_None);\n\t\treturn Py_None;\n}\n\nPyObject *py_snmp_set_counter64(PyObject * self, PyObject * args) {\n\n\tuint8_t oid_num;\n\tuint64_t oid_val = 0;\n\n\tif (!PyArg_ParseTuple(args, \"bK:snmp_set_counter64\", &oid_num, &oid_val)) {\n\t\treturn NULL;\n\t}\n\n\tif (oid_num > 100 || oid_num < 1)\n\tgoto clear;\n\n\tUWSGI_RELEASE_GIL\n\tuwsgi_wlock(uwsgi.snmp_lock);\n\n\tuwsgi.shared->snmp_value[oid_num - 1].type = SNMP_COUNTER64;\n\tuwsgi.shared->snmp_value[oid_num - 1].val = oid_val;\n\n\tuwsgi_rwunlock(uwsgi.snmp_lock);\n\tUWSGI_GET_GIL\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\nclear:\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_snmp_set_gauge(PyObject * self, PyObject * args) {\n\n\tuint8_t oid_num;\n\tuint32_t oid_val = 0;\n\n\tif (!PyArg_ParseTuple(args, \"bI:snmp_set_gauge\", &oid_num, &oid_val)) {\n\t\treturn NULL;\n\t}\n\n\tif (oid_num > 100 || oid_num < 1)\n\t\tgoto clear;\n\n\tUWSGI_RELEASE_GIL\n\tuwsgi_wlock(uwsgi.snmp_lock);\n\n\tuwsgi.shared->snmp_value[oid_num - 1].type = SNMP_GAUGE;\n\tuwsgi.shared->snmp_value[oid_num - 1].val = oid_val;\n\n\tuwsgi_rwunlock(uwsgi.snmp_lock);\n\tUWSGI_GET_GIL\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\nclear:\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_snmp_incr_counter32(PyObject * self, PyObject * args) {\n\n\tuint8_t oid_num;\n\tuint32_t oid_val = 1;\n\n\tif (!PyArg_ParseTuple(args, \"bI:snmp_incr_counter32\", &oid_num, &oid_val)) {\n\t\tPyErr_Clear();\n\t\tif (!PyArg_ParseTuple(args, \"b:snmp_incr_counter32\", &oid_num)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (oid_num > 100 || oid_num < 1)\n\t\tgoto clear;\n\n\tUWSGI_RELEASE_GIL\n\tuwsgi_wlock(uwsgi.snmp_lock);\n\n\tuwsgi.shared->snmp_value[oid_num - 1].type = SNMP_COUNTER32;\n\tuwsgi.shared->snmp_value[oid_num - 1].val = uwsgi.shared->snmp_value[oid_num - 1].val + oid_val;\n\n\tuwsgi_rwunlock(uwsgi.snmp_lock);\n\tUWSGI_GET_GIL\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\nclear:\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_snmp_incr_counter64(PyObject * self, PyObject * args) {\n\n\tuint8_t oid_num;\n\tuint64_t oid_val = 1;\n\n\tif (!PyArg_ParseTuple(args, \"bI:snmp_incr_counter64\", &oid_num, &oid_val)) {\n\t\tPyErr_Clear();\n\t\tif (!PyArg_ParseTuple(args, \"b:snmp_incr_counter64\", &oid_num)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (oid_num > 100 || oid_num < 1)\n\t\tgoto clear;\n\n\tUWSGI_RELEASE_GIL\n\tuwsgi_wlock(uwsgi.snmp_lock);\n\n\tuwsgi.shared->snmp_value[oid_num - 1].type = SNMP_COUNTER64;\n\tuwsgi.shared->snmp_value[oid_num - 1].val = uwsgi.shared->snmp_value[oid_num - 1].val + oid_val;\n\n\tuwsgi_rwunlock(uwsgi.snmp_lock);\n\tUWSGI_GET_GIL\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\nclear:\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_snmp_incr_gauge(PyObject * self, PyObject * args) {\n\n\tuint8_t oid_num;\n\tuint64_t oid_val = 1;\n\n\tif (!PyArg_ParseTuple(args, \"bI:snmp_incr_gauge\", &oid_num, &oid_val)) {\n\t\tPyErr_Clear();\n\t\tif (!PyArg_ParseTuple(args, \"b:snmp_incr_gauge\", &oid_num)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (oid_num > 100 || oid_num < 1)\n\t\tgoto clear;\n\n\tUWSGI_RELEASE_GIL\n\tuwsgi_wlock(uwsgi.snmp_lock);\n\n\tuwsgi.shared->snmp_value[oid_num - 1].type = SNMP_GAUGE;\n\tuwsgi.shared->snmp_value[oid_num - 1].val = uwsgi.shared->snmp_value[oid_num - 1].val + oid_val;\n\n\tuwsgi_rwunlock(uwsgi.snmp_lock);\n\tUWSGI_GET_GIL\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\nclear:\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_snmp_decr_counter32(PyObject * self, PyObject * args) {\n\n\tuint8_t oid_num;\n\tuint32_t oid_val = 1;\n\n\tif (!PyArg_ParseTuple(args, \"bI:snmp_incr_counter32\", &oid_num, &oid_val)) {\n\t\tPyErr_Clear();\n\t\tif (!PyArg_ParseTuple(args, \"b:snmp_incr_counter32\", &oid_num)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (oid_num > 100 || oid_num < 1)\n\t\tgoto clear;\n\n\tUWSGI_RELEASE_GIL\n\tuwsgi_wlock(uwsgi.snmp_lock);\n\n\tuwsgi.shared->snmp_value[oid_num - 1].type = SNMP_COUNTER32;\n\tuwsgi.shared->snmp_value[oid_num - 1].val = uwsgi.shared->snmp_value[oid_num - 1].val - oid_val;\n\n\tuwsgi_rwunlock(uwsgi.snmp_lock);\n\tUWSGI_GET_GIL\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\nclear:\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nPyObject *py_snmp_decr_counter64(PyObject * self, PyObject * args) {\n\n\tuint8_t oid_num;\n\tuint64_t oid_val = 1;\n\n\tif (!PyArg_ParseTuple(args, \"bI:snmp_incr_counter64\", &oid_num, &oid_val)) {\n\t\tPyErr_Clear();\n\t\tif (!PyArg_ParseTuple(args, \"b:snmp_incr_counter64\", &oid_num)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (oid_num > 100 || oid_num < 1)\n\t\tgoto clear;\n\n\tUWSGI_RELEASE_GIL\n\tuwsgi_wlock(uwsgi.snmp_lock);\n\n\tuwsgi.shared->snmp_value[oid_num - 1].type = SNMP_COUNTER64;\n\tuwsgi.shared->snmp_value[oid_num - 1].val = uwsgi.shared->snmp_value[oid_num - 1].val - oid_val;\n\n\tuwsgi_rwunlock(uwsgi.snmp_lock);\n\tUWSGI_GET_GIL\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\nclear:\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nstatic PyObject *py_snmp_decr_gauge(PyObject * self, PyObject * args) {\n\n\tuint8_t oid_num;\n\tuint64_t oid_val = 1;\n\n\tif (!PyArg_ParseTuple(args, \"bI:snmp_incr_gauge\", &oid_num, &oid_val)) {\n\t\tPyErr_Clear();\n\t\tif (!PyArg_ParseTuple(args, \"b:snmp_incr_gauge\", &oid_num)) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (oid_num > 100 || oid_num < 1)\n\t\tgoto clear;\n       \n\tUWSGI_RELEASE_GIL\n\tuwsgi_wlock(uwsgi.snmp_lock);\n\n\tuwsgi.shared->snmp_value[oid_num - 1].type = SNMP_GAUGE;\n\tuwsgi.shared->snmp_value[oid_num - 1].val = uwsgi.shared->snmp_value[oid_num - 1].val - oid_val;\n\n\tuwsgi_rwunlock(uwsgi.snmp_lock);\n\tUWSGI_GET_GIL\n\n\tPy_INCREF(Py_True);\n\treturn Py_True;\n\nclear:\n\n\tPy_INCREF(Py_None);\n\treturn Py_None;\n}\n\nstatic PyObject *py_snmp_set_community(PyObject * self, PyObject * args) {\n\n        char *snmp_community;\n\n        if (!PyArg_ParseTuple(args, \"s:snmp_set_community\", &snmp_community)) {\n                return NULL;\n        }\n\n        if (strlen(snmp_community) > 72) {\n                uwsgi_log( \"*** warning the supplied SNMP community string will be truncated to 72 chars ***\\n\");\n                memcpy(uwsgi.shared->snmp_community, snmp_community, 72);\n        }\n        else {\n                memcpy(uwsgi.shared->snmp_community, snmp_community, strlen(snmp_community) + 1);\n        }\n\n        Py_INCREF(Py_True);\n        return Py_True;\n\n}\n\n\nstatic PyMethodDef uwsgi_snmp_methods[] = {\n        {\"snmp_set_counter32\", py_snmp_set_counter32, METH_VARARGS, \"\"},\n        {\"snmp_set_counter64\", py_snmp_set_counter64, METH_VARARGS, \"\"},\n        {\"snmp_set_gauge\", py_snmp_set_gauge, METH_VARARGS, \"\"},\n        {\"snmp_incr_counter32\", py_snmp_incr_counter32, METH_VARARGS, \"\"},\n        {\"snmp_incr_counter64\", py_snmp_incr_counter64, METH_VARARGS, \"\"},\n        {\"snmp_incr_gauge\", py_snmp_incr_gauge, METH_VARARGS, \"\"},\n        {\"snmp_decr_counter32\", py_snmp_decr_counter32, METH_VARARGS, \"\"},\n        {\"snmp_decr_counter64\", py_snmp_decr_counter64, METH_VARARGS, \"\"},\n        {\"snmp_decr_gauge\", py_snmp_decr_gauge, METH_VARARGS, \"\"},\n        {\"snmp_set_community\", py_snmp_set_community, METH_VARARGS, \"\"},\n        {NULL, NULL},\n};\n\nvoid init_uwsgi_module_snmp(PyObject * current_uwsgi_module) {\n\n        PyMethodDef *uwsgi_function;\n\n\tPyObject *uwsgi_module_dict = PyModule_GetDict(current_uwsgi_module);\n        if (!uwsgi_module_dict) {\n                uwsgi_log(\"could not get uwsgi module __dict__\\n\");\n                exit(1);\n        }\n\n        for (uwsgi_function = uwsgi_snmp_methods; uwsgi_function->ml_name != NULL; uwsgi_function++) {\n                PyObject *func = PyCFunction_New(uwsgi_function, NULL);\n                PyDict_SetItemString(uwsgi_module_dict, uwsgi_function->ml_name, func);\n                Py_DECREF(func);\n        }\n\n        uwsgi_log( \"SNMP python functions initialized.\\n\");\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/plugins/gccgo/gccgo_plugin.c": "#include <uwsgi.h>\n\n/*\n\n\tSoon before official Go 1.1, we understood supporting Go in a fork() heavy\n\tenvironment was not blessed by the Go community.\n\n\tInstead of completely dropping support for Go, we studied how the gccgo project works and we\n\tdecided it was a better approach for uWSGI.\n\n\tThis new plugin works by initializing a new \"go runtime\" after each fork().\n\n\tThe runtime calls the Go main function (developed by the user), and pass the whole\n\tuWSGI control to it.\n\t\n\tthe uwsgi.Run() go function directly calls the uwsgi_takeover() function (it automatically\n\tmanages mules, spoolers and workers)\n\n\tThe plugin implements goroutines too.\n\n\tOn startup a goroutine is created for each socket and signals file descriptors.\n\n\tFor every request a new goroutine is created too.\n\n\tThe wsgi_request * structure is attached to the \"closure\" field of the goroutine (PAY ATTENTION)\n\n\teven if the loop engine makes use of the async mode, pthreads could be spawned all over the place.\n\tFor such a reason a mutex is created avoiding the global wsgi_req structures to be clobbered\n\n\tContrary to the standard way Go apps are deployed, the plugin supports loading shared libraries.\n\tWhile this is a common approach in other environments, the Go community prefers monolithic binaries.\n\n\tAs always, choose the model that best suite for you. Eventually building a single uWSGI binary with your Go\n\tapp embedded is pretty easy:\n\n\t\n\tCFLAGS=-DUWSGI_GCCGO_MONOLITHIC UWSGI_ADDITIONAL_SOURCES=t/go/uploadtest.go UWSGI_PROFILE=gccgo make\n\n\tor you can add the following two directives in a build profile:\n\n\tcflags = -DUWSGI_GCCGO_MONOLITHIC\n\tadditional_sources = t/go/uploadtest.go\n\n\n*/\n\nextern struct uwsgi_server uwsgi;\nstruct uwsgi_plugin gccgo_plugin;\n\nstruct uwsgi_gccgo{\n\t// 1 if a main is loaded\n\tint initialized;\n\tstruct uwsgi_string_list *libs;\n\tchar *args;\n\tpthread_mutex_t wsgi_req_lock;\n} ugccgo;\n\n/*\n\tshortcut for enabling the \"goroutines\" loop engine\n*/\nstatic void uwsgi_opt_setup_goroutines(char *opt, char *value, void *foobar) {\n        // set async mode\n        uwsgi_opt_set_int(opt, value, &uwsgi.async);\n        // set loop engine\n        uwsgi.loop = \"goroutines\";\n}\n\nstruct uwsgi_option uwsgi_gccgo_options[] = {\n\t{\"go-load\", required_argument, 0, \"load a go shared library in the process address space, eventually patching main.main and __go_init_main\", uwsgi_opt_add_string_list, &ugccgo.libs, 0},\n\t{\"gccgo-load\", required_argument, 0, \"load a go shared library in the process address space, eventually patching main.main and __go_init_main\", uwsgi_opt_add_string_list, &ugccgo.libs, 0},\n\t{\"go-args\", required_argument, 0, \"set go commandline arguments\", uwsgi_opt_set_str, &ugccgo.args, 0},\n\t{\"gccgo-args\", required_argument, 0, \"set go commandline arguments\", uwsgi_opt_set_str, &ugccgo.args, 0},\n\t{\"goroutines\", required_argument, 0, \"a shortcut setting optimal options for goroutine-based apps, takes the number of max goroutines to spawn as argument\", uwsgi_opt_setup_goroutines, NULL, UWSGI_OPT_THREADS},\n        {0, 0, 0, 0, 0, 0, 0},\n\n};\n\n// no_split_stack is the key to avoid crashing !!!\nvoid* runtime_m(void) __attribute__ ((noinline, no_split_stack));\n\n// initialize runtime\nvoid runtime_check(void);\nvoid runtime_args(int, char **);\nvoid runtime_osinit(void);\nvoid runtime_schedinit(void);\nvoid runtime_main(void);\nvoid runtime_mstart(void *);\n\n// spawn a goroutine\nvoid *__go_go(void *, void *);\n\n// api functions exposed\nextern void uwsgigo_request(void *, void *) __asm__ (\"go.uwsgi.RequestHandler\");\nextern void* uwsgigo_env(void *) __asm__ (\"go.uwsgi.Env\");\nextern void* uwsgigo_env_add(void *, void *, uint16_t, void *, uint16_t) __asm__ (\"go.uwsgi.EnvAdd\");\nextern void uwsgigo_signal_handler(void *, uint8_t) __asm__ (\"go.uwsgi.SignalHandler\");\n\n// for goroutines \nvoid runtime_netpollinit(void);\nvoid runtime_starttheworld(void);\nvoid *runtime_pollOpen(int) __asm__ (\"net.runtime_pollOpen\");\nvoid runtime_pollClose(void *) __asm__ (\"net.runtime_pollClose\");\nvoid runtime_pollUnblock(void *) __asm__ (\"net.runtime_pollUnblock\");\nint runtime_pollWait(void *, int) __asm__ (\"net.runtime_pollWait\");\nvoid runtime_pollSetDeadline(void *, int64_t, int) __asm__ (\"net.runtime_pollSetDeadline\");\nvoid runtime_gosched(void);\n// the current goroutine\nvoid *runtime_g(void);\n// we use the closure field to store the wsgi_req structure\nvoid __go_set_closure(void *);\nvoid *__go_get_closure(void);\n\nstatic void mainstart(void *arg __attribute__((unused))) {\n\truntime_main();\n}\n\n#ifndef UWSGI_GCCGO_MONOLITHIC\nvoid uwsgigo_main_main(void) __asm__ (\"main.main\");\nvoid uwsgigo_main_init(void) __asm__ (\"__go_init_main\");\n#endif\n\nvoid (*uwsgigo_hook_init)(void);\nvoid (*uwsgigo_hook_main)(void);\n\nvoid uwsgigo_main_init(void) {\n\tuwsgigo_hook_init();\n}\n\nvoid uwsgigo_main_main(void) {\n\tuwsgigo_hook_main();\n}\n\nint uwsgi_gccgo_helper_request_body_read(struct wsgi_request *wsgi_req, char *p, uint64_t len) {\n\tssize_t rlen = 0;\n\tchar *buf = uwsgi_request_body_read(wsgi_req, len, &rlen);\n\tif (buf == uwsgi.empty) {\n\t\treturn 0;\n\t}\n\telse if (buf == NULL) {\n\t\treturn -1;\n\t}\n\tmemcpy(p, buf, rlen);\n\treturn (int) rlen;\n}\n\nint uwsgi_gccgo_helper_register_signal(uint8_t signum, char *receiver, void *handler) {\n\treturn uwsgi_register_signal(signum, receiver, handler, gccgo_plugin.modifier1);\n}\n\nstatic void uwsgi_gccgo_initialize() {\n\tif (uwsgi.threads > 1) {\n\t\tuwsgi_log(\"!!! the Go runtime cannot work in multithreaded modes !!!\\n\");\n\t\texit(1);\n\t}\n#ifdef UWSGI_GCCGO_MONOLITHIC\n\tuwsgigo_hook_init = dlsym(RTLD_DEFAULT, \"__go_init_main\");\n\tuwsgigo_hook_main = dlsym(RTLD_DEFAULT, \"main.main\");\n#endif\n\tstruct uwsgi_string_list *usl = ugccgo.libs;\n\twhile(usl) {\n\t\tvoid *handle = dlopen(usl->value, RTLD_NOW | RTLD_GLOBAL);\n\t\tif (!handle) {\n\t\t\tuwsgi_log(\"unable to open go shared library: %s\\n\", dlerror());\n\t\t\texit(1);\n\t\t}\n\t\tvoid *g_init = dlsym(handle, \"__go_init_main\");\n\t\tvoid *g_main = dlsym(handle, \"main.main\");\n\t\tif (g_init && g_main) {\n\t\t\tuwsgigo_hook_init = g_init;\n\t\t\tuwsgigo_hook_main = g_main;\n\t\t\tuwsgi_log(\"[uwsgi-gccgo] loaded %s as main\\n\", usl->value);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"[uwsgi-gccgo] loaded %s\\n\", usl->value);\n\t\t}\n\t\tusl = usl->next;\n\t}\n\n\tif (!uwsgigo_hook_init || !uwsgigo_hook_main) {\n\t\treturn;\n\t}\n\n\tugccgo.initialized = 1;\n\n\t// Go runtime initialization\n\tint argc = 0;\n\tif (ugccgo.args) {\n        \tchar *argv_list = uwsgi_str(ugccgo.args);\n                char *p, *ctx = NULL;\n\t\tuwsgi_foreach_token(argv_list, \" \", p, ctx) {\n\t\t\targc++;\n                }\n\t\tfree(argv_list);\n        }\n        runtime_check();\n\tif (argc > 0) {\n\t\tchar **argv = uwsgi_calloc(sizeof(char *) * (argc + 2));\n\t\tchar *argv_list = uwsgi_str(ugccgo.args);\n\t\tchar *p, *ctx = NULL;\n\t\tint n = 0;\n\t\tuwsgi_foreach_token(argv_list, \" \", p, ctx) {\n\t\t\targv[n] = p;\n\t\t\tn++;\n                }\n        \truntime_args(argc, argv);\n\t}\n\telse {\n\t\tchar *argv[2] = {0,0};\n        \truntime_args(0, argv);\n\t}\n\n        runtime_osinit();\n        runtime_schedinit();\n        __go_go(mainstart, NULL);\n        runtime_mstart(runtime_m());\n\t// never here\n}\n\nstatic int uwsgi_gccgo_request(struct wsgi_request *wsgi_req) {\n\tif (!ugccgo.initialized) {\n\t\tuwsgi_log(\"!!! Go runtime not initialized !!!\\n\");\n\t\tgoto end;\n\t}\n\t/* Standard GO request */\n        if (!wsgi_req->uh->pktsize) {\n                uwsgi_log(\"Empty GO request. skip.\\n\");\n                return -1;\n        }\n\n        if (uwsgi_parse_vars(wsgi_req)) {\n                return -1;\n        }\n\n\twsgi_req->async_environ = uwsgigo_env(wsgi_req);\n\tint i;\n        for(i=0;i<wsgi_req->var_cnt;i+=2) {\n                uwsgigo_env_add(wsgi_req->async_environ, wsgi_req->hvec[i].iov_base,  wsgi_req->hvec[i].iov_len, wsgi_req->hvec[i+1].iov_base, wsgi_req->hvec[i+1].iov_len);\n        }\n\tuwsgigo_request(wsgi_req->async_environ, wsgi_req);\nend:\n\treturn UWSGI_OK;\n}\n\nstatic void uwsgi_gccgo_after_request(struct wsgi_request *wsgi_req) {\n\tlog_request(wsgi_req);\n}\n\nstatic int uwsgi_gccgo_signal_handler(uint8_t signum, void *handler) {\n\tif (!ugccgo.initialized) return -1;\n        uwsgigo_signal_handler(handler, signum);\n\treturn 0;\n}\n\n#define free_req_queue pthread_mutex_lock(&ugccgo.wsgi_req_lock);uwsgi.async_queue_unused_ptr++; uwsgi.async_queue_unused[uwsgi.async_queue_unused_ptr] = wsgi_req; pthread_mutex_unlock(&ugccgo.wsgi_req_lock)\n\nstatic void uwsgi_gccgo_request_goroutine(void *arg) {\n\n\tstruct wsgi_request *wsgi_req = (struct wsgi_request *) arg;\n\n\t// map wsgi_req to the goroutine\n\t__go_set_closure(wsgi_req);\n\n\tint ret,status;\n\n        for(;;) {\n                ret = uwsgi.wait_read_hook(wsgi_req->fd, uwsgi.socket_timeout);\n                wsgi_req->switches++;\n\n                if (ret <= 0) {\n                        goto end;\n                }\n\nretry:\n                status = wsgi_req->socket->proto(wsgi_req);\n                if (status < 0) {\n                        goto end;\n                }\n                else if (status == 0) {\n                        break;\n                }\n\t\tif (uwsgi_is_again()) continue;\n\t\tgoto retry;\n        }\n\n#ifdef UWSGI_ROUTING\n        if (uwsgi_apply_routes(wsgi_req) == UWSGI_ROUTE_BREAK) {\n                goto end;\n        }\n#endif\n\n        for(;;) {\n                if (uwsgi.p[wsgi_req->uh->modifier1]->request(wsgi_req) <= UWSGI_OK) {\n                        goto end;\n                }\n                wsgi_req->switches++;\n\t\t// yield\n\t\truntime_gosched();\n        }\n\nend:\n        uwsgi_close_request(wsgi_req);\n        free_req_queue;\n}\n\nstatic struct wsgi_request *uwsgi_gccgo_current_wsgi_req(void) {\n\treturn (struct wsgi_request *) __go_get_closure();\n}\n\nstatic int uwsgi_gccgo_wait_read_hook(int fd, int timeout) {\n        void *pdesc = runtime_pollOpen(fd);\n\tint64_t t = (uwsgi_micros() * 1000LL) + (((int64_t)timeout) * 1000LL * 1000LL * 1000LL);\n\truntime_pollSetDeadline(pdesc, t, 'r');\n        int ret = runtime_pollWait(pdesc, 'r');\n\truntime_pollUnblock(pdesc);\n        runtime_pollClose(pdesc);\n\tif (ret == 0) return 1;\n\t// timeout\n\tif (ret == 2) return 0;\n\treturn -1;\n}\n\nstatic int uwsgi_gccgo_wait_write_hook(int fd, int timeout) {\n\tvoid *pdesc = runtime_pollOpen(fd);\n\tint64_t t = (uwsgi_micros() * 1000LL) + (((int64_t)timeout) * 1000LL * 1000LL * 1000LL);\n\truntime_pollSetDeadline(pdesc, t, 'w');\n\tint ret = runtime_pollWait(pdesc, 'w');\t\n\truntime_pollUnblock(pdesc);\n\truntime_pollClose(pdesc);\n\tif (ret == 0) return 1;\n\t// timeout\n\tif (ret == 2) return 0;\n\treturn -1;\n}\n\n/*\n\tthis goroutine manages signals\n*/\nstatic void uwsgi_gccgo_signal_goroutine(void *arg) {\n\tint *fd = (int *) arg;\n\tvoid *pdesc = runtime_pollOpen(*fd);\n\tfor(;;) {\n\t\truntime_pollWait(pdesc, 'r');\nretry:\n\t\tuwsgi_receive_signal(*fd, \"worker\", uwsgi.mywid);\n\t\tif (uwsgi_is_again()) continue;\n\t\tgoto retry;\n\t}\n}\n\nstatic void uwsgi_gccgo_socket_goroutine(void *arg) {\n\tstruct uwsgi_socket *uwsgi_sock = (struct uwsgi_socket *) arg;\n\tstruct wsgi_request *wsgi_req = NULL;\n\tvoid *pdesc = runtime_pollOpen(uwsgi_sock->fd);\n\t// wait for connection\n\tfor(;;) {\n\t\truntime_pollWait(pdesc, 'r');\t\nretry:\n\t\tpthread_mutex_lock(&ugccgo.wsgi_req_lock);\n\t\twsgi_req = find_first_available_wsgi_req();\n\t\tpthread_mutex_unlock(&ugccgo.wsgi_req_lock);\n\n\t\tif (wsgi_req == NULL) {\n                \tuwsgi_async_queue_is_full(uwsgi_now());\n\t\t\t// try rescheduling...\n\t\t\t// we do not use runtime_gosched() as we want to call the netpoll loop too\n\t\t\truntime_pollUnblock(pdesc);\n\t\t\truntime_pollClose(pdesc);\n\t\t\tpdesc = runtime_pollOpen(uwsgi_sock->fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// fill wsgi_request structure\n\t\twsgi_req_setup(wsgi_req, wsgi_req->async_id, uwsgi_sock );\n\n\t\t// mark core as used\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 1;\n\n\t\t// accept the connection (since uWSGI 1.5 all of the sockets are non-blocking)\n\t\tif (wsgi_req_simple_accept(wsgi_req, uwsgi_sock->fd)) {\n\t\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 0;\n                \tfree_req_queue;\n\t\t\tif (uwsgi_is_again()) continue;\n                        goto retry;\n                }\n\n\t\twsgi_req->start_of_request = uwsgi_micros();\n\t\twsgi_req->start_of_request_in_sec = wsgi_req->start_of_request/1000000;\n\n\t\t// enter harakiri mode\n\t\tif (uwsgi.harakiri_options.workers > 0) {\n                \tset_harakiri(uwsgi.harakiri_options.workers);\n        \t}\n\n\t\t// spawn the new goroutine\n\t\t__go_go(uwsgi_gccgo_request_goroutine, wsgi_req);\n\t\tgoto retry;\n\t}\n}\n\nstatic void uwsgi_gccgo_loop() {\n\tif (!ugccgo.initialized) {\n\t\tuwsgi_log(\"no go.main code loaded !!!\\n\");\n\t\texit(1);\n\t}\n\t// initialize the log protecting the wsgi_req structures\n\tpthread_mutex_init(&ugccgo.wsgi_req_lock, NULL);\n\n\t// hooks\n\tuwsgi.current_wsgi_req = uwsgi_gccgo_current_wsgi_req;\n\tuwsgi.wait_write_hook = uwsgi_gccgo_wait_write_hook;\n        uwsgi.wait_read_hook = uwsgi_gccgo_wait_read_hook;\n\n\t// ininitialize Go I/O loop\n\truntime_netpollinit();\n\n\tif (uwsgi.signal_socket > -1) {\n\t\t__go_go(uwsgi_gccgo_signal_goroutine, &uwsgi.signal_socket);\n\t\t__go_go(uwsgi_gccgo_signal_goroutine, &uwsgi.my_signal_socket);\n\t}\n\n\t// start a goroutine for each socket\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi.sockets;\n\twhile(uwsgi_sock) {\n\t\tif (!uwsgi_sock->next) {\n\t\t\tuwsgi_gccgo_socket_goroutine(uwsgi_sock);\n\t\t}\n\t\telse {\n\t\t\t__go_go(uwsgi_gccgo_socket_goroutine, uwsgi_sock);\n\t\t}\n\t\tuwsgi_sock = uwsgi_sock->next;\n\t}\n\n\t// never here\n}\n\nstatic void uwsgi_gccgo_on_load() {\n\tuwsgi_register_loop( (char *) \"go\", uwsgi_gccgo_loop);\n\tuwsgi_register_loop( (char *) \"goroutine\", uwsgi_gccgo_loop);\n\tuwsgi_register_loop( (char *) \"goroutines\", uwsgi_gccgo_loop);\n}\n\nstruct uwsgi_plugin gccgo_plugin = {\n        .name = \"gccgo\",\n        .modifier1 = 11,\n\t.options = uwsgi_gccgo_options,\n\t.on_load = uwsgi_gccgo_on_load,\n        .request = uwsgi_gccgo_request,\n        .after_request = uwsgi_gccgo_after_request,\n        .post_fork = uwsgi_gccgo_initialize,\n\t.signal_handler = uwsgi_gccgo_signal_handler,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/plugins/pypy/pypy_plugin.c": "/*******************************************************************\n\n This is the C part of the PyPy plugin (with the main logic being in\n Python, see pypy_setup.py).\n\n Idea and initial implementation by Maciej Fijalkowski\n\n *******************************************************************/\n\n#include <uwsgi.h>\n\nstruct uwsgi_pypy {\n\tvoid *handler;\n\tchar *lib;\n\tchar *setup;\n\tchar *home;\n\tchar *wsgi;\n\tchar *wsgi_file;\n\tchar *paste;\n\tstruct uwsgi_string_list *eval;\n\tstruct uwsgi_string_list *eval_post_fork;\n\tstruct uwsgi_string_list *exec;\n\tstruct uwsgi_string_list *exec_post_fork;\n\n\tstruct uwsgi_string_list *pp;\n\n\tpthread_mutex_t attach_thread_lock;\n} upypy;\n\n// the functions exposed by libpypy-c\nchar *(*u_rpython_startup_code)(void);\nint (*u_pypy_setup_home)(char *, int);\nint (*u_pypy_execute_source)(char *);\nvoid (*u_pypy_thread_attach)(void);\nvoid (*u_pypy_init_threads)(void);\n\n// the hooks you can override with pypy\nvoid (*uwsgi_pypy_hook_execute_source)(char *);\nvoid (*uwsgi_pypy_hook_loader)(char *);\nvoid (*uwsgi_pypy_hook_file_loader)(char *);\nvoid (*uwsgi_pypy_hook_paste_loader)(char *);\nvoid (*uwsgi_pypy_hook_pythonpath)(char *);\nvoid (*uwsgi_pypy_hook_request)(void *, int);\nvoid (*uwsgi_pypy_post_fork_hook)(void);\n\nextern struct uwsgi_server uwsgi;\nstruct uwsgi_plugin pypy_plugin;\n\nstatic int uwsgi_pypy_init() {\n\n\tsize_t rlen = 0;\n\tchar *buffer = NULL;\n\n\tvoid *is_cpython_loaded = dlsym(RTLD_DEFAULT, \"Py_Initialize\");\n\tif (is_cpython_loaded) {\n\t\tuwsgi_log(\"!!! Loading both PyPy and CPython in the same process IS PURE EVIL AND IT IS NOT SUPPORTED !!!\\n\");\n\t\texit(1);\n\t}\n\n\tif (dlsym(RTLD_DEFAULT, \"rpython_startup_code\")) {\n\t\tuwsgi_log(\"PyPy runtime detected, skipping libpypy-c loading\\n\");\n\t\tgoto ready;\n\t}\n\telse if (upypy.lib) {\n\t\tupypy.handler = dlopen(upypy.lib, RTLD_NOW | RTLD_GLOBAL);\n\t}\n\telse {\n\t\tif (upypy.home) {\n\t\t\t// first try with /bin way:\n#ifdef __CYGWIN__\n                        char *libpath = uwsgi_concat2(upypy.home, \"/bin/libpypy-c.dll\");\n#elif defined(__APPLE__)\n                        char *libpath = uwsgi_concat2(upypy.home, \"/bin/libpypy-c.dylib\");\n#else\n                        char *libpath = uwsgi_concat2(upypy.home, \"/bin/libpypy-c.so\");\n#endif\n\t\t\tif (uwsgi_file_exists(libpath)) {\n                                upypy.handler = dlopen(libpath, RTLD_NOW | RTLD_GLOBAL);\n                        }\n                        free(libpath);\n\n\t\t\t// fallback to old-style way\n\t\t\tif (!upypy.handler) {\n\t\t\t\n#ifdef __CYGWIN__\n                        \tchar *libpath = uwsgi_concat2(upypy.home, \"/libpypy-c.dll\");\n#elif defined(__APPLE__)\n                        \tchar *libpath = uwsgi_concat2(upypy.home, \"/libpypy-c.dylib\");\n#else\n                        \tchar *libpath = uwsgi_concat2(upypy.home, \"/libpypy-c.so\");\n#endif\n\t\t\t\tif (uwsgi_file_exists(libpath)) {\n\t\t\t\t\tupypy.handler = dlopen(libpath, RTLD_NOW | RTLD_GLOBAL);\n\t\t\t\t}\n\t\t\t\tfree(libpath);\n\t\t\t}\n\t\t}\n\t\t// fallback to standard library search path\n\t\tif (!upypy.handler) {\n#ifdef __CYGWIN__\n\t\t\tupypy.handler = dlopen(\"libpypy-c.dll\", RTLD_NOW | RTLD_GLOBAL);\n#elif defined(__APPLE__)\n\t\t\tupypy.handler = dlopen(\"libpypy-c.dylib\", RTLD_NOW | RTLD_GLOBAL);\n#else\n\t\t\tupypy.handler = dlopen(\"libpypy-c.so\", RTLD_NOW | RTLD_GLOBAL);\n#endif\n\t\t}\n\t}\n\n\tif (!upypy.handler) {\n\t\tuwsgi_log(\"unable to load pypy library: %s\\n\", dlerror());\n\t\texit(1);\n\t}\n\n\tu_rpython_startup_code = dlsym(upypy.handler, \"rpython_startup_code\");\n\tif (!u_rpython_startup_code) {\n\t\tuwsgi_log(\"unable to find rpython_startup_code() symbol\\n\");\n\t\texit(1);\n\t}\n\n\tu_pypy_setup_home = dlsym(upypy.handler, \"pypy_setup_home\");\n\tif (!u_pypy_setup_home) {\n\t\tuwsgi_log(\"unable to find pypy_setup_home() symbol\\n\");\n\t\texit(1);\n\t}\n\n\tu_pypy_init_threads = dlsym(upypy.handler, \"pypy_init_threads\");\n        if (!u_pypy_init_threads) {\n                uwsgi_log(\"!!! WARNING your libpypy-c does not export pypy_init_threads, multithreading will not work !!!\\n\");\n        }\n\t\n\tu_rpython_startup_code();\n\n\tif (!upypy.home) {\n\t\tupypy.home = getenv(\"PYPY_HOME\");\n\t\tif (!upypy.home) {\n\t\t\tuwsgi_log(\"you have to specify a pypy home with --pypy-home\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (u_pypy_setup_home(upypy.home, 0)) {\n\t\tchar *retry = uwsgi_concat2(upypy.home, \"/lib_pypy\");\n\t\tif (uwsgi_is_dir(retry)) {\n\t\t\t// this time we use debug\n\t\t\tif (!u_pypy_setup_home(retry, 1)) {\n\t\t\t\tfree(retry);\n\t\t\t\tgoto ready;\n\t\t\t}\n\t\t}\n                uwsgi_log(\"unable to set pypy home to \\\"%s\\\"\\n\", upypy.home);\n\t\texit(1);\n        }\n\nready:\n\tu_pypy_execute_source = dlsym(upypy.handler, \"pypy_execute_source\");\n\tif (!u_pypy_execute_source) {\n\t\tuwsgi_log(\"unable to find pypy_execute_source() symbol\\n\");\n\t\texit(1);\n\t}\n\n\tu_pypy_thread_attach = dlsym(upypy.handler, \"pypy_thread_attach\");\n        if (!u_pypy_thread_attach) {\n                uwsgi_log(\"!!! WARNING your libpypy-c does not export pypy_thread_attach, multithreading will not work !!!\\n\");\n        }\n\n\tif (upypy.setup) {\n\t\tbuffer = uwsgi_open_and_read(upypy.setup, &rlen, 1, NULL);\n\t}\n\telse {\n\t\tchar *start = dlsym(RTLD_DEFAULT, \"uwsgi_pypy_setup_start\");\n\t\tif (!start) {\n\t\t\tstart = dlsym(RTLD_DEFAULT, \"_uwsgi_pypy_setup_start\");\n\t\t}\n\t\tchar *end = dlsym(RTLD_DEFAULT, \"uwsgi_pypy_setup_end\");\n\t\tif (!end) {\n\t\t\tend = dlsym(RTLD_DEFAULT, \"_uwsgi_pypy_setup_end\");\n\t\t}\n\t\tif (start && end) {\n\t\t\tbuffer = uwsgi_concat2n(start, end-start, \"\", 0);\n\t\t}\n\t}\n\n\tif (!buffer) {\n\t\tuwsgi_log(\"you have to load a pypy setup file with --pypy-setup\\n\");\n\t\texit(1);\n\t}\n\tif (u_pypy_execute_source(buffer)) {\n\t\texit(1);\n\t}\n\tfree(buffer);\n\n\t// add items to the pythonpath\n\tstruct uwsgi_string_list *usl = upypy.pp;\n\twhile(usl) {\n\t\tif (uwsgi_pypy_hook_pythonpath) {\n\t\t\tuwsgi_pypy_hook_pythonpath(usl->value);\n\t\t}\n\t\tusl = usl->next;\n\t}\n\n\treturn 0;\n}\n\nstatic void uwsgi_pypy_preinit_apps() {\n\n\tif (!uwsgi_pypy_hook_execute_source) {\n\t\tuwsgi_log(\"*** WARNING your pypy setup code does not expose a callback for \\\"execute_source\\\" ***\\n\");\n\t\treturn;\n\t}\n\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, upypy.eval) {\n\t\tuwsgi_pypy_hook_execute_source(usl->value);\n\t}\n\n\tuwsgi_foreach(usl, upypy.exec) {\n\t\tsize_t rlen = 0;\n\t\tchar *buffer = uwsgi_open_and_read(usl->value, &rlen, 1, NULL);\n\t\tuwsgi_pypy_hook_execute_source(buffer);\n\t\tfree(buffer);\n\t}\n}\n\nstatic int uwsgi_pypy_request(struct wsgi_request *wsgi_req) {\n\t/* Standard WSGI request */\n        if (!wsgi_req->uh->pktsize) {\n                uwsgi_log( \"Empty pypy request. skip.\\n\");\n                return -1;\n        }\n\n        if (uwsgi_parse_vars(wsgi_req)) {\n                return -1;\n        }\n\n\tif (uwsgi_pypy_hook_request) {\n\t\tuwsgi_pypy_hook_request(wsgi_req, wsgi_req->async_id);\n\t}\n\treturn UWSGI_OK;\n}\n\nstatic void uwsgi_pypy_after_request(struct wsgi_request *wsgi_req) {\n\tlog_request(wsgi_req);\n}\n\nstatic void uwsgi_pypy_init_apps() {\n\tif (uwsgi_pypy_hook_loader && upypy.wsgi) {\n\t\tuwsgi_pypy_hook_loader(upypy.wsgi);\n\t}\n\n\tif (uwsgi_pypy_hook_file_loader && upypy.wsgi_file) {\n\t\tuwsgi_pypy_hook_file_loader(upypy.wsgi_file);\n\t}\n\n\tif (uwsgi_pypy_hook_paste_loader && upypy.paste) {\n\t\tuwsgi_pypy_hook_paste_loader(upypy.paste);\n\t}\n}\n\n/*\nstatic void uwsgi_pypy_atexit() {\n\tif (pypy_debug_file)\n\t\tfflush(pypy_debug_file);\n}\n*/\n\nstatic void uwsgi_opt_pypy_ini_paste(char *opt, char *value, void *foobar) {\n        uwsgi_opt_load_ini(opt, value, NULL);\n        upypy.paste = value;\n}\n\n\nstatic struct uwsgi_option uwsgi_pypy_options[] = {\n\t{\"pypy-lib\", required_argument, 0, \"set the path/name of the pypy library\", uwsgi_opt_set_str, &upypy.lib, 0},\n\t{\"pypy-setup\", required_argument, 0, \"set the path of the python setup script\", uwsgi_opt_set_str, &upypy.setup, 0},\n\t{\"pypy-home\", required_argument, 0, \"set the home of pypy library\", uwsgi_opt_set_str, &upypy.home, 0},\n\t{\"pypy-wsgi\", required_argument, 0, \"load a WSGI module\", uwsgi_opt_set_str, &upypy.wsgi, 0},\n\t{\"pypy-wsgi-file\", required_argument, 0, \"load a WSGI/mod_wsgi file\", uwsgi_opt_set_str, &upypy.wsgi_file, 0},\n\t{\"pypy-ini-paste\", required_argument, 0, \"load a paste.deploy config file containing uwsgi section\", uwsgi_opt_pypy_ini_paste, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"pypy-paste\", required_argument, 0, \"load a paste.deploy config file\", uwsgi_opt_set_str, &upypy.paste, 0},\n\t{\"pypy-eval\", required_argument, 0, \"evaluate pypy code before fork()\", uwsgi_opt_add_string_list, &upypy.eval, 0},\n\t{\"pypy-eval-post-fork\", required_argument, 0, \"evaluate pypy code soon after fork()\", uwsgi_opt_add_string_list, &upypy.eval_post_fork, 0},\n\t{\"pypy-exec\", required_argument, 0, \"execute pypy code from file before fork()\", uwsgi_opt_add_string_list, &upypy.exec, 0},\n\t{\"pypy-exec-post-fork\", required_argument, 0, \"execute pypy code from file soon after fork()\", uwsgi_opt_add_string_list, &upypy.exec_post_fork, 0},\n\t{\"pypy-pp\", required_argument, 0, \"add an item to the pythonpath\", uwsgi_opt_add_string_list, &upypy.pp, 0},\n\t{\"pypy-python-path\", required_argument, 0, \"add an item to the pythonpath\", uwsgi_opt_add_string_list, &upypy.pp, 0},\n\t{\"pypy-pythonpath\", required_argument, 0, \"add an item to the pythonpath\", uwsgi_opt_add_string_list, &upypy.pp, 0},\n\t{0, 0, 0, 0, 0, 0, 0},\n};\n\nstatic void uwsgi_pypy_enable_threads() {\n\tif (u_pypy_init_threads) {\n\t\tu_pypy_init_threads();\n\t}\n}\n\nstatic void uwsgi_pypy_init_thread() {\n\tif (u_pypy_thread_attach) {\n\t\tpthread_mutex_lock(&upypy.attach_thread_lock);\n\t\tu_pypy_thread_attach();\n\t\tpthread_mutex_unlock(&upypy.attach_thread_lock);\n\t}\n}\n\nstatic int uwsgi_pypy_signal_handler(uint8_t sig, void *handler) {\n\tvoid (*pypy_func)(int) = (void(*)(int)) handler;\n\tpypy_func(sig);\n\treturn 0;\n}\n\nstatic uint64_t uwsgi_pypy_rpc(void *func, uint8_t argc, char **argv, uint16_t argvs[], char **buffer) {\n\tint iargvs[UMAX8];\n\tint i;\n\tint (*pypy_func)(int, char **, int*, char **) = (int (*)(int, char **, int*, char **)) func;\n\t// we convert 16bit to int\n\tfor(i=0;i<argc;i++) {\n\t\tiargvs[i] = (int) argvs[i]; \n\t}\n\treturn pypy_func(argc, argv, iargvs, buffer);\n}\n\nstatic void uwsgi_pypy_post_fork() {\n\tpthread_mutex_init(&upypy.attach_thread_lock, NULL);\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, upypy.eval_post_fork) {\n                uwsgi_pypy_hook_execute_source(usl->value);\n        }\n\tuwsgi_foreach(usl, upypy.exec_post_fork) {\n                size_t rlen = 0;\n                char *buffer = uwsgi_open_and_read(usl->value, &rlen, 1, NULL);\n                uwsgi_pypy_hook_execute_source(buffer);\n                free(buffer);\n        }\n\n\tif (uwsgi_pypy_post_fork_hook) {\n\t\tuwsgi_pypy_post_fork_hook();\n\t}\n}\n\nstatic void uwsgi_pypy_onload() {\n#ifdef UWSGI_PYPY_HOME\n\tupypy.home = UWSGI_PYPY_HOME;\n#endif\n\tuwsgi.has_threads = 1;\n}\n\nstatic int uwsgi_pypy_mule(char *opt) {\n\n\tif (!uwsgi_pypy_hook_execute_source) {\n\t\tuwsgi_log(\"!!! no \\\"execute_source\\\" callback in your pypy setup code !!!\\n\");\n\t\texit(1);\n\t}\n\n        if (uwsgi_endswith(opt, \".py\")) {\n                size_t rlen = 0;\n                char *buffer = uwsgi_open_and_read(opt, &rlen, 1, NULL);\n                uwsgi_pypy_hook_execute_source(buffer);\n\t\tfree(buffer);\n                return 1;\n        }\n        return 0;\n\n}\n\n\nstruct uwsgi_plugin pypy_plugin = {\n\t.name = \"pypy\",\n\t.modifier1 = 0,\n\t.on_load = uwsgi_pypy_onload,\n\t.init = uwsgi_pypy_init,\n\t.request = uwsgi_pypy_request,\n\t.after_request = uwsgi_pypy_after_request,\n\t.options = uwsgi_pypy_options,\n\t.preinit_apps = uwsgi_pypy_preinit_apps,\n\t.init_apps = uwsgi_pypy_init_apps,\n\t.init_thread = uwsgi_pypy_init_thread,\n\t.signal_handler = uwsgi_pypy_signal_handler,\n\t.enable_threads = uwsgi_pypy_enable_threads,\n\t.rpc = uwsgi_pypy_rpc,\n\t.post_fork = uwsgi_pypy_post_fork,\n\t.mule = uwsgi_pypy_mule,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/plugins/cgi/cgi_plugin.c": "#include <uwsgi.h>\n\nextern struct uwsgi_server uwsgi;\n\n#define kill_on_error if (!uc.do_not_kill_on_error) { if (kill(cgi_pid, SIGKILL)) uwsgi_error(\"kill()\");}\n\nstruct uwsgi_cgi {\n\tstruct uwsgi_dyn_dict *mountpoint;\n\tstruct uwsgi_dyn_dict *helpers;\n\tsize_t buffer_size;\n\tint timeout;\n\tstruct uwsgi_string_list *index;\n\tstruct uwsgi_string_list *allowed_ext;\n\tstruct uwsgi_string_list *unset;\n\tstruct uwsgi_string_list *loadlib;\n\tstruct uwsgi_string_list *cgi_safe;\n\tint optimize;\n\tint from_docroot;\n\tint has_mountpoints;\n\tstruct uwsgi_dyn_dict *default_cgi;\n\tint path_info;\n\tint do_not_kill_on_error;\n\tint async_max_attempts;\n\tint close_stdin_on_eof;\n} uc ;\n\nstatic void uwsgi_opt_add_cgi(char *opt, char *value, void *foobar) {\n\n\tchar *val = strchr(value, '=');\n        if (!val) {\n        \tuwsgi_dyn_dict_new(&uc.mountpoint, value, strlen(value), NULL, 0);\n        }\n        else {\n        \tuwsgi_dyn_dict_new(&uc.mountpoint, value, val-value, val+1, strlen(val+1));\n        }\n\n}\n\nstatic void uwsgi_opt_add_cgi_maphelper(char *opt, char *value, void *foobar) {\n\tchar *val = strchr(value, '=');\n        if (!val) {\n        \tuwsgi_log(\"invalid CGI helper syntax, must be ext=command\\n\");\n                exit(1);\n        }\n        uwsgi_dyn_dict_new(&uc.helpers, value, val-value, val+1, strlen(val+1));\n}\n\nstruct uwsgi_option uwsgi_cgi_options[] = {\n\n        {\"cgi\", required_argument, 0, \"add a cgi mountpoint/directory/script\", uwsgi_opt_add_cgi, NULL, 0},\n\n        {\"cgi-map-helper\", required_argument, 0, \"add a cgi map-helper\", uwsgi_opt_add_cgi_maphelper, NULL, 0},\n        {\"cgi-helper\", required_argument, 0, \"add a cgi map-helper\", uwsgi_opt_add_cgi_maphelper, NULL, 0},\n\n        {\"cgi-from-docroot\", no_argument, 0, \"blindly enable cgi in DOCUMENT_ROOT\", uwsgi_opt_true, &uc.from_docroot, 0},\n\n        {\"cgi-buffer-size\", required_argument, 0, \"set cgi buffer size\", uwsgi_opt_set_64bit, &uc.buffer_size, 0},\n        {\"cgi-timeout\", required_argument, 0, \"set cgi script timeout\", uwsgi_opt_set_int, &uc.timeout, 0},\n\n        {\"cgi-index\", required_argument, 0, \"add a cgi index file\", uwsgi_opt_add_string_list, &uc.index, 0},\n        {\"cgi-allowed-ext\", required_argument, 0, \"cgi allowed extension\", uwsgi_opt_add_string_list, &uc.allowed_ext, 0},\n\n        {\"cgi-unset\", required_argument, 0, \"unset specified environment variables\", uwsgi_opt_add_string_list, &uc.unset, 0},\n\n        {\"cgi-loadlib\", required_argument, 0, \"load a cgi shared library/optimizer\", uwsgi_opt_add_string_list, &uc.loadlib, 0},\n        {\"cgi-optimize\", no_argument, 0, \"enable cgi realpath() optimizer\", uwsgi_opt_true, &uc.optimize, 0},\n        {\"cgi-optimized\", no_argument, 0, \"enable cgi realpath() optimizer\", uwsgi_opt_true, &uc.optimize, 0},\n\n        {\"cgi-path-info\", no_argument, 0, \"disable PATH_INFO management in cgi scripts\", uwsgi_opt_true, &uc.path_info, 0},\n\n        {\"cgi-do-not-kill-on-error\", no_argument, 0, \"do not send SIGKILL to cgi script on errors\", uwsgi_opt_true, &uc.do_not_kill_on_error, 0},\n        {\"cgi-async-max-attempts\", no_argument, 0, \"max waitpid() attempts in cgi async mode (default 10)\", uwsgi_opt_set_int, &uc.async_max_attempts, 0},\n\n        {\"cgi-close-stdin-on-eof\", no_argument, 0, \"close STDIN on input EOF\", uwsgi_opt_true, &uc.close_stdin_on_eof, 0},\n\n        {\"cgi-safe\", required_argument, 0, \"skip security checks if the cgi file is under the specified path\", uwsgi_opt_add_string_list, &uc.cgi_safe, 0},\n\n        {0, 0, 0, 0, 0, 0, 0},\n\n};\n\nstatic void uwsgi_cgi_apps() {\n\n\tstruct uwsgi_dyn_dict *udd = uc.mountpoint;\n\tstruct stat st;\n\n\twhile(udd) {\n\t\tif (udd->vallen) {\n\t\t\tif (uc.optimize) {\n\t\t\t\tudd->value = realpath(udd->value, NULL);\t\n\t\t\t\tif (!udd->value) {\n\t\t\t\t\tuwsgi_log(\"unable to find CGI path %.*s\\n\", udd->vallen, udd->value);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tudd->vallen = strlen(udd->value);\n\t\t\t\tudd->status = 1;\n\t\t\t\tif (stat(udd->value, &st)) {\n\t\t\t\t\tuwsgi_error(\"stat()\");\n\t\t\t\t\tuwsgi_log(\"something horrible happened during CGI initialization\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t\t\tudd->status = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tuc.has_mountpoints = 1;\n\t\t\tuwsgi_log(\"initialized CGI mountpoint: %.*s = %.*s\\n\", udd->keylen, udd->key, udd->vallen, udd->value);\n\t\t}\n\t\telse {\n\t\t\tif (uc.optimize) {\n\t\t\t\tudd->key = realpath(udd->key, NULL);\n\t\t\t\tif (!udd->key) {\n                                        uwsgi_log(\"unable to find CGI path %.*s\\n\", udd->keylen, udd->key);\n                                        exit(1);\n                                }\n                                udd->keylen = strlen(udd->key);\n\t\t\t\tudd->status = 1;\n\n\t\t\t\tif (stat(udd->key, &st)) {\n                                        uwsgi_error(\"stat()\");  \n                                        uwsgi_log(\"something horrible happened during CGI initialization\\n\");\n                                        exit(1);\n                                }\n\n                                if (!S_ISDIR(st.st_mode)) {\n                                        udd->status = 2;\n                                }\n\n\t\t\t}\n\t\t\tuwsgi_log(\"initialized CGI path: %.*s\\n\", udd->keylen, udd->key);\n\t\t\tuc.default_cgi = udd;\n\t\t}\n\t\tudd = udd->next;\n\t}\n\n}\n\nstatic int uwsgi_cgi_init(){\n\n\tvoid (*cgi_sym)(void);\n\n\tif (!uc.buffer_size) uc.buffer_size = 65536;\n\tif (!uc.timeout) uc.timeout = 60;\n\n\tstruct uwsgi_string_list *ll = uc.loadlib;\n\twhile(ll) {\n\t\tchar *colon = strchr(ll->value, ':');\n\t\tif (!colon) {\n\t\t\tuwsgi_log(\"invalid cgi-loadlib syntax, must be in the form lib:func\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t*colon = 0;\n\t\tvoid *cgi_lib = dlopen(ll->value, RTLD_NOW | RTLD_GLOBAL);\n\t\tif (!cgi_lib) {\n\t\t\tuwsgi_log( \"cgi-loadlib: %s\\n\", dlerror());\n\t\t\texit(1);\n\t\t}\n\n\t\tcgi_sym = dlsym(cgi_lib, colon+1);\n\t\tif (!cgi_sym) {\n\t\t\tuwsgi_log(\"unknown symbol %s in lib %s\\n\", colon+1, ll->value);\n\t\t\texit(1);\n\t\t}\n\n\t\tcgi_sym();\n\t\tuwsgi_log(\"[cgi-loadlib] loaded symbol %s from %s\\n\", colon+1, ll->value);\n\n\t\t*colon = ':';\n\t\tll = ll->next;\n\t}\n\n\treturn 0;\t\n\n}\n\nstatic char *uwsgi_cgi_get_helper(char *filename) {\n\n\tstruct uwsgi_dyn_dict *helpers = uc.helpers;\n\tsize_t len = strlen(filename);\n\n\twhile(helpers) {\n\t\tif (len >= (size_t) helpers->keylen) {\n\t\t\tif (!uwsgi_strncmp((filename+len)-helpers->keylen, helpers->keylen, helpers->key, helpers->keylen)) {\n\t\t\t\treturn helpers->value;\n\t\t\t}\n\t\t}\n\t\thelpers = helpers->next;\n\t}\n\n\treturn NULL;\n\t\n}\n\n/*\nstart reading each line until Status or Location are found\n-1 error\n0 not found\n1 found\n*/\nstatic int uwsgi_cgi_check_status(struct wsgi_request *wsgi_req, char *buf, size_t len) {\n\tchar *key = buf, *value = NULL;\n\tsize_t header_size = 0;\n\tsize_t i;\n\n\tfor(i=0;i<len;i++) {\n       \t\t// end of a line\n                if (buf[i] == '\\n') {\n                \t// end of headers\n                        if (key == NULL) {\n                        \t// Default status\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"setting default Status header\\n\");\n#endif\n\t\t\t\tif (uwsgi_response_prepare_headers(wsgi_req, \"200 OK\", 6)) return -1;\n\t\t\t\treturn 1;\n\t\t\t}\n                        // invalid header\n                        else if (value == NULL) return -1;\n                        header_size = (buf+i) - key;\n                        // security check\n                        if (buf+i > buf) {\n\t\t\t\t// remove \\r\n                        \tif ((buf[i-1]) == '\\r') {\n                                \theader_size--;\n                                }\n                        }\n\n\t\t\t// enough space for Status ?\n                        if (header_size >= 11) {\n                        \t// \"Status: NNN\"\n                                if (!strncasecmp(\"Status: \", key, 8)) {\n#ifdef UWSGI_DEBUG\n                                \tuwsgi_log(\"found Status header: %.*s\\n\", header_size, key);\n#endif\n                                        if (uwsgi_response_prepare_headers(wsgi_req, key+8, header_size - 8)) return -1;\n\t\t\t\t\treturn 1;\n                                }\n                                // Location: X\n                                if (!strncasecmp(\"Location: \", key, 10)) {\n#ifdef UWSGI_DEBUG\n                                \tuwsgi_log(\"found Location header: %.*s\\n\", header_size, key);\n#endif\n                                        if (uwsgi_response_prepare_headers(wsgi_req, \"302 Found\", 9)) return -1;\n\t\t\t\t\treturn 1;\n                                }\n\t\t\t}\n\n                        key = NULL;\n                        value = NULL;\n\t\t}\n                else if (buf[i] == ':') {\n\t\t\tvalue = buf+i;\n                }\n                else if (buf[i] != '\\r') {\n                \tif (key == NULL) key = buf + i;\n                }\n\n\t}\n\n\t// no Status/Location found\n\treturn 0;\n\n}\n\nstatic int uwsgi_cgi_parse(struct wsgi_request *wsgi_req, int fd, char *buf, size_t blen) {\n\n\tsize_t i;\n\tsize_t header_size = 0;\n\tint status_sent = 0;\n\tsize_t remains = blen;\n\tchar *ptr = buf;\n\tsize_t len = 0;\n\n\twhile(remains > 0) {\n\t\tssize_t rlen = uwsgi_read_true_nb(fd, ptr, remains, uc.timeout);\n\t\tif (rlen < 0) {\n\t\t\tif (!errno) return 1;\n\t\t\treturn -1;\n\t\t}\n\t\t// timed out\n\t\tif (rlen == 0) return -1;\n\t\tremains -= rlen;\n\t\tlen += rlen;\n\t\tptr += rlen;\n\n\t\t// Search for Status/Location headers\n\t\tif (!status_sent) {\n\t\t\tstatus_sent = uwsgi_cgi_check_status(wsgi_req, buf, len); \n\t\t\tif (status_sent < 0) return -1;\n\t\t\t// need more data ?\n\t\t\tif (status_sent == 0) continue;\n\t\t}\n\n\t\t// send headers\n\t\tchar *key = buf;\n\t\tchar *value = NULL;\n\n\t\tfor(i=0;i<len;i++) {\n\t\t\t// end of a line\n\t\t\tif (buf[i] == '\\n') {\n\t\t\t\t// end of headers\n\t\t\t\tif (key == NULL) {\n\t\t\t\t\ti++;\n\t\t\t\t\tgoto send_body;\n\t\t\t\t}\n\t\t\t\t// invalid header\n\t\t\t\telse if (value == NULL) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\theader_size = (buf+i) - key;\n\t\t\t\t// security check\n\t\t\t\tif (buf+i > buf) {\n\t\t\t\t\tif ((buf[i-1]) == '\\r') {\n\t\t\t\t\t\theader_size--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"found CGI header: %.*s\\n\", header_size, key);\n#endif\n\n\t\t\t\t// Ignore \"Status: NNN\" header\n\t\t\t\tif (header_size >= 11) {\n\t\t\t\t\tif (!strncasecmp(\"Status: \", key, 8)) {\n\t\t\t\t\t\tkey = NULL;\n\t\t\t\t\t\tvalue = NULL;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuwsgi_response_add_header(wsgi_req, NULL, 0, key, header_size);\n\t\t\t\tkey = NULL;\n\t\t\t\tvalue = NULL;\n\t\t\t}\n\t\t\telse if (buf[i] == ':') {\n\t\t\t\tvalue = buf+i;\n\t\t\t}\n\t\t\telse if (buf[i] != '\\r') {\n\t\t\t\tif (key == NULL) {\n\t\t\t\t\tkey = buf + i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n\nsend_body:\n\n\tif (len-i > 0) {\n\t\tuwsgi_response_write_body_do(wsgi_req, buf+i, len-i);\n\t}\n\n\treturn 0;\t\n}\n\nstatic char *uwsgi_cgi_get_docroot(char *path_info, uint16_t path_info_len, int *need_free, int *is_a_file, int *discard_base, char **script_name) {\n\n\tstruct uwsgi_dyn_dict *udd = uc.mountpoint, *choosen_udd = NULL;\n\tint best_found = 0;\n\tstruct stat st;\n\tchar *path = NULL;\n\n\tif (uc.has_mountpoints) {\n\t\twhile(udd) {\n\t\t\tif (udd->vallen) {\n\t\t\t\tif (!uwsgi_starts_with(path_info, path_info_len, udd->key, udd->keylen) && udd->keylen > best_found) {\n\t\t\t\t\tbest_found = udd->keylen ;\n\t\t\t\t\tchoosen_udd = udd;\n\t\t\t\t\tpath = udd->value;\n\t\t\t\t\t*script_name = udd->key;\n\t\t\t\t\t*discard_base = udd->keylen;\n\t\t\t\t\tif (udd->key[udd->keylen-1] == '/') {\n\t\t\t\t\t\t*discard_base = *discard_base-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tudd = udd->next;\n\t\t}\n\t}\n\n\tif (choosen_udd == NULL) {\n\t\tchoosen_udd = uc.default_cgi;\n\t\tif (!choosen_udd) return NULL;\n\t\tpath = choosen_udd->key;\n\t}\n\n\tif (choosen_udd->status == 0) {\n\t\tchar *tmp_udd = uwsgi_malloc(PATH_MAX+1);\n\t\tif (!realpath(path, tmp_udd)) {\n\t\t\tfree(tmp_udd);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (stat(tmp_udd, &st)) {\n\t\t\tuwsgi_error(\"stat()\");\n\t\t\tfree(tmp_udd);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\t*is_a_file = 1;\n\t\t}\n\n\t\t*need_free = 1;\n\t\treturn tmp_udd;\n\t}\n\n\tif (choosen_udd->status == 2)\n\t\t*is_a_file = 1;\n\treturn path;\n}\n\nstatic int uwsgi_cgi_walk(struct wsgi_request *wsgi_req, char *full_path, char *docroot, size_t docroot_len, int discard_base, char **path_info) {\n\n\t// and now start walking...\n        uint16_t i;\n        char *ptr = wsgi_req->path_info+discard_base;\n        char *dst = full_path+docroot_len;\n        char *part = ptr;\n        int part_size = 0;\n\tstruct stat st;\n\n\tif (wsgi_req->path_info_len == 0) return 0;\n\n        if (ptr[0] == '/') part_size++;\n\n        for(i=0;i<wsgi_req->path_info_len-discard_base;i++) {\n        \tif (ptr[i] == '/') {\n                \tmemcpy(dst, part, part_size-1);\n                        *(dst+part_size-1) = 0;\n\n                        if (stat(full_path, &st)) {\n                        \tuwsgi_404(wsgi_req);\n                                return -1;\n                        }\n\n\n\t\t\t// not a directory, stop walking\n                        if (!S_ISDIR(st.st_mode)) {\n\t\t\t\tif (i < (wsgi_req->path_info_len-discard_base)-1) {\n                        \t\t*path_info = ptr + i;\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n                        }\n\n\n\t\t\t// check for buffer overflow !!!\n                        *(dst+part_size-1) = '/';\n                        *(dst+part_size) = 0;\n\n                        dst += part_size ;\n                        part_size = 0;\n                        part = ptr + i + 1;\n         \t}\n\n                part_size++;\n\t}\n\n\tif (part < wsgi_req->path_info+wsgi_req->path_info_len) {\n\t\tmemcpy(dst, part, part_size-1);\n\t\t*(dst+part_size-1) = 0;\n\t}\n\n\treturn 0;\n\n\n}\n\nstatic int uwsgi_cgi_run(struct wsgi_request *, char *, size_t, char *, char *, char *, char *, int, int);\n\nstatic int uwsgi_cgi_request(struct wsgi_request *wsgi_req) {\n\n\tchar full_path[PATH_MAX];\n\tchar tmp_path[PATH_MAX];\n\tstruct stat cgi_stat;\n\tint need_free = 0;\n\tint is_a_file = 0;\n\tint discard_base = 0;\n\tsize_t docroot_len = 0;\n\tsize_t full_path_len = 0;\n\tchar *helper = NULL;\n\tchar *path_info = NULL;\n\tchar *script_name = NULL;\n\n\t/* Standard CGI request */\n\tif (!wsgi_req->uh->pktsize) {\n\t\tuwsgi_log(\"Empty CGI request. skip.\\n\");\n\t\treturn -1;\n\t}\n\n\n\tif (uwsgi_parse_vars(wsgi_req)) {\n\t\treturn -1;\n\t}\n\n\tchar *docroot = NULL;\n\n\t// check for file availability (and 'runnability')\n\tif (uc.from_docroot) {\n\t\tdocroot = wsgi_req->document_root;\t\n\t\tdocroot_len = wsgi_req->document_root_len;\t\n\t}\n\telse {\n\t\tdocroot = uwsgi_cgi_get_docroot(wsgi_req->path_info, wsgi_req->path_info_len, &need_free, &is_a_file, &discard_base, &script_name);\n\t\tif (docroot)\n\t\t\tdocroot_len = strlen(docroot);\n\t}\n\n\tif (docroot == NULL || docroot_len == 0) {\n\t\tuwsgi_404(wsgi_req);\n\t\treturn UWSGI_OK;\n\t}\n\n\tmemcpy(full_path, docroot, docroot_len);\n\n\tif (!is_a_file) {\n\n\t\t*(full_path+docroot_len) = '/';\n\t\t*(full_path+docroot_len+1) = 0;\n\n\t\tif (uwsgi_cgi_walk(wsgi_req, full_path, docroot, docroot_len, discard_base, &path_info)) {\n\t\t\tif (need_free)\n\t\t\t\tfree(docroot);\n\t\t\treturn UWSGI_OK;\n\t\t}\n\n\t\tif (realpath(full_path, tmp_path) == NULL) {\n\t\t\tif (need_free)\n\t\t\t\tfree(docroot);\n\t\t\tuwsgi_404(wsgi_req);\n\t\t\treturn UWSGI_OK;\n\t\t}\n\n\t\tfull_path_len = strlen(tmp_path);\n\t\t// add +1 to copy the null byte\n\t\tmemcpy(full_path, tmp_path, full_path_len+1);\n\n\t\tstruct uwsgi_string_list *safe = uc.cgi_safe;\n\t\twhile(safe) {\n\t\t\tif (!uwsgi_starts_with(full_path, full_path_len, safe->value, safe->len))\n\t\t\t\tbreak;\n\t\t\tsafe = safe->next;\n\t\t}\n\n\t\tif (!safe) {\n\t\t\tif (uwsgi_starts_with(full_path, full_path_len, docroot, docroot_len)) {\n\t\t\t\tuwsgi_log(\"CGI security error: %s is not under %s\\n\", full_path, docroot);\n\t\t\t\tif (need_free)\n\t\t\t\t\tfree(docroot);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t}\n\telse {\n\t\t*(full_path+docroot_len) = 0;\n\t\tpath_info = wsgi_req->path_info+discard_base;\n\t}\n\n\tif (stat(full_path, &cgi_stat)) {\n\t\tuwsgi_404(wsgi_req);\n\t\tif (need_free)\n\t\t\tfree(docroot);\n\t\treturn UWSGI_OK;\n\t}\n\n\tif (S_ISDIR(cgi_stat.st_mode)) {\n\n\t\t// add / to directories\n\t\tif (wsgi_req->path_info_len == 0 || (wsgi_req->path_info_len > 0 && wsgi_req->path_info[wsgi_req->path_info_len-1] != '/')) {\n\t\t\tuwsgi_redirect_to_slash(wsgi_req);\n\t\t\tif (need_free)\n                        \tfree(docroot);\n                \treturn UWSGI_OK;\n\t\t}\n\t\tstruct uwsgi_string_list *ci = uc.index;\n\t\tfull_path[full_path_len] = '/';\n\t\tfull_path_len++;\n\t\tint found = 0;\n\t\twhile(ci) {\n\t\t\tif (full_path_len + ci->len + 1 < PATH_MAX) {\n\t\t\t\t// add + 1 to ensure null byte\n\t\t\t\tmemcpy(full_path+full_path_len, ci->value, ci->len + 1);\n\t\t\t\tif (!access(full_path, R_OK)) {\n\t\t\t\t\t\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tci = ci->next;\n\t\t}\n\n\t\tif (!found) {\n\t\t\tuwsgi_404(wsgi_req);\n\t\t\tif (need_free)\n\t\t\t\tfree(docroot);\n\t\t\treturn UWSGI_OK;\n\t\t}\n\n\t}\n\n\tfull_path_len = strlen(full_path);\n\n\tint cgi_allowed = 1;\n\tstruct uwsgi_string_list *allowed = uc.allowed_ext;\n\twhile(allowed) {\n\t\tcgi_allowed = 0;\n\t\tif (full_path_len >= allowed->len) {\n\t\t\tif (!uwsgi_strncmp(full_path+(full_path_len-allowed->len), allowed->len, allowed->value, allowed->len)) {\n\t\t\t\tcgi_allowed = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tallowed = allowed->next;\n\t}\n\n\tif (!cgi_allowed) {\n\t\tuwsgi_403(wsgi_req);\n\t\tif (need_free)\n\t\t\tfree(docroot);\n\t\treturn UWSGI_OK;\n\t}\n\n\t// get the helper\n\tif (!is_a_file) {\n\t\thelper = uwsgi_cgi_get_helper(full_path);\n\n\t\tif (helper == NULL) {\n\t\t\tif (access(full_path, X_OK)) {\n\t\t\t\tuwsgi_error(\"access()\");\n\t\t\t\tuwsgi_403(wsgi_req);\n                \t\tif (need_free)\n                        \t\tfree(docroot);\n\t\t\t\treturn UWSGI_OK;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = uwsgi_cgi_run(wsgi_req, docroot, docroot_len, full_path, helper, path_info, script_name, is_a_file, discard_base);\n\tif (need_free) free(docroot);\n\treturn ret;\n}\n\nstatic int uwsgi_cgi_run(struct wsgi_request *wsgi_req, char *docroot, size_t docroot_len, char *full_path, char *helper, char *path_info, char *script_name, int is_a_file, int discard_base) {\n\n\tint cgi_pipe[2];\n\tint post_pipe[2];\n\tint nargs = 0;\n\tint waitpid_status;\n\tint i;\n\tchar **argv;\n\n\tchar *command = full_path;\n\tint stdin_closed = 0;\n\n\tif (is_a_file) {\n                command = docroot;\n        }\n\n\tif (pipe(cgi_pipe)) {\n\t\tuwsgi_error(\"uwsgi_cgi_run()/pipe()\");\n\t\treturn UWSGI_OK;\n\t}\n\n\tif (pipe(post_pipe)) {\n\t\tclose(cgi_pipe[0]);\n\t\tclose(cgi_pipe[1]);\n\t\tuwsgi_error(\"uwsgi_cgi_run()/pipe()\");\n\t\treturn UWSGI_OK;\n\t}\n\n\tpid_t cgi_pid = fork();\n\n\tif (cgi_pid < 0) {\n\t\tuwsgi_error(\"uwsgi_cgi_run()/fork()\");\n\t\tclose(cgi_pipe[0]);\n\t\tclose(cgi_pipe[1]);\n\t\tclose(post_pipe[0]);\n\t\tclose(post_pipe[1]);\n\t\treturn UWSGI_OK;\n\t}\n\n\tif (cgi_pid > 0) {\n\n\t\tclose(cgi_pipe[1]);\n\t\tclose(post_pipe[0]);\n\n\t\tuwsgi_socket_nb(cgi_pipe[0]);\n\t\tuwsgi_socket_nb(post_pipe[1]);\n\n\t\t// ok start sending post data...\n\t\tsize_t remains = wsgi_req->post_cl;\n\t\twhile(remains > 0) {\n                \tssize_t rlen = 0;\n                \tchar *buf = uwsgi_request_body_read(wsgi_req, 8192, &rlen);\n                \tif (!buf) {\n\t\t\t\tgoto clear2;\n                \t}\n                \tif (buf == uwsgi.empty) break;\n                \t// write data to the node\n                \tif (uwsgi_write_true_nb(post_pipe[1], buf, rlen, uc.timeout)) {\n\t\t\t\tgoto clear2;\n                \t}\n                \tremains -= rlen;\n        \t}\n\n\t\tif (uc.close_stdin_on_eof) {\n\t\t\tclose(post_pipe[1]);\n\t\t\tstdin_closed = 1;\n\t\t}\n\n\t\t// wait for data\n\t\tchar *buf = uwsgi_malloc(uc.buffer_size);\n\n\t\tint completed = uwsgi_cgi_parse(wsgi_req, cgi_pipe[0], buf, uc.buffer_size);\n\t\tif (completed < 0) {\n\t\t\tuwsgi_log(\"invalid CGI response !!!\\n\");\n\t\t\tkill_on_error\n\t\t\tgoto clear;\n\t\t}\n\n\t\twhile (!completed) {\n\t\t\tssize_t rlen = uwsgi_read_true_nb(cgi_pipe[0], buf, uc.buffer_size, uc.timeout);\n\t\t\tif (rlen > 0) {\n\t\t\t\tif (uwsgi_response_write_body_do(wsgi_req, buf, rlen)) {\n\t\t\t\t\tkill_on_error\n\t\t\t\t\tgoto clear;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (rlen == 0) {\n\t\t\t\tuwsgi_log(\"CGI timeout !!!\\n\");\n\t\t\t\tkill_on_error\n\t\t\t\tgoto clear;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (errno) {\n\t\t\t\t\tuwsgi_req_error(\"error reading CGI response\\n\");\n\t\t\t\t\tkill_on_error\n\t\t\t\t}\n\t\t\t\tgoto clear;\n\t\t\t}\n\t\t}\n\nclear:\n\t\tfree(buf);\nclear2:\n\t\tclose(cgi_pipe[0]);\n\t\tif (!stdin_closed)\n\t\t\tclose(post_pipe[1]);\n\n\t\t// now wait for process exit/death\n\t\t// in async mode we need a trick...\n\t\tif (uwsgi.async > 1) {\n\t\t\tpid_t diedpid = waitpid(cgi_pid, &waitpid_status, WNOHANG);\n\t\t\tif (diedpid < 0) {\n                               \tuwsgi_error(\"waitpid()\");\n                        }\n\t\t\telse if (diedpid == 0) {\n\t\t\t\t// pass the pid of the cgi to async_plagued (the after request hook will clear the process)\n\t\t\t\twsgi_req->async_plagued = (int) cgi_pid;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (waitpid(cgi_pid, &waitpid_status, 0) < 0) {\n\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t}\n\t\t}\n\n\t\treturn UWSGI_OK;\n\t}\n\n\t// now map wsgi_req->poll.fd (or async_post) to 0 & cgi_pipe[1] to 1\n\tdup2(post_pipe[0], 0);\n\tclose(post_pipe[0]);\n\n\tdup2(cgi_pipe[1],1);\n\tclose(cgi_pipe[1]);\n\n\t// close all the fd > 2\n\tfor(i=3;i<(int)uwsgi.max_fd;i++) {\n\t\tclose(i);\n\t}\n\n\t// fill cgi env\n\tfor(i=0;i<wsgi_req->var_cnt;i+=2) {\n\t\t// no need to free the putenv() memory\n\t\tif (putenv(uwsgi_concat3n(wsgi_req->hvec[i].iov_base, wsgi_req->hvec[i].iov_len, \"=\", 1, wsgi_req->hvec[i+1].iov_base, wsgi_req->hvec[i+1].iov_len))) {\n\t\t\tuwsgi_error(\"putenv()\");\n\t\t}\n\t}\n\n\n\tif (setenv(\"GATEWAY_INTERFACE\", \"CGI/1.1\", 0)) {\n\t\tuwsgi_error(\"setenv()\");\n\t}\n\n\tif (setenv(\"SERVER_SOFTWARE\", uwsgi_concat2(\"uWSGI/\", UWSGI_VERSION), 0)) {\n\t\tuwsgi_error(\"setenv()\");\n\t}\n\n\t// for newer php\n\tif (setenv(\"REDIRECT_STATUS\", \"200\", 0)) {\n\t\tuwsgi_error(\"setenv()\");\n\t}\n\n\n\n\tif (path_info) {\n\n\t\tsize_t pi_len = wsgi_req->path_info_len - (path_info - wsgi_req->path_info);\n\n\t\tif (setenv(\"PATH_INFO\", uwsgi_concat2n(path_info, pi_len, \"\", 0), 1)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tif (wsgi_req->document_root_len > 0) {\n\t\t\tif (setenv(\"PATH_TRANSLATED\", uwsgi_concat3n(wsgi_req->document_root, wsgi_req->document_root_len, path_info, pi_len, \"\", 0) , 1)) {\n\t\t\t\tuwsgi_error(\"setenv()\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (setenv(\"PATH_TRANSLATED\", uwsgi_concat3n(docroot, docroot_len, path_info, pi_len, \"\", 0) , 1)) {\n\t\t\t\tuwsgi_error(\"setenv()\");\n\t\t\t}\n\t\t}\n\n\t}\n\telse {\n\t\tunsetenv(\"PATH_INFO\");\n\t\tunsetenv(\"PATH_TRANSLATED\");\n\t}\n\n\tif (is_a_file) {\n\t\tif (setenv(\"DOCUMENT_ROOT\", uwsgi.cwd, 0)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tif (setenv(\"SCRIPT_FILENAME\", docroot, 0)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tif (script_name && discard_base > 1) {\n\t\t\tif (setenv(\"SCRIPT_NAME\", uwsgi_concat2n(script_name, discard_base, \"\", 0), 1)) {\n\t\t\t\tuwsgi_error(\"setenv()\");\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (setenv(\"DOCUMENT_ROOT\", docroot, 0)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tif (setenv(\"SCRIPT_FILENAME\", full_path, 0)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tif (setenv(\"SCRIPT_NAME\", uwsgi_concat2n(wsgi_req->path_info, discard_base, full_path+docroot_len, strlen(full_path+docroot_len)), 1)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t}\n\n\t\tchar *base = uwsgi_get_last_char(full_path, '/');\n\t\tif (base) {\n\t\t\t// a little trick :P\n\t\t\t*base = 0;\n\t\t\tif (chdir(full_path)) {\n                                uwsgi_error(\"chdir()\");\n                        }\n\t\t\t*base = '/';\n\t\t}\n\t\telse if (docroot_len > 0) {\n\t\t\tif (chdir(docroot)) {\n\t\t\t\tuwsgi_error(\"chdir()\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstruct uwsgi_string_list *drop_env = uc.unset;\n\twhile(drop_env) {\n\t\tunsetenv(drop_env->value);\n\t\tdrop_env = drop_env->next;\n\t}\n\n\targv = uwsgi_malloc(sizeof(char *) * 3);\n\n\t// check if we need to parse indexed QUERY_STRING\n\tif (wsgi_req->query_string_len > 0) {\n\t\tif (!memchr(wsgi_req->query_string, '=', wsgi_req->query_string_len)) {\n\t\t\tnargs = 1;\n\t\t\tfor(i=0;i<wsgi_req->query_string_len;i++) {\n\t\t\t\tif (wsgi_req->query_string[i] == '+')\n\t\t\t\t\tnargs++;\n\t\t\t}\n\n\t\t\t\n\t\t\t// reallocate argv and qs\n\t\t\targv = uwsgi_malloc(sizeof(char *) * (3+nargs));\n\t\t\tchar *qs = uwsgi_concat2n(wsgi_req->query_string, wsgi_req->query_string_len, \"\", 0);\n\t\t\t// set the start position of args in argv\n\t\t\ti = 1;\n\t\t\tif (helper) i = 2;\n\t\t\tchar *p, *ctx = NULL;\n\t\t\tuwsgi_foreach_token(qs, \"+\", p, ctx) {\n\t\t\t\t// create a copy for the url_decoded string\n\t\t\t\tchar *arg_copy = uwsgi_str(p);\n\t\t\t\tuint16_t arg_copy_len = strlen(p);\n\t\t\t\thttp_url_decode(p, &arg_copy_len, arg_copy);\n\t\t\t\t// and a final copy for shell escaped arg\n\t\t\t\targv[i] = uwsgi_malloc( (arg_copy_len * 2) +1);\n\t\t\t\tescape_shell_arg(arg_copy, arg_copy_len, argv[i]);\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfree(qs);\n\t\t}\n\t}\n\n\tif (helper) {\n\t\tif (!uwsgi_starts_with(helper, strlen(helper), \"sym://\", 6)) {\n\t\t\tvoid (*cgi_func)(char *) = dlsym(RTLD_DEFAULT, helper+6);\n\t\t\tif (cgi_func) {\n\t\t\t\tcgi_func(command);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_log(\"unable to find symbol %s\\n\", helper+6);\n\t\t\t}\n\t\t\texit(0);\t\n\t\t}\n\t\targv[0] = helper;\n\t\targv[1] = command;\n\t\targv[nargs+2] = NULL;\n\t}\n\telse {\n\t\targv[0] = command;\n\t\targv[nargs+1] = NULL;\n\t}\n\n\tif (execvp(argv[0], argv)) {\n\t\tuwsgi_error(\"uwsgi_cgi_run()/execvp()\");\n\t}\n\n\t// never here\n\texit(1);\n}\n\n\nstatic void uwsgi_cgi_after_request(struct wsgi_request *wsgi_req) {\n\tif (wsgi_req->async_plagued > 0) {\n\t\tint waitpid_status;\n\t\tpid_t cgi_pid = (pid_t) wsgi_req->async_plagued;\n\t\tint max_attempts = uc.async_max_attempts;\n                        if (!max_attempts) max_attempts = 10;\n                        while(max_attempts) {\n                                pid_t diedpid = waitpid(cgi_pid, &waitpid_status, WNOHANG);\n                                if (diedpid < 0) {\n                                        uwsgi_error(\"waitpid()\");\n                                        break;\n                                }\n                                else if (diedpid == 0) {\n                                        int ret = uwsgi.wait_milliseconds_hook(1000);\n                                        if (ret < 0) {\n                                                kill_on_error\n\t\t\t\t\t\tif (waitpid(cgi_pid, &waitpid_status, 0) < 0) {\n                                \t\t\tuwsgi_error(\"waitpid()\");\n                        \t\t\t}\n                                        }\n                                }\n                                else {\n                                        break;\n                                }\n                                max_attempts--;\n                        }\n                        if (max_attempts == 0) {\n                                kill_on_error\n\t\t\t\tif (waitpid(cgi_pid, &waitpid_status, 0) < 0) {\n                                \tuwsgi_error(\"waitpid()\");\n                        \t}\n                        }\n\t}\n\n\tlog_request(wsgi_req);\n}\n\n#ifdef UWSGI_ROUTING\nstatic int uwsgi_routing_func_cgi(struct wsgi_request *wsgi_req, struct uwsgi_route *ur){\n\n        char **subject = (char **) (((char *)(wsgi_req))+ur->subject);\n        uint16_t *subject_len = (uint16_t *) (((char *)(wsgi_req))+ur->subject_len);\n\n        struct uwsgi_buffer *ub_command = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, ur->data, ur->data_len);\n        if (!ub_command) return UWSGI_ROUTE_BREAK;\n\tstruct uwsgi_buffer *ub_helper = NULL;\n\tif (ur->data2_len) {\n\t\tub_helper = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, ur->data2, ur->data2_len);\n\t\tif (!ub_helper) {\n\t\t\tuwsgi_buffer_destroy(ub_command);\n        \t\treturn UWSGI_ROUTE_BREAK;\n\t\t}\n\t}\n\telse {\n\t\tif (!uwsgi_is_file(ub_command->buf)) {\n\t\t\tuwsgi_404(wsgi_req);\n\t\t\tuwsgi_buffer_destroy(ub_command);\n\t\t\treturn UWSGI_ROUTE_BREAK;\n\t\t}\n\n\t\tif (access(ub_command->buf, X_OK)) {\n\t\t\tuwsgi_403(wsgi_req);\n\t\t\tuwsgi_buffer_destroy(ub_command);\n\t\t\treturn UWSGI_ROUTE_BREAK;\n\t\t}\n\t}\n\t// we need a NULL suffix-ed copy of the docroot\n\tchar *docroot = uwsgi_concat2n(wsgi_req->document_root, wsgi_req->document_root_len, \"\", 0);\n        uwsgi_cgi_run(wsgi_req, wsgi_req->document_root, wsgi_req->document_root_len, ub_command->buf, ub_helper ? ub_helper->buf : NULL, NULL, NULL, 0, 0 );\n\tfree(docroot);\n        uwsgi_buffer_destroy(ub_command);\n\tif (ub_helper) uwsgi_buffer_destroy(ub_helper);\n        return UWSGI_ROUTE_BREAK;\n}\n\nstatic int uwsgi_router_cgi_helper(struct uwsgi_route *ur, char *args) {\n        ur->func = uwsgi_routing_func_cgi;\n\tchar *space = strchr(args, ' ');\n\tif (!space) {\n\t\tuwsgi_log(\"invalid cgihelper syntax, must be \\\"cgihelper:helper command\\\"\\n\");\n\t\treturn -1;\n\t}\n\t*space = 0;\n        ur->data = space+1;\n        ur->data_len = strlen(space+1);\n\tur->data2 = args;\n\tur->data2_len = strlen(args);\n        return 0;\n}\nstatic int uwsgi_router_cgi(struct uwsgi_route *ur, char *args) {\n        ur->func = uwsgi_routing_func_cgi;\n\tur->data = args;\n\tur->data_len = strlen(args);\n        return 0;\n}\nstatic void uwsgi_cgi_register_router() {\n        uwsgi_register_router(\"cgi\", uwsgi_router_cgi);\n        uwsgi_register_router(\"cgihelper\", uwsgi_router_cgi_helper);\n}\n#endif\n\nstruct uwsgi_plugin cgi_plugin = {\n\n\t.name = \"cgi\",\n\t.modifier1 = 9,\n\t.init = uwsgi_cgi_init,\n\t.init_apps = uwsgi_cgi_apps,\n\t.options = uwsgi_cgi_options,\n\t.request = uwsgi_cgi_request,\n\t.after_request = uwsgi_cgi_after_request,\n#ifdef UWSGI_ROUTING\n        .on_load = uwsgi_cgi_register_router,\n#endif\n\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/plugins/libffi/libffi.c": "#include <uwsgi.h>\n#include <ffi.h>\n\nffi_type *uwsgi_libffi_get_type(char *what, size_t *skip) {\n\tif (!uwsgi_startswith(what, \"int:\", 4)) { *skip = 4; return &ffi_type_sint32;}\n\tif (!uwsgi_startswith(what, \"sint:\", 5)) { *skip = 5; return &ffi_type_sint32;}\n\tif (!uwsgi_startswith(what, \"uint:\", 5)) { *skip = 5;return &ffi_type_uint32;}\n\treturn &ffi_type_pointer;\n}\n\nvoid *uwsgi_libffi_get_value(char *what, ffi_type *t) {\n\tif (t == &ffi_type_sint32) {\n\t\tint32_t *num = uwsgi_malloc(sizeof(int32_t));\n\t\t*num = atoi(what);\n\t\treturn num;\n\t}\n\treturn NULL;\n}\n\nstatic int uwsgi_libffi_hook(char *arg) {\n\tsize_t argc = 0;\n\tsize_t i;\n\tchar **argv = uwsgi_split_quoted(arg, strlen(arg), \" \\t\", &argc);\n\tif (!argc) goto end;\n\t\n\tvoid *func = dlsym(RTLD_DEFAULT, argv[0]);\n\tif (!func) goto destroy;\n\n\tffi_cif cif;\n\tffi_type **args_type = (ffi_type **) uwsgi_malloc(sizeof(ffi_type) * (argc-1));\n\tvoid **values = uwsgi_malloc(sizeof(void*) * (argc-1));\n\tfor(i=1;i<argc;i++) {\n\t\tsize_t skip = 0;\n\t\targs_type[i-1] = uwsgi_libffi_get_type(argv[i], &skip);\n\t\tvoid *v = uwsgi_libffi_get_value(argv[i] + skip, args_type[i-1]);\n\t\tvalues[i-1] = v ? v : &argv[i];\n\t\tuwsgi_log(\"%d = %s %p\\n\", i, argv[i], values[i-1]);\n\t}\n\n\tif (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, argc-1, &ffi_type_sint64, args_type) == FFI_OK) {\n\t\tint64_t rc = 0;\n\t\tuwsgi_log(\"ready to call\\n\");\n\t\tffi_call(&cif, func, &rc, values); \n\t}\n\n\tuwsgi_log(\"ready to call2\\n\");\n\tfor(i=0;i<(argc-1);i++) {\n\t\tchar **ptr = (char **) values[i];\n\t\tif (*ptr != argv[i+1]) {\n\t\t\tfree(values[i]);\n\t\t}\n\t}\n\tfree(args_type);\n\tfree(values);\ndestroy:\n\tfor(i=0;i<argc;i++) {\n\t\tfree(argv[i]);\n\t}\nend:\n\tfree(argv);\n\treturn -1;\n}\n\nstatic void uwsgi_libffi_setup() {\n\tuwsgi_register_hook(\"ffi\", uwsgi_libffi_hook);\n}\n\nstruct uwsgi_plugin libffi_plugin = {\n\t.name = \"libffi\",\n\t.on_load = uwsgi_libffi_setup,\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/core/metrics.c": "#include <uwsgi.h>\n\nextern struct uwsgi_server uwsgi;\n\n/*\n\n\tuWSGI metrics subsystem\n\n\ta metric is a node in a linked list reachable via a numeric id (OID, in SNMP way) or a simple string:\n\n\tuwsgi.worker.1.requests\n\tuwsgi.custom.foo.bar\n\n\tthe oid representation:\n\n\t\t1.3.6.1.4.1.35156.17 = iso.org.dod.internet.private.enterprise.unbit.uwsgi\n\t\t1.3.6.1.4.1.35156.17.3.1.1 = iso.org.dod.internet.private.enterprise.unbit.uwsgi.worker.1.requests\n\t\t1.3.6.1.4.1.35156.17.3.1.1 = iso.org.dod.internet.private.enterprise.unbit.uwsgi.worker.1.requests\n\t\t1.3.6.1.4.1.35156.17.3.1.2.1.1 = iso.org.dod.internet.private.enterprise.unbit.uwsgi.worker.1.core.1.requests\n\t\t...\n\n\teach metric is a collected value with a specific frequency\n\tmetrics are meant for numeric values signed 64 bit, but they can be exposed as:\n\n\tgauge\n\tcounter\n\tabsolute\n\n\tmetrics are managed by a dedicated thread (in the master) holding a linked list of all the items. For few metrics it is a good (read: simple) approach,\n\tbut you can cache lookups in a uWSGI cache for really big list. (TODO)\n\n\tstruct uwsgi_metric *um = uwsgi_register_metric(\"worker.1.requests\", \"3.1.1\", UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[1].requests, 0, NULL);\n\tprototype: struct uwsgi_metric *uwsgi_register_metric(char *name, char *oid, uint8_t value_type, char *collector, void *ptr, uint32_t freq, void *custom);\n\n\tvalue_type = UWSGI_METRIC_COUNTER/UWSGI_METRIC_GAUGE/UWSGI_METRIC_ABSOLUTE\n\tcollect_way = \"ptr\" -> get from a pointer / UWSGI_METRIC_FUNC -> get from a func with the prototype int64_t func(struct uwsgi_metric *); / UWSGI_METRIC_FILE -> get the value from a file, ptr is the filename\n\n\tFor some metric (or all ?) you may want to hold a value even after a server reload. For such a reason you can specify a directory on wich the server (on startup/restart) will look for\n\ta file named like the metric and will read the initial value from it. It may look an old-fashioned and quite inefficient way, but it is the most versatile for a sysadmin (allowing him/her\n\tto even modify the values manually)\n\n\tWhen registering a metric with the same name of an already registered one, the new one will overwrite the previous one. This allows plugins writer to override default behaviours\n\n\tApplications are allowed to update metrics (but they cannot register new ones), with simple api funcs:\n\n\tuwsgi.metric_set(\"worker.1.requests\", N)\n\tuwsgi.metric_inc(\"worker.1.requests\", N=1)\n\tuwsgi.metric_dec(\"worker.1.requests\", N=1)\n\tuwsgi.metric_mul(\"worker.1.requests\", N=1)\n\tuwsgi.metric_div(\"worker.1.requests\", N=1)\n\n\tand obviously they can get values:\n\n\tuwsgi.metric_get(\"worker.1.requests\")\n\n\tUpdating metrics from your app MUST BE ATOMIC, for such a reason a uWSGI rwlock is initialized on startup and used for each operation (simple reading from a metric does not require locking)\n\n\tMetrics can be updated from the internal routing subsystem too:\n\n\t\troute-if = equal:${REQUEST_URI};/foobar metricinc:foobar.test 2\n\n\tand can be accessed as ${metric[foobar.test]}\n\n\tThe stats server exports the metrics list in the \"metrics\" attribute (obviously some info could be redundant)\n\n*/\n\n\nint64_t uwsgi_metric_collector_file(struct uwsgi_metric *metric) {\n\tchar *filename = metric->arg1;\n\tif (!filename) return 0;\n\tint split_pos = metric->arg1n;\n\n\tchar buf[4096];\n\tint64_t ret = 0;\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(filename);\n\t\treturn 0;\n\t}\n\n\tssize_t rlen = read(fd, buf, 4096);\n\tif (rlen <= 0) goto end;\n\n\tchar *ptr = buf;\n\tssize_t i;\n\tint pos = 0;\n\tint found = 0;\n\tfor(i=0;i<rlen;i++) {\n\t\tif (!found) {\n\t\t\tif (buf[i] == ' ' || buf[i] == '\\t' || buf[i] == '\\r' || buf[i] == 0 || buf[i] == '\\n') {\n\t\t\t\tif (pos == split_pos) goto found;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!(buf[i] == ' ' || buf[i] == '\\t' || buf[i] == '\\r' || buf[i] == 0 || buf[i] == '\\n')) {\n\t\t\t\tfound = 0;\n\t\t\t\tptr = buf + i;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pos == split_pos) goto found;\n\tgoto end;\nfound:\n\tret = strtoll(ptr, NULL, 10);\nend:\n\tclose(fd);\n\treturn ret;\n\n}\n\n\n\n/*\n\n\tallowed chars for metrics name\n\n\t0-9\n\ta-z\n\tA-Z\n\t.\n\t-\n\t_\n\n*/\n\nstatic int uwsgi_validate_metric_name(char *buf) {\n\tsize_t len = strlen(buf);\n\tsize_t i;\n\tfor(i=0;i<len;i++) {\n\t\tif ( !(\n\t\t\t(buf[i] >= '0' && buf[i] <= '9') ||\n\t\t\t(buf[i] >= 'a' && buf[i] <= 'z') ||\n\t\t\t(buf[i] >= 'A' && buf[i] <= 'Z') ||\n\t\t\tbuf[i] == '.' || buf[i] == '-' || buf[i] == '_'\n\t\t)) {\n\n\t\t\treturn 0;\n\t\t\n\t\t}\n\t}\t\n\n\treturn 1;\n}\n\n/*\n\n\tallowed chars for metrics oid\n\n\t0-9\n\t.\n\n\toids can be null\n*/\n\nstatic int uwsgi_validate_metric_oid(char *buf) {\n\tif (!buf) return 1;\n        size_t len = strlen(buf);\n        size_t i;\n        for(i=0;i<len;i++) {\n                if ( !(\n                        (buf[i] >= '0' && buf[i] <= '9') ||\n                        buf[i] == '.'\n                )) {\n                \n                        return 0;\n                \n                }\n        }\n\n        return 1;\n}\n\nvoid uwsgi_metric_append(struct uwsgi_metric *um) {\n\tstruct uwsgi_metric *old_metric=NULL,*metric=uwsgi.metrics;\n\twhile(metric) {\n\t\told_metric = metric;\n                metric = metric->next;\n\t}\n\n\tif (old_metric) {\n                       old_metric->next = um;\n        }\n        else {\n        \tuwsgi.metrics = um;\n        }\n\n        uwsgi.metrics_cnt++;\n}\n\nstruct uwsgi_metric_collector *uwsgi_metric_collector_by_name(char *name) {\n\tif (!name) return NULL;\n\tstruct uwsgi_metric_collector *umc = uwsgi.metric_collectors;\n\twhile(umc) {\n\t\tif (!strcmp(name, umc->name)) return umc;\n\t\tumc = umc->next;\n\t}\n\tuwsgi_log(\"unable to find metric collector \\\"%s\\\"\\n\", name);\n\texit(1);\n}\n\nstruct uwsgi_metric *uwsgi_register_metric_do(char *name, char *oid, uint8_t value_type, char *collector, void *ptr, uint32_t freq, void *custom, int do_not_push) {\n\tif (!uwsgi.has_metrics) return NULL;\n\tstruct uwsgi_metric *old_metric=NULL,*metric=uwsgi.metrics;\n\n\tif (!uwsgi_validate_metric_name(name)) {\n\t\tuwsgi_log(\"invalid metric name: %s\\n\", name);\n\t\texit(1);\n\t}\n\n\tif (!uwsgi_validate_metric_oid(oid)) {\n\t\tuwsgi_log(\"invalid metric oid: %s\\n\", oid);\n\t\texit(1);\n\t}\n\n\twhile(metric) {\n\t\tif (!strcmp(metric->name, name)) {\n\t\t\tgoto found;\n\t\t}\n\t\told_metric = metric;\n\t\tmetric = metric->next;\n\t}\n\n\tmetric = uwsgi_calloc(sizeof(struct uwsgi_metric));\n\t// always make a copy of the name (so we can use stack for building strings)\n\tmetric->name = uwsgi_str(name);\n\tmetric->name_len = strlen(metric->name);\n\n\tif (!do_not_push) {\n\t\tif (old_metric) {\n\t\t\told_metric->next = metric;\n\t\t}\n\t\telse {\n\t\t\tuwsgi.metrics = metric;\n\t\t}\n\n\t\tuwsgi.metrics_cnt++;\n\t}\n\nfound:\n\tmetric->oid = oid;\n\tif (metric->oid) {\n\t\tmetric->oid_len = strlen(oid);\n\t\tmetric->oid = uwsgi_str(oid);\n\t\tchar *p, *ctx = NULL;\n\t\tchar *oid_tmp = uwsgi_str(metric->oid);\n\t\t// slower but we save lot of memory\n\t\tstruct uwsgi_buffer *ub = uwsgi_buffer_new(1);\n                uwsgi_foreach_token(oid_tmp, \".\", p, ctx) {\n\t\t\tuint64_t l = strtoull(p, NULL, 10);\t\n\t\t\tif (uwsgi_base128(ub, l, 1)) {\n\t\t\t\tuwsgi_log(\"unable to encode oid %s to asn/ber\\n\", metric->oid);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tmetric->asn = ub->buf;\n\t\tmetric->asn_len = ub->pos;\n\t\tub->buf = NULL;\n\t\tuwsgi_buffer_destroy(ub);\n\t\tfree(oid_tmp);\n\t}\n\tmetric->type = value_type;\n\tmetric->collector = uwsgi_metric_collector_by_name(collector);\n\tmetric->ptr = ptr;\n\tmetric->freq = freq;\n\tif (!metric->freq) metric->freq = 1;\n\tmetric->custom = custom;\n\n\tif (uwsgi.metrics_dir) {\n\t\tchar *filename = uwsgi_concat3(uwsgi.metrics_dir, \"/\", name);\n\t\tint fd = open(filename, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP);\n\t\tif (fd < 0) {\n\t\t\tuwsgi_error_open(filename);\n\t\t\texit(1);\n\t\t}\n\t\t// fill the file\n\t\tif (lseek(fd, uwsgi.page_size-1, SEEK_SET) < 0) {\n\t\t\tuwsgi_error(\"uwsgi_register_metric()/lseek()\");\n\t\t\tuwsgi_log(\"unable to register metric: %s\\n\", name);\n\t\t\texit(1);\n\t\t}\n\t\tif (write(fd, \"\\0\", 1) != 1) {\n\t\t\tuwsgi_error(\"uwsgi_register_metric()/write()\");\n\t\t\tuwsgi_log(\"unable to register metric: %s\\n\", name);\n\t\t\texit(1);\n\t\t}\n\t\tmetric->map = mmap(NULL, uwsgi.page_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\t\tif (metric->map == MAP_FAILED) {\n\t\t\tuwsgi_error(\"uwsgi_register_metric()/mmap()\");\n\t\t\tuwsgi_log(\"unable to register metric: %s\\n\", name);\n\t\t\texit(1);\n\t\t}\n\t\t\n\t\t// we can now safely close the file descriptor and update the file from memory\n\t\tclose(fd);\n\t\tfree(filename);\n\t}\n\n\treturn metric;\n}\n\nstruct uwsgi_metric *uwsgi_register_metric(char *name, char *oid, uint8_t value_type, char *collector, void *ptr, uint32_t freq, void *custom) {\n\treturn uwsgi_register_metric_do(name, oid, value_type, collector, ptr, freq, custom, 0);\n}\n\nstruct uwsgi_metric *uwsgi_register_keyval_metric(char *arg) {\n\tchar *m_name = NULL;\n\tchar *m_oid = NULL;\n\tchar *m_type = NULL;\n\tchar *m_collector = NULL;\n\tchar *m_freq = NULL;\n\tchar *m_arg1 = NULL;\n\tchar *m_arg2 = NULL;\n\tchar *m_arg3 = NULL;\n\tchar *m_arg1n = NULL;\n\tchar *m_arg2n = NULL;\n\tchar *m_arg3n = NULL;\n\tchar *m_initial_value = NULL;\n\tchar *m_children = NULL;\n\tchar *m_alias = NULL;\n\tchar *m_reset_after_push = NULL;\n\n\tif (!strchr(arg, '=')) {\n\t\tm_name = uwsgi_str(arg);\n\t}\n\telse if (uwsgi_kvlist_parse(arg, strlen(arg), ',', '=',\n\t\t\"name\", &m_name,\n\t\t\"oid\", &m_oid,\n\t\t\"type\", &m_type,\n\t\t\"initial_value\", &m_initial_value,\n\t\t\"collector\", &m_collector,\n\t\t\"freq\", &m_freq,\n\t\t\"arg1\", &m_arg1,\n\t\t\"arg2\", &m_arg2,\n\t\t\"arg3\", &m_arg3,\n\t\t\"arg1n\", &m_arg1n,\n\t\t\"arg2n\", &m_arg2n,\n\t\t\"arg3n\", &m_arg3n,\n\t\t\"children\", &m_children,\n\t\t\"alias\", &m_alias,\n\t\t\"reset_after_push\", &m_reset_after_push,\n\t\tNULL)) {\n\t\tuwsgi_log(\"invalid metric keyval syntax: %s\\n\", arg);\n\t\texit(1);\n\t}\n\n\tif (!m_name) {\n\t\tuwsgi_log(\"you need to specify a metric name: %s\\n\", arg);\n\t\texit(1);\n\t}\n\n\tuint8_t type = UWSGI_METRIC_COUNTER;\n\tchar *collector = NULL;\n\tuint32_t freq = 0;\n\tint64_t initial_value = 0;\n\n\tif (m_type) {\n\t\tif (!strcmp(m_type, \"gauge\")) {\n\t\t\ttype = UWSGI_METRIC_GAUGE;\n\t\t}\n\t\telse if (!strcmp(m_type, \"absolute\")) {\n\t\t\ttype = UWSGI_METRIC_ABSOLUTE;\n\t\t}\n\t\telse if (!strcmp(m_type, \"alias\")) {\n\t\t\ttype = UWSGI_METRIC_ALIAS;\n\t\t}\n\t}\n\n\tif (m_collector) {\n\t\tcollector = m_collector;\t\n\t}\n\n\tif (m_freq) freq = strtoul(m_freq, NULL, 10);\n\n\t\n\tif (m_initial_value) {\n\t\tinitial_value = strtoll(m_initial_value, NULL, 10);\t\t\n\t}\n\n\tstruct uwsgi_metric* um =  uwsgi_register_metric(m_name, m_oid, type, collector, NULL, freq, NULL);\n\tum->initial_value = initial_value;\n\n\tif (m_reset_after_push){\n\t\tum->reset_after_push = 1;\n\t}\n\n\tif (m_children) {\n\t\tchar *p, *ctx = NULL;\n        \tuwsgi_foreach_token(m_children, \";\", p, ctx) {\n\t\t\tstruct uwsgi_metric *child = uwsgi_metric_find_by_name(p);\n\t\t\tif (!child) {\n\t\t\t\tuwsgi_log(\"unable to find metric \\\"%s\\\"\\n\", p);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tuwsgi_metric_add_child(um, child);\n                }\n        }\n\n\tif (m_alias) {\n\t\tstruct uwsgi_metric *alias = uwsgi_metric_find_by_name(m_alias);\n\t\tif (!alias) {\n\t\t\tuwsgi_log(\"unable to find metric \\\"%s\\\"\\n\", m_alias);\n                        exit(1);\n\t\t}\n\t\tum->ptr = (void *) alias;\n\t}\n\n\tum->arg1 = m_arg1;\n\tum->arg2 = m_arg2;\n\tum->arg3 = m_arg3;\n\n\tif (m_arg1n) um->arg1n = strtoll(m_arg1n, NULL, 10);\n\tif (m_arg2n) um->arg2n = strtoll(m_arg2n, NULL, 10);\n\tif (m_arg3n) um->arg3n = strtoll(m_arg3n, NULL, 10);\n\n\tfree(m_name);\n\tif (m_oid) free(m_oid);\n\tif (m_type) free(m_type);\n\tif (m_collector) free(m_collector);\n\tif (m_freq) free(m_freq);\n\t/*\n\tDO NOT FREE THEM\n\tif (m_arg1) free(m_arg1);\n\tif (m_arg2) free(m_arg2);\n\tif (m_arg3) free(m_arg3);\n\t*/\n\tif (m_arg1n) free(m_arg1n);\n\tif (m_arg2n) free(m_arg2n);\n\tif (m_arg3n) free(m_arg3n);\n\tif (m_initial_value) free(m_initial_value);\n\tif (m_children) free(m_children);\n\tif (m_alias) free(m_alias);\n\tif (m_reset_after_push) free(m_reset_after_push);\n\treturn um;\n}\n\nstatic void *uwsgi_metrics_loop(void *arg) {\n\n\t// block signals on this thread\n        sigset_t smask;\n        sigfillset(&smask);\n#ifndef UWSGI_DEBUG\n        sigdelset(&smask, SIGSEGV);\n#endif\n        pthread_sigmask(SIG_BLOCK, &smask, NULL);\n\n\tfor(;;) {\n\t\tstruct uwsgi_metric *metric = uwsgi.metrics;\n\t\t// every second scan the whole metrics tree\n\t\ttime_t now = uwsgi_now();\n\t\twhile(metric) {\n\t\t\tif (!metric->last_update) {\n\t\t\t\tmetric->last_update = now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((uint32_t) (now - metric->last_update) < metric->freq) goto next;\n\t\t\t}\n\t\t\tuwsgi_wlock(uwsgi.metrics_lock);\n\t\t\tint64_t value = *metric->value;\n\t\t\t// gather the new value based on the type of collection strategy\n\t\t\tif (metric->collector) {\n\t\t\t\t*metric->value = metric->initial_value + metric->collector->func(metric);\n\t\t\t}\n\t\t\tint64_t new_value = *metric->value;\n\t\t\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\n\t\t\tmetric->last_update = now;\n\n\t\t\tif (uwsgi.metrics_dir && metric->map) {\n\t\t\t\tif (value != new_value) {\n\t\t\t\t\tint ret = snprintf(metric->map, uwsgi.page_size, \"%lld\\n\", (long long) new_value);\n\t\t\t\t\tif (ret > 0 && ret < uwsgi.page_size) {\n\t\t\t\t\t\tmemset(metric->map+ret, 0, 4096-ret);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// thresholds;\n\t\t\tstruct uwsgi_metric_threshold *umt = metric->thresholds;\n\t\t\twhile(umt) {\n\t\t\t\tif (new_value >= umt->value) {\n\t\t\t\t\tif (umt->reset) {\n\t\t\t\t\t\tuwsgi_wlock(uwsgi.metrics_lock);\n\t\t\t\t\t\t*metric->value = umt->reset_value;\n\t\t\t\t\t\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (umt->alarm) {\n\t\t\t\t\t\tif (umt->last_alarm + umt->rate <= now) {\n\t\t\t\t\t\t\tif (umt->msg) {\n\t\t\t\t\t\t\t\tuwsgi_alarm_trigger(umt->alarm, umt->msg, umt->msg_len);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tuwsgi_alarm_trigger(umt->alarm, metric->name, metric->name_len);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tumt->last_alarm = now;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tumt = umt->next;\n\t\t\t}\nnext:\n\t\t\tmetric = metric->next;\n\t\t}\n\t\tsleep(1);\n\t}\n\n\treturn NULL;\n\t\n}\n\nvoid uwsgi_metrics_start_collector() {\n\tif (!uwsgi.has_metrics) return;\n\tpthread_t t;\n        pthread_create(&t, NULL, uwsgi_metrics_loop, NULL);\n\tuwsgi_log(\"metrics collector thread started\\n\");\n}\n\nstruct uwsgi_metric *uwsgi_metric_find_by_name(char *name) {\n\tstruct uwsgi_metric *um = uwsgi.metrics;\n\twhile(um) {\n\t\tif (!strcmp(um->name, name)) {\n\t\t\treturn um;\n\t\t}\t\n\t\tum = um->next;\n\t}\n\n\treturn NULL;\n}\n\nstruct uwsgi_metric *uwsgi_metric_find_by_namen(char *name, size_t len) {\n        struct uwsgi_metric *um = uwsgi.metrics;\n        while(um) {\n                if (!uwsgi_strncmp(um->name, um->name_len, name, len)) {\n                        return um;\n                }\n                um = um->next;\n        }\n\n        return NULL;\n}\n\nstruct uwsgi_metric_child *uwsgi_metric_add_child(struct uwsgi_metric *parent, struct uwsgi_metric *child) {\n\tstruct uwsgi_metric_child *umc = parent->children, *old_umc = NULL;\n\twhile(umc) {\n\t\told_umc = umc;\n\t\tumc = umc->next;\n\t}\n\n\tumc = uwsgi_calloc(sizeof(struct uwsgi_metric_child));\n\tumc->um = child;\n\tif (old_umc) {\n\t\told_umc->next = umc;\n\t}\n\telse {\n\t\tparent->children = umc;\n\t}\n\treturn umc;\n}\n\nstruct uwsgi_metric *uwsgi_metric_find_by_oid(char *oid) {\n        struct uwsgi_metric *um = uwsgi.metrics;\n        while(um) {\n                if (um->oid && !strcmp(um->oid, oid)) {\n                        return um;\n                }\n                um = um->next;\n        }\n\n        return NULL;\n}\n\nstruct uwsgi_metric *uwsgi_metric_find_by_oidn(char *oid, size_t len) {\n        struct uwsgi_metric *um = uwsgi.metrics;\n        while(um) {\n                if (um->oid && !uwsgi_strncmp(um->oid, um->oid_len, oid, len)) {\n                        return um;\n                }\n                um = um->next;\n        }\n\n        return NULL;\n}\n\nstruct uwsgi_metric *uwsgi_metric_find_by_asn(char *asn, size_t len) {\n        struct uwsgi_metric *um = uwsgi.metrics;\n        while(um) {\n                if (um->oid && um->asn && !uwsgi_strncmp(um->asn, um->asn_len, asn, len)) {\n                        return um;\n                }\n                um = um->next;\n        }\n\n        return NULL;\n}\n\n\n/*\n\n\tapi functions\n\n\tmetric_set\n\tmetric_inc\n\tmetric_dec\n\tmetric_mul\n\tmetric_div\n\n*/\n\n#define um_op struct uwsgi_metric *um = NULL;\\\n\tif (!uwsgi.has_metrics) return -1;\\\n\tif (name) {\\\n                um = uwsgi_metric_find_by_name(name);\\\n        }\\\n        else if (oid) {\\\n                um = uwsgi_metric_find_by_oid(oid);\\\n        }\\\n        if (!um) return -1;\\\n\tif (um->collector || um->type == UWSGI_METRIC_ALIAS) return -1;\\\n\tuwsgi_wlock(uwsgi.metrics_lock)\n\nint uwsgi_metric_set(char *name, char *oid, int64_t value) {\n\tum_op;\n\t*um->value = value;\n\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\treturn 0;\n}\n\nint uwsgi_metric_inc(char *name, char *oid, int64_t value) {\n        um_op;\n\t*um->value += value;\n\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\treturn 0;\n}\n\nint uwsgi_metric_dec(char *name, char *oid, int64_t value) {\n        um_op;\n\t*um->value -= value;\n\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\treturn 0;\n}\n\nint uwsgi_metric_mul(char *name, char *oid, int64_t value) {\n        um_op;\n\t*um->value *= value;\n\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\treturn 0;\n}\n\nint uwsgi_metric_div(char *name, char *oid, int64_t value) {\n\t// avoid division by zero\n\tif (value == 0) return -1;\n        um_op;\n\t*um->value /= value;\n\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\treturn 0;\n}\n\nint64_t uwsgi_metric_get(char *name, char *oid) {\n\tif (!uwsgi.has_metrics) return 0;\n\tint64_t ret = 0;\n\tstruct uwsgi_metric *um = NULL;\n\tif (name) {\n\t\tum = uwsgi_metric_find_by_name(name);\n\t}\n\telse if (oid) {\n\t\tum = uwsgi_metric_find_by_oid(oid);\n\t}\n\tif (!um) return 0;\n\n\t// now (in rlocked context) we get the value from\n\t// the map\n\tuwsgi_rlock(uwsgi.metrics_lock);\n\tret = *um->value;\n\t// unlock\n\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\treturn ret;\n}\n\nint64_t uwsgi_metric_getn(char *name, size_t nlen, char *oid, size_t olen) {\n        if (!uwsgi.has_metrics) return 0;\n        int64_t ret = 0;\n        struct uwsgi_metric *um = NULL;\n        if (name) {\n                um = uwsgi_metric_find_by_namen(name, nlen);\n        }\n        else if (oid) {\n                um = uwsgi_metric_find_by_oidn(oid, olen);\n        }\n        if (!um) return 0;\n\n        // now (in rlocked context) we get the value from\n        // the map\n        uwsgi_rlock(uwsgi.metrics_lock);\n        ret = *um->value;\n        // unlock\n        uwsgi_rwunlock(uwsgi.metrics_lock);\n        return ret;\n}\n\nint uwsgi_metric_set_max(char *name, char *oid, int64_t value) {\n\tum_op;\n    if (value > *um->value)\n        *um->value = value;\n\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\treturn 0;\n}\n\nint uwsgi_metric_set_min(char *name, char *oid, int64_t value) {\n\tum_op;\n    if ((value > um->initial_value || 0) && value < *um->value)\n        *um->value = value;\n\tuwsgi_rwunlock(uwsgi.metrics_lock);\n\treturn 0;\n}\n\n#define uwsgi_metric_name(f, n) ret = snprintf(buf, 4096, f, n); if (ret <= 1 || ret >= 4096) { uwsgi_log(\"unable to register metric name %s\\n\", f); exit(1);}\n#define uwsgi_metric_name2(f, n, n2) ret = snprintf(buf, 4096, f, n, n2); if (ret <= 1 || ret >= 4096) { uwsgi_log(\"unable to register metric name %s\\n\", f); exit(1);}\n\n#define uwsgi_metric_oid(f, n) ret = snprintf(buf2, 4096, f, n); if (ret <= 1 || ret >= 4096) { uwsgi_log(\"unable to register metric oid %s\\n\", f); exit(1);}\n#define uwsgi_metric_oid2(f, n, n2) ret = snprintf(buf2, 4096, f, n, n2); if (ret <= 1 || ret >= 4096) { uwsgi_log(\"unable to register metric oid %s\\n\", f); exit(1);}\n\nvoid uwsgi_setup_metrics() {\n\n\tif (!uwsgi.has_metrics) return;\n\n\tchar buf[4096];\n\tchar buf2[4096];\n\n\t// create the main rwlock\n\tuwsgi.metrics_lock = uwsgi_rwlock_init(\"metrics\");\n\t\n\t// get realpath of the storage dir\n\tif (uwsgi.metrics_dir) {\n\t\tchar *dir = uwsgi_expand_path(uwsgi.metrics_dir, strlen(uwsgi.metrics_dir), NULL);\n\t\tif (!dir) {\n\t\t\tuwsgi_error(\"uwsgi_setup_metrics()/uwsgi_expand_path()\");\n\t\t\texit(1);\n\t\t}\n\t\tuwsgi.metrics_dir = dir;\n\t}\n\n\t// the 'core' namespace\n\tuwsgi_register_metric(\"core.routed_signals\", \"5.1\", UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.shared->routed_signals, 0, NULL);\n\tuwsgi_register_metric(\"core.unrouted_signals\", \"5.2\", UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.shared->unrouted_signals, 0, NULL);\n\n\tuwsgi_register_metric(\"core.busy_workers\", \"5.3\", UWSGI_METRIC_GAUGE, \"ptr\", &uwsgi.shared->busy_workers, 0, NULL);\n\tuwsgi_register_metric(\"core.idle_workers\", \"5.4\", UWSGI_METRIC_GAUGE, \"ptr\", &uwsgi.shared->idle_workers, 0, NULL);\n\tuwsgi_register_metric(\"core.overloaded\", \"5.5\", UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.shared->overloaded, 0, NULL);\n\n\t// parents are appended only at the end\n\tstruct uwsgi_metric *total_tx = uwsgi_register_metric_do(\"core.total_tx\", \"5.100\", UWSGI_METRIC_COUNTER, \"sum\", NULL, 0, NULL, 1);\n\tstruct uwsgi_metric *total_rss = uwsgi_register_metric_do(\"core.total_rss\", \"5.101\", UWSGI_METRIC_GAUGE, \"sum\", NULL, 0, NULL, 1);\n\tstruct uwsgi_metric *total_vsz = uwsgi_register_metric_do(\"core.total_vsz\", \"5.102\", UWSGI_METRIC_GAUGE, \"sum\", NULL, 0, NULL, 1);\n\tstruct uwsgi_metric *total_avg_rt = uwsgi_register_metric_do(\"core.avg_response_time\", \"5.103\", UWSGI_METRIC_GAUGE, \"avg\", NULL, 0, NULL, 1);\n\tstruct uwsgi_metric *total_running_time = uwsgi_register_metric_do(\"core.total_running_time\", \"5.104\", UWSGI_METRIC_COUNTER, \"sum\", NULL, 0, NULL, 1);\n\n\tint ret;\n\n\t// create the 'worker' namespace\n\tint i;\n\tfor(i=0;i<=uwsgi.numproc;i++) {\n\n\t\tuwsgi_metric_name(\"worker.%d.requests\", i) ; uwsgi_metric_oid(\"3.%d.1\", i);\n\t\tuwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].requests, 0, NULL);\n\n\t\tuwsgi_metric_name(\"worker.%d.delta_requests\", i) ; uwsgi_metric_oid(\"3.%d.2\", i);\n\t\tuwsgi_register_metric(buf, buf2, UWSGI_METRIC_ABSOLUTE, \"ptr\", &uwsgi.workers[i].delta_requests, 0, NULL);\n\n\t\tuwsgi_metric_name(\"worker.%d.failed_requests\", i) ; uwsgi_metric_oid(\"3.%d.13\", i);\n\t\tuwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].failed_requests, 0, NULL);\n\n\t\tuwsgi_metric_name(\"worker.%d.respawns\", i) ; uwsgi_metric_oid(\"3.%d.14\", i);\n\t\tuwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].respawn_count, 0, NULL);\n\n\t\tuwsgi_metric_name(\"worker.%d.avg_response_time\", i) ; uwsgi_metric_oid(\"3.%d.8\", i);\n\t\tstruct uwsgi_metric *avg_rt = uwsgi_register_metric(buf, buf2, UWSGI_METRIC_GAUGE, \"ptr\", &uwsgi.workers[i].avg_response_time, 0, NULL);\n\t\tif (i > 0) uwsgi_metric_add_child(total_avg_rt, avg_rt);\n\n\t\tuwsgi_metric_name(\"worker.%d.total_tx\", i) ; uwsgi_metric_oid(\"3.%d.9\", i);\n\t\tstruct uwsgi_metric *tx = uwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].tx, 0, NULL);\n\t\tif (i > 0) uwsgi_metric_add_child(total_tx, tx);\n\n\t\tuwsgi_metric_name(\"worker.%d.rss_size\", i) ; uwsgi_metric_oid(\"3.%d.11\", i);\n\t\tstruct uwsgi_metric *rss = uwsgi_register_metric(buf, buf2, UWSGI_METRIC_GAUGE, \"ptr\", &uwsgi.workers[i].rss_size, 0, NULL);\n\t\tif (i > 0) uwsgi_metric_add_child(total_rss, rss);\n\n\t\tuwsgi_metric_name(\"worker.%d.vsz_size\", i) ; uwsgi_metric_oid(\"3.%d.12\", i);\n\t\tstruct uwsgi_metric *vsz = uwsgi_register_metric(buf, buf2, UWSGI_METRIC_GAUGE, \"ptr\", &uwsgi.workers[i].vsz_size, 0, NULL);\n\t\tif (i > 0) uwsgi_metric_add_child(total_vsz, vsz);\n\n\t\tuwsgi_metric_name(\"worker.%d.running_time\", i) ; uwsgi_metric_oid(\"3.%d.13\", i);\n\t\tstruct uwsgi_metric *running_time = uwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].running_time, 0, NULL);\n\t\tif (i > 0) uwsgi_metric_add_child(total_running_time, running_time);\n\n\t\t// skip core metrics for worker 0\n\t\tif (i == 0) continue;\n\n\t\tif (uwsgi.metrics_no_cores) continue;\n\n\t\tint j;\n\t\tfor(j=0;j<uwsgi.cores;j++) {\n\t\t\tuwsgi_metric_name2(\"worker.%d.core.%d.requests\", i, j) ; uwsgi_metric_oid2(\"3.%d.2.%d.1\", i, j);\n\t\t\tuwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].cores[j].requests, 0, NULL);\n\n\t\t\tuwsgi_metric_name2(\"worker.%d.core.%d.write_errors\", i, j) ; uwsgi_metric_oid2(\"3.%d.2.%d.3\", i, j);\n\t\t\tuwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].cores[j].write_errors, 0, NULL);\n\n\t\t\tuwsgi_metric_name2(\"worker.%d.core.%d.routed_requests\", i, j) ; uwsgi_metric_oid2(\"3.%d.2.%d.4\", i, j);\n\t\t\tuwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].cores[j].routed_requests, 0, NULL);\n\n\t\t\tuwsgi_metric_name2(\"worker.%d.core.%d.static_requests\", i, j) ; uwsgi_metric_oid2(\"3.%d.2.%d.5\", i, j);\n\t\t\tuwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].cores[j].static_requests, 0, NULL);\n\n\t\t\tuwsgi_metric_name2(\"worker.%d.core.%d.offloaded_requests\", i, j) ; uwsgi_metric_oid2(\"3.%d.2.%d.6\", i, j);\n\t\t\tuwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].cores[j].offloaded_requests, 0, NULL);\n\n\t\t\tuwsgi_metric_name2(\"worker.%d.core.%d.exceptions\", i, j) ; uwsgi_metric_oid2(\"3.%d.2.%d.7\", i, j);\n\t\t\tuwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].cores[j].exceptions, 0, NULL);\n\n\t\t\tuwsgi_metric_name2(\"worker.%d.core.%d.read_errors\", i, j) ; uwsgi_metric_oid2(\"3.%d.2.%d.8\", i, j);\n\t\t\tuwsgi_register_metric(buf, buf2, UWSGI_METRIC_COUNTER, \"ptr\", &uwsgi.workers[i].cores[j].read_errors, 0, NULL);\n\n\t\t}\n\t}\n\n\t// append parents\n\tuwsgi_metric_append(total_tx);\n\tuwsgi_metric_append(total_rss);\n\tuwsgi_metric_append(total_vsz);\n\tuwsgi_metric_append(total_avg_rt);\n\tuwsgi_metric_append(total_running_time);\n\n\t// sockets\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi.sockets;\n\tint pos = 0;\n\twhile(uwsgi_sock) {\n\t\tuwsgi_metric_name(\"socket.%d.listen_queue\", pos) ; uwsgi_metric_oid(\"7.%d.1\", pos);\n                uwsgi_register_metric(buf, buf2, UWSGI_METRIC_GAUGE, \"ptr\", &uwsgi_sock->queue, 0, NULL);\n\t\tpos++;\n\t\tuwsgi_sock = uwsgi_sock->next;\n\t}\n\n\t// create aliases\n\tuwsgi_register_metric(\"rss_size\", NULL, UWSGI_METRIC_ALIAS, NULL, total_rss, 0, NULL);\n\tuwsgi_register_metric(\"vsz_size\", NULL, UWSGI_METRIC_ALIAS, NULL, total_vsz, 0, NULL);\n\n\t// create custom/user-defined metrics\n\tstruct uwsgi_string_list *usl;\n\tuwsgi_foreach(usl, uwsgi.additional_metrics) {\n\t\tstruct uwsgi_metric *um = uwsgi_register_keyval_metric(usl->value);\n\t\tif (um) {\n\t\t\tuwsgi_log(\"added custom metric: %s\\n\", um->name);\n\t\t}\n\t}\n\n\t// allocate shared memory\n\tint64_t *values = uwsgi_calloc_shared(sizeof(int64_t) * uwsgi.metrics_cnt);\n\tpos = 0;\n\n\tstruct uwsgi_metric *metric = uwsgi.metrics;\n\twhile(metric) {\n\t\tmetric->value = &values[pos];\n\t\tpos++;\n\t\tmetric = metric->next;\n\t}\n\n\t// remap aliases\n\tmetric = uwsgi.metrics;\n        while(metric) {\n\t\tif (metric->type == UWSGI_METRIC_ALIAS) {\n\t\t\tstruct uwsgi_metric *alias = (struct uwsgi_metric *) metric->ptr;\n\t\t\tif (!alias) {\n\t\t\t\tuwsgi_log(\"metric alias \\\"%s\\\" requires a mapping !!!\\n\", metric->name);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tmetric->value = alias->value;\n\t\t\tmetric->oid = alias->oid;\n\t\t}\n\t\tif (metric->initial_value) {\n\t\t\t*metric->value = metric->initial_value;\n\t\t}\n\t\tmetric = metric->next;\n\t}\n\n\t// setup thresholds\n\tuwsgi_foreach(usl, uwsgi.metrics_threshold) {\n\t\tchar *m_key = NULL;\n\t\tchar *m_value = NULL;\n\t\tchar *m_alarm = NULL;\n\t\tchar *m_rate = NULL;\n\t\tchar *m_reset = NULL;\n\t\tchar *m_msg = NULL;\n\t\tif (uwsgi_kvlist_parse(usl->value, usl->len, ',', '=',\n                \t\"key\", &m_key,\n                \t\"value\", &m_value,\n                \t\"alarm\", &m_alarm,\n                \t\"rate\", &m_rate,\n                \t\"msg\", &m_msg,\n                \t\"reset\", &m_reset,\n                \tNULL)) {\n                \t\tuwsgi_log(\"invalid metric threshold keyval syntax: %s\\n\", usl->value);\n                \t\texit(1);\n\t\t}\n\n\t\tif (!m_key || !m_value) {\n\t\t\tuwsgi_log(\"metric's threshold requires a key and a value: %s\\n\", usl->value);\n\t\t\texit(1);\n\t\t}\n\n\t\tstruct uwsgi_metric *um = uwsgi_metric_find_by_name(m_key);\n\t\tif (!um) {\n\t\t\tuwsgi_log(\"unable to find metric %s\\n\", m_key);\n\t\t\texit(1);\n\t\t}\n\n\t\tstruct uwsgi_metric_threshold *umt = uwsgi_calloc(sizeof(struct uwsgi_metric_threshold));\n\t\tumt->value = strtoll(m_value, NULL, 10);\n\t\tif (m_reset) {\n\t\t\tumt->reset = 1;\n\t\t\tumt->reset_value = strtoll(m_reset, NULL, 10);\n\t\t}\n\n\t\tif (m_rate) {\n\t\t\tumt->rate = (int32_t) atoi(m_rate);\n\t\t}\n\n\t\tumt->alarm = m_alarm;\n\n\t\tif (m_msg) {\n\t\t\tumt->msg = m_msg;\n\t\t\tumt->msg_len = strlen(m_msg);\n\t\t}\n\n\t\tfree(m_key);\n\t\tfree(m_value);\n\t\tif (m_rate) free(m_rate);\n\t\tif (m_reset) free(m_reset);\n\n\t\tif (um->thresholds) {\n\t\t\tstruct uwsgi_metric_threshold *umt_list = um->thresholds;\n\t\t\twhile(umt_list) {\n\t\t\t\tif (!umt_list->next) {\n\t\t\t\t\tumt_list->next = umt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tumt_list = umt_list->next;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tum->thresholds = umt;\n\t\t}\n\n\t\tuwsgi_log(\"added threshold for metric %s (value: %lld)\\n\", um->name, umt->value);\n\t}\n\n\tuwsgi_log(\"initialized %llu metrics\\n\", uwsgi.metrics_cnt);\n\n\tif (uwsgi.metrics_dir) {\n\t\tuwsgi_log(\"memory allocated for metrics storage: %llu bytes (%llu MB)\\n\", uwsgi.metrics_cnt * uwsgi.page_size, (uwsgi.metrics_cnt * uwsgi.page_size)/1024/1024);\n\t\tif (uwsgi.metrics_dir_restore) {\n\t\t\tmetric = uwsgi.metrics;\n        \t\twhile(metric) {\n\t\t\t\tif (metric->map) {\n\t\t\t\t\tmetric->initial_value = strtoll(metric->map, NULL, 10);\n\t\t\t\t}\n\t\t\t\tmetric = metric->next;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstruct uwsgi_metric_collector *uwsgi_register_metric_collector(char *name, int64_t (*func)(struct uwsgi_metric *)) {\n\tstruct uwsgi_metric_collector *collector = uwsgi.metric_collectors, *old_collector = NULL;\n\n\twhile(collector) {\n\t\tif (!strcmp(collector->name, name)) goto found;\n\t\told_collector = collector;\n\t\tcollector = collector->next;\n\t}\n\n\tcollector = uwsgi_calloc(sizeof(struct uwsgi_metric_collector));\n\tcollector->name = name;\n\tif (old_collector) {\n\t\told_collector->next = collector;\n\t}\n\telse {\n\t\tuwsgi.metric_collectors = collector;\n\t}\nfound:\n\tcollector->func = func;\n\n\treturn collector;\n}\n\nstatic int64_t uwsgi_metric_collector_ptr(struct uwsgi_metric *um) {\n\treturn *um->ptr;\n}\n\nstatic int64_t uwsgi_metric_collector_sum(struct uwsgi_metric *um) {\n\tint64_t total = 0;\n        struct uwsgi_metric_child *umc = um->children;\n        while(umc) {\n                struct uwsgi_metric *c = umc->um;\n                total += *c->value;\n                umc = umc->next;\n        }\n\n        return total;\n}\n\nstatic int64_t uwsgi_metric_collector_accumulator(struct uwsgi_metric *um) {\n        int64_t total = *um->value;\n        struct uwsgi_metric_child *umc = um->children;\n        while(umc) {\n                struct uwsgi_metric *c = umc->um;\n                total += *c->value;\n                umc = umc->next;\n        }\n\n        return total;\n}\n\nstatic int64_t uwsgi_metric_collector_multiplier(struct uwsgi_metric *um) {\n        int64_t total = 0;\n        struct uwsgi_metric_child *umc = um->children;\n        while(umc) {\n                struct uwsgi_metric *c = umc->um;\n                total += *c->value;\n                umc = umc->next;\n        }\n\n        return total * um->arg1n;\n}\n\nstatic int64_t uwsgi_metric_collector_adder(struct uwsgi_metric *um) {\n        int64_t total = 0;\n        struct uwsgi_metric_child *umc = um->children;\n        while(umc) {\n                struct uwsgi_metric *c = umc->um;\n                total += *c->value;\n                umc = umc->next;\n        }\n\n        return total + um->arg1n;\n}\n\nstatic int64_t uwsgi_metric_collector_avg(struct uwsgi_metric *um) {\n        int64_t total = 0;\n\tint64_t count = 0;\n        struct uwsgi_metric_child *umc = um->children;\n        while(umc) {\n                struct uwsgi_metric *c = umc->um;\n                total += *c->value;\n\t\tcount++;\n                umc = umc->next;\n        }\n\n\tif (count == 0) return 0;\n\n        return total/count;\n}\n\nstatic int64_t uwsgi_metric_collector_func(struct uwsgi_metric *um) {\n\tif (!um->arg1) return 0;\n\tint64_t (*func)(struct uwsgi_metric *) = (int64_t (*)(struct uwsgi_metric *)) um->custom;\n\tif (!func) {\n\t\tfunc = dlsym(RTLD_DEFAULT, um->arg1);\n\t\tum->custom = func;\n\t}\n\tif (!func) return 0;\n        return func(um);\n}\n\nvoid uwsgi_metrics_collectors_setup() {\n\tuwsgi_register_metric_collector(\"ptr\", uwsgi_metric_collector_ptr);\n\tuwsgi_register_metric_collector(\"file\", uwsgi_metric_collector_file);\n\tuwsgi_register_metric_collector(\"sum\", uwsgi_metric_collector_sum);\n\tuwsgi_register_metric_collector(\"accumulator\", uwsgi_metric_collector_accumulator);\n\tuwsgi_register_metric_collector(\"adder\", uwsgi_metric_collector_adder);\n\tuwsgi_register_metric_collector(\"multiplier\", uwsgi_metric_collector_multiplier);\n\tuwsgi_register_metric_collector(\"avg\", uwsgi_metric_collector_avg);\n\tuwsgi_register_metric_collector(\"func\", uwsgi_metric_collector_func);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/core/emperor.c": "/*\n\nThe uWSGI Emperor\n\n*/\n#include <uwsgi.h>\n\n\nextern struct uwsgi_server uwsgi;\nextern char **environ;\n\nvoid emperor_send_stats(int);\n\ntime_t emperor_throttle;\nint emperor_throttle_level;\nint emperor_warming_up = 1;\n\nstruct uwsgi_instance *ui;\n\ntime_t on_royal_death = 0;\n\n/*\n\n\tblacklist subsystem\n\n\tfailed unloyal vassals are blacklisted and throttled\n\n*/\nstruct uwsgi_emperor_blacklist_item {\n\tchar id[0xff];\n\tstruct timeval first_attempt;\n\tstruct timeval last_attempt;\n\tint throttle_level;\n\tint attempt;\n\tstruct uwsgi_emperor_blacklist_item *prev;\n\tstruct uwsgi_emperor_blacklist_item *next;\n};\n\nstruct uwsgi_emperor_blacklist_item *emperor_blacklist;\n\n/*\nthis should be placed in core/socket.c but we realized it was needed\nonly after 2.0 so we cannot change uwsgi.h\n\nbasically it is a stripped down bind_to_tcp/bind_to_unix with rollback\n*/\nstatic int on_demand_bind(char *socket_name) {\n\tunion uwsgi_sockaddr us;\n\tsocklen_t addr_len = sizeof(struct sockaddr_un);\n\tchar *is_tcp = strchr(socket_name, ':');\n\tint af_family = is_tcp ? AF_INET : AF_UNIX;\n\tint fd = socket(af_family, SOCK_STREAM, 0);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tmemset(&us, 0, sizeof(union uwsgi_sockaddr));\n\n\tif (is_tcp) {\n\t\tint reuse = 1;\n\t\tif (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse, sizeof(int)) < 0) {\n\t\t\tgoto error;\n\t\t}\n\t\tus.sa_in.sin_family = AF_INET;\n\t\tus.sa_in.sin_port = htons(atoi(is_tcp + 1));\n\t\t*is_tcp = 0;\n\t\tif (socket_name[0] != 0) {\n\t\t\tus.sa_in.sin_addr.s_addr = inet_addr(socket_name);\n\t\t}\n\t\telse {\n\t\t\tus.sa_in.sin_addr.s_addr = INADDR_ANY;\n\t\t}\n\t\t*is_tcp = ':';\n\t\taddr_len = sizeof(struct sockaddr_in);\n\t}\n\telse {\n\t\tif (unlink(socket_name) != 0 && errno != ENOENT) {\n\t\t\tgoto error;\n\t\t}\n\n\t\tus.sa_un.sun_family = AF_UNIX;\n\t\tmemcpy(us.sa_un.sun_path, socket_name, UMIN(strlen(socket_name), 102));\n\t\taddr_len = strlen(socket_name) + ((void *) us.sa_un.sun_path - (void *) &us.sa_un);\n\t}\n\n\tif (bind(fd, (struct sockaddr *) &us, addr_len) != 0) {\n\t\tgoto error;\n\t}\n\n\tif (!is_tcp) {\n\t\tif (chmod(socket_name, 0666)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (listen(fd, uwsgi.listen_queue) != 0) {\n\t\tgoto error;\n\t}\n\n\treturn fd;\n\nerror:\n\tclose(fd);\n\treturn -1;\n}\n\nstruct uwsgi_emperor_blacklist_item *uwsgi_emperor_blacklist_check(char *id) {\n\tstruct uwsgi_emperor_blacklist_item *uebi = emperor_blacklist;\n\twhile (uebi) {\n\t\tif (!strcmp(uebi->id, id)) {\n\t\t\treturn uebi;\n\t\t}\n\t\tuebi = uebi->next;\n\t}\n\treturn NULL;\n}\n\n\nvoid uwsgi_emperor_blacklist_add(char *id) {\n\n\t// check if the item is already in the blacklist        \n\tstruct uwsgi_emperor_blacklist_item *uebi = uwsgi_emperor_blacklist_check(id);\n\tif (uebi) {\n\t\tgettimeofday(&uebi->last_attempt, NULL);\n\t\tif (uebi->throttle_level < (uwsgi.emperor_max_throttle * 1000)) {\n\t\t\tuebi->throttle_level += (uwsgi.emperor_throttle * 1000);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log_verbose(\"[emperor] maximum throttle level for vassal %s reached !!!\\n\", id);\n\t\t\tuebi->throttle_level = uebi->throttle_level / 2;\n\t\t}\n\t\tuebi->attempt++;\n\t\tif (uebi->attempt == 2) {\n\t\t\tuwsgi_log_verbose(\"[emperor] unloyal bad behaving vassal found: %s throttling it...\\n\", id);\n\t\t}\n\t\treturn;\n\t}\n\n\tuebi = emperor_blacklist;\n\tif (!uebi) {\n\t\tuebi = uwsgi_calloc(sizeof(struct uwsgi_emperor_blacklist_item));\n\t\tuebi->prev = NULL;\n\t\temperor_blacklist = uebi;\n\t}\n\telse {\n\t\twhile (uebi) {\n\t\t\tif (!uebi->next) {\n\t\t\t\tuebi->next = uwsgi_calloc(sizeof(struct uwsgi_emperor_blacklist_item));\n\t\t\t\tuebi->next->prev = uebi;\n\t\t\t\tuebi = uebi->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuebi = uebi->next;\n\t\t}\n\t}\n\n\tsnprintf(uebi->id, 0xff, \"%s\", id);\n\tgettimeofday(&uebi->first_attempt, NULL);\n\tmemcpy(&uebi->last_attempt, &uebi->first_attempt, sizeof(struct timeval));\n\tuebi->throttle_level = uwsgi.emperor_throttle;\n\tuebi->next = NULL;\n\n}\n\nvoid uwsgi_emperor_blacklist_remove(char *id) {\n\n\tstruct uwsgi_emperor_blacklist_item *uebi = uwsgi_emperor_blacklist_check(id);\n\tif (!uebi)\n\t\treturn;\n\n\t// ok let's remove the item\n\t//is it the first item ?\n\tif (uebi == emperor_blacklist) {\n\t\temperor_blacklist = uebi->next;\n\t}\n\n\tstruct uwsgi_emperor_blacklist_item *next = uebi->next;\n\tstruct uwsgi_emperor_blacklist_item *prev = uebi->prev;\n\n\tif (next)\n\t\tnext->prev = prev;\n\n\tif (prev)\n\t\tprev->next = next;\n\n\tfree(uebi);\n}\n\n\nstruct uwsgi_emperor_scanner *emperor_scanners;\n\nstatic int has_extra_extension(char *name) {\n\tstruct uwsgi_string_list *usl = uwsgi.emperor_extra_extension;\n\twhile (usl) {\n\t\tif (uwsgi_endswith(name, usl->value)) {\n\t\t\treturn 1;\n\t\t}\n\t\tusl = usl->next;\n\t}\n\treturn 0;\n}\n\nint uwsgi_emperor_is_valid(char *name) {\n\n\tif (uwsgi_endswith(name, \".xml\") || uwsgi_endswith(name, \".ini\") || uwsgi_endswith(name, \".yml\") || uwsgi_endswith(name, \".yaml\") || uwsgi_endswith(name, \".js\") || uwsgi_endswith(name, \".json\") || has_extra_extension(name)) {\n\n\t\tif (strlen(name) < 0xff) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\n\treturn 0;\n}\n\nstatic char *emperor_check_on_demand_socket(char *filename) {\n\tsize_t len = 0;\n\tif (uwsgi.emperor_on_demand_extension) {\n\t\tchar *tmp = uwsgi_concat2(filename, uwsgi.emperor_on_demand_extension);\n\t\tint fd = open(tmp, O_RDONLY);\n\t\tfree(tmp);\n\t\tif (fd < 0)\n\t\t\treturn NULL;\n\t\tchar *ret = uwsgi_read_fd(fd, &len, 1);\n\t\tclose(fd);\n\t\t// change the first non printable character to 0\n\t\tsize_t i;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (ret[i] < 32) {\n\t\t\t\tret[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret[0] == 0) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ret;\n\t}\n\telse if (uwsgi.emperor_on_demand_directory) {\n\t\t// we need to build the socket path automagically\n\t\tchar *start_of_vassal_name = uwsgi_get_last_char(filename, '/');\n\t\tif (!start_of_vassal_name) {\n\t\t\tstart_of_vassal_name = filename;\n\t\t}\n\t\telse {\n\t\t\tstart_of_vassal_name++;\n\t\t}\n\t\tchar *last_dot = uwsgi_get_last_char(filename, '.');\n\t\tif (!last_dot)\n\t\t\treturn NULL;\n\n\t\treturn uwsgi_concat4n(uwsgi.emperor_on_demand_directory, strlen(uwsgi.emperor_on_demand_directory), \"/\", 1, start_of_vassal_name, last_dot - start_of_vassal_name, \".socket\", 7);\n\t}\n\telse if (uwsgi.emperor_on_demand_exec) {\n\t\tint cpipe[2];\n\t\tif (pipe(cpipe)) {\n\t\t\tuwsgi_error(\"emperor_check_on_demand_socket()pipe()\");\n\t\t\treturn NULL;\n\t\t}\n\t\tchar *cmd = uwsgi_concat4(uwsgi.emperor_on_demand_exec, \" \\\"\", filename, \"\\\"\");\n\t\tint r = uwsgi_run_command(cmd, NULL, cpipe[1]);\n\t\tfree(cmd);\n\t\tif (r < 0) {\n\t\t\tclose(cpipe[0]);\n\t\t\tclose(cpipe[1]);\n\t\t\treturn NULL;\n\t\t}\n\t\tchar *ret = uwsgi_read_fd(cpipe[0], &len, 1);\n\t\tclose(cpipe[0]);\n\t\tclose(cpipe[1]);\n\t\t// change the first non prinabel character to 0\n\t\tsize_t i;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (ret[i] < 32) {\n\t\t\t\tret[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret[0] == 0) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\n// this is the monitor for non-glob directories\nvoid uwsgi_imperial_monitor_directory(struct uwsgi_emperor_scanner *ues) {\n\tstruct uwsgi_instance *ui_current;\n\tstruct dirent *de;\n\tstruct stat st;\n\n\tif (chdir(ues->arg)) {\n\t\tuwsgi_error(\"chdir()\");\n\t\treturn;\n\t}\n\n\tDIR *dir = opendir(\".\");\n\twhile ((de = readdir(dir)) != NULL) {\n\n\t\tif (!uwsgi_emperor_is_valid(de->d_name))\n\t\t\tcontinue;\n\n\t\tif (uwsgi.emperor_nofollow) {\n\t\t\tif (lstat(de->d_name, &st))\n\t\t\t\tcontinue;\n\t\t\tif (!S_ISLNK(st.st_mode) && !S_ISREG(st.st_mode))\n\t\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tif (stat(de->d_name, &st))\n\t\t\t\tcontinue;\n\t\t\tif (!S_ISREG(st.st_mode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tui_current = emperor_get(de->d_name);\n\n\t\tuid_t t_uid = st.st_uid;\n\t\tgid_t t_gid = st.st_gid;\n\n\t\tif (uwsgi.emperor_tyrant && uwsgi.emperor_tyrant_nofollow) {\n\t\t\tstruct stat lst;\n\t\t\tif (lstat(de->d_name, &lst)) {\n\t\t\t\tuwsgi_error(\"[emperor-tyrant]/lstat()\");\n\t\t\t\tif (ui_current) {\n\t\t\t\t\tuwsgi_log(\"!!! availability of file %s changed. stopping the instance... !!!\\n\", de->d_name);\n\t\t\t\t\temperor_stop(ui_current);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tt_uid = lst.st_uid;\n\t\t\tt_gid = lst.st_gid;\n\t\t}\n\n\t\tif (ui_current) {\n\t\t\t// check if uid or gid are changed, in such case, stop the instance\n\t\t\tif (uwsgi.emperor_tyrant) {\n\t\t\t\tif (t_uid != ui_current->uid || t_gid != ui_current->gid) {\n\t\t\t\t\tuwsgi_log(\"!!! permissions of file %s changed. stopping the instance... !!!\\n\", de->d_name);\n\t\t\t\t\temperor_stop(ui_current);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// check if mtime is changed and the uWSGI instance must be reloaded\n\t\t\tif (st.st_mtime > ui_current->last_mod) {\n\t\t\t\temperor_respawn(ui_current, st.st_mtime);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tchar *socket_name = emperor_check_on_demand_socket(de->d_name);\n\t\t\temperor_add(ues, de->d_name, st.st_mtime, NULL, 0, t_uid, t_gid, socket_name);\n\t\t\tif (socket_name)\n\t\t\t\tfree(socket_name);\n\t\t}\n\t}\n\tclosedir(dir);\n\n\t// now check for removed instances\n\tstruct uwsgi_instance *c_ui = ui->ui_next;\n\n\twhile (c_ui) {\n\t\tif (c_ui->scanner == ues) {\n\t\t\tif (c_ui->zerg) {\n\t\t\t\tchar *colon = strrchr(c_ui->name, ':');\n\t\t\t\tif (!colon) {\n\t\t\t\t\temperor_stop(c_ui);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *filename = uwsgi_calloc(0xff);\n\t\t\t\t\tmemcpy(filename, c_ui->name, colon - c_ui->name);\n\t\t\t\t\tif (uwsgi.emperor_nofollow) {\n\t\t\t\t\t\tif (lstat(filename, &st)) {\n\t\t\t\t\t\t\temperor_stop(c_ui);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (stat(filename, &st)) {\n\t\t\t\t\t\t\temperor_stop(c_ui);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (uwsgi.emperor_nofollow) {\n\t\t\t\t\tif (lstat(c_ui->name, &st)) {\n\t\t\t\t\t\temperor_stop(c_ui);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (stat(c_ui->name, &st)) {\n\t\t\t\t\t\temperor_stop(c_ui);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc_ui = c_ui->ui_next;\n\t}\n}\n\n// this is the monitor for glob patterns\nvoid uwsgi_imperial_monitor_glob(struct uwsgi_emperor_scanner *ues) {\n\n\tglob_t g;\n\tint i;\n\tstruct stat st;\n\tstruct uwsgi_instance *ui_current;\n\n\tif (chdir(uwsgi.cwd)) {\n\t\tuwsgi_error(\"uwsgi_imperial_monitor_glob()/chdir()\");\n\t\texit(1);\n\t}\n\n\tif (glob(ues->arg, GLOB_MARK | GLOB_NOCHECK, NULL, &g)) {\n\t\tuwsgi_error(\"uwsgi_imperial_monitor_glob()/glob()\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < (int) g.gl_pathc; i++) {\n\n\t\tif (!uwsgi_emperor_is_valid(g.gl_pathv[i]))\n\t\t\tcontinue;\n\n\t\tif (uwsgi.emperor_nofollow) {\n\t\t\tif (lstat(g.gl_pathv[i], &st))\n\t\t\t\tcontinue;\n\t\t\tif (!S_ISREG(st.st_mode) && !S_ISLNK(st.st_mode))\n\t\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tif (stat(g.gl_pathv[i], &st))\n\t\t\t\tcontinue;\n\t\t\tif (!S_ISREG(st.st_mode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tui_current = emperor_get(g.gl_pathv[i]);\n\n\t\tuid_t t_uid = st.st_uid;\n\t\tgid_t t_gid = st.st_gid;\n\n\t\tif (uwsgi.emperor_tyrant && uwsgi.emperor_tyrant_nofollow) {\n\t\t\tstruct stat lst;\n\t\t\tif (lstat(g.gl_pathv[i], &lst)) {\n\t\t\t\tuwsgi_error(\"[emperor-tyrant]/lstat()\");\n\t\t\t\tif (ui_current) {\n\t\t\t\t\tuwsgi_log(\"!!! availability of file %s changed. stopping the instance... !!!\\n\", g.gl_pathv[i]);\n\t\t\t\t\temperor_stop(ui_current);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tt_uid = lst.st_uid;\n\t\t\tt_gid = lst.st_gid;\n\t\t}\n\n\t\tif (ui_current) {\n\t\t\t// check if uid or gid are changed, in such case, stop the instance\n\t\t\tif (uwsgi.emperor_tyrant) {\n\t\t\t\tif (t_uid != ui_current->uid || t_gid != ui_current->gid) {\n\t\t\t\t\tuwsgi_log(\"!!! permissions of file %s changed. stopping the instance... !!!\\n\", g.gl_pathv[i]);\n\t\t\t\t\temperor_stop(ui_current);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// check if mtime is changed and the uWSGI instance must be reloaded\n\t\t\tif (st.st_mtime > ui_current->last_mod) {\n\t\t\t\temperor_respawn(ui_current, st.st_mtime);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tchar *socket_name = emperor_check_on_demand_socket(g.gl_pathv[i]);\n\t\t\temperor_add(ues, g.gl_pathv[i], st.st_mtime, NULL, 0, t_uid, t_gid, socket_name);\n\t\t\tif (socket_name)\n\t\t\t\tfree(socket_name);\n\t\t}\n\n\t}\n\tglobfree(&g);\n\n\t// now check for removed instances\n\tstruct uwsgi_instance *c_ui = ui->ui_next;\n\n\twhile (c_ui) {\n\t\tif (c_ui->scanner == ues) {\n\t\t\tif (c_ui->zerg) {\n\t\t\t\tchar *colon = strrchr(c_ui->name, ':');\n\t\t\t\tif (!colon) {\n\t\t\t\t\temperor_stop(c_ui);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *filename = uwsgi_calloc(0xff);\n\t\t\t\t\tmemcpy(filename, c_ui->name, colon - c_ui->name);\n\t\t\t\t\tif (uwsgi.emperor_nofollow) {\n\t\t\t\t\t\tif (lstat(filename, &st)) {\n\t\t\t\t\t\t\temperor_stop(c_ui);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (stat(filename, &st)) {\n\t\t\t\t\t\t\temperor_stop(c_ui);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree(filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (uwsgi.emperor_nofollow) {\n\t\t\t\t\tif (lstat(c_ui->name, &st)) {\n\t\t\t\t\t\temperor_stop(c_ui);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (stat(c_ui->name, &st)) {\n\t\t\t\t\t\temperor_stop(c_ui);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc_ui = c_ui->ui_next;\n\t}\n\n\n}\n\nvoid uwsgi_register_imperial_monitor(char *name, void (*init) (struct uwsgi_emperor_scanner *), void (*func) (struct uwsgi_emperor_scanner *)) {\n\n\tstruct uwsgi_imperial_monitor *uim = uwsgi.emperor_monitors;\n\tif (!uim) {\n\t\tuim = uwsgi_calloc(sizeof(struct uwsgi_imperial_monitor));\n\t\tuwsgi.emperor_monitors = uim;\n\t}\n\telse {\n\t\twhile (uim) {\n\t\t\tif (!uim->next) {\n\t\t\t\tuim->next = uwsgi_calloc(sizeof(struct uwsgi_imperial_monitor));\n\t\t\t\tuim = uim->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuim = uim->next;\n\t\t}\n\t}\n\n\tuim->scheme = name;\n\tuim->init = init;\n\tuim->func = func;\n\tuim->next = NULL;\n}\n\n\n// the sad death of an Emperor\nstatic void royal_death(int signum) {\n\n\tif (on_royal_death) {\n\t\tuwsgi_log(\"[emperor] *** RAGNAROK ALREADY EVOKED (mercyless in %d seconds)***\\n\", uwsgi.reload_mercy - (uwsgi_now() - on_royal_death));\n\t\treturn;\n\t}\n\n\tstruct uwsgi_instance *c_ui = ui->ui_next;\n\n\tif (uwsgi.vassals_stop_hook) {\n\n\n\t\twhile (c_ui) {\n\t\t\tuwsgi_log(\"[emperor] running vassal stop-hook: %s %s\\n\", uwsgi.vassals_stop_hook, c_ui->name);\n\t\t\tif (uwsgi.emperor_absolute_dir) {\n\t\t\t\tif (setenv(\"UWSGI_VASSALS_DIR\", uwsgi.emperor_absolute_dir, 1)) {\n\t\t\t\t\tuwsgi_error(\"setenv()\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tint stop_hook_ret = uwsgi_run_command_and_wait(uwsgi.vassals_stop_hook, c_ui->name);\n\t\t\tuwsgi_log(\"[emperor] %s stop-hook returned %d\\n\", c_ui->name, stop_hook_ret);\n\t\t\tc_ui = c_ui->ui_next;\n\t\t}\n\t}\n\n\tuwsgi_log(\"[emperor] *** RAGNAROK EVOKED ***\\n\");\n\n\twhile (c_ui) {\n\t\temperor_stop(c_ui);\n\t\tc_ui = c_ui->ui_next;\n\t}\n\n\tif (!uwsgi.reload_mercy)\n\t\tuwsgi.reload_mercy = 30;\n\ton_royal_death = uwsgi_now();\n}\n\n// massive reload of vassals\nstatic void emperor_massive_reload(int signum) {\n\tstruct uwsgi_instance *c_ui = ui->ui_next;\n\n\twhile (c_ui) {\n\t\temperor_respawn(c_ui, uwsgi_now());\n\t\tc_ui = c_ui->ui_next;\n\t}\n}\n\n\nstatic void emperor_stats() {\n\n\tstruct uwsgi_instance *c_ui = ui->ui_next;\n\n\twhile (c_ui) {\n\n\t\tuwsgi_log(\"vassal instance %s (last modified %lld) status %d loyal %d zerg %d\\n\", c_ui->name, (long long) c_ui->last_mod, c_ui->status, c_ui->loyal, c_ui->zerg);\n\n\t\tc_ui = c_ui->ui_next;\n\t}\n\n}\n\nstruct uwsgi_instance *emperor_get_by_fd(int fd) {\n\n\tstruct uwsgi_instance *c_ui = ui;\n\n\twhile (c_ui->ui_next) {\n\t\tc_ui = c_ui->ui_next;\n\n\t\tif (c_ui->pipe[0] == fd) {\n\t\t\treturn c_ui;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstruct uwsgi_instance *emperor_get_by_socket_fd(int fd) {\n\n\tstruct uwsgi_instance *c_ui = ui;\n\n\twhile (c_ui->ui_next) {\n\t\tc_ui = c_ui->ui_next;\n\n\t\t// over engineering...\n\t\tif (c_ui->on_demand_fd > -1 && c_ui->on_demand_fd == fd) {\n\t\t\treturn c_ui;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\n\nstruct uwsgi_instance *emperor_get(char *name) {\n\n\tstruct uwsgi_instance *c_ui = ui;\n\n\twhile (c_ui->ui_next) {\n\t\tc_ui = c_ui->ui_next;\n\n\t\tif (!strcmp(c_ui->name, name)) {\n\t\t\treturn c_ui;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid emperor_del(struct uwsgi_instance *c_ui) {\n\n\tstruct uwsgi_instance *parent_ui = c_ui->ui_prev;\n\tstruct uwsgi_instance *child_ui = c_ui->ui_next;\n\n\tparent_ui->ui_next = child_ui;\n\tif (child_ui) {\n\t\tchild_ui->ui_prev = parent_ui;\n\t}\n\n\t// this will destroy the whole uWSGI instance (and workers)\n\tif (c_ui->pipe[0] != -1)\n\t\tclose(c_ui->pipe[0]);\n\tif (c_ui->pipe[1] != -1)\n\t\tclose(c_ui->pipe[1]);\n\n\tif (c_ui->use_config) {\n\t\tif (c_ui->pipe_config[0] != -1)\n\t\t\tclose(c_ui->pipe_config[0]);\n\t\tif (c_ui->pipe_config[1] != -1)\n\t\t\tclose(c_ui->pipe_config[1]);\n\t}\n\n\tif (uwsgi.vassals_stop_hook) {\n\t\tuwsgi_log(\"[emperor] running vassal stop-hook: %s %s\\n\", uwsgi.vassals_stop_hook, c_ui->name);\n\t\tif (uwsgi.emperor_absolute_dir) {\n\t\t\tif (setenv(\"UWSGI_VASSALS_DIR\", uwsgi.emperor_absolute_dir, 1)) {\n\t\t\t\tuwsgi_error(\"setenv()\");\n\t\t\t}\n\t\t}\n\t\tint stop_hook_ret = uwsgi_run_command_and_wait(uwsgi.vassals_stop_hook, c_ui->name);\n\t\tuwsgi_log(\"[emperor] %s stop-hook returned %d\\n\", c_ui->name, stop_hook_ret);\n\t}\n\n\tuwsgi_log_verbose(\"[emperor] removed uwsgi instance %s\\n\", c_ui->name);\n\t// put the instance in the blacklist (or update its throttling value)\n\tif (!c_ui->loyal && !uwsgi.emperor_no_blacklist) {\n\t\tuwsgi_emperor_blacklist_add(c_ui->name);\n\t}\n\n\tif (c_ui->zerg) {\n\t\tuwsgi.emperor_broodlord_count--;\n\t}\n\n\tif (c_ui->socket_name) {\n\t\tfree(c_ui->socket_name);\n\t}\n\n\tif (c_ui->config)\n\t\tfree(c_ui->config);\n\n\tif (c_ui->on_demand_fd > -1) {\n\t\tclose(c_ui->on_demand_fd);\n\t}\n\n\tfree(c_ui);\n\n}\n\nvoid emperor_back_to_ondemand(struct uwsgi_instance *c_ui) {\n\tif (c_ui->status > 0)\n\t\treturn;\n\n\t// remove uWSGI instance\n\n\tif (c_ui->pid != -1) {\n\t\tif (write(c_ui->pipe[0], \"\\0\", 1) != 1) {\n\t\t\tuwsgi_error(\"emperor_stop()/write()\");\n\t\t}\n\t}\n\n\tc_ui->status = 2;\n\tc_ui->cursed_at = uwsgi_now();\n\n\tuwsgi_log_verbose(\"[emperor] bringing back instance %s to on-demand mode\\n\", c_ui->name);\n}\n\nvoid emperor_stop(struct uwsgi_instance *c_ui) {\n\tif (c_ui->status == 1)\n\t\treturn;\n\t// remove uWSGI instance\n\n\tif (c_ui->pid != -1) {\n\t\tif (write(c_ui->pipe[0], \"\\0\", 1) != 1) {\n\t\t\tuwsgi_error(\"emperor_stop()/write()\");\n\t\t}\n\t}\n\n\tc_ui->status = 1;\n\tc_ui->cursed_at = uwsgi_now();\n\n\tuwsgi_log_verbose(\"[emperor] stop the uwsgi instance %s\\n\", c_ui->name);\n}\n\nvoid emperor_curse(struct uwsgi_instance *c_ui) {\n\tif (c_ui->status == 1)\n\t\treturn;\n\t// curse uWSGI instance\n\n\t// take in account on-demand mode\n\tif (c_ui->status == 0)\n\t\tc_ui->status = 1;\n\tc_ui->cursed_at = uwsgi_now();\n\n\tuwsgi_log_verbose(\"[emperor] curse the uwsgi instance %s (pid: %d)\\n\", c_ui->name, (int) c_ui->pid);\n\n}\n\n// send configuration (if required to the vassal)\nstatic void emperor_push_config(struct uwsgi_instance *c_ui) {\n\tstruct uwsgi_header uh;\n\n\tif (c_ui->use_config) {\n\t\tuh.modifier1 = 115;\n\t\tuh.pktsize = c_ui->config_len;\n\t\tuh.modifier2 = 0;\n\t\tif (write(c_ui->pipe_config[0], &uh, 4) != 4) {\n\t\t\tuwsgi_error(\"[uwsgi-emperor] write() header config\");\n\t\t}\n\t\telse {\n\t\t\tif (write(c_ui->pipe_config[0], c_ui->config, c_ui->config_len) != (long) c_ui->config_len) {\n\t\t\t\tuwsgi_error(\"[uwsgi-emperor] write() config\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid emperor_respawn(struct uwsgi_instance *c_ui, time_t mod) {\n\n\t// if the vassal is being destroyed, do not honour respawns\n\tif (c_ui->status > 0)\n\t\treturn;\n\n\t// check if we are in on_demand mode (the respawn will be ignored)\n\tif (c_ui->pid == -1 && c_ui->on_demand_fd > -1) {\n\t\tc_ui->last_mod = mod;\n\t\t// reset readyness\n\t\tc_ui->ready = 0;\n\t\t// reset accepting\n\t\tc_ui->accepting = 0;\n\t\tuwsgi_log_verbose(\"[emperor] updated configuration for \\\"on demand\\\" instance %s\\n\", c_ui->name);\n\t\treturn;\n\t}\n\n\t// reload the uWSGI instance\n\tif (write(c_ui->pipe[0], \"\\1\", 1) != 1) {\n\t\t// the vassal could be already dead, better to curse it\n\t\tuwsgi_error(\"emperor_respawn/write()\");\n\t\temperor_curse(c_ui);\n\t\treturn;\n\t}\n\n\t// push the config to the config pipe (if needed)\n\temperor_push_config(c_ui);\n\n\tc_ui->respawns++;\n\tc_ui->last_mod = mod;\n\tc_ui->last_run = uwsgi_now();\n\t// reset readyness\n\tc_ui->ready = 0;\n\t// reset accepting\n\tc_ui->accepting = 0;\n\n\tuwsgi_log_verbose(\"[emperor] reload the uwsgi instance %s\\n\", c_ui->name);\n}\n\nvoid emperor_add(struct uwsgi_emperor_scanner *ues, char *name, time_t born, char *config, uint32_t config_size, uid_t uid, gid_t gid, char *socket_name) {\n\n\tstruct uwsgi_instance *c_ui = ui;\n\tstruct uwsgi_instance *n_ui = NULL;\n\tstruct timeval tv;\n\n#ifdef UWSGI_DEBUG\n\tuwsgi_log(\"\\n\\nVASSAL %s %d %.*s %d %d\\n\", name, born, config_size, config, uid, gid);\n#endif\n\n\tif (strlen(name) > (0xff - 1)) {\n\t\tuwsgi_log(\"[emperor] invalid vassal name: %s\\n\", name);\n\t\treturn;\n\t}\n\n\n\tgettimeofday(&tv, NULL);\n\tint now = tv.tv_sec;\n\tuint64_t micros = (tv.tv_sec * 1000ULL * 1000ULL) + tv.tv_usec;\n\n\t// blacklist check\n\tstruct uwsgi_emperor_blacklist_item *uebi = uwsgi_emperor_blacklist_check(name);\n\tif (uebi) {\n\t\tuint64_t i_micros = (uebi->last_attempt.tv_sec * 1000ULL * 1000ULL) + uebi->last_attempt.tv_usec + uebi->throttle_level;\n\t\tif (i_micros > micros) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// TODO make it meaningful\n\tif (now - emperor_throttle < 1) {\n\t\temperor_throttle_level = emperor_throttle_level * 2;\n\t}\n\telse {\n\t\tif (emperor_throttle_level > uwsgi.emperor_throttle) {\n\t\t\temperor_throttle_level = emperor_throttle_level / 2;\n\t\t}\n\n\t\tif (emperor_throttle_level < uwsgi.emperor_throttle) {\n\t\t\temperor_throttle_level = uwsgi.emperor_throttle;\n\t\t}\n\t}\n\n\temperor_throttle = now;\n#ifdef UWSGI_DEBUG\n\tuwsgi_log(\"emperor throttle = %d\\n\", emperor_throttle_level);\n#endif\n\t/*\n\tif (emperor_warming_up) {\n\t\tif (emperor_throttle_level > 0) {\n\t\t\t// wait 10 milliseconds in case of fork-bombing\n\t\t\t// pretty random value, but should avoid the load average to increase\n\t\t\tusleep(10 * 1000);\n\t\t}\n\t}\n\telse {\n\t\tusleep(emperor_throttle_level * 1000);\n\t}\n\t*/\n\n\tif (uwsgi.emperor_tyrant) {\n\t\tif (uid == 0 || gid == 0) {\n\t\t\tuwsgi_log(\"[emperor-tyrant] invalid permissions for vassal %s\\n\", name);\n\t\t\treturn;\n\t\t}\n\t}\n\n\twhile (c_ui->ui_next) {\n\t\tc_ui = c_ui->ui_next;\n\t}\n\n\tn_ui = uwsgi_calloc(sizeof(struct uwsgi_instance));\n\n\tif (config) {\n\t\tn_ui->use_config = 1;\n\t\tn_ui->config = config;\n\t\tn_ui->config_len = config_size;\n\t}\n\n\tc_ui->ui_next = n_ui;\n#ifdef UWSGI_DEBUG\n\tuwsgi_log(\"c_ui->ui_next = %p\\n\", c_ui->ui_next);\n#endif\n\tn_ui->ui_prev = c_ui;\n\n\tif (strchr(name, ':')) {\n\t\tn_ui->zerg = 1;\n\t\tuwsgi.emperor_broodlord_count++;\n\t}\n\n\tn_ui->scanner = ues;\n\tmemcpy(n_ui->name, name, strlen(name));\n\tn_ui->born = born;\n\tn_ui->uid = uid;\n\tn_ui->gid = gid;\n\tn_ui->last_mod = born;\n\t// start non-ready\n\tn_ui->last_ready = 0;\n\tn_ui->ready = 0;\n\t// start without loyalty\n\tn_ui->last_loyal = 0;\n\tn_ui->loyal = 0;\n\n\tn_ui->first_run = uwsgi_now();\n\tn_ui->last_run = n_ui->first_run;\n\tn_ui->on_demand_fd = -1;\n\tif (socket_name) {\n\t\tn_ui->socket_name = uwsgi_str(socket_name);\n\t}\n\n\tn_ui->pid = -1;\n\tn_ui->pipe[0] = -1;\n\tn_ui->pipe[1] = -1;\n\n\tn_ui->pipe_config[0] = -1;\n\tn_ui->pipe_config[1] = -1;\n\n\t// ok here we check if we need to bind to the specified socket or continue with the activation\n\tif (socket_name) {\n\t\tn_ui->on_demand_fd = on_demand_bind(socket_name);\n\t\tif (n_ui->on_demand_fd < 0) {\n\t\t\tuwsgi_error(\"emperor_add()/bind()\");\n\t\t\temperor_del(n_ui);\n\t\t\treturn;\n\t\t}\n\n\t\tevent_queue_add_fd_read(uwsgi.emperor_queue, n_ui->on_demand_fd);\n\t\tuwsgi_log(\"[uwsgi-emperor] %s -> \\\"on demand\\\" instance detected, waiting for connections on socket \\\"%s\\\" ...\\n\", name, socket_name);\n\t\treturn;\n\t}\n\n\tif (uwsgi_emperor_vassal_start(n_ui)) {\n\t\t// clear the vassal\n\t\temperor_del(n_ui);\n\t}\n}\n\nstatic int uwsgi_emperor_spawn_vassal(struct uwsgi_instance *);\n\nint uwsgi_emperor_vassal_start(struct uwsgi_instance *n_ui) {\n\n\tpid_t pid;\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, n_ui->pipe)) {\n\t\tuwsgi_error(\"socketpair()\");\n\t\treturn -1;\n\t}\n\tuwsgi_socket_nb(n_ui->pipe[0]);\n\n\tevent_queue_add_fd_read(uwsgi.emperor_queue, n_ui->pipe[0]);\n\n\tif (n_ui->use_config) {\n\t\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, n_ui->pipe_config)) {\n\t\t\tuwsgi_error(\"socketpair()\");\n\t\t\treturn -1;\n\t\t}\n\t\tuwsgi_socket_nb(n_ui->pipe_config[0]);\n\t}\n\n\tif (n_ui->zerg) {\n\t\tuwsgi.emperor_broodlord_num++;\n\t}\n\n\t// TODO pre-start hook\n\n\t// a new uWSGI instance will start \n#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL) && !defined(__ia64__)\n\tif (uwsgi.emperor_clone) {\n\t\tchar stack[PTHREAD_STACK_MIN];\n\t\tpid = clone((int (*)(void *)) uwsgi_emperor_spawn_vassal, stack + PTHREAD_STACK_MIN, SIGCHLD | uwsgi.emperor_clone, (void *) n_ui);\n\t}\n\telse {\n#endif\n\t\tpid = fork();\n#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL) && !defined(__ia64__)\n\t}\n#endif\n\tif (pid < 0) {\n\t\tuwsgi_error(\"uwsgi_emperor_spawn_vassal()/fork()\")\n\t}\n\telse if (pid > 0) {\n\t\tn_ui->pid = pid;\n\t\t// close the right side of the pipe\n\t\tclose(n_ui->pipe[1]);\n\t\tn_ui->pipe[1] = -1;\n\t\t/* THE ON-DEMAND file descriptor is left mapped to the emperor to allow fast-respawn\n\t\t   // TODO add an option to force closing it\n\t\t   // close the \"on demand\" socket\n\t\t   if (n_ui->on_demand_fd > -1) {\n\t\t   close(n_ui->on_demand_fd);\n\t\t   n_ui->on_demand_fd = -1;\n\t\t   }\n\t\t */\n\t\tif (n_ui->use_config) {\n\t\t\tclose(n_ui->pipe_config[1]);\n\t\t\tn_ui->pipe_config[1] = -1;\n\t\t\temperor_push_config(n_ui);\n\t\t}\n\n\t\t// once the config is sent we can run hooks (they can fail)\n\t\t// exec hooks have access to all of the currently defined vars + UWSGI_VASSAL_PID, UWSGI_VASSAL_UID, UWSGI_VASSAL_GID, UWSGI_VASSAL_CONFIG\n\t\tuwsgi_hooks_run(uwsgi.hook_as_emperor, \"as-emperor\", 0);\n\t\tstruct uwsgi_string_list *usl;\n\t\tuwsgi_foreach(usl, uwsgi.mount_as_emperor) {\n\t\t\tuwsgi_log(\"mounting \\\"%s\\\" (as-emperor for vassal \\\"%s\\\" pid: %d uid: %d gid: %d)...\\n\", usl->value, n_ui->name, n_ui->pid, n_ui->uid, n_ui->gid);\n\t\t\tif (uwsgi_mount_hook(usl->value)) {\n\t\t\t\tuwsgi_log(\"unable to mount %s\\n\", usl->value);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.umount_as_emperor) {\n\t\t\tuwsgi_log(\"un-mounting \\\"%s\\\" (as-emperor for vassal \\\"%s\\\" pid: %d uid: %d gid: %d)...\\n\", usl->value, n_ui->name, n_ui->pid, n_ui->uid, n_ui->gid);\n\t\t\tif (uwsgi_umount_hook(usl->value)) {\n\t\t\t\tuwsgi_log(\"unable to umount %s\\n\", usl->value);\n\t\t\t}\n\t\t}\n\t\tuwsgi_foreach(usl, uwsgi.exec_as_emperor) {\n\t\t\tuwsgi_log(\"running \\\"%s\\\" (as-emperor for vassal \\\"%s\\\" pid: %d uid: %d gid: %d)...\\n\", usl->value, n_ui->name, n_ui->pid, n_ui->uid, n_ui->gid);\n\t\t\tchar *argv[4];\n\t\t\targv[0] = uwsgi_concat2(\"UWSGI_VASSAL_CONFIG=\", n_ui->name);\n\t\t\tchar argv_pid[17 + 11];\n\t\t\tsnprintf(argv_pid, 17 + 11, \"UWSGI_VASSAL_PID=%d\", (int) n_ui->pid);\n\t\t\targv[1] = argv_pid;\n\t\t\tchar argv_uid[17 + 11];\n\t\t\tsnprintf(argv_uid, 17 + 11, \"UWSGI_VASSAL_UID=%d\", (int) n_ui->uid);\n\t\t\targv[2] = argv_uid;\n\t\t\tchar argv_gid[17 + 11];\n\t\t\tsnprintf(argv_gid, 17 + 11, \"UWSGI_VASSAL_GID=%d\", (int) n_ui->gid);\n\t\t\targv[3] = argv_gid;\n\t\t\tint ret = uwsgi_run_command_putenv_and_wait(NULL, usl->value, argv, 4);\n\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with code: %d\\n\", usl->value, ret);\n\t\t\tfree(argv[0]);\n\t\t}\n\t\t// 4 call hooks\n\t\t// config / config + pid / config + pid + uid + gid\n\t\t// call\n\t\tuwsgi_foreach(usl, uwsgi.call_as_emperor) {\n\t\t\tvoid (*func) (void) = dlsym(RTLD_DEFAULT, usl->value);\n\t\t\tif (!func) {\n\t\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfunc();\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.call_as_emperor1) {\n\t\t\tvoid (*func) (char *) = dlsym(RTLD_DEFAULT, usl->value);\n\t\t\tif (!func) {\n\t\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfunc(n_ui->name);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.call_as_emperor2) {\n\t\t\tvoid (*func) (char *, pid_t) = dlsym(RTLD_DEFAULT, usl->value);\n\t\t\tif (!func) {\n\t\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfunc(n_ui->name, n_ui->pid);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.call_as_emperor4) {\n\t\t\tvoid (*func) (char *, pid_t, uid_t, gid_t) = dlsym(RTLD_DEFAULT, usl->value);\n\t\t\tif (!func) {\n\t\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfunc(n_ui->name, n_ui->pid, n_ui->uid, n_ui->gid);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\telse {\n\t\tuwsgi_emperor_spawn_vassal(n_ui);\n\t}\n\treturn -1;\n}\n\nstatic int uwsgi_emperor_spawn_vassal(struct uwsgi_instance *n_ui) {\n\tint i;\n\n\t// run plugin hooks for the vassal\n\tfor (i = 0; i < 256; i++) {\n                if (uwsgi.p[i]->vassal) {\n                        uwsgi.p[i]->vassal(n_ui);\n                }\n        }\n\n        for (i = 0; i < uwsgi.gp_cnt; i++) {\n                if (uwsgi.gp[i]->vassal) {\n                        uwsgi.gp[i]->vassal(n_ui);\n                }\n        }\n\n#ifdef __linux__\n\tif (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0)) {\n\t\tuwsgi_error(\"prctl()\");\n\t}\n#ifdef CLONE_NEWUSER\n\tif (uwsgi.emperor_clone & CLONE_NEWUSER) {\n\t\tif (setuid(0)) {\n\t\t\tuwsgi_error(\"uwsgi_emperor_spawn_vassal()/setuid(0)\");\n\t\t\texit(1);\n\t\t}\n\t}\n#endif\n\n#ifdef UWSGI_CAP\n#if defined(CAP_LAST_CAP) && defined(PR_CAPBSET_READ) && defined(PR_CAPBSET_DROP)\n\tif (uwsgi.emperor_cap && uwsgi.emperor_cap_count > 0) {\n\t\tint i;\n\t\tfor (i = 0; i <= CAP_LAST_CAP; i++) {\n\n\t\t\tint has_cap = prctl(PR_CAPBSET_READ, i, 0, 0, 0);\n\t\t\tif (has_cap == 1) {\n\t\t\t\tif (i == CAP_SETPCAP)\n\t\t\t\t\tcontinue;\n\t\t\t\tint j;\n\t\t\t\tint found = 0;\n\t\t\t\tfor (j = 0; j < uwsgi.emperor_cap_count; j++) {\n\t\t\t\t\tif (uwsgi.emperor_cap[j] == (int) i) {\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (prctl(PR_CAPBSET_DROP, i, 0, 0, 0)) {\n\t\t\t\t\tuwsgi_error(\"uwsgi_emperor_spawn_vassal()/prctl()\");\n\t\t\t\t\tuwsgi_log_verbose(\"unable to drop capability %lu\\n\", i);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// just for being paranoid\n#ifdef SECBIT_KEEP_CAPS\n\t\tif (prctl(SECBIT_KEEP_CAPS, 1, 0, 0, 0) < 0) {\n\t\t\tuwsgi_error(\"prctl()\");\n\t\t\texit(1);\n\t\t}\n#else\n\t\tif (prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0) {\n\t\t\tuwsgi_error(\"prctl()\");\n\t\t\texit(1);\n\t\t}\n#endif\n\t\tuwsgi_log(\"capabilities applied for vassal %s (pid: %d)\\n\", n_ui->name, (int) getpid());\n\t}\n#endif\n#endif\n#endif\n\n\tif (uwsgi.emperor_tyrant) {\n\t\tuwsgi_log(\"[emperor-tyrant] dropping privileges to %d %d for instance %s\\n\", (int) n_ui->uid, (int) n_ui->gid, n_ui->name);\n\t\tif (setgid(n_ui->gid)) {\n\t\t\tuwsgi_error(\"setgid()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (setgroups(0, NULL)) {\n\t\t\tuwsgi_error(\"setgroups()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (setuid(n_ui->uid)) {\n\t\t\tuwsgi_error(\"setuid()\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\tunsetenv(\"UWSGI_RELOADS\");\n\tunsetenv(\"NOTIFY_SOCKET\");\n\n\tchar *uef = uwsgi_num2str(n_ui->pipe[1]);\n\tif (setenv(\"UWSGI_EMPEROR_FD\", uef, 1)) {\n\t\tuwsgi_error(\"setenv()\");\n\t\texit(1);\n\t}\n\tfree(uef);\n\n\t// add UWSGI_BROODLORD_NUM\n\tif (n_ui->zerg) {\n\t\tuef = uwsgi_num2str(uwsgi.emperor_broodlord_num);\n\t\tif (setenv(\"UWSGI_BROODLORD_NUM\", uef, 1)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t\texit(1);\n\t\t}\n\t\tfree(uef);\n\t}\n\n\tif (n_ui->use_config) {\n\t\tuef = uwsgi_num2str(n_ui->pipe_config[1]);\n\t\tif (setenv(\"UWSGI_EMPEROR_FD_CONFIG\", uef, 1)) {\n\t\t\tuwsgi_error(\"setenv()\");\n\t\t\texit(1);\n\t\t}\n\t\tfree(uef);\n\t}\n\n\tchar **uenvs = environ;\n\twhile (*uenvs) {\n\t\tif (!strncmp(*uenvs, \"UWSGI_VASSAL_\", 13) && strchr(*uenvs, '=')) {\n\t\t\tchar *oe = uwsgi_concat2n(*uenvs, strchr(*uenvs, '=') - *uenvs, \"\", 0), *ne;\n#ifdef UNSETENV_VOID\n\t\t\tunsetenv(oe);\n#else\n\t\t\tif (unsetenv(oe)) {\n\t\t\t\tuwsgi_error(\"unsetenv()\");\n\t\t\t\tfree(oe);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tfree(oe);\n\n\t\t\tne = uwsgi_concat2(\"UWSGI_\", *uenvs + 13);\n#ifdef UWSGI_DEBUG\n\t\t\tuwsgi_log(\"putenv %s\\n\", ne);\n#endif\n\n\t\t\tif (putenv(ne)) {\n\t\t\t\tuwsgi_error(\"putenv()\");\n\t\t\t}\n\t\t\t// do not free ne as putenv will add it to the environ\n\t\t\tuenvs = environ;\n\t\t\tcontinue;\n\t\t}\n\t\tuenvs++;\n\t}\n\n\t// close the left side of the pipe\n\tclose(n_ui->pipe[0]);\n\n\tif (n_ui->use_config) {\n\t\tclose(n_ui->pipe_config[0]);\n\t}\n\n\tint counter = 4;\n\tstruct uwsgi_string_list *uct;\n\tuwsgi_foreach(uct, uwsgi.vassals_templates_before) counter += 2;\n\tuwsgi_foreach(uct, uwsgi.vassals_includes_before) counter += 2;\n\tuwsgi_foreach(uct, uwsgi.vassals_set) counter += 2;\n\tuwsgi_foreach(uct, uwsgi.vassals_templates) counter += 2;\n\tuwsgi_foreach(uct, uwsgi.vassals_includes) counter += 2;\n\n\tchar **vassal_argv = uwsgi_malloc(sizeof(char *) * counter);\n\t// set args\n\tvassal_argv[0] = uwsgi.emperor_wrapper ? uwsgi.emperor_wrapper : uwsgi.binary_path;\n\n\t// reset counter\n\tcounter = 1;\n\n\tuwsgi_foreach(uct, uwsgi.vassals_templates_before) {\n\t\tvassal_argv[counter] = \"--inherit\";\n\t\tvassal_argv[counter + 1] = uct->value;\n\t\tcounter += 2;\n\t}\n\n\tuwsgi_foreach(uct, uwsgi.vassals_includes_before) {\n\t\tvassal_argv[counter] = \"--include\";\n\t\tvassal_argv[counter + 1] = uct->value;\n\t\tcounter += 2;\n\t}\n\n\tuwsgi_foreach(uct, uwsgi.vassals_set) {\n\t\tvassal_argv[counter] = \"--set\";\n\t\tvassal_argv[counter + 1] = uct->value;\n\t\tcounter += 2;\n\t}\n\n\tchar *colon = NULL;\n\tif (uwsgi.emperor_broodlord) {\n\t\tcolon = strchr(n_ui->name, ':');\n\t\tif (colon) {\n\t\t\tcolon[0] = 0;\n\t\t}\n\t}\n\t// initialize to a default value\n\tvassal_argv[counter] = \"--inherit\";\n\n\tif (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), \".xml\"))\n\t\tvassal_argv[counter] = \"--xml\";\n\tif (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), \".ini\"))\n\t\tvassal_argv[counter] = \"--ini\";\n\tif (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), \".yml\"))\n\t\tvassal_argv[counter] = \"--yaml\";\n\tif (!strcmp(n_ui->name + (strlen(n_ui->name) - 5), \".yaml\"))\n\t\tvassal_argv[counter] = \"--yaml\";\n\tif (!strcmp(n_ui->name + (strlen(n_ui->name) - 3), \".js\"))\n\t\tvassal_argv[counter] = \"--json\";\n\tif (!strcmp(n_ui->name + (strlen(n_ui->name) - 5), \".json\"))\n\t\tvassal_argv[counter] = \"--json\";\n\tstruct uwsgi_string_list *usl = uwsgi.emperor_extra_extension;\n\twhile (usl) {\n\t\tif (uwsgi_endswith(n_ui->name, usl->value)) {\n\t\t\tvassal_argv[counter] = \"--config\";\n\t\t\tbreak;\n\t\t}\n\t\tusl = usl->next;\n\t}\n\tif (colon)\n\t\tcolon[0] = ':';\n\n\t// start config filename...\n\tcounter++;\n\n\tvassal_argv[counter] = n_ui->name;\n\tif (uwsgi.emperor_magic_exec) {\n\t\tif (!access(n_ui->name, R_OK | X_OK)) {\n\t\t\tvassal_argv[counter] = uwsgi_concat2(\"exec://\", n_ui->name);\n\t\t}\n\n\t}\n\n\tif (n_ui->use_config) {\n\t\tvassal_argv[counter] = uwsgi_concat2(\"emperor://\", n_ui->name);\n\t}\n\n\t// start templates,includes,inherit...\n\tcounter++;\n\n\tuwsgi_foreach(uct, uwsgi.vassals_templates) {\n\t\tvassal_argv[counter] = \"--inherit\";\n\t\tvassal_argv[counter + 1] = uct->value;\n\t\tcounter += 2;\n\t}\n\n\tuwsgi_foreach(uct, uwsgi.vassals_includes) {\n\t\tvassal_argv[counter] = \"--include\";\n\t\tvassal_argv[counter + 1] = uct->value;\n\t\tcounter += 2;\n\t}\n\n\tvassal_argv[counter] = NULL;\n\n\t// disable stdin OR map it to the \"on demand\" socket\n\tif (n_ui->on_demand_fd > -1) {\n\t\tif (n_ui->on_demand_fd != 0) {\n\t\t\tif (dup2(n_ui->on_demand_fd, 0) < 0) {\n\t\t\t\tuwsgi_error(\"dup2()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tclose(n_ui->on_demand_fd);\n\t\t}\n\t}\n\telse {\n\t\tuwsgi_remap_fd(0, \"/dev/null\");\n\t}\n\n\t// close all of the unneded fd\n\tfor (i = 3; i < (int) uwsgi.max_fd; i++) {\n\t\tif (uwsgi_fd_is_safe(i))\n\t\t\tcontinue;\n\t\tif (n_ui->use_config) {\n\t\t\tif (i == n_ui->pipe_config[1])\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (i != n_ui->pipe[1]) {\n\t\t\tclose(i);\n\t\t}\n\t}\n\n\t// run start hook (can fail)\n\tif (uwsgi.vassals_start_hook) {\n\t\tuwsgi_log(\"[emperor] running vassal start-hook: %s %s\\n\", uwsgi.vassals_start_hook, n_ui->name);\n\t\tif (uwsgi.emperor_absolute_dir) {\n\t\t\tif (setenv(\"UWSGI_VASSALS_DIR\", uwsgi.emperor_absolute_dir, 1)) {\n\t\t\t\tuwsgi_error(\"setenv()\");\n\t\t\t}\n\t\t}\n\t\tint start_hook_ret = uwsgi_run_command_and_wait(uwsgi.vassals_start_hook, n_ui->name);\n\t\tuwsgi_log(\"[emperor] %s start-hook returned %d\\n\", n_ui->name, start_hook_ret);\n\t}\n\n\tuwsgi_hooks_run(uwsgi.hook_as_vassal, \"as-vassal\", 1);\n\n\tuwsgi_foreach(usl, uwsgi.mount_as_vassal) {\n\t\tuwsgi_log(\"mounting \\\"%s\\\" (as-vassal)...\\n\", usl->value);\n\t\tif (uwsgi_mount_hook(usl->value)) {\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.umount_as_vassal) {\n\t\tuwsgi_log(\"un-mounting \\\"%s\\\" (as-vassal)...\\n\", usl->value);\n\t\tif (uwsgi_umount_hook(usl->value)) {\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// run exec hooks (cannot fail)\n\tuwsgi_foreach(usl, uwsgi.exec_as_vassal) {\n\t\tuwsgi_log(\"running \\\"%s\\\" (as-vassal)...\\n\", usl->value);\n\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\tif (ret != 0) {\n\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// run low-level hooks\n\tuwsgi_foreach(usl, uwsgi.call_as_vassal) {\n\t\tvoid (*func) (void) = dlsym(RTLD_DEFAULT, usl->value);\n\t\tif (!func) {\n\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n\t\t}\n\t\tfunc();\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.call_as_vassal1) {\n\t\tvoid (*func) (char *) = dlsym(RTLD_DEFAULT, usl->value);\n\t\tif (!func) {\n\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n\t\t}\n\t\tfunc(n_ui->name);\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.call_as_vassal3) {\n\t\tvoid (*func) (char *, uid_t, gid_t) = dlsym(RTLD_DEFAULT, usl->value);\n\t\tif (!func) {\n\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n\t\t}\n\t\tfunc(n_ui->name, n_ui->uid, n_ui->gid);\n\t}\n\n\t// ->vassal_before_exec\n\tfor (i = 0; i < 256; i++) {\n                if (uwsgi.p[i]->vassal_before_exec) {\n                        uwsgi.p[i]->vassal_before_exec(n_ui);\n                }\n        }\n\n        for (i = 0; i < uwsgi.gp_cnt; i++) {\n                if (uwsgi.gp[i]->vassal) {\n                        uwsgi.gp[i]->vassal_before_exec(n_ui);\n                }\n        }\n\n\t\n\tif (uwsgi.emperor_wrapper_override) {\n\t\tchar *orig_wrapper = vassal_argv[0];\t\n\t\tuwsgi_foreach(usl, uwsgi.emperor_wrapper_override) {\n\t\t\tvassal_argv[0] = usl->value;\n\t\t\tuwsgi_log(\"[emperor] trying to use %s as binary wrapper ...\\n\", usl->value);\n\t\t\texecvp(vassal_argv[0], vassal_argv);\n\t\t\t// not here if the binary is found\n\t\t}\n\t\tvassal_argv[0] = orig_wrapper;\n\t}\n\n\t// start !!!\n\tif (execvp(vassal_argv[0], vassal_argv)) {\n\t\tuwsgi_error(\"execvp()\");\n\t}\n\tuwsgi_log(\"[emperor] binary path: %s\\n\", vassal_argv[0]);\n\tuwsgi_log(\"[emperor] is the uwsgi binary in your system PATH ?\\n\");\n\n\t// trying fallback\n\tuwsgi_foreach(usl, uwsgi.emperor_wrapper_fallback) {\n\t\tuwsgi_log(\"[emperor] trying to use %s as binary fallback ...\\n\", usl->value);\n                vassal_argv[0] = usl->value;\n                execvp(vassal_argv[0], vassal_argv);\n                // not here if the binary is found\n        }\n\t// never here\n\texit(UWSGI_EXILE_CODE);\n\n\treturn 0;\n}\n\nvoid uwsgi_imperial_monitor_glob_init(struct uwsgi_emperor_scanner *ues) {\n\tif (chdir(uwsgi.cwd)) {\n\t\tuwsgi_error(\"chdir()\");\n\t\texit(1);\n\t}\n\n\tuwsgi.emperor_absolute_dir = uwsgi.cwd;\n\n\tif (!uwsgi_startswith(ues->arg, \"glob://\", 7)) {\n\t\tues->arg += 7;\n\t}\n}\n\nvoid uwsgi_imperial_monitor_directory_init(struct uwsgi_emperor_scanner *ues) {\n\n\tif (!uwsgi_startswith(ues->arg, \"dir://\", 6)) {\n\t\tues->arg += 6;\n\t}\n\n\tif (chdir(ues->arg)) {\n\t\tuwsgi_error(\"chdir()\");\n\t\texit(1);\n\t}\n\n\tuwsgi.emperor_absolute_dir = uwsgi_malloc(PATH_MAX + 1);\n\tif (realpath(\".\", uwsgi.emperor_absolute_dir) == NULL) {\n\t\tuwsgi_error(\"realpath()\");\n\t\texit(1);\n\t}\n\n\tues->arg = uwsgi.emperor_absolute_dir;\n\n}\n\nstruct uwsgi_imperial_monitor *imperial_monitor_get_by_id(char *scheme) {\n\tstruct uwsgi_imperial_monitor *uim = uwsgi.emperor_monitors;\n\twhile (uim) {\n\t\tif (!strcmp(uim->scheme, scheme)) {\n\t\t\treturn uim;\n\t\t}\n\t\tuim = uim->next;\n\t}\n\treturn NULL;\n}\n\nstruct uwsgi_imperial_monitor *imperial_monitor_get_by_scheme(char *arg) {\n\tstruct uwsgi_imperial_monitor *uim = uwsgi.emperor_monitors;\n\twhile (uim) {\n\t\tchar *scheme = uwsgi_concat2(uim->scheme, \"://\");\n\t\tif (!uwsgi_starts_with(arg, strlen(arg), scheme, strlen(scheme))) {\n\t\t\tfree(scheme);\n\t\t\treturn uim;\n\t\t}\n\t\tfree(scheme);\n\t\tuim = uim->next;\n\t}\n\treturn NULL;\n}\n\nvoid emperor_add_scanner(struct uwsgi_imperial_monitor *monitor, char *arg) {\n\tstruct uwsgi_emperor_scanner *ues = emperor_scanners;\n\tif (!ues) {\n\t\tues = uwsgi_calloc(sizeof(struct uwsgi_emperor_scanner));\n\t\temperor_scanners = ues;\n\t}\n\telse {\n\t\twhile (ues) {\n\t\t\tif (!ues->next) {\n\t\t\t\tues->next = uwsgi_calloc(sizeof(struct uwsgi_emperor_scanner));\n\t\t\t\tues = ues->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tues = ues->next;\n\t\t}\n\t}\n\n\tues->arg = arg;\n\tues->monitor = monitor;\n\tues->next = NULL;\n\tues->fd = -1;\n\t// run the init hook\n\tues->monitor->init(ues);\n}\n\nvoid uwsgi_emperor_run_scanners(void) {\n\tstruct uwsgi_emperor_scanner *ues = emperor_scanners;\n\twhile (ues) {\n\t\tues->monitor->func(ues);\n\t\tues = ues->next;\n\t}\n\temperor_warming_up = 0;\n}\n\nvoid emperor_build_scanners() {\n\tstruct uwsgi_string_list *usl = uwsgi.emperor;\n\tglob_t g;\n\twhile (usl) {\n\t\tstruct uwsgi_imperial_monitor *uim = imperial_monitor_get_by_scheme(usl->value);\n\t\tif (uim) {\n\t\t\temperor_add_scanner(uim, usl->value);\n\t\t}\n\t\telse {\n\t\t\t// check for \"glob\" and fallback to \"dir\"\n\t\t\tif (!glob(usl->value, GLOB_MARK | GLOB_NOCHECK, NULL, &g)) {\n\t\t\t\tif (g.gl_pathc == 1 && g.gl_pathv[0][strlen(g.gl_pathv[0]) - 1] == '/') {\n\t\t\t\t\tglobfree(&g);\n\t\t\t\t\tgoto dir;\n\t\t\t\t}\n\t\t\t\tglobfree(&g);\n\t\t\t\tuim = imperial_monitor_get_by_id(\"glob\");\n\t\t\t\temperor_add_scanner(uim, usl->value);\n\t\t\t\tgoto next;\n\t\t\t}\ndir:\n\t\t\tuim = imperial_monitor_get_by_id(\"dir\");\n\t\t\temperor_add_scanner(uim, usl->value);\n\t\t}\nnext:\n\t\tusl = usl->next;\n\t}\n}\n\nint uwsgi_emperor_scanner_event(int fd) {\n\n\tstruct uwsgi_emperor_scanner *ues = emperor_scanners;\n\twhile (ues) {\n\t\tif (ues->fd > -1 && ues->fd == fd) {\n\t\t\tues->event_func(ues);\n\t\t\treturn 1;\n\t\t}\n\t\tues = ues->next;\n\t}\n\n\treturn 0;\n\n}\n\nstatic void emperor_wakeup(int sn) {\n}\n\nstatic void emperor_cleanup(int signum) {\n\tuwsgi_log_verbose(\"[emperor] cleaning up blacklist ...\\n\");\n\tstruct uwsgi_emperor_blacklist_item *uebi = emperor_blacklist;\n\twhile (uebi) {\n\t\tstruct uwsgi_emperor_blacklist_item *next = uebi->next;\n\t\tfree(uebi);\n\t\tuebi = next;\n\t}\n\temperor_blacklist = NULL;\n}\n\nvoid emperor_loop() {\n\n\t// monitor a directory\n\n\tstruct uwsgi_instance ui_base;\n\tstruct uwsgi_instance *ui_current;\n\n\tpid_t diedpid;\n\tint waitpid_status;\n\tint has_children = 0;\n\tint i_am_alone = 0;\n\tint i;\n\n\tvoid *events;\n\tint nevents;\n\tint interesting_fd;\n\tchar notification_message[64];\n\tstruct rlimit rl;\n\n\tuwsgi.disable_nuclear_blast = 1;\n\n\tuwsgi.emperor_stats_fd = -1;\n\n\tif (uwsgi.emperor_pidfile) {\n\t\tuwsgi_write_pidfile(uwsgi.emperor_pidfile);\n\t}\n\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGWINCH, emperor_wakeup);\n\tuwsgi_unix_signal(SIGINT, royal_death);\n\tuwsgi_unix_signal(SIGTERM, royal_death);\n\tuwsgi_unix_signal(SIGQUIT, royal_death);\n\tuwsgi_unix_signal(SIGUSR1, emperor_stats);\n\tuwsgi_unix_signal(SIGHUP, emperor_massive_reload);\n\tuwsgi_unix_signal(SIGURG, emperor_cleanup);\n\n\tmemset(&ui_base, 0, sizeof(struct uwsgi_instance));\n\n\tif (getrlimit(RLIMIT_NOFILE, &rl)) {\n\t\tuwsgi_error(\"getrlimit()\");\n\t\texit(1);\n\t}\n\n\tuwsgi.max_fd = rl.rlim_cur;\n\n\temperor_throttle_level = uwsgi.emperor_throttle;\n\temperor_throttle = 0;\n\n\t// the queue must be initialized before adding scanners\n\tuwsgi.emperor_queue = event_queue_init();\n\n\temperor_build_scanners();\n\n\tevents = event_queue_alloc(64);\n\n\tif (uwsgi.has_emperor) {\n\t\tuwsgi_log(\"*** starting uWSGI sub-Emperor ***\\n\");\n\t}\n\telse {\n\t\tuwsgi_log(\"*** starting uWSGI Emperor ***\\n\");\n\t}\n\n\tif (uwsgi.emperor_stats) {\n\t\tchar *tcp_port = strchr(uwsgi.emperor_stats, ':');\n\t\tif (tcp_port) {\n\t\t\t// disable deferred accept for this socket\n\t\t\tint current_defer_accept = uwsgi.no_defer_accept;\n\t\t\tuwsgi.no_defer_accept = 1;\n\t\t\tuwsgi.emperor_stats_fd = bind_to_tcp(uwsgi.emperor_stats, uwsgi.listen_queue, tcp_port);\n\t\t\tuwsgi.no_defer_accept = current_defer_accept;\n\t\t}\n\t\telse {\n\t\t\tuwsgi.emperor_stats_fd = bind_to_unix(uwsgi.emperor_stats, uwsgi.listen_queue, uwsgi.chmod_socket, uwsgi.abstract_socket);\n\t\t}\n\n\t\tevent_queue_add_fd_read(uwsgi.emperor_queue, uwsgi.emperor_stats_fd);\n\t\tuwsgi_log(\"*** Emperor stats server enabled on %s fd: %d ***\\n\", uwsgi.emperor_stats, uwsgi.emperor_stats_fd);\n\t}\n\n\tui = &ui_base;\n\n\tint freq = 0;\n\n\tuwsgi_hooks_run(uwsgi.hook_emperor_start, \"emperor-start\", 1);\n\n\t// signal parent-Emperor about my loyalty\n\tif (uwsgi.has_emperor && !uwsgi.loyal) {\n\t\tuwsgi_log(\"announcing my loyalty to the Emperor...\\n\");\n\t\tchar byte = 17;\n\t\tif (write(uwsgi.emperor_fd, &byte, 1) != 1) {\n\t\t\tuwsgi_error(\"write()\");\n\t\t}\n\t\tuwsgi.loyal = 1;\n\t}\n\n\tfor (;;) {\n\n\t\tif (on_royal_death) {\n\t\t\tif (!ui->ui_next)\n\t\t\t\tbreak;\n\t\t\tif (uwsgi_now() - on_royal_death >= uwsgi.reload_mercy) {\n\t\t\t\tui_current = ui->ui_next;\n\t\t\t\twhile (ui_current) {\n\t\t\t\t\tuwsgi_log_verbose(\"[emperor] NO MERCY for vassal %s !!!\\n\", ui_current->name);\n\t\t\t\t\tif (kill(ui_current->pid, SIGKILL) < 0) {\n\t\t\t\t\t\tuwsgi_error(\"[emperor] kill()\");\n\t\t\t\t\t\temperor_del(ui_current);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tui_current = ui_current->ui_next;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tui_current = ui->ui_next;\n\t\t\twhile (ui_current) {\n\t\t\t\tstruct uwsgi_instance *dead_vassal = ui_current;\n\t\t\t\tui_current = ui_current->ui_next;\n\t\t\t\tpid_t dead_pid = waitpid(dead_vassal->pid, &waitpid_status, WNOHANG);\n\t\t\t\tif (dead_pid > 0 || dead_pid < 0) {\n\t\t\t\t\temperor_del(dead_vassal);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsleep(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!i_am_alone) {\n\t\t\tdiedpid = waitpid(uwsgi.emperor_pid, &waitpid_status, WNOHANG);\n\t\t\tif (diedpid < 0 || diedpid > 0) {\n\t\t\t\ti_am_alone = 1;\n\t\t\t}\n\t\t}\n\n\t\tnevents = event_queue_wait_multi(uwsgi.emperor_queue, freq, events, 64);\n\t\tfreq = uwsgi.emperor_freq;\n\n\t\tfor (i = 0; i < nevents; i++) {\n\t\t\tinteresting_fd = event_queue_interesting_fd(events, i);\n\n\t\t\tif (uwsgi.emperor_stats && uwsgi.emperor_stats_fd > -1 && interesting_fd == uwsgi.emperor_stats_fd) {\n\t\t\t\temperor_send_stats(uwsgi.emperor_stats_fd);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// check if a monitor is mapped to that file descriptor\n\t\t\tif (uwsgi_emperor_scanner_event(interesting_fd)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tui_current = emperor_get_by_fd(interesting_fd);\n\t\t\tif (ui_current) {\n\t\t\t\tchar byte;\n\t\t\t\tssize_t rlen = read(interesting_fd, &byte, 1);\n\t\t\t\t// retry if needed\n\t\t\t\tif (rlen < 0 && uwsgi_is_again()) continue;\n\t\t\t\tif (rlen <= 0) {\n\t\t\t\t\t// SAFE\n\t\t\t\t\tevent_queue_del_fd(uwsgi.emperor_queue, interesting_fd, event_queue_read());\n\t\t\t\t\tif (ui_current->status > 0) {\n\t\t\t\t\t\t// temporarily set frequency to a low value , so we can eventually fast-restart the instance\n\t\t\t\t\t\tfreq = ui_current->status;\n\t\t\t\t\t}\n\t\t\t\t\temperor_curse(ui_current);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (byte == 17) {\n\t\t\t\t\t\tui_current->loyal = 1;\n\t\t\t\t\t\tui_current->last_loyal = uwsgi_now();\n\t\t\t\t\t\tuwsgi_log_verbose(\"[emperor] vassal %s is now loyal\\n\", ui_current->name);\n\t\t\t\t\t\t// remove it from the blacklist\n\t\t\t\t\t\tuwsgi_emperor_blacklist_remove(ui_current->name);\n\t\t\t\t\t\t// TODO post-start hook\n\t\t\t\t\t}\n\t\t\t\t\t// heartbeat can be used for spotting blocked instances\n\t\t\t\t\telse if (byte == 26) {\n\t\t\t\t\t\tui_current->last_heartbeat = uwsgi_now();\n\t\t\t\t\t}\n\t\t\t\t\telse if (byte == 22) {\n\t\t\t\t\t\t// command 22 changes meaning when in \"on_demand\" mode  \n\t\t\t\t\t\tif (ui_current->on_demand_fd != -1) {\n\t\t\t\t\t\t\temperor_back_to_ondemand(ui_current);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\temperor_stop(ui_current);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (byte == 30 && uwsgi.emperor_broodlord > 0 && uwsgi.emperor_broodlord_count < uwsgi.emperor_broodlord) {\n\t\t\t\t\t\tuwsgi_log_verbose(\"[emperor] going in broodlord mode: launching zergs for %s\\n\", ui_current->name);\n\t\t\t\t\t\tchar *zerg_name = uwsgi_concat3(ui_current->name, \":\", \"zerg\");\n\t\t\t\t\t\t// here we discard socket name as broodlord/zerg cannot be on demand\n\t\t\t\t\t\temperor_add(ui_current->scanner, zerg_name, uwsgi_now(), NULL, 0, ui_current->uid, ui_current->gid, NULL);\n\t\t\t\t\t\tfree(zerg_name);\n\t\t\t\t\t}\n\t\t\t\t\telse if (byte == 5) {\n\t\t\t\t\t\tui_current->accepting = 1;\n\t\t\t\t\t\tui_current->last_accepting = uwsgi_now();\n\t\t\t\t\t\tuwsgi_log_verbose(\"[emperor] vassal %s is ready to accept requests\\n\", ui_current->name);\n\t\t\t\t\t}\n\t\t\t\t\telse if (byte == 1) {\n\t\t\t\t\t\tui_current->ready = 1;\n\t\t\t\t\t\tui_current->last_ready = uwsgi_now();\n\t\t\t\t\t\tuwsgi_log_verbose(\"[emperor] vassal %s has been spawned\\n\", ui_current->name);\n\t\t\t\t\t}\n\t\t\t\t\telse if (byte == 2) {\n\t\t\t\t\t\temperor_push_config(ui_current);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tui_current = emperor_get_by_socket_fd(interesting_fd);\n\t\t\t\tif (ui_current) {\n\t\t\t\t\tevent_queue_del_fd(uwsgi.emperor_queue, ui_current->on_demand_fd, event_queue_read());\n\t\t\t\t\tif (uwsgi_emperor_vassal_start(ui_current)) {\n\t\t\t\t\t\temperor_del(ui_current);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_log(\"[emperor] unrecognized vassal event on fd %d\\n\", interesting_fd);\n\t\t\t\t\tclose(interesting_fd);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tuwsgi_emperor_run_scanners();\n\n\t\t// check for heartbeat (if required)\n\t\tui_current = ui->ui_next;\n\t\twhile (ui_current) {\n\t\t\tif (ui_current->last_heartbeat > 0) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%d %d %d %d\\n\", ui_current->last_heartbeat, uwsgi.emperor_heartbeat, ui_current->last_heartbeat + uwsgi.emperor_heartbeat, uwsgi_now());\n#endif\n\t\t\t\tif ((ui_current->last_heartbeat + uwsgi.emperor_heartbeat) < uwsgi_now()) {\n\t\t\t\t\tuwsgi_log(\"[emperor] vassal %s sent no heartbeat in last %d seconds, brutally respawning it...\\n\", ui_current->name, uwsgi.emperor_heartbeat);\n\t\t\t\t\t// set last_heartbeat to 0 avoiding races\n\t\t\t\t\tui_current->last_heartbeat = 0;\n\t\t\t\t\tif (ui_current->pid > 0) {\n\t\t\t\t\t\tif (kill(ui_current->pid, SIGKILL) < 0) {\n\t\t\t\t\t\t\tuwsgi_error(\"[emperor] kill()\");\n\t\t\t\t\t\t\temperor_del(ui_current);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tui_current = ui_current->ui_next;\n\t\t}\n\n\nrecheck:\n\t\t// check for removed instances\n\t\tui_current = ui;\n\t\thas_children = 0;\n\t\twhile (ui_current->ui_next) {\n\t\t\tui_current = ui_current->ui_next;\n\t\t\tif (ui_current->pid > -1) {\n\t\t\t\thas_children++;\n\t\t\t}\n\t\t}\n\n\t\tif (uwsgi.notify) {\n\t\t\tif (snprintf(notification_message, 64, \"The Emperor is governing %d vassals\", has_children) >= 34) {\n\t\t\t\tuwsgi_notify(notification_message);\n\t\t\t}\n\t\t}\n\n\t\tif (has_children) {\n\t\t\tdiedpid = waitpid(WAIT_ANY, &waitpid_status, WNOHANG);\n\t\t}\n\t\telse {\n\t\t\t// vacuum\n\t\t\twaitpid(WAIT_ANY, &waitpid_status, WNOHANG);\n\t\t\tdiedpid = 0;\n\t\t}\n\t\tif (diedpid < 0) {\n\t\t\t// it looks like it happens when OOM is triggered to Linux cgroup, but it could be a uWSGI bug :P\n\t\t\t// by the way, fallback to a clean situation...\n\t\t\tif (errno == ECHILD) {\n\t\t\t\tuwsgi_log(\"--- MUTINY DETECTED !!! IMPALING VASSALS... ---\\n\");\n\t\t\t\tui_current = ui->ui_next;\n\t\t\t\twhile (ui_current) {\n\t\t\t\t\tstruct uwsgi_instance *rebel_vassal = ui_current;\n\t\t\t\t\tui_current = ui_current->ui_next;\n\t\t\t\t\temperor_del(rebel_vassal);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t}\n\t\t}\n\t\tui_current = ui;\n\t\twhile (ui_current->ui_next) {\n\t\t\tui_current = ui_current->ui_next;\n\t\t\ttime_t now = uwsgi_now();\n\t\t\tif (diedpid > 0 && ui_current->pid == diedpid) {\n\t\t\t\tif (ui_current->status == 0) {\n\t\t\t\t\t// respawn an accidentally dead instance if its exit code is not UWSGI_EXILE_CODE\n\t\t\t\t\tif (WIFEXITED(waitpid_status) && WEXITSTATUS(waitpid_status) == UWSGI_EXILE_CODE) {\n\t\t\t\t\t\t// SAFE\n\t\t\t\t\t\temperor_del(ui_current);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// UNSAFE\n\t\t\t\t\t\tchar *config = NULL;\n\t\t\t\t\t\tif (ui_current->config) {\n\t\t\t\t\t\t\tconfig = uwsgi_str(ui_current->config);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchar *socket_name = NULL;\n\t\t\t\t\t\tif (ui_current->socket_name) {\n\t\t\t\t\t\t\tsocket_name = uwsgi_str(ui_current->socket_name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\temperor_add(ui_current->scanner, ui_current->name, ui_current->last_mod, config, ui_current->config_len, ui_current->uid, ui_current->gid, socket_name);\n\t\t\t\t\t\t// temporarily set frequency to 0, so we can eventually fast-restart the instance\n\t\t\t\t\t\temperor_del(ui_current);\n\t\t\t\t\t\tfreq = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (ui_current->status == 1) {\n\t\t\t\t\t// remove 'marked for dead' instance\n\t\t\t\t\temperor_del(ui_current);\n\t\t\t\t\t// temporarily set frequency to 0, so we can eventually fast-restart the instance\n\t\t\t\t\tfreq = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// back to on_demand mode ...\n\t\t\t\telse if (ui_current->status == 2) {\n\t\t\t\t\tevent_queue_add_fd_read(uwsgi.emperor_queue, ui_current->on_demand_fd);\n\t\t\t\t\tclose(ui_current->pipe[0]);\n\t\t\t\t\tui_current->pipe[0] = -1;\n\t\t\t\t\tif (ui_current->use_config) {\n\t\t\t\t\t\tclose(ui_current->pipe_config[0]);\n\t\t\t\t\t\tui_current->pipe_config[0] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tui_current->pid = -1;\n\t\t\t\t\tui_current->status = 0;\n\t\t\t\t\tui_current->cursed_at = 0;\n\t\t\t\t\tui_current->ready = 0;\n\t\t\t\t\tui_current->accepting = 0;\n\t\t\t\t\tuwsgi_log(\"[uwsgi-emperor] %s -> back to \\\"on demand\\\" mode, waiting for connections on socket \\\"%s\\\" ...\\n\", ui_current->name, ui_current->socket_name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ui_current->cursed_at > 0) {\n\t\t\t\tif (ui_current->pid == -1) {\n\t\t\t\t\temperor_del(ui_current);\n\t\t\t\t\t// temporarily set frequency to 0, so we can eventually fast-restart the instance\n\t\t\t\t\tfreq = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (now - ui_current->cursed_at >= uwsgi.emperor_curse_tolerance) {\n\t\t\t\t\tui_current->cursed_at = now;\n\t\t\t\t\tif (kill(ui_current->pid, SIGKILL) < 0) {\n\t\t\t\t\t\tuwsgi_error(\"[emperor] kill()\");\n\t\t\t\t\t\t// delete the vassal, something is seriously wrong better to not leak memory...\n\t\t\t\t\t\temperor_del(ui_current);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if waitpid returned an item, let's check for another (potential) one\n\t\tif (diedpid > 0)\n\t\t\tgoto recheck;\n\n\n\t}\n\n\tuwsgi_log_verbose(\"The Emperor is buried.\\n\");\n\tuwsgi_notify(\"The Emperor is buried.\");\n\texit(0);\n\n}\n\nvoid emperor_send_stats(int fd) {\n\n\tstruct sockaddr_un client_src;\n\tsocklen_t client_src_len = 0;\n\n\tint client_fd = accept(fd, (struct sockaddr *) &client_src, &client_src_len);\n\tif (client_fd < 0) {\n\t\tuwsgi_error(\"accept()\");\n\t\treturn;\n\t}\n\n\tif (uwsgi.stats_http) {\n\t\tif (uwsgi_send_http_stats(client_fd)) {\n\t\t\tclose(client_fd);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct uwsgi_stats *us = uwsgi_stats_new(8192);\n\n\tif (uwsgi_stats_keyval_comma(us, \"version\", UWSGI_VERSION))\n\t\tgoto end;\n\tif (uwsgi_stats_keylong_comma(us, \"pid\", (unsigned long long) getpid()))\n\t\tgoto end;\n\tif (uwsgi_stats_keylong_comma(us, \"uid\", (unsigned long long) getuid()))\n\t\tgoto end;\n\tif (uwsgi_stats_keylong_comma(us, \"gid\", (unsigned long long) getgid()))\n\t\tgoto end;\n\n\tchar *cwd = uwsgi_get_cwd();\n\tif (uwsgi_stats_keyval_comma(us, \"cwd\", cwd))\n\t\tgoto end0;\n\n\tif (uwsgi_stats_key(us, \"emperor\"))\n\t\tgoto end0;\n\tif (uwsgi_stats_list_open(us))\n\t\tgoto end0;\n\tstruct uwsgi_emperor_scanner *ues = emperor_scanners;\n\twhile (ues) {\n\t\tif (uwsgi_stats_str(us, ues->arg))\n\t\t\tgoto end0;\n\t\tues = ues->next;\n\t\tif (ues) {\n\t\t\tif (uwsgi_stats_comma(us))\n\t\t\t\tgoto end0;\n\t\t}\n\t}\n\tif (uwsgi_stats_list_close(us))\n\t\tgoto end0;\n\n\tif (uwsgi_stats_comma(us))\n\t\tgoto end0;\n\n\tif (uwsgi_stats_keylong_comma(us, \"emperor_tyrant\", (unsigned long long) uwsgi.emperor_tyrant))\n\t\tgoto end0;\n\n\t// will be zero for now\n\tif (uwsgi_stats_keylong_comma(us, \"throttle_level\", (unsigned long long) 0))\n\t\tgoto end0;\n\n\n\tif (uwsgi_stats_key(us, \"vassals\"))\n\t\tgoto end0;\n\tif (uwsgi_stats_list_open(us))\n\t\tgoto end0;\n\n\tstruct uwsgi_instance *c_ui = ui->ui_next;\n\n\twhile (c_ui) {\n\t\tif (uwsgi_stats_object_open(us))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_keyval_comma(us, \"id\", c_ui->name))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_keyslong_comma(us, \"pid\", (long long) c_ui->pid))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"born\", (unsigned long long) c_ui->born))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"last_mod\", (unsigned long long) c_ui->last_mod))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"last_heartbeat\", (unsigned long long) c_ui->last_heartbeat))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"loyal\", (unsigned long long) c_ui->loyal))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"ready\", (unsigned long long) c_ui->ready))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"accepting\", (unsigned long long) c_ui->accepting))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"last_loyal\", (unsigned long long) c_ui->last_loyal))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"last_ready\", (unsigned long long) c_ui->last_ready))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"last_accepting\", (unsigned long long) c_ui->last_accepting))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"first_run\", (unsigned long long) c_ui->first_run))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"last_run\", (unsigned long long) c_ui->last_run))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"cursed\", (unsigned long long) c_ui->cursed_at))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"zerg\", (unsigned long long) c_ui->zerg))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_keyval_comma(us, \"on_demand\", c_ui->socket_name ? c_ui->socket_name : \"\"))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_keylong_comma(us, \"uid\", (unsigned long long) c_ui->uid))\n\t\t\tgoto end0;\n\t\tif (uwsgi_stats_keylong_comma(us, \"gid\", (unsigned long long) c_ui->gid))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_keyval_comma(us, \"monitor\", c_ui->scanner->arg))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_keylong(us, \"respawns\", (unsigned long long) c_ui->respawns))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_object_close(us))\n\t\t\tgoto end0;\n\n\t\tc_ui = c_ui->ui_next;\n\n\t\tif (c_ui) {\n\t\t\tif (uwsgi_stats_comma(us))\n\t\t\t\tgoto end0;\n\t\t}\n\t}\n\n\n\tif (uwsgi_stats_list_close(us))\n\t\tgoto end0;\n\n\tif (uwsgi_stats_comma(us))\n\t\tgoto end0;\n\n\tif (uwsgi_stats_key(us, \"blacklist\"))\n\t\tgoto end0;\n\tif (uwsgi_stats_list_open(us))\n\t\tgoto end0;\n\n\tstruct uwsgi_emperor_blacklist_item *uebi = emperor_blacklist;\n\twhile (uebi) {\n\n\t\tif (uwsgi_stats_object_open(us))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_keyval_comma(us, \"id\", uebi->id))\n\t\t\tgoto end0;\n\n\n\t\tif (uwsgi_stats_keylong_comma(us, \"throttle_level\", uebi->throttle_level / 1000))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_keylong_comma(us, \"attempt\", (unsigned long long) uebi->attempt))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_keylong_comma(us, \"first_attempt\", (unsigned long long) uebi->first_attempt.tv_sec))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_keylong(us, \"last_attempt\", (unsigned long long) uebi->last_attempt.tv_sec))\n\t\t\tgoto end0;\n\n\t\tif (uwsgi_stats_object_close(us))\n\t\t\tgoto end0;\n\n\n\t\tuebi = uebi->next;\n\t\tif (uebi) {\n\t\t\tif (uwsgi_stats_comma(us))\n\t\t\t\tgoto end0;\n\t\t}\n\t}\n\n\n\tif (uwsgi_stats_list_close(us))\n\t\tgoto end0;\n\n\tif (uwsgi_stats_object_close(us))\n\t\tgoto end0;\n\n\tsize_t remains = us->pos;\n\toff_t pos = 0;\n\twhile (remains > 0) {\n\t\tint ret = uwsgi_waitfd_write(client_fd, uwsgi.socket_timeout);\n\t\tif (ret <= 0) {\n\t\t\tgoto end0;\n\t\t}\n\t\tssize_t res = write(client_fd, us->base + pos, remains);\n\t\tif (res <= 0) {\n\t\t\tif (res < 0) {\n\t\t\t\tuwsgi_error(\"write()\");\n\t\t\t}\n\t\t\tgoto end0;\n\t\t}\n\t\tpos += res;\n\t\tremains -= res;\n\t}\n\nend0:\n\tfree(cwd);\nend:\n\tfree(us->base);\n\tfree(us);\n\tclose(client_fd);\n}\n\nvoid uwsgi_emperor_start() {\n\n\tif (!uwsgi.sockets && !ushared->gateways_cnt && !uwsgi.master_process) {\n\t\tif (uwsgi.emperor_procname) {\n\t\t\tuwsgi_set_processname(uwsgi.emperor_procname);\n\t\t}\n\t\tuwsgi_notify_ready();\n\t\temperor_loop();\n\t\t// never here\n\t\texit(1);\n\t}\n\n\tif (uwsgi.emperor_procname) {\n\t\tuwsgi.emperor_pid = uwsgi_fork(uwsgi.emperor_procname);\n\t}\n\telse {\n\t\tuwsgi.emperor_pid = uwsgi_fork(\"uWSGI Emperor\");\n\t}\n\n\tif (uwsgi.emperor_pid < 0) {\n\t\tuwsgi_error(\"pid()\");\n\t\texit(1);\n\t}\n\telse if (uwsgi.emperor_pid == 0) {\n#ifdef __linux__\n\t\tif (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0)) {\n\t\t\tuwsgi_error(\"prctl()\");\n\t\t}\n#endif\n\t\temperor_loop();\n\t\t// never here\n\t\texit(1);\n\t}\n\n}\n\nvoid uwsgi_check_emperor() {\n\tchar *emperor_fd_pass = getenv(\"UWSGI_EMPEROR_PROXY\");\n\tif (emperor_fd_pass) {\n\t\tfor (;;) {\n\t\t\tint proxy_fd = uwsgi_connect(emperor_fd_pass, 30, 0);\n\t\t\tif (proxy_fd < 0) {\n\t\t\t\tuwsgi_error(\"uwsgi_check_emperor()/uwsgi_connect()\");\n\t\t\t\tsleep(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint count = 2;\n\t\t\tint *fds = uwsgi_attach_fd(proxy_fd, &count, \"uwsgi-emperor\", 13);\n\t\t\tif (fds && count > 0) {\n\t\t\t\tchar *env_emperor_fd = uwsgi_num2str(fds[0]);\n\t\t\t\tif (setenv(\"UWSGI_EMPEROR_FD\", env_emperor_fd, 1)) {\n\t\t\t\t\tuwsgi_error(\"uwsgi_check_emperor()/setenv(UWSGI_EMPEROR_FD)\");\n\t\t\t\t\tfree(env_emperor_fd);\n\t\t\t\t\tint i;\n\t\t\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\t\t\tclose(fds[i]);\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tfree(env_emperor_fd);\n\t\t\t\tif (count > 1) {\n\t\t\t\t\tchar *env_emperor_fd_config = uwsgi_num2str(fds[1]);\n\t\t\t\t\tif (setenv(\"UWSGI_EMPEROR_FD_CONFIG\", env_emperor_fd_config, 1)) {\n\t\t\t\t\t\tuwsgi_error(\"uwsgi_check_emperor()/setenv(UWSGI_EMPEROR_FD_CONFIG)\");\n\t\t\t\t\t\tfree(env_emperor_fd_config);\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\t\t\t\tclose(fds[i]);\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t\tfree(env_emperor_fd_config);\n\t\t\t\t}\n\t\t\t\tif (fds)\n\t\t\t\t\tfree(fds);\n\t\t\t\tclose(proxy_fd);\n\t\t\t\tbreak;\n\t\t\t}\nnext:\n\t\t\tif (fds)\n\t\t\t\tfree(fds);\n\t\t\tclose(proxy_fd);\n\t\t\tsleep(1);\n\t\t}\n\t\tunsetenv(\"UWSGI_EMPEROR_PROXY\");\n\t}\n\n\tchar *emperor_env = getenv(\"UWSGI_EMPEROR_FD\");\n\tif (emperor_env) {\n\t\tuwsgi.has_emperor = 1;\n\t\tuwsgi.emperor_fd = atoi(emperor_env);\n\t\tuwsgi.master_process = 1;\n\t\tuwsgi_log(\"*** has_emperor mode detected (fd: %d) ***\\n\", uwsgi.emperor_fd);\n\n\t\tif (getenv(\"UWSGI_EMPEROR_FD_CONFIG\")) {\n\t\t\tuwsgi.emperor_fd_config = atoi(getenv(\"UWSGI_EMPEROR_FD_CONFIG\"));\n\t\t}\n\t}\n\n}\n\nvoid uwsgi_emperor_simple_do(struct uwsgi_emperor_scanner *ues, char *name, char *config, time_t ts, uid_t uid, gid_t gid, char *socket_name) {\n\n\tif (!uwsgi_emperor_is_valid(name))\n\t\treturn;\n\n\tstruct uwsgi_instance *ui_current = emperor_get(name);\n\n\tif (ui_current) {\n\n\t\t// skip in case the instance is going down...\n\t\tif (ui_current->status > 0)\n\t\t\treturn;\n\n\t\t// check if uid or gid are changed, in such case, stop the instance\n\t\tif (uwsgi.emperor_tyrant) {\n\t\t\tif (uid != ui_current->uid || gid != ui_current->gid) {\n\t\t\t\tuwsgi_log(\"[emperor-tyrant] !!! permissions of vassal %s changed. stopping the instance... !!!\\n\", name);\n\t\t\t\temperor_stop(ui_current);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// check if mtime is changed and the uWSGI instance must be reloaded\n\t\tif (ts > ui_current->last_mod) {\n\t\t\t// now we neeed a special check for allowing an instance to move to \"on_demand\" mode (and back)\n\t\t\t// allowing means \"stoppping the instance\"\n\t\t\tif ((!ui_current->socket_name && ui_current->on_demand_fd == -1) && socket_name) {\n\t\t\t\tuwsgi_log(\"[uwsgi-emperor] %s -> requested move to \\\"on demand\\\" mode for socket \\\"%s\\\" ...\\n\", name, socket_name);\n\t\t\t\temperor_stop(ui_current);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if ((ui_current->socket_name && ui_current->on_demand_fd > -1) && !socket_name) {\n\t\t\t\tuwsgi_log(\"[uwsgi-emperor] %s -> asked for leaving \\\"on demand\\\" mode for socket \\\"%s\\\" ...\\n\", name, ui_current->socket_name);\n\t\t\t\temperor_stop(ui_current);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// make a new config (free the old one) if needed\n\t\t\tif (config) {\n\t\t\t\tif (ui_current->config)\n\t\t\t\t\tfree(ui_current->config);\n\t\t\t\tui_current->config = uwsgi_str(config);\n\t\t\t\tui_current->config_len = strlen(ui_current->config);\n\t\t\t}\n\t\t\t// reload the instance\n\t\t\temperor_respawn(ui_current, ts);\n\t\t}\n\t}\n\telse {\n\t\t// make a copy of the config as it will be freed\n\t\tchar *new_config = NULL;\n\t\tsize_t new_config_len = 0;\n\t\tif (config) {\n\t\t\tnew_config = uwsgi_str(config);\n\t\t\tnew_config_len = strlen(new_config);\n\t\t}\n\t\temperor_add(ues, name, ts, new_config, new_config_len, uid, gid, socket_name);\n\t}\n}\n\nvoid uwsgi_master_manage_emperor() {\n\tchar byte;\n#ifdef UWSGI_EVENT_USE_PORT\n\t// special cose for port event system\n\t// place the socket in non-blocking mode\n        uwsgi_socket_nb(uwsgi.emperor_fd);\n#endif\n\tssize_t rlen = read(uwsgi.emperor_fd, &byte, 1);\n#ifdef UWSGI_EVENT_USE_PORT\n\t// special cose for port event system\n\t// and place back in blocking mode\n        uwsgi_socket_b(uwsgi.emperor_fd);\n#endif\n\tif (rlen > 0) {\n\t\tuwsgi_log_verbose(\"received message %d from emperor\\n\", byte);\n\t\t// remove me\n\t\tif (byte == 0) {\n\t\t\tuwsgi_hooks_run(uwsgi.hook_emperor_stop, \"emperor-stop\", 0);\n\t\t\tclose(uwsgi.emperor_fd);\n\t\t\tif (!uwsgi.status.brutally_reloading)\n\t\t\t\tkill_them_all(0);\n\t\t}\n\t\t// reload me\n\t\telse if (byte == 1) {\n\t\t\tuwsgi_hooks_run(uwsgi.hook_emperor_reload, \"emperor-reload\", 0);\n\t\t\t// un-lazy the stack to trigger a real reload\n\t\t\tuwsgi.lazy = 0;\n\t\t\tuwsgi_block_signal(SIGHUP);\n\t\t\tgrace_them_all(0);\n\t\t\tuwsgi_unblock_signal(SIGHUP);\n\t\t}\n\t}\n#ifdef UWSGI_EVENT_USE_PORT\n        // special cose for port event system\n\telse if (rlen < 0 && uwsgi_is_again()) {\n\t\treturn;\n\t}\n#endif\n\telse {\n\t\tuwsgi_error(\"uwsgi_master_manage_emperor()/read()\");\n\t\tuwsgi_log(\"lost connection with my emperor !!!\\n\");\n\t\tuwsgi_hooks_run(uwsgi.hook_emperor_lost, \"emperor-lost\", 0);\n\t\tclose(uwsgi.emperor_fd);\n\t\tif (!uwsgi.status.brutally_reloading)\n\t\t\tkill_them_all(0);\n\t\tsleep(2);\n\t\texit(1);\n\t}\n\n}\n\nvoid uwsgi_master_manage_emperor_proxy() {\n\n\tstruct sockaddr_un epsun;\n\tsocklen_t epsun_len = sizeof(struct sockaddr_un);\n\n\tint ep_client = accept(uwsgi.emperor_fd_proxy, (struct sockaddr *) &epsun, &epsun_len);\n\tif (ep_client < 0) {\n\t\tuwsgi_error(\"uwsgi_master_manage_emperor_proxy()/accept()\");\n\t\treturn;\n\t}\n\n\tint num_fds = 1;\n\tif (uwsgi.emperor_fd_config > -1)\n\t\tnum_fds++;\n\n\tstruct msghdr ep_msg;\n\tvoid *ep_msg_control = uwsgi_malloc(CMSG_SPACE(sizeof(int) * num_fds));\n\tstruct iovec ep_iov[2];\n\tstruct cmsghdr *cmsg;\n\n\tep_iov[0].iov_base = \"uwsgi-emperor\";\n\tep_iov[0].iov_len = 13;\n\tep_iov[1].iov_base = &num_fds;\n\tep_iov[1].iov_len = sizeof(int);\n\n\tep_msg.msg_name = NULL;\n\tep_msg.msg_namelen = 0;\n\n\tep_msg.msg_iov = ep_iov;\n\tep_msg.msg_iovlen = 2;\n\n\tep_msg.msg_flags = 0;\n\tep_msg.msg_control = ep_msg_control;\n\tep_msg.msg_controllen = CMSG_SPACE(sizeof(int) * num_fds);\n\n\tcmsg = CMSG_FIRSTHDR(&ep_msg);\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int) * num_fds);\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\n\tunsigned char *ep_fd_ptr = CMSG_DATA(cmsg);\n\n\tmemcpy(ep_fd_ptr, &uwsgi.emperor_fd, sizeof(int));\n\tif (num_fds > 1) {\n\t\tmemcpy(ep_fd_ptr + sizeof(int), &uwsgi.emperor_fd_config, sizeof(int));\n\t}\n\n\tif (sendmsg(ep_client, &ep_msg, 0) < 0) {\n\t\tuwsgi_error(\"uwsgi_master_manage_emperor_proxy()/sendmsg()\");\n\t}\n\n\tfree(ep_msg_control);\n\n\tclose(ep_client);\n}\n\nstatic void emperor_notify_ready() {\n\tif (!uwsgi.has_emperor)\n\t\treturn;\n\tchar byte = 1;\n\tif (write(uwsgi.emperor_fd, &byte, 1) != 1) {\n\t\tuwsgi_error(\"emperor_notify_ready()/write()\");\n\t\texit(1);\n\t}\n}\n\nvoid uwsgi_setup_emperor() {\n\tif (!uwsgi.has_emperor)\n\t\treturn;\n\tuwsgi.notify_ready = emperor_notify_ready;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/core/hooks.c": "#include <uwsgi.h>\n\nextern struct uwsgi_server uwsgi;\n\n/*\n\n\tadvanced (pluggable) hooks\n\n\tthey are executed before the other hooks, and can be extended by plugins\n\n\tif a plugin tries to register an hook with a name already available in the list, its function\n\twill be overridden\n\n*/\n\nstruct uwsgi_hook *uwsgi_hook_by_name(char *name) {\n\tstruct uwsgi_hook *uh = uwsgi.hooks;\n\twhile(uh) {\n\t\tif (!strcmp(uh->name, name)) {\n\t\t\treturn uh;\n\t\t}\n\t\tuh = uh->next;\n\t}\n\treturn NULL;\n}\n\nvoid uwsgi_register_hook(char *name, int (*func)(char *)) {\n\tstruct uwsgi_hook *old_uh = NULL, *uh = uwsgi.hooks;\n        while(uh) {\n                if (!strcmp(uh->name, name)) {\n                        uh->func = func;\n\t\t\treturn;\n                }\n\t\told_uh = uh;\n\t\tuh = uh->next;\n        }\n\n\tuh = uwsgi_calloc(sizeof(struct uwsgi_hook));\n\tuh->name = name;\n\tuh->func = func;\n\n\tif (old_uh) {\n\t\told_uh->next = uh;\n\t}\n\telse {\n\t\tuwsgi.hooks = uh;\n\t}\n}\n\nstatic int uwsgi_hook_alarm(char *arg) {\n\tchar *space = strchr(arg,' ');\n\tif (!space) {\n\t\tuwsgi_log(\"invalid alarm hook syntax, must be: <alarm> <msg>\\n\");\n\t\treturn -1;\n\t}\n\t*space = 0;\n\tuwsgi_alarm_trigger(arg, space+1,  strlen(space+1));\n\t*space = ' ';\n\treturn 0;\n}\n\nstatic int uwsgi_hook_chdir(char *arg) {\n\tint ret = chdir(arg);\n\tif (ret) {\n\t\tuwsgi_error(\"uwsgi_hook_chdir()\");\n\t}\n\treturn ret;\n}\n\nstatic int uwsgi_hook_mkdir(char *arg) {\n        int ret = mkdir(arg, 0777);\n        if (ret) {\n                uwsgi_error(\"uwsgi_hook_mkdir()\");\n        }\n        return ret;\n}\n\nstatic int uwsgi_hook_putenv(char *arg) {\n        int ret = putenv(arg);\n        if (ret) {\n                uwsgi_error(\"uwsgi_hook_putenv()\");\n        }\n        return ret;\n}\n\nstatic int uwsgi_hook_exec(char *arg) {\n\tint ret = uwsgi_run_command_and_wait(NULL, arg);\n\tif (ret != 0) {\n        \tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", arg, ret);\n        }\n\treturn ret;\n}\n\nstatic int uwsgi_hook_safeexec(char *arg) {\n        int ret = uwsgi_run_command_and_wait(NULL, arg);\n        if (ret != 0) {\n                uwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", arg, ret);\n        }\n        return 0;\n}\n\nstatic int uwsgi_hook_exit(char *arg) {\n\tint exit_code = 0;\n\tif (strlen(arg) > 1) {\n\t\texit_code = atoi(arg);\n\t}\n\texit(exit_code);\n}\n\nstatic int uwsgi_hook_print(char *arg) {\n\tchar *line = uwsgi_concat2(arg, \"\\n\");\n\tuwsgi_log(line);\n\tfree(line);\n\treturn 0;\n}\n\nstatic int uwsgi_hook_unlink(char *arg) {\n\tint ret = unlink(arg);\n\tif (ret) {\n\t\tuwsgi_error(\"uwsgi_hook_unlink()/unlink()\");\n\t}\n\treturn ret;\n}\n\nstatic int uwsgi_hook_writefifo(char *arg) {\n\tchar *space = strchr(arg, ' ');\n\tif (!space) {\n\t\tuwsgi_log(\"invalid hook writefifo syntax, must be: <file> <string>\\n\");\n\t\treturn -1;\n\t}\n\t*space = 0;\n\tint fd = open(arg, O_WRONLY|O_NONBLOCK);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(arg);\n\t\t*space = ' ';\n\t\tif (errno == ENODEV) return 0;\n#ifdef ENXIO\n\t\tif (errno == ENXIO) return 0;\n#endif\n\t\treturn -1;\n\t}\n\t*space = ' ';\n\tsize_t l = strlen(space+1);\n\tif (write(fd, space+1, l) != (ssize_t) l) {\n\t\tuwsgi_error(\"uwsgi_hook_writefifo()/write()\");\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tclose(fd);\n        return 0;\n}\n\nstatic int uwsgi_hook_write(char *arg) {\n        char *space = strchr(arg, ' ');\n        if (!space) {\n                uwsgi_log(\"invalid hook write syntax, must be: <file> <string>\\n\");\n                return -1;\n        }\n        *space = 0;\n        int fd = open(arg, O_WRONLY|O_CREAT|O_TRUNC, 0666);\n        if (fd < 0) {\n                uwsgi_error_open(arg);\n                *space = ' ';\n                return -1;\n        }\n        *space = ' ';\n        size_t l = strlen(space+1);\n        if (write(fd, space+1, l) != (ssize_t) l) {\n                uwsgi_error(\"uwsgi_hook_write()/write()\");\n                close(fd);\n                return -1;\n        }\n        close(fd);\n        return 0;\n}\n\nstatic int uwsgi_hook_creat(char *arg) {\n        int fd = open(arg, O_WRONLY|O_CREAT|O_TRUNC, 0666);\n        if (fd < 0) {\n                uwsgi_error_open(arg);\n                return -1;\n        }\n        close(fd);\n        return 0;\n}\n\n\nstatic int uwsgi_hook_append(char *arg) {\n        char *space = strchr(arg, ' ');\n        if (!space) {\n                uwsgi_log(\"invalid hook append syntax, must be: <file> <string>\\n\");\n                return -1;\n        }\n        *space = 0;\n        int fd = open(arg, O_WRONLY|O_CREAT|O_APPEND, 0666);\n        if (fd < 0) {\n                uwsgi_error_open(arg);\n                *space = ' ';\n                return -1;\n        }\n        *space = ' ';\n        size_t l = strlen(space+1);\n        if (write(fd, space+1, l) != (ssize_t) l) {\n                uwsgi_error(\"uwsgi_hook_append()/write()\");\n                close(fd);\n                return -1;\n        }\n        close(fd);\n        return 0;\n}\n\n\nstatic int uwsgi_hook_writen(char *arg) {\n        char *space = strchr(arg, ' ');\n        if (!space) {\n                uwsgi_log(\"invalid hook writen syntax, must be: <file> <string>\\n\");\n                return -1;\n        }\n        *space = 0;\n        int fd = open(arg, O_WRONLY|O_CREAT|O_TRUNC, 0666);\n        if (fd < 0) {\n                uwsgi_error_open(arg);\n                *space = ' ';\n                return -1;\n        }\n        *space = ' ';\n        size_t l = strlen(space+1);\n\tchar *buf = uwsgi_malloc(l + 1);\n\tmemcpy(buf, space+1, l);\n\tbuf[l] = '\\n';\n        if (write(fd, buf, l+1) != (ssize_t) (l+1)) {\n                uwsgi_error(\"uwsgi_hook_writen()/write()\");\n\t\tfree(buf);\n                close(fd);\n                return -1;\n        }\n\tfree(buf);\n        close(fd);\n        return 0;\n}\n\nstatic int uwsgi_hook_appendn(char *arg) {\n        char *space = strchr(arg, ' ');\n\tif (space)\n        \t*space = 0;\n        int fd = open(arg, O_WRONLY|O_CREAT|O_APPEND, 0666);\n        if (fd < 0) {\n                uwsgi_error_open(arg);\n\t\tif (space)\n                \t*space = ' ';\n                return -1;\n        }\n\tif (!space) {\n\t\t// simple newline\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n                \tuwsgi_error(\"uwsgi_hook_appendn()/write()\");\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\t\tclose(fd);\n\t\treturn 0;\n\t}\n\n        *space = ' ';\n        size_t l = strlen(space+1);\n        char *buf = uwsgi_malloc(l + 1);\n\tmemcpy(buf, space+1, l);\n        buf[l] = '\\n';\n        if (write(fd, buf, l+1) != (ssize_t) (l+1)) {\n                uwsgi_error(\"uwsgi_hook_appendn()/write()\");\n                free(buf);\n                close(fd);\n                return -1;\n        }\n        free(buf);\n        close(fd);\n        return 0;\n}\n\n\n\nstatic int uwsgi_hook_chmod(char *arg) {\n\tchar *space = strchr(arg, ' ');\n        if (!space) {\n                uwsgi_log(\"invalid hook chmod syntax, must be: <file> <mode>\\n\");\n                return -1;\n        }\n        *space = 0;\n\tint error = 0;\n\tmode_t mask = uwsgi_mode_t(space+1, &error);\n\tif (error) {\n\t\tuwsgi_log(\"invalid hook chmod mask: %s\\n\", space+1); \n\t\t*space = ' ';\n\t\treturn -1;\n\t}\n\n\tint ret = chmod(arg, mask);\n\t*space = ' ';\n\tif (ret) {\n\t\tuwsgi_error(\"uwsgi_hook_chmod()/chmod()\");\n\t}\n\treturn ret;\n}\n\nstatic int uwsgi_hook_sticky(char *arg) {\n\tstruct stat st;\n\tif (stat(arg, &st)) {\n                uwsgi_error(\"uwsgi_hook_sticky()/stat()\");\n\t\treturn -1;\n\t}\n        if (chmod(arg, st.st_mode | S_ISVTX)) {\n                uwsgi_error(\"uwsgi_hook_sticky()/chmod()\");\n\t\treturn -1;\n        }\n        return 0;\n}\n\n\nstatic int uwsgi_hook_chown(char *arg) {\n        char *space = strchr(arg, ' ');\n        if (!space) {\n                uwsgi_log(\"invalid hook chown syntax, must be: <file> <uid> <gid>\\n\");\n                return -1;\n        }\n        *space = 0;\n\n\tchar *space2 = strchr(space+1, ' ');\n\tif (!space2) {\n\t\t*space = ' ';\n                uwsgi_log(\"invalid hook chown syntax, must be: <file> <uid> <gid>\\n\");\n                return -1;\n\t}\n\t*space2 = 0;\n\n\tstruct passwd *pw = getpwnam(space+1);\n\tif (!pw) {\n\t\tuwsgi_log(\"unable to find uid %s\\n\", space+1);\n\t\t*space = ' ';\n\t\t*space2 = ' ';\n\t\treturn -1;\n\t}\n\n\tstruct group *gr = getgrnam(space2+1);\n\tif (!gr) {\n                uwsgi_log(\"unable to find gid %s\\n\", space2+1);\n                *space = ' ';\n                *space2 = ' ';\n                return -1;\n        }\n        int ret = chown(arg, pw->pw_uid, gr->gr_gid);\n        *space = ' ';\n        *space2 = ' ';\n        if (ret) {\n                uwsgi_error(\"uwsgi_hook_chown()/chown)\");\n        }\n        return ret;\n}\n\nstatic int uwsgi_hook_chown2(char *arg) {\n        char *space = strchr(arg, ' ');\n        if (!space) {\n                uwsgi_log(\"invalid hook chown2 syntax, must be: <file> <uid> <gid>\\n\");\n                return -1;\n        }\n        *space = 0;\n\n        char *space2 = strchr(space+1, ' ');\n        if (!space2) {\n                *space = ' ';\n                uwsgi_log(\"invalid hook chown2 syntax, must be: <file> <uid> <gid>\\n\");\n                return -1;\n        }\n        *space2 = 0;\n\n\tif (!is_a_number(space+1)) {\n\t\tuwsgi_log(\"invalid hook chown2 syntax, uid must be a number\\n\");\n\t\t*space = ' ';\n\t\t*space2 = ' ';\n\t\treturn -1;\n\t}\n\n\tif (!is_a_number(space2+1)) {\n                uwsgi_log(\"invalid hook chown2 syntax, gid must be a number\\n\");\n                *space = ' ';\n                *space2 = ' ';\n                return -1;\n        }\n\n        int ret = chown(arg, atoi(space+1), atoi(space2+1));\n        *space = ' ';\n        *space2 = ' ';\n        if (ret) {\n                uwsgi_error(\"uwsgi_hook_chown2()/chown)\");\n        }\n        return ret;\n}\n\n\n#ifdef __sun__\nextern int sethostname(char *, int);\n#endif\nstatic int uwsgi_hook_hostname(char *arg) {\n#ifdef __CYGWIN__\n\treturn -1;\n#else\n\treturn sethostname(arg, strlen(arg));\n#endif\n}\n\nstatic int uwsgi_hook_unix_signal(char *arg) {\n\tchar *space = strchr(arg, ' ');\n\tif (!space) {\n\t\tuwsgi_log(\"invalid unix_signal syntax, must be <signum> <func>\\n\");\n\t\treturn -1;\n\t}\n\t*space = 0;\n\tint signum = atoi(arg);\n\t*space = ' ';\n\tvoid (*func)(int) = dlsym(RTLD_DEFAULT, space+1);\n\tif (!func) {\n\t\tuwsgi_log(\"unable to find function \\\"%s\\\"\\n\", space+1);\n\t\treturn -1;\n\t}\n\tuwsgi_unix_signal(signum, func);\n\treturn 0;\n}\n\n\nstatic int uwsgi_hook_callint(char *arg) {\n        char *space = strchr(arg, ' ');\n        if (space) {\n                *space = 0;\n                int num = atoi(space+1);\n                void (*func)(int) = dlsym(RTLD_DEFAULT, arg);\n                if (!func) {\n                \tuwsgi_log(\"unable to call function \\\"%s(%d)\\\"\\n\", arg, num);\n                        *space = ' ';\n                        return -1;\n\t\t}\n                *space = ' ';\n                func(num);\n        }\n        else {\n                void (*func)(void) = dlsym(RTLD_DEFAULT, arg);\n                if (!func) {\n                        uwsgi_log(\"unable to call function \\\"%s\\\"\\n\", arg);\n                        return -1;\n                }\n                func();\n        }\n        return 0;\n}\n\n\nstatic int uwsgi_hook_call(char *arg) {\n\tchar *space = strchr(arg, ' ');\n\tif (space) {\n\t\t*space = 0;\n\t\tvoid (*func)(char *) = dlsym(RTLD_DEFAULT, arg);\n                if (!func) {\n                \tuwsgi_log(\"unable to call function \\\"%s(%s)\\\"\\n\", arg, space + 1);\n\t\t\t*space = ' ';\n\t\t\treturn -1;\n\t\t}\n\t\t*space = ' ';\n                func(space + 1);\n\t}\n\telse {\n\t\tvoid (*func)(void) = dlsym(RTLD_DEFAULT, arg);\n                if (!func) {\n                \tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", arg);\n\t\t\treturn -1;\n\t\t}\n                func();\n\t}\n\treturn 0;\n}\n\nstatic int uwsgi_hook_callintret(char *arg) {\n        char *space = strchr(arg, ' ');\n        if (space) {\n                *space = 0;\n                int num = atoi(space+1);\n                int (*func)(int) = dlsym(RTLD_DEFAULT, arg);\n                if (!func) {\n                        uwsgi_log(\"unable to call function \\\"%s(%d)\\\"\\n\", arg, num);\n                        *space = ' ';\n                        return -1;\n                }\n                *space = ' ';\n                return func(num);\n        }\n        int (*func)(void) = dlsym(RTLD_DEFAULT, arg);\n        if (!func) {\n        \tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", arg);\n                return -1;\n        }\n\treturn func();\n}\n\n\nstatic int uwsgi_hook_callret(char *arg) {\n        char *space = strchr(arg, ' ');\n        if (space) {\n                *space = 0;\n                int (*func)(char *) = dlsym(RTLD_DEFAULT, arg);\n                if (!func) {\n                        uwsgi_log(\"unable to call function \\\"%s(%s)\\\"\\n\", arg, space + 1);\n                        *space = ' ';\n                        return -1;\n                }\n                *space = ' ';\n                return func(space + 1);\n        }\n        int (*func)(void) = dlsym(RTLD_DEFAULT, arg);\n        if (!func) {\n        \tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", arg);\n                return -1;\n        }\n        return func();\n}\n\nstatic int uwsgi_hook_rpc(char *arg) {\n\n\tint ret = -1;\n\tsize_t i, argc = 0;\n        char **rargv = uwsgi_split_quoted(arg, strlen(arg), \" \\t\", &argc);\n        if (!argc) goto end;\n\tif (argc > 256) goto destroy;\n\n        char *argv[256];\n        uint16_t argvs[256];\n\n        char *node = NULL;\n        char *func = rargv[0];\n\n\tchar *at = strchr(func, '@');\n\tif (at) {\n\t\t*at = 0;\n\t\tnode = at + 1;\n\t}\n\n        for(i=0;i<(argc-1);i++) {\n\t\tsize_t a_len = strlen(rargv[i+1]);\n\t\tif (a_len > 0xffff) goto destroy;\n                argv[i] = rargv[i+1] ;\n                argvs[i] = a_len;\n        }\n\n        uint64_t size = 0;\n        // response must be always freed\n        char *response = uwsgi_do_rpc(node, func, argc-1, argv, argvs, &size);\n        if (response) {\n\t\tif (at) *at = '@';\n\t\tuwsgi_log(\"[rpc result from \\\"%s\\\"] %.*s\\n\", rargv[0], size, response);\n                free(response);\n\t\tret = 0;\n        }\n\ndestroy:\n        for(i=0;i<argc;i++) {\n                free(rargv[i]);\n        }\nend:\n\tfree(rargv);\n\treturn ret;\n}\n\nstatic int uwsgi_hook_retryrpc(char *arg) {\n\tfor(;;) {\n\t\tint ret = uwsgi_hook_rpc(arg);\n\t\tif (!ret) break;\n\t\tsleep(2);\n\t}\n\treturn 0;\n}\n\nstatic int uwsgi_hook_wait_for_fs(char *arg) {\n\treturn uwsgi_wait_for_fs(arg, 0);\n}\n\nstatic int uwsgi_hook_wait_for_file(char *arg) {\n\treturn uwsgi_wait_for_fs(arg, 1);\n}\n\nstatic int uwsgi_hook_wait_for_dir(char *arg) {\n\treturn uwsgi_wait_for_fs(arg, 2);\n}\n\nstatic int uwsgi_hook_wait_for_socket(char *arg) {\n\treturn uwsgi_wait_for_socket(arg);\n}\n\nstatic int spinningfifo_hook(char *arg) {\n        int fd;\n        char *space = strchr(arg, ' ');\n        if (!space) {\n                uwsgi_log(\"invalid hook spinningfifo syntax, must be: <file> <string>\\n\");\n                return -1;\n        }\n        *space = 0;\nretry:\n        uwsgi_log(\"waiting for %s ...\\n\", arg);\n        fd = open(arg, O_WRONLY|O_NONBLOCK);\n        if (fd < 0) {\n                if (errno == ENODEV || errno == ENOENT) {\n                        sleep(1);\n                        goto retry;\n                }\n#ifdef ENXIO\n                if (errno == ENXIO) {\n                        sleep(1);\n                        goto retry;\n                }\n#endif\n                uwsgi_error_open(arg);\n                *space = ' ';\n                return -1;\n        }\n        *space = ' ';\n        size_t l = strlen(space+1);\n        if (write(fd, space+1, l) != (ssize_t) l) {\n                uwsgi_error(\"spinningfifo_hook()/write()\");\n                close(fd);\n                return -1;\n        }\n        close(fd);\n        return 0;\n}\n\nvoid uwsgi_register_base_hooks() {\n\tuwsgi_register_hook(\"cd\", uwsgi_hook_chdir);\n\tuwsgi_register_hook(\"chdir\", uwsgi_hook_chdir);\n\n\tuwsgi_register_hook(\"mkdir\", uwsgi_hook_mkdir);\n\tuwsgi_register_hook(\"putenv\", uwsgi_hook_putenv);\n\tuwsgi_register_hook(\"chmod\", uwsgi_hook_chmod);\n\tuwsgi_register_hook(\"chown\", uwsgi_hook_chown);\n\tuwsgi_register_hook(\"chown2\", uwsgi_hook_chown2);\n\n\tuwsgi_register_hook(\"sticky\", uwsgi_hook_sticky);\n\n\tuwsgi_register_hook(\"exec\", uwsgi_hook_exec);\n\tuwsgi_register_hook(\"safeexec\", uwsgi_hook_safeexec);\n\n\tuwsgi_register_hook(\"create\", uwsgi_hook_creat);\n\tuwsgi_register_hook(\"creat\", uwsgi_hook_creat);\n\n\tuwsgi_register_hook(\"write\", uwsgi_hook_write);\n\tuwsgi_register_hook(\"writen\", uwsgi_hook_writen);\n\tuwsgi_register_hook(\"append\", uwsgi_hook_append);\n\tuwsgi_register_hook(\"appendn\", uwsgi_hook_appendn);\n\tuwsgi_register_hook(\"writefifo\", uwsgi_hook_writefifo);\n\tuwsgi_register_hook(\"unlink\", uwsgi_hook_unlink);\n\n\tuwsgi_register_hook(\"mount\", uwsgi_mount_hook);\n\tuwsgi_register_hook(\"umount\", uwsgi_umount_hook);\n\n\tuwsgi_register_hook(\"call\", uwsgi_hook_call);\n\tuwsgi_register_hook(\"callret\", uwsgi_hook_callret);\n\n\tuwsgi_register_hook(\"callint\", uwsgi_hook_callint);\n\tuwsgi_register_hook(\"callintret\", uwsgi_hook_callintret);\n\n\tuwsgi_register_hook(\"hostname\", uwsgi_hook_hostname);\n\n\tuwsgi_register_hook(\"alarm\", uwsgi_hook_alarm);\n\n\tuwsgi_register_hook(\"rpc\", uwsgi_hook_rpc);\n\tuwsgi_register_hook(\"retryrpc\", uwsgi_hook_retryrpc);\n\n\tuwsgi_register_hook(\"wait_for_fs\", uwsgi_hook_wait_for_fs);\n\tuwsgi_register_hook(\"wait_for_file\", uwsgi_hook_wait_for_file);\n\tuwsgi_register_hook(\"wait_for_dir\", uwsgi_hook_wait_for_dir);\n\n\tuwsgi_register_hook(\"wait_for_socket\", uwsgi_hook_wait_for_socket);\n\n\tuwsgi_register_hook(\"unix_signal\", uwsgi_hook_unix_signal);\n\n\tuwsgi_register_hook(\"spinningfifo\", spinningfifo_hook);\n\n\t// for testing\n\tuwsgi_register_hook(\"exit\", uwsgi_hook_exit);\n\tuwsgi_register_hook(\"print\", uwsgi_hook_print);\n\tuwsgi_register_hook(\"log\", uwsgi_hook_print);\n}\n\nvoid uwsgi_hooks_run(struct uwsgi_string_list *l, char *phase, int fatal) {\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, l) {\n\t\tchar *colon = strchr(usl->value, ':');\n\t\tif (!colon) {\n\t\t\tuwsgi_log(\"invalid hook syntax, must be hook:args\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t*colon = 0;\n\t\tint private = 0;\n\t\tchar *action = usl->value;\n\t\t// private hook ?\n\t\tif (action[0] == '!') {\n\t\t\taction++;\n\t\t\tprivate = 1;\n\t\t}\n\t\tstruct uwsgi_hook *uh = uwsgi_hook_by_name(action);\n\t\tif (!uh) {\n\t\t\tuwsgi_log(\"hook action not found: %s\\n\", action);\n\t\t\texit(1);\n\t\t}\n\t\t*colon = ':';\n\n\t\tif (private) {\n\t\t\tuwsgi_log(\"running --- PRIVATE HOOK --- (%s)...\\n\", phase);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"running \\\"%s\\\" (%s)...\\n\", usl->value, phase);\n\t\t}\n\t\t\t\n\t\tint ret = uh->func(colon+1);\n\t\tif (fatal && ret != 0) {\n\t\t\tuwsgi_log_verbose(\"FATAL hook failed, destroying instance\\n\");\n\t\t\tif (uwsgi.master_process) {\n\t\t\t\tif (uwsgi.workers) {\n\t\t\t\t\tif (uwsgi.workers[0].pid == getpid()) {\n\t\t\t\t\t\tkill_them_all(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n                                        \tif (kill(uwsgi.workers[0].pid, SIGINT)) {\n\t\t\t\t\t\t\tuwsgi_error(\"uwsgi_hooks_run()/kill()\");\n\t\t\t\t\t\t\texit(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n                                \t}\n\t\t\t\t}\n\t\t\t}\n\t\t\texit(1);\n\t\t}\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/core/utils.c": "#include <uwsgi.h>\n\n\nextern struct uwsgi_server uwsgi;\n\n#ifdef __BIG_ENDIAN__\nuint16_t uwsgi_swap16(uint16_t x) {\n\treturn (uint16_t) ((x & 0xff) << 8 | (x & 0xff00) >> 8);\n}\n\nuint32_t uwsgi_swap32(uint32_t x) {\n\tx = ((x << 8) & 0xFF00FF00) | ((x >> 8) & 0x00FF00FF);\n\treturn (x >> 16) | (x << 16);\n}\n\n// thanks to ffmpeg project for this idea :P\nuint64_t uwsgi_swap64(uint64_t x) {\n\tunion {\n\t\tuint64_t ll;\n\t\tuint32_t l[2];\n\t} w, r;\n\tw.ll = x;\n\tr.l[0] = uwsgi_swap32(w.l[1]);\n\tr.l[1] = uwsgi_swap32(w.l[0]);\n\treturn r.ll;\n}\n\n#endif\n\n// check if a string is a valid hex number\nint check_hex(char *str, int len) {\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((str[i] < '0' && str[i] > '9') && (str[i] < 'a' && str[i] > 'f') && (str[i] < 'A' && str[i] > 'F')\n\t\t\t) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n\n}\n\n// increase worker harakiri\nvoid inc_harakiri(int sec) {\n\tif (uwsgi.master_process) {\n\t\tuwsgi.workers[uwsgi.mywid].harakiri += sec;\n\t}\n\telse {\n\t\talarm(uwsgi.harakiri_options.workers + sec);\n\t}\n}\n\n// set worker harakiri\nvoid set_harakiri(int sec) {\n\tif (sec == 0) {\n\t\tuwsgi.workers[uwsgi.mywid].harakiri = 0;\n\t}\n\telse {\n\t\tuwsgi.workers[uwsgi.mywid].harakiri = uwsgi_now() + sec;\n\t}\n\tif (!uwsgi.master_process) {\n\t\talarm(sec);\n\t}\n}\n\n// set user harakiri\nvoid set_user_harakiri(int sec) {\n\tif (!uwsgi.master_process) {\n\t\tuwsgi_log(\"!!! unable to set user harakiri without the master process !!!\\n\");\n\t\treturn;\n\t}\n\t// a 0 seconds value, reset the timer\n\tif (sec == 0) {\n\t\tif (uwsgi.muleid > 0) {\n\t\t\tuwsgi.mules[uwsgi.muleid - 1].user_harakiri = 0;\n\t\t}\n\t\telse if (uwsgi.i_am_a_spooler) {\n\t\t\tstruct uwsgi_spooler *uspool = uwsgi.i_am_a_spooler;\n\t\t\tuspool->user_harakiri = 0;\n\t\t}\n\t\telse {\n\t\t\tuwsgi.workers[uwsgi.mywid].user_harakiri = 0;\n\t\t}\n\t}\n\telse {\n\t\tif (uwsgi.muleid > 0) {\n\t\t\tuwsgi.mules[uwsgi.muleid - 1].user_harakiri = uwsgi_now() + sec;\n\t\t}\n\t\telse if (uwsgi.i_am_a_spooler) {\n\t\t\tstruct uwsgi_spooler *uspool = uwsgi.i_am_a_spooler;\n\t\t\tuspool->user_harakiri = uwsgi_now() + sec;\n\t\t}\n\t\telse {\n\t\t\tuwsgi.workers[uwsgi.mywid].user_harakiri = uwsgi_now() + sec;\n\t\t}\n\t}\n}\n\n// set mule harakiri\nvoid set_mule_harakiri(int sec) {\n\tif (sec == 0) {\n\t\tuwsgi.mules[uwsgi.muleid - 1].harakiri = 0;\n\t}\n\telse {\n\t\tuwsgi.mules[uwsgi.muleid - 1].harakiri = uwsgi_now() + sec;\n\t}\n\tif (!uwsgi.master_process) {\n\t\talarm(sec);\n\t}\n}\n\n// set spooler harakiri\nvoid set_spooler_harakiri(int sec) {\n\tif (sec == 0) {\n\t\tuwsgi.i_am_a_spooler->harakiri = 0;\n\t}\n\telse {\n\t\tuwsgi.i_am_a_spooler->harakiri = uwsgi_now() + sec;\n\t}\n\tif (!uwsgi.master_process) {\n\t\talarm(sec);\n\t}\n}\n\n\n// daemonize to the specified logfile\nvoid daemonize(char *logfile) {\n\tpid_t pid;\n\n\t// do not daemonize under emperor\n\tif (uwsgi.has_emperor) {\n\t\tlogto(logfile);\n\t\treturn;\n\t}\n\n\tpid = fork();\n\tif (pid < 0) {\n\t\tuwsgi_error(\"fork()\");\n\t\texit(1);\n\t}\n\tif (pid != 0) {\n\t\t_exit(0);\n\t}\n\n\tif (setsid() < 0) {\n\t\tuwsgi_error(\"setsid()\");\n\t\texit(1);\n\t}\n\n\t/* refork... */\n\tpid = fork();\n\tif (pid < 0) {\n\t\tuwsgi_error(\"fork()\");\n\t\texit(1);\n\t}\n\tif (pid != 0) {\n\t\t_exit(0);\n\t}\n\n\tif (!uwsgi.do_not_change_umask) {\n\t\tumask(0);\n\t}\n\n\t/*if (chdir(\"/\") != 0) {\n\t   uwsgi_error(\"chdir()\");\n\t   exit(1);\n\t   } */\n\n\tuwsgi_remap_fd(0, \"/dev/null\");\n\n\tlogto(logfile);\n}\n\n// get current working directory\nchar *uwsgi_get_cwd() {\n\n\t// set this to static to avoid useless reallocations in stats mode\n\tstatic size_t newsize = 256;\n\n\tchar *cwd = uwsgi_malloc(newsize);\n\n\tif (getcwd(cwd, newsize) == NULL && errno == ERANGE) {\n\t\tnewsize += 256;\n\t\tuwsgi_log(\"need a bigger buffer (%lu bytes) for getcwd(). doing reallocation.\\n\", (unsigned long) newsize);\n\t\tfree(cwd);\n\t\tcwd = uwsgi_malloc(newsize);\n\t\tif (getcwd(cwd, newsize) == NULL) {\n\t\t\tuwsgi_error(\"getcwd()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn cwd;\n\n}\n\n#ifdef __linux__\nvoid uwsgi_set_cgroup() {\n\n\tchar *cgroup_taskfile;\n\tFILE *cgroup;\n\tchar *cgroup_opt;\n\tstruct uwsgi_string_list *usl, *uslo;\n\n\tif (!uwsgi.cgroup)\n\t\treturn;\n\n\tif (getuid())\n\t\treturn;\n\n\tusl = uwsgi.cgroup;\n\n\twhile (usl) {\n\t\tint mode = strtol(uwsgi.cgroup_dir_mode, 0, 8);\n\t\tif (mkdir(usl->value, mode)) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tuwsgi_error(\"uwsgi_set_cgroup()/mkdir()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (chmod(usl->value, mode)) {\n\t\t\t\tuwsgi_error(\"uwsgi_set_cgroup()/chmod()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tuwsgi_log(\"using Linux cgroup %s with mode %o\\n\", usl->value, mode);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"created Linux cgroup %s with mode %o\\n\", usl->value, mode);\n\t\t}\n\n\t\tcgroup_taskfile = uwsgi_concat2(usl->value, \"/tasks\");\n\t\tcgroup = fopen(cgroup_taskfile, \"w\");\n\t\tif (!cgroup) {\n\t\t\tuwsgi_error_open(cgroup_taskfile);\n\t\t\texit(1);\n\t\t}\n\t\tif (fprintf(cgroup, \"%d\\n\", (int) getpid()) <= 0 || ferror(cgroup) || fclose(cgroup)) {\n\t\t\tuwsgi_error(\"could not set cgroup\");\n\t\t\texit(1);\n\t\t}\n\t\tuwsgi_log(\"assigned process %d to cgroup %s\\n\", (int) getpid(), cgroup_taskfile);\n\t\tfree(cgroup_taskfile);\n\n\n\t\tuslo = uwsgi.cgroup_opt;\n\t\twhile (uslo) {\n\t\t\tcgroup_opt = strchr(uslo->value, '=');\n\t\t\tif (!cgroup_opt) {\n\t\t\t\tcgroup_opt = strchr(uslo->value, ':');\n\t\t\t\tif (!cgroup_opt) {\n\t\t\t\t\tuwsgi_log(\"invalid cgroup-opt syntax\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcgroup_opt[0] = 0;\n\t\t\tcgroup_opt++;\n\n\t\t\tcgroup_taskfile = uwsgi_concat3(usl->value, \"/\", uslo->value);\n\t\t\tcgroup = fopen(cgroup_taskfile, \"w\");\n\t\t\tif (cgroup) {\n\t\t\t\tif (fprintf(cgroup, \"%s\\n\", cgroup_opt) <= 0 || ferror(cgroup) || fclose(cgroup)) {\n\t\t\t\t\tuwsgi_log(\"could not set cgroup option %s to %s\\n\", uslo->value, cgroup_opt);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tuwsgi_log(\"set %s to %s\\n\", cgroup_opt, cgroup_taskfile);\n\t\t\t}\n\t\t\tfree(cgroup_taskfile);\n\n\t\t\tcgroup_opt[-1] = '=';\n\n\t\t\tuslo = uslo->next;\n\t\t}\n\n\t\tusl = usl->next;\n\t}\n\n}\n#endif\n\n#ifdef UWSGI_CAP\nvoid uwsgi_apply_cap(cap_value_t * cap, int caps_count) {\n\tcap_value_t minimal_cap_values[] = { CAP_SYS_CHROOT, CAP_SETUID, CAP_SETGID, CAP_SETPCAP };\n\n\tcap_t caps = cap_init();\n\n\tif (!caps) {\n\t\tuwsgi_error(\"cap_init()\");\n\t\texit(1);\n\t}\n\tcap_clear(caps);\n\n\tcap_set_flag(caps, CAP_EFFECTIVE, 4, minimal_cap_values, CAP_SET);\n\n\tcap_set_flag(caps, CAP_PERMITTED, 4, minimal_cap_values, CAP_SET);\n\tcap_set_flag(caps, CAP_PERMITTED, caps_count, cap, CAP_SET);\n\n\tcap_set_flag(caps, CAP_INHERITABLE, caps_count, cap, CAP_SET);\n\n\tif (cap_set_proc(caps) < 0) {\n\t\tuwsgi_error(\"cap_set_proc()\");\n\t\texit(1);\n\t}\n\tcap_free(caps);\n\n#ifdef __linux__\n#ifdef SECBIT_KEEP_CAPS\n\tif (prctl(SECBIT_KEEP_CAPS, 1, 0, 0, 0) < 0) {\n\t\tuwsgi_error(\"prctl()\");\n\t\texit(1);\n\t}\n#else\n\tif (prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0) {\n\t\tuwsgi_error(\"prctl()\");\n\t\texit(1);\n\t}\n#endif\n#endif\n}\n#endif\n\n// drop privileges (as root)\n/*\n\n\there we manage jails/namespaces too\n\tit is a pretty huge function... refactory is needed\n\n*/\nvoid uwsgi_as_root() {\n\n\n\tif (getuid() > 0)\n\t\tgoto nonroot;\n\n\tif (!uwsgi.master_as_root && !uwsgi.uidname) {\n\t\tuwsgi_log_initial(\"uWSGI running as root, you can use --uid/--gid/--chroot options\\n\");\n\t}\n\n\tint in_jail = 0;\n\n#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)\n\tif (uwsgi.unshare && !uwsgi.reloads) {\n\n\t\tif (unshare(uwsgi.unshare)) {\n\t\t\tuwsgi_error(\"unshare()\");\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"[linux-namespace] applied unshare() mask: %d\\n\", uwsgi.unshare);\n\t\t}\n\n#ifdef CLONE_NEWUSER\n\t\tif (uwsgi.unshare & CLONE_NEWUSER) {\n\t\t\tif (setuid(0)) {\n\t\t\t\tuwsgi_error(\"uwsgi_as_root()/setuid(0)\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n#endif\n\t\tin_jail = 1;\n\t}\n#endif\n\n#ifdef UWSGI_CAP\n\tif (uwsgi.cap && uwsgi.cap_count > 0 && !uwsgi.reloads) {\n\t\tuwsgi_apply_cap(uwsgi.cap, uwsgi.cap_count);\n\t}\n#endif\n\n\n#if defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\tif (uwsgi.jail && !uwsgi.reloads) {\n\n\t\tstruct jail ujail;\n\t\tchar *jarg = uwsgi_str(uwsgi.jail);\n\t\tchar *j_hostname = NULL;\n\t\tchar *j_name = NULL;\n\n\t\tchar *space = strchr(jarg, ' ');\n\t\tif (space) {\n\t\t\t*space = 0;\n\t\t\tj_hostname = space + 1;\n\t\t\tspace = strchr(j_hostname, ' ');\n\t\t\tif (space) {\n\t\t\t\t*space = 0;\n\t\t\t\tj_name = space + 1;\n\t\t\t}\n\t\t}\n\t\tujail.version = JAIL_API_VERSION;\n\t\tujail.path = jarg;\n\t\tujail.hostname = j_hostname ? j_hostname : \"\";\n\t\tujail.jailname = j_name;\n\t\tujail.ip4s = 0;\n\t\tujail.ip6s = 0;\n\n\t\tstruct uwsgi_string_list *usl = NULL;\n\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip4) {\n\t\t\tujail.ip4s++;\n\t\t}\n\t\tstruct in_addr *saddr = uwsgi_calloc(sizeof(struct in_addr) * ujail.ip4s);\n\t\tint i = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip4) {\n\t\t\tif (!inet_pton(AF_INET, usl->value, &saddr[i].s_addr)) {\n\t\t\t\tuwsgi_error(\"jail()/inet_pton()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tujail.ip4 = saddr;\n#ifdef AF_INET6\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip6) {\n\t\t\tujail.ip6s++;\n\t\t}\n\n\t\tstruct in6_addr *saddr6 = uwsgi_calloc(sizeof(struct in6_addr) * ujail.ip6s);\n\t\ti = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail_ip6) {\n\t\t\tif (!inet_pton(AF_INET6, usl->value, &saddr6[i].s6_addr)) {\n\t\t\t\tuwsgi_error(\"jail()/inet_pton()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tujail.ip6 = saddr6;\n#endif\n\n\t\tint jail_id = jail(&ujail);\n\t\tif (jail_id < 0) {\n\t\t\tuwsgi_error(\"jail()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (uwsgi.jidfile) {\n\t\t\tif (uwsgi_write_intfile(uwsgi.jidfile, jail_id)) {\n\t\t\t\tuwsgi_log(\"unable to write jidfile\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_log(\"--- running in FreeBSD jail %d ---\\n\", jail_id);\n\t\tin_jail = 1;\n\t}\n\n#ifdef UWSGI_HAS_FREEBSD_LIBJAIL\n\tif (uwsgi.jail_attach && !uwsgi.reloads) {\n\t\tstruct jailparam jparam;\n\t\tuwsgi_log(\"attaching to FreeBSD jail %s ...\\n\", uwsgi.jail_attach);\n\t\tif (!is_a_number(uwsgi.jail_attach)) {\n\t\t\tif (jailparam_init(&jparam, \"name\")) {\n\t\t\t\tuwsgi_error(\"jailparam_init()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (jailparam_init(&jparam, \"jid\")) {\n\t\t\t\tuwsgi_error(\"jailparam_init()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tjailparam_import(&jparam, uwsgi.jail_attach);\n\t\tint jail_id = jailparam_set(&jparam, 1, JAIL_UPDATE | JAIL_ATTACH);\n\t\tif (jail_id < 0) {\n\t\t\tuwsgi_error(\"jailparam_set()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tjailparam_free(&jparam, 1);\n\t\tuwsgi_log(\"--- running in FreeBSD jail %d ---\\n\", jail_id);\n\t\tin_jail = 1;\n\t}\n\n\tif (uwsgi.jail2 && !uwsgi.reloads) {\n\t\tstruct uwsgi_string_list *usl = NULL;\n\t\tunsigned nparams = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail2) {\n\t\t\tnparams++;\n\t\t}\n\t\tstruct jailparam *params = uwsgi_malloc(sizeof(struct jailparam) * nparams);\n\t\tint i = 0;\n\t\tuwsgi_foreach(usl, uwsgi.jail2) {\n\t\t\tuwsgi_log(\"FreeBSD libjail applying %s\\n\", usl->value);\n\t\t\tchar *equal = strchr(usl->value, '=');\n\t\t\tif (equal) {\n\t\t\t\t*equal = 0;\n\t\t\t}\n\t\t\tif (jailparam_init(&params[i], usl->value)) {\n\t\t\t\tuwsgi_error(\"jailparam_init()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (equal) {\n\t\t\t\tjailparam_import(&params[i], equal + 1);\n\t\t\t\t*equal = '=';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjailparam_import(&params[i], \"1\");\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tint jail_id = jailparam_set(params, nparams, JAIL_CREATE | JAIL_ATTACH);\n\t\tif (jail_id < 0) {\n\t\t\tuwsgi_error(\"jailparam_set()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tjailparam_free(params, nparams);\n\n\t\tif (uwsgi.jidfile) {\n\t\t\tif (uwsgi_write_intfile(uwsgi.jidfile, jail_id)) {\n\t\t\t\tuwsgi_log(\"unable to write jidfile\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_log(\"--- running in FreeBSD jail %d ---\\n\", jail_id);\n\t\tin_jail = 1;\n\t}\n#endif\n#endif\n\n\tif (in_jail || uwsgi.jailed) {\n\t\tint i;\n\t\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\t\tif (uwsgi.gp[i]->early_post_jail) {\n\t\t\t\tuwsgi.gp[i]->early_post_jail();\n\t\t\t}\n\t\t}\n\t\tuwsgi_hooks_run(uwsgi.hook_post_jail, \"post-jail\", 1);\n\t\tstruct uwsgi_string_list *usl = NULL;\n\t\tuwsgi_foreach(usl, uwsgi.mount_post_jail) {\n\t\t\tuwsgi_log(\"mounting \\\"%s\\\" (post-jail)...\\n\", usl->value);\n\t\t\tif (uwsgi_mount_hook(usl->value)) {\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.umount_post_jail) {\n\t\t\tuwsgi_log(\"un-mounting \\\"%s\\\" (post-jail)...\\n\", usl->value);\n\t\t\tif (uwsgi_umount_hook(usl->value)) {\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.exec_post_jail) {\n\t\t\tuwsgi_log(\"running \\\"%s\\\" (post-jail)...\\n\", usl->value);\n\t\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\t\tif (ret != 0) {\n\t\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.call_post_jail) {\n\t\t\tif (uwsgi_call_symbol(usl->value)) {\n\t\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (uwsgi.refork_post_jail) {\n\t\t\tuwsgi_log(\"re-fork()ing...\\n\");\n\t\t\tpid_t pid = fork();\n\t\t\tif (pid < 0) {\n\t\t\t\tuwsgi_error(\"fork()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (pid > 0) {\n\t\t\t\t// block all signals\n\t\t\t\tsigset_t smask;\n\t\t\t\tsigfillset(&smask);\n\t\t\t\tsigprocmask(SIG_BLOCK, &smask, NULL);\n\t\t\t\tint status;\n\t\t\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t\t}\n\t\t\t\t_exit(0);\n\t\t\t}\n\t\t}\n\n\n\t\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\t\tif (uwsgi.gp[i]->post_jail) {\n\t\t\t\tuwsgi.gp[i]->post_jail();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (uwsgi.chroot && !uwsgi.reloads) {\n\t\tif (!uwsgi.master_as_root)\n\t\t\tuwsgi_log(\"chroot() to %s\\n\", uwsgi.chroot);\n\t\tif (chroot(uwsgi.chroot)) {\n\t\t\tuwsgi_error(\"chroot()\");\n\t\t\texit(1);\n\t\t}\n#ifdef __linux__\n\t\tif (uwsgi.logging_options.memory_report) {\n\t\t\tuwsgi_log(\"*** Warning, on linux system you have to bind-mount the /proc fs in your chroot to get memory debug/report.\\n\");\n\t\t}\n#endif\n\t}\n\n#ifdef __linux__\n\tif (uwsgi.pivot_root && !uwsgi.reloads) {\n\t\tchar *arg = uwsgi_str(uwsgi.pivot_root);\n\t\tchar *space = strchr(arg, ' ');\n\t\tif (!space) {\n\t\t\tuwsgi_log(\"invalid pivot_root syntax, new_root and put_old must be separated by a space\\n\");\n\t\t\texit(1);\n\t\t}\n\t\t*space = 0;\n#if defined(MS_REC) && defined(MS_PRIVATE)\n\t\tif (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL)) {\n\t\t\tuwsgi_error(\"mount()\");\n\t\t\texit(1);\n\t\t}\n#endif\n\t\tif (chdir(arg)) {\n\t\t\tuwsgi_error(\"pivot_root()/chdir()\");\n\t\t\texit(1);\n\t\t}\n\t\tspace += 1 + strlen(arg);\n\t\tif (space[0] == '/')\n\t\t\tspace++;\n\t\tif (pivot_root(\".\", space)) {\n\t\t\tuwsgi_error(\"pivot_root()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (uwsgi.logging_options.memory_report) {\n\t\t\tuwsgi_log(\"*** Warning, on linux system you have to bind-mount the /proc fs in your chroot to get memory debug/report.\\n\");\n\t\t}\n\t\tfree(arg);\n\t\tif (chdir(\"/\")) {\n\t\t\tuwsgi_error(\"chdir()\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n#endif\n\n#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)\n\tif (uwsgi.unshare2 && !uwsgi.reloads) {\n\n\t\tif (unshare(uwsgi.unshare2)) {\n\t\t\tuwsgi_error(\"unshare()\");\n\t\t\texit(1);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"[linux-namespace] applied unshare() mask: %d\\n\", uwsgi.unshare2);\n\t\t}\n#ifdef CLONE_NEWUSER\n\t\tif (uwsgi.unshare2 & CLONE_NEWUSER) {\n\t\t\tif (setuid(0)) {\n\t\t\t\tuwsgi_error(\"uwsgi_as_root()/setuid(0)\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n#endif\n\t\tin_jail = 1;\n\t}\n#endif\n\n\tif (uwsgi.refork_as_root) {\n\t\tuwsgi_log(\"re-fork()ing...\\n\");\n\t\tpid_t pid = fork();\n\t\tif (pid < 0) {\n\t\t\tuwsgi_error(\"fork()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid > 0) {\n\t\t\t// block all signals\n\t\t\tsigset_t smask;\n\t\t\tsigfillset(&smask);\n\t\t\tsigprocmask(SIG_BLOCK, &smask, NULL);\n\t\t\tint status;\n\t\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t}\n\n\n\tstruct uwsgi_string_list *usl;\n\tuwsgi_foreach(usl, uwsgi.wait_for_interface) {\n\t\tif (!uwsgi.wait_for_interface_timeout) {\n\t\t\tuwsgi.wait_for_interface_timeout = 60;\n\t\t}\n\t\tuwsgi_log(\"waiting for interface %s (max %d seconds) ...\\n\", usl->value, uwsgi.wait_for_interface_timeout);\n\t\tint counter = 0;\n\t\tfor (;;) {\n\t\t\tif (counter > uwsgi.wait_for_interface_timeout) {\n\t\t\t\tuwsgi_log(\"interface %s unavailable after %d seconds\\n\", usl->value, counter);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tunsigned int index = if_nametoindex(usl->value);\n\t\t\tif (index > 0) {\n\t\t\t\tuwsgi_log(\"interface %s found with index %u\\n\", usl->value, index);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsleep(1);\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.wait_for_fs) {\n                if (uwsgi_wait_for_fs(usl->value, 0)) exit(1);\n        }\n\n        uwsgi_foreach(usl, uwsgi.wait_for_file) {\n                if (uwsgi_wait_for_fs(usl->value, 1)) exit(1);\n        }\n\n        uwsgi_foreach(usl, uwsgi.wait_for_dir) {\n                if (uwsgi_wait_for_fs(usl->value, 2)) exit(1);\n        }\n\n        uwsgi_foreach(usl, uwsgi.wait_for_mountpoint) {\n                if (uwsgi_wait_for_mountpoint(usl->value)) exit(1);\n        }\n\n\tuwsgi_hooks_run(uwsgi.hook_as_root, \"as root\", 1);\n\n\tuwsgi_foreach(usl, uwsgi.mount_as_root) {\n\t\tuwsgi_log(\"mounting \\\"%s\\\" (as root)...\\n\", usl->value);\n\t\tif (uwsgi_mount_hook(usl->value)) {\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.umount_as_root) {\n\t\tuwsgi_log(\"un-mounting \\\"%s\\\" (as root)...\\n\", usl->value);\n\t\tif (uwsgi_umount_hook(usl->value)) {\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// now run the scripts needed by root\n\tuwsgi_foreach(usl, uwsgi.exec_as_root) {\n\t\tuwsgi_log(\"running \\\"%s\\\" (as root)...\\n\", usl->value);\n\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\tif (ret != 0) {\n\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.call_as_root) {\n\t\tif (uwsgi_call_symbol(usl->value)) {\n\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t}\n\t}\n\n\n\tif (uwsgi.gidname) {\n\t\tstruct group *ugroup = getgrnam(uwsgi.gidname);\n\t\tif (ugroup) {\n\t\t\tuwsgi.gid = ugroup->gr_gid;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"group %s not found.\\n\", uwsgi.gidname);\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (uwsgi.uidname) {\n\t\tstruct passwd *upasswd = getpwnam(uwsgi.uidname);\n\t\tif (upasswd) {\n\t\t\tuwsgi.uid = upasswd->pw_uid;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"user %s not found.\\n\", uwsgi.uidname);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (uwsgi.logfile_chown) {\n\t\tint log_fd = 2;\n\t\tif (uwsgi.log_master && uwsgi.original_log_fd > -1) {\n\t\t\tlog_fd = uwsgi.original_log_fd;\n\t\t}\n\t\tif (fchown(log_fd, uwsgi.uid, uwsgi.gid)) {\n\t\t\tuwsgi_error(\"fchown()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// fix ipcsem owner\n\tif (uwsgi.lock_ops.lock_init == uwsgi_lock_ipcsem_init) {\n\t\tstruct uwsgi_lock_item *uli = uwsgi.registered_locks;\n\n\t\twhile (uli) {\n\t\t\tunion semun {\n\t\t\t\tint val;\n\t\t\t\tstruct semid_ds *buf;\n\t\t\t\tushort *array;\n\t\t\t} semu;\n\n\t\t\tstruct semid_ds sds;\n\t\t\tmemset(&sds, 0, sizeof(sds));\n\t\t\tsemu.buf = &sds;\n\t\t\tint semid = 0;\n\t\t\tmemcpy(&semid, uli->lock_ptr, sizeof(int));\n\n\t\t\tif (semctl(semid, 0, IPC_STAT, semu)) {\n\t\t\t\tuwsgi_error(\"semctl()\");\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tsemu.buf->sem_perm.uid = uwsgi.uid;\n\t\t\tsemu.buf->sem_perm.gid = uwsgi.gid;\n\n\t\t\tif (semctl(semid, 0, IPC_SET, semu)) {\n\t\t\t\tuwsgi_error(\"semctl()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tuli = uli->next;\n\t\t}\n\n\t}\n\n\t// ok try to call some special hook before finally dropping privileges\n\tint i;\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->before_privileges_drop) {\n\t\t\tuwsgi.gp[i]->before_privileges_drop();\n\t\t}\n\t}\n\n\tif (uwsgi.gid) {\n\t\tif (!uwsgi.master_as_root)\n\t\t\tuwsgi_log(\"setgid() to %d\\n\", uwsgi.gid);\n\t\tif (setgid(uwsgi.gid)) {\n\t\t\tuwsgi_error(\"setgid()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (uwsgi.no_initgroups || !uwsgi.uid) {\n\t\t\tif (setgroups(0, NULL)) {\n\t\t\t\tuwsgi_error(\"setgroups()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tchar *uidname = uwsgi.uidname;\n\t\t\tif (!uidname) {\n\t\t\t\tstruct passwd *pw = getpwuid(uwsgi.uid);\n\t\t\t\tif (pw)\n\t\t\t\t\tuidname = pw->pw_name;\n\n\t\t\t}\n\t\t\tif (!uidname)\n\t\t\t\tuidname = uwsgi_num2str(uwsgi.uid);\n\t\t\tif (initgroups(uidname, uwsgi.gid)) {\n\t\t\t\tuwsgi_error(\"setgroups()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tstruct uwsgi_string_list *usl;\n\t\tsize_t ags = 0;\n\t\tuwsgi_foreach(usl, uwsgi.additional_gids) ags++;\n\t\tif (ags > 0) {\n\t\t\tgid_t *ags_list = uwsgi_calloc(sizeof(gid_t) * ags);\n\t\t\tsize_t g_pos = 0;\n\t\t\tuwsgi_foreach(usl, uwsgi.additional_gids) {\n\t\t\t\tags_list[g_pos] = atoi(usl->value);\n\t\t\t\tif (!ags_list[g_pos]) {\n\t\t\t\t\tstruct group *g = getgrnam(usl->value);\n\t\t\t\t\tif (g) {\n\t\t\t\t\t\tags_list[g_pos] = g->gr_gid;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuwsgi_log(\"unable to find group %s\\n\", usl->value);\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg_pos++;\n\t\t\t}\n\t\t\tif (setgroups(ags, ags_list)) {\n\t\t\t\tuwsgi_error(\"setgroups()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tint additional_groups = getgroups(0, NULL);\n\t\tif (additional_groups > 0) {\n\t\t\tgid_t *gids = uwsgi_calloc(sizeof(gid_t) * additional_groups);\n\t\t\tif (getgroups(additional_groups, gids) > 0) {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < additional_groups; i++) {\n\t\t\t\t\tif (gids[i] == uwsgi.gid)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tstruct group *gr = getgrgid(gids[i]);\n\t\t\t\t\tif (gr) {\n\t\t\t\t\t\tuwsgi_log(\"set additional group %d (%s)\\n\", gids[i], gr->gr_name);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuwsgi_log(\"set additional group %d\\n\", gids[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (uwsgi.uid) {\n\t\tif (!uwsgi.master_as_root)\n\t\t\tuwsgi_log(\"setuid() to %d\\n\", uwsgi.uid);\n\t\tif (setuid(uwsgi.uid)) {\n\t\t\tuwsgi_error(\"setuid()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (!getuid()) {\n\t\tuwsgi_log_initial(\"*** WARNING: you are running uWSGI as root !!! (use the --uid flag) *** \\n\");\n\t}\n\n#ifdef UWSGI_CAP\n\n\tif (uwsgi.cap && uwsgi.cap_count > 0 && !uwsgi.reloads) {\n\n\t\tcap_t caps = cap_init();\n\n\t\tif (!caps) {\n\t\t\tuwsgi_error(\"cap_init()\");\n\t\t\texit(1);\n\t\t}\n\t\tcap_clear(caps);\n\n\t\tcap_set_flag(caps, CAP_EFFECTIVE, uwsgi.cap_count, uwsgi.cap, CAP_SET);\n\t\tcap_set_flag(caps, CAP_PERMITTED, uwsgi.cap_count, uwsgi.cap, CAP_SET);\n\t\tcap_set_flag(caps, CAP_INHERITABLE, uwsgi.cap_count, uwsgi.cap, CAP_SET);\n\n\t\tif (cap_set_proc(caps) < 0) {\n\t\t\tuwsgi_error(\"cap_set_proc()\");\n\t\t\texit(1);\n\t\t}\n\t\tcap_free(caps);\n\t}\n#endif\n\n\tif (uwsgi.refork) {\n\t\tuwsgi_log(\"re-fork()ing...\\n\");\n\t\tpid_t pid = fork();\n\t\tif (pid < 0) {\n\t\t\tuwsgi_error(\"fork()\");\n\t\t\texit(1);\n\t\t}\n\t\tif (pid > 0) {\n\t\t\t// block all signals\n\t\t\tsigset_t smask;\n\t\t\tsigfillset(&smask);\n\t\t\tsigprocmask(SIG_BLOCK, &smask, NULL);\n\t\t\tint status;\n\t\t\tif (waitpid(pid, &status, 0) < 0) {\n\t\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\t}\n\t\t\t_exit(0);\n\t\t}\n\t}\n\n\tuwsgi_hooks_run(uwsgi.hook_as_user, \"as user\", 1);\n\n\t// now run the scripts needed by the user\n\tuwsgi_foreach(usl, uwsgi.exec_as_user) {\n\t\tuwsgi_log(\"running \\\"%s\\\" (as uid: %d gid: %d) ...\\n\", usl->value, (int) getuid(), (int) getgid());\n\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\tif (ret != 0) {\n\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.call_as_user) {\n\t\tif (uwsgi_call_symbol(usl->value)) {\n\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// we could now patch the binary\n\tif (uwsgi.unprivileged_binary_patch) {\n\t\tuwsgi.argv[0] = uwsgi.unprivileged_binary_patch;\n\t\texecvp(uwsgi.unprivileged_binary_patch, uwsgi.argv);\n\t\tuwsgi_error(\"execvp()\");\n\t\texit(1);\n\t}\n\n\tif (uwsgi.unprivileged_binary_patch_arg) {\n\t\tuwsgi_exec_command_with_args(uwsgi.unprivileged_binary_patch_arg);\n\t}\n\treturn;\n\nnonroot:\n\tif (uwsgi.chroot && !uwsgi.is_a_reload) {\n\t\tuwsgi_log(\"cannot chroot() as non-root user\\n\");\n\t\texit(1);\n\t}\n\tif (uwsgi.gid && getgid() != uwsgi.gid) {\n\t\tuwsgi_log(\"cannot setgid() as non-root user\\n\");\n\t\texit(1);\n\t}\n\tif (uwsgi.uid && getuid() != uwsgi.uid) {\n\t\tuwsgi_log(\"cannot setuid() as non-root user\\n\");\n\t\texit(1);\n\t}\n}\n\nstatic void close_and_free_request(struct wsgi_request *wsgi_req) {\n\n\t// close the connection with the client\n        if (!wsgi_req->fd_closed) {\n                // NOTE, if we close the socket before receiving eventually sent data, socket layer will send a RST\n                wsgi_req->socket->proto_close(wsgi_req);\n        }\n\n        if (wsgi_req->post_file) {\n                fclose(wsgi_req->post_file);\n        }\n\n        if (wsgi_req->post_read_buf) {\n                free(wsgi_req->post_read_buf);\n        }\n\n        if (wsgi_req->post_readline_buf) {\n                free(wsgi_req->post_readline_buf);\n        }\n\n        if (wsgi_req->proto_parser_buf) {\n                free(wsgi_req->proto_parser_buf);\n        }\n\n}\n\n// destroy a request\nvoid uwsgi_destroy_request(struct wsgi_request *wsgi_req) {\n\n\tclose_and_free_request(wsgi_req);\n\n\tint foo;\n        if (uwsgi.threads > 1) {\n                // now the thread can die...\n                pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &foo);\n        }\n\n\t// reset for avoiding following requests to fail on non-uwsgi protocols\n\t// thanks Marko Tiikkaja for catching it\n\twsgi_req->uh->pktsize = 0;\n\n\t// some plugins expected async_id to be defined before setup\n        int tmp_id = wsgi_req->async_id;\n        memset(wsgi_req, 0, sizeof(struct wsgi_request));\n        wsgi_req->async_id = tmp_id;\n}\n\n// finalize/close/free a request\nvoid uwsgi_close_request(struct wsgi_request *wsgi_req) {\n\n\tint waitpid_status;\n\tint tmp_id;\n\tuint64_t tmp_rt, rss = 0, vsz = 0;\n\n\t// apply transformations\n\tif (wsgi_req->transformations) {\n\t\tif (uwsgi_apply_final_transformations(wsgi_req) == 0) {\n\t\t\tif (wsgi_req->transformed_chunk && wsgi_req->transformed_chunk_len > 0) {\n\t\t\t\tuwsgi_response_write_body_do(wsgi_req, wsgi_req->transformed_chunk, wsgi_req->transformed_chunk_len);\n\t\t\t}\n\t\t}\n\t\tuwsgi_free_transformations(wsgi_req);\n\t}\n\n\t// check if headers should be sent\n\tif (wsgi_req->headers) {\n\t\tif (!wsgi_req->headers_sent && !wsgi_req->headers_size && !wsgi_req->response_size) {\n\t\t\tuwsgi_response_write_headers_do(wsgi_req);\n\t\t}\n\t\tuwsgi_buffer_destroy(wsgi_req->headers);\n\t}\n\n\tuint64_t end_of_request = uwsgi_micros();\n\twsgi_req->end_of_request = end_of_request;\n\n\tif (!wsgi_req->do_not_account_avg_rt) {\n\t\ttmp_rt = wsgi_req->end_of_request - wsgi_req->start_of_request;\n\t\tuwsgi.workers[uwsgi.mywid].running_time += tmp_rt;\n\t\tuwsgi.workers[uwsgi.mywid].avg_response_time = (uwsgi.workers[uwsgi.mywid].avg_response_time + tmp_rt) / 2;\n\t}\n\n\t// get memory usage\n\tif (uwsgi.logging_options.memory_report == 1 || uwsgi.force_get_memusage) {\n\t\tget_memusage(&rss, &vsz);\n\t\tuwsgi.workers[uwsgi.mywid].vsz_size = vsz;\n\t\tuwsgi.workers[uwsgi.mywid].rss_size = rss;\n\t}\n\n\tif (!wsgi_req->do_not_account) {\n\t\tuwsgi.workers[0].requests++;\n\t\tuwsgi.workers[uwsgi.mywid].requests++;\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].requests++;\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].write_errors += wsgi_req->write_errors;\n\t\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].read_errors += wsgi_req->read_errors;\n\t\t// this is used for MAX_REQUESTS\n\t\tuwsgi.workers[uwsgi.mywid].delta_requests++;\n\t}\n\n#ifdef UWSGI_ROUTING\n\t// apply final routes after accounting\n\tuwsgi_apply_final_routes(wsgi_req);\n#endif\n\n\t// close socket and free parsers-allocated memory\n\tclose_and_free_request(wsgi_req);\n\n\t// after_request hook\n\tif (!wsgi_req->is_raw && uwsgi.p[wsgi_req->uh->modifier1]->after_request)\n\t\tuwsgi.p[wsgi_req->uh->modifier1]->after_request(wsgi_req);\n\n\t// after_request custom hooks\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, uwsgi.after_request_hooks) {\n\t\tvoid (*func) (struct wsgi_request *) = (void (*)(struct wsgi_request *)) usl->custom_ptr;\n\t\tfunc(wsgi_req);\n\t}\n\n\tif (uwsgi.threads > 1) {\n\t\t// now the thread can die...\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &tmp_id);\n\t}\n\n\t// leave harakiri mode\n\tif (uwsgi.workers[uwsgi.mywid].harakiri > 0) {\n\t\tset_harakiri(0);\n\t}\n\n\t// leave user harakiri mode\n\tif (uwsgi.workers[uwsgi.mywid].user_harakiri > 0) {\n\t\tset_user_harakiri(0);\n\t}\n\n\tif (!wsgi_req->do_not_account) {\n\t\t// this is racy in multithread mode\n\t\tif (wsgi_req->response_size > 0) {\n\t\t\tuwsgi.workers[uwsgi.mywid].tx += wsgi_req->response_size;\n\t\t}\n\t\tif (wsgi_req->headers_size > 0) {\n\t\t\tuwsgi.workers[uwsgi.mywid].tx += wsgi_req->headers_size;\n\t\t}\n\t}\n\n\t// defunct process reaper\n\tif (uwsgi.reaper == 1) {\n\t\twhile (waitpid(WAIT_ANY, &waitpid_status, WNOHANG) > 0);\n\t}\n\n\t// free logvars\n\tstruct uwsgi_logvar *lv = wsgi_req->logvars;\n\twhile (lv) {\n\t\tstruct uwsgi_logvar *ptr = lv;\n\t\tlv = lv->next;\n\t\tfree(ptr);\n\t}\n\n\t// free additional headers\n\tstruct uwsgi_string_list *ah = wsgi_req->additional_headers;\n\twhile (ah) {\n\t\tstruct uwsgi_string_list *ptr = ah;\n\t\tah = ah->next;\n\t\tfree(ptr->value);\n\t\tfree(ptr);\n\t}\n\t// free remove headers\n\tah = wsgi_req->remove_headers;\n\twhile (ah) {\n\t\tstruct uwsgi_string_list *ptr = ah;\n\t\tah = ah->next;\n\t\tfree(ptr->value);\n\t\tfree(ptr);\n\t}\n\n\t// free chunked input\n\tif (wsgi_req->chunked_input_buf) {\n\t\tuwsgi_buffer_destroy(wsgi_req->chunked_input_buf);\n\t}\n\n\t// free websocket engine\n\tif (wsgi_req->websocket_buf) {\n\t\tuwsgi_buffer_destroy(wsgi_req->websocket_buf);\n\t}\n\tif (wsgi_req->websocket_send_buf) {\n\t\tuwsgi_buffer_destroy(wsgi_req->websocket_send_buf);\n\t}\n\n\n\t// reset request\n\twsgi_req->uh->pktsize = 0;\n\ttmp_id = wsgi_req->async_id;\n\tmemset(wsgi_req, 0, sizeof(struct wsgi_request));\n\t// some plugins expected async_id to be defined before setup\n\twsgi_req->async_id = tmp_id;\n\t// yes, this is pretty useless but we cannot ensure all of the plugin have the same behaviour\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 0;\n\n\tif (uwsgi.max_requests > 0 && uwsgi.workers[uwsgi.mywid].delta_requests >= uwsgi.max_requests\n\t    && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world();\n\t}\n\n\tif (uwsgi.reload_on_as && (rlim_t) vsz >= uwsgi.reload_on_as && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world();\n\t}\n\n\tif (uwsgi.reload_on_rss && (rlim_t) rss >= uwsgi.reload_on_rss && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {\n\t\tgoodbye_cruel_world();\n\t}\n\n\n\t// after the first request, if i am a vassal, signal Emperor about my loyalty\n\tif (uwsgi.has_emperor && !uwsgi.loyal) {\n\t\tuwsgi_log(\"announcing my loyalty to the Emperor...\\n\");\n\t\tchar byte = 17;\n\t\tif (write(uwsgi.emperor_fd, &byte, 1) != 1) {\n\t\t\tuwsgi_error(\"write()\");\n\t\t}\n\t\tuwsgi.loyal = 1;\n\t}\n\n#ifdef __linux__\n#ifdef MADV_MERGEABLE\n\t// run the ksm mapper\n\tif (uwsgi.linux_ksm > 0 && (uwsgi.workers[uwsgi.mywid].requests % uwsgi.linux_ksm) == 0) {\n\t\tuwsgi_linux_ksm_map();\n\t}\n#endif\n#endif\n\n}\n\n#ifdef __linux__\n#ifdef MADV_MERGEABLE\n\nvoid uwsgi_linux_ksm_map(void) {\n\n\tint dirty = 0;\n\tsize_t i;\n\tunsigned long long start = 0, end = 0;\n\tint errors = 0;\n\tint lines = 0;\n\n\tint fd = open(\"/proc/self/maps\", O_RDONLY);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(\"[uwsgi-KSM] /proc/self/maps\");\n\t\treturn;\n\t}\n\n\t// allocate memory if not available;\n\tif (uwsgi.ksm_mappings_current == NULL) {\n\t\tif (!uwsgi.ksm_buffer_size)\n\t\t\tuwsgi.ksm_buffer_size = 32768;\n\t\tuwsgi.ksm_mappings_current = uwsgi_malloc(uwsgi.ksm_buffer_size);\n\t\tuwsgi.ksm_mappings_current_size = 0;\n\t}\n\tif (uwsgi.ksm_mappings_last == NULL) {\n\t\tif (!uwsgi.ksm_buffer_size)\n\t\t\tuwsgi.ksm_buffer_size = 32768;\n\t\tuwsgi.ksm_mappings_last = uwsgi_malloc(uwsgi.ksm_buffer_size);\n\t\tuwsgi.ksm_mappings_last_size = 0;\n\t}\n\n\tuwsgi.ksm_mappings_current_size = read(fd, uwsgi.ksm_mappings_current, uwsgi.ksm_buffer_size);\n\tclose(fd);\n\tif (uwsgi.ksm_mappings_current_size <= 0) {\n\t\tuwsgi_log(\"[uwsgi-KSM] unable to read /proc/self/maps data\\n\");\n\t\treturn;\n\t}\n\n\t// we now have areas\n\tif (uwsgi.ksm_mappings_last_size == 0 || uwsgi.ksm_mappings_current_size != uwsgi.ksm_mappings_last_size) {\n\t\tdirty = 1;\n\t}\n\telse {\n\t\tif (memcmp(uwsgi.ksm_mappings_current, uwsgi.ksm_mappings_last, uwsgi.ksm_mappings_current_size) != 0) {\n\t\t\tdirty = 1;\n\t\t}\n\t}\n\n\t// it is dirty, swap addresses and parse it\n\tif (dirty) {\n\t\tchar *tmp = uwsgi.ksm_mappings_last;\n\t\tuwsgi.ksm_mappings_last = uwsgi.ksm_mappings_current;\n\t\tuwsgi.ksm_mappings_current = tmp;\n\n\t\tsize_t tmp_size = uwsgi.ksm_mappings_last_size;\n\t\tuwsgi.ksm_mappings_last_size = uwsgi.ksm_mappings_current_size;\n\t\tuwsgi.ksm_mappings_current_size = tmp_size;\n\n\t\t// scan each line and call madvise on it\n\t\tchar *ptr = uwsgi.ksm_mappings_last;\n\t\tfor (i = 0; i < uwsgi.ksm_mappings_last_size; i++) {\n\t\t\tif (uwsgi.ksm_mappings_last[i] == '\\n') {\n\t\t\t\tlines++;\n\t\t\t\tuwsgi.ksm_mappings_last[i] = 0;\n\t\t\t\tif (sscanf(ptr, \"%llx-%llx %*s\", &start, &end) == 2) {\n\t\t\t\t\tif (madvise((void *) (long) start, (size_t) (end - start), MADV_MERGEABLE)) {\n\t\t\t\t\t\terrors++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tuwsgi.ksm_mappings_last[i] = '\\n';\n\t\t\t\tptr = uwsgi.ksm_mappings_last + i + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (errors >= lines) {\n\t\t\tuwsgi_error(\"[uwsgi-KSM] unable to share pages\");\n\t\t}\n\t}\n}\n#endif\n#endif\n\n#ifdef __linux__\nlong uwsgi_num_from_file(char *filename, int quiet) {\n\tchar buf[16];\n\tssize_t len;\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tif (!quiet)\n\t\t\tuwsgi_error_open(filename);\n\t\treturn -1L;\n\t}\n\tlen = read(fd, buf, sizeof(buf));\n\tif (len == 0) {\n\t\tif (!quiet)\n\t\t\tuwsgi_log(\"read error %s\\n\", filename);\n\t\tclose(fd);\n\t\treturn -1L;\n\t}\n\tclose(fd);\n\treturn strtol(buf, (char **) NULL, 10);\n}\n#endif\n\n// setup for a new request\nvoid wsgi_req_setup(struct wsgi_request *wsgi_req, int async_id, struct uwsgi_socket *uwsgi_sock) {\n\n\twsgi_req->app_id = -1;\n\n\twsgi_req->async_id = async_id;\n\twsgi_req->sendfile_fd = -1;\n\n\twsgi_req->hvec = uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].hvec;\n\t// skip the first 4 bytes;\n\twsgi_req->uh = (struct uwsgi_header *) uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].buffer;\n\twsgi_req->buffer = uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].buffer + 4;\n\n\tif (uwsgi.post_buffering > 0) {\n\t\twsgi_req->post_buffering_buf = uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].post_buf;\n\t}\n\n\tif (uwsgi_sock) {\n\t\twsgi_req->socket = uwsgi_sock;\n\t}\n\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 0;\n\n\t// now check for suspend request\n\tif (uwsgi.workers[uwsgi.mywid].suspended == 1) {\n\t\tuwsgi_log_verbose(\"*** worker %d suspended ***\\n\", uwsgi.mywid);\ncycle:\n\t\t// wait for some signal (normally SIGTSTP) or 10 seconds (as fallback)\n\t\t(void) poll(NULL, 0, 10 * 1000);\n\t\tif (uwsgi.workers[uwsgi.mywid].suspended == 1)\n\t\t\tgoto cycle;\n\t\tuwsgi_log_verbose(\"*** worker %d resumed ***\\n\", uwsgi.mywid);\n\t}\n}\n\nint wsgi_req_async_recv(struct wsgi_request *wsgi_req) {\n\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 1;\n\n\twsgi_req->start_of_request = uwsgi_micros();\n\twsgi_req->start_of_request_in_sec = wsgi_req->start_of_request / 1000000;\n\n\tif (!wsgi_req->do_not_add_to_async_queue) {\n\t\tif (event_queue_add_fd_read(uwsgi.async_queue, wsgi_req->fd) < 0)\n\t\t\treturn -1;\n\n\t\tasync_add_timeout(wsgi_req, uwsgi.socket_timeout);\n\t\tuwsgi.async_proto_fd_table[wsgi_req->fd] = wsgi_req;\n\t}\n\n\t// enter harakiri mode\n\tif (uwsgi.harakiri_options.workers > 0) {\n\t\tset_harakiri(uwsgi.harakiri_options.workers);\n\t}\n\n\treturn 0;\n}\n\n// receive a new request\nint wsgi_req_recv(int queue, struct wsgi_request *wsgi_req) {\n\n\tuwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 1;\n\n\twsgi_req->start_of_request = uwsgi_micros();\n\twsgi_req->start_of_request_in_sec = wsgi_req->start_of_request / 1000000;\n\n\t// edge triggered sockets get the whole request during accept() phase\n\tif (!wsgi_req->socket->edge_trigger) {\n\t\tfor (;;) {\n\t\t\tint ret = wsgi_req->socket->proto(wsgi_req);\n\t\t\tif (ret == UWSGI_OK)\n\t\t\t\tbreak;\n\t\t\tif (ret == UWSGI_AGAIN) {\n\t\t\t\tret = uwsgi_wait_read_req(wsgi_req);\n\t\t\t\tif (ret <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t// enter harakiri mode\n\tif (uwsgi.harakiri_options.workers > 0) {\n\t\tset_harakiri(uwsgi.harakiri_options.workers);\n\t}\n\n#ifdef UWSGI_ROUTING\n\tif (uwsgi_apply_routes(wsgi_req) == UWSGI_ROUTE_BREAK)\n\t\treturn 0;\n#endif\n\n\twsgi_req->async_status = uwsgi.p[wsgi_req->uh->modifier1]->request(wsgi_req);\n\n\treturn 0;\n}\n\nvoid uwsgi_post_accept(struct wsgi_request *wsgi_req) {\n\n\t// set close on exec (if not a new socket)\n\tif (!wsgi_req->socket->edge_trigger && uwsgi.close_on_exec) {\n\t\tif (fcntl(wsgi_req->fd, F_SETFD, FD_CLOEXEC) < 0) {\n\t\t\tuwsgi_error(\"fcntl()\");\n\t\t}\n\t}\n\n\t// enable TCP_NODELAY ?\n\tif (uwsgi.tcp_nodelay) {\n\t\tuwsgi_tcp_nodelay(wsgi_req->fd);\n\t}\n}\n\n// accept a new request\nint wsgi_req_simple_accept(struct wsgi_request *wsgi_req, int fd) {\n\n\twsgi_req->fd = wsgi_req->socket->proto_accept(wsgi_req, fd);\n\n\tif (wsgi_req->fd < 0) {\n\t\treturn -1;\n\t}\n\n\tuwsgi_post_accept(wsgi_req);\n\n\treturn 0;\n}\n\n// send heartbeat to the emperor\nvoid uwsgi_heartbeat() {\n\n\tif (!uwsgi.has_emperor)\n\t\treturn;\n\n\ttime_t now = uwsgi_now();\n\tif (uwsgi.next_heartbeat <= now) {\n\t\tchar byte = 26;\n\t\tif (write(uwsgi.emperor_fd, &byte, 1) != 1) {\n\t\t\tuwsgi_error(\"write()\");\n\t\t}\n\t\tuwsgi.next_heartbeat = now + uwsgi.heartbeat;\n\t}\n\n}\n\n// accept a request\nint wsgi_req_accept(int queue, struct wsgi_request *wsgi_req) {\n\n\tint ret;\n\tint interesting_fd = -1;\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi.sockets;\n\tint timeout = -1;\n\n\n\tthunder_lock;\n\n\t// Recheck the manage_next_request before going forward.\n\t// This is because the worker might get cheaped while it's\n\t// blocking on the thunder_lock, because thunder_lock is\n\t// not interruptable, it'll slow down the cheaping process\n\t// (the worker will handle the next request before shuts down).\n\tif (!uwsgi.workers[uwsgi.mywid].manage_next_request) {\n\t\tthunder_unlock;\n\t\treturn -1;\n\t}\n\n\t// heartbeat\n\t// in multithreaded mode we are now locked\n\tif (uwsgi.has_emperor && uwsgi.heartbeat) {\n\t\ttime_t now = uwsgi_now();\n\t\t// overengineering ... (reduce skew problems)\n\t\ttimeout = uwsgi.heartbeat;\n\t\tif (!uwsgi.next_heartbeat) {\n\t\t\tuwsgi.next_heartbeat = now;\n\t\t}\n\t\tif (uwsgi.next_heartbeat >= now) {\n\t\t\ttimeout = uwsgi.next_heartbeat - now;\n\t\t}\n\t}\n\n\t// need edge trigger ?\n\tif (uwsgi.is_et) {\n\t\twhile (uwsgi_sock) {\n\t\t\tif (uwsgi_sock->retry && uwsgi_sock->retry[wsgi_req->async_id]) {\n\t\t\t\ttimeout = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tuwsgi_sock = uwsgi_sock->next;\n\t\t}\n\t\t// reset pointer\n\t\tuwsgi_sock = uwsgi.sockets;\n\t}\n\n\tret = event_queue_wait(queue, timeout, &interesting_fd);\n\tif (ret < 0) {\n\t\tthunder_unlock;\n\t\treturn -1;\n\t}\n\n\t// check for heartbeat\n\tif (uwsgi.has_emperor && uwsgi.heartbeat) {\n\t\tuwsgi_heartbeat();\n\t\t// no need to continue if timed-out\n\t\tif (ret == 0) {\n\t\t\tthunder_unlock;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t// kill the thread after the request completion\n\tif (uwsgi.threads > 1)\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &ret);\n\n\tif (uwsgi.signal_socket > -1 && (interesting_fd == uwsgi.signal_socket || interesting_fd == uwsgi.my_signal_socket)) {\n\n\t\tthunder_unlock;\n\n\t\tuwsgi_receive_signal(interesting_fd, \"worker\", uwsgi.mywid);\n\n\t\tif (uwsgi.threads > 1)\n\t\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &ret);\n\t\treturn -1;\n\t}\n\n\n\twhile (uwsgi_sock) {\n\t\tif (interesting_fd == uwsgi_sock->fd || (uwsgi_sock->retry && uwsgi_sock->retry[wsgi_req->async_id]) || (uwsgi_sock->fd_threads && interesting_fd == uwsgi_sock->fd_threads[wsgi_req->async_id])) {\n\t\t\twsgi_req->socket = uwsgi_sock;\n\t\t\twsgi_req->fd = wsgi_req->socket->proto_accept(wsgi_req, interesting_fd);\n\t\t\tthunder_unlock;\n\t\t\tif (wsgi_req->fd < 0) {\n\t\t\t\tif (uwsgi.threads > 1)\n\t\t\t\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &ret);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!uwsgi_sock->edge_trigger) {\n\t\t\t\tuwsgi_post_accept(wsgi_req);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tuwsgi_sock = uwsgi_sock->next;\n\t}\n\n\tthunder_unlock;\n\tif (uwsgi.threads > 1)\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &ret);\n\treturn -1;\n}\n\n// translate a OS env to a uWSGI option\nvoid env_to_arg(char *src, char *dst) {\n\tint i;\n\tint val = 0;\n\n\tfor (i = 0; i < (int) strlen(src); i++) {\n\t\tif (src[i] == '=') {\n\t\t\tval = 1;\n\t\t}\n\t\tif (val) {\n\t\t\tdst[i] = src[i];\n\t\t}\n\t\telse {\n\t\t\tdst[i] = tolower((int) src[i]);\n\t\t\tif (dst[i] == '_') {\n\t\t\t\tdst[i] = '-';\n\t\t\t}\n\t\t}\n\t}\n\n\tdst[strlen(src)] = 0;\n}\n\n// parse OS envs\nvoid parse_sys_envs(char **envs) {\n\n\tchar **uenvs = envs;\n\tchar *earg, *eq_pos;\n\n\twhile (*uenvs) {\n\t\tif (!strncmp(*uenvs, \"UWSGI_\", 6) && strncmp(*uenvs, \"UWSGI_RELOADS=\", 14) && strncmp(*uenvs, \"UWSGI_VASSALS_DIR=\", 18) && strncmp(*uenvs, \"UWSGI_EMPEROR_FD=\", 17) && strncmp(*uenvs, \"UWSGI_BROODLORD_NUM=\", 20) && strncmp(*uenvs, \"UWSGI_EMPEROR_FD_CONFIG=\", 24) && strncmp(*uenvs, \"UWSGI_EMPEROR_PROXY=\", 20) && strncmp(*uenvs, \"UWSGI_JAIL_PID=\", 15) && strncmp(*uenvs, \"UWSGI_ORIGINAL_PROC_NAME=\", 25)) {\n\t\t\tearg = uwsgi_malloc(strlen(*uenvs + 6) + 1);\n\t\t\tenv_to_arg(*uenvs + 6, earg);\n\t\t\teq_pos = strchr(earg, '=');\n\t\t\tif (!eq_pos) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teq_pos[0] = 0;\n\n\t\t\tadd_exported_option(earg, eq_pos + 1, 0);\n\t\t}\n\t\tuenvs++;\n\t}\n\n}\n\n// get the application id\nint uwsgi_get_app_id(struct wsgi_request *wsgi_req, char *key, uint16_t key_len, int modifier1) {\n\n\tint i;\n\tstruct stat st;\n\tint found;\n\n\tchar *app_name = key;\n\tuint16_t app_name_len = key_len;\n\n\tif (app_name_len == 0 && wsgi_req) {\n\t\tapp_name = wsgi_req->appid;\n\t\tapp_name_len = wsgi_req->appid_len;\n\t\tif (app_name_len == 0) {\n\t\t\tif (!uwsgi.ignore_script_name) {\n\t\t\t\tapp_name = wsgi_req->script_name;\n\t\t\t\tapp_name_len = wsgi_req->script_name_len;\n\t\t\t}\n\n\t\t\tif (uwsgi.vhost) {\n\t\t\t\tchar *vhost_name = uwsgi_concat3n(wsgi_req->host, wsgi_req->host_len, \"|\", 1, wsgi_req->script_name, wsgi_req->script_name_len);\n\t\t\t\tapp_name_len = wsgi_req->host_len + 1 + wsgi_req->script_name_len;\n\t\t\t\tapp_name = uwsgi_req_append(wsgi_req, \"UWSGI_APPID\", 11, vhost_name, app_name_len);\n\t\t\t\tfree(vhost_name);\n\t\t\t\tif (!app_name) {\n\t\t\t\t\tuwsgi_log(\"unable to add UWSGI_APPID to the uwsgi buffer, consider increasing it\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_debug(\"VirtualHost KEY=%.*s\\n\", app_name_len, app_name);\n#endif\n\t\t\t}\n\t\t\twsgi_req->appid = app_name;\n\t\t\twsgi_req->appid_len = app_name_len;\n\t\t}\n\t}\n\n\n\tfor (i = 0; i < uwsgi_apps_cnt; i++) {\n\t\t// reset check\n\t\tfound = 0;\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"searching for %.*s in %.*s %p\\n\", app_name_len, app_name, uwsgi_apps[i].mountpoint_len, uwsgi_apps[i].mountpoint, uwsgi_apps[i].callable);\n#endif\n\t\tif (!uwsgi_apps[i].callable) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!uwsgi_strncmp(uwsgi_apps[i].mountpoint, uwsgi_apps[i].mountpoint_len, app_name, app_name_len)) {\n\t\t\tfound = 1;\n\t\t}\n\n\t\tif (found) {\n\t\t\tif (uwsgi_apps[i].touch_reload[0]) {\n\t\t\t\tif (!stat(uwsgi_apps[i].touch_reload, &st)) {\n\t\t\t\t\tif (st.st_mtime != uwsgi_apps[i].touch_reload_mtime) {\n\t\t\t\t\t\t// serve the new request and reload\n\t\t\t\t\t\tuwsgi.workers[uwsgi.mywid].manage_next_request = 0;\n\t\t\t\t\t\tif (uwsgi.threads > 1) {\n\t\t\t\t\t\t\tuwsgi.workers[uwsgi.mywid].destroy = 1;\n\t\t\t\t\t\t}\n\n#ifdef UWSGI_DEBUG\n\t\t\t\t\t\tuwsgi_log(\"mtime %d %d\\n\", st.st_mtime, uwsgi_apps[i].touch_reload_mtime);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (modifier1 == -1)\n\t\t\t\treturn i;\n\t\t\tif (modifier1 == uwsgi_apps[i].modifier1)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nchar *uwsgi_substitute(char *src, char *what, char *with) {\n\n\tint count = 0;\n\tif (!with)\n\t\treturn src;\n\n\tsize_t len = strlen(src);\n\tsize_t wlen = strlen(what);\n\tsize_t with_len = strlen(with);\n\n\tchar *p = strstr(src, what);\n\tif (!p) {\n\t\treturn src;\n\t}\n\n\twhile (p) {\n\t\tcount++;\n\t\tp = strstr(p + wlen, what);\n\t}\n\n\tlen += (count * with_len) + 1;\n\n\tchar *dst = uwsgi_calloc(len);\n\tchar *ptr = src;\n\tchar *dst_ptr = dst;\n\n\tp = strstr(ptr, what);\n\twhile (p) {\n\t\tmemcpy(dst_ptr, ptr, p - ptr);\n\t\tdst_ptr += p - ptr;\n\t\tmemcpy(dst_ptr, with, with_len);\n\t\tdst_ptr += with_len;\n\t\tptr = p + wlen;\n\t\tp = strstr(ptr, what);\n\t}\n\n\tsnprintf(dst_ptr, strlen(ptr) + 1, \"%s\", ptr);\n\n\treturn dst;\n}\n\nint uwsgi_is_file(char *filename) {\n\tstruct stat st;\n\tif (stat(filename, &st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISREG(st.st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\nint uwsgi_is_file2(char *filename, struct stat *st) {\n\tif (stat(filename, st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISREG(st->st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\n\nint uwsgi_is_dir(char *filename) {\n\tstruct stat st;\n\tif (stat(filename, &st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISDIR(st.st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\nint uwsgi_is_link(char *filename) {\n\tstruct stat st;\n\tif (lstat(filename, &st)) {\n\t\treturn 0;\n\t}\n\tif (S_ISLNK(st.st_mode))\n\t\treturn 1;\n\treturn 0;\n}\n\nvoid *uwsgi_malloc(size_t size) {\n\n\tchar *ptr = malloc(size);\n\tif (ptr == NULL) {\n\t\tuwsgi_error(\"malloc()\");\n\t\tuwsgi_log(\"!!! tried memory allocation of %llu bytes !!!\\n\", (unsigned long long) size);\n\t\tuwsgi_backtrace(uwsgi.backtrace_depth);\n\t\texit(1);\n\t}\n\n\treturn ptr;\n}\n\nvoid *uwsgi_calloc(size_t size) {\n\n\tchar *ptr = uwsgi_malloc(size);\n\tmemset(ptr, 0, size);\n\treturn ptr;\n}\n\n\nchar *uwsgi_resolve_ip(char *domain) {\n\n\tstruct hostent *he;\n\n\the = gethostbyname(domain);\n\tif (!he || !*he->h_addr_list || (he->h_addrtype != AF_INET\n#ifdef AF_INET6\n\t\t\t\t\t && he->h_addrtype != AF_INET6\n#endif\n\t    )) {\n\t\treturn NULL;\n\t}\n\n\treturn inet_ntoa(*(struct in_addr *) he->h_addr_list[0]);\n}\n\nint uwsgi_file_exists(char *filename) {\n\t// TODO check for http url or stdin\n\treturn !access(filename, R_OK);\n}\n\nint uwsgi_file_executable(char *filename) {\n\t// TODO check for http url or stdin\n\treturn !access(filename, R_OK | X_OK);\n}\n\nchar *magic_sub(char *buffer, size_t len, size_t * size, char *magic_table[]) {\n\n\tsize_t i;\n\tsize_t magic_len = 0;\n\tchar *magic_buf = uwsgi_malloc(len);\n\tchar *magic_ptr = magic_buf;\n\tchar *old_magic_buf;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buffer[i] == '%' && (i + 1) < len && magic_table[(unsigned char) buffer[i + 1]]) {\n\t\t\told_magic_buf = magic_buf;\n\t\t\tmagic_buf = uwsgi_concat3n(old_magic_buf, magic_len, magic_table[(unsigned char) buffer[i + 1]], strlen(magic_table[(unsigned char) buffer[i + 1]]), buffer + i + 2, len - i);\n\t\t\tfree(old_magic_buf);\n\t\t\tmagic_len += strlen(magic_table[(unsigned char) buffer[i + 1]]);\n\t\t\tmagic_ptr = magic_buf + magic_len;\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\t*magic_ptr = buffer[i];\n\t\t\tmagic_ptr++;\n\t\t\tmagic_len++;\n\t\t}\n\t}\n\n\t*size = magic_len;\n\n\treturn magic_buf;\n\n}\n\nvoid init_magic_table(char *magic_table[]) {\n\n\tint i;\n\tfor (i = 0; i <= 0xff; i++) {\n\t\tmagic_table[i] = \"\";\n\t}\n\n\tmagic_table['%'] = \"%\";\n\tmagic_table['('] = \"%(\";\n}\n\nchar *uwsgi_get_last_char(char *what, char c) {\n\tsize_t len = strlen(what);\n\twhile (len--) {\n\t\tif (what[len] == c)\n\t\t\treturn what + len;\n\t}\n\treturn NULL;\n}\n\nchar *uwsgi_get_last_charn(char *what, size_t len, char c) {\n\twhile (len--) {\n\t\tif (what[len] == c)\n\t\t\treturn what + len;\n\t}\n\treturn NULL;\n}\n\n\nchar *uwsgi_num2str(int num) {\n\n\tchar *str = uwsgi_malloc(11);\n\n\tsnprintf(str, 11, \"%d\", num);\n\treturn str;\n}\n\nchar *uwsgi_float2str(float num) {\n\n\tchar *str = uwsgi_malloc(11);\n\n\tsnprintf(str, 11, \"%f\", num);\n\treturn str;\n}\n\nchar *uwsgi_64bit2str(int64_t num) {\n\tchar *str = uwsgi_malloc(sizeof(MAX64_STR) + 1);\n\tsnprintf(str, sizeof(MAX64_STR) + 1, \"%lld\", (long long) num);\n\treturn str;\n}\n\nint uwsgi_num2str2(int num, char *ptr) {\n\n\treturn snprintf(ptr, 11, \"%d\", num);\n}\n\nint uwsgi_num2str2n(int num, char *ptr, int size) {\n\treturn snprintf(ptr, size, \"%d\", num);\n}\n\nint uwsgi_long2str2n(unsigned long long num, char *ptr, int size) {\n\tint ret = snprintf(ptr, size, \"%llu\", num);\n\tif (ret <= 0 || ret > size)\n\t\treturn 0;\n\treturn ret;\n}\n\nint is_unix(char *socket_name, int len) {\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (socket_name[i] == ':')\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint is_a_number(char *what) {\n\tint i;\n\n\tfor (i = 0; i < (int) strlen(what); i++) {\n\t\tif (!isdigit((int) what[i]))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nvoid uwsgi_unix_signal(int signum, void (*func) (int)) {\n\n\tstruct sigaction sa;\n\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\n\tsa.sa_handler = func;\n\n\tsigemptyset(&sa.sa_mask);\n\n\tif (sigaction(signum, &sa, NULL) < 0) {\n\t\tuwsgi_error(\"sigaction()\");\n\t}\n}\n\nint uwsgi_list_has_num(char *list, int num) {\n\n\tchar *list2 = uwsgi_concat2(list, \"\");\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(list2, \",\", p, ctx) {\n\t\tif (atoi(p) == num) {\n\t\t\tfree(list2);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(list2);\n\treturn 0;\n}\n\nint uwsgi_list_has_str(char *list, char *str) {\n\n\tchar *list2 = uwsgi_str(list);\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(list2, \" \", p, ctx) {\n\t\tif (!strcasecmp(p, str)) {\n\t\t\tfree(list2);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(list2);\n\treturn 0;\n}\n\nstatic char hex2num(char *str) {\n\n\tchar val = 0;\n\n\tval <<= 4;\n\n\tif (str[0] >= '0' && str[0] <= '9') {\n\t\tval += str[0] & 0x0F;\n\t}\n\telse if (str[0] >= 'A' && str[0] <= 'F') {\n\t\tval += (str[0] & 0x0F) + 9;\n\t}\n\telse if (str[0] >= 'a' && str[0] <= 'f') {\n\t\tval += (str[0] & 0x0F) + 9;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n\tval <<= 4;\n\n\tif (str[1] >= '0' && str[1] <= '9') {\n\t\tval += str[1] & 0x0F;\n\t}\n\telse if (str[1] >= 'A' && str[1] <= 'F') {\n\t\tval += (str[1] & 0x0F) + 9;\n\t}\n\telse if (str[1] >= 'a' && str[1] <= 'f') {\n\t\tval += (str[1] & 0x0F) + 9;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n\n\treturn val;\n}\n\nint uwsgi_str2_num(char *str) {\n\n\tint num = 0;\n\n\tnum = 10 * (str[0] - 48);\n\tnum += str[1] - 48;\n\n\treturn num;\n}\n\nint uwsgi_str3_num(char *str) {\n\n\tint num = 0;\n\n\tnum = 100 * (str[0] - 48);\n\tnum += 10 * (str[1] - 48);\n\tnum += str[2] - 48;\n\n\treturn num;\n}\n\n\nint uwsgi_str4_num(char *str) {\n\n\tint num = 0;\n\n\tnum = 1000 * (str[0] - 48);\n\tnum += 100 * (str[1] - 48);\n\tnum += 10 * (str[2] - 48);\n\tnum += str[3] - 48;\n\n\treturn num;\n}\n\nuint64_t uwsgi_str_num(char *str, int len) {\n\n\tint i;\n\tuint64_t num = 0;\n\n\tuint64_t delta = pow(10, len);\n\n\tfor (i = 0; i < len; i++) {\n\t\tdelta = delta / 10;\n\t\tnum += delta * (str[i] - 48);\n\t}\n\n\treturn num;\n}\n\nchar *uwsgi_split3(char *buf, size_t len, char sep, char **part1, size_t * part1_len, char **part2, size_t * part2_len, char **part3, size_t * part3_len) {\n\n\tsize_t i;\n\tint status = 0;\n\n\t*part1 = NULL;\n\t*part2 = NULL;\n\t*part3 = NULL;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] == sep) {\n\t\t\t// get part1\n\t\t\tif (status == 0) {\n\t\t\t\t*part1 = buf;\n\t\t\t\t*part1_len = i;\n\t\t\t\tstatus = 1;\n\t\t\t}\n\t\t\t// get part2\n\t\t\telse if (status == 1) {\n\t\t\t\t*part2 = *part1 + *part1_len + 1;\n\t\t\t\t*part2_len = (buf + i) - *part2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*part1 && *part2) {\n\t\tif (*part2 + *part2_len + 1 > buf + len) {\n\t\t\treturn NULL;\n\t\t}\n\t\t*part3 = *part2 + *part2_len + 1;\n\t\t*part3_len = (buf + len) - *part3;\n\t\treturn buf + len;\n\t}\n\n\treturn NULL;\n}\n\nchar *uwsgi_split4(char *buf, size_t len, char sep, char **part1, size_t * part1_len, char **part2, size_t * part2_len, char **part3, size_t * part3_len, char **part4, size_t * part4_len) {\n\n\tsize_t i;\n\tint status = 0;\n\n\t*part1 = NULL;\n\t*part2 = NULL;\n\t*part3 = NULL;\n\t*part4 = NULL;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] == sep) {\n\t\t\t// get part1\n\t\t\tif (status == 0) {\n\t\t\t\t*part1 = buf;\n\t\t\t\t*part1_len = i;\n\t\t\t\tstatus = 1;\n\t\t\t}\n\t\t\t// get part2\n\t\t\telse if (status == 1) {\n\t\t\t\t*part2 = *part1 + *part1_len + 1;\n\t\t\t\t*part2_len = (buf + i) - *part2;\n\t\t\t\tstatus = 2;\n\t\t\t}\n\t\t\t// get part3\n\t\t\telse if (status == 2) {\n\t\t\t\t*part3 = *part2 + *part2_len + 1;\n\t\t\t\t*part3_len = (buf + i) - *part3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (*part1 && *part2 && *part3) {\n\t\tif (*part3 + *part3_len + 1 > buf + len) {\n\t\t\treturn NULL;\n\t\t}\n\t\t*part4 = *part3 + *part3_len + 1;\n\t\t*part4_len = (buf + len) - *part4;\n\t\treturn buf + len;\n\t}\n\n\treturn NULL;\n}\n\n\nchar *uwsgi_netstring(char *buf, size_t len, char **netstring, size_t * netstring_len) {\n\n\tchar *ptr = buf;\n\tchar *watermark = buf + len;\n\t*netstring_len = 0;\n\n\twhile (ptr < watermark) {\n\t\t// end of string size ?\n\t\tif (*ptr == ':') {\n\t\t\t*netstring_len = uwsgi_str_num(buf, ptr - buf);\n\n\t\t\tif (ptr + *netstring_len + 2 > watermark) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t*netstring = ptr + 1;\n\t\t\treturn ptr + *netstring_len + 2;\n\t\t}\n\t\tptr++;\n\t}\n\n\treturn NULL;\n}\n\nstruct uwsgi_dyn_dict *uwsgi_dyn_dict_new(struct uwsgi_dyn_dict **dd, char *key, int keylen, char *val, int vallen) {\n\n\tstruct uwsgi_dyn_dict *uwsgi_dd = *dd, *old_dd;\n\n\tif (!uwsgi_dd) {\n\t\t*dd = uwsgi_malloc(sizeof(struct uwsgi_dyn_dict));\n\t\tuwsgi_dd = *dd;\n\t\tuwsgi_dd->prev = NULL;\n\t}\n\telse {\n\t\twhile (uwsgi_dd) {\n\t\t\told_dd = uwsgi_dd;\n\t\t\tuwsgi_dd = uwsgi_dd->next;\n\t\t}\n\n\t\tuwsgi_dd = uwsgi_malloc(sizeof(struct uwsgi_dyn_dict));\n\t\told_dd->next = uwsgi_dd;\n\t\tuwsgi_dd->prev = old_dd;\n\t}\n\n\tuwsgi_dd->key = key;\n\tuwsgi_dd->keylen = keylen;\n\tuwsgi_dd->value = val;\n\tuwsgi_dd->vallen = vallen;\n\tuwsgi_dd->hits = 0;\n\tuwsgi_dd->status = 0;\n\tuwsgi_dd->next = NULL;\n\n\treturn uwsgi_dd;\n}\n\nvoid uwsgi_dyn_dict_del(struct uwsgi_dyn_dict *item) {\n\n\tstruct uwsgi_dyn_dict *prev = item->prev;\n\tstruct uwsgi_dyn_dict *next = item->next;\n\n\tif (prev) {\n\t\tprev->next = next;\n\t}\n\n\tif (next) {\n\t\tnext->prev = prev;\n\t}\n\n\tfree(item);\n}\n\nvoid *uwsgi_malloc_shared(size_t size) {\n\n\tvoid *addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);\n\n\tif (addr == MAP_FAILED) {\n\t\tuwsgi_log(\"unable to allocate %llu bytes (%lluMB)\\n\", (unsigned long long) size, (unsigned long long) (size / (1024 * 1024)));\n\t\tuwsgi_error(\"mmap()\");\n\t\texit(1);\n\t}\n\n\treturn addr;\n}\n\nvoid *uwsgi_calloc_shared(size_t size) {\n\tvoid *ptr = uwsgi_malloc_shared(size);\n\tmemset(ptr, 0, size);\n\treturn ptr;\n}\n\n\nstruct uwsgi_string_list *uwsgi_string_new_list(struct uwsgi_string_list **list, char *value) {\n\n\tstruct uwsgi_string_list *uwsgi_string = *list, *old_uwsgi_string;\n\n\tif (!uwsgi_string) {\n\t\t*list = uwsgi_malloc(sizeof(struct uwsgi_string_list));\n\t\tuwsgi_string = *list;\n\t}\n\telse {\n\t\twhile (uwsgi_string) {\n\t\t\told_uwsgi_string = uwsgi_string;\n\t\t\tuwsgi_string = uwsgi_string->next;\n\t\t}\n\n\t\tuwsgi_string = uwsgi_malloc(sizeof(struct uwsgi_string_list));\n\t\told_uwsgi_string->next = uwsgi_string;\n\t}\n\n\tuwsgi_string->value = value;\n\tuwsgi_string->len = 0;\n\tif (value) {\n\t\tuwsgi_string->len = strlen(value);\n\t}\n\tuwsgi_string->next = NULL;\n\tuwsgi_string->custom = 0;\n\tuwsgi_string->custom2 = 0;\n\tuwsgi_string->custom_ptr = NULL;\n\n\treturn uwsgi_string;\n}\n\n#ifdef UWSGI_PCRE\nstruct uwsgi_regexp_list *uwsgi_regexp_custom_new_list(struct uwsgi_regexp_list **list, char *value, char *custom) {\n\n\tstruct uwsgi_regexp_list *url = *list, *old_url;\n\n\tif (!url) {\n\t\t*list = uwsgi_malloc(sizeof(struct uwsgi_regexp_list));\n\t\turl = *list;\n\t}\n\telse {\n\t\twhile (url) {\n\t\t\told_url = url;\n\t\t\turl = url->next;\n\t\t}\n\n\t\turl = uwsgi_malloc(sizeof(struct uwsgi_regexp_list));\n\t\told_url->next = url;\n\t}\n\n\tif (uwsgi_regexp_build(value, &url->pattern, &url->pattern_extra)) {\n\t\texit(1);\n\t}\n\turl->next = NULL;\n\turl->custom = 0;\n\turl->custom_ptr = NULL;\n\turl->custom_str = custom;\n\n\treturn url;\n}\n\nint uwsgi_regexp_match_pattern(char *pattern, char *str) {\n\n\tpcre *regexp;\n\tpcre_extra *regexp_extra;\n\n\tif (uwsgi_regexp_build(pattern, &regexp, &regexp_extra))\n\t\treturn 1;\n\treturn !uwsgi_regexp_match(regexp, regexp_extra, str, strlen(str));\n}\n\n\n#endif\n\nchar *uwsgi_string_get_list(struct uwsgi_string_list **list, int pos, size_t * len) {\n\n\tstruct uwsgi_string_list *uwsgi_string = *list;\n\tint counter = 0;\n\n\twhile (uwsgi_string) {\n\t\tif (counter == pos) {\n\t\t\t*len = uwsgi_string->len;\n\t\t\treturn uwsgi_string->value;\n\t\t}\n\t\tuwsgi_string = uwsgi_string->next;\n\t\tcounter++;\n\t}\n\n\t*len = 0;\n\treturn NULL;\n\n}\n\n\nvoid uwsgi_string_del_list(struct uwsgi_string_list **list, struct uwsgi_string_list *item) {\n\n\tstruct uwsgi_string_list *uwsgi_string = *list, *old_uwsgi_string = NULL;\n\n\twhile (uwsgi_string) {\n\t\tif (uwsgi_string == item) {\n\t\t\t// parent instance ?\n\t\t\tif (old_uwsgi_string == NULL) {\n\t\t\t\t*list = uwsgi_string->next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\told_uwsgi_string->next = uwsgi_string->next;\n\t\t\t}\n\n\t\t\tfree(uwsgi_string);\n\t\t\treturn;\n\t\t}\n\n\t\told_uwsgi_string = uwsgi_string;\n\t\tuwsgi_string = uwsgi_string->next;\n\t}\n\n}\n\nvoid uwsgi_sig_pause() {\n\n\tsigset_t mask;\n\tsigemptyset(&mask);\n\tsigsuspend(&mask);\n}\n\nchar *uwsgi_binsh() {\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, uwsgi.binsh) {\n\t\tif (uwsgi_file_executable(usl->value)) {\n\t\t\treturn usl->value;\n\t\t}\n\t}\n\treturn \"/bin/sh\";\n}\n\nvoid uwsgi_exec_command_with_args(char *cmdline) {\n\tchar *argv[4];\n\targv[0] = uwsgi_binsh();\n\targv[1] = \"-c\";\n\targv[2] = cmdline;\n\targv[3] = NULL;\n\texecvp(argv[0], argv);\n\tuwsgi_error(\"execvp()\");\n\texit(1);\n}\n\nstatic int uwsgi_run_command_do(char *command, char *arg) {\n\n\tchar *argv[4];\n\n#ifdef __linux__\n\tif (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0)) {\n\t\tuwsgi_error(\"prctl()\");\n\t}\n#endif\n\n\tif (command == NULL) {\n\t\targv[0] = uwsgi_binsh();\n\t\targv[1] = \"-c\";\n\t\targv[2] = arg;\n\t\targv[3] = NULL;\n\t\texecvp(argv[0], argv);\n\t}\n\telse {\n\t\targv[0] = command;\n\t\targv[1] = arg;\n\t\targv[2] = NULL;\n\t\texecvp(command, argv);\n\t}\n\n\n\tuwsgi_error(\"execvp()\");\n\t//never here\n\texit(1);\n}\n\nint uwsgi_run_command_and_wait(char *command, char *arg) {\n\n\tint waitpid_status = 0;\n\tpid_t pid = fork();\n\tif (pid < 0) {\n\t\treturn -1;\n\t}\n\n\tif (pid > 0) {\n\t\tif (waitpid(pid, &waitpid_status, 0) < 0) {\n\t\t\tuwsgi_error(\"uwsgi_run_command_and_wait()/waitpid()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn WEXITSTATUS(waitpid_status);\n\t}\n\treturn uwsgi_run_command_do(command, arg);\n}\n\nint uwsgi_run_command_putenv_and_wait(char *command, char *arg, char **envs, unsigned int nenvs) {\n\n\tint waitpid_status = 0;\n\tpid_t pid = fork();\n\tif (pid < 0) {\n\t\treturn -1;\n\t}\n\n\tif (pid > 0) {\n\t\tif (waitpid(pid, &waitpid_status, 0) < 0) {\n\t\t\tuwsgi_error(\"uwsgi_run_command_and_wait()/waitpid()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn WEXITSTATUS(waitpid_status);\n\t}\n\n\tunsigned int i;\n\tfor (i = 0; i < nenvs; i++) {\n\t\tif (putenv(envs[i])) {\n\t\t\tuwsgi_error(\"uwsgi_run_command_putenv_and_wait()/putenv()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn uwsgi_run_command_do(command, arg);\n}\n\n\npid_t uwsgi_run_command(char *command, int *stdin_fd, int stdout_fd) {\n\n\tchar *argv[4];\n\n\tint waitpid_status = 0;\n\tpid_t pid = fork();\n\tif (pid < 0) {\n\t\treturn -1;\n\t}\n\n\tif (pid > 0) {\n\t\tif (stdin_fd && stdin_fd[0] > -1) {\n\t\t\tclose(stdin_fd[0]);\n\t\t}\n\t\tif (stdout_fd > -1) {\n\t\t\tclose(stdout_fd);\n\t\t}\n\t\tif (waitpid(pid, &waitpid_status, WNOHANG) < 0) {\n\t\t\tuwsgi_error(\"waitpid()\");\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn pid;\n\t}\n\n\tuwsgi_close_all_sockets();\n\t//uwsgi_close_all_fds();\n\tint i;\n\tfor (i = 3; i < (int) uwsgi.max_fd; i++) {\n\t\tif (stdin_fd) {\n\t\t\tif (i == stdin_fd[0] || i == stdin_fd[1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (stdout_fd > -1) {\n\t\t\tif (i == stdout_fd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#ifdef __APPLE__\n\t\tfcntl(i, F_SETFD, FD_CLOEXEC);\n#else\n\t\tclose(i);\n#endif\n\t}\n\n\n\n\tif (stdin_fd) {\n\t\tclose(stdin_fd[1]);\n\t}\n\telse {\n\t\tif (!uwsgi_valid_fd(0)) {\n\t\t\tint in_fd = open(\"/dev/null\", O_RDONLY);\n\t\t\tif (in_fd < 0) {\n\t\t\t\tuwsgi_error_open(\"/dev/null\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (in_fd != 0) {\n\t\t\t\t\tif (dup2(in_fd, 0) < 0) {\n\t\t\t\t\t\tuwsgi_error(\"dup2()\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stdout_fd > -1 && stdout_fd != 1) {\n\t\tif (dup2(stdout_fd, 1) < 0) {\n\t\t\tuwsgi_error(\"dup2()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (stdin_fd && stdin_fd[0] > -1 && stdin_fd[0] != 0) {\n\t\tif (dup2(stdin_fd[0], 0) < 0) {\n\t\t\tuwsgi_error(\"dup2()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (setsid() < 0) {\n\t\tuwsgi_error(\"setsid()\");\n\t\texit(1);\n\t}\n\n\targv[0] = uwsgi_binsh();\n\targv[1] = \"-c\";\n\targv[2] = command;\n\targv[3] = NULL;\n\n\texecvp(uwsgi_binsh(), argv);\n\n\tuwsgi_error(\"execvp()\");\n\t//never here\n\texit(1);\n}\n\nint uwsgi_endswith(char *str1, char *str2) {\n\n\tsize_t i;\n\tsize_t str1len = strlen(str1);\n\tsize_t str2len = strlen(str2);\n\tchar *ptr;\n\n\tif (str2len > str1len)\n\t\treturn 0;\n\n\tptr = (str1 + str1len) - str2len;\n\n\tfor (i = 0; i < str2len; i++) {\n\t\tif (*ptr != str2[i])\n\t\t\treturn 0;\n\t\tptr++;\n\t}\n\n\treturn 1;\n}\n\nvoid uwsgi_chown(char *filename, char *owner) {\n\n\tuid_t new_uid = -1;\n\tuid_t new_gid = -1;\n\tstruct group *new_group = NULL;\n\tstruct passwd *new_user = NULL;\n\n\tchar *colon = strchr(owner, ':');\n\tif (colon) {\n\t\tcolon[0] = 0;\n\t}\n\n\n\tif (is_a_number(owner)) {\n\t\tnew_uid = atoi(owner);\n\t}\n\telse {\n\t\tnew_user = getpwnam(owner);\n\t\tif (!new_user) {\n\t\t\tuwsgi_log(\"unable to find user %s\\n\", owner);\n\t\t\texit(1);\n\t\t}\n\t\tnew_uid = new_user->pw_uid;\n\t}\n\n\tif (colon) {\n\t\tcolon[0] = ':';\n\t\tif (is_a_number(colon + 1)) {\n\t\t\tnew_gid = atoi(colon + 1);\n\t\t}\n\t\telse {\n\t\t\tnew_group = getgrnam(colon + 1);\n\t\t\tif (!new_group) {\n\t\t\t\tuwsgi_log(\"unable to find group %s\\n\", colon + 1);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tnew_gid = new_group->gr_gid;\n\t\t}\n\t}\n\n\tif (chown(filename, new_uid, new_gid)) {\n\t\tuwsgi_error(\"chown()\");\n\t\texit(1);\n\t}\n\n}\n\nchar *uwsgi_get_binary_path(char *argvzero) {\n\n#if defined(__linux__) || defined(__CYGWIN__)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tssize_t len = readlink(\"/proc/self/exe\", buf, PATH_MAX);\n\tif (len > 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(_WIN32)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tif (GetModuleFileName(NULL, buf, PATH_MAX) > 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(__NetBSD__)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tssize_t len = readlink(\"/proc/curproc/exe\", buf, PATH_MAX);\n\tif (len > 0) {\n\t\treturn buf;\n\t}\n\n\tif (realpath(argvzero, buf)) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(__APPLE__)\n\tchar *buf = uwsgi_malloc(uwsgi.page_size);\n\tuint32_t len = uwsgi.page_size;\n\tif (_NSGetExecutablePath(buf, &len) == 0) {\n\t\t// return only absolute path\n#ifndef OLD_REALPATH\n\t\tchar *newbuf = realpath(buf, NULL);\n\t\tif (newbuf) {\n\t\t\tfree(buf);\n\t\t\treturn newbuf;\n\t\t}\n#endif\n\t}\n\tfree(buf);\n#elif defined(__sun__)\n\t// do not free this value !!!\n\tchar *buf = (char *) getexecname();\n\tif (buf) {\n\t\t// return only absolute path\n\t\tif (buf[0] == '/') {\n\t\t\treturn buf;\n\t\t}\n\n\t\tchar *newbuf = uwsgi_malloc(PATH_MAX + 1);\n\t\tif (realpath(buf, newbuf)) {\n\t\t\treturn newbuf;\n\t\t}\n\t}\n#elif defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\tchar *buf = uwsgi_malloc(uwsgi.page_size);\n\tsize_t len = uwsgi.page_size;\n\tint mib[4];\n\tmib[0] = CTL_KERN;\n\tmib[1] = KERN_PROC;\n\tmib[2] = KERN_PROC_PATHNAME;\n\tmib[3] = -1;\n\tif (sysctl(mib, 4, buf, &len, NULL, 0) == 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#endif\n\n\n\treturn argvzero;\n\n}\n\nchar *uwsgi_get_line(char *ptr, char *watermark, int *size) {\n\tchar *p = ptr;\n\tint count = 0;\n\n\twhile (p < watermark) {\n\t\tif (*p == '\\n') {\n\t\t\t*size = count;\n\t\t\treturn ptr + count;\n\t\t}\n\t\tcount++;\n\t\tp++;\n\t}\n\n\treturn NULL;\n}\n\nvoid uwsgi_build_mime_dict(char *filename) {\n\n\tsize_t size = 0;\n\tchar *buf = uwsgi_open_and_read(filename, &size, 1, NULL);\n\tchar *watermark = buf + size;\n\n\tint linesize = 0;\n\tchar *line = buf;\n\tint i;\n\tint type_size = 0;\n\tint ext_start = 0;\n\tint found;\n\tint entries = 0;\n\n\tuwsgi_log(\"building mime-types dictionary from file %s...\", filename);\n\n\twhile (uwsgi_get_line(line, watermark, &linesize) != NULL) {\n\t\tfound = 0;\n\t\tif (isalnum((int) line[0])) {\n\t\t\t// get the type size\n\t\t\tfor (i = 0; i < linesize; i++) {\n\t\t\t\tif (isblank((int) line[i])) {\n\t\t\t\t\ttype_size = i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tline += linesize + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfound = 0;\n\t\t\tfor (i = type_size; i < linesize; i++) {\n\t\t\t\tif (!isblank((int) line[i])) {\n\t\t\t\t\text_start = i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tline += linesize + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchar *current = line + ext_start;\n\t\t\tint ext_size = 0;\n\t\t\tfor (i = ext_start; i < linesize; i++) {\n\t\t\t\tif (isblank((int) line[i])) {\n#ifdef UWSGI_DEBUG\n\t\t\t\t\tuwsgi_log(\"%.*s %.*s\\n\", ext_size, current, type_size, line);\n#endif\n\t\t\t\t\tuwsgi_dyn_dict_new(&uwsgi.mimetypes, current, ext_size, line, type_size);\n\t\t\t\t\tentries++;\n\t\t\t\t\text_size = 0;\n\t\t\t\t\tcurrent = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (current == NULL) {\n\t\t\t\t\tcurrent = line + i;\n\t\t\t\t}\n\t\t\t\text_size++;\n\t\t\t}\n\t\t\tif (current && ext_size > 1) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%.*s %.*s\\n\", ext_size, current, type_size, line);\n#endif\n\t\t\t\tuwsgi_dyn_dict_new(&uwsgi.mimetypes, current, ext_size, line, type_size);\n\t\t\t\tentries++;\n\t\t\t}\n\n\t\t}\n\t\tline += linesize + 1;\n\t}\n\n\tuwsgi_log(\"%d entry found\\n\", entries);\n\n}\n\n#ifdef __linux__\nstruct uwsgi_unshare_id {\n\tchar *name;\n\tint value;\n};\n\nstatic struct uwsgi_unshare_id uwsgi_unshare_list[] = {\n#ifdef CLONE_FILES\n\t{\"files\", CLONE_FILES},\n#endif\n#ifdef CLONE_NEWIPC\n\t{\"ipc\", CLONE_NEWIPC},\n#endif\n#ifdef CLONE_NEWNET\n\t{\"net\", CLONE_NEWNET},\n#endif\n#ifdef CLONE_IO\n\t{\"io\", CLONE_IO},\n#endif\n#ifdef CLONE_PARENT\n\t{\"parent\", CLONE_PARENT},\n#endif\n#ifdef CLONE_NEWPID\n\t{\"pid\", CLONE_NEWPID},\n#endif\n#ifdef CLONE_NEWNS\n\t{\"ns\", CLONE_NEWNS},\n\t{\"fs\", CLONE_NEWNS},\n\t{\"mount\", CLONE_NEWNS},\n\t{\"mnt\", CLONE_NEWNS},\n#endif\n#ifdef CLONE_SYSVSEM\n\t{\"sysvsem\", CLONE_SYSVSEM},\n#endif\n#ifdef CLONE_NEWUTS\n\t{\"uts\", CLONE_NEWUTS},\n#endif\n#ifdef CLONE_NEWUSER\n\t{\"user\", CLONE_NEWUSER},\n#endif\n\t{NULL, -1}\n};\n\nstatic int uwsgi_get_unshare_id(char *name) {\n\n\tstruct uwsgi_unshare_id *uui = uwsgi_unshare_list;\n\twhile (uui->name) {\n\t\tif (!strcmp(uui->name, name))\n\t\t\treturn uui->value;\n\t\tuui++;\n\t}\n\n\treturn -1;\n}\n\nvoid uwsgi_build_unshare(char *what, int *mask) {\n\n\tchar *list = uwsgi_str(what);\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(list, \",\", p, ctx) {\n\t\tint u_id = uwsgi_get_unshare_id(p);\n\t\tif (u_id != -1) {\n\t\t\t*mask |= u_id;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"unknown namespace subsystem: %s\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(list);\n}\n\n\n#endif\n\n#ifdef UWSGI_CAP\nstruct uwsgi_cap {\n\tchar *name;\n\tcap_value_t value;\n};\n\nstatic struct uwsgi_cap uwsgi_cap_list[] = {\n\t{\"chown\", CAP_CHOWN},\n\t{\"dac_override\", CAP_DAC_OVERRIDE},\n\t{\"dac_read_search\", CAP_DAC_READ_SEARCH},\n\t{\"fowner\", CAP_FOWNER},\n\t{\"fsetid\", CAP_FSETID},\n\t{\"kill\", CAP_KILL},\n\t{\"setgid\", CAP_SETGID},\n\t{\"setuid\", CAP_SETUID},\n\t{\"setpcap\", CAP_SETPCAP},\n\t{\"linux_immutable\", CAP_LINUX_IMMUTABLE},\n\t{\"net_bind_service\", CAP_NET_BIND_SERVICE},\n\t{\"net_broadcast\", CAP_NET_BROADCAST},\n\t{\"net_admin\", CAP_NET_ADMIN},\n\t{\"net_raw\", CAP_NET_RAW},\n\t{\"ipc_lock\", CAP_IPC_LOCK},\n\t{\"ipc_owner\", CAP_IPC_OWNER},\n\t{\"sys_module\", CAP_SYS_MODULE},\n\t{\"sys_rawio\", CAP_SYS_RAWIO},\n\t{\"sys_chroot\", CAP_SYS_CHROOT},\n\t{\"sys_ptrace\", CAP_SYS_PTRACE},\n\t{\"sys_pacct\", CAP_SYS_PACCT},\n\t{\"sys_admin\", CAP_SYS_ADMIN},\n\t{\"sys_boot\", CAP_SYS_BOOT},\n\t{\"sys_nice\", CAP_SYS_NICE},\n\t{\"sys_resource\", CAP_SYS_RESOURCE},\n\t{\"sys_time\", CAP_SYS_TIME},\n\t{\"sys_tty_config\", CAP_SYS_TTY_CONFIG},\n\t{\"mknod\", CAP_MKNOD},\n#ifdef CAP_LEASE\n\t{\"lease\", CAP_LEASE},\n#endif\n#ifdef CAP_AUDIT_WRITE\n\t{\"audit_write\", CAP_AUDIT_WRITE},\n#endif\n#ifdef CAP_AUDIT_CONTROL\n\t{\"audit_control\", CAP_AUDIT_CONTROL},\n#endif\n#ifdef CAP_SETFCAP\n\t{\"setfcap\", CAP_SETFCAP},\n#endif\n#ifdef CAP_MAC_OVERRIDE\n\t{\"mac_override\", CAP_MAC_OVERRIDE},\n#endif\n#ifdef CAP_MAC_ADMIN\n\t{\"mac_admin\", CAP_MAC_ADMIN},\n#endif\n#ifdef CAP_SYSLOG\n\t{\"syslog\", CAP_SYSLOG},\n#endif\n#ifdef CAP_WAKE_ALARM\n\t{\"wake_alarm\", CAP_WAKE_ALARM},\n#endif\n\t{NULL, -1}\n};\n\nstatic int uwsgi_get_cap_id(char *name) {\n\n\tstruct uwsgi_cap *ucl = uwsgi_cap_list;\n\twhile (ucl->name) {\n\t\tif (!strcmp(ucl->name, name))\n\t\t\treturn ucl->value;\n\t\tucl++;\n\t}\n\n\treturn -1;\n}\n\nint uwsgi_build_cap(char *what, cap_value_t ** cap) {\n\n\tint cap_id;\n\tchar *caps = uwsgi_str(what);\n\tint pos = 0;\n\tint count = 0;\n\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(caps, \",\", p, ctx) {\n\t\tif (is_a_number(p)) {\n\t\t\tcount++;\n\t\t}\n\t\telse {\n\t\t\tcap_id = uwsgi_get_cap_id(p);\n\t\t\tif (cap_id != -1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_log(\"[security] unknown capability: %s\\n\", p);\n\t\t\t}\n\t\t}\n\t}\n\tfree(caps);\n\n\t*cap = uwsgi_malloc(sizeof(cap_value_t) * count);\n\n\tcaps = uwsgi_str(what);\n\tctx = NULL;\n\tuwsgi_foreach_token(caps, \",\", p, ctx) {\n\t\tif (is_a_number(p)) {\n\t\t\tcap_id = atoi(p);\n\t\t}\n\t\telse {\n\t\t\tcap_id = uwsgi_get_cap_id(p);\n\t\t}\n\t\tif (cap_id != -1) {\n\t\t\t(*cap)[pos] = cap_id;\n\t\t\tuwsgi_log(\"setting capability %s [%d]\\n\", p, cap_id);\n\t\t\tpos++;\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"[security] unknown capability: %s\\n\", p);\n\t\t}\n\t}\n\tfree(caps);\n\n\treturn count;\n}\n\n#endif\n\nvoid uwsgi_apply_config_pass(char symbol, char *(*hook) (char *)) {\n\n\tint i, j;\n\n\tfor (i = 0; i < uwsgi.exported_opts_cnt; i++) {\n\t\tint has_symbol = 0;\n\t\tint depth = 0;\n\t\tchar *magic_key = NULL;\n\t\tchar *magic_val = NULL;\n\t\tif (uwsgi.exported_opts[i]->value && !uwsgi.exported_opts[i]->configured) {\n\t\t\tfor (j = 0; j < (int) strlen(uwsgi.exported_opts[i]->value); j++) {\n\t\t\t\tif (uwsgi.exported_opts[i]->value[j] == symbol) {\n\t\t\t\t\thas_symbol = 1;\n\t\t\t\t}\n\t\t\t\telse if (uwsgi.exported_opts[i]->value[j] == '(' && has_symbol == 1) {\n\t\t\t\t\thas_symbol = 2;\n\t\t\t\t\tdepth = 0;\n\t\t\t\t\tmagic_key = uwsgi.exported_opts[i]->value + j + 1;\n\t\t\t\t}\n\t\t\t\telse if (has_symbol > 1) {\n\t\t\t\t\tif (uwsgi.exported_opts[i]->value[j] == '(') {\n\t\t\t\t\t\thas_symbol++;\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (uwsgi.exported_opts[i]->value[j] == ')') {\n\t\t\t\t\t\tif (depth > 0) {\n\t\t\t\t\t\t\thas_symbol++;\n\t\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (has_symbol <= 2) {\n\t\t\t\t\t\t\tmagic_key = NULL;\n\t\t\t\t\t\t\thas_symbol = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n#ifdef UWSGI_DEBUG\n\t\t\t\t\t\tuwsgi_log(\"need to interpret the %.*s tag\\n\", has_symbol - 2, magic_key);\n#endif\n\t\t\t\t\t\tchar *tmp_magic_key = uwsgi_concat2n(magic_key, has_symbol - 2, \"\", 0);\n\t\t\t\t\t\tmagic_val = hook(tmp_magic_key);\n\t\t\t\t\t\tfree(tmp_magic_key);\n\t\t\t\t\t\tif (!magic_val) {\n\t\t\t\t\t\t\tmagic_key = NULL;\n\t\t\t\t\t\t\thas_symbol = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuwsgi.exported_opts[i]->value = uwsgi_concat4n(uwsgi.exported_opts[i]->value, (magic_key - 2) - uwsgi.exported_opts[i]->value, magic_val, strlen(magic_val), magic_key + (has_symbol - 1), strlen(magic_key + (has_symbol - 1)), \"\", 0);\n#ifdef UWSGI_DEBUG\n\t\t\t\t\t\tuwsgi_log(\"computed new value = %s\\n\", uwsgi.exported_opts[i]->value);\n#endif\n\t\t\t\t\t\tmagic_key = NULL;\n\t\t\t\t\t\thas_symbol = 0;\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thas_symbol++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thas_symbol = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid uwsgi_set_processname(char *name) {\n\n#if defined(__linux__) || defined(__sun__)\n\tsize_t amount = 0;\n\n\t// prepare for strncat\n\t*uwsgi.orig_argv[0] = 0;\n\n\tif (uwsgi.procname_prefix) {\n\t\tamount += strlen(uwsgi.procname_prefix);\n\t\tif ((int) amount > uwsgi.max_procname - 1)\n\t\t\treturn;\n\t\tstrncat(uwsgi.orig_argv[0], uwsgi.procname_prefix, uwsgi.max_procname - (amount + 1));\n\t}\n\n\tamount += strlen(name);\n\tif ((int) amount > uwsgi.max_procname - 1)\n\t\treturn;\n\tstrncat(uwsgi.orig_argv[0], name, (uwsgi.max_procname - amount + 1));\n\n\tif (uwsgi.procname_append) {\n\t\tamount += strlen(uwsgi.procname_append);\n\t\tif ((int) amount > uwsgi.max_procname - 1)\n\t\t\treturn;\n\t\tstrncat(uwsgi.orig_argv[0], uwsgi.procname_append, uwsgi.max_procname - (amount + 1));\n\t}\n\n\t// fill with spaces...\n\tmemset(uwsgi.orig_argv[0] + amount + 1, ' ', uwsgi.max_procname - (amount));\n\t// end with \\0\n\tmemset(uwsgi.orig_argv[0] + amount + 1 + (uwsgi.max_procname - (amount)), '\\0', 1);\n\n#elif defined(__FreeBSD__) || defined(__GNU_kFreeBSD__) || defined(__NetBSD__)\n\tif (uwsgi.procname_prefix) {\n\t\tif (!uwsgi.procname_append) {\n\t\t\tsetproctitle(\"-%s%s\", uwsgi.procname_prefix, name);\n\t\t}\n\t\telse {\n\t\t\tsetproctitle(\"-%s%s%s\", uwsgi.procname_prefix, name, uwsgi.procname_append);\n\t\t}\n\t}\n\telse if (uwsgi.procname_append) {\n\t\tif (!uwsgi.procname_prefix) {\n\t\t\tsetproctitle(\"-%s%s\", name, uwsgi.procname_append);\n\t\t}\n\t\telse {\n\t\t\tsetproctitle(\"-%s%s%s\", uwsgi.procname_prefix, name, uwsgi.procname_append);\n\t\t}\n\t}\n\telse {\n\t\tsetproctitle(\"-%s\", name);\n\t}\n#endif\n}\n\n// this is a wrapper for fork restoring original argv\npid_t uwsgi_fork(char *name) {\n\n\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\n#ifndef __CYGWIN__\n\t\tif (uwsgi.never_swap) {\n\t\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE)) {\n\t\t\t\tuwsgi_error(\"mlockall()\");\n\t\t\t}\n\t\t}\n#endif\n\n#if defined(__linux__) || defined(__sun__)\n\t\tint i;\n\t\tfor (i = 0; i < uwsgi.argc; i++) {\n\t\t\t// stop fixing original argv if the new one is bigger\n\t\t\tif (!uwsgi.orig_argv[i]) break;\n\t\t\tstrcpy(uwsgi.orig_argv[i], uwsgi.argv[i]);\n\t\t}\n#endif\n\n\t\tif (uwsgi.auto_procname && name) {\n\t\t\tif (uwsgi.procname) {\n\t\t\t\tuwsgi_set_processname(uwsgi.procname);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_set_processname(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pid;\n}\n\nvoid escape_shell_arg(char *src, size_t len, char *dst) {\n\n\tsize_t i;\n\tchar *ptr = dst;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (strchr(\"&;`'\\\"|*?~<>^()[]{}$\\\\\\n\", src[i])) {\n\t\t\t*ptr++ = '\\\\';\n\t\t}\n\t\t*ptr++ = src[i];\n\t}\n\n\t*ptr++ = 0;\n}\n\nvoid escape_json(char *src, size_t len, char *dst) {\n\n\tsize_t i;\n\tchar *ptr = dst;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (src[i] == '\\t') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = 't';\n\t\t}\n\t\telse if (src[i] == '\\n') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = 'n';\n\t\t}\n\t\telse if (src[i] == '\\r') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = 'r';\n\t\t}\n\t\telse if (src[i] == '\"') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = '\"';\n\t\t}\n\t\telse if (src[i] == '\\\\') {\n\t\t\t*ptr++ = '\\\\';\n\t\t\t*ptr++ = '\\\\';\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = src[i];\n\t\t}\n\t}\n\n\t*ptr++ = 0;\n}\n\n/*\n\nbuild PATH_INFO from raw_uri\n\nit manages:\n\n\tpercent encoding\n\tdot_segments removal\n\tstop at the first #\n\n*/\nvoid http_url_decode(char *buf, uint16_t * len, char *dst) {\n\n\tenum {\n\t\tzero = 0,\n\t\tpercent1,\n\t\tpercent2,\n\t\tslash,\n\t\tdot,\n\t\tdotdot\n\t} status;\n\n\tuint16_t i, current_new_len, new_len = 0;\n\n\tchar value[2];\n\n\tchar *ptr = dst;\n\n\tvalue[0] = '0';\n\tvalue[1] = '0';\n\n\tstatus = zero;\n\tint no_slash = 0;\n\n\tif (*len > 0 && buf[0] != '/') {\n\t\tstatus = slash;\n\t\tno_slash = 1;\n\t}\n\n\tfor (i = 0; i < *len; i++) {\n\t\tchar c = buf[i];\n\t\tif (c == '#')\n\t\t\tbreak;\n\t\tswitch (status) {\n\t\tcase zero:\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '/') {\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tbreak;\n\t\tcase percent1:\n\t\t\tif (c == '%') {\n\t\t\t\t*ptr++ = '%';\n\t\t\t\tnew_len++;\n\t\t\t\tstatus = zero;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue[0] = c;\n\t\t\tstatus = percent2;\n\t\t\tbreak;\n\t\tcase percent2:\n\t\t\tvalue[1] = c;\n\t\t\t*ptr++ = hex2num(value);\n\t\t\tnew_len++;\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\tcase slash:\n\t\t\tif (c == '.') {\n\t\t\t\tstatus = dot;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// we could be at the first round (in non slash)\n\t\t\tif (i > 0 || !no_slash) {\n\t\t\t\t*ptr++ = '/';\n\t\t\t\tnew_len++;\n\t\t\t}\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '/') {\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\tcase dot:\n\t\t\tif (c == '.') {\n\t\t\t\tstatus = dotdot;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '/') {\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i > 1) {\n\t\t\t\t*ptr++ = '/';\n\t\t\t\tnew_len++;\n\t\t\t}\n\t\t\t*ptr++ = '.';\n\t\t\tnew_len++;\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\tcase dotdot:\n\t\t\t// here we need to remove a segment\n\t\t\tif (c == '/') {\n\t\t\t\tcurrent_new_len = new_len;\n\t\t\t\twhile (current_new_len) {\n\t\t\t\t\tcurrent_new_len--;\n\t\t\t\t\tptr--;\n\t\t\t\t\tif (dst[current_new_len] == '/') {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnew_len = current_new_len;\n\t\t\t\tstatus = slash;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i > 2) {\n\t\t\t\t*ptr++ = '/';\n\t\t\t\tnew_len++;\n\t\t\t}\n\t\t\t*ptr++ = '.';\n\t\t\tnew_len++;\n\t\t\t*ptr++ = '.';\n\t\t\tnew_len++;\n\t\t\tif (c == '%') {\n\t\t\t\tstatus = percent1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tstatus = zero;\n\t\t\tbreak;\n\t\t\t// over engineering\n\t\tdefault:\n\t\t\t*ptr++ = c;\n\t\t\tnew_len++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (status) {\n\tcase slash:\n\tcase dot:\n\t\t*ptr++ = '/';\n\t\tnew_len++;\n\t\tbreak;\n\tcase dotdot:\n\t\tcurrent_new_len = new_len;\n\t\twhile (current_new_len) {\n\t\t\tif (dst[current_new_len - 1] == '/') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_new_len--;\n\t\t}\n\t\tnew_len = current_new_len;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t*len = new_len;\n\n}\n\n\n/*\n\twe scan the table in reverse, as updated values are at the end\n*/\nchar *uwsgi_get_var(struct wsgi_request *wsgi_req, char *key, uint16_t keylen, uint16_t * len) {\n\n\tint i;\n\n\tfor (i = wsgi_req->var_cnt - 1; i > 0; i -= 2) {\n\t\tif (!uwsgi_strncmp(key, keylen, wsgi_req->hvec[i - 1].iov_base, wsgi_req->hvec[i - 1].iov_len)) {\n\t\t\t*len = wsgi_req->hvec[i].iov_len;\n\t\t\treturn wsgi_req->hvec[i].iov_base;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct uwsgi_app *uwsgi_add_app(int id, uint8_t modifier1, char *mountpoint, int mountpoint_len, void *interpreter, void *callable) {\n\n\tif (id > uwsgi.max_apps) {\n\t\tuwsgi_log(\"FATAL ERROR: you cannot load more than %d apps in a worker\\n\", uwsgi.max_apps);\n\t\texit(1);\n\t}\n\n\tstruct uwsgi_app *wi = &uwsgi_apps[id];\n\tmemset(wi, 0, sizeof(struct uwsgi_app));\n\n\twi->modifier1 = modifier1;\n\twi->mountpoint_len = mountpoint_len < 0xff ? mountpoint_len : (0xff - 1);\n\tstrncpy(wi->mountpoint, mountpoint, wi->mountpoint_len);\n\twi->interpreter = interpreter;\n\twi->callable = callable;\n\n\tuwsgi_apps_cnt++;\n\t// check if we need to emulate fork() COW\n\tint i;\n\tif (uwsgi.mywid == 0) {\n\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\tmemcpy(&uwsgi.workers[i].apps[id], &uwsgi.workers[0].apps[id], sizeof(struct uwsgi_app));\n\t\t\tuwsgi.workers[i].apps_cnt = uwsgi_apps_cnt;\n\t\t}\n\t}\n\n\tif (!uwsgi.no_default_app) {\n\t\tif ((mountpoint_len == 0 || (mountpoint_len == 1 && mountpoint[0] == '/')) && uwsgi.default_app == -1) {\n\t\t\tuwsgi.default_app = id;\n\t\t}\n\t}\n\n\treturn wi;\n}\n\n\nchar *uwsgi_check_touches(struct uwsgi_string_list *touch_list) {\n\n\t// touch->value   - file path\n\t// touch->custom  - file timestamp\n\t// touch->custom2 - 0 if file exists, 1 if it does not exists\n\n\tstruct uwsgi_string_list *touch = touch_list;\n\twhile (touch) {\n\t\tstruct stat tr_st;\n\t\tif (stat(touch->value, &tr_st)) {\n\t\t\tif (touch->custom && !touch->custom2) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"[uwsgi-check-touches] File %s was removed\\n\", touch->value);\n#endif\n\t\t\t\ttouch->custom2 = 1;\n\t\t\t\treturn touch->custom_ptr ? touch->custom_ptr : touch->value;\n\t\t\t}\n\t\t\telse if (!touch->custom && !touch->custom2) {\n\t\t\t\tuwsgi_log(\"unable to stat() %s, events will be triggered as soon as the file is created\\n\", touch->value);\n\t\t\t\ttouch->custom2 = 1;\n\t\t\t}\n\t\t\ttouch->custom = 0;\n\t\t}\n\t\telse {\n\t\t\tif (!touch->custom && touch->custom2) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"[uwsgi-check-touches] File was created: %s\\n\", touch->value);\n#endif\n\t\t\t\ttouch->custom = (uint64_t) tr_st.st_mtime;\n\t\t\t\ttouch->custom2 = 0;\n\t\t\t\treturn touch->custom_ptr ? touch->custom_ptr : touch->value;\n\t\t\t}\n\t\t\telse if (touch->custom && (uint64_t) tr_st.st_mtime > touch->custom) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"[uwsgi-check-touches] modification detected on %s: %llu -> %llu\\n\", touch->value, (unsigned long long) touch->custom, (unsigned long long) tr_st.st_mtime);\n#endif\n\t\t\t\ttouch->custom = (uint64_t) tr_st.st_mtime;\n\t\t\t\treturn touch->custom_ptr ? touch->custom_ptr : touch->value;\n\t\t\t}\n\t\t\ttouch->custom = (uint64_t) tr_st.st_mtime;\n\t\t}\n\t\ttouch = touch->next;\n\t}\n\n\treturn NULL;\n}\n\nchar *uwsgi_chomp(char *str) {\n\tssize_t slen = (ssize_t) strlen(str), i;\n\tif (!slen)\n\t\treturn str;\n\tslen--;\n\tfor (i = slen; i >= 0; i--) {\n\t\tif (str[i] == '\\r' || str[i] == '\\n') {\n\t\t\tstr[i] = 0;\n\t\t}\n\t\telse {\n\t\t\treturn str;\n\t\t}\n\t}\n\n\treturn str;\n}\n\nchar *uwsgi_chomp2(char *str) {\n\tssize_t slen = (ssize_t) strlen(str), i;\n\tif (!slen)\n\t\treturn str;\n\tslen--;\n\tfor (i = slen; i >= 0; i--) {\n\t\tif (str[i] == '\\r' || str[i] == '\\n' || str[i] == '\\t' || str[i] == ' ') {\n\t\t\tstr[i] = 0;\n\t\t}\n\t\telse {\n\t\t\treturn str;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n\n\nint uwsgi_tmpfd() {\n\tint fd = -1;\n\tchar *tmpdir = getenv(\"TMPDIR\");\n\tif (!tmpdir) {\n\t\ttmpdir = \"/tmp\";\n\t}\n#ifdef O_TMPFILE\n\tfd = open(tmpdir, O_TMPFILE | O_RDWR, S_IRUSR | S_IWUSR);\n\tif (fd >= 0) {\n\t\treturn fd;\n\t}\n\t// fallback to old style\n#endif\n\tchar *template = uwsgi_concat2(tmpdir, \"/uwsgiXXXXXX\");\n\tfd = mkstemp(template);\n\tunlink(template);\n\tfree(template);\n\treturn fd;\n}\n\nFILE *uwsgi_tmpfile() {\n\tint fd = uwsgi_tmpfd();\n\tif (fd < 0)\n\t\treturn NULL;\n\treturn fdopen(fd, \"w+\");\n}\n\nint uwsgi_file_to_string_list(char *filename, struct uwsgi_string_list **list) {\n\n\tchar line[1024];\n\n\tFILE *fh = fopen(filename, \"r\");\n\tif (fh) {\n\t\twhile (fgets(line, 1024, fh)) {\n\t\t\tuwsgi_string_new_list(list, uwsgi_chomp(uwsgi_str(line)));\n\t\t}\n\t\tfclose(fh);\n\t\treturn 1;\n\t}\n\tuwsgi_error_open(filename);\n\treturn 0;\n}\n\nvoid uwsgi_setup_post_buffering() {\n\n\tif (!uwsgi.post_buffering_bufsize)\n\t\tuwsgi.post_buffering_bufsize = 8192;\n\n\tif (uwsgi.post_buffering_bufsize < uwsgi.post_buffering) {\n\t\tuwsgi.post_buffering_bufsize = uwsgi.post_buffering;\n\t\tuwsgi_log(\"setting request body buffering size to %lu bytes\\n\", (unsigned long) uwsgi.post_buffering_bufsize);\n\t}\n\n}\n\nvoid uwsgi_emulate_cow_for_apps(int id) {\n\tint i;\n\t// check if we need to emulate fork() COW\n\tif (uwsgi.mywid == 0) {\n\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\tmemcpy(&uwsgi.workers[i].apps[id], &uwsgi.workers[0].apps[id], sizeof(struct uwsgi_app));\n\t\t\tuwsgi.workers[i].apps_cnt = uwsgi_apps_cnt;\n\t\t}\n\t}\n}\n\nint uwsgi_write_intfile(char *filename, int n) {\n\tFILE *pidfile = fopen(filename, \"w\");\n\tif (!pidfile) {\n\t\tuwsgi_error_open(filename);\n\t\texit(1);\n\t}\n\tif (fprintf(pidfile, \"%d\\n\", n) <= 0 || ferror(pidfile)) {\n\t\tfclose(pidfile);\n\t\treturn -1;\n\t}\n\tif (fclose(pidfile)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nvoid uwsgi_write_pidfile(char *pidfile_name) {\n\tuwsgi_log(\"writing pidfile to %s\\n\", pidfile_name);\n\tif (uwsgi_write_intfile(pidfile_name, (int) getpid())) {\n\t\tuwsgi_log(\"could not write pidfile.\\n\");\n\t}\n}\n\nvoid uwsgi_write_pidfile_explicit(char *pidfile_name, pid_t pid) {\n\tuwsgi_log(\"writing pidfile to %s\\n\", pidfile_name);\n\tif (uwsgi_write_intfile(pidfile_name, (int) pid)) {\n\t\tuwsgi_log(\"could not write pidfile.\\n\");\n\t}\n}\n\nchar *uwsgi_expand_path(char *dir, int dir_len, char *ptr) {\n\tif (dir_len > PATH_MAX)\n\t{\n\t\tuwsgi_log(\"invalid path size: %d (max %d)\\n\", dir_len, PATH_MAX);\n\t\treturn NULL;\n\t}\n\tchar *src = uwsgi_concat2n(dir, dir_len, \"\", 0);\n\tchar *dst = ptr;\n\tif (!dst)\n\t\tdst = uwsgi_malloc(PATH_MAX + 1);\n\tif (!realpath(src, dst)) {\n\t\tuwsgi_error_realpath(src);\n\t\tif (!ptr)\n\t\t\tfree(dst);\n\t\tfree(src);\n\t\treturn NULL;\n\t}\n\tfree(src);\n\treturn dst;\n}\n\n\nvoid uwsgi_set_cpu_affinity() {\n\tchar buf[4096];\n\tint ret;\n\tint pos = 0;\n\tif (uwsgi.cpu_affinity) {\n\t\tint base_cpu = (uwsgi.mywid - 1) * uwsgi.cpu_affinity;\n\t\tif (base_cpu >= uwsgi.cpus) {\n\t\t\tbase_cpu = base_cpu % uwsgi.cpus;\n\t\t}\n\t\tret = snprintf(buf, 4096, \"mapping worker %d to CPUs:\", uwsgi.mywid);\n\t\tif (ret < 25 || ret >= 4096) {\n\t\t\tuwsgi_log(\"unable to initialize cpu affinity !!!\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tpos += ret;\n#if defined(__linux__) || defined(__GNU_kFreeBSD__)\n\t\tcpu_set_t cpuset;\n#elif defined(__FreeBSD__)\n\t\tcpuset_t cpuset;\n#endif\n#if defined(__linux__) || defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\t\tCPU_ZERO(&cpuset);\n\t\tint i;\n\t\tfor (i = 0; i < uwsgi.cpu_affinity; i++) {\n\t\t\tif (base_cpu >= uwsgi.cpus)\n\t\t\t\tbase_cpu = 0;\n\t\t\tCPU_SET(base_cpu, &cpuset);\n\t\t\tret = snprintf(buf + pos, 4096 - pos, \" %d\", base_cpu);\n\t\t\tif (ret < 2 || ret >= 4096) {\n\t\t\t\tuwsgi_log(\"unable to initialize cpu affinity !!!\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tpos += ret;\n\t\t\tbase_cpu++;\n\t\t}\n#endif\n#if defined(__linux__) || defined(__GNU_kFreeBSD__)\n\t\tif (sched_setaffinity(0, sizeof(cpu_set_t), &cpuset)) {\n\t\t\tuwsgi_error(\"sched_setaffinity()\");\n\t\t}\n#elif defined(__FreeBSD__)\n\t\tif (cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(cpuset), &cpuset)) {\n\t\t\tuwsgi_error(\"cpuset_setaffinity\");\n\t\t}\n#endif\n\t\tuwsgi_log(\"%s\\n\", buf);\n\t}\n\n}\n\n#ifdef UWSGI_ELF\n#if defined(__linux__)\n#include <elf.h>\n#endif\nchar *uwsgi_elf_section(char *filename, char *s, size_t * len) {\n\tstruct stat st;\n\tchar *output = NULL;\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(filename);\n\t\treturn NULL;\n\t}\n\n\tif (fstat(fd, &st)) {\n\t\tuwsgi_error(\"stat()\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tif (st.st_size < EI_NIDENT) {\n\t\tuwsgi_log(\"invalid elf file: %s\\n\", filename);\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tchar *addr = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (addr == MAP_FAILED) {\n\t\tuwsgi_error(\"mmap()\");\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\n\tif (addr[0] != ELFMAG0)\n\t\tgoto clear;\n\tif (addr[1] != ELFMAG1)\n\t\tgoto clear;\n\tif (addr[2] != ELFMAG2)\n\t\tgoto clear;\n\tif (addr[3] != ELFMAG3)\n\t\tgoto clear;\n\n\tif (addr[4] == ELFCLASS32) {\n\t\t// elf header\n\t\tElf32_Ehdr *elfh = (Elf32_Ehdr *) addr;\n\t\t// first section\n\t\tElf32_Shdr *sections = ((Elf32_Shdr *) (addr + elfh->e_shoff));\n\t\t// number of sections\n\t\tint ns = elfh->e_shnum;\n\t\t// the names table\n\t\tElf32_Shdr *table = &sections[elfh->e_shstrndx];\n\t\t// string table session pointer\n\t\tchar *names = addr + table->sh_offset;\n\t\tElf32_Shdr *ss = NULL;\n\t\tint i;\n\t\tfor (i = 0; i < ns; i++) {\n\t\t\tchar *name = names + sections[i].sh_name;\n\t\t\tif (!strcmp(name, s)) {\n\t\t\t\tss = &sections[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ss) {\n\t\t\t*len = ss->sh_size;\n\t\t\toutput = uwsgi_concat2n(addr + ss->sh_offset, ss->sh_size, \"\", 0);\n\t\t}\n\t}\n\telse if (addr[4] == ELFCLASS64) {\n\t\t// elf header\n\t\tElf64_Ehdr *elfh = (Elf64_Ehdr *) addr;\n\t\t// first section\n\t\tElf64_Shdr *sections = ((Elf64_Shdr *) (addr + elfh->e_shoff));\n\t\t// number of sections\n\t\tint ns = elfh->e_shnum;\n\t\t// the names table\n\t\tElf64_Shdr *table = &sections[elfh->e_shstrndx];\n\t\t// string table session pointer\n\t\tchar *names = addr + table->sh_offset;\n\t\tElf64_Shdr *ss = NULL;\n\t\tint i;\n\t\tfor (i = 0; i < ns; i++) {\n\t\t\tchar *name = names + sections[i].sh_name;\n\t\t\tif (!strcmp(name, s)) {\n\t\t\t\tss = &sections[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ss) {\n\t\t\t*len = ss->sh_size;\n\t\t\toutput = uwsgi_concat2n(addr + ss->sh_offset, ss->sh_size, \"\", 0);\n\t\t}\n\t}\n\n\nclear:\n\tclose(fd);\n\tmunmap(addr, st.st_size);\n\treturn output;\n}\n#endif\n\nstatic void *uwsgi_thread_run(void *arg) {\n\tstruct uwsgi_thread *ut = (struct uwsgi_thread *) arg;\n\t// block all signals\n\tsigset_t smask;\n\tsigfillset(&smask);\n\tpthread_sigmask(SIG_BLOCK, &smask, NULL);\n\n\tut->queue = event_queue_init();\n\tevent_queue_add_fd_read(ut->queue, ut->pipe[1]);\n\n\tut->func(ut);\n\treturn NULL;\n}\n\nstruct uwsgi_thread *uwsgi_thread_new_with_data(void (*func) (struct uwsgi_thread *), void *data) {\n\n\tstruct uwsgi_thread *ut = uwsgi_calloc(sizeof(struct uwsgi_thread));\n\n#if defined(SOCK_SEQPACKET) && defined(__linux__)\n\tif (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, ut->pipe)) {\n#else\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, ut->pipe)) {\n#endif\n\t\tfree(ut);\n\t\treturn NULL;\n\t}\n\n\tuwsgi_socket_nb(ut->pipe[0]);\n\tuwsgi_socket_nb(ut->pipe[1]);\n\n\tut->func = func;\n\tut->data = data;\n\n\tpthread_attr_init(&ut->tattr);\n\tpthread_attr_setdetachstate(&ut->tattr, PTHREAD_CREATE_DETACHED);\n\t// 512K should be enough...\n\tpthread_attr_setstacksize(&ut->tattr, 512 * 1024);\n\n\tif (pthread_create(&ut->tid, &ut->tattr, uwsgi_thread_run, ut)) {\n\t\tuwsgi_error(\"pthread_create()\");\n\t\tgoto error;\n\t}\n\n\treturn ut;\nerror:\n\tclose(ut->pipe[0]);\n\tclose(ut->pipe[1]);\n\tfree(ut);\n\treturn NULL;\n}\n\nstruct uwsgi_thread *uwsgi_thread_new(void (*func) (struct uwsgi_thread *)) {\n\treturn uwsgi_thread_new_with_data(func, NULL);\n}\n\nint uwsgi_kvlist_parse(char *src, size_t len, char list_separator, int kv_separator, ...) {\n\tsize_t i;\n\tva_list ap;\n\tstruct uwsgi_string_list *itemlist = NULL;\n\n\tchar *buf = uwsgi_calloc(len + 1);\n\n\t// ok let's start splitting the string\n\tint escaped = 0;\n\tchar *base = buf;\n\tchar *ptr = buf;\n\tfor (i = 0; i < len; i++) {\n\t\tif (src[i] == list_separator && !escaped) {\n\t\t\t*ptr++ = 0;\n\t\t\tuwsgi_string_new_list(&itemlist, base);\n\t\t\tbase = ptr;\n\t\t}\n\t\telse if (src[i] == '\\\\' && !escaped) {\n\t\t\tescaped = 1;\n\t\t}\n\t\telse if (escaped) {\n\t\t\t*ptr++ = src[i];\n\t\t\tescaped = 0;\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = src[i];\n\t\t}\n\t}\n\n\tif (ptr > base) {\n\t\tuwsgi_string_new_list(&itemlist, base);\n\t}\n\n\tstruct uwsgi_string_list *usl = itemlist;\n\twhile (usl) {\n\t\tlen = strlen(usl->value);\n\t\tchar *item_buf = uwsgi_calloc(len + 1);\n\t\tbase = item_buf;\n\t\tptr = item_buf;\n\t\tescaped = 0;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (usl->value[i] == kv_separator && !escaped) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tva_start(ap, kv_separator);\n\t\t\t\tfor (;;) {\n\t\t\t\t\tchar *p = va_arg(ap, char *);\n\t\t\t\t\tif (!p)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tchar **pp = va_arg(ap, char **);\n\t\t\t\t\tif (!pp)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!strcmp(p, base)) {\n\t\t\t\t\t\t*pp = uwsgi_str(usl->value + i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tva_end(ap);\n\t\t\t\tbase = ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (usl->value[i] == '\\\\' && !escaped) {\n\t\t\t\tescaped = 1;\n\t\t\t}\n\t\t\telse if (escaped) {\n\t\t\t\tescaped = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t*ptr++ = usl->value[i];\n\t\t\t}\n\t\t}\n\t\tfree(item_buf);\n\t\tusl = usl->next;\n\t}\n\n\t// destroy the list (no need to destroy the value as it is a pointer to buf)\n\tusl = itemlist;\n\twhile (usl) {\n\t\tstruct uwsgi_string_list *tmp_usl = usl;\n\t\tusl = usl->next;\n\t\tfree(tmp_usl);\n\t}\n\n\tfree(buf);\n\treturn 0;\n}\n\nint uwsgi_send_http_stats(int fd) {\n\n\tchar buf[4096];\n\n\tint ret = uwsgi_waitfd(fd, uwsgi.socket_timeout);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tif (read(fd, buf, 4096) <= 0)\n\t\treturn -1;\n\n\tstruct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);\n\tif (!ub)\n\t\treturn -1;\n\n\tif (uwsgi_buffer_append(ub, \"HTTP/1.0 200 OK\\r\\n\", 17))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"Connection: close\\r\\n\", 19))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"Access-Control-Allow-Origin: *\\r\\n\", 32))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"Content-Type: application/json\\r\\n\", 32))\n\t\tgoto error;\n\tif (uwsgi_buffer_append(ub, \"\\r\\n\", 2))\n\t\tgoto error;\n\n\tif (uwsgi_buffer_send(ub, fd))\n\t\tgoto error;\n\tuwsgi_buffer_destroy(ub);\n\treturn 0;\n\nerror:\n\tuwsgi_buffer_destroy(ub);\n\treturn -1;\n}\n\nint uwsgi_call_symbol(char *symbol) {\n\tvoid (*func) (void) = dlsym(RTLD_DEFAULT, symbol);\n\tif (!func)\n\t\treturn -1;\n\tfunc();\n\treturn 0;\n}\n\nint uwsgi_plugin_modifier1(char *plugin) {\n\tint ret = -1;\n\tchar *symbol_name = uwsgi_concat2(plugin, \"_plugin\");\n\tstruct uwsgi_plugin *up = dlsym(RTLD_DEFAULT, symbol_name);\n\tif (!up)\n\t\tgoto end;\n\tret = up->modifier1;\nend:\n\tfree(symbol_name);\n\treturn ret;\n}\n\nchar *uwsgi_strip(char *src) {\n\tchar *dst = src;\n\tsize_t len = strlen(src);\n\tint i;\n\n\tfor (i = 0; i < (ssize_t) len; i++) {\n\t\tif (src[i] == ' ' || src[i] == '\\t') {\n\t\t\tdst++;\n\t\t}\n\t}\n\n\tlen -= (dst - src);\n\n\tfor (i = len; i >= 0; i--) {\n\t\tif (dst[i] == ' ' || dst[i] == '\\t') {\n\t\t\tdst[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn dst;\n}\n\nvoid uwsgi_uuid(char *buf) {\n#ifdef UWSGI_UUID\n\tuuid_t uuid_value;\n\tuuid_generate(uuid_value);\n\tuuid_unparse(uuid_value, buf);\n#else\n\tint i, r[11];\n\tif (!uwsgi_file_exists(\"/dev/urandom\"))\n\t\tgoto fallback;\n\tint fd = open(\"/dev/urandom\", O_RDONLY);\n\tif (fd < 0)\n\t\tgoto fallback;\n\tfor (i = 0; i < 11; i++) {\n\t\tif (read(fd, &r[i], 4) != 4) {\n\t\t\tclose(fd);\n\t\t\tgoto fallback;\n\t\t}\n\t}\n\tclose(fd);\n\tgoto done;\nfallback:\n\tfor (i = 0; i < 11; i++) {\n\t\tr[i] = rand();\n\t}\ndone:\n\tsnprintf(buf, 37, \"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\", r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10]);\n#endif\n}\n\nint uwsgi_uuid_cmp(char *x, char *y) {\n\tint i;\n\tfor (i = 0; i < 36; i++) {\n\t\tif (x[i] != y[i]) {\n\t\t\tif (x[i] > y[i]) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid uwsgi_additional_header_add(struct wsgi_request *wsgi_req, char *hh, uint16_t hh_len) {\n\t// will be freed on request's end\n\tchar *header = uwsgi_concat2n(hh, hh_len, \"\", 0);\n\tuwsgi_string_new_list(&wsgi_req->additional_headers, header);\n}\n\nvoid uwsgi_remove_header(struct wsgi_request *wsgi_req, char *hh, uint16_t hh_len) {\n\tchar *header = uwsgi_concat2n(hh, hh_len, \"\", 0);\n\tuwsgi_string_new_list(&wsgi_req->remove_headers, header);\n}\n\n// based on nginx implementation\n\nstatic uint8_t b64_table64[] = {\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 62, 77, 77, 77, 63,\n\t52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 77, 77, 77, 77, 77, 77,\n\t77, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n\t15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 77, 77, 77, 77, 77,\n\t77, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n\t41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 77, 77, 77, 77, 77,\n\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,\n\t77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77\n};\n\nstatic char b64_table64_2[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nchar *uwsgi_base64_decode(char *buf, size_t len, size_t * d_len) {\n\n\t// find the real size and check for invalid values\n\tsize_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (buf[i] == '=')\n\t\t\tbreak;\n\n\t\t// check for invalid content\n\t\tif (b64_table64[(uint8_t) buf[i]] == 77) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t// check for invalid size\n\tif (i % 4 == 1)\n\t\treturn NULL;\n\n\t// compute the new size\n\t*d_len = (((len + 3) / 4) * 3);\n\tchar *dst = uwsgi_malloc(*d_len + 1);\n\n\tchar *ptr = dst;\n\tuint8_t *src = (uint8_t *) buf;\n\twhile (i > 3) {\n\t\t*ptr++ = (char) (b64_table64[src[0]] << 2 | b64_table64[src[1]] >> 4);\n\t\t*ptr++ = (char) (b64_table64[src[1]] << 4 | b64_table64[src[2]] >> 2);\n\t\t*ptr++ = (char) (b64_table64[src[2]] << 6 | b64_table64[src[3]]);\n\n\t\tsrc += 4;\n\t\ti -= 4;\n\t}\n\n\tif (i > 1) {\n\t\t*ptr++ = (char) (b64_table64[src[0]] << 2 | b64_table64[src[1]] >> 4);\n\t}\n\n\tif (i > 2) {\n\t\t*ptr++ = (char) (b64_table64[src[1]] << 4 | b64_table64[src[2]] >> 2);\n\t}\n\n\t*d_len = (ptr - dst);\n\t*ptr++ = 0;\n\n\treturn dst;\n\n}\n\nchar *uwsgi_base64_encode(char *buf, size_t len, size_t * d_len) {\n\t*d_len = ((len * 4) / 3) + 5;\n\tuint8_t *src = (uint8_t *) buf;\n\tchar *dst = uwsgi_malloc(*d_len);\n\tchar *ptr = dst;\n\twhile (len >= 3) {\n\t\t*ptr++ = b64_table64_2[src[0] >> 2];\n\t\t*ptr++ = b64_table64_2[((src[0] << 4) & 0x30) | (src[1] >> 4)];\n\t\t*ptr++ = b64_table64_2[((src[1] << 2) & 0x3C) | (src[2] >> 6)];\n\t\t*ptr++ = b64_table64_2[src[2] & 0x3F];\n\t\tsrc += 3;\n\t\tlen -= 3;\n\t}\n\n\tif (len > 0) {\n\t\t*ptr++ = b64_table64_2[src[0] >> 2];\n\t\tuint8_t tmp = (src[0] << 4) & 0x30;\n\t\tif (len > 1)\n\t\t\ttmp |= src[1] >> 4;\n\t\t*ptr++ = b64_table64_2[tmp];\n\t\tif (len < 2) {\n\t\t\t*ptr++ = '=';\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = b64_table64_2[(src[1] << 2) & 0x3C];\n\t\t}\n\t\t*ptr++ = '=';\n\t}\n\n\t*ptr = 0;\n\t*d_len = ((char *) ptr - dst);\n\n\treturn dst;\n}\n\nuint16_t uwsgi_be16(char *buf) {\n\tuint16_t *src = (uint16_t *) buf;\n\tuint16_t ret = 0;\n\tuint8_t *ptr = (uint8_t *) & ret;\n\tptr[0] = (uint8_t) ((*src >> 8) & 0xff);\n\tptr[1] = (uint8_t) (*src & 0xff);\n\treturn ret;\n}\n\nuint32_t uwsgi_be32(char *buf) {\n\tuint32_t *src = (uint32_t *) buf;\n\tuint32_t ret = 0;\n\tuint8_t *ptr = (uint8_t *) & ret;\n\tptr[0] = (uint8_t) ((*src >> 24) & 0xff);\n\tptr[1] = (uint8_t) ((*src >> 16) & 0xff);\n\tptr[2] = (uint8_t) ((*src >> 8) & 0xff);\n\tptr[3] = (uint8_t) (*src & 0xff);\n\treturn ret;\n}\n\nuint64_t uwsgi_be64(char *buf) {\n\tuint64_t *src = (uint64_t *) buf;\n\tuint64_t ret = 0;\n\tuint8_t *ptr = (uint8_t *) & ret;\n\tptr[0] = (uint8_t) ((*src >> 56) & 0xff);\n\tptr[1] = (uint8_t) ((*src >> 48) & 0xff);\n\tptr[2] = (uint8_t) ((*src >> 40) & 0xff);\n\tptr[3] = (uint8_t) ((*src >> 32) & 0xff);\n\tptr[4] = (uint8_t) ((*src >> 24) & 0xff);\n\tptr[5] = (uint8_t) ((*src >> 16) & 0xff);\n\tptr[6] = (uint8_t) ((*src >> 8) & 0xff);\n\tptr[7] = (uint8_t) (*src & 0xff);\n\treturn ret;\n}\n\nchar *uwsgi_get_header(struct wsgi_request *wsgi_req, char *hh, uint16_t len, uint16_t * rlen) {\n\tchar *key = uwsgi_malloc(len + 6);\n\tuint16_t key_len = len;\n\tchar *ptr = key;\n\t*rlen = 0;\n\tif (uwsgi_strncmp(hh, len, \"Content-Length\", 14) && uwsgi_strncmp(hh, len, \"Content-Type\", 12)) {\n\t\tmemcpy(ptr, \"HTTP_\", 5);\n\t\tptr += 5;\n\t\tkey_len += 5;\n\t}\n\n\tuint16_t i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (hh[i] == '-') {\n\t\t\t*ptr++ = '_';\n\t\t}\n\t\telse {\n\t\t\t*ptr++ = toupper((int) hh[i]);\n\t\t}\n\t}\n\n\tchar *value = uwsgi_get_var(wsgi_req, key, key_len, rlen);\n\tfree(key);\n\treturn value;\n\n}\n\nstatic char *uwsgi_hex_table[] = {\n\t\"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"0A\", \"0B\", \"0C\", \"0D\", \"0E\", \"0F\",\n\t\"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"1A\", \"1B\", \"1C\", \"1D\", \"1E\", \"1F\",\n\t\"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"2A\", \"2B\", \"2C\", \"2D\", \"2E\", \"2F\",\n\t\"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3A\", \"3B\", \"3C\", \"3D\", \"3E\", \"3F\",\n\t\"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"4A\", \"4B\", \"4C\", \"4D\", \"4E\", \"4F\",\n\t\"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"5A\", \"5B\", \"5C\", \"5D\", \"5E\", \"5F\",\n\t\"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"6A\", \"6B\", \"6C\", \"6D\", \"6E\", \"6F\",\n\t\"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"7A\", \"7B\", \"7C\", \"7D\", \"7E\", \"7F\",\n\t\"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8A\", \"8B\", \"8C\", \"8D\", \"8E\", \"8F\",\n\t\"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"9A\", \"9B\", \"9C\", \"9D\", \"9E\", \"9F\",\n\t\"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\", \"A6\", \"A7\", \"A8\", \"A9\", \"AA\", \"AB\", \"AC\", \"AD\", \"AE\", \"AF\",\n\t\"B0\", \"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B8\", \"B9\", \"BA\", \"BB\", \"BC\", \"BD\", \"BE\", \"BF\",\n\t\"C0\", \"C1\", \"C2\", \"C3\", \"C4\", \"C5\", \"C6\", \"C7\", \"C8\", \"C9\", \"CA\", \"CB\", \"CC\", \"CD\", \"CE\", \"CF\",\n\t\"D0\", \"D1\", \"D2\", \"D3\", \"D4\", \"D5\", \"D6\", \"D7\", \"D8\", \"D9\", \"DA\", \"DB\", \"DC\", \"DD\", \"DE\", \"DF\",\n\t\"E0\", \"E1\", \"E2\", \"E3\", \"E4\", \"E5\", \"E6\", \"E7\", \"E8\", \"E9\", \"EA\", \"EB\", \"EC\", \"ED\", \"EE\", \"EF\",\n\t\"F0\", \"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"FA\", \"FB\", \"FC\", \"FD\", \"FE\", \"FF\",\n};\n\nchar *uwsgi_str_to_hex(char *src, size_t slen) {\n\tchar *dst = uwsgi_malloc(slen * 2);\n\tchar *ptr = dst;\n\tsize_t i;\n\tfor (i = 0; i < slen; i++) {\n\t\tuint8_t pos = (uint8_t) src[i];\n\t\tmemcpy(ptr, uwsgi_hex_table[pos], 2);\n\t\tptr += 2;\n\t}\n\treturn dst;\n}\n\n// dst has to be 3 times buf size (USE IT ONLY FOR PATH_INFO !!!)\nvoid http_url_encode(char *buf, uint16_t * len, char *dst) {\n\n\tuint16_t i;\n\tchar *ptr = dst;\n\tfor (i = 0; i < *len; i++) {\n\t\tif ((buf[i] >= 'A' && buf[i] <= 'Z') || (buf[i] >= 'a' && buf[i] <= 'z') || (buf[i] >= '0' && buf[i] <= '9') || buf[i] == '-' || buf[i] == '_' || buf[i] == '.' || buf[i] == '~' || buf[i] == '/') {\n\t\t\t*ptr++ = buf[i];\n\t\t}\n\t\telse {\n\t\t\tchar *h = uwsgi_hex_table[(int) buf[i]];\n\t\t\t*ptr++ = '%';\n\t\t\t*ptr++ = h[0];\n\t\t\t*ptr++ = h[1];\n\t\t}\n\t}\n\n\t*len = ptr - dst;\n\n}\n\nvoid uwsgi_takeover() {\n\tif (uwsgi.i_am_a_spooler) {\n\t\tuwsgi_spooler_run();\n\t}\n\telse if (uwsgi.muleid) {\n\t\tuwsgi_mule_run();\n\t}\n\telse {\n\t\tuwsgi_worker_run();\n\t}\n}\n\n// create a message pipe\nvoid create_msg_pipe(int *fd, int bufsize) {\n\n#if defined(SOCK_SEQPACKET) && defined(__linux__)\n\tif (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, fd)) {\n#else\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, fd)) {\n#endif\n\t\tuwsgi_error(\"create_msg_pipe()/socketpair()\");\n\t\texit(1);\n\t}\n\n\tuwsgi_socket_nb(fd[0]);\n\tuwsgi_socket_nb(fd[1]);\n\n\tif (bufsize) {\n\t\tif (setsockopt(fd[0], SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\t\tif (setsockopt(fd[0], SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\n\t\tif (setsockopt(fd[1], SOL_SOCKET, SO_SNDBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\t\tif (setsockopt(fd[1], SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(int))) {\n\t\t\tuwsgi_error(\"create_msg_pipe()/setsockopt()\");\n\t\t}\n\t}\n}\n\nchar *uwsgi_binary_path() {\n\treturn uwsgi.binary_path ? uwsgi.binary_path : \"uwsgi\";\n}\n\nvoid uwsgi_envdir(char *edir) {\n\tDIR *d = opendir(edir);\n\tif (!d) {\n\t\tuwsgi_error(\"[uwsgi-envdir] opendir()\");\n\t\texit(1);\n\t}\n\tstruct dirent *de;\n\twhile ((de = readdir(d)) != NULL) {\n\t\t// skip hidden files\n\t\tif (de->d_name[0] == '.')\n\t\t\tcontinue;\n\t\tstruct stat st;\n\t\tchar *filename = uwsgi_concat3(edir, \"/\", de->d_name);\n\t\tif (stat(filename, &st)) {\n\t\t\tuwsgi_log(\"[uwsgi-envdir] error stating %s\\n\", filename);\n\t\t\tuwsgi_error(\"[uwsgi-envdir] stat()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!S_ISREG(st.st_mode)) {\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// unsetenv\n\t\tif (st.st_size == 0) {\n#ifdef UNSETENV_VOID\n\t\t\tunsetenv(de->d_name);\n#else\n\t\t\tif (unsetenv(de->d_name)) {\n\t\t\t\tuwsgi_log(\"[uwsgi-envdir] unable to unset %s\\n\", de->d_name);\n\t\t\t\tuwsgi_error(\"[uwsgi-envdir] unsetenv\");\n\t\t\t\texit(1);\n\t\t\t}\n#endif\n\t\t\tfree(filename);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// read the content of the file\n\t\tsize_t size = 0;\n\t\tchar *content = uwsgi_open_and_read(filename, &size, 1, NULL);\n\t\tif (!content) {\n\t\t\tuwsgi_log(\"[uwsgi-envdir] unable to open %s\\n\", filename);\n\t\t\tuwsgi_error_open(filename);\n\t\t\texit(1);\n\t\t}\n\t\tfree(filename);\n\n\t\t// HACK, envdir states we only need to strip the end of the string ....\n\t\tuwsgi_chomp2(content);\n\t\t// ... and substitute 0 with \\n\n\t\tsize_t slen = strlen(content);\n\t\tsize_t i;\n\t\tfor (i = 0; i < slen; i++) {\n\t\t\tif (content[i] == 0) {\n\t\t\t\tcontent[i] = '\\n';\n\t\t\t}\n\t\t}\n\n\t\tif (setenv(de->d_name, content, 1)) {\n\t\t\tuwsgi_log(\"[uwsgi-envdir] unable to set %s\\n\", de->d_name);\n\t\t\tuwsgi_error(\"[uwsgi-envdir] setenv\");\n\t\t\texit(1);\n\t\t}\n\n\t\tfree(content);\n\t}\n\tclosedir(d);\n}\n\nvoid uwsgi_envdirs(struct uwsgi_string_list *envdirs) {\n\tstruct uwsgi_string_list *usl = envdirs;\n\twhile (usl) {\n\t\tuwsgi_envdir(usl->value);\n\t\tusl = usl->next;\n\t}\n}\n\nvoid uwsgi_opt_envdir(char *opt, char *value, void *foobar) {\n\tuwsgi_envdir(value);\n}\n\nvoid uwsgi_exit(int status) {\n\tuwsgi.last_exit_code = status;\n\t// disable macro expansion\n\t(exit) (status);\n}\n\nint uwsgi_base128(struct uwsgi_buffer *ub, uint64_t l, int first) {\n\tif (l > 127) {\n\t\tif (uwsgi_base128(ub, l / 128, 0))\n\t\t\treturn -1;\n\t}\n\tl %= 128;\n\tif (first) {\n\t\tif (uwsgi_buffer_u8(ub, (uint8_t) l))\n\t\t\treturn -1;\n\t}\n\telse {\n\t\tif (uwsgi_buffer_u8(ub, 0x80 | (uint8_t) l))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n#ifdef __linux__\nvoid uwsgi_setns(char *path) {\n\tint (*u_setns) (int, int) = (int (*)(int, int)) dlsym(RTLD_DEFAULT, \"setns\");\n\tif (!u_setns) {\n\t\tuwsgi_log(\"your system misses setns() syscall !!!\\n\");\n\t\texit(1);\n\t}\n\n\t// cound be overwritten\n\tint count = 64;\n\n\tuwsgi_log(\"joining namespaces from %s ...\\n\", path);\n\tfor (;;) {\n\t\tint ns_fd = uwsgi_connect(path, 30, 0);\n\t\tif (ns_fd < 0) {\n\t\t\tuwsgi_error(\"uwsgi_setns()/uwsgi_connect()\");\n\t\t\tsleep(1);\n\t\t\tcontinue;\n\t\t}\n\t\tint *fds = uwsgi_attach_fd(ns_fd, &count, \"uwsgi-setns\", 11);\n\t\tif (fds && count > 0) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (fds[i] > -1) {\n\t\t\t\t\tif (u_setns(fds[i], 0) < 0) {\n\t\t\t\t\t\tuwsgi_error(\"uwsgi_setns()/setns()\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tclose(fds[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(fds);\n\t\t\tclose(ns_fd);\n\t\t\tbreak;\n\t\t}\n\t\tif (fds)\n\t\t\tfree(fds);\n\t\tclose(ns_fd);\n\t\tsleep(1);\n\t}\n}\n#endif\n\nmode_t uwsgi_mode_t(char *value, int *error) {\n\tmode_t mode = 0;\n\t*error = 0;\n\n        if (strlen(value) < 3) {\n\t\t*error = 1;\n\t\treturn mode;\n\t}\n\n        if (strlen(value) == 3) {\n                mode = (mode << 3) + (value[0] - '0');\n                mode = (mode << 3) + (value[1] - '0');\n                mode = (mode << 3) + (value[2] - '0');\n        }\n        else {\n                mode = (mode << 3) + (value[1] - '0');\n                mode = (mode << 3) + (value[2] - '0');\n                mode = (mode << 3) + (value[3] - '0');\n        }\n\n\treturn mode;\n}\n\n\nint uwsgi_wait_for_mountpoint(char *mountpoint) {\n        if (!uwsgi.wait_for_fs_timeout) {\n                uwsgi.wait_for_fs_timeout = 60;\n        }\n        uwsgi_log(\"waiting for %s (max %d seconds) ...\\n\", mountpoint, uwsgi.wait_for_fs_timeout);\n        int counter = 0;\n        for (;;) {\n                if (counter > uwsgi.wait_for_fs_timeout) {\n                        uwsgi_log(\"%s unavailable after %d seconds\\n\", mountpoint, counter);\n                        return -1;\n                }\n                struct stat st0;\n                struct stat st1;\n                if (stat(mountpoint, &st0)) goto retry;\n                if (!S_ISDIR(st0.st_mode)) goto retry;\n                char *relative = uwsgi_concat2(mountpoint, \"/../\");\n                if (stat(relative, &st1)) {\n                        free(relative);\n                        goto retry;\n                }\n                free(relative);\n                // useless :P\n                if (!S_ISDIR(st1.st_mode)) goto retry;\n                if (st0.st_dev == st1.st_dev) goto retry;\n                uwsgi_log_verbose(\"%s mounted\\n\", mountpoint);\n                return 0;\nretry:\n                sleep(1);\n                counter++;\n        }\n\treturn -1;\n}\n\n// type -> 1 file, 2 dir, 0 both\nint uwsgi_wait_for_fs(char *filename, int type) {\n        if (!uwsgi.wait_for_fs_timeout) {\n                uwsgi.wait_for_fs_timeout = 60;\n        }\n        uwsgi_log(\"waiting for %s (max %d seconds) ...\\n\", filename, uwsgi.wait_for_fs_timeout);\n        int counter = 0;\n        for (;;) {\n                if (counter > uwsgi.wait_for_fs_timeout) {\n                        uwsgi_log(\"%s unavailable after %d seconds\\n\", filename, counter);\n                        return -1;\n                }\n                struct stat st;\n                if (stat(filename, &st)) goto retry;\n                if (type == 1 && !S_ISREG(st.st_mode)) goto retry;\n                if (type == 2 && !S_ISDIR(st.st_mode)) goto retry;\n                uwsgi_log_verbose(\"%s found\\n\", filename);\n                return 0;\nretry:\n                sleep(1);\n                counter++;\n        }\n\treturn -1;\n}\n\nint uwsgi_wait_for_socket(char *socket_name) {\n        if (!uwsgi.wait_for_socket_timeout) {\n                uwsgi.wait_for_socket_timeout = 60;\n        }\n        uwsgi_log(\"waiting for %s (max %d seconds) ...\\n\", socket_name, uwsgi.wait_for_socket_timeout);\n        int counter = 0;\n        for (;;) {\n                if (counter > uwsgi.wait_for_socket_timeout) {\n                        uwsgi_log(\"%s unavailable after %d seconds\\n\", socket_name, counter);\n                        return -1;\n                }\n\t\t// wait for 1 second to respect uwsgi.wait_for_fs_timeout\n\t\tint fd = uwsgi_connect(socket_name, 1, 0);\n\t\tif (fd < 0) goto retry;\n\t\tclose(fd);\n                uwsgi_log_verbose(\"%s ready\\n\", socket_name);\n                return 0;\nretry:\n                sleep(1);\n                counter++;\n        }\n\treturn -1;\n}\n\nvoid uwsgi_fix_range_for_size(enum uwsgi_range* parsed, int64_t* from, int64_t* to, int64_t size) {\n        if (*parsed != UWSGI_RANGE_PARSED) {\n                return;\n        }\n        if (*from < 0) {\n                *from = size + *from;\n        }\n        if (*to > size-1) {\n                *to = size-1;\n        }\n        if (*from == 0 && *to == size-1) {\n                /* we have a right to reset to 200 OK answer */\n                *parsed = UWSGI_RANGE_NOT_PARSED;\n        }\n        else if (*to >= *from) {\n                *parsed = UWSGI_RANGE_VALID;\n        }\n        else { /* case *from > size-1 is also handled here */\n                *parsed = UWSGI_RANGE_INVALID;\n                *from = 0;\n                *to = 0;\n        }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/core/uwsgi.c": "/*\n\n *** uWSGI ***\n\n Copyright (C) 2009-2017 Unbit S.a.s. <info@unbit.it>\n\n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\n*/\n\n\n#include <uwsgi.h>\n\nstruct uwsgi_server uwsgi;\npid_t masterpid;\n\n#if defined(__APPLE__) && defined(UWSGI_AS_SHARED_LIBRARY)\n#include <crt_externs.h>\n#define UWSGI_ENVIRON (*_NSGetEnviron())\n#else\nextern char **environ;\n#define UWSGI_ENVIRON environ\n#endif\n\nUWSGI_DECLARE_EMBEDDED_PLUGINS;\n\nstatic struct uwsgi_option uwsgi_base_options[] = {\n\t{\"socket\", required_argument, 's', \"bind to the specified UNIX/TCP socket using default protocol\", uwsgi_opt_add_socket, NULL, 0},\n\t{\"uwsgi-socket\", required_argument, 's', \"bind to the specified UNIX/TCP socket using uwsgi protocol\", uwsgi_opt_add_socket, \"uwsgi\", 0},\n#ifdef UWSGI_SSL\n\t{\"suwsgi-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using uwsgi protocol over SSL\", uwsgi_opt_add_ssl_socket, \"suwsgi\", 0},\n\t{\"ssl-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using uwsgi protocol over SSL\", uwsgi_opt_add_ssl_socket, \"suwsgi\", 0},\n#endif\n\n\t{\"http-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using HTTP protocol\", uwsgi_opt_add_socket, \"http\", 0},\n\t{\"http-socket-modifier1\", required_argument, 0, \"force the specified modifier1 when using HTTP protocol\", uwsgi_opt_set_64bit, &uwsgi.http_modifier1, 0},\n\t{\"http-socket-modifier2\", required_argument, 0, \"force the specified modifier2 when using HTTP protocol\", uwsgi_opt_set_64bit, &uwsgi.http_modifier2, 0},\n\n\t{\"http11-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using HTTP 1.1 (Keep-Alive) protocol\", uwsgi_opt_add_socket, \"http11\", 0},\n\n#ifdef UWSGI_SSL\n\t{\"https-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using HTTPS protocol\", uwsgi_opt_add_ssl_socket, \"https\", 0},\n\t{\"https-socket-modifier1\", required_argument, 0, \"force the specified modifier1 when using HTTPS protocol\", uwsgi_opt_set_64bit, &uwsgi.https_modifier1, 0},\n\t{\"https-socket-modifier2\", required_argument, 0, \"force the specified modifier2 when using HTTPS protocol\", uwsgi_opt_set_64bit, &uwsgi.https_modifier2, 0},\n#endif\n\n\t{\"fastcgi-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using FastCGI protocol\", uwsgi_opt_add_socket, \"fastcgi\", 0},\n\t{\"fastcgi-nph-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using FastCGI protocol (nph mode)\", uwsgi_opt_add_socket, \"fastcgi-nph\", 0},\n\t{\"fastcgi-modifier1\", required_argument, 0, \"force the specified modifier1 when using FastCGI protocol\", uwsgi_opt_set_64bit, &uwsgi.fastcgi_modifier1, 0},\n\t{\"fastcgi-modifier2\", required_argument, 0, \"force the specified modifier2 when using FastCGI protocol\", uwsgi_opt_set_64bit, &uwsgi.fastcgi_modifier2, 0},\n\n\t{\"scgi-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using SCGI protocol\", uwsgi_opt_add_socket, \"scgi\", 0},\n\t{\"scgi-nph-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using SCGI protocol (nph mode)\", uwsgi_opt_add_socket, \"scgi-nph\", 0},\n\t{\"scgi-modifier1\", required_argument, 0, \"force the specified modifier1 when using SCGI protocol\", uwsgi_opt_set_64bit, &uwsgi.scgi_modifier1, 0},\n\t{\"scgi-modifier2\", required_argument, 0, \"force the specified modifier2 when using SCGI protocol\", uwsgi_opt_set_64bit, &uwsgi.scgi_modifier2, 0},\n\n\t{\"raw-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using RAW protocol\", uwsgi_opt_add_socket_no_defer, \"raw\", 0},\n\t{\"raw-modifier1\", required_argument, 0, \"force the specified modifier1 when using RAW protocol\", uwsgi_opt_set_64bit, &uwsgi.raw_modifier1, 0},\n\t{\"raw-modifier2\", required_argument, 0, \"force the specified modifier2 when using RAW protocol\", uwsgi_opt_set_64bit, &uwsgi.raw_modifier2, 0},\n\n\t{\"puwsgi-socket\", required_argument, 0, \"bind to the specified UNIX/TCP socket using persistent uwsgi protocol (puwsgi)\", uwsgi_opt_add_socket, \"puwsgi\", 0},\n\n\t{\"protocol\", required_argument, 0, \"force the specified protocol for default sockets\", uwsgi_opt_set_str, &uwsgi.protocol, 0},\n\t{\"socket-protocol\", required_argument, 0, \"force the specified protocol for default sockets\", uwsgi_opt_set_str, &uwsgi.protocol, 0},\n\t{\"shared-socket\", required_argument, 0, \"create a shared socket for advanced jailing or ipc\", uwsgi_opt_add_shared_socket, NULL, 0},\n\t{\"undeferred-shared-socket\", required_argument, 0, \"create a shared socket for advanced jailing or ipc (undeferred mode)\", uwsgi_opt_add_shared_socket, NULL, 0},\n\t{\"processes\", required_argument, 'p', \"spawn the specified number of workers/processes\", uwsgi_opt_set_int, &uwsgi.numproc, 0},\n\t{\"workers\", required_argument, 'p', \"spawn the specified number of workers/processes\", uwsgi_opt_set_int, &uwsgi.numproc, 0},\n\t{\"thunder-lock\", no_argument, 0, \"serialize accept() usage (if possible)\", uwsgi_opt_true, &uwsgi.use_thunder_lock, 0},\n\t{\"harakiri\", required_argument, 't', \"set harakiri timeout\", uwsgi_opt_set_int, &uwsgi.harakiri_options.workers, 0},\n\t{\"harakiri-verbose\", no_argument, 0, \"enable verbose mode for harakiri\", uwsgi_opt_true, &uwsgi.harakiri_verbose, 0},\n\t{\"harakiri-no-arh\", no_argument, 0, \"do not enable harakiri during after-request-hook\", uwsgi_opt_true, &uwsgi.harakiri_no_arh, 0},\n\t{\"no-harakiri-arh\", no_argument, 0, \"do not enable harakiri during after-request-hook\", uwsgi_opt_true, &uwsgi.harakiri_no_arh, 0},\n\t{\"no-harakiri-after-req-hook\", no_argument, 0, \"do not enable harakiri during after-request-hook\", uwsgi_opt_true, &uwsgi.harakiri_no_arh, 0},\n\t{\"backtrace-depth\", required_argument, 0, \"set backtrace depth\", uwsgi_opt_set_int, &uwsgi.backtrace_depth, 0},\n\t{\"mule-harakiri\", required_argument, 0, \"set harakiri timeout for mule tasks\", uwsgi_opt_set_int, &uwsgi.harakiri_options.mules, 0},\n#ifdef UWSGI_XML\n\t{\"xmlconfig\", required_argument, 'x', \"load config from xml file\", uwsgi_opt_load_xml, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"xml\", required_argument, 'x', \"load config from xml file\", uwsgi_opt_load_xml, NULL, UWSGI_OPT_IMMEDIATE},\n#endif\n\t{\"config\", required_argument, 0, \"load configuration using the pluggable system\", uwsgi_opt_load_config, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"fallback-config\", required_argument, 0, \"re-exec uwsgi with the specified config when exit code is 1\", uwsgi_opt_set_str, &uwsgi.fallback_config, UWSGI_OPT_IMMEDIATE},\n\t{\"strict\", no_argument, 0, \"enable strict mode (placeholder cannot be used)\", uwsgi_opt_true, &uwsgi.strict, UWSGI_OPT_IMMEDIATE},\n\n\t{\"skip-zero\", no_argument, 0, \"skip check of file descriptor 0\", uwsgi_opt_true, &uwsgi.skip_zero, 0},\n\t{\"skip-atexit\", no_argument, 0, \"skip atexit hooks (ignored by the master)\", uwsgi_opt_true, &uwsgi.skip_atexit, 0},\n\t{\"skip-atexit-teardown\", no_argument, 0, \"skip atexit teardown (ignored by the master)\", uwsgi_opt_true, &uwsgi.skip_atexit_teardown, 0},\n\n\t{\"set\", required_argument, 'S', \"set a placeholder or an option\", uwsgi_opt_set_placeholder, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"set-placeholder\", required_argument, 0, \"set a placeholder\", uwsgi_opt_set_placeholder, (void *) 1, UWSGI_OPT_IMMEDIATE},\n\t{\"set-ph\", required_argument, 0, \"set a placeholder\", uwsgi_opt_set_placeholder, (void *) 1, UWSGI_OPT_IMMEDIATE},\n\t{\"get\", required_argument, 0, \"print the specified option value and exit\", uwsgi_opt_add_string_list, &uwsgi.get_list, UWSGI_OPT_NO_INITIAL},\n\t{\"declare-option\", required_argument, 0, \"declare a new uWSGI custom option\", uwsgi_opt_add_custom_option, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"declare-option2\", required_argument, 0, \"declare a new uWSGI custom option (non-immediate)\", uwsgi_opt_add_custom_option, NULL, 0},\n\n\t{\"resolve\", required_argument, 0, \"place the result of a dns query in the specified placeholder, sytax: placeholder=name (immediate option)\", uwsgi_opt_resolve, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"for\", required_argument, 0, \"(opt logic) for cycle\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_for, UWSGI_OPT_IMMEDIATE},\n\t{\"for-glob\", required_argument, 0, \"(opt logic) for cycle (expand glob)\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_for_glob, UWSGI_OPT_IMMEDIATE},\n\t{\"for-times\", required_argument, 0, \"(opt logic) for cycle (expand the specified num to a list starting from 1)\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_for_times, UWSGI_OPT_IMMEDIATE},\n\t{\"for-readline\", required_argument, 0, \"(opt logic) for cycle (expand the specified file to a list of lines)\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_for_readline, UWSGI_OPT_IMMEDIATE},\n\t{\"endfor\", optional_argument, 0, \"(opt logic) end for cycle\", uwsgi_opt_noop, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"end-for\", optional_argument, 0, \"(opt logic) end for cycle\", uwsgi_opt_noop, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-opt\", required_argument, 0, \"(opt logic) check for option\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_opt, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-opt\", required_argument, 0, \"(opt logic) check for option\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_opt, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-env\", required_argument, 0, \"(opt logic) check for environment variable\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_env, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-env\", required_argument, 0, \"(opt logic) check for environment variable\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_env, UWSGI_OPT_IMMEDIATE},\n\t{\"ifenv\", required_argument, 0, \"(opt logic) check for environment variable\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_env, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-reload\", no_argument, 0, \"(opt logic) check for reload\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_reload, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-reload\", no_argument, 0, \"(opt logic) check for reload\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_reload, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-hostname\", required_argument, 0, \"(opt logic) check for hostname\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_hostname, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-hostname\", required_argument, 0, \"(opt logic) check for hostname\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_hostname, UWSGI_OPT_IMMEDIATE},\n\n#ifdef UWSGI_PCRE\n\t{\"if-hostname-match\", required_argument, 0, \"(opt logic) try to match hostname against a regular expression\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_hostname_match, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-hostname-match\", required_argument, 0, \"(opt logic) try to match hostname against a regular expression\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_hostname_match, UWSGI_OPT_IMMEDIATE},\n#endif\n\n\t{\"if-exists\", required_argument, 0, \"(opt logic) check for file/directory existence\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_exists, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-exists\", required_argument, 0, \"(opt logic) check for file/directory existence\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_exists, UWSGI_OPT_IMMEDIATE},\n\t{\"ifexists\", required_argument, 0, \"(opt logic) check for file/directory existence\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_exists, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-plugin\", required_argument, 0, \"(opt logic) check for plugin\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_plugin, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-plugin\", required_argument, 0, \"(opt logic) check for plugin\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_plugin, UWSGI_OPT_IMMEDIATE},\n\t{\"ifplugin\", required_argument, 0, \"(opt logic) check for plugin\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_plugin, UWSGI_OPT_IMMEDIATE},\n\n\t{\"if-file\", required_argument, 0, \"(opt logic) check for file existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_file, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-file\", required_argument, 0, \"(opt logic) check for file existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_file, UWSGI_OPT_IMMEDIATE},\n\t{\"if-dir\", required_argument, 0, \"(opt logic) check for directory existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_dir, UWSGI_OPT_IMMEDIATE},\n\t{\"if-not-dir\", required_argument, 0, \"(opt logic) check for directory existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_dir, UWSGI_OPT_IMMEDIATE},\n\n\t{\"ifdir\", required_argument, 0, \"(opt logic) check for directory existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_dir, UWSGI_OPT_IMMEDIATE},\n\t{\"if-directory\", required_argument, 0, \"(opt logic) check for directory existance\", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_dir, UWSGI_OPT_IMMEDIATE},\n\n\t{\"endif\", optional_argument, 0, \"(opt logic) end if\", uwsgi_opt_noop, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"end-if\", optional_argument, 0, \"(opt logic) end if\", uwsgi_opt_noop, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"blacklist\", required_argument, 0, \"set options blacklist context\", uwsgi_opt_set_str, &uwsgi.blacklist_context, UWSGI_OPT_IMMEDIATE},\n\t{\"end-blacklist\", no_argument, 0, \"clear options blacklist context\", uwsgi_opt_set_null, &uwsgi.blacklist_context, UWSGI_OPT_IMMEDIATE},\n\n\t{\"whitelist\", required_argument, 0, \"set options whitelist context\", uwsgi_opt_set_str, &uwsgi.whitelist_context, UWSGI_OPT_IMMEDIATE},\n\t{\"end-whitelist\", no_argument, 0, \"clear options whitelist context\", uwsgi_opt_set_null, &uwsgi.whitelist_context, UWSGI_OPT_IMMEDIATE},\n\n\t{\"ignore-sigpipe\", no_argument, 0, \"do not report (annoying) SIGPIPE\", uwsgi_opt_true, &uwsgi.ignore_sigpipe, 0},\n\t{\"ignore-write-errors\", no_argument, 0, \"do not report (annoying) write()/writev() errors\", uwsgi_opt_true, &uwsgi.ignore_write_errors, 0},\n\t{\"write-errors-tolerance\", required_argument, 0, \"set the maximum number of allowed write errors (default: no tolerance)\", uwsgi_opt_set_64bit, &uwsgi.write_errors_tolerance, 0},\n\t{\"write-errors-exception-only\", no_argument, 0, \"only raise an exception on write errors giving control to the app itself\", uwsgi_opt_true, &uwsgi.write_errors_exception_only, 0},\n\t{\"disable-write-exception\", no_argument, 0, \"disable exception generation on write()/writev()\", uwsgi_opt_true, &uwsgi.disable_write_exception, 0},\n\n\t{\"inherit\", required_argument, 0, \"use the specified file as config template\", uwsgi_opt_load, NULL, 0},\n\t{\"include\", required_argument, 0, \"include the specified file as immediate configuration\", uwsgi_opt_load, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"inject-before\", required_argument, 0, \"inject a text file before the config file (advanced templating)\", uwsgi_opt_add_string_list, &uwsgi.inject_before, UWSGI_OPT_IMMEDIATE},\n\t{\"inject-after\", required_argument, 0, \"inject a text file after the config file (advanced templating)\", uwsgi_opt_add_string_list, &uwsgi.inject_after, UWSGI_OPT_IMMEDIATE},\n\t{\"daemonize\", required_argument, 'd', \"daemonize uWSGI\", uwsgi_opt_set_str, &uwsgi.daemonize, 0},\n\t{\"daemonize2\", required_argument, 0, \"daemonize uWSGI after app loading\", uwsgi_opt_set_str, &uwsgi.daemonize2, 0},\n\t{\"stop\", required_argument, 0, \"stop an instance\", uwsgi_opt_pidfile_signal, (void *) SIGINT, UWSGI_OPT_IMMEDIATE},\n\t{\"reload\", required_argument, 0, \"reload an instance\", uwsgi_opt_pidfile_signal, (void *) SIGHUP, UWSGI_OPT_IMMEDIATE},\n\t{\"pause\", required_argument, 0, \"pause an instance\", uwsgi_opt_pidfile_signal, (void *) SIGTSTP, UWSGI_OPT_IMMEDIATE},\n\t{\"suspend\", required_argument, 0, \"suspend an instance\", uwsgi_opt_pidfile_signal, (void *) SIGTSTP, UWSGI_OPT_IMMEDIATE},\n\t{\"resume\", required_argument, 0, \"resume an instance\", uwsgi_opt_pidfile_signal, (void *) SIGTSTP, UWSGI_OPT_IMMEDIATE},\n\n\t{\"connect-and-read\", required_argument, 0, \"connect to a socket and wait for data from it\", uwsgi_opt_connect_and_read, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"extract\", required_argument, 0, \"fetch/dump any supported address to stdout\", uwsgi_opt_extract, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"listen\", required_argument, 'l', \"set the socket listen queue size\", uwsgi_opt_set_int, &uwsgi.listen_queue, UWSGI_OPT_IMMEDIATE},\n\t{\"max-vars\", required_argument, 'v', \"set the amount of internal iovec/vars structures\", uwsgi_opt_max_vars, NULL, 0},\n\t{\"max-apps\", required_argument, 0, \"set the maximum number of per-worker applications\", uwsgi_opt_set_int, &uwsgi.max_apps, 0},\n\t{\"buffer-size\", required_argument, 'b', \"set internal buffer size\", uwsgi_opt_set_16bit, &uwsgi.buffer_size, 0},\n\t{\"memory-report\", no_argument, 'm', \"enable memory report\", uwsgi_opt_true, &uwsgi.logging_options.memory_report, 0},\n\t{\"profiler\", required_argument, 0, \"enable the specified profiler\", uwsgi_opt_set_str, &uwsgi.profiler, 0},\n\t{\"cgi-mode\", no_argument, 'c', \"force CGI-mode for plugins supporting it\", uwsgi_opt_true, &uwsgi.cgi_mode, 0},\n\t{\"abstract-socket\", no_argument, 'a', \"force UNIX socket in abstract mode (Linux only)\", uwsgi_opt_true, &uwsgi.abstract_socket, 0},\n\t{\"chmod-socket\", optional_argument, 'C', \"chmod-socket\", uwsgi_opt_chmod_socket, NULL, 0},\n\t{\"chmod\", optional_argument, 'C', \"chmod-socket\", uwsgi_opt_chmod_socket, NULL, 0},\n\t{\"chown-socket\", required_argument, 0, \"chown unix sockets\", uwsgi_opt_set_str, &uwsgi.chown_socket, 0},\n\t{\"umask\", required_argument, 0, \"set umask\", uwsgi_opt_set_umask, NULL, UWSGI_OPT_IMMEDIATE},\n#ifdef __linux__\n\t{\"freebind\", no_argument, 0, \"put socket in freebind mode\", uwsgi_opt_true, &uwsgi.freebind, 0},\n#endif\n\t{\"map-socket\", required_argument, 0, \"map sockets to specific workers\", uwsgi_opt_add_string_list, &uwsgi.map_socket, 0},\n\t{\"enable-threads\", no_argument, 'T', \"enable threads\", uwsgi_opt_true, &uwsgi.has_threads, 0},\n\t{\"no-threads-wait\", no_argument, 0, \"do not wait for threads cancellation on quit/reload\", uwsgi_opt_true, &uwsgi.no_threads_wait, 0},\n\n\t{\"auto-procname\", no_argument, 0, \"automatically set processes name to something meaningful\", uwsgi_opt_true, &uwsgi.auto_procname, 0},\n\t{\"procname-prefix\", required_argument, 0, \"add a prefix to the process names\", uwsgi_opt_set_str, &uwsgi.procname_prefix, UWSGI_OPT_PROCNAME},\n\t{\"procname-prefix-spaced\", required_argument, 0, \"add a spaced prefix to the process names\", uwsgi_opt_set_str_spaced, &uwsgi.procname_prefix, UWSGI_OPT_PROCNAME},\n\t{\"procname-append\", required_argument, 0, \"append a string to process names\", uwsgi_opt_set_str, &uwsgi.procname_append, UWSGI_OPT_PROCNAME},\n\t{\"procname\", required_argument, 0, \"set process names\", uwsgi_opt_set_str, &uwsgi.procname, UWSGI_OPT_PROCNAME},\n\t{\"procname-master\", required_argument, 0, \"set master process name\", uwsgi_opt_set_str, &uwsgi.procname_master, UWSGI_OPT_PROCNAME},\n\n\t{\"single-interpreter\", no_argument, 'i', \"do not use multiple interpreters (where available)\", uwsgi_opt_true, &uwsgi.single_interpreter, 0},\n\t{\"need-app\", no_argument, 0, \"exit if no app can be loaded\", uwsgi_opt_true, &uwsgi.need_app, 0},\n\t{\"master\", no_argument, 'M', \"enable master process\", uwsgi_opt_true, &uwsgi.master_process, 0},\n\t{\"honour-stdin\", no_argument, 0, \"do not remap stdin to /dev/null\", uwsgi_opt_true, &uwsgi.honour_stdin, 0},\n\t{\"emperor\", required_argument, 0, \"run the Emperor\", uwsgi_opt_add_string_list, &uwsgi.emperor, 0},\n\t{\"emperor-proxy-socket\", required_argument, 0, \"force the vassal to became an Emperor proxy\", uwsgi_opt_set_str, &uwsgi.emperor_proxy, 0},\n\t{\"emperor-wrapper\", required_argument, 0, \"set a binary wrapper for vassals\", uwsgi_opt_set_str, &uwsgi.emperor_wrapper, 0},\n\t{\"emperor-wrapper-override\", required_argument, 0, \"set a binary wrapper for vassals to try before the default one\", uwsgi_opt_add_string_list, &uwsgi.emperor_wrapper_override, 0},\n\t{\"emperor-wrapper-fallback\", required_argument, 0, \"set a binary wrapper for vassals to try as a last resort\", uwsgi_opt_add_string_list, &uwsgi.emperor_wrapper_fallback, 0},\n\t{\"emperor-nofollow\", no_argument, 0, \"do not follow symlinks when checking for mtime\", uwsgi_opt_true, &uwsgi.emperor_nofollow, 0},\n\t{\"emperor-procname\", required_argument, 0, \"set the Emperor process name\", uwsgi_opt_set_str, &uwsgi.emperor_procname, 0},\n\t{\"emperor-freq\", required_argument, 0, \"set the Emperor scan frequency (default 3 seconds)\", uwsgi_opt_set_int, &uwsgi.emperor_freq, 0},\n\t{\"emperor-required-heartbeat\", required_argument, 0, \"set the Emperor tolerance about heartbeats\", uwsgi_opt_set_int, &uwsgi.emperor_heartbeat, 0},\n\t{\"emperor-curse-tolerance\", required_argument, 0, \"set the Emperor tolerance about cursed vassals\", uwsgi_opt_set_int, &uwsgi.emperor_curse_tolerance, 0},\n\t{\"emperor-pidfile\", required_argument, 0, \"write the Emperor pid in the specified file\", uwsgi_opt_set_str, &uwsgi.emperor_pidfile, 0},\n\t{\"emperor-tyrant\", no_argument, 0, \"put the Emperor in Tyrant mode\", uwsgi_opt_true, &uwsgi.emperor_tyrant, 0},\n\t{\"emperor-tyrant-nofollow\", no_argument, 0, \"do not follow symlinks when checking for uid/gid in Tyrant mode\", uwsgi_opt_true, &uwsgi.emperor_tyrant_nofollow, 0},\n\t{\"emperor-stats\", required_argument, 0, \"run the Emperor stats server\", uwsgi_opt_set_str, &uwsgi.emperor_stats, 0},\n\t{\"emperor-stats-server\", required_argument, 0, \"run the Emperor stats server\", uwsgi_opt_set_str, &uwsgi.emperor_stats, 0},\n\t{\"early-emperor\", no_argument, 0, \"spawn the emperor as soon as possibile\", uwsgi_opt_true, &uwsgi.early_emperor, 0},\n\t{\"emperor-broodlord\", required_argument, 0, \"run the emperor in BroodLord mode\", uwsgi_opt_set_int, &uwsgi.emperor_broodlord, 0},\n\t{\"emperor-throttle\", required_argument, 0, \"set throttling level (in milliseconds) for bad behaving vassals (default 1000)\", uwsgi_opt_set_int, &uwsgi.emperor_throttle, 0},\n\t{\"emperor-max-throttle\", required_argument, 0, \"set max throttling level (in milliseconds) for bad behaving vassals (default 3 minutes)\", uwsgi_opt_set_int, &uwsgi.emperor_max_throttle, 0},\n\t{\"emperor-magic-exec\", no_argument, 0, \"prefix vassals config files with exec:// if they have the executable bit\", uwsgi_opt_true, &uwsgi.emperor_magic_exec, 0},\n\t{\"emperor-on-demand-extension\", required_argument, 0, \"search for text file (vassal name + extension) containing the on demand socket name\", uwsgi_opt_set_str, &uwsgi.emperor_on_demand_extension, 0},\n\t{\"emperor-on-demand-ext\", required_argument, 0, \"search for text file (vassal name + extension) containing the on demand socket name\", uwsgi_opt_set_str, &uwsgi.emperor_on_demand_extension, 0},\n\t{\"emperor-on-demand-directory\", required_argument, 0, \"enable on demand mode binding to the unix socket in the specified directory named like the vassal + .socket\", uwsgi_opt_set_str, &uwsgi.emperor_on_demand_directory, 0},\n\t{\"emperor-on-demand-dir\", required_argument, 0, \"enable on demand mode binding to the unix socket in the specified directory named like the vassal + .socket\", uwsgi_opt_set_str, &uwsgi.emperor_on_demand_directory, 0},\n\t{\"emperor-on-demand-exec\", required_argument, 0, \"use the output of the specified command as on demand socket name (the vassal name is passed as the only argument)\", uwsgi_opt_set_str, &uwsgi.emperor_on_demand_exec, 0},\n\t{\"emperor-extra-extension\", required_argument, 0, \"allows the specified extension in the Emperor (vassal will be called with --config)\", uwsgi_opt_add_string_list, &uwsgi.emperor_extra_extension, 0},\n\t{\"emperor-extra-ext\", required_argument, 0, \"allows the specified extension in the Emperor (vassal will be called with --config)\", uwsgi_opt_add_string_list, &uwsgi.emperor_extra_extension, 0},\n\t{\"emperor-no-blacklist\", no_argument, 0, \"disable Emperor blacklisting subsystem\", uwsgi_opt_true, &uwsgi.emperor_no_blacklist, 0},\n#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)\n\t{\"emperor-use-clone\", required_argument, 0, \"use clone() instead of fork() passing the specified unshare() flags\", uwsgi_opt_set_unshare, &uwsgi.emperor_clone, 0},\n#endif\n#ifdef UWSGI_CAP\n\t{\"emperor-cap\", required_argument, 0, \"set vassals capability\", uwsgi_opt_set_emperor_cap, NULL, 0},\n\t{\"vassals-cap\", required_argument, 0, \"set vassals capability\", uwsgi_opt_set_emperor_cap, NULL, 0},\n\t{\"vassal-cap\", required_argument, 0, \"set vassals capability\", uwsgi_opt_set_emperor_cap, NULL, 0},\n#endif\n\t{\"imperial-monitor-list\", no_argument, 0, \"list enabled imperial monitors\", uwsgi_opt_true, &uwsgi.imperial_monitor_list, 0},\n\t{\"imperial-monitors-list\", no_argument, 0, \"list enabled imperial monitors\", uwsgi_opt_true, &uwsgi.imperial_monitor_list, 0},\n\t{\"vassals-inherit\", required_argument, 0, \"add config templates to vassals config (uses --inherit)\", uwsgi_opt_add_string_list, &uwsgi.vassals_templates, 0},\n\t{\"vassals-include\", required_argument, 0, \"include config templates to vassals config (uses --include instead of --inherit)\", uwsgi_opt_add_string_list, &uwsgi.vassals_includes, 0},\n\t{\"vassals-inherit-before\", required_argument, 0, \"add config templates to vassals config (uses --inherit, parses before the vassal file)\", uwsgi_opt_add_string_list, &uwsgi.vassals_templates_before, 0},\n\t{\"vassals-include-before\", required_argument, 0, \"include config templates to vassals config (uses --include instead of --inherit, parses before the vassal file)\", uwsgi_opt_add_string_list, &uwsgi.vassals_includes_before, 0},\n\t{\"vassals-start-hook\", required_argument, 0, \"run the specified command before each vassal starts\", uwsgi_opt_set_str, &uwsgi.vassals_start_hook, 0},\n\t{\"vassals-stop-hook\", required_argument, 0, \"run the specified command after vassal's death\", uwsgi_opt_set_str, &uwsgi.vassals_stop_hook, 0},\n\t{\"vassal-sos\", required_argument, 0, \"ask emperor for reinforcement when overloaded\", uwsgi_opt_set_int, &uwsgi.vassal_sos, 0},\n\t{\"vassal-sos-backlog\", required_argument, 0, \"ask emperor for sos if backlog queue has more items than the value specified\", uwsgi_opt_set_int, &uwsgi.vassal_sos_backlog, 0},\n\t{\"vassals-set\", required_argument, 0, \"automatically set the specified option (via --set) for every vassal\", uwsgi_opt_add_string_list, &uwsgi.vassals_set, 0},\n\t{\"vassal-set\", required_argument, 0, \"automatically set the specified option (via --set) for every vassal\", uwsgi_opt_add_string_list, &uwsgi.vassals_set, 0},\n\n\t{\"heartbeat\", required_argument, 0, \"announce healthiness to the emperor\", uwsgi_opt_set_int, &uwsgi.heartbeat, 0},\n\n\t{\"reload-mercy\", required_argument, 0, \"set the maximum time (in seconds) we wait for workers and other processes to die during reload/shutdown\", uwsgi_opt_set_int, &uwsgi.reload_mercy, 0},\n\t{\"worker-reload-mercy\", required_argument, 0, \"set the maximum time (in seconds) a worker can take to reload/shutdown (default is 60)\", uwsgi_opt_set_int, &uwsgi.worker_reload_mercy, 0},\n\t{\"mule-reload-mercy\", required_argument, 0, \"set the maximum time (in seconds) a mule can take to reload/shutdown (default is 60)\", uwsgi_opt_set_int, &uwsgi.mule_reload_mercy, 0},\n\t{\"exit-on-reload\", no_argument, 0, \"force exit even if a reload is requested\", uwsgi_opt_true, &uwsgi.exit_on_reload, 0},\n\t{\"die-on-term\", no_argument, 0, \"exit instead of brutal reload on SIGTERM\", uwsgi_opt_true, &uwsgi.die_on_term, 0},\n\t{\"force-gateway\", no_argument, 0, \"force the spawn of the first registered gateway without a master\", uwsgi_opt_true, &uwsgi.force_gateway, 0},\n\t{\"help\", no_argument, 'h', \"show this help\", uwsgi_help, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"usage\", no_argument, 'h', \"show this help\", uwsgi_help, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"print-sym\", required_argument, 0, \"print content of the specified binary symbol\", uwsgi_print_sym, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"print-symbol\", required_argument, 0, \"print content of the specified binary symbol\", uwsgi_print_sym, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"reaper\", no_argument, 'r', \"call waitpid(-1,...) after each request to get rid of zombies\", uwsgi_opt_true, &uwsgi.reaper, 0},\n\t{\"max-requests\", required_argument, 'R', \"reload workers after the specified amount of managed requests\", uwsgi_opt_set_64bit, &uwsgi.max_requests, 0},\n\t{\"min-worker-lifetime\", required_argument, 0, \"number of seconds worker must run before being reloaded (default is 60)\", uwsgi_opt_set_64bit, &uwsgi.min_worker_lifetime, 0},\n\t{\"max-worker-lifetime\", required_argument, 0, \"reload workers after the specified amount of seconds (default is disabled)\", uwsgi_opt_set_64bit, &uwsgi.max_worker_lifetime, 0},\n\n\t{\"socket-timeout\", required_argument, 'z', \"set internal sockets timeout\", uwsgi_opt_set_int, &uwsgi.socket_timeout, 0},\n\t{\"no-fd-passing\", no_argument, 0, \"disable file descriptor passing\", uwsgi_opt_true, &uwsgi.no_fd_passing, 0},\n\t{\"locks\", required_argument, 0, \"create the specified number of shared locks\", uwsgi_opt_set_int, &uwsgi.locks, 0},\n\t{\"lock-engine\", required_argument, 0, \"set the lock engine\", uwsgi_opt_set_str, &uwsgi.lock_engine, 0},\n\t{\"ftok\", required_argument, 0, \"set the ipcsem key via ftok() for avoiding duplicates\", uwsgi_opt_set_str, &uwsgi.ftok, 0},\n\t{\"persistent-ipcsem\", no_argument, 0, \"do not remove ipcsem's on shutdown\", uwsgi_opt_true, &uwsgi.persistent_ipcsem, 0},\n\t{\"sharedarea\", required_argument, 'A', \"create a raw shared memory area of specified pages (note: it supports keyval too)\", uwsgi_opt_add_string_list, &uwsgi.sharedareas_list, 0},\n\n\t{\"safe-fd\", required_argument, 0, \"do not close the specified file descriptor\", uwsgi_opt_safe_fd, NULL, 0},\n\t{\"fd-safe\", required_argument, 0, \"do not close the specified file descriptor\", uwsgi_opt_safe_fd, NULL, 0},\n\n\t{\"cache\", required_argument, 0, \"create a shared cache containing given elements\", uwsgi_opt_set_64bit, &uwsgi.cache_max_items, 0},\n\t{\"cache-blocksize\", required_argument, 0, \"set cache blocksize\", uwsgi_opt_set_64bit, &uwsgi.cache_blocksize, 0},\n\t{\"cache-store\", required_argument, 0, \"enable persistent cache to disk\", uwsgi_opt_set_str, &uwsgi.cache_store, UWSGI_OPT_MASTER},\n\t{\"cache-store-sync\", required_argument, 0, \"set frequency of sync for persistent cache\", uwsgi_opt_set_int, &uwsgi.cache_store_sync, 0},\n\t{\"cache-no-expire\", no_argument, 0, \"disable auto sweep of expired items\", uwsgi_opt_true, &uwsgi.cache_no_expire, 0},\n\t{\"cache-expire-freq\", required_argument, 0, \"set the frequency of cache sweeper scans (default 3 seconds)\", uwsgi_opt_set_int, &uwsgi.cache_expire_freq, 0},\n\t{\"cache-report-freed-items\", no_argument, 0, \"constantly report the cache item freed by the sweeper (use only for debug)\", uwsgi_opt_true, &uwsgi.cache_report_freed_items, 0},\n\t{\"cache-udp-server\", required_argument, 0, \"bind the cache udp server (used only for set/update/delete) to the specified socket\", uwsgi_opt_add_string_list, &uwsgi.cache_udp_server, UWSGI_OPT_MASTER},\n\t{\"cache-udp-node\", required_argument, 0, \"send cache update/deletion to the specified cache udp server\", uwsgi_opt_add_string_list, &uwsgi.cache_udp_node, UWSGI_OPT_MASTER},\n\t{\"cache-sync\", required_argument, 0, \"copy the whole content of another uWSGI cache server on server startup\", uwsgi_opt_set_str, &uwsgi.cache_sync, 0},\n\t{\"cache-use-last-modified\", no_argument, 0, \"update last_modified_at timestamp on every cache item modification (default is disabled)\", uwsgi_opt_true, &uwsgi.cache_use_last_modified, 0},\n\n\t{\"add-cache-item\", required_argument, 0, \"add an item in the cache\", uwsgi_opt_add_string_list, &uwsgi.add_cache_item, 0},\n\t{\"load-file-in-cache\", required_argument, 0, \"load a static file in the cache\", uwsgi_opt_add_string_list, &uwsgi.load_file_in_cache, 0},\n#ifdef UWSGI_ZLIB\n\t{\"load-file-in-cache-gzip\", required_argument, 0, \"load a static file in the cache with gzip compression\", uwsgi_opt_add_string_list, &uwsgi.load_file_in_cache_gzip, 0},\n#endif\n\n\t{\"cache2\", required_argument, 0, \"create a new generation shared cache (keyval syntax)\", uwsgi_opt_add_string_list, &uwsgi.cache2, 0},\n\n\n\t{\"queue\", required_argument, 0, \"enable shared queue\", uwsgi_opt_set_int, &uwsgi.queue_size, 0},\n\t{\"queue-blocksize\", required_argument, 0, \"set queue blocksize\", uwsgi_opt_set_int, &uwsgi.queue_blocksize, 0},\n\t{\"queue-store\", required_argument, 0, \"enable persistent queue to disk\", uwsgi_opt_set_str, &uwsgi.queue_store, UWSGI_OPT_MASTER},\n\t{\"queue-store-sync\", required_argument, 0, \"set frequency of sync for persistent queue\", uwsgi_opt_set_int, &uwsgi.queue_store_sync, 0},\n\n\t{\"spooler\", required_argument, 'Q', \"run a spooler on the specified directory\", uwsgi_opt_add_spooler, NULL, UWSGI_OPT_MASTER},\n\t{\"spooler-external\", required_argument, 0, \"map spoolers requests to a spooler directory managed by an external instance\", uwsgi_opt_add_spooler, (void *) UWSGI_SPOOLER_EXTERNAL, UWSGI_OPT_MASTER},\n\t{\"spooler-ordered\", no_argument, 0, \"try to order the execution of spooler tasks\", uwsgi_opt_true, &uwsgi.spooler_ordered, 0},\n\t{\"spooler-chdir\", required_argument, 0, \"chdir() to specified directory before each spooler task\", uwsgi_opt_set_str, &uwsgi.spooler_chdir, 0},\n\t{\"spooler-processes\", required_argument, 0, \"set the number of processes for spoolers\", uwsgi_opt_set_int, &uwsgi.spooler_numproc, UWSGI_OPT_IMMEDIATE},\n\t{\"spooler-quiet\", no_argument, 0, \"do not be verbose with spooler tasks\", uwsgi_opt_true, &uwsgi.spooler_quiet, 0},\n\t{\"spooler-max-tasks\", required_argument, 0, \"set the maximum number of tasks to run before recycling a spooler\", uwsgi_opt_set_int, &uwsgi.spooler_max_tasks, 0},\n\t{\"spooler-harakiri\", required_argument, 0, \"set harakiri timeout for spooler tasks\", uwsgi_opt_set_int, &uwsgi.harakiri_options.spoolers, 0},\n\t{\"spooler-frequency\", required_argument, 0, \"set spooler frequency\", uwsgi_opt_set_int, &uwsgi.spooler_frequency, 0},\n\t{\"spooler-freq\", required_argument, 0, \"set spooler frequency\", uwsgi_opt_set_int, &uwsgi.spooler_frequency, 0},\n\n\t{\"mule\", optional_argument, 0, \"add a mule\", uwsgi_opt_add_mule, NULL, UWSGI_OPT_MASTER},\n\t{\"mules\", required_argument, 0, \"add the specified number of mules\", uwsgi_opt_add_mules, NULL, UWSGI_OPT_MASTER},\n\t{\"farm\", required_argument, 0, \"add a mule farm\", uwsgi_opt_add_farm, NULL, UWSGI_OPT_MASTER},\n\t{\"mule-msg-size\", optional_argument, 0, \"set mule message buffer size\", uwsgi_opt_set_int, &uwsgi.mule_msg_size, UWSGI_OPT_MASTER},\n\n\t{\"signal\", required_argument, 0, \"send a uwsgi signal to a server\", uwsgi_opt_signal, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"signal-bufsize\", required_argument, 0, \"set buffer size for signal queue\", uwsgi_opt_set_int, &uwsgi.signal_bufsize, 0},\n\t{\"signals-bufsize\", required_argument, 0, \"set buffer size for signal queue\", uwsgi_opt_set_int, &uwsgi.signal_bufsize, 0},\n\n\t{\"signal-timer\", required_argument, 0, \"add a timer (syntax: <signal> <seconds>)\", uwsgi_opt_add_string_list, &uwsgi.signal_timers, UWSGI_OPT_MASTER},\n\t{\"timer\", required_argument, 0, \"add a timer (syntax: <signal> <seconds>)\", uwsgi_opt_add_string_list, &uwsgi.signal_timers, UWSGI_OPT_MASTER},\n\n\t{\"signal-rbtimer\", required_argument, 0, \"add a redblack timer (syntax: <signal> <seconds>)\", uwsgi_opt_add_string_list, &uwsgi.rb_signal_timers, UWSGI_OPT_MASTER},\n\t{\"rbtimer\", required_argument, 0, \"add a redblack timer (syntax: <signal> <seconds>)\", uwsgi_opt_add_string_list, &uwsgi.rb_signal_timers, UWSGI_OPT_MASTER},\n\n\t{\"rpc-max\", required_argument, 0, \"maximum number of rpc slots (default: 64)\", uwsgi_opt_set_64bit, &uwsgi.rpc_max, 0},\n\n\t{\"disable-logging\", no_argument, 'L', \"disable request logging\", uwsgi_opt_false, &uwsgi.logging_options.enabled, 0},\n\n\t{\"flock\", required_argument, 0, \"lock the specified file before starting, exit if locked\", uwsgi_opt_flock, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"flock-wait\", required_argument, 0, \"lock the specified file before starting, wait if locked\", uwsgi_opt_flock_wait, NULL, UWSGI_OPT_IMMEDIATE},\n\n\t{\"flock2\", required_argument, 0, \"lock the specified file after logging/daemon setup, exit if locked\", uwsgi_opt_set_str, &uwsgi.flock2, UWSGI_OPT_IMMEDIATE},\n\t{\"flock-wait2\", required_argument, 0, \"lock the specified file after logging/daemon setup, wait if locked\", uwsgi_opt_set_str, &uwsgi.flock_wait2, UWSGI_OPT_IMMEDIATE},\n\n\t{\"pidfile\", required_argument, 0, \"create pidfile (before privileges drop)\", uwsgi_opt_set_str, &uwsgi.pidfile, 0},\n\t{\"pidfile2\", required_argument, 0, \"create pidfile (after privileges drop)\", uwsgi_opt_set_str, &uwsgi.pidfile2, 0},\n\t{\"safe-pidfile\", required_argument, 0, \"create safe pidfile (before privileges drop)\", uwsgi_opt_set_str, &uwsgi.safe_pidfile, 0},\n\t{\"safe-pidfile2\", required_argument, 0, \"create safe pidfile (after privileges drop)\", uwsgi_opt_set_str, &uwsgi.safe_pidfile2, 0},\n\t{\"chroot\", required_argument, 0, \"chroot() to the specified directory\", uwsgi_opt_set_str, &uwsgi.chroot, 0},\n#ifdef __linux__\n\t{\"pivot-root\", required_argument, 0, \"pivot_root() to the specified directories (new_root and put_old must be separated with a space)\", uwsgi_opt_set_str, &uwsgi.pivot_root, 0},\n\t{\"pivot_root\", required_argument, 0, \"pivot_root() to the specified directories (new_root and put_old must be separated with a space)\", uwsgi_opt_set_str, &uwsgi.pivot_root, 0},\n#endif\n\n\t{\"uid\", required_argument, 0, \"setuid to the specified user/uid\", uwsgi_opt_set_uid, NULL, 0},\n\t{\"gid\", required_argument, 0, \"setgid to the specified group/gid\", uwsgi_opt_set_gid, NULL, 0},\n\t{\"add-gid\", required_argument, 0, \"add the specified group id to the process credentials\", uwsgi_opt_add_string_list, &uwsgi.additional_gids, 0},\n\t{\"immediate-uid\", required_argument, 0, \"setuid to the specified user/uid IMMEDIATELY\", uwsgi_opt_set_immediate_uid, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"immediate-gid\", required_argument, 0, \"setgid to the specified group/gid IMMEDIATELY\", uwsgi_opt_set_immediate_gid, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"no-initgroups\", no_argument, 0, \"disable additional groups set via initgroups()\", uwsgi_opt_true, &uwsgi.no_initgroups, 0},\n#ifdef UWSGI_CAP\n\t{\"cap\", required_argument, 0, \"set process capability\", uwsgi_opt_set_cap, NULL, 0},\n#endif\n#ifdef __linux__\n\t{\"unshare\", required_argument, 0, \"unshare() part of the processes and put it in a new namespace\", uwsgi_opt_set_unshare, &uwsgi.unshare, 0},\n\t{\"unshare2\", required_argument, 0, \"unshare() part of the processes and put it in a new namespace after rootfs change\", uwsgi_opt_set_unshare, &uwsgi.unshare2, 0},\n\t{\"setns-socket\", required_argument, 0, \"expose a unix socket returning namespace fds from /proc/self/ns\", uwsgi_opt_set_str, &uwsgi.setns_socket, UWSGI_OPT_MASTER},\n\t{\"setns-socket-skip\", required_argument, 0, \"skip the specified entry when sending setns file descriptors\", uwsgi_opt_add_string_list, &uwsgi.setns_socket_skip, 0},\n\t{\"setns-skip\", required_argument, 0, \"skip the specified entry when sending setns file descriptors\", uwsgi_opt_add_string_list, &uwsgi.setns_socket_skip, 0},\n\t{\"setns\", required_argument, 0, \"join a namespace created by an external uWSGI instance\", uwsgi_opt_set_str, &uwsgi.setns, 0},\n\t{\"setns-preopen\", no_argument, 0, \"open /proc/self/ns as soon as possible and cache fds\", uwsgi_opt_true, &uwsgi.setns_preopen, 0},\n#endif\n\t{\"jailed\", no_argument, 0, \"mark the instance as jailed (force the execution of post_jail hooks)\", uwsgi_opt_true, &uwsgi.jailed, 0},\n#if defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\t{\"jail\", required_argument, 0, \"put the instance in a FreeBSD jail\", uwsgi_opt_set_str, &uwsgi.jail, 0},\n\t{\"jail-ip4\", required_argument, 0, \"add an ipv4 address to the FreeBSD jail\", uwsgi_opt_add_string_list, &uwsgi.jail_ip4, 0},\n\t{\"jail-ip6\", required_argument, 0, \"add an ipv6 address to the FreeBSD jail\", uwsgi_opt_add_string_list, &uwsgi.jail_ip6, 0},\n\t{\"jidfile\", required_argument, 0, \"save the jid of a FreeBSD jail in the specified file\", uwsgi_opt_set_str, &uwsgi.jidfile, 0},\n\t{\"jid-file\", required_argument, 0, \"save the jid of a FreeBSD jail in the specified file\", uwsgi_opt_set_str, &uwsgi.jidfile, 0},\n#ifdef UWSGI_HAS_FREEBSD_LIBJAIL\n\t{\"jail2\", required_argument, 0, \"add an option to the FreeBSD jail\", uwsgi_opt_add_string_list, &uwsgi.jail2, 0},\n\t{\"libjail\", required_argument, 0, \"add an option to the FreeBSD jail\", uwsgi_opt_add_string_list, &uwsgi.jail2, 0},\n\t{\"jail-attach\", required_argument, 0, \"attach to the FreeBSD jail\", uwsgi_opt_set_str, &uwsgi.jail_attach, 0},\n#endif\n#endif\n\t{\"refork\", no_argument, 0, \"fork() again after privileges drop. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork, 0},\n\t{\"re-fork\", no_argument, 0, \"fork() again after privileges drop. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork, 0},\n\t{\"refork-as-root\", no_argument, 0, \"fork() again before privileges drop. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork_as_root, 0},\n\t{\"re-fork-as-root\", no_argument, 0, \"fork() again before privileges drop. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork_as_root, 0},\n\t{\"refork-post-jail\", no_argument, 0, \"fork() again after jailing. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork_post_jail, 0},\n\t{\"re-fork-post-jail\", no_argument, 0, \"fork() again after jailing. Useful for jailing systems\", uwsgi_opt_true, &uwsgi.refork_post_jail, 0},\n\n\t{\"hook-asap\", required_argument, 0, \"run the specified hook as soon as possible\", uwsgi_opt_add_string_list, &uwsgi.hook_asap, 0},\n\t{\"hook-pre-jail\", required_argument, 0, \"run the specified hook before jailing\", uwsgi_opt_add_string_list, &uwsgi.hook_pre_jail, 0},\n        {\"hook-post-jail\", required_argument, 0, \"run the specified hook after jailing\", uwsgi_opt_add_string_list, &uwsgi.hook_post_jail, 0},\n        {\"hook-in-jail\", required_argument, 0, \"run the specified hook in jail after initialization\", uwsgi_opt_add_string_list, &uwsgi.hook_in_jail, 0},\n        {\"hook-as-root\", required_argument, 0, \"run the specified hook before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.hook_as_root, 0},\n        {\"hook-as-user\", required_argument, 0, \"run the specified hook after privileges drop\", uwsgi_opt_add_string_list, &uwsgi.hook_as_user, 0},\n        {\"hook-as-user-atexit\", required_argument, 0, \"run the specified hook before app exit and reload\", uwsgi_opt_add_string_list, &uwsgi.hook_as_user_atexit, 0},\n        {\"hook-pre-app\", required_argument, 0, \"run the specified hook before app loading\", uwsgi_opt_add_string_list, &uwsgi.hook_pre_app, 0},\n        {\"hook-post-app\", required_argument, 0, \"run the specified hook after app loading\", uwsgi_opt_add_string_list, &uwsgi.hook_post_app, 0},\n\t{\"hook-post-fork\", required_argument, 0, \"run the specified hook after each fork\", uwsgi_opt_add_string_list, &uwsgi.hook_post_fork, 0},\n        {\"hook-accepting\", required_argument, 0, \"run the specified hook after each worker enter the accepting phase\", uwsgi_opt_add_string_list, &uwsgi.hook_accepting, 0},\n        {\"hook-accepting1\", required_argument, 0, \"run the specified hook after the first worker enters the accepting phase\", uwsgi_opt_add_string_list, &uwsgi.hook_accepting1, 0},\n        {\"hook-accepting-once\", required_argument, 0, \"run the specified hook after each worker enter the accepting phase (once per-instance)\", uwsgi_opt_add_string_list, &uwsgi.hook_accepting_once, 0},\n        {\"hook-accepting1-once\", required_argument, 0, \"run the specified hook after the first worker enters the accepting phase (once per instance)\", uwsgi_opt_add_string_list, &uwsgi.hook_accepting1_once, 0},\n\n        {\"hook-master-start\", required_argument, 0, \"run the specified hook when the Master starts\", uwsgi_opt_add_string_list, &uwsgi.hook_master_start, 0},\n\n        {\"hook-touch\", required_argument, 0, \"run the specified hook when the specified file is touched (syntax: <file> <action>)\", uwsgi_opt_add_string_list, &uwsgi.hook_touch, 0},\n\n        {\"hook-emperor-start\", required_argument, 0, \"run the specified hook when the Emperor starts\", uwsgi_opt_add_string_list, &uwsgi.hook_emperor_start, 0},\n        {\"hook-emperor-stop\", required_argument, 0, \"run the specified hook when the Emperor send a stop message\", uwsgi_opt_add_string_list, &uwsgi.hook_emperor_stop, 0},\n        {\"hook-emperor-reload\", required_argument, 0, \"run the specified hook when the Emperor send a reload message\", uwsgi_opt_add_string_list, &uwsgi.hook_emperor_reload, 0},\n        {\"hook-emperor-lost\", required_argument, 0, \"run the specified hook when the Emperor connection is lost\", uwsgi_opt_add_string_list, &uwsgi.hook_emperor_lost, 0},\n\n        {\"hook-as-vassal\", required_argument, 0, \"run the specified hook before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.hook_as_vassal, 0},\n        {\"hook-as-emperor\", required_argument, 0, \"run the specified hook in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.hook_as_emperor, 0},\n\n        {\"hook-as-mule\", required_argument, 0, \"run the specified hook in each mule\", uwsgi_opt_add_string_list, &uwsgi.hook_as_mule, 0},\n\n        {\"hook-as-gateway\", required_argument, 0, \"run the specified hook in each gateway\", uwsgi_opt_add_string_list, &uwsgi.hook_as_gateway, 0},\n\n        {\"after-request-hook\", required_argument, 0, \"run the specified function/symbol after each request\", uwsgi_opt_add_string_list, &uwsgi.after_request_hooks, 0},\n        {\"after-request-call\", required_argument, 0, \"run the specified function/symbol after each request\", uwsgi_opt_add_string_list, &uwsgi.after_request_hooks, 0},\n\n\t{\"exec-asap\", required_argument, 0, \"run the specified command as soon as possible\", uwsgi_opt_add_string_list, &uwsgi.exec_asap, 0},\n\t{\"exec-pre-jail\", required_argument, 0, \"run the specified command before jailing\", uwsgi_opt_add_string_list, &uwsgi.exec_pre_jail, 0},\n\t{\"exec-post-jail\", required_argument, 0, \"run the specified command after jailing\", uwsgi_opt_add_string_list, &uwsgi.exec_post_jail, 0},\n\t{\"exec-in-jail\", required_argument, 0, \"run the specified command in jail after initialization\", uwsgi_opt_add_string_list, &uwsgi.exec_in_jail, 0},\n\t{\"exec-as-root\", required_argument, 0, \"run the specified command before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.exec_as_root, 0},\n\t{\"exec-as-user\", required_argument, 0, \"run the specified command after privileges drop\", uwsgi_opt_add_string_list, &uwsgi.exec_as_user, 0},\n\t{\"exec-as-user-atexit\", required_argument, 0, \"run the specified command before app exit and reload\", uwsgi_opt_add_string_list, &uwsgi.exec_as_user_atexit, 0},\n\t{\"exec-pre-app\", required_argument, 0, \"run the specified command before app loading\", uwsgi_opt_add_string_list, &uwsgi.exec_pre_app, 0},\n\t{\"exec-post-app\", required_argument, 0, \"run the specified command after app loading\", uwsgi_opt_add_string_list, &uwsgi.exec_post_app, 0},\n\n\t{\"exec-as-vassal\", required_argument, 0, \"run the specified command before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.exec_as_vassal, 0},\n\t{\"exec-as-emperor\", required_argument, 0, \"run the specified command in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.exec_as_emperor, 0},\n\n\t{\"mount-asap\", required_argument, 0, \"mount filesystem as soon as possible\", uwsgi_opt_add_string_list, &uwsgi.mount_asap, 0},\n\t{\"mount-pre-jail\", required_argument, 0, \"mount filesystem before jailing\", uwsgi_opt_add_string_list, &uwsgi.mount_pre_jail, 0},\n        {\"mount-post-jail\", required_argument, 0, \"mount filesystem after jailing\", uwsgi_opt_add_string_list, &uwsgi.mount_post_jail, 0},\n        {\"mount-in-jail\", required_argument, 0, \"mount filesystem in jail after initialization\", uwsgi_opt_add_string_list, &uwsgi.mount_in_jail, 0},\n        {\"mount-as-root\", required_argument, 0, \"mount filesystem before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.mount_as_root, 0},\n\n        {\"mount-as-vassal\", required_argument, 0, \"mount filesystem before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.mount_as_vassal, 0},\n        {\"mount-as-emperor\", required_argument, 0, \"mount filesystem in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.mount_as_emperor, 0},\n\n\t{\"umount-asap\", required_argument, 0, \"unmount filesystem as soon as possible\", uwsgi_opt_add_string_list, &uwsgi.umount_asap, 0},\n\t{\"umount-pre-jail\", required_argument, 0, \"unmount filesystem before jailing\", uwsgi_opt_add_string_list, &uwsgi.umount_pre_jail, 0},\n        {\"umount-post-jail\", required_argument, 0, \"unmount filesystem after jailing\", uwsgi_opt_add_string_list, &uwsgi.umount_post_jail, 0},\n        {\"umount-in-jail\", required_argument, 0, \"unmount filesystem in jail after initialization\", uwsgi_opt_add_string_list, &uwsgi.umount_in_jail, 0},\n        {\"umount-as-root\", required_argument, 0, \"unmount filesystem before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.umount_as_root, 0},\n\n        {\"umount-as-vassal\", required_argument, 0, \"unmount filesystem before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.umount_as_vassal, 0},\n        {\"umount-as-emperor\", required_argument, 0, \"unmount filesystem in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.umount_as_emperor, 0},\n\n\t{\"wait-for-interface\", required_argument, 0, \"wait for the specified network interface to come up before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_interface, 0},\n\t{\"wait-for-interface-timeout\", required_argument, 0, \"set the timeout for wait-for-interface\", uwsgi_opt_set_int, &uwsgi.wait_for_interface_timeout, 0},\n\n\t{\"wait-interface\", required_argument, 0, \"wait for the specified network interface to come up before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_interface, 0},\n\t{\"wait-interface-timeout\", required_argument, 0, \"set the timeout for wait-for-interface\", uwsgi_opt_set_int, &uwsgi.wait_for_interface_timeout, 0},\n\n\t{\"wait-for-iface\", required_argument, 0, \"wait for the specified network interface to come up before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_interface, 0},\n\t{\"wait-for-iface-timeout\", required_argument, 0, \"set the timeout for wait-for-interface\", uwsgi_opt_set_int, &uwsgi.wait_for_interface_timeout, 0},\n\n\t{\"wait-iface\", required_argument, 0, \"wait for the specified network interface to come up before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_interface, 0},\n\t{\"wait-iface-timeout\", required_argument, 0, \"set the timeout for wait-for-interface\", uwsgi_opt_set_int, &uwsgi.wait_for_interface_timeout, 0},\n\n\t{\"wait-for-fs\", required_argument, 0, \"wait for the specified filesystem item to appear before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_fs, 0},\n\t{\"wait-for-file\", required_argument, 0, \"wait for the specified file to appear before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_fs, 0},\n\t{\"wait-for-dir\", required_argument, 0, \"wait for the specified directory to appear before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_fs, 0},\n\t{\"wait-for-mountpoint\", required_argument, 0, \"wait for the specified mountpoint to appear before running root hooks\", uwsgi_opt_add_string_list, &uwsgi.wait_for_mountpoint, 0},\n\t{\"wait-for-fs-timeout\", required_argument, 0, \"set the timeout for wait-for-fs/file/dir\", uwsgi_opt_set_int, &uwsgi.wait_for_fs_timeout, 0},\n\n\t{\"wait-for-socket\", required_argument, 0, \"wait for the specified socket to be ready before loading apps\", uwsgi_opt_add_string_list, &uwsgi.wait_for_socket, 0},\n\t{\"wait-for-socket-timeout\", required_argument, 0, \"set the timeout for wait-for-socket\", uwsgi_opt_set_int, &uwsgi.wait_for_socket_timeout, 0},\n\n\t{\"call-asap\", required_argument, 0, \"call the specified function as soon as possible\", uwsgi_opt_add_string_list, &uwsgi.call_asap, 0},\n\t{\"call-pre-jail\", required_argument, 0, \"call the specified function before jailing\", uwsgi_opt_add_string_list, &uwsgi.call_pre_jail, 0},\n\t{\"call-post-jail\", required_argument, 0, \"call the specified function after jailing\", uwsgi_opt_add_string_list, &uwsgi.call_post_jail, 0},\n\t{\"call-in-jail\", required_argument, 0, \"call the specified function in jail after initialization\", uwsgi_opt_add_string_list, &uwsgi.call_in_jail, 0},\n\t{\"call-as-root\", required_argument, 0, \"call the specified function before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.call_as_root, 0},\n\t{\"call-as-user\", required_argument, 0, \"call the specified function after privileges drop\", uwsgi_opt_add_string_list, &uwsgi.call_as_user, 0},\n\t{\"call-as-user-atexit\", required_argument, 0, \"call the specified function before app exit and reload\", uwsgi_opt_add_string_list, &uwsgi.call_as_user_atexit, 0},\n\t{\"call-pre-app\", required_argument, 0, \"call the specified function before app loading\", uwsgi_opt_add_string_list, &uwsgi.call_pre_app, 0},\n\t{\"call-post-app\", required_argument, 0, \"call the specified function after app loading\", uwsgi_opt_add_string_list, &uwsgi.call_post_app, 0},\n\n\t{\"call-as-vassal\", required_argument, 0, \"call the specified function() before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.call_as_vassal, 0},\n\t{\"call-as-vassal1\", required_argument, 0, \"call the specified function(char *) before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.call_as_vassal1, 0},\n\t{\"call-as-vassal3\", required_argument, 0, \"call the specified function(char *, uid_t, gid_t) before exec()ing the vassal\", uwsgi_opt_add_string_list, &uwsgi.call_as_vassal3, 0},\n\n\t{\"call-as-emperor\", required_argument, 0, \"call the specified function() in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.call_as_emperor, 0},\n\t{\"call-as-emperor1\", required_argument, 0, \"call the specified function(char *) in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.call_as_emperor1, 0},\n\t{\"call-as-emperor2\", required_argument, 0, \"call the specified function(char *, pid_t) in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.call_as_emperor2, 0},\n\t{\"call-as-emperor4\", required_argument, 0, \"call the specified function(char *, pid_t, uid_t, gid_t) in the emperor after the vassal has been started\", uwsgi_opt_add_string_list, &uwsgi.call_as_emperor4, 0},\n\n\n\n\t{\"ini\", required_argument, 0, \"load config from ini file\", uwsgi_opt_load_ini, NULL, UWSGI_OPT_IMMEDIATE},\n#ifdef UWSGI_YAML\n\t{\"yaml\", required_argument, 'y', \"load config from yaml file\", uwsgi_opt_load_yml, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"yml\", required_argument, 'y', \"load config from yaml file\", uwsgi_opt_load_yml, NULL, UWSGI_OPT_IMMEDIATE},\n#endif\n#ifdef UWSGI_JSON\n\t{\"json\", required_argument, 'j', \"load config from json file\", uwsgi_opt_load_json, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"js\", required_argument, 'j', \"load config from json file\", uwsgi_opt_load_json, NULL, UWSGI_OPT_IMMEDIATE},\n#endif\n\t{\"weight\", required_argument, 0, \"weight of the instance (used by clustering/lb/subscriptions)\", uwsgi_opt_set_64bit, &uwsgi.weight, 0},\n\t{\"auto-weight\", required_argument, 0, \"set weight of the instance (used by clustering/lb/subscriptions) automatically\", uwsgi_opt_true, &uwsgi.auto_weight, 0},\n\t{\"no-server\", no_argument, 0, \"force no-server mode\", uwsgi_opt_true, &uwsgi.no_server, 0},\n\t{\"command-mode\", no_argument, 0, \"force command mode\", uwsgi_opt_true, &uwsgi.command_mode, UWSGI_OPT_IMMEDIATE},\n\t{\"no-defer-accept\", no_argument, 0, \"disable deferred-accept on sockets\", uwsgi_opt_true, &uwsgi.no_defer_accept, 0},\n\t{\"tcp-nodelay\", no_argument, 0, \"enable TCP NODELAY on each request\", uwsgi_opt_true, &uwsgi.tcp_nodelay, 0},\n\t{\"so-keepalive\", no_argument, 0, \"enable TCP KEEPALIVEs\", uwsgi_opt_true, &uwsgi.so_keepalive, 0},\n\t{\"so-send-timeout\", no_argument, 0, \"set SO_SNDTIMEO\", uwsgi_opt_set_int, &uwsgi.so_send_timeout, 0},\n\t{\"socket-send-timeout\", no_argument, 0, \"set SO_SNDTIMEO\", uwsgi_opt_set_int, &uwsgi.so_send_timeout, 0},\n\t{\"so-write-timeout\", no_argument, 0, \"set SO_SNDTIMEO\", uwsgi_opt_set_int, &uwsgi.so_send_timeout, 0},\n\t{\"socket-write-timeout\", no_argument, 0, \"set SO_SNDTIMEO\", uwsgi_opt_set_int, &uwsgi.so_send_timeout, 0},\n\t{\"socket-sndbuf\", required_argument, 0, \"set SO_SNDBUF\", uwsgi_opt_set_64bit, &uwsgi.so_sndbuf, 0},\n\t{\"socket-rcvbuf\", required_argument, 0, \"set SO_RCVBUF\", uwsgi_opt_set_64bit, &uwsgi.so_rcvbuf, 0},\n\t{\"shutdown-sockets\", no_argument, 0, \"force calling shutdown() in addition to close() when sockets are destroyed\", uwsgi_opt_true, &uwsgi.shutdown_sockets, 0},\n\t{\"limit-as\", required_argument, 0, \"limit processes address space/vsz\", uwsgi_opt_set_megabytes, &uwsgi.rl.rlim_max, 0},\n\t{\"limit-nproc\", required_argument, 0, \"limit the number of spawnable processes\", uwsgi_opt_set_int, &uwsgi.rl_nproc.rlim_max, 0},\n\t{\"reload-on-as\", required_argument, 0, \"reload if address space is higher than specified megabytes\", uwsgi_opt_set_megabytes, &uwsgi.reload_on_as, UWSGI_OPT_MEMORY},\n\t{\"reload-on-rss\", required_argument, 0, \"reload if rss memory is higher than specified megabytes\", uwsgi_opt_set_megabytes, &uwsgi.reload_on_rss, UWSGI_OPT_MEMORY},\n\t{\"evil-reload-on-as\", required_argument, 0, \"force the master to reload a worker if its address space is higher than specified megabytes\", uwsgi_opt_set_megabytes, &uwsgi.evil_reload_on_as, UWSGI_OPT_MASTER | UWSGI_OPT_MEMORY},\n\t{\"evil-reload-on-rss\", required_argument, 0, \"force the master to reload a worker if its rss memory is higher than specified megabytes\", uwsgi_opt_set_megabytes, &uwsgi.evil_reload_on_rss, UWSGI_OPT_MASTER | UWSGI_OPT_MEMORY},\n\t{\"mem-collector-freq\", required_argument, 0, \"set the memory collector frequency when evil reloads are in place\", uwsgi_opt_set_int, &uwsgi.mem_collector_freq, 0},\n\n\t{\"reload-on-fd\", required_argument, 0, \"reload if the specified file descriptor is ready\", uwsgi_opt_add_string_list, &uwsgi.reload_on_fd, UWSGI_OPT_MASTER},\n\t{\"brutal-reload-on-fd\", required_argument, 0, \"brutal reload if the specified file descriptor is ready\", uwsgi_opt_add_string_list, &uwsgi.brutal_reload_on_fd, UWSGI_OPT_MASTER},\n\n#ifdef __linux__\n#ifdef MADV_MERGEABLE\n\t{\"ksm\", optional_argument, 0, \"enable Linux KSM\", uwsgi_opt_set_int, &uwsgi.linux_ksm, 0},\n#endif\n#endif\n#ifdef UWSGI_PCRE\n\t{\"pcre-jit\", no_argument, 0, \"enable pcre jit (if available)\", uwsgi_opt_pcre_jit, NULL, UWSGI_OPT_IMMEDIATE},\n#endif\n\t{\"never-swap\", no_argument, 0, \"lock all memory pages avoiding swapping\", uwsgi_opt_true, &uwsgi.never_swap, 0},\n\t{\"touch-reload\", required_argument, 0, \"reload uWSGI if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_reload, UWSGI_OPT_MASTER},\n\t{\"touch-workers-reload\", required_argument, 0, \"trigger reload of (only) workers if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_workers_reload, UWSGI_OPT_MASTER},\n\t{\"touch-mules-reload\", required_argument, 0, \"reload mules if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_mules_reload, UWSGI_OPT_MASTER},\n\t{\"touch-spoolers-reload\", required_argument, 0, \"reload spoolers if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_spoolers_reload, UWSGI_OPT_MASTER},\n\t{\"touch-chain-reload\", required_argument, 0, \"trigger chain reload if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_chain_reload, UWSGI_OPT_MASTER},\n\t{\"touch-logrotate\", required_argument, 0, \"trigger logrotation if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_logrotate, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"touch-logreopen\", required_argument, 0, \"trigger log reopen if the specified file is modified/touched\", uwsgi_opt_add_string_list, &uwsgi.touch_logreopen, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"touch-exec\", required_argument, 0, \"run command when the specified file is modified/touched (syntax: file command)\", uwsgi_opt_add_string_list, &uwsgi.touch_exec, UWSGI_OPT_MASTER},\n\t{\"touch-signal\", required_argument, 0, \"signal when the specified file is modified/touched (syntax: file signal)\", uwsgi_opt_add_string_list, &uwsgi.touch_signal, UWSGI_OPT_MASTER},\n\n\t{\"fs-reload\", required_argument, 0, \"graceful reload when the specified filesystem object is modified\", uwsgi_opt_add_string_list, &uwsgi.fs_reload, UWSGI_OPT_MASTER},\n\t{\"fs-brutal-reload\", required_argument, 0, \"brutal reload when the specified filesystem object is modified\", uwsgi_opt_add_string_list, &uwsgi.fs_brutal_reload, UWSGI_OPT_MASTER},\n\t{\"fs-signal\", required_argument, 0, \"raise a uwsgi signal when the specified filesystem object is modified (syntax: file signal)\", uwsgi_opt_add_string_list, &uwsgi.fs_signal, UWSGI_OPT_MASTER},\n\n\t{\"check-mountpoint\", required_argument, 0, \"destroy the instance if a filesystem is no more reachable (useful for reliable Fuse management)\", uwsgi_opt_add_string_list, &uwsgi.mountpoints_check, UWSGI_OPT_MASTER},\n\t{\"mountpoint-check\", required_argument, 0, \"destroy the instance if a filesystem is no more reachable (useful for reliable Fuse management)\", uwsgi_opt_add_string_list, &uwsgi.mountpoints_check, UWSGI_OPT_MASTER},\n\t{\"check-mount\", required_argument, 0, \"destroy the instance if a filesystem is no more reachable (useful for reliable Fuse management)\", uwsgi_opt_add_string_list, &uwsgi.mountpoints_check, UWSGI_OPT_MASTER},\n\t{\"mount-check\", required_argument, 0, \"destroy the instance if a filesystem is no more reachable (useful for reliable Fuse management)\", uwsgi_opt_add_string_list, &uwsgi.mountpoints_check, UWSGI_OPT_MASTER},\n\n\t{\"propagate-touch\", no_argument, 0, \"over-engineering option for system with flaky signal management\", uwsgi_opt_true, &uwsgi.propagate_touch, 0},\n\t{\"limit-post\", required_argument, 0, \"limit request body\", uwsgi_opt_set_64bit, &uwsgi.limit_post, 0},\n\t{\"no-orphans\", no_argument, 0, \"automatically kill workers if master dies (can be dangerous for availability)\", uwsgi_opt_true, &uwsgi.no_orphans, 0},\n\t{\"prio\", required_argument, 0, \"set processes/threads priority\", uwsgi_opt_set_rawint, &uwsgi.prio, 0},\n\t{\"cpu-affinity\", required_argument, 0, \"set cpu affinity\", uwsgi_opt_set_int, &uwsgi.cpu_affinity, 0},\n\t{\"post-buffering\", required_argument, 0, \"set size in bytes after which will buffer to disk instead of memory\", uwsgi_opt_set_64bit, &uwsgi.post_buffering, 0},\n\t{\"post-buffering-bufsize\", required_argument, 0, \"set buffer size for read() in post buffering mode\", uwsgi_opt_set_64bit, &uwsgi.post_buffering_bufsize, 0},\n\t{\"body-read-warning\", required_argument, 0, \"set the amount of allowed memory allocation (in megabytes) for request body before starting printing a warning\", uwsgi_opt_set_64bit, &uwsgi.body_read_warning, 0},\n\t{\"upload-progress\", required_argument, 0, \"enable creation of .json files in the specified directory during a file upload\", uwsgi_opt_set_str, &uwsgi.upload_progress, 0},\n\t{\"no-default-app\", no_argument, 0, \"do not fallback to default app\", uwsgi_opt_true, &uwsgi.no_default_app, 0},\n\t{\"manage-script-name\", no_argument, 0, \"automatically rewrite SCRIPT_NAME and PATH_INFO\", uwsgi_opt_true, &uwsgi.manage_script_name, 0},\n\t{\"ignore-script-name\", no_argument, 0, \"ignore SCRIPT_NAME\", uwsgi_opt_true, &uwsgi.ignore_script_name, 0},\n\n\t{\"catch-exceptions\", no_argument, 0, \"report exception as http output (discouraged, use only for testing)\", uwsgi_opt_true, &uwsgi.catch_exceptions, 0},\n\t{\"reload-on-exception\", no_argument, 0, \"reload a worker when an exception is raised\", uwsgi_opt_true, &uwsgi.reload_on_exception, 0},\n\t{\"reload-on-exception-type\", required_argument, 0, \"reload a worker when a specific exception type is raised\", uwsgi_opt_add_string_list, &uwsgi.reload_on_exception_type, 0},\n\t{\"reload-on-exception-value\", required_argument, 0, \"reload a worker when a specific exception value is raised\", uwsgi_opt_add_string_list, &uwsgi.reload_on_exception_value, 0},\n\t{\"reload-on-exception-repr\", required_argument, 0, \"reload a worker when a specific exception type+value (language-specific) is raised\", uwsgi_opt_add_string_list, &uwsgi.reload_on_exception_repr, 0},\n\t{\"exception-handler\", required_argument, 0, \"add an exception handler\", uwsgi_opt_add_string_list, &uwsgi.exception_handlers_instance, UWSGI_OPT_MASTER},\n\n\t{\"enable-metrics\", no_argument, 0, \"enable metrics subsystem\", uwsgi_opt_true, &uwsgi.has_metrics, UWSGI_OPT_MASTER},\n\t{\"metric\", required_argument, 0, \"add a custom metric\", uwsgi_opt_add_string_list, &uwsgi.additional_metrics, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metric-threshold\", required_argument, 0, \"add a metric threshold/alarm\", uwsgi_opt_add_string_list, &uwsgi.metrics_threshold, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metric-alarm\", required_argument, 0, \"add a metric threshold/alarm\", uwsgi_opt_add_string_list, &uwsgi.metrics_threshold, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"alarm-metric\", required_argument, 0, \"add a metric threshold/alarm\", uwsgi_opt_add_string_list, &uwsgi.metrics_threshold, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metrics-dir\", required_argument, 0, \"export metrics as text files to the specified directory\", uwsgi_opt_set_str, &uwsgi.metrics_dir, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metrics-dir-restore\", no_argument, 0, \"restore last value taken from the metrics dir\", uwsgi_opt_true, &uwsgi.metrics_dir_restore, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metric-dir\", required_argument, 0, \"export metrics as text files to the specified directory\", uwsgi_opt_set_str, &uwsgi.metrics_dir, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metric-dir-restore\", no_argument, 0, \"restore last value taken from the metrics dir\", uwsgi_opt_true, &uwsgi.metrics_dir_restore, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\t{\"metrics-no-cores\", no_argument, 0, \"disable generation of cores-related metrics\", uwsgi_opt_true, &uwsgi.metrics_no_cores, UWSGI_OPT_METRICS|UWSGI_OPT_MASTER},\n\n\t{\"udp\", required_argument, 0, \"run the udp server on the specified address\", uwsgi_opt_set_str, &uwsgi.udp_socket, UWSGI_OPT_MASTER},\n\t{\"stats\", required_argument, 0, \"enable the stats server on the specified address\", uwsgi_opt_set_str, &uwsgi.stats, UWSGI_OPT_MASTER},\n\t{\"stats-server\", required_argument, 0, \"enable the stats server on the specified address\", uwsgi_opt_set_str, &uwsgi.stats, UWSGI_OPT_MASTER},\n\t{\"stats-http\", no_argument, 0, \"prefix stats server json output with http headers\", uwsgi_opt_true, &uwsgi.stats_http, UWSGI_OPT_MASTER},\n\t{\"stats-minified\", no_argument, 0, \"minify statistics json output\", uwsgi_opt_true, &uwsgi.stats_minified, UWSGI_OPT_MASTER},\n\t{\"stats-min\", no_argument, 0, \"minify statistics json output\", uwsgi_opt_true, &uwsgi.stats_minified, UWSGI_OPT_MASTER},\n\t{\"stats-push\", required_argument, 0, \"push the stats json to the specified destination\", uwsgi_opt_add_string_list, &uwsgi.requested_stats_pushers, UWSGI_OPT_MASTER|UWSGI_OPT_METRICS},\n\t{\"stats-pusher-default-freq\", required_argument, 0, \"set the default frequency of stats pushers\", uwsgi_opt_set_int, &uwsgi.stats_pusher_default_freq, UWSGI_OPT_MASTER},\n\t{\"stats-pushers-default-freq\", required_argument, 0, \"set the default frequency of stats pushers\", uwsgi_opt_set_int, &uwsgi.stats_pusher_default_freq, UWSGI_OPT_MASTER},\n\t{\"stats-no-cores\", no_argument, 0, \"disable generation of cores-related stats\", uwsgi_opt_true, &uwsgi.stats_no_cores, UWSGI_OPT_MASTER},\n\t{\"stats-no-metrics\", no_argument, 0, \"do not include metrics in stats output\", uwsgi_opt_true, &uwsgi.stats_no_metrics, UWSGI_OPT_MASTER},\n\t{\"multicast\", required_argument, 0, \"subscribe to specified multicast group\", uwsgi_opt_set_str, &uwsgi.multicast_group, UWSGI_OPT_MASTER},\n\t{\"multicast-ttl\", required_argument, 0, \"set multicast ttl\", uwsgi_opt_set_int, &uwsgi.multicast_ttl, 0},\n\t{\"multicast-loop\", required_argument, 0, \"set multicast loop (default 1)\", uwsgi_opt_set_int, &uwsgi.multicast_loop, 0},\n\n\t{\"master-fifo\", required_argument, 0, \"enable the master fifo\", uwsgi_opt_add_string_list, &uwsgi.master_fifo, UWSGI_OPT_MASTER},\n\n\t{\"notify-socket\", required_argument, 0, \"enable the notification socket\", uwsgi_opt_set_str, &uwsgi.notify_socket, UWSGI_OPT_MASTER},\n\t{\"subscription-notify-socket\", required_argument, 0, \"set the notification socket for subscriptions\", uwsgi_opt_set_str, &uwsgi.subscription_notify_socket, UWSGI_OPT_MASTER},\n\n#ifdef UWSGI_SSL\n\t{\"legion\", required_argument, 0, \"became a member of a legion\", uwsgi_opt_legion, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-mcast\", required_argument, 0, \"became a member of a legion (shortcut for multicast)\", uwsgi_opt_legion_mcast, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-node\", required_argument, 0, \"add a node to a legion\", uwsgi_opt_legion_node, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-freq\", required_argument, 0, \"set the frequency of legion packets\", uwsgi_opt_set_int, &uwsgi.legion_freq, UWSGI_OPT_MASTER},\n\t{\"legion-tolerance\", required_argument, 0, \"set the tolerance of legion subsystem\", uwsgi_opt_set_int, &uwsgi.legion_tolerance, UWSGI_OPT_MASTER},\n\t{\"legion-death-on-lord-error\", required_argument, 0, \"declare itself as a dead node for the specified amount of seconds if one of the lord hooks fails\", uwsgi_opt_set_int, &uwsgi.legion_death_on_lord_error, UWSGI_OPT_MASTER},\n\t{\"legion-skew-tolerance\", required_argument, 0, \"set the clock skew tolerance of legion subsystem (default 30 seconds)\", uwsgi_opt_set_int, &uwsgi.legion_skew_tolerance, UWSGI_OPT_MASTER},\n\t{\"legion-lord\", required_argument, 0, \"action to call on Lord election\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-unlord\", required_argument, 0, \"action to call on Lord dismiss\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-setup\", required_argument, 0, \"action to call on legion setup\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-death\", required_argument, 0, \"action to call on legion death (shutdown of the instance)\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-join\", required_argument, 0, \"action to call on legion join (first time quorum is reached)\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-node-joined\", required_argument, 0, \"action to call on new node joining legion\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-node-left\", required_argument, 0, \"action to call node leaving legion\", uwsgi_opt_legion_hook, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-quorum\", required_argument, 0, \"set the quorum of a legion\", uwsgi_opt_legion_quorum, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-scroll\", required_argument, 0, \"set the scroll of a legion\", uwsgi_opt_legion_scroll, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-scroll-max-size\", required_argument, 0, \"set max size of legion scroll buffer\", uwsgi_opt_set_16bit, &uwsgi.legion_scroll_max_size, 0},\n\t{\"legion-scroll-list-max-size\", required_argument, 0, \"set max size of legion scroll list buffer\", uwsgi_opt_set_64bit, &uwsgi.legion_scroll_list_max_size, 0},\n\t{\"subscriptions-sign-check\", required_argument, 0, \"set digest algorithm and certificate directory for secured subscription system\", uwsgi_opt_scd, NULL, UWSGI_OPT_MASTER},\n\t{\"subscriptions-sign-check-tolerance\", required_argument, 0, \"set the maximum tolerance (in seconds) of clock skew for secured subscription system\", uwsgi_opt_set_int, &uwsgi.subscriptions_sign_check_tolerance, UWSGI_OPT_MASTER},\n\t{\"subscriptions-sign-skip-uid\", required_argument, 0, \"skip signature check for the specified uid when using unix sockets credentials\", uwsgi_opt_add_string_list, &uwsgi.subscriptions_sign_skip_uid, UWSGI_OPT_MASTER},\n#endif\n\t{\"subscriptions-credentials-check\", required_argument, 0, \"add a directory to search for subscriptions key credentials\", uwsgi_opt_add_string_list, &uwsgi.subscriptions_credentials_check_dir, UWSGI_OPT_MASTER},\n\t{\"subscriptions-use-credentials\", no_argument, 0, \"enable management of SCM_CREDENTIALS in subscriptions UNIX sockets\", uwsgi_opt_true, &uwsgi.subscriptions_use_credentials, 0},\n\t{\"subscription-algo\", required_argument, 0, \"set load balancing algorithm for the subscription system\", uwsgi_opt_ssa, NULL, 0},\n\t{\"subscription-dotsplit\", no_argument, 0, \"try to fallback to the next part (dot based) in subscription key\", uwsgi_opt_true, &uwsgi.subscription_dotsplit, 0},\n\t{\"subscribe-to\", required_argument, 0, \"subscribe to the specified subscription server\", uwsgi_opt_add_string_list, &uwsgi.subscriptions, UWSGI_OPT_MASTER},\n\t{\"st\", required_argument, 0, \"subscribe to the specified subscription server\", uwsgi_opt_add_string_list, &uwsgi.subscriptions, UWSGI_OPT_MASTER},\n\t{\"subscribe\", required_argument, 0, \"subscribe to the specified subscription server\", uwsgi_opt_add_string_list, &uwsgi.subscriptions, UWSGI_OPT_MASTER},\n\t{\"subscribe2\", required_argument, 0, \"subscribe to the specified subscription server using advanced keyval syntax\", uwsgi_opt_add_string_list, &uwsgi.subscriptions2, UWSGI_OPT_MASTER},\n\t{\"subscribe-freq\", required_argument, 0, \"send subscription announce at the specified interval\", uwsgi_opt_set_int, &uwsgi.subscribe_freq, 0},\n\t{\"subscription-tolerance\", required_argument, 0, \"set tolerance for subscription servers\", uwsgi_opt_set_int, &uwsgi.subscription_tolerance, 0},\n\t{\"unsubscribe-on-graceful-reload\", no_argument, 0, \"force unsubscribe request even during graceful reload\", uwsgi_opt_true, &uwsgi.unsubscribe_on_graceful_reload, 0},\n\t{\"start-unsubscribed\", no_argument, 0, \"configure subscriptions but do not send them (useful with master fifo)\", uwsgi_opt_true, &uwsgi.subscriptions_blocked, 0},\n\n\t{\"subscribe-with-modifier1\", required_argument, 0, \"force the specififed modifier1 when subscribing\", uwsgi_opt_set_str, &uwsgi.subscribe_with_modifier1, UWSGI_OPT_MASTER},\n\n\t{\"snmp\", optional_argument, 0, \"enable the embedded snmp server\", uwsgi_opt_snmp, NULL, 0},\n\t{\"snmp-community\", required_argument, 0, \"set the snmp community string\", uwsgi_opt_snmp_community, NULL, 0},\n#ifdef UWSGI_SSL\n\t{\"ssl-verbose\", no_argument, 0, \"be verbose about SSL errors\", uwsgi_opt_true, &uwsgi.ssl_verbose, 0},\n\t{\"ssl-verify-depth\", optional_argument, 0, \"set maximum certificate verification depth\", uwsgi_opt_set_int, &uwsgi.ssl_verify_depth, 0},\n#ifdef UWSGI_SSL_SESSION_CACHE\n\t// force master, as ssl sessions caching initialize locking early\n\t{\"ssl-sessions-use-cache\", optional_argument, 0, \"use uWSGI cache for ssl sessions storage\", uwsgi_opt_set_str, &uwsgi.ssl_sessions_use_cache, UWSGI_OPT_MASTER},\n\t{\"ssl-session-use-cache\", optional_argument, 0, \"use uWSGI cache for ssl sessions storage\", uwsgi_opt_set_str, &uwsgi.ssl_sessions_use_cache, UWSGI_OPT_MASTER},\n\t{\"ssl-sessions-timeout\", required_argument, 0, \"set SSL sessions timeout (default: 300 seconds)\", uwsgi_opt_set_int, &uwsgi.ssl_sessions_timeout, 0},\n\t{\"ssl-session-timeout\", required_argument, 0, \"set SSL sessions timeout (default: 300 seconds)\", uwsgi_opt_set_int, &uwsgi.ssl_sessions_timeout, 0},\n#endif\n\t{\"sni\", required_argument, 0, \"add an SNI-governed SSL context\", uwsgi_opt_sni, NULL, 0},\n\t{\"sni-dir\", required_argument, 0, \"check for cert/key/client_ca file in the specified directory and create a sni/ssl context on demand\", uwsgi_opt_set_str, &uwsgi.sni_dir, 0},\n\t{\"sni-dir-ciphers\", required_argument, 0, \"set ssl ciphers for sni-dir option\", uwsgi_opt_set_str, &uwsgi.sni_dir_ciphers, 0},\n\t{\"ssl-enable3\", no_argument, 0, \"enable SSLv3 (insecure)\", uwsgi_opt_true, &uwsgi.sslv3, 0},\n\t{\"ssl-enable-sslv3\", no_argument, 0, \"enable SSLv3 (insecure)\", uwsgi_opt_true, &uwsgi.sslv3, 0},\n\t{\"ssl-enable-tlsv1\", no_argument, 0, \"enable TLSv1 (insecure)\", uwsgi_opt_true, &uwsgi.tlsv1, 0},\n\t{\"ssl-option\", no_argument, 0, \"set a raw ssl option (numeric value)\", uwsgi_opt_add_string_list, &uwsgi.ssl_options, 0},\n#ifdef UWSGI_PCRE\n\t{\"sni-regexp\", required_argument, 0, \"add an SNI-governed SSL context (the key is a regexp)\", uwsgi_opt_sni, NULL, 0},\n#endif\n\t{\"ssl-tmp-dir\", required_argument, 0, \"store ssl-related temp files in the specified directory\", uwsgi_opt_set_str, &uwsgi.ssl_tmp_dir, 0},\n#endif\n\t{\"check-interval\", required_argument, 0, \"set the interval (in seconds) of master checks\", uwsgi_opt_set_int, &uwsgi.master_interval, UWSGI_OPT_MASTER},\n\t{\"forkbomb-delay\", required_argument, 0, \"sleep for the specified number of seconds when a forkbomb is detected\", uwsgi_opt_set_int, &uwsgi.forkbomb_delay, UWSGI_OPT_MASTER},\n\t{\"binary-path\", required_argument, 0, \"force binary path\", uwsgi_opt_set_str, &uwsgi.binary_path, 0},\n\t{\"privileged-binary-patch\", required_argument, 0, \"patch the uwsgi binary with a new command (before privileges drop)\", uwsgi_opt_set_str, &uwsgi.privileged_binary_patch, 0},\n\t{\"unprivileged-binary-patch\", required_argument, 0, \"patch the uwsgi binary with a new command (after privileges drop)\", uwsgi_opt_set_str, &uwsgi.unprivileged_binary_patch, 0},\n\t{\"privileged-binary-patch-arg\", required_argument, 0, \"patch the uwsgi binary with a new command and arguments (before privileges drop)\", uwsgi_opt_set_str, &uwsgi.privileged_binary_patch_arg, 0},\n\t{\"unprivileged-binary-patch-arg\", required_argument, 0, \"patch the uwsgi binary with a new command and arguments (after privileges drop)\", uwsgi_opt_set_str, &uwsgi.unprivileged_binary_patch_arg, 0},\n\t{\"async\", required_argument, 0, \"enable async mode with specified cores\", uwsgi_opt_set_int, &uwsgi.async, 0},\n\t{\"max-fd\", required_argument, 0, \"set maximum number of file descriptors (requires root privileges)\", uwsgi_opt_set_int, &uwsgi.requested_max_fd, 0},\n\t{\"logto\", required_argument, 0, \"set logfile/udp address\", uwsgi_opt_set_str, &uwsgi.logfile, 0},\n\t{\"logto2\", required_argument, 0, \"log to specified file or udp address after privileges drop\", uwsgi_opt_set_str, &uwsgi.logto2, 0},\n\t{\"log-format\", required_argument, 0, \"set advanced format for request logging\", uwsgi_opt_set_str, &uwsgi.logformat, 0},\n\t{\"logformat\", required_argument, 0, \"set advanced format for request logging\", uwsgi_opt_set_str, &uwsgi.logformat, 0},\n\t{\"logformat-strftime\", no_argument, 0, \"apply strftime to logformat output\", uwsgi_opt_true, &uwsgi.logformat_strftime, 0},\n\t{\"log-format-strftime\", no_argument, 0, \"apply strftime to logformat output\", uwsgi_opt_true, &uwsgi.logformat_strftime, 0},\n\t{\"logfile-chown\", no_argument, 0, \"chown logfiles\", uwsgi_opt_true, &uwsgi.logfile_chown, 0},\n\t{\"logfile-chmod\", required_argument, 0, \"chmod logfiles\", uwsgi_opt_logfile_chmod, NULL, 0},\n\t{\"log-syslog\", optional_argument, 0, \"log to syslog\", uwsgi_opt_set_logger, \"syslog\", UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"log-socket\", required_argument, 0, \"send logs to the specified socket\", uwsgi_opt_set_logger, \"socket\", UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"req-logger\", required_argument, 0, \"set/append a request logger\", uwsgi_opt_set_req_logger, NULL, UWSGI_OPT_REQ_LOG_MASTER},\n\t{\"logger-req\", required_argument, 0, \"set/append a request logger\", uwsgi_opt_set_req_logger, NULL, UWSGI_OPT_REQ_LOG_MASTER},\n\t{\"logger\", required_argument, 0, \"set/append a logger\", uwsgi_opt_set_logger, NULL, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"logger-list\", no_argument, 0, \"list enabled loggers\", uwsgi_opt_true, &uwsgi.loggers_list, 0},\n\t{\"loggers-list\", no_argument, 0, \"list enabled loggers\", uwsgi_opt_true, &uwsgi.loggers_list, 0},\n\t{\"threaded-logger\", no_argument, 0, \"offload log writing to a thread\", uwsgi_opt_true, &uwsgi.threaded_logger, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\n\n\t{\"log-encoder\", required_argument, 0, \"add an item in the log encoder chain\", uwsgi_opt_add_string_list, &uwsgi.requested_log_encoders, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"log-req-encoder\", required_argument, 0, \"add an item in the log req encoder chain\", uwsgi_opt_add_string_list, &uwsgi.requested_log_req_encoders, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t\n\n#ifdef UWSGI_PCRE\n\t{\"log-drain\", required_argument, 0, \"drain (do not show) log lines matching the specified regexp\", uwsgi_opt_add_regexp_list, &uwsgi.log_drain_rules, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"log-filter\", required_argument, 0, \"show only log lines matching the specified regexp\", uwsgi_opt_add_regexp_list, &uwsgi.log_filter_rules, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"log-route\", required_argument, 0, \"log to the specified named logger if regexp applied on logline matches\", uwsgi_opt_add_regexp_custom_list, &uwsgi.log_route, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"log-req-route\", required_argument, 0, \"log requests to the specified named logger if regexp applied on logline matches\", uwsgi_opt_add_regexp_custom_list, &uwsgi.log_req_route, UWSGI_OPT_REQ_LOG_MASTER},\n#endif\n\n\t{\"use-abort\", no_argument, 0, \"call abort() on segfault/fpe, could be useful for generating a core dump\", uwsgi_opt_true, &uwsgi.use_abort, 0},\n\n\t{\"alarm\", required_argument, 0, \"create a new alarm, syntax: <alarm> <plugin:args>\", uwsgi_opt_add_string_list, &uwsgi.alarm_list, UWSGI_OPT_MASTER},\n\t{\"alarm-cheap\", required_argument, 0, \"use main alarm thread rather than create dedicated threads for curl-based alarms\", uwsgi_opt_true, &uwsgi.alarm_cheap, 0},\n\t{\"alarm-freq\", required_argument, 0, \"tune the anti-loop alarm system (default 3 seconds)\", uwsgi_opt_set_int, &uwsgi.alarm_freq, 0},\n\t{\"alarm-fd\", required_argument, 0, \"raise the specified alarm when an fd is read for read (by default it reads 1 byte, set 8 for eventfd)\", uwsgi_opt_add_string_list, &uwsgi.alarm_fd_list, UWSGI_OPT_MASTER},\n\t{\"alarm-segfault\", required_argument, 0, \"raise the specified alarm when the segmentation fault handler is executed\", uwsgi_opt_add_string_list, &uwsgi.alarm_segfault, UWSGI_OPT_MASTER},\n\t{\"segfault-alarm\", required_argument, 0, \"raise the specified alarm when the segmentation fault handler is executed\", uwsgi_opt_add_string_list, &uwsgi.alarm_segfault, UWSGI_OPT_MASTER},\n\t{\"alarm-backlog\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n\t{\"backlog-alarm\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n\t{\"lq-alarm\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n\t{\"alarm-lq\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n\t{\"alarm-listen-queue\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n\t{\"listen-queue-alarm\", required_argument, 0, \"raise the specified alarm when the socket backlog queue is full\", uwsgi_opt_add_string_list, &uwsgi.alarm_backlog, UWSGI_OPT_MASTER},\n#ifdef UWSGI_PCRE\n\t{\"log-alarm\", required_argument, 0, \"raise the specified alarm when a log line matches the specified regexp, syntax: <alarm>[,alarm...] <regexp>\", uwsgi_opt_add_string_list, &uwsgi.alarm_logs_list, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"alarm-log\", required_argument, 0, \"raise the specified alarm when a log line matches the specified regexp, syntax: <alarm>[,alarm...] <regexp>\", uwsgi_opt_add_string_list, &uwsgi.alarm_logs_list, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"not-log-alarm\", required_argument, 0, \"skip the specified alarm when a log line matches the specified regexp, syntax: <alarm>[,alarm...] <regexp>\", uwsgi_opt_add_string_list_custom, &uwsgi.alarm_logs_list, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n\t{\"not-alarm-log\", required_argument, 0, \"skip the specified alarm when a log line matches the specified regexp, syntax: <alarm>[,alarm...] <regexp>\", uwsgi_opt_add_string_list_custom, &uwsgi.alarm_logs_list, UWSGI_OPT_MASTER | UWSGI_OPT_LOG_MASTER},\n#endif\n\t{\"alarm-list\", no_argument, 0, \"list enabled alarms\", uwsgi_opt_true, &uwsgi.alarms_list, 0},\n\t{\"alarms-list\", no_argument, 0, \"list enabled alarms\", uwsgi_opt_true, &uwsgi.alarms_list, 0},\n\t{\"alarm-msg-size\", required_argument, 0, \"set the max size of an alarm message (default 8192)\", uwsgi_opt_set_64bit, &uwsgi.alarm_msg_size, 0},\n\t{\"log-master\", no_argument, 0, \"delegate logging to master process\", uwsgi_opt_true, &uwsgi.log_master, UWSGI_OPT_MASTER|UWSGI_OPT_LOG_MASTER},\n\t{\"log-master-bufsize\", required_argument, 0, \"set the buffer size for the master logger. bigger log messages will be truncated\", uwsgi_opt_set_64bit, &uwsgi.log_master_bufsize, 0},\n\t{\"log-master-stream\", no_argument, 0, \"create the master logpipe as SOCK_STREAM\", uwsgi_opt_true, &uwsgi.log_master_stream, 0},\n\t{\"log-master-req-stream\", no_argument, 0, \"create the master requests logpipe as SOCK_STREAM\", uwsgi_opt_true, &uwsgi.log_master_req_stream, 0},\n\t{\"log-reopen\", no_argument, 0, \"reopen log after reload\", uwsgi_opt_true, &uwsgi.log_reopen, 0},\n\t{\"log-truncate\", no_argument, 0, \"truncate log on startup\", uwsgi_opt_true, &uwsgi.log_truncate, 0},\n\t{\"log-maxsize\", required_argument, 0, \"set maximum logfile size\", uwsgi_opt_set_64bit, &uwsgi.log_maxsize, UWSGI_OPT_MASTER|UWSGI_OPT_LOG_MASTER},\n\t{\"log-backupname\", required_argument, 0, \"set logfile name after rotation\", uwsgi_opt_set_str, &uwsgi.log_backupname, 0},\n\n\t{\"logdate\", optional_argument, 0, \"prefix logs with date or a strftime string\", uwsgi_opt_log_date, NULL, 0},\n\t{\"log-date\", optional_argument, 0, \"prefix logs with date or a strftime string\", uwsgi_opt_log_date, NULL, 0},\n\t{\"log-prefix\", optional_argument, 0, \"prefix logs with a string\", uwsgi_opt_log_date, NULL, 0},\n\n\t{\"log-zero\", no_argument, 0, \"log responses without body\", uwsgi_opt_true, &uwsgi.logging_options.zero, 0},\n\t{\"log-slow\", required_argument, 0, \"log requests slower than the specified number of milliseconds\", uwsgi_opt_set_int, &uwsgi.logging_options.slow, 0},\n\t{\"log-4xx\", no_argument, 0, \"log requests with a 4xx response\", uwsgi_opt_true, &uwsgi.logging_options._4xx, 0},\n\t{\"log-5xx\", no_argument, 0, \"log requests with a 5xx response\", uwsgi_opt_true, &uwsgi.logging_options._5xx, 0},\n\t{\"log-big\", required_argument, 0, \"log requestes bigger than the specified size\", uwsgi_opt_set_64bit,  &uwsgi.logging_options.big, 0},\n\t{\"log-sendfile\", required_argument, 0, \"log sendfile requests\", uwsgi_opt_true, &uwsgi.logging_options.sendfile, 0},\n\t{\"log-ioerror\", required_argument, 0, \"log requests with io errors\", uwsgi_opt_true, &uwsgi.logging_options.ioerror, 0},\n\t{\"log-micros\", no_argument, 0, \"report response time in microseconds instead of milliseconds\", uwsgi_opt_true, &uwsgi.log_micros, 0},\n\t{\"log-x-forwarded-for\", no_argument, 0, \"use the ip from X-Forwarded-For header instead of REMOTE_ADDR\", uwsgi_opt_true, &uwsgi.logging_options.log_x_forwarded_for, 0},\n\t{\"master-as-root\", no_argument, 0, \"leave master process running as root\", uwsgi_opt_true, &uwsgi.master_as_root, 0},\n\n\t{\"drop-after-init\", no_argument, 0, \"run privileges drop after plugin initialization, superseded by drop-after-apps\", uwsgi_opt_true, &uwsgi.drop_after_init, 0},\n\t{\"drop-after-apps\", no_argument, 0, \"run privileges drop after apps loading, superseded by master-as-root\", uwsgi_opt_true, &uwsgi.drop_after_apps, 0},\n\n\t{\"force-cwd\", required_argument, 0, \"force the initial working directory to the specified value\", uwsgi_opt_set_str, &uwsgi.force_cwd, 0},\n\t{\"binsh\", required_argument, 0, \"override /bin/sh (used by exec hooks, it always fallback to /bin/sh)\", uwsgi_opt_add_string_list, &uwsgi.binsh, 0},\n\t{\"chdir\", required_argument, 0, \"chdir to specified directory before apps loading\", uwsgi_opt_set_str, &uwsgi.chdir, 0},\n\t{\"chdir2\", required_argument, 0, \"chdir to specified directory after apps loading\", uwsgi_opt_set_str, &uwsgi.chdir2, 0},\n\t{\"lazy\", no_argument, 0, \"set lazy mode (load apps in workers instead of master)\", uwsgi_opt_true, &uwsgi.lazy, 0},\n\t{\"lazy-apps\", no_argument, 0, \"load apps in each worker instead of the master\", uwsgi_opt_true, &uwsgi.lazy_apps, 0},\n\t{\"cheap\", no_argument, 0, \"set cheap mode (spawn workers only after the first request)\", uwsgi_opt_true, &uwsgi.status.is_cheap, UWSGI_OPT_MASTER},\n\t{\"cheaper\", required_argument, 0, \"set cheaper mode (adaptive process spawning)\", uwsgi_opt_set_int, &uwsgi.cheaper_count, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"cheaper-initial\", required_argument, 0, \"set the initial number of processes to spawn in cheaper mode\", uwsgi_opt_set_int, &uwsgi.cheaper_initial, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"cheaper-algo\", required_argument, 0, \"choose to algorithm used for adaptive process spawning\", uwsgi_opt_set_str, &uwsgi.requested_cheaper_algo, UWSGI_OPT_MASTER},\n\t{\"cheaper-step\", required_argument, 0, \"number of additional processes to spawn at each overload\", uwsgi_opt_set_int, &uwsgi.cheaper_step, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"cheaper-overload\", required_argument, 0, \"increase workers after specified overload\", uwsgi_opt_set_64bit, &uwsgi.cheaper_overload, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"cheaper-algo-list\", no_argument, 0, \"list enabled cheapers algorithms\", uwsgi_opt_true, &uwsgi.cheaper_algo_list, 0},\n\t{\"cheaper-algos-list\", no_argument, 0, \"list enabled cheapers algorithms\", uwsgi_opt_true, &uwsgi.cheaper_algo_list, 0},\n\t{\"cheaper-list\", no_argument, 0, \"list enabled cheapers algorithms\", uwsgi_opt_true, &uwsgi.cheaper_algo_list, 0},\n\t{\"cheaper-rss-limit-soft\", required_argument, 0, \"don't spawn new workers if total resident memory usage of all workers is higher than this limit\", uwsgi_opt_set_64bit, &uwsgi.cheaper_rss_limit_soft, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"cheaper-rss-limit-hard\", required_argument, 0, \"if total workers resident memory usage is higher try to stop workers\", uwsgi_opt_set_64bit, &uwsgi.cheaper_rss_limit_hard, UWSGI_OPT_MASTER | UWSGI_OPT_CHEAPER},\n\t{\"idle\", required_argument, 0, \"set idle mode (put uWSGI in cheap mode after inactivity)\", uwsgi_opt_set_int, &uwsgi.idle, UWSGI_OPT_MASTER},\n\t{\"die-on-idle\", no_argument, 0, \"shutdown uWSGI when idle\", uwsgi_opt_true, &uwsgi.die_on_idle, 0},\n\t{\"mount\", required_argument, 0, \"load application under mountpoint\", uwsgi_opt_add_string_list, &uwsgi.mounts, 0},\n\t{\"worker-mount\", required_argument, 0, \"load application under mountpoint in the specified worker or after workers spawn\", uwsgi_opt_add_string_list, &uwsgi.mounts, 0},\n\n\t{\"threads\", required_argument, 0, \"run each worker in prethreaded mode with the specified number of threads\", uwsgi_opt_set_int, &uwsgi.threads, UWSGI_OPT_THREADS},\n\t{\"thread-stacksize\", required_argument, 0, \"set threads stacksize\", uwsgi_opt_set_int, &uwsgi.threads_stacksize, UWSGI_OPT_THREADS},\n\t{\"threads-stacksize\", required_argument, 0, \"set threads stacksize\", uwsgi_opt_set_int, &uwsgi.threads_stacksize, UWSGI_OPT_THREADS},\n\t{\"thread-stack-size\", required_argument, 0, \"set threads stacksize\", uwsgi_opt_set_int, &uwsgi.threads_stacksize, UWSGI_OPT_THREADS},\n\t{\"threads-stack-size\", required_argument, 0, \"set threads stacksize\", uwsgi_opt_set_int, &uwsgi.threads_stacksize, UWSGI_OPT_THREADS},\n\n\t{\"vhost\", no_argument, 0, \"enable virtualhosting mode (based on SERVER_NAME variable)\", uwsgi_opt_true, &uwsgi.vhost, 0},\n\t{\"vhost-host\", no_argument, 0, \"enable virtualhosting mode (based on HTTP_HOST variable)\", uwsgi_opt_true, &uwsgi.vhost_host, UWSGI_OPT_VHOST},\n#ifdef UWSGI_ROUTING\n\t{\"route\", required_argument, 0, \"add a route\", uwsgi_opt_add_route, \"path_info\", 0},\n\t{\"route-host\", required_argument, 0, \"add a route based on Host header\", uwsgi_opt_add_route, \"http_host\", 0},\n\t{\"route-uri\", required_argument, 0, \"add a route based on REQUEST_URI\", uwsgi_opt_add_route, \"request_uri\", 0},\n\t{\"route-qs\", required_argument, 0, \"add a route based on QUERY_STRING\", uwsgi_opt_add_route, \"query_string\", 0},\n\t{\"route-remote-addr\", required_argument, 0, \"add a route based on REMOTE_ADDR\", uwsgi_opt_add_route, \"remote_addr\", 0},\n\t{\"route-user-agent\", required_argument, 0, \"add a route based on HTTP_USER_AGENT\", uwsgi_opt_add_route, \"user_agent\", 0},\n\t{\"route-remote-user\", required_argument, 0, \"add a route based on REMOTE_USER\", uwsgi_opt_add_route, \"remote_user\", 0},\n\t{\"route-referer\", required_argument, 0, \"add a route based on HTTP_REFERER\", uwsgi_opt_add_route, \"referer\", 0},\n\t{\"route-label\", required_argument, 0, \"add a routing label (for use with goto)\", uwsgi_opt_add_route, NULL, 0},\n\t{\"route-if\", required_argument, 0, \"add a route based on condition\", uwsgi_opt_add_route, \"if\", 0},\n\t{\"route-if-not\", required_argument, 0, \"add a route based on condition (negate version)\", uwsgi_opt_add_route, \"if-not\", 0},\n\t{\"route-run\", required_argument, 0, \"always run the specified route action\", uwsgi_opt_add_route, \"run\", 0},\n\n\n\n\t{\"final-route\", required_argument, 0, \"add a final route\", uwsgi_opt_add_route, \"path_info\", 0},\n\t{\"final-route-status\", required_argument, 0, \"add a final route for the specified status\", uwsgi_opt_add_route, \"status\", 0},\n        {\"final-route-host\", required_argument, 0, \"add a final route based on Host header\", uwsgi_opt_add_route, \"http_host\", 0},\n        {\"final-route-uri\", required_argument, 0, \"add a final route based on REQUEST_URI\", uwsgi_opt_add_route, \"request_uri\", 0},\n        {\"final-route-qs\", required_argument, 0, \"add a final route based on QUERY_STRING\", uwsgi_opt_add_route, \"query_string\", 0},\n        {\"final-route-remote-addr\", required_argument, 0, \"add a final route based on REMOTE_ADDR\", uwsgi_opt_add_route, \"remote_addr\", 0},\n        {\"final-route-user-agent\", required_argument, 0, \"add a final route based on HTTP_USER_AGENT\", uwsgi_opt_add_route, \"user_agent\", 0},\n        {\"final-route-remote-user\", required_argument, 0, \"add a final route based on REMOTE_USER\", uwsgi_opt_add_route, \"remote_user\", 0},\n        {\"final-route-referer\", required_argument, 0, \"add a final route based on HTTP_REFERER\", uwsgi_opt_add_route, \"referer\", 0},\n        {\"final-route-label\", required_argument, 0, \"add a final routing label (for use with goto)\", uwsgi_opt_add_route, NULL, 0},\n        {\"final-route-if\", required_argument, 0, \"add a final route based on condition\", uwsgi_opt_add_route, \"if\", 0},\n        {\"final-route-if-not\", required_argument, 0, \"add a final route based on condition (negate version)\", uwsgi_opt_add_route, \"if-not\", 0},\n        {\"final-route-run\", required_argument, 0, \"always run the specified final route action\", uwsgi_opt_add_route, \"run\", 0},\n\n\t{\"error-route\", required_argument, 0, \"add an error route\", uwsgi_opt_add_route, \"path_info\", 0},\n\t{\"error-route-status\", required_argument, 0, \"add an error route for the specified status\", uwsgi_opt_add_route, \"status\", 0},\n        {\"error-route-host\", required_argument, 0, \"add an error route based on Host header\", uwsgi_opt_add_route, \"http_host\", 0},\n        {\"error-route-uri\", required_argument, 0, \"add an error route based on REQUEST_URI\", uwsgi_opt_add_route, \"request_uri\", 0},\n        {\"error-route-qs\", required_argument, 0, \"add an error route based on QUERY_STRING\", uwsgi_opt_add_route, \"query_string\", 0},\n        {\"error-route-remote-addr\", required_argument, 0, \"add an error route based on REMOTE_ADDR\", uwsgi_opt_add_route, \"remote_addr\", 0},\n        {\"error-route-user-agent\", required_argument, 0, \"add an error route based on HTTP_USER_AGENT\", uwsgi_opt_add_route, \"user_agent\", 0},\n        {\"error-route-remote-user\", required_argument, 0, \"add an error route based on REMOTE_USER\", uwsgi_opt_add_route, \"remote_user\", 0},\n        {\"error-route-referer\", required_argument, 0, \"add an error route based on HTTP_REFERER\", uwsgi_opt_add_route, \"referer\", 0},\n        {\"error-route-label\", required_argument, 0, \"add an error routing label (for use with goto)\", uwsgi_opt_add_route, NULL, 0},\n        {\"error-route-if\", required_argument, 0, \"add an error route based on condition\", uwsgi_opt_add_route, \"if\", 0},\n        {\"error-route-if-not\", required_argument, 0, \"add an error route based on condition (negate version)\", uwsgi_opt_add_route, \"if-not\", 0},\n        {\"error-route-run\", required_argument, 0, \"always run the specified error route action\", uwsgi_opt_add_route, \"run\", 0},\n\n\t{\"response-route\", required_argument, 0, \"add a response route\", uwsgi_opt_add_route, \"path_info\", 0},\n        {\"response-route-status\", required_argument, 0, \"add a response route for the specified status\", uwsgi_opt_add_route, \"status\", 0},\n        {\"response-route-host\", required_argument, 0, \"add a response route based on Host header\", uwsgi_opt_add_route, \"http_host\", 0},\n        {\"response-route-uri\", required_argument, 0, \"add a response route based on REQUEST_URI\", uwsgi_opt_add_route, \"request_uri\", 0},\n        {\"response-route-qs\", required_argument, 0, \"add a response route based on QUERY_STRING\", uwsgi_opt_add_route, \"query_string\", 0},\n        {\"response-route-remote-addr\", required_argument, 0, \"add a response route based on REMOTE_ADDR\", uwsgi_opt_add_route, \"remote_addr\", 0},\n        {\"response-route-user-agent\", required_argument, 0, \"add a response route based on HTTP_USER_AGENT\", uwsgi_opt_add_route, \"user_agent\", 0},\n        {\"response-route-remote-user\", required_argument, 0, \"add a response route based on REMOTE_USER\", uwsgi_opt_add_route, \"remote_user\", 0},\n        {\"response-route-referer\", required_argument, 0, \"add a response route based on HTTP_REFERER\", uwsgi_opt_add_route, \"referer\", 0},\n        {\"response-route-label\", required_argument, 0, \"add a response routing label (for use with goto)\", uwsgi_opt_add_route, NULL, 0},\n        {\"response-route-if\", required_argument, 0, \"add a response route based on condition\", uwsgi_opt_add_route, \"if\", 0},\n        {\"response-route-if-not\", required_argument, 0, \"add a response route based on condition (negate version)\", uwsgi_opt_add_route, \"if-not\", 0},\n        {\"response-route-run\", required_argument, 0, \"always run the specified response route action\", uwsgi_opt_add_route, \"run\", 0},\n\n\t{\"router-list\", no_argument, 0, \"list enabled routers\", uwsgi_opt_true, &uwsgi.router_list, 0},\n\t{\"routers-list\", no_argument, 0, \"list enabled routers\", uwsgi_opt_true, &uwsgi.router_list, 0},\n#endif\n\n\n\t{\"error-page-403\", required_argument, 0, \"add an error page (html) for managed 403 response\", uwsgi_opt_add_string_list, &uwsgi.error_page_403, 0},\n\t{\"error-page-404\", required_argument, 0, \"add an error page (html) for managed 404 response\", uwsgi_opt_add_string_list, &uwsgi.error_page_404, 0},\n\t{\"error-page-500\", required_argument, 0, \"add an error page (html) for managed 500 response\", uwsgi_opt_add_string_list, &uwsgi.error_page_500, 0},\n\n\t{\"websockets-ping-freq\", required_argument, 0, \"set the frequency (in seconds) of websockets automatic ping packets\", uwsgi_opt_set_int, &uwsgi.websockets_ping_freq, 0},\n\t{\"websocket-ping-freq\", required_argument, 0, \"set the frequency (in seconds) of websockets automatic ping packets\", uwsgi_opt_set_int, &uwsgi.websockets_ping_freq, 0},\n\n\t{\"websockets-pong-tolerance\", required_argument, 0, \"set the tolerance (in seconds) of websockets ping/pong subsystem\", uwsgi_opt_set_int, &uwsgi.websockets_pong_tolerance, 0},\n\t{\"websocket-pong-tolerance\", required_argument, 0, \"set the tolerance (in seconds) of websockets ping/pong subsystem\", uwsgi_opt_set_int, &uwsgi.websockets_pong_tolerance, 0},\n\n\t{\"websockets-max-size\", required_argument, 0, \"set the max allowed size of websocket messages (in Kbytes, default 1024)\", uwsgi_opt_set_64bit, &uwsgi.websockets_max_size, 0},\n\t{\"websocket-max-size\", required_argument, 0, \"set the max allowed size of websocket messages (in Kbytes, default 1024)\", uwsgi_opt_set_64bit, &uwsgi.websockets_max_size, 0},\n\n\t{\"chunked-input-limit\", required_argument, 0, \"set the max size of a chunked input part (default 1MB, in bytes)\", uwsgi_opt_set_64bit, &uwsgi.chunked_input_limit, 0},\n\t{\"chunked-input-timeout\", required_argument, 0, \"set default timeout for chunked input\", uwsgi_opt_set_int, &uwsgi.chunked_input_timeout, 0},\n\n\t{\"clock\", required_argument, 0, \"set a clock source\", uwsgi_opt_set_str, &uwsgi.requested_clock, 0},\n\n\t{\"clock-list\", no_argument, 0, \"list enabled clocks\", uwsgi_opt_true, &uwsgi.clock_list, 0},\n\t{\"clocks-list\", no_argument, 0, \"list enabled clocks\", uwsgi_opt_true, &uwsgi.clock_list, 0},\n\n\t{\"add-header\", required_argument, 0, \"automatically add HTTP headers to response\", uwsgi_opt_add_string_list, &uwsgi.additional_headers, 0},\n\t{\"rem-header\", required_argument, 0, \"automatically remove specified HTTP header from the response\", uwsgi_opt_add_string_list, &uwsgi.remove_headers, 0},\n\t{\"del-header\", required_argument, 0, \"automatically remove specified HTTP header from the response\", uwsgi_opt_add_string_list, &uwsgi.remove_headers, 0},\n\t{\"collect-header\", required_argument, 0, \"store the specified response header in a request var (syntax: header var)\", uwsgi_opt_add_string_list, &uwsgi.collect_headers, 0},\n\t{\"response-header-collect\", required_argument, 0, \"store the specified response header in a request var (syntax: header var)\", uwsgi_opt_add_string_list, &uwsgi.collect_headers, 0},\n\n\t{\"pull-header\", required_argument, 0, \"store the specified response header in a request var and remove it from the response (syntax: header var)\", uwsgi_opt_add_string_list, &uwsgi.pull_headers, 0},\n\n\t{\"check-static\", required_argument, 0, \"check for static files in the specified directory\", uwsgi_opt_check_static, NULL, UWSGI_OPT_MIME},\n\t{\"check-static-docroot\", no_argument, 0, \"check for static files in the requested DOCUMENT_ROOT\", uwsgi_opt_true, &uwsgi.check_static_docroot, UWSGI_OPT_MIME},\n\t{\"static-check\", required_argument, 0, \"check for static files in the specified directory\", uwsgi_opt_check_static, NULL, UWSGI_OPT_MIME},\n\t{\"static-map\", required_argument, 0, \"map mountpoint to static directory (or file)\", uwsgi_opt_static_map, &uwsgi.static_maps, UWSGI_OPT_MIME},\n\t{\"static-map2\", required_argument, 0, \"like static-map but completely appending the requested resource to the docroot\", uwsgi_opt_static_map, &uwsgi.static_maps2, UWSGI_OPT_MIME},\n\t{\"static-skip-ext\", required_argument, 0, \"skip specified extension from staticfile checks\", uwsgi_opt_add_string_list, &uwsgi.static_skip_ext, UWSGI_OPT_MIME},\n\t{\"static-index\", required_argument, 0, \"search for specified file if a directory is requested\", uwsgi_opt_add_string_list, &uwsgi.static_index, UWSGI_OPT_MIME},\n\t{\"static-safe\", required_argument, 0, \"skip security checks if the file is under the specified path\", uwsgi_opt_add_string_list, &uwsgi.static_safe, UWSGI_OPT_MIME},\n\t{\"static-cache-paths\", required_argument, 0, \"put resolved paths in the uWSGI cache for the specified amount of seconds\", uwsgi_opt_set_int, &uwsgi.use_static_cache_paths, UWSGI_OPT_MIME|UWSGI_OPT_MASTER},\n\t{\"static-cache-paths-name\", required_argument, 0, \"use the specified cache for static paths\", uwsgi_opt_set_str, &uwsgi.static_cache_paths_name, UWSGI_OPT_MIME|UWSGI_OPT_MASTER},\n#ifdef __APPLE__\n\t{\"mimefile\", required_argument, 0, \"set mime types file path (default /etc/apache2/mime.types)\", uwsgi_opt_add_string_list, &uwsgi.mime_file, UWSGI_OPT_MIME},\n\t{\"mime-file\", required_argument, 0, \"set mime types file path (default /etc/apache2/mime.types)\", uwsgi_opt_add_string_list, &uwsgi.mime_file, UWSGI_OPT_MIME},\n#else\n\t{\"mimefile\", required_argument, 0, \"set mime types file path (default /etc/mime.types)\", uwsgi_opt_add_string_list, &uwsgi.mime_file, UWSGI_OPT_MIME},\n\t{\"mime-file\", required_argument, 0, \"set mime types file path (default /etc/mime.types)\", uwsgi_opt_add_string_list, &uwsgi.mime_file, UWSGI_OPT_MIME},\n#endif\n\n\t{\"static-expires-type\", required_argument, 0, \"set the Expires header based on content type\", uwsgi_opt_add_dyn_dict, &uwsgi.static_expires_type, UWSGI_OPT_MIME},\n\t{\"static-expires-type-mtime\", required_argument, 0, \"set the Expires header based on content type and file mtime\", uwsgi_opt_add_dyn_dict, &uwsgi.static_expires_type_mtime, UWSGI_OPT_MIME},\n\n#ifdef UWSGI_PCRE\n\t{\"static-expires\", required_argument, 0, \"set the Expires header based on filename regexp\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires, UWSGI_OPT_MIME},\n\t{\"static-expires-mtime\", required_argument, 0, \"set the Expires header based on filename regexp and file mtime\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires_mtime, UWSGI_OPT_MIME},\n\n\t{\"static-expires-uri\", required_argument, 0, \"set the Expires header based on REQUEST_URI regexp\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires_uri, UWSGI_OPT_MIME},\n\t{\"static-expires-uri-mtime\", required_argument, 0, \"set the Expires header based on REQUEST_URI regexp and file mtime\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires_uri_mtime, UWSGI_OPT_MIME},\n\n\t{\"static-expires-path-info\", required_argument, 0, \"set the Expires header based on PATH_INFO regexp\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires_path_info, UWSGI_OPT_MIME},\n\t{\"static-expires-path-info-mtime\", required_argument, 0, \"set the Expires header based on PATH_INFO regexp and file mtime\", uwsgi_opt_add_regexp_dyn_dict, &uwsgi.static_expires_path_info_mtime, UWSGI_OPT_MIME},\n\t{\"static-gzip\", required_argument, 0, \"if the supplied regexp matches the static file translation it will search for a gzip version\", uwsgi_opt_add_regexp_list, &uwsgi.static_gzip, UWSGI_OPT_MIME},\n#endif\n\t{\"static-gzip-all\", no_argument, 0, \"check for a gzip version of all requested static files\", uwsgi_opt_true, &uwsgi.static_gzip_all, UWSGI_OPT_MIME},\n\t{\"static-gzip-dir\", required_argument, 0, \"check for a gzip version of all requested static files in the specified dir/prefix\", uwsgi_opt_add_string_list, &uwsgi.static_gzip_dir, UWSGI_OPT_MIME},\n\t{\"static-gzip-prefix\", required_argument, 0, \"check for a gzip version of all requested static files in the specified dir/prefix\", uwsgi_opt_add_string_list, &uwsgi.static_gzip_dir, UWSGI_OPT_MIME},\n\t{\"static-gzip-ext\", required_argument, 0, \"check for a gzip version of all requested static files with the specified ext/suffix\", uwsgi_opt_add_string_list, &uwsgi.static_gzip_ext, UWSGI_OPT_MIME},\n\t{\"static-gzip-suffix\", required_argument, 0, \"check for a gzip version of all requested static files with the specified ext/suffix\", uwsgi_opt_add_string_list, &uwsgi.static_gzip_ext, UWSGI_OPT_MIME},\n\n\t{\"honour-range\", no_argument, 0, \"enable support for the HTTP Range header\", uwsgi_opt_true, &uwsgi.honour_range, 0},\n\n\t{\"offload-threads\", required_argument, 0, \"set the number of offload threads to spawn (per-worker, default 0)\", uwsgi_opt_set_int, &uwsgi.offload_threads, 0},\n\t{\"offload-thread\", required_argument, 0, \"set the number of offload threads to spawn (per-worker, default 0)\", uwsgi_opt_set_int, &uwsgi.offload_threads, 0},\n\n\t{\"file-serve-mode\", required_argument, 0, \"set static file serving mode\", uwsgi_opt_fileserve_mode, NULL, UWSGI_OPT_MIME},\n\t{\"fileserve-mode\", required_argument, 0, \"set static file serving mode\", uwsgi_opt_fileserve_mode, NULL, UWSGI_OPT_MIME},\n\n\t{\"disable-sendfile\", no_argument, 0, \"disable sendfile() and rely on boring read()/write()\", uwsgi_opt_true, &uwsgi.disable_sendfile, 0},\n\n\t{\"check-cache\", optional_argument, 0, \"check for response data in the specified cache (empty for default cache)\", uwsgi_opt_set_str, &uwsgi.use_check_cache, 0},\n\t{\"close-on-exec\", no_argument, 0, \"set close-on-exec on connection sockets (could be required for spawning processes in requests)\", uwsgi_opt_true, &uwsgi.close_on_exec, 0},\n\t{\"close-on-exec2\", no_argument, 0, \"set close-on-exec on server sockets (could be required for spawning processes in requests)\", uwsgi_opt_true, &uwsgi.close_on_exec2, 0},\n\t{\"mode\", required_argument, 0, \"set uWSGI custom mode\", uwsgi_opt_set_str, &uwsgi.mode, 0},\n\t{\"env\", required_argument, 0, \"set environment variable\", uwsgi_opt_set_env, NULL, 0},\n\t{\"envdir\", required_argument, 0, \"load a daemontools compatible envdir\", uwsgi_opt_add_string_list, &uwsgi.envdirs, 0},\n\t{\"early-envdir\", required_argument, 0, \"load a daemontools compatible envdir ASAP\", uwsgi_opt_envdir, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"unenv\", required_argument, 0, \"unset environment variable\", uwsgi_opt_unset_env, NULL, 0},\n\t{\"vacuum\", no_argument, 0, \"try to remove all of the generated file/sockets\", uwsgi_opt_true, &uwsgi.vacuum, 0},\n\t{\"file-write\", required_argument, 0, \"write the specified content to the specified file (syntax: file=value) before privileges drop\", uwsgi_opt_add_string_list, &uwsgi.file_write_list, 0},\n#ifdef __linux__\n\t{\"cgroup\", required_argument, 0, \"put the processes in the specified cgroup\", uwsgi_opt_add_string_list, &uwsgi.cgroup, 0},\n\t{\"cgroup-opt\", required_argument, 0, \"set value in specified cgroup option\", uwsgi_opt_add_string_list, &uwsgi.cgroup_opt, 0},\n\t{\"cgroup-dir-mode\", required_argument, 0, \"set permission for cgroup directory (default is 700)\", uwsgi_opt_set_str, &uwsgi.cgroup_dir_mode, 0},\n\t{\"namespace\", required_argument, 0, \"run in a new namespace under the specified rootfs\", uwsgi_opt_set_str, &uwsgi.ns, 0},\n\t{\"namespace-keep-mount\", required_argument, 0, \"keep the specified mountpoint in your namespace\", uwsgi_opt_add_string_list, &uwsgi.ns_keep_mount, 0},\n\t{\"ns\", required_argument, 0, \"run in a new namespace under the specified rootfs\", uwsgi_opt_set_str, &uwsgi.ns, 0},\n\t{\"namespace-net\", required_argument, 0, \"add network namespace\", uwsgi_opt_set_str, &uwsgi.ns_net, 0},\n\t{\"ns-net\", required_argument, 0, \"add network namespace\", uwsgi_opt_set_str, &uwsgi.ns_net, 0},\n#endif\n\t{\"enable-proxy-protocol\", no_argument, 0, \"enable PROXY1 protocol support (only for http parsers)\", uwsgi_opt_true, &uwsgi.enable_proxy_protocol, 0},\n\t{\"reuse-port\", no_argument, 0, \"enable REUSE_PORT flag on socket (BSD only)\", uwsgi_opt_true, &uwsgi.reuse_port, 0},\n\t{\"tcp-fast-open\", required_argument, 0, \"enable TCP_FASTOPEN flag on TCP sockets with the specified qlen value\", uwsgi_opt_set_int, &uwsgi.tcp_fast_open, 0},\n\t{\"tcp-fastopen\", required_argument, 0, \"enable TCP_FASTOPEN flag on TCP sockets with the specified qlen value\", uwsgi_opt_set_int, &uwsgi.tcp_fast_open, 0},\n\t{\"tcp-fast-open-client\", no_argument, 0, \"use sendto(..., MSG_FASTOPEN, ...) instead of connect() if supported\", uwsgi_opt_true, &uwsgi.tcp_fast_open_client, 0},\n\t{\"tcp-fastopen-client\", no_argument, 0, \"use sendto(..., MSG_FASTOPEN, ...) instead of connect() if supported\", uwsgi_opt_true, &uwsgi.tcp_fast_open_client, 0},\n\t{\"zerg\", required_argument, 0, \"attach to a zerg server\", uwsgi_opt_add_string_list, &uwsgi.zerg_node, 0},\n\t{\"zerg-fallback\", no_argument, 0, \"fallback to normal sockets if the zerg server is not available\", uwsgi_opt_true, &uwsgi.zerg_fallback, 0},\n\t{\"zerg-server\", required_argument, 0, \"enable the zerg server on the specified UNIX socket\", uwsgi_opt_set_str, &uwsgi.zerg_server, UWSGI_OPT_MASTER},\n\n\t{\"cron\", required_argument, 0, \"add a cron task\", uwsgi_opt_add_cron, NULL, UWSGI_OPT_MASTER},\n\t{\"cron2\", required_argument, 0, \"add a cron task (key=val syntax)\", uwsgi_opt_add_cron2, NULL, UWSGI_OPT_MASTER},\n\t{\"unique-cron\", required_argument, 0, \"add a unique cron task\", uwsgi_opt_add_unique_cron, NULL, UWSGI_OPT_MASTER},\n\t{\"cron-harakiri\", required_argument, 0, \"set the maximum time (in seconds) we wait for cron command to complete\", uwsgi_opt_set_int, &uwsgi.cron_harakiri, 0},\n#ifdef UWSGI_SSL\n\t{\"legion-cron\", required_argument, 0, \"add a cron task runnable only when the instance is a lord of the specified legion\", uwsgi_opt_add_legion_cron, NULL, UWSGI_OPT_MASTER},\n\t{\"cron-legion\", required_argument, 0, \"add a cron task runnable only when the instance is a lord of the specified legion\", uwsgi_opt_add_legion_cron, NULL, UWSGI_OPT_MASTER},\n\t{\"unique-legion-cron\", required_argument, 0, \"add a unique cron task runnable only when the instance is a lord of the specified legion\", uwsgi_opt_add_unique_legion_cron, NULL, UWSGI_OPT_MASTER},\n\t{\"unique-cron-legion\", required_argument, 0, \"add a unique cron task runnable only when the instance is a lord of the specified legion\", uwsgi_opt_add_unique_legion_cron, NULL, UWSGI_OPT_MASTER},\n#endif\n\t{\"loop\", required_argument, 0, \"select the uWSGI loop engine\", uwsgi_opt_set_str, &uwsgi.loop, 0},\n\t{\"loop-list\", no_argument, 0, \"list enabled loop engines\", uwsgi_opt_true, &uwsgi.loop_list, 0},\n\t{\"loops-list\", no_argument, 0, \"list enabled loop engines\", uwsgi_opt_true, &uwsgi.loop_list, 0},\n\t{\"worker-exec\", required_argument, 0, \"run the specified command as worker\", uwsgi_opt_set_str, &uwsgi.worker_exec, 0},\n\t{\"worker-exec2\", required_argument, 0, \"run the specified command as worker (after post_fork hook)\", uwsgi_opt_set_str, &uwsgi.worker_exec2, 0},\n\t{\"attach-daemon\", required_argument, 0, \"attach a command/daemon to the master process (the command has to not go in background)\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n\t{\"attach-control-daemon\", required_argument, 0, \"attach a command/daemon to the master process (the command has to not go in background), when the daemon dies, the master dies too\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n\t{\"smart-attach-daemon\", required_argument, 0, \"attach a command/daemon to the master process managed by a pidfile (the command has to daemonize)\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n\t{\"smart-attach-daemon2\", required_argument, 0, \"attach a command/daemon to the master process managed by a pidfile (the command has to NOT daemonize)\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n#ifdef UWSGI_SSL\n\t{\"legion-attach-daemon\", required_argument, 0, \"same as --attach-daemon but daemon runs only on legion lord node\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-smart-attach-daemon\", required_argument, 0, \"same as --smart-attach-daemon but daemon runs only on legion lord node\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n\t{\"legion-smart-attach-daemon2\", required_argument, 0, \"same as --smart-attach-daemon2 but daemon runs only on legion lord node\", uwsgi_opt_add_daemon, NULL, UWSGI_OPT_MASTER},\n#endif\n\t{\"daemons-honour-stdin\", no_argument, 0, \"do not change the stdin of external daemons to /dev/null\", uwsgi_opt_true, &uwsgi.daemons_honour_stdin, UWSGI_OPT_MASTER},\n\t{\"attach-daemon2\", required_argument, 0, \"attach-daemon keyval variant (supports smart modes too)\", uwsgi_opt_add_daemon2, NULL, UWSGI_OPT_MASTER},\n\t{\"plugins\", required_argument, 0, \"load uWSGI plugins\", uwsgi_opt_load_plugin, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"plugin\", required_argument, 0, \"load uWSGI plugins\", uwsgi_opt_load_plugin, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"need-plugins\", required_argument, 0, \"load uWSGI plugins (exit on error)\", uwsgi_opt_load_plugin, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"need-plugin\", required_argument, 0, \"load uWSGI plugins (exit on error)\", uwsgi_opt_load_plugin, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"plugins-dir\", required_argument, 0, \"add a directory to uWSGI plugin search path\", uwsgi_opt_add_string_list, &uwsgi.plugins_dir, UWSGI_OPT_IMMEDIATE},\n\t{\"plugin-dir\", required_argument, 0, \"add a directory to uWSGI plugin search path\", uwsgi_opt_add_string_list, &uwsgi.plugins_dir, UWSGI_OPT_IMMEDIATE},\n\t{\"plugins-list\", no_argument, 0, \"list enabled plugins\", uwsgi_opt_true, &uwsgi.plugins_list, 0},\n\t{\"plugin-list\", no_argument, 0, \"list enabled plugins\", uwsgi_opt_true, &uwsgi.plugins_list, 0},\n\t{\"autoload\", no_argument, 0, \"try to automatically load plugins when unknown options are found\", uwsgi_opt_true, &uwsgi.autoload, UWSGI_OPT_IMMEDIATE},\n\t{\"dlopen\", required_argument, 0, \"blindly load a shared library\", uwsgi_opt_load_dl, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"allowed-modifiers\", required_argument, 0, \"comma separated list of allowed modifiers\", uwsgi_opt_set_str, &uwsgi.allowed_modifiers, 0},\n\t{\"remap-modifier\", required_argument, 0, \"remap request modifier from one id to another\", uwsgi_opt_set_str, &uwsgi.remap_modifier, 0},\n\n\t{\"dump-options\", no_argument, 0, \"dump the full list of available options\", uwsgi_opt_true, &uwsgi.dump_options, 0},\n\t{\"show-config\", no_argument, 0, \"show the current config reformatted as ini\", uwsgi_opt_true, &uwsgi.show_config, 0},\n\t{\"binary-append-data\", required_argument, 0, \"return the content of a resource to stdout for appending to a uwsgi binary (for data:// usage)\", uwsgi_opt_binary_append_data, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"print\", required_argument, 0, \"simple print\", uwsgi_opt_print, NULL, 0},\n\t{\"iprint\", required_argument, 0, \"simple print (immediate version)\", uwsgi_opt_print, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"exit\", optional_argument, 0, \"force exit() of the instance\", uwsgi_opt_exit, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"cflags\", no_argument, 0, \"report uWSGI CFLAGS (useful for building external plugins)\", uwsgi_opt_cflags, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"dot-h\", no_argument, 0, \"dump the uwsgi.h used for building the core  (useful for building external plugins)\", uwsgi_opt_dot_h, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"config-py\", no_argument, 0, \"dump the uwsgiconfig.py used for building the core  (useful for building external plugins)\", uwsgi_opt_config_py, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"build-plugin\", required_argument, 0, \"build a uWSGI plugin for the current binary\", uwsgi_opt_build_plugin, NULL, UWSGI_OPT_IMMEDIATE},\n\t{\"version\", no_argument, 0, \"print uWSGI version\", uwsgi_opt_print, UWSGI_VERSION, 0},\n\t{\"response-headers-limit\", required_argument, 0, \"set response header maximum size (default: 64k)\", uwsgi_opt_set_int, &uwsgi.response_header_limit, 0},\n\t{0, 0, 0, 0, 0, 0, 0}\n};\n\nvoid show_config(void) {\n\tint i;\n\tuwsgi_log(\"\\n;uWSGI instance configuration\\n[uwsgi]\\n\");\n\tfor (i = 0; i < uwsgi.exported_opts_cnt; i++) {\n\t\tif (uwsgi.exported_opts[i]->value) {\n\t\t\tuwsgi_log(\"%s = %s\\n\", uwsgi.exported_opts[i]->key, uwsgi.exported_opts[i]->value);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"%s = true\\n\", uwsgi.exported_opts[i]->key);\n\t\t}\n\t}\n\tuwsgi_log(\";end of configuration\\n\\n\");\n\n}\n\nvoid config_magic_table_fill(char *filename, char **magic_table) {\n\n\tchar *tmp = NULL;\n\tchar *fullname = filename;\n\n\tmagic_table['o'] = filename;\n\n\tif (uwsgi_check_scheme(filename) || !strcmp(filename, \"-\")) {\n\t\treturn;\n\t}\n\n        char *section = uwsgi_get_last_char(filename, ':');\n        if (section) {\n                *section = 0;\n\t\tif (section == filename) {\n\t\t\tgoto reuse;\n\t\t}\n\t}\n\n\n\t// we have a special case for symlinks\n\tif (uwsgi_is_link(filename)) {\n\t\tif (filename[0] != '/') {\n\t\t\tfullname = uwsgi_concat3(uwsgi.cwd, \"/\", filename);\n\t\t}\n\t}\n\telse {\n\n\t\tfullname = uwsgi_expand_path(filename, strlen(filename), NULL);\n\t\tif (!fullname) {\n\t\t\texit(1);\n\t\t}\n\t\tchar *minimal_name = uwsgi_malloc(strlen(fullname) + 1);\n\t\tmemcpy(minimal_name, fullname, strlen(fullname));\n\t\tminimal_name[strlen(fullname)] = 0;\n\t\tfree(fullname);\n\t\tfullname = minimal_name;\n\t}\n\n\tmagic_table['b'] = uwsgi.binary_path;\n\tmagic_table['p'] = fullname;\n\n\t// compute filename hash\n\tuint32_t hash = djb33x_hash(magic_table['p'], strlen(magic_table['p']));\n\tchar *hex = uwsgi_str_to_hex((char *)&hash, 4);\n\tmagic_table['j'] = uwsgi_concat2n(hex, 8, \"\", 0);\n\tfree(hex);\n\n\tstruct stat st;\n\tif (!lstat(fullname, &st)) {\n\t\tmagic_table['i'] = uwsgi_num2str(st.st_ino);\n\t}\n\n\tmagic_table['s'] = uwsgi_get_last_char(fullname, '/') + 1;\n\n\tmagic_table['d'] = uwsgi_concat2n(magic_table['p'], magic_table['s'] - magic_table['p'], \"\", 0);\n\tif (magic_table['d'][strlen(magic_table['d']) - 1] == '/') {\n\t\ttmp = magic_table['d'] + (strlen(magic_table['d']) - 1);\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"tmp = %c\\n\", *tmp);\n#endif\n\t\t*tmp = 0;\n\t}\n\n\t// clear optional vars\n\tmagic_table['c'] = \"\";\n\tmagic_table['e'] = \"\";\n\tmagic_table['n'] = magic_table['s'];\n\n\tmagic_table['0'] = \"\";\n\tmagic_table['1'] = \"\";\n\tmagic_table['2'] = \"\";\n\tmagic_table['3'] = \"\";\n\tmagic_table['4'] = \"\";\n\tmagic_table['5'] = \"\";\n\tmagic_table['6'] = \"\";\n\tmagic_table['7'] = \"\";\n\tmagic_table['8'] = \"\";\n\tmagic_table['9'] = \"\";\n\n\tif (uwsgi_get_last_char(magic_table['d'], '/')) {\n\t\tmagic_table['c'] = uwsgi_str(uwsgi_get_last_char(magic_table['d'], '/') + 1);\n\t\tif (magic_table['c'][strlen(magic_table['c']) - 1] == '/') {\n\t\t\tmagic_table['c'][strlen(magic_table['c']) - 1] = 0;\n\t\t}\n\t}\n\n\tint base = '0';\n\tchar *to_split = uwsgi_str(magic_table['d']);\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(to_split, \"/\", p, ctx) {\n\t\tif (base <= '9') {\n\t\t\tmagic_table[base] = p;\n\t\t\tbase++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp)\n\t\t*tmp = '/';\n\n\tif (uwsgi_get_last_char(magic_table['s'], '.'))\n\t\tmagic_table['e'] = uwsgi_get_last_char(magic_table['s'], '.') + 1;\n\tif (uwsgi_get_last_char(magic_table['s'], '.'))\n\t\tmagic_table['n'] = uwsgi_concat2n(magic_table['s'], uwsgi_get_last_char(magic_table['s'], '.') - magic_table['s'], \"\", 0);\n\nreuse:\n\tmagic_table['x'] = \"\";\n\tif (section) {\n\t\tmagic_table['x'] = section+1;\n\t\t*section = ':';\n\t}\n\n\t// first round ?\n\tif (!uwsgi.magic_table_first_round) { \n\t\tmagic_table['O'] = magic_table['o'];\n                magic_table['D'] = magic_table['d'];\n                magic_table['S'] = magic_table['s'];\n                magic_table['P'] = magic_table['p'];\n                magic_table['C'] = magic_table['c'];\n                magic_table['E'] = magic_table['e'];\n                magic_table['N'] = magic_table['n'];\n                magic_table['X'] = magic_table['x'];\n                magic_table['I'] = magic_table['i'];\n                magic_table['J'] = magic_table['j'];\n\t\tuwsgi.magic_table_first_round = 1;\n        }\n\n}\n\nint find_worker_id(pid_t pid) {\n\tint i;\n\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\tif (uwsgi.workers[i].pid == pid)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\n\nvoid warn_pipe() {\n\tstruct wsgi_request *wsgi_req = current_wsgi_req();\n\n\tif (uwsgi.threads < 2 && wsgi_req->uri_len > 0) {\n\t\tuwsgi_log_verbose(\"SIGPIPE: writing to a closed pipe/socket/fd (probably the client disconnected) on request %.*s (ip %.*s) !!!\\n\", wsgi_req->uri_len, wsgi_req->uri, wsgi_req->remote_addr_len, wsgi_req->remote_addr);\n\t}\n\telse {\n\t\tuwsgi_log_verbose(\"SIGPIPE: writing to a closed pipe/socket/fd (probably the client disconnected) !!!\\n\");\n\t}\n}\n\n// in threading mode we need to use the cancel pthread subsystem\nvoid wait_for_threads() {\n\tint i, ret;\n\n\t// on some platform thread cancellation is REALLY flaky\n\tif (uwsgi.no_threads_wait) return;\n\n\tint sudden_death = 0;\n\n\tpthread_mutex_lock(&uwsgi.six_feet_under_lock);\n\tfor (i = 1; i < uwsgi.threads; i++) {\n\t\tif (!pthread_equal(uwsgi.workers[uwsgi.mywid].cores[i].thread_id, pthread_self())) {\n\t\t\tif (pthread_cancel(uwsgi.workers[uwsgi.mywid].cores[i].thread_id)) {\n\t\t\t\tuwsgi_error(\"pthread_cancel()\\n\");\n\t\t\t\tsudden_death = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sudden_death)\n\t\tgoto end;\n\n\t// wait for thread termination\n\tfor (i = 1; i < uwsgi.threads; i++) {\n\t\tif (!pthread_equal(uwsgi.workers[uwsgi.mywid].cores[i].thread_id, pthread_self())) {\n\t\t\tret = pthread_join(uwsgi.workers[uwsgi.mywid].cores[i].thread_id, NULL);\n\t\t\tif (ret) {\n\t\t\t\tuwsgi_log(\"pthread_join() = %d\\n\", ret);\n\t\t\t}\n\t\t}\n\t}\n\n\t// cancel inital thread last since after pthread_cancel() and\n\t// pthread_join() is called on it, the whole process will appear to be\n\t// a zombie. although it won't eliminate process zombie time, but it\n\t// should minimize it.\n\tif (!pthread_equal(uwsgi.workers[uwsgi.mywid].cores[0].thread_id, pthread_self())) {\n\t\tif (pthread_cancel(uwsgi.workers[uwsgi.mywid].cores[0].thread_id)) {\n\t\t\tuwsgi_error(\"pthread_cancel() on initial thread\\n\");\n\t\t\tgoto end;\n\t\t}\n\n\t\tret = pthread_join(uwsgi.workers[uwsgi.mywid].cores[0].thread_id, NULL);\n\t\tif (ret) {\n\t\t\tuwsgi_log(\"pthread_join() = %d on initial thread\\n\", ret);\n\t\t}\n\t}\n\nend:\n\n\tpthread_mutex_unlock(&uwsgi.six_feet_under_lock);\n}\n\n\nvoid gracefully_kill(int signum) {\n\n\tuwsgi_log(\"Gracefully killing worker %d (pid: %d)...\\n\", uwsgi.mywid, uwsgi.mypid);\n\tuwsgi.workers[uwsgi.mywid].manage_next_request = 0;\n\tif (uwsgi.threads > 1) {\n\t\tstruct wsgi_request *wsgi_req = current_wsgi_req();\n\t\twait_for_threads();\n\t\tif (!uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request) {\n\t\t\tif (uwsgi.workers[uwsgi.mywid].shutdown_sockets)\n\t\t\t\tuwsgi_shutdown_all_sockets();\n\t\t\texit(UWSGI_RELOAD_CODE);\n\t\t}\n\t\treturn;\n\t\t// never here\n\t}\n\n\t// still not found a way to gracefully reload in async mode\n\tif (uwsgi.async > 1) {\n\t\tif (uwsgi.workers[uwsgi.mywid].shutdown_sockets)\n\t\t\tuwsgi_shutdown_all_sockets();\n\t\texit(UWSGI_RELOAD_CODE);\n\t}\n\n\tif (!uwsgi.workers[uwsgi.mywid].cores[0].in_request) {\n\t\tif (uwsgi.workers[uwsgi.mywid].shutdown_sockets)\n\t\t\tuwsgi_shutdown_all_sockets();\n\t\texit(UWSGI_RELOAD_CODE);\n\t}\n}\n\nvoid end_me(int signum) {\n\tif (getpid() != masterpid && uwsgi.skip_atexit) {\n\t\t_exit(UWSGI_END_CODE);\n\t\t// never here\n\t}\n\texit(UWSGI_END_CODE);\n}\n\nvoid simple_goodbye_cruel_world() {\n\n\tif (uwsgi.threads > 1 && !uwsgi_instance_is_dying) {\n\t\twait_for_threads();\n\t}\n\n\tuwsgi.workers[uwsgi.mywid].manage_next_request = 0;\n\tuwsgi_log(\"...The work of process %d is done. Seeya!\\n\", getpid());\n\texit(0);\n}\n\nvoid goodbye_cruel_world() {\n\tuwsgi_curse(uwsgi.mywid, 0);\n\n\tif (!uwsgi.gbcw_hook) {\n\t\tsimple_goodbye_cruel_world();\n\t}\n\telse {\n\t\tuwsgi.gbcw_hook();\n\t}\n}\n\n// brutally destroy\nvoid kill_them_all(int signum) {\n\n\tif (uwsgi_instance_is_dying) return;\n\tuwsgi.status.brutally_destroying = 1;\n\n\t// unsubscribe if needed\n\tuwsgi_unsubscribe_all();\n\n\tuwsgi_log(\"SIGINT/SIGQUIT received...killing workers...\\n\");\n\n\tint i;\n\tfor (i = 1; i <= uwsgi.numproc; i++) {\n                if (uwsgi.workers[i].pid > 0) {\n                        uwsgi_curse(i, SIGINT);\n                }\n        }\n\tfor (i = 0; i < uwsgi.mules_cnt; i++) {\n\t\tif (uwsgi.mules[i].pid > 0) {\n\t\t\tuwsgi_curse_mule(i, SIGINT);\n\t\t}\n\t}\n\n\tuwsgi_destroy_processes();\n}\n\n// gracefully destroy\nvoid gracefully_kill_them_all(int signum) {\n\n        if (uwsgi_instance_is_dying) return;\n        uwsgi.status.gracefully_destroying = 1;\n\n        // unsubscribe if needed\n        uwsgi_unsubscribe_all();\n\n        uwsgi_log_verbose(\"graceful shutdown triggered...\\n\");\n\n        int i;\n        for (i = 1; i <= uwsgi.numproc; i++) {\n                if (uwsgi.workers[i].pid > 0) {\n\t\t\tif (uwsgi.shutdown_sockets)\n\t\t\t\tuwsgi.workers[i].shutdown_sockets = 1;\n                        uwsgi_curse(i, SIGHUP);\n                }\n        }\n        for (i = 0; i < uwsgi.mules_cnt; i++) {\n                if (uwsgi.mules[i].pid > 0) {\n                        uwsgi_curse_mule(i, SIGHUP);\n                }\n        }\n\n        uwsgi_destroy_processes();\n}\n\n\n// graceful reload\nvoid grace_them_all(int signum) {\n\tif (uwsgi_instance_is_reloading || uwsgi_instance_is_dying)\n\t\treturn;\n\n\tint i;\n\n\tif (uwsgi.lazy) {\n\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\tif (uwsgi.workers[i].pid > 0) {\n\t\t\t\tuwsgi_curse(i, SIGHUP);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\t\n\n\tuwsgi.status.gracefully_reloading = 1;\n\n\tuwsgi_destroy_processes();\n\n\tuwsgi_log(\"...gracefully killing workers...\\n\");\n\n#ifdef UWSGI_SSL\n\tuwsgi_legion_announce_death();\n#endif\n\n\tif (uwsgi.unsubscribe_on_graceful_reload) {\n\t\tuwsgi_unsubscribe_all();\n\t}\n\n\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\tif (uwsgi.workers[i].pid > 0) {\n\t\t\tuwsgi_curse(i, SIGHUP);\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.mules_cnt; i++) {\n\t\tif (uwsgi.mules[i].pid > 0) {\n\t\t\tuwsgi_curse_mule(i, SIGHUP);\n\t\t}\n\t}\n}\n\nvoid uwsgi_nuclear_blast() {\n\n\t// the Emperor (as an example) cannot nuke itself\n\tif (uwsgi.disable_nuclear_blast) return;\n\n\tif (!uwsgi.workers) {\n\t\treap_them_all(0);\n\t}\n\telse if (uwsgi.master_process) {\n\t\tif (getpid() == uwsgi.workers[0].pid) {\n\t\t\treap_them_all(0);\n\t\t}\n\t}\n\n\texit(1);\n}\n\n// brutally reload\nvoid reap_them_all(int signum) {\n\n\t// avoid reace condition in lazy mode\n\tif (uwsgi_instance_is_reloading)\n\t\treturn;\n\n\tuwsgi.status.brutally_reloading = 1;\n\n\tif (!uwsgi.workers) return;\n\n\tuwsgi_destroy_processes();\n\n\tuwsgi_log(\"...brutally killing workers...\\n\");\n\n#ifdef UWSGI_SSL\n        uwsgi_legion_announce_death();\n#endif\n\n\t// unsubscribe if needed\n\tuwsgi_unsubscribe_all();\n\n\tint i;\n\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\tif (uwsgi.workers[i].pid > 0)\n\t\t\tuwsgi_curse(i, SIGTERM);\n\t}\n\tfor (i = 0; i < uwsgi.mules_cnt; i++) {\n\t\tif (uwsgi.mules[i].pid > 0) {\n\t\t\tuwsgi_curse_mule(i, SIGTERM);\n\t\t}\n\t}\n}\n\nvoid harakiri() {\n\n\tuwsgi_log(\"\\nF*CK !!! i must kill myself (pid: %d app_id: %d)...\\n\", uwsgi.mypid, uwsgi.wsgi_req->app_id);\n\n\tif (!uwsgi.master_process) {\n\t\tuwsgi_log(\"*** if you want your workers to be automatically respawned consider enabling the uWSGI master process ***\\n\");\n\t}\n\texit(0);\n}\n\nvoid stats(int signum) {\n\t//fix this for better logging(this cause races)\n\tstruct uwsgi_app *ua = NULL;\n\tint i, j;\n\n\tif (uwsgi.mywid == 0) {\n\t\tshow_config();\n\t\tuwsgi_log(\"\\tworkers total requests: %lu\\n\", uwsgi.workers[0].requests);\n\t\tuwsgi_log(\"-----------------\\n\");\n\t\tfor (j = 1; j <= uwsgi.numproc; j++) {\n\t\t\tfor (i = 0; i < uwsgi.workers[j].apps_cnt; i++) {\n\t\t\t\tua = &uwsgi.workers[j].apps[i];\n\t\t\t\tif (ua) {\n\t\t\t\t\tuwsgi_log(\"\\tworker %d app %d [%.*s] requests: %lu exceptions: %lu\\n\", j, i, ua->mountpoint_len, ua->mountpoint, ua->requests, ua->exceptions);\n\t\t\t\t}\n\t\t\t}\n\t\t\tuwsgi_log(\"-----------------\\n\");\n\t\t}\n\t}\n\telse {\n\t\tuwsgi_log(\"worker %d total requests: %lu\\n\", uwsgi.mywid, uwsgi.workers[0].requests);\n\t\tfor (i = 0; i < uwsgi.workers[uwsgi.mywid].apps_cnt; i++) {\n\t\t\tua = &uwsgi.workers[uwsgi.mywid].apps[i];\n\t\t\tif (ua) {\n\t\t\t\tuwsgi_log(\"\\tapp %d [%.*s] requests: %lu exceptions: %lu\\n\", i, ua->mountpoint_len, ua->mountpoint, ua->requests, ua->exceptions);\n\t\t\t}\n\t\t}\n\t\tuwsgi_log(\"-----------------\\n\");\n\t}\n\tuwsgi_log(\"\\n\");\n}\n\nvoid what_i_am_doing() {\n\n\tstruct wsgi_request *wsgi_req;\n\tint i;\n\tchar ctime_storage[26];\n\n\tuwsgi_backtrace(uwsgi.backtrace_depth);\n\n\tif (uwsgi.cores > 1) {\n\t\tfor (i = 0; i < uwsgi.cores; i++) {\n\t\t\twsgi_req = &uwsgi.workers[uwsgi.mywid].cores[i].req;\n\t\t\tif (wsgi_req->uri_len > 0) {\n#if defined(__sun__) && !defined(__clang__)\n\t\t\t\tctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage, 26);\n#else\n\t\t\t\tctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage);\n#endif\n\t\t\t\tif (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now()) {\n\t\t\t\t\tuwsgi_log(\"HARAKIRI: --- uWSGI worker %d core %d (pid: %d) WAS managing request %.*s since %.*s ---\\n\", (int) uwsgi.mywid, i, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_log(\"SIGUSR2: --- uWSGI worker %d core %d (pid: %d) is managing request %.*s since %.*s ---\\n\", (int) uwsgi.mywid, i, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\twsgi_req = &uwsgi.workers[uwsgi.mywid].cores[0].req;\n\t\tif (wsgi_req->uri_len > 0) {\n#if defined(__sun__) && !defined(__clang__)\n\t\t\tctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage, 26);\n#else\n\t\t\tctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage);\n#endif\n\t\t\tif (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now()) {\n\t\t\t\tuwsgi_log(\"HARAKIRI: --- uWSGI worker %d (pid: %d) WAS managing request %.*s since %.*s ---\\n\", (int) uwsgi.mywid, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_log(\"SIGUSR2: --- uWSGI worker %d (pid: %d) is managing request %.*s since %.*s ---\\n\", (int) uwsgi.mywid, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);\n\t\t\t}\n\t\t}\n\t\telse if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now() && uwsgi.workers[uwsgi.mywid].sig) {\n\t\t\tuwsgi_log(\"HARAKIRI: --- uWSGI worker %d (pid: %d) WAS handling signal %d ---\\n\", (int) uwsgi.mywid, (int) uwsgi.mypid, uwsgi.workers[uwsgi.mywid].signum);\n\t\t}\n\t}\n}\n\n\n\nint unconfigured_hook(struct wsgi_request *wsgi_req) {\n\tif (wsgi_req->uh->modifier1 == 0 && !uwsgi.no_default_app) {\n\t\tif (uwsgi_apps_cnt > 0 && uwsgi.default_app > -1) {\n\t\t\tstruct uwsgi_app *ua = &uwsgi_apps[uwsgi.default_app];\n\t\t\tif (uwsgi.p[ua->modifier1]->request != unconfigured_hook) {\n\t\t\t\twsgi_req->uh->modifier1 = ua->modifier1;\n\t\t\t\treturn uwsgi.p[ua->modifier1]->request(wsgi_req);\n\t\t\t}\n\t\t}\n\t}\n\tuwsgi_log(\"-- unavailable modifier requested: %d --\\n\", wsgi_req->uh->modifier1);\n\treturn -1;\n}\n\nstatic void unconfigured_after_hook(struct wsgi_request *wsgi_req) {\n\treturn;\n}\n\nstruct uwsgi_plugin unconfigured_plugin = {\n\n\t.name = \"unconfigured\",\n\t.request = unconfigured_hook,\n\t.after_request = unconfigured_after_hook,\n};\n\nvoid uwsgi_exec_atexit(void) {\n\tif (getpid() == masterpid) {\n\t\n\t\tuwsgi_hooks_run(uwsgi.hook_as_user_atexit, \"atexit\", 0);\n\t\t// now run exit scripts needed by the user\n\t\tstruct uwsgi_string_list *usl;\n\n\t\tuwsgi_foreach(usl, uwsgi.exec_as_user_atexit) {\n\t\t\tuwsgi_log(\"running \\\"%s\\\" (as uid: %d gid: %d) ...\\n\", usl->value, (int) getuid(), (int) getgid());\n\t\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\t\tif (ret != 0) {\n\t\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.call_as_user_atexit) {\n                \tif (uwsgi_call_symbol(usl->value)) {\n                        \tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n                \t}\n        \t}\n\t}\n}\n\nstatic void vacuum(void) {\n\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi.sockets;\n\n\tif (uwsgi.restore_tc) {\n\t\tif (getpid() == masterpid) {\n\t\t\tif (tcsetattr(0, TCSANOW, &uwsgi.termios)) {\n\t\t\t\tuwsgi_error(\"vacuum()/tcsetattr()\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (uwsgi.vacuum) {\n\t\tif (getpid() == masterpid) {\n\t\t\tif (chdir(uwsgi.cwd)) {\n\t\t\t\tuwsgi_error(\"chdir()\");\n\t\t\t}\n\t\t\tif (uwsgi.pidfile && !uwsgi.uid) {\n\t\t\t\tif (unlink(uwsgi.pidfile)) {\n\t\t\t\t\tuwsgi_error(\"unlink()\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_log(\"VACUUM: pidfile removed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (uwsgi.pidfile2) {\n\t\t\t\tif (unlink(uwsgi.pidfile2)) {\n\t\t\t\t\tuwsgi_error(\"unlink()\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_log(\"VACUUM: pidfile2 removed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (uwsgi.safe_pidfile && !uwsgi.uid) {\n\t\t\t\tif (unlink(uwsgi.safe_pidfile)) {\n\t\t\t\t\tuwsgi_error(\"unlink()\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_log(\"VACUUM: safe pidfile removed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (uwsgi.safe_pidfile2) {\n\t\t\t\tif (unlink(uwsgi.safe_pidfile2)) {\n\t\t\t\t\tuwsgi_error(\"unlink()\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi_log(\"VACUUM: safe pidfile2 removed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (uwsgi.chdir) {\n\t\t\t\tif (chdir(uwsgi.chdir)) {\n\t\t\t\t\tuwsgi_error(\"chdir()\");\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (uwsgi_sock) {\n\t\t\t\tif (uwsgi_sock->family == AF_UNIX && uwsgi_sock->name[0] != '@') {\n\t\t\t\t\tstruct stat st;\n\t\t\t\t\tif (!stat(uwsgi_sock->name, &st)) {\n\t\t\t\t\t\tif (st.st_ino != uwsgi_sock->inode) {\n\t\t\t\t\t\t\tuwsgi_log(\"VACUUM WARNING: unix socket %s changed inode. Skip removal\\n\", uwsgi_sock->name);\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (unlink(uwsgi_sock->name)) {\n\t\t\t\t\t\tuwsgi_error(\"unlink()\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuwsgi_log(\"VACUUM: unix socket %s removed.\\n\", uwsgi_sock->name);\n\t\t\t\t\t}\n\t\t\t\t}\nnext:\n\t\t\t\tuwsgi_sock = uwsgi_sock->next;\n\t\t\t}\n\t\t\tif (uwsgi.stats) {\n\t\t\t\t// is a unix socket ?\n\t\t\t\tif (!strchr(uwsgi.stats, ':') && uwsgi.stats[0] != '@') {\n\t\t\t\t\tif (unlink(uwsgi.stats)) {\n                                                uwsgi_error(\"unlink()\");\n                                        }\n                                        else {\n                                                uwsgi_log(\"VACUUM: unix socket %s (stats) removed.\\n\", uwsgi.stats);\n                                        }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint signal_pidfile(int sig, char *filename) {\n\n\tint ret = 0;\n\tsize_t size = 0;\n\n\tchar *buffer = uwsgi_open_and_read(filename, &size, 1, NULL);\n\n\tif (size > 0) {\n\t\tif (kill((pid_t) atoi(buffer), sig)) {\n\t\t\tuwsgi_error(\"signal_pidfile()/kill()\");\n\t\t\tret = -1;\n\t\t}\n\t}\n\telse {\n\t\tuwsgi_log(\"error: invalid pidfile\\n\");\n\t\tret = -1;\n\t}\n\tfree(buffer);\n\treturn ret;\n}\n\n/*static*/ void uwsgi_command_signal(char *opt) {\n\n\tint tmp_signal;\n\tchar *colon = strchr(opt, ',');\n\tif (!colon) {\n\t\tuwsgi_log(\"invalid syntax for signal, must be addr,signal\\n\");\n\t\texit(1);\n\t}\n\n\tcolon[0] = 0;\n\ttmp_signal = atoi(colon + 1);\n\n\tif (tmp_signal < 0 || tmp_signal > 255) {\n\t\tuwsgi_log(\"invalid signal number\\n\");\n\t\texit(3);\n\t}\n\n\tuint8_t uwsgi_signal = tmp_signal;\n\tint ret = uwsgi_remote_signal_send(opt, uwsgi_signal);\n\n\tif (ret < 0) {\n\t\tuwsgi_log(\"unable to deliver signal %d to node %s\\n\", uwsgi_signal, opt);\n\t\texit(1);\n\t}\n\n\tif (ret == 0) {\n\t\tuwsgi_log(\"node %s rejected signal %d\\n\", opt, uwsgi_signal);\n\t\texit(2);\n\t}\n\n\tuwsgi_log(\"signal %d delivered to node %s\\n\", uwsgi_signal, opt);\n\texit(0);\n}\n\nstatic void fixup_argv_and_environ(int argc, char **argv, char **environ, char **envp) {\n\n\tuwsgi.orig_argv = argv;\n\tuwsgi.argv = argv;\n\tuwsgi.argc = argc;\n\tuwsgi.environ = UWSGI_ENVIRON;\n\n\t// avoid messing with fake environ\n\tif (envp && *environ != *envp) return;\n\t\n\n#if defined(__linux__) || defined(__sun__)\n\n\tint i;\n\tint env_count = 0;\n\n\tuwsgi.argv = uwsgi_malloc(sizeof(char *) * (argc + 1));\n\n\tfor (i = 0; i < argc; i++) {\n\t\tif (i == 0 || argv[0] + uwsgi.max_procname + 1 == argv[i]) {\n\t\t\tuwsgi.max_procname += strlen(argv[i]) + 1;\n\t\t}\n\t\tuwsgi.argv[i] = strdup(argv[i]);\n\t}\n\n\t// required by execve\n\tuwsgi.argv[i] = NULL;\n\n\tuwsgi.max_procname++;\n\n\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t// useless\n\t\t//if ((environ[0] + uwsgi.max_procname + 1) == environ[i]) {\n\t\tuwsgi.max_procname += strlen(environ[i]) + 1;\n\t\t//}\n\t\tenv_count++;\n\t}\n\n\tuwsgi.environ = uwsgi_malloc(sizeof(char *) * (env_count+1));\n\tfor (i = 0; i < env_count; i++) {\n\t\tuwsgi.environ[i] = strdup(environ[i]);\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"ENVIRON: %s\\n\", uwsgi.environ[i]);\n#endif\n\t\tenviron[i] = uwsgi.environ[i];\n\t}\n\tuwsgi.environ[env_count] = NULL;\n\n#ifdef UWSGI_DEBUG\n\tuwsgi_log(\"max space for custom process name = %d\\n\", uwsgi.max_procname);\n#endif\n\t//environ = uwsgi.environ;\n\n#endif\n}\n\n\nvoid uwsgi_plugins_atexit(void) {\n\n\tint j;\n\n\tif (!uwsgi.workers)\n\t\treturn;\n\n\t// the master cannot run atexit handlers...\n\tif (uwsgi.master_process && uwsgi.workers[0].pid == getpid())\n\t\treturn;\n\n\tfor (j = 0; j < uwsgi.gp_cnt; j++) {\n\t\tif (uwsgi.gp[j]->atexit) {\n\t\t\tuwsgi.gp[j]->atexit();\n\t\t}\n\t}\n\n\tfor (j = 0; j < 256; j++) {\n\t\tif (uwsgi.p[j]->atexit) {\n\t\t\tuwsgi.p[j]->atexit();\n\t\t}\n\t}\n\n}\n\nvoid uwsgi_backtrace(int depth) {\n\n#if defined(__GLIBC__) || (defined(__APPLE__) && !defined(NO_EXECINFO)) || defined(UWSGI_HAS_EXECINFO)\n\n#include <execinfo.h>\n\n\tvoid **btrace = uwsgi_malloc(sizeof(void *) * depth);\n\tsize_t bt_size, i;\n\tchar **bt_strings;\n\n\tbt_size = backtrace(btrace, depth);\n\n\tbt_strings = backtrace_symbols(btrace, bt_size);\n\n\tstruct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);\n\tuwsgi_buffer_append(ub, \"*** backtrace of \",17);\n\tuwsgi_buffer_num64(ub, (int64_t) getpid());\n\tuwsgi_buffer_append(ub, \" ***\\n\", 5);\n\tfor (i = 0; i < bt_size; i++) {\n\t\tuwsgi_buffer_append(ub, bt_strings[i], strlen(bt_strings[i]));\n\t\tuwsgi_buffer_append(ub, \"\\n\", 1);\n\t}\n\n\tfree(btrace);\n\n\tuwsgi_buffer_append(ub, \"*** end of backtrace ***\\n\", 25);\n\n\tuwsgi_log(\"%.*s\", ub->pos, ub->buf);\n\n\tstruct uwsgi_string_list *usl = uwsgi.alarm_segfault;\n\twhile(usl) {\n\t\tuwsgi_alarm_trigger(usl->value, ub->buf, ub->pos);\t\n\t\tusl = usl->next;\n\t}\t\n\n\tuwsgi_buffer_destroy(ub);\n#endif\n\n}\n\nvoid uwsgi_segfault(int signum) {\n\n\tuwsgi_log(\"!!! uWSGI process %d got Segmentation Fault !!!\\n\", (int) getpid());\n\tuwsgi_backtrace(uwsgi.backtrace_depth);\n\n\tif (uwsgi.use_abort) abort();\n\n\t// restore default handler to generate core\n\tsignal(signum, SIG_DFL);\n\tkill(getpid(), signum);\n\n\t// never here...\n\texit(1);\n}\n\nvoid uwsgi_fpe(int signum) {\n\n\tuwsgi_log(\"!!! uWSGI process %d got Floating Point Exception !!!\\n\", (int) getpid());\n\tuwsgi_backtrace(uwsgi.backtrace_depth);\n\n\tif (uwsgi.use_abort) abort();\n\n\t// restore default handler to generate core\n\tsignal(signum, SIG_DFL);\n\tkill(getpid(), signum);\n\n\t// never here...\n\texit(1);\n}\n\nvoid uwsgi_flush_logs() {\n\n\tstruct pollfd pfd;\n\n\tif (!uwsgi.master_process)\n\t\treturn;\n\tif (!uwsgi.log_master)\n\t\treturn;\n\n\tif (uwsgi.workers) {\n\t\tif (uwsgi.workers[0].pid == getpid()) {\n\t\t\tgoto check;\n\t\t}\n\t}\n\n\n\tif (uwsgi.mywid == 0)\n\t\tgoto check;\n\n\treturn;\n\ncheck:\n\t// this buffer could not be initialized !!!\n\tif (uwsgi.log_master) {\n\t\tuwsgi.log_master_buf = uwsgi_malloc(uwsgi.log_master_bufsize);\n\t}\n\n\t// check for data in logpipe\n\tpfd.events = POLLIN;\n\tpfd.fd = uwsgi.shared->worker_log_pipe[0];\n\tif (pfd.fd == -1)\n\t\tpfd.fd = 2;\n\n\twhile (poll(&pfd, 1, 0) > 0) {\n\t\tif (uwsgi_master_log()) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void plugins_list(void) {\n\tint i;\n\tuwsgi_log(\"\\n*** uWSGI loaded generic plugins ***\\n\");\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tuwsgi_log(\"%s\\n\", uwsgi.gp[i]->name);\n\t}\n\n\tuwsgi_log(\"\\n*** uWSGI loaded request plugins ***\\n\");\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i] == &unconfigured_plugin)\n\t\t\tcontinue;\n\t\tuwsgi_log(\"%d: %s\\n\", i, uwsgi.p[i]->name);\n\t}\n\n\tuwsgi_log(\"--- end of plugins list ---\\n\\n\");\n}\n\nstatic void loggers_list(void) {\n\tstruct uwsgi_logger *ul = uwsgi.loggers;\n\tuwsgi_log(\"\\n*** uWSGI loaded loggers ***\\n\");\n\twhile (ul) {\n\t\tuwsgi_log(\"%s\\n\", ul->name);\n\t\tul = ul->next;\n\t}\n\tuwsgi_log(\"--- end of loggers list ---\\n\\n\");\n}\n\nstatic void cheaper_algo_list(void) {\n\tstruct uwsgi_cheaper_algo *uca = uwsgi.cheaper_algos;\n\tuwsgi_log(\"\\n*** uWSGI loaded cheaper algorithms ***\\n\");\n\twhile (uca) {\n\t\tuwsgi_log(\"%s\\n\", uca->name);\n\t\tuca = uca->next;\n\t}\n\tuwsgi_log(\"--- end of cheaper algorithms list ---\\n\\n\");\n}\n\n#ifdef UWSGI_ROUTING\nstatic void router_list(void) {\n\tstruct uwsgi_router *ur = uwsgi.routers;\n\tuwsgi_log(\"\\n*** uWSGI loaded routers ***\\n\");\n\twhile (ur) {\n\t\tuwsgi_log(\"%s\\n\", ur->name);\n\t\tur = ur->next;\n\t}\n\tuwsgi_log(\"--- end of routers list ---\\n\\n\");\n}\n#endif\n\nstatic void loop_list(void) {\n\tstruct uwsgi_loop *loop = uwsgi.loops;\n\tuwsgi_log(\"\\n*** uWSGI loaded loop engines ***\\n\");\n\twhile (loop) {\n\t\tuwsgi_log(\"%s\\n\", loop->name);\n\t\tloop = loop->next;\n\t}\n\tuwsgi_log(\"--- end of loop engines list ---\\n\\n\");\n}\n\nstatic void imperial_monitor_list(void) {\n\tstruct uwsgi_imperial_monitor *uim = uwsgi.emperor_monitors;\n\tuwsgi_log(\"\\n*** uWSGI loaded imperial monitors ***\\n\");\n\twhile (uim) {\n\t\tuwsgi_log(\"%s\\n\", uim->scheme);\n\t\tuim = uim->next;\n\t}\n\tuwsgi_log(\"--- end of imperial monitors list ---\\n\\n\");\n}\n\nstatic void clocks_list(void) {\n\tstruct uwsgi_clock *clocks = uwsgi.clocks;\n\tuwsgi_log(\"\\n*** uWSGI loaded clocks ***\\n\");\n\twhile (clocks) {\n\t\tuwsgi_log(\"%s\\n\", clocks->name);\n\t\tclocks = clocks->next;\n\t}\n\tuwsgi_log(\"--- end of clocks list ---\\n\\n\");\n}\n\nstatic void alarms_list(void) {\n\tstruct uwsgi_alarm *alarms = uwsgi.alarms;\n\tuwsgi_log(\"\\n*** uWSGI loaded alarms ***\\n\");\n\twhile (alarms) {\n\t\tuwsgi_log(\"%s\\n\", alarms->name);\n\t\talarms = alarms->next;\n\t}\n\tuwsgi_log(\"--- end of alarms list ---\\n\\n\");\n}\n\nstatic time_t uwsgi_unix_seconds() {\n\treturn time(NULL);\n}\n\nstatic uint64_t uwsgi_unix_microseconds() {\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn ((uint64_t) tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nstatic struct uwsgi_clock uwsgi_unix_clock = {\n\t.name = \"unix\",\n\t.seconds = uwsgi_unix_seconds,\n\t.microseconds = uwsgi_unix_microseconds,\n};\n\nvoid uwsgi_init_random() {\n        srand((unsigned int) (uwsgi.start_tv.tv_usec * uwsgi.start_tv.tv_sec));\n}\n\n#ifdef UWSGI_AS_SHARED_LIBRARY\nint uwsgi_init(int argc, char *argv[], char *envp[]) {\n#else\nint main(int argc, char *argv[], char *envp[]) {\n#endif\n\tuwsgi_setup(argc, argv, envp);\n\treturn uwsgi_run();\n}\n\nstatic char *uwsgi_at_file_read(char *filename) {\n\tsize_t size = 0;\n\tchar *buffer = uwsgi_open_and_read(filename, &size, 1, NULL);\n\tif (size > 1) {\n\t\tif (buffer[size-2] == '\\n' || buffer[size-2] == '\\r') {\n\t\t\tbuffer[size-2] = 0;\n\t\t}\n\t}\n\treturn buffer;\n}\n\nvoid uwsgi_setup(int argc, char *argv[], char *envp[]) {\n\tint i;\n\n\tstruct utsname uuts;\n\n\t// signal mask is inherited, and sme process manager could make a real mess...\n\tsigset_t smask;\n        sigfillset(&smask);\n        if (sigprocmask(SIG_UNBLOCK, &smask, NULL)) {\n                uwsgi_error(\"sigprocmask()\");\n        }\n\n\tsignal(SIGCHLD, SIG_DFL);\n\tsignal(SIGSEGV, uwsgi_segfault);\n\tsignal(SIGFPE, uwsgi_fpe);\n\tsignal(SIGHUP, SIG_IGN);\n\tsignal(SIGTERM, SIG_IGN);\n\tsignal(SIGPIPE, SIG_IGN);\n\n\t//initialize masterpid with a default value\n\tmasterpid = getpid();\n\n\tmemset(&uwsgi, 0, sizeof(struct uwsgi_server));\n\tuwsgi_proto_hooks_setup();\n\tuwsgi.cwd = uwsgi_get_cwd();\n\n\tinit_magic_table(uwsgi.magic_table);\n\n\t// initialize schemes\n\tuwsgi_setup_schemes();\n\n\t// initialize the clock\n\tuwsgi_register_clock(&uwsgi_unix_clock);\n\tuwsgi_set_clock(\"unix\");\n\n\t// fallback config\n\tatexit(uwsgi_fallback_config);\n\t// manage/flush logs\n\tatexit(uwsgi_flush_logs);\n\t// clear sockets, pidfiles...\n\tatexit(vacuum);\n\t// call user scripts\n\tatexit(uwsgi_exec_atexit);\n#ifdef UWSGI_SSL\n\t// call legions death hooks\n\tatexit(uwsgi_legion_atexit);\n#endif\n\n\t// allocate main shared memory\n\tuwsgi.shared = (struct uwsgi_shared *) uwsgi_calloc_shared(sizeof(struct uwsgi_shared));\n\n\t// initialize request plugin to void\n\tfor (i = 0; i < 256; i++) {\n\t\tuwsgi.p[i] = &unconfigured_plugin;\n\t}\n\n\t// set default values\n\tuwsgi_init_default();\n\n\t// detect cpu cores\n#if defined(_SC_NPROCESSORS_ONLN)\n\tuwsgi.cpus = sysconf(_SC_NPROCESSORS_ONLN);\n#elif defined(_SC_NPROCESSORS_CONF)\n\tuwsgi.cpus = sysconf(_SC_NPROCESSORS_CONF);\n#endif\n\t// set default logit hook\n\tuwsgi.logit = uwsgi_logit_simple;\n\n#ifdef UWSGI_BLACKLIST\n\tif (!uwsgi_file_to_string_list(UWSGI_BLACKLIST, &uwsgi.blacklist)) {\n\t\tuwsgi_log(\"you cannot run this build of uWSGI without a blacklist file\\n\");\n\t\texit(1);\n\t}\n#endif\n\n#ifdef UWSGI_WHITELIST\n\tif (!uwsgi_file_to_string_list(UWSGI_WHITELIST, &uwsgi.whitelist)) {\n\t\tuwsgi_log(\"you cannot run this build of uWSGI without a whitelist file\\n\");\n\t\texit(1);\n\t}\n#endif\n\n\t// get startup time\n\tgettimeofday(&uwsgi.start_tv, NULL);\n\n\t// initialize random engine\n\tuwsgi_init_random();\n\n\tsetlinebuf(stdout);\n\n\tuwsgi.rl.rlim_cur = 0;\n\tuwsgi.rl.rlim_max = 0;\n\n\t// are we under systemd ?\n\tchar *notify_socket = getenv(\"NOTIFY_SOCKET\");\n\tif (notify_socket) {\n\t\tuwsgi_systemd_init(notify_socket);\n\t}\n\n\tuwsgi_notify(\"initializing uWSGI\");\n\n\t// check if we are under the Emperor\n\tuwsgi_check_emperor();\n\n\tchar *screen_env = getenv(\"TERM\");\n\tif (screen_env) {\n\t\tif (!strcmp(screen_env, \"screen\")) {\n\t\t\tuwsgi.screen_session = getenv(\"STY\");\n\t\t}\n\t}\n\n\n\t// count/set the current reload status\n\tuwsgi_setup_reload();\n\n#ifdef __CYGWIN__\n\tSYSTEM_INFO si;\n\tGetSystemInfo(&si);\n\tuwsgi.page_size = si.dwPageSize;\n#else\n\tuwsgi.page_size = getpagesize();\n#endif\n\tuwsgi.binary_path = uwsgi_get_binary_path(argv[0]);\n\n\tif(uwsgi.response_header_limit == 0)\n\t\tuwsgi.response_header_limit = UMAX16;\n\n\t// ok we can now safely play with argv and environ\n\tfixup_argv_and_environ(argc, argv, UWSGI_ENVIRON, envp);\n\n\tif (gethostname(uwsgi.hostname, 255)) {\n\t\tuwsgi_error(\"gethostname()\");\n\t}\n\tuwsgi.hostname_len = strlen(uwsgi.hostname);\n\n#ifdef UWSGI_ROUTING\n\tuwsgi_register_embedded_routers();\n#endif\n\n\t// call here to allows plugin to override hooks\n\tuwsgi_register_base_hooks();\n\tuwsgi_register_logchunks();\n\tuwsgi_log_encoders_register_embedded();\n\n\t// register base metrics (so plugins can override them)\n\tuwsgi_metrics_collectors_setup();\n\n\t//initialize embedded plugins\n\tUWSGI_LOAD_EMBEDDED_PLUGINS\n\t\t// now a bit of magic, if the executable basename contains a 'uwsgi_' string,\n\t\t// try to automatically load a plugin\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_log(\"executable name: %s\\n\", uwsgi.binary_path);\n#endif\n\tuwsgi_autoload_plugins_by_name(argv[0]);\n\n\n\t// build the options structure\n\tbuild_options();\n\n\t// set a couple of 'static' magic vars\n\tuwsgi.magic_table['v'] = uwsgi.cwd;\n\tuwsgi.magic_table['h'] = uwsgi.hostname;\n\tuwsgi.magic_table['t'] = uwsgi_64bit2str(uwsgi_now());\n\tuwsgi.magic_table['T'] = uwsgi_64bit2str(uwsgi_micros());\n\tuwsgi.magic_table['V'] = UWSGI_VERSION;\n\tuwsgi.magic_table['k'] = uwsgi_num2str(uwsgi.cpus);\n\tuwsgi.magic_table['['] = \"\\033\";\n\tuwsgi.magic_table['u'] = uwsgi_num2str((int)getuid());\n\tstruct passwd *pw = getpwuid(getuid());\n\tuwsgi.magic_table['U'] = pw ? pw->pw_name : uwsgi.magic_table['u'];\n\tuwsgi.magic_table['g'] = uwsgi_num2str((int)getgid());\n\tstruct group *gr = getgrgid(getgid());\n\tuwsgi.magic_table['G'] = gr ? gr->gr_name : uwsgi.magic_table['g'];\n\n\t// you can embed a ini file in the uWSGi binary with default options\n#ifdef UWSGI_EMBED_CONFIG\n\tuwsgi_ini_config(\"\", uwsgi.magic_table);\n\t// rebuild options if a custom ini is set\n\tbuild_options();\n#endif\n\t//parse environ\n\tparse_sys_envs(UWSGI_ENVIRON);\n\n\t// parse commandline options\n\tuwsgi_commandline_config();\n\n\t// second pass: ENVs\n\tuwsgi_apply_config_pass('$', (char *(*)(char *)) getenv);\n\n\t// third pass: FILEs\n\tuwsgi_apply_config_pass('@', uwsgi_at_file_read);\n\n\t// last pass: REFERENCEs\n\tuwsgi_apply_config_pass('%', uwsgi_manage_placeholder);\n\n\t// ok, the options dictionary is available, lets manage it\n\tuwsgi_configure();\n\n\t// fixup cwd\n\tif (uwsgi.force_cwd) uwsgi.cwd = uwsgi.force_cwd;\n\n\t// run \"asap\" hooks\n\tuwsgi_hooks_run(uwsgi.hook_asap, \"asap\", 1);\n        struct uwsgi_string_list *usl = NULL;\n        uwsgi_foreach(usl, uwsgi.mount_asap) {\n        \tuwsgi_log(\"mounting \\\"%s\\\" (asap)...\\n\", usl->value);\n                if (uwsgi_mount_hook(usl->value)) exit(1);\n\t}\n        uwsgi_foreach(usl, uwsgi.umount_asap) {\n        \tuwsgi_log(\"un-mounting \\\"%s\\\" (asap)...\\n\", usl->value);\n                if (uwsgi_umount_hook(usl->value)) exit(1);\n\t}\n        uwsgi_foreach(usl, uwsgi.exec_asap) {\n        \tuwsgi_log(\"running \\\"%s\\\" (asap)...\\n\", usl->value);\n                int ret = uwsgi_run_command_and_wait(NULL, usl->value);\n                if (ret != 0) {\n                \tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n                        exit(1);\n                }\n\t}\n        uwsgi_foreach(usl, uwsgi.call_asap) {\n        \tif (uwsgi_call_symbol(usl->value)) {\n                \tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n                        exit(1);\n                }\n\t}\n\n\t// manage envdirs ASAP\n\tuwsgi_envdirs(uwsgi.envdirs);\n\n\t// --get management\n\tstruct uwsgi_string_list *get_list = uwsgi.get_list;\n\twhile(get_list) {\n\t\tchar *v = uwsgi_get_exported_opt(get_list->value);\n\t\tif (v) {\n\t\t\tfprintf(stdout, \"%s\\n\", v);\n\t\t}\n\t\tget_list = get_list->next;\n\t}\n\n\tif (uwsgi.get_list) {\n\t\texit(0);\n\t}\n\n\n\t// initial log setup (files and daemonization)\n\tuwsgi_setup_log();\n\n#ifndef __CYGWIN__\n\t// enable never-swap mode\n\tif (uwsgi.never_swap) {\n\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE)) {\n\t\t\tuwsgi_error(\"mlockall()\");\n\t\t}\n\t}\n#endif\n\n\tif (uwsgi.flock2)\n\t\tuwsgi_opt_flock(NULL, uwsgi.flock2, NULL);\n\n\tif (uwsgi.flock_wait2)\n\t\tuwsgi_opt_flock(NULL, uwsgi.flock_wait2, NULL);\n\n\t// setup master logging\n\tif (uwsgi.log_master && !uwsgi.daemonize2)\n\t\tuwsgi_setup_log_master();\n\n\t// setup offload engines\n\tuwsgi_offload_engines_register_all();\n\n\t// setup main loops\n\tuwsgi_register_loop(\"simple\", simple_loop);\n\tuwsgi_register_loop(\"async\", async_loop);\n\n\t// setup cheaper algos\n\tuwsgi_register_cheaper_algo(\"spare\", uwsgi_cheaper_algo_spare);\n\tuwsgi_register_cheaper_algo(\"backlog\", uwsgi_cheaper_algo_backlog);\n\tuwsgi_register_cheaper_algo(\"manual\", uwsgi_cheaper_algo_manual);\n\n\t// setup imperial monitors\n\tuwsgi_register_imperial_monitor(\"dir\", uwsgi_imperial_monitor_directory_init, uwsgi_imperial_monitor_directory);\n\tuwsgi_register_imperial_monitor(\"glob\", uwsgi_imperial_monitor_glob_init, uwsgi_imperial_monitor_glob);\n\n\t// setup stats pushers\n\tuwsgi_stats_pusher_setup();\n\n\t// register embedded alarms\n\tuwsgi_register_embedded_alarms();\n\n\t/* uWSGI IS CONFIGURED !!! */\n\n\tif (uwsgi.dump_options) {\n\t\tstruct option *lopt = uwsgi.long_options;\n\t\twhile (lopt && lopt->name) {\n\t\t\tfprintf(stdout, \"%s\\n\", lopt->name);\n\t\t\tlopt++;\n\t\t}\n\t\texit(0);\n\t}\n\n\tif (uwsgi.show_config)\n\t\tshow_config();\n\n\tif (uwsgi.plugins_list)\n\t\tplugins_list();\n\n\tif (uwsgi.loggers_list)\n\t\tloggers_list();\n\n\tif (uwsgi.cheaper_algo_list)\n\t\tcheaper_algo_list();\n\n\n#ifdef UWSGI_ROUTING\n\tif (uwsgi.router_list)\n\t\trouter_list();\n#endif\n\n\n\tif (uwsgi.loop_list)\n\t\tloop_list();\n\n\tif (uwsgi.imperial_monitor_list)\n\t\timperial_monitor_list();\n\n\tif (uwsgi.clock_list)\n\t\tclocks_list();\n\n\tif (uwsgi.alarms_list)\n\t\talarms_list();\n\n\t// set the clock\n\tif (uwsgi.requested_clock)\n\t\tuwsgi_set_clock(uwsgi.requested_clock);\n\n\tif (uwsgi.binary_path == uwsgi.argv[0]) {\n\t\tuwsgi.binary_path = uwsgi_str(uwsgi.argv[0]);\n\t}\n\n\tuwsgi_log_initial(\"*** Starting uWSGI %s (%dbit) on [%.*s] ***\\n\", UWSGI_VERSION, (int) (sizeof(void *)) * 8, 24, ctime((const time_t *) &uwsgi.start_tv.tv_sec));\n\n#ifdef UWSGI_DEBUG\n\tuwsgi_log(\"***\\n*** You are running a DEBUG version of uWSGI, please disable debug in your build profile and recompile it ***\\n***\\n\");\n#endif\n\n\tuwsgi_log_initial(\"compiled with version: %s on %s\\n\", __VERSION__, UWSGI_BUILD_DATE);\n\n#ifdef __sun__\n\tif (uname(&uuts) < 0) {\n#else\n\tif (uname(&uuts)) {\n#endif\n\t\tuwsgi_error(\"uname()\");\n\t}\n\telse {\n\t\tuwsgi_log_initial(\"os: %s-%s %s\\n\", uuts.sysname, uuts.release, uuts.version);\n\t\tuwsgi_log_initial(\"nodename: %s\\n\", uuts.nodename);\n\t\tuwsgi_log_initial(\"machine: %s\\n\", uuts.machine);\n\t}\n\n\tuwsgi_log_initial(\"clock source: %s\\n\", uwsgi.clock->name);\n#ifdef UWSGI_PCRE\n\tif (uwsgi.pcre_jit) {\n\t\tuwsgi_log_initial(\"pcre jit enabled\\n\");\n\t}\n\telse {\n\t\tuwsgi_log_initial(\"pcre jit disabled\\n\");\n\t}\n#endif\n\n#ifdef __BIG_ENDIAN__\n\tuwsgi_log_initial(\"*** big endian arch detected ***\\n\");\n#endif\n\n\tuwsgi_log_initial(\"detected number of CPU cores: %d\\n\", uwsgi.cpus);\n\n\n\tuwsgi_log_initial(\"current working directory: %s\\n\", uwsgi.cwd);\n\n\tif (uwsgi.screen_session) {\n\t\tuwsgi_log(\"*** running under screen session %s ***\\n\", uwsgi.screen_session);\n\t}\n\n\tif (uwsgi.pidfile && !uwsgi.is_a_reload) {\n\t\tuwsgi_write_pidfile(uwsgi.pidfile);\n\t}\n\n\tuwsgi_log_initial(\"detected binary path: %s\\n\", uwsgi.binary_path);\n\n\tif (uwsgi.is_a_reload) {\n\t\tstruct rlimit rl;\n\t\tif (!getrlimit(RLIMIT_NOFILE, &rl)) {\n\t\t\tuwsgi.max_fd = rl.rlim_cur;\n\t\t}\n\t}\n\n#ifdef UWSGI_ROUTING\n\tuwsgi_routing_dump();\n#else\n\tuwsgi_log(\"!!! no internal routing support, rebuild with pcre support !!!\\n\");\n#endif\n\n\t// initialize shared sockets\n\tuwsgi_setup_shared_sockets();\n\n#ifdef __linux__\n\tif (uwsgi.setns_preopen) {\n\t\tuwsgi_setns_preopen();\n\t}\n\t// eventually join a linux namespace\n\tif (uwsgi.setns) {\n\t\tuwsgi_setns(uwsgi.setns);\n\t}\n#endif\n\n\t// start the Emperor if needed\n\tif (uwsgi.early_emperor && uwsgi.emperor) {\n\t\tuwsgi_emperor_start();\n\t}\n\n\tif (!uwsgi.reloads) {\n\t\tuwsgi_hooks_run(uwsgi.hook_pre_jail, \"pre-jail\", 1);\n\t\tstruct uwsgi_string_list *usl = NULL;\n\t\tuwsgi_foreach(usl, uwsgi.mount_pre_jail) {\n                                uwsgi_log(\"mounting \\\"%s\\\" (pre-jail)...\\n\", usl->value);\n                                if (uwsgi_mount_hook(usl->value)) {\n                                        exit(1);\n                                }\n                        }\n\n                        uwsgi_foreach(usl, uwsgi.umount_pre_jail) {\n                                uwsgi_log(\"un-mounting \\\"%s\\\" (pre-jail)...\\n\", usl->value);\n                                if (uwsgi_umount_hook(usl->value)) {\n                                        exit(1);\n                                }\n                        }\n\t\t// run the pre-jail scripts\n\t\tuwsgi_foreach(usl, uwsgi.exec_pre_jail) {\n\t\t\tuwsgi_log(\"running \\\"%s\\\" (pre-jail)...\\n\", usl->value);\n\t\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\t\tif (ret != 0) {\n\t\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi_foreach(usl, uwsgi.call_pre_jail) {\n\t\t\tif (uwsgi_call_symbol(usl->value)) {\n\t\t\t\tuwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// we could now patch the binary\n\tif (uwsgi.privileged_binary_patch) {\n\t\tuwsgi.argv[0] = uwsgi.privileged_binary_patch;\n\t\texecvp(uwsgi.privileged_binary_patch, uwsgi.argv);\n\t\tuwsgi_error(\"execvp()\");\n\t\texit(1);\n\t}\n\n\tif (uwsgi.privileged_binary_patch_arg) {\n\t\tuwsgi_exec_command_with_args(uwsgi.privileged_binary_patch_arg);\n\t}\n\n\n\t// call jail systems\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->jail) {\n\t\t\tuwsgi.gp[i]->jail(uwsgi_start, uwsgi.argv);\n\t\t}\n\t}\n\n\t// TODO pluginize basic Linux namespace support\n#if defined(__linux__) && !defined(__ia64__)\n\tif (uwsgi.ns) {\n\t\tlinux_namespace_start((void *) uwsgi.argv);\n\t\t// never here\n\t}\n\telse {\n#endif\n\t\tuwsgi_start((void *) uwsgi.argv);\n#if defined(__linux__) && !defined(__ia64__)\n\t}\n#endif\n\n\tif (uwsgi.safe_pidfile && !uwsgi.is_a_reload) {\n\t\tuwsgi_write_pidfile_explicit(uwsgi.safe_pidfile, masterpid);\n\t}\n}\n\n\nint uwsgi_start(void *v_argv) {\n\n\tint i, j;\n\n#ifdef __linux__\n\tuwsgi_set_cgroup();\n\n#if !defined(__ia64__)\n\tif (uwsgi.ns) {\n\t\tlinux_namespace_jail();\n\t}\n#endif\n#endif\n\n\tuwsgi_hooks_run(uwsgi.hook_in_jail, \"in-jail\", 1);\n\n\tstruct uwsgi_string_list *usl;\n\n\tuwsgi_foreach(usl, uwsgi.mount_in_jail) {\n                                uwsgi_log(\"mounting \\\"%s\\\" (in-jail)...\\n\", usl->value);\n                                if (uwsgi_mount_hook(usl->value)) {\n                                        exit(1);\n                                }\n                        }\n\n                        uwsgi_foreach(usl, uwsgi.umount_in_jail) {\n                                uwsgi_log(\"un-mounting \\\"%s\\\" (in-jail)...\\n\", usl->value);\n                                if (uwsgi_umount_hook(usl->value)) {\n                                        exit(1);\n                                }\n                        }\n\n\tuwsgi_foreach(usl, uwsgi.exec_in_jail) {\n                uwsgi_log(\"running \\\"%s\\\" (in-jail)...\\n\", usl->value);\n                int ret = uwsgi_run_command_and_wait(NULL, usl->value);\n                if (ret != 0) {\n                        uwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n                        exit(1);\n                }\n        }\n\n        uwsgi_foreach(usl, uwsgi.call_in_jail) {\n                if (uwsgi_call_symbol(usl->value)) {\n                        uwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n                }\n        }\n\n\n\tuwsgi_file_write_do(uwsgi.file_write_list);\n\n\tif (!uwsgi.master_as_root && !uwsgi.chown_socket && !uwsgi.drop_after_init && !uwsgi.drop_after_apps) {\n\t\tuwsgi_as_root();\n\t}\n\n\t// wait for socket\n\tuwsgi_foreach(usl, uwsgi.wait_for_socket) {\n\t\tif (uwsgi_wait_for_socket(usl->value)) exit(1);\n\t}\n\n\tif (uwsgi.logto2) {\n\t\tif (!uwsgi.is_a_reload || uwsgi.log_reopen) {\n\t\t\tlogto(uwsgi.logto2);\n\t\t}\n\t}\n\n\tif (uwsgi.chdir) {\n\t\tuwsgi_log(\"chdir() to %s\\n\", uwsgi.chdir);\n\t\tif (chdir(uwsgi.chdir)) {\n\t\t\tuwsgi_error(\"chdir()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (uwsgi.pidfile2 && !uwsgi.is_a_reload) {\n\t\tuwsgi_write_pidfile(uwsgi.pidfile2);\n\t}\n\n\tif (!uwsgi.master_process && !uwsgi.command_mode) {\n\t\tuwsgi_log_initial(\"*** WARNING: you are running uWSGI without its master process manager ***\\n\");\n\t}\n\n#ifdef RLIMIT_NPROC\n\tif (uwsgi.rl_nproc.rlim_max > 0) {\n\t\tuwsgi.rl_nproc.rlim_cur = uwsgi.rl_nproc.rlim_max;\n\t\tuwsgi_log_initial(\"limiting number of processes to %d...\\n\", (int) uwsgi.rl_nproc.rlim_max);\n\t\tif (setrlimit(RLIMIT_NPROC, &uwsgi.rl_nproc)) {\n\t\t\tuwsgi_error(\"setrlimit()\");\n\t\t}\n\t}\n\n\tif (!getrlimit(RLIMIT_NPROC, &uwsgi.rl_nproc)) {\n\t\tif (uwsgi.rl_nproc.rlim_cur != RLIM_INFINITY) {\n\t\t\tuwsgi_log_initial(\"your processes number limit is %d\\n\", (int) uwsgi.rl_nproc.rlim_cur);\n\t\t\tif ((int) uwsgi.rl_nproc.rlim_cur < uwsgi.numproc + uwsgi.master_process) {\n\t\t\t\tuwsgi.numproc = uwsgi.rl_nproc.rlim_cur - 1;\n\t\t\t\tuwsgi_log_initial(\"!!! number of workers adjusted to %d due to system limits !!!\\n\", uwsgi.numproc);\n\t\t\t}\n\t\t}\n\t}\n#endif\n#ifndef __OpenBSD__\n\n\tif (uwsgi.rl.rlim_max > 0) {\n\t\tuwsgi.rl.rlim_cur = uwsgi.rl.rlim_max;\n\t\tuwsgi_log_initial(\"limiting address space of processes...\\n\");\n\t\tif (setrlimit(RLIMIT_AS, &uwsgi.rl)) {\n\t\t\tuwsgi_error(\"setrlimit()\");\n\t\t}\n\t}\n\tif (uwsgi.prio != 0) {\n#ifdef __HAIKU__\n\t\tif (set_thread_priority(find_thread(NULL), uwsgi.prio) == B_BAD_THREAD_ID) {\n\t\t\tuwsgi_error(\"set_thread_priority()\");\n#else\n\t\tif (setpriority(PRIO_PROCESS, 0, uwsgi.prio)) {\n\t\t\tuwsgi_error(\"setpriority()\");\n#endif\n\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log_initial(\"scheduler priority set to %d\\n\", uwsgi.prio);\n\t\t}\n\t}\n\tif (!getrlimit(RLIMIT_AS, &uwsgi.rl)) {\n\t\t//check for overflow\n\t\tif (uwsgi.rl.rlim_max != (rlim_t) RLIM_INFINITY) {\n\t\t\tuwsgi_log_initial(\"your process address space limit is %lld bytes (%lld MB)\\n\", (long long) uwsgi.rl.rlim_max, (long long) uwsgi.rl.rlim_max / 1024 / 1024);\n\t\t}\n\t}\n#endif\n\n\tuwsgi_log_initial(\"your memory page size is %d bytes\\n\", uwsgi.page_size);\n\n\t// automatically fix options\n\tsanitize_args();\n\n\n\tif (uwsgi.requested_max_fd) {\n\t\tuwsgi.rl.rlim_cur = uwsgi.requested_max_fd;\n\t\tuwsgi.rl.rlim_max = uwsgi.requested_max_fd;\n\t\tif (setrlimit(RLIMIT_NOFILE, &uwsgi.rl)) {\n\t\t\tuwsgi_error(\"setrlimit()\");\n\t\t}\n\t}\n\n\tif (!getrlimit(RLIMIT_NOFILE, &uwsgi.rl)) {\n\t\tuwsgi.max_fd = uwsgi.rl.rlim_cur;\n\t\tuwsgi_log_initial(\"detected max file descriptor number: %lu\\n\", (unsigned long) uwsgi.max_fd);\n\t}\n\n\t// start the Emperor if needed\n\tif (!uwsgi.early_emperor && uwsgi.emperor) {\n\t\tuwsgi_emperor_start();\n\t}\n\n\t// end of generic initialization\n\n\n\t// build mime.types dictionary\n\tif (uwsgi.build_mime_dict) {\n\t\tif (!uwsgi.mime_file)\n#ifdef __APPLE__\n\t\t\tuwsgi_string_new_list(&uwsgi.mime_file, \"/etc/apache2/mime.types\");\n#else\n\t\t\tuwsgi_string_new_list(&uwsgi.mime_file, \"/etc/mime.types\");\n#endif\n\t\tstruct uwsgi_string_list *umd = uwsgi.mime_file;\n\t\twhile (umd) {\n\t\t\tif (!access(umd->value, R_OK)) {\n\t\t\t\tuwsgi_build_mime_dict(umd->value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_log(\"!!! no %s file found !!!\\n\", umd->value);\n\t\t\t}\n\t\t\tumd = umd->next;\n\t\t}\n\t}\n\n\tif (uwsgi.async > 1) {\n\t\tif ((unsigned long) uwsgi.max_fd < (unsigned long) uwsgi.async) {\n\t\t\tuwsgi_log_initial(\"- your current max open files limit is %lu, this is lower than requested async cores !!! -\\n\", (unsigned long) uwsgi.max_fd);\n\t\t\tuwsgi.rl.rlim_cur = uwsgi.async;\n\t\t\tuwsgi.rl.rlim_max = uwsgi.async;\n\t\t\tif (!setrlimit(RLIMIT_NOFILE, &uwsgi.rl)) {\n\t\t\t\tuwsgi_log(\"max open files limit raised to %lu\\n\", (unsigned long) uwsgi.rl.rlim_cur);\n\t\t\t\tuwsgi.async = uwsgi.rl.rlim_cur;\n\t\t\t\tuwsgi.max_fd = uwsgi.rl.rlim_cur;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi.async = (int) uwsgi.max_fd;\n\t\t\t}\n\t\t}\n\t\tuwsgi_log_initial(\"- async cores set to %d - fd table size: %d\\n\", uwsgi.async, (int) uwsgi.max_fd);\n\t}\n\n#ifdef UWSGI_DEBUG\n\tuwsgi_log(\"cores allocated...\\n\");\n#endif\n\n\tif (uwsgi.vhost) {\n\t\tuwsgi_log_initial(\"VirtualHosting mode enabled.\\n\");\n\t}\n\n\t// setup locking\n\tuwsgi_setup_locking();\n\tif (uwsgi.use_thunder_lock) {\n\t\tuwsgi_log_initial(\"thunder lock: enabled\\n\");\n\t}\n\telse {\n\t\tuwsgi_log_initial(\"thunder lock: disabled (you can enable it with --thunder-lock)\\n\");\n\t}\n\n\t// allocate rpc structures\n        uwsgi_rpc_init();\n\n\t// initialize sharedareas\n\tuwsgi_sharedareas_init();\n\n\tuwsgi.snmp_lock = uwsgi_lock_init(\"snmp\");\n\n\t// setup queue\n\tif (uwsgi.queue_size > 0) {\n\t\tuwsgi_init_queue();\n\t}\n\n\tuwsgi_cache_create_all();\n\n\tif (uwsgi.use_check_cache) {\n\t\tuwsgi.check_cache = uwsgi_cache_by_name(uwsgi.use_check_cache);\n\t\tif (!uwsgi.check_cache) {\n\t\t\tuwsgi_log(\"unable to find cache \\\"%s\\\"\\n\", uwsgi.use_check_cache);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (uwsgi.use_static_cache_paths) {\n\t\tif (uwsgi.static_cache_paths_name) {\n\t\t\tuwsgi.static_cache_paths = uwsgi_cache_by_name(uwsgi.static_cache_paths_name);\n\t\t\tif (!uwsgi.static_cache_paths) {\n\t\t\t\tuwsgi_log(\"unable to find cache \\\"%s\\\"\\n\", uwsgi.static_cache_paths_name);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!uwsgi.caches) {\n                \t\tuwsgi_log(\"caching of static paths requires uWSGI caching !!!\\n\");\n                \t\texit(1);\n\t\t\t}\n\t\t\tuwsgi.static_cache_paths = uwsgi.caches;\n\t\t}\n        }\n\n        // initialize the alarm subsystem\n        uwsgi_alarms_init();\n\n\t// initialize the exception handlers\n\tuwsgi_exception_setup_handlers();\n\n\t// initialize socket protocols (do it after caching !!!)\n\tuwsgi_protocols_register();\n\n\t/* plugin initialization */\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->init) {\n\t\t\tuwsgi.gp[i]->init();\n\t\t}\n\t}\n\n\tif (!uwsgi.no_server) {\n\n\t\t// systemd/upstart/zerg socket activation\n\t\tif (!uwsgi.is_a_reload) {\n\t\t\tuwsgi_setup_systemd();\n\t\t\tuwsgi_setup_upstart();\n\t\t\tuwsgi_setup_zerg();\n\t\t\tuwsgi_setup_emperor();\n\t\t}\n\n\n\t\t//check for inherited sockets\n\t\tif (uwsgi.is_a_reload) {\n\t\t\tuwsgi_setup_inherited_sockets();\n\t\t}\n\n\n\t\t//now bind all the unbound sockets\n\t\tuwsgi_bind_sockets();\n\n\t\tif (!uwsgi.master_as_root && !uwsgi.drop_after_init && !uwsgi.drop_after_apps) {\n\t\t\tuwsgi_as_root();\n\t\t}\n\n\t\t// put listening socket in non-blocking state and set the protocol\n\t\tuwsgi_set_sockets_protocols();\n\n\t}\n\n\n\t// initialize request plugin only if workers or master are available\n\tif (uwsgi.sockets || uwsgi.master_process || uwsgi.no_server || uwsgi.command_mode || uwsgi.loop) {\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (uwsgi.p[i]->init) {\n\t\t\t\tuwsgi.p[i]->init();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!uwsgi.master_as_root && !uwsgi.drop_after_apps) {\n\t\tuwsgi_as_root();\n\t}\n\n\n\t/* gp/plugin initialization */\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->post_init) {\n\t\t\tuwsgi.gp[i]->post_init();\n\t\t}\n\t}\n\n\t// again check for workers/sockets...\n\tif (uwsgi.sockets || uwsgi.master_process || uwsgi.no_server || uwsgi.command_mode || uwsgi.loop) {\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (uwsgi.p[i]->post_init) {\n\t\t\t\tuwsgi.p[i]->post_init();\n\t\t\t}\n\t\t}\n\t}\n\n\tuwsgi.current_wsgi_req = simple_current_wsgi_req;\n\n\n\tif (uwsgi.has_threads) {\n\t\tif (uwsgi.threads > 1)\n\t\t\tuwsgi.current_wsgi_req = threaded_current_wsgi_req;\n\t\t(void) pthread_attr_init(&uwsgi.threads_attr);\n\t\tif (uwsgi.threads_stacksize) {\n\t\t\tif (pthread_attr_setstacksize(&uwsgi.threads_attr, uwsgi.threads_stacksize * 1024) == 0) {\n\t\t\t\tuwsgi_log(\"threads stack size set to %luk\\n\", (unsigned long) uwsgi.threads_stacksize);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_log(\"!!! unable to set requested threads stacksize !!!\\n\");\n\t\t\t}\n\t\t}\n\n\t\tpthread_mutex_init(&uwsgi.lock_static, NULL);\n\n\t\t// again check for workers/sockets...\n\t\tif (uwsgi.sockets || uwsgi.master_process || uwsgi.no_server || uwsgi.command_mode || uwsgi.loop) {\n\t\t\tfor (i = 0; i < 256; i++) {\n\t\t\t\tif (uwsgi.p[i]->enable_threads)\n\t\t\t\t\tuwsgi.p[i]->enable_threads();\n\t\t\t}\n\t\t}\n\t}\n\n\t// users of the --loop option should know what they are doing... really...\n#ifndef UWSGI_DEBUG\n\tif (uwsgi.loop)\n\t\tgoto unsafe;\n#endif\n\n\tif (!uwsgi.sockets &&\n\t\t!ushared->gateways_cnt &&\n\t\t!uwsgi.no_server &&\n\t\t!uwsgi.udp_socket &&\n\t\t!uwsgi.emperor &&\n\t\t!uwsgi.command_mode &&\n\t\t!uwsgi.daemons_cnt &&\n\t\t!uwsgi.crons &&\n\t\t!uwsgi.spoolers &&\n\t\t!uwsgi.emperor_proxy\n#ifdef __linux__\n\t\t&& !uwsgi.setns_socket\n#endif\n#ifdef UWSGI_SSL\n&& !uwsgi.legions\n#endif\n\t\t) {\n\t\tuwsgi_log(\"The -s/--socket option is missing and stdin is not a socket.\\n\");\n\t\texit(1);\n\t}\n\telse if (!uwsgi.sockets && ushared->gateways_cnt && !uwsgi.no_server && !uwsgi.master_process) {\n\t\t// here we will have a zombie... sorry\n\t\tuwsgi_log(\"...you should enable the master process... really...\\n\");\n\t\tif (uwsgi.force_gateway) {\n\t\t\tstruct uwsgi_gateway *ug = &ushared->gateways[0];\n\t\t\tug->loop(0, ug->data);\n\t\t\t// when we are here the gateway is dead :(\n\t\t}\n\t\texit(0);\n\t}\n\n\tif (!uwsgi.sockets)\n\t\tuwsgi.numproc = 0;\n\n\tif (uwsgi.command_mode) {\n\t\tuwsgi.sockets = NULL;\n\t\tuwsgi.numproc = 1;\n\t\t// hack to destroy the instance after command exit\n\t\tuwsgi.status.brutally_destroying = 1;\n\t}\n\n#ifndef UWSGI_DEBUG\nunsafe:\n#endif\n\n#ifdef UWSGI_DEBUG\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi.sockets;\n\tint so_bufsize;\n\tsocklen_t so_bufsize_len;\n\twhile (uwsgi_sock) {\n\t\tso_bufsize_len = sizeof(int);\n\t\tif (getsockopt(uwsgi_sock->fd, SOL_SOCKET, SO_RCVBUF, &so_bufsize, &so_bufsize_len)) {\n\t\t\tuwsgi_error(\"getsockopt()\");\n\t\t}\n\t\telse {\n\t\t\tuwsgi_debug(\"uwsgi socket %d SO_RCVBUF size: %d\\n\", i, so_bufsize);\n\t\t}\n\n\t\tso_bufsize_len = sizeof(int);\n\t\tif (getsockopt(uwsgi_sock->fd, SOL_SOCKET, SO_SNDBUF, &so_bufsize, &so_bufsize_len)) {\n\t\t\tuwsgi_error(\"getsockopt()\");\n\t\t}\n\t\telse {\n\t\t\tuwsgi_debug(\"uwsgi socket %d SO_SNDBUF size: %d\\n\", i, so_bufsize);\n\t\t}\n\t\tuwsgi_sock = uwsgi_sock->next;\n\t}\n#endif\n\n\n#ifndef UNBIT\n\tif (uwsgi.sockets)\n\t\tuwsgi_log(\"your server socket listen backlog is limited to %d connections\\n\", uwsgi.listen_queue);\n#endif\n\n\tuwsgi_log(\"your mercy for graceful operations on workers is %d seconds\\n\", uwsgi.worker_reload_mercy);\n\n\tif (uwsgi.crons) {\n\t\tstruct uwsgi_cron *ucron = uwsgi.crons;\n\t\twhile (ucron) {\n#ifdef UWSGI_SSL\n\t\t\tif (ucron->legion) {\n\t\t\t\tuwsgi_log(\"[uwsgi-cron] command \\\"%s\\\" registered as cron task for legion \\\"%s\\\"\\n\", ucron->command, ucron->legion);\n\t\t\t\tucron = ucron->next;\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tuwsgi_log(\"[uwsgi-cron] command \\\"%s\\\" registered as cron task\\n\", ucron->command);\n\t\t\tucron = ucron->next;\n\t\t}\n\t}\n\n\n\t// initialize post buffering values\n\tif (uwsgi.post_buffering > 0)\n\t\tuwsgi_setup_post_buffering();\n\n\t// initialize workers/master shared memory segments\n\tuwsgi_setup_workers();\n\n\t// create signal pipes if master is enabled\n\tif (uwsgi.master_process) {\n\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\tcreate_signal_pipe(uwsgi.workers[i].signal_pipe);\n\t\t}\n\t}\n\n\t// set masterpid\n\tuwsgi.mypid = getpid();\n\tmasterpid = uwsgi.mypid;\n\tuwsgi.workers[0].pid = masterpid;\n\n\t// initialize mules and farms\n\tuwsgi_setup_mules_and_farms();\n\n\tif (uwsgi.command_mode) {\n\t\tuwsgi_log(\"*** Operational MODE: command ***\\n\");\n\t}\n\telse if (!uwsgi.numproc) {\n\t\tuwsgi_log(\"*** Operational MODE: no-workers ***\\n\");\n\t}\n\telse if (uwsgi.threads > 1) {\n\t\tif (uwsgi.numproc > 1) {\n\t\t\tuwsgi_log(\"*** Operational MODE: preforking+threaded ***\\n\");\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"*** Operational MODE: threaded ***\\n\");\n\t\t}\n\t}\n\telse if (uwsgi.async > 1) {\n\t\tif (uwsgi.numproc > 1) {\n\t\t\tuwsgi_log(\"*** Operational MODE: preforking+async ***\\n\");\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"*** Operational MODE: async ***\\n\");\n\t\t}\n\t}\n\telse if (uwsgi.numproc > 1) {\n\t\tuwsgi_log(\"*** Operational MODE: preforking ***\\n\");\n\t}\n\telse {\n\t\tuwsgi_log(\"*** Operational MODE: single process ***\\n\");\n\t}\n\n\t// set a default request structure (for loading apps...)\n\tuwsgi.wsgi_req = &uwsgi.workers[0].cores[0].req;\n\n\t// ok, let's initialize the metrics subsystem\n\tuwsgi_setup_metrics();\n\n\t// cores are allocated, lets allocate logformat (if required)\n\tif (uwsgi.logformat) {\n\t\tuwsgi_build_log_format(uwsgi.logformat);\n\t\tuwsgi.logit = uwsgi_logit_lf;\n\t\t// TODO check it\n\t\t//if (uwsgi.logformat_strftime) {\n\t\t\t//uwsgi.logit = uwsgi_logit_lf_strftime;\n\t\t//}\n\t\tuwsgi.logvectors = uwsgi_malloc(sizeof(struct iovec *) * uwsgi.cores);\n\t\tfor (j = 0; j < uwsgi.cores; j++) {\n\t\t\tuwsgi.logvectors[j] = uwsgi_malloc(sizeof(struct iovec) * uwsgi.logformat_vectors);\n\t\t\tuwsgi.logvectors[j][uwsgi.logformat_vectors - 1].iov_base = \"\\n\";\n\t\t\tuwsgi.logvectors[j][uwsgi.logformat_vectors - 1].iov_len = 1;\n\t\t}\n\t}\n\n\t// initialize locks and socket as soon as possible, as the master could enqueue tasks\n\tif (uwsgi.spoolers != NULL) {\n\t\tcreate_signal_pipe(uwsgi.shared->spooler_signal_pipe);\n\t\tstruct uwsgi_spooler *uspool = uwsgi.spoolers;\n\t\twhile (uspool) {\n\t\t\t// lock is required even in EXTERNAL mode\n\t\t\tuspool->lock = uwsgi_lock_init(uwsgi_concat2(\"spooler on \", uspool->dir));\n\t\t\tif (uspool->mode == UWSGI_SPOOLER_EXTERNAL)\n\t\t\t\tgoto next;\n\t\t\tcreate_signal_pipe(uspool->signal_pipe);\nnext:\n\t\t\tuspool = uspool->next;\n\t\t}\n\t}\n\n\t// preinit apps (create the language environment)\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->preinit_apps) {\n\t\t\tuwsgi.p[i]->preinit_apps();\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->preinit_apps) {\n\t\t\tuwsgi.gp[i]->preinit_apps();\n\t\t}\n\t}\n\n\t//init apps hook (if not lazy)\n\tif (!uwsgi.lazy && !uwsgi.lazy_apps) {\n\t\tuwsgi_init_all_apps();\n\t}\n\n\t// Register uwsgi atexit plugin callbacks after all applications have\n\t// been loaded. This ensures plugin atexit callbacks are called prior\n\t// to application registered atexit callbacks.\n\tatexit(uwsgi_plugins_atexit);\n\n\tif (!uwsgi.master_as_root) {\n\t\tuwsgi_as_root();\n\t}\n\n\t// postinit apps (setup specific features after app initialization)\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->postinit_apps) {\n\t\t\tuwsgi.p[i]->postinit_apps();\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->postinit_apps) {\n\t\t\tuwsgi.gp[i]->postinit_apps();\n\t\t}\n\t}\n\n\t// initialize after_request hooks\n\tuwsgi_foreach(usl, uwsgi.after_request_hooks) {\n\t\tusl->custom_ptr =  dlsym(RTLD_DEFAULT, usl->value);\n\t\tif (!usl->custom_ptr) {\n\t\t\tuwsgi_log(\"unable to find symbol/function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n\t\t}\n\t\tuwsgi_log(\"added \\\"%s(struct wsgi_request *)\\\" to the after-request chain\\n\", usl->value);\n\t}\n\n\tif (uwsgi.daemonize2) {\n\t\tmasterpid = uwsgi_daemonize2();\n\t}\n\n\tif (uwsgi.no_server) {\n\t\tuwsgi_log(\"no-server mode requested. Goodbye.\\n\");\n\t\texit(0);\n\t}\n\n\n\tif (!uwsgi.master_process && uwsgi.numproc == 0) {\n\t\texit(0);\n\t}\n\n\tif (!uwsgi.single_interpreter && uwsgi.numproc > 0) {\n\t\tuwsgi_log(\"*** uWSGI is running in multiple interpreter mode ***\\n\");\n\t}\n\n\t// check for request plugins, and eventually print a warning\n\tint rp_available = 0;\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i] != &unconfigured_plugin) {\n\t\t\trp_available = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!rp_available && !ushared->gateways_cnt) {\n\t\tuwsgi_log(\"!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!\\n\");\n\t\tuwsgi_log(\"no request plugin is loaded, you will not be able to manage requests.\\n\");\n\t\tuwsgi_log(\"you may need to install the package for your language of choice, or simply load it with --plugin.\\n\");\n\t\tuwsgi_log(\"!!!!!!!!!!! END OF WARNING !!!!!!!!!!\\n\");\n\t}\n\n#ifdef __linux__\n#ifdef MADV_MERGEABLE\n\tif (uwsgi.linux_ksm > 0) {\n\t\tuwsgi_log(\"[uwsgi-KSM] enabled with frequency: %d\\n\", uwsgi.linux_ksm);\n\t}\n#endif\n#endif\n\n\tif (uwsgi.master_process) {\n\t\t// initialize threads with shared state\n\t\tuwsgi_alarm_thread_start();\n        \tuwsgi_exceptions_handler_thread_start();\n\t\t// initialize a mutex to avoid glibc problem with pthread+fork()\n\t\tif (uwsgi.threaded_logger) {\n\t\t\tpthread_mutex_init(&uwsgi.threaded_logger_lock, NULL);\n\t\t}\n\n\t\tif (uwsgi.is_a_reload) {\n\t\t\tuwsgi_log(\"gracefully (RE)spawned uWSGI master process (pid: %d)\\n\", uwsgi.mypid);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"spawned uWSGI master process (pid: %d)\\n\", uwsgi.mypid);\n\t\t}\n\t}\n\n\n\n\t// security in multiuser environment: allow only a subset of modifiers\n\tif (uwsgi.allowed_modifiers) {\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (!uwsgi_list_has_num(uwsgi.allowed_modifiers, i)) {\n\t\t\t\tuwsgi.p[i]->request = unconfigured_hook;\n\t\t\t\tuwsgi.p[i]->after_request = unconfigured_after_hook;\n\t\t\t}\n\t\t}\n\t}\n\n\t// master fixup\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->master_fixup) {\n\t\t\tuwsgi.p[i]->master_fixup(0);\n\t\t}\n\t}\n\n\n\n\tstruct uwsgi_spooler *uspool = uwsgi.spoolers;\n\twhile (uspool) {\n\t\tif (uspool->mode == UWSGI_SPOOLER_EXTERNAL)\n\t\t\tgoto next2;\n\t\tuspool->pid = spooler_start(uspool);\nnext2:\n\t\tuspool = uspool->next;\n\t}\n\n\tif (!uwsgi.master_process) {\n\t\tif (uwsgi.numproc == 1) {\n\t\t\tuwsgi_log(\"spawned uWSGI worker 1 (and the only) (pid: %d, cores: %d)\\n\", masterpid, uwsgi.cores);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"spawned uWSGI worker 1 (pid: %d, cores: %d)\\n\", masterpid, uwsgi.cores);\n\t\t}\n\t\tuwsgi.workers[1].pid = masterpid;\n\t\tuwsgi.workers[1].id = 1;\n\t\tuwsgi.workers[1].last_spawn = uwsgi_now();\n\t\tuwsgi.workers[1].manage_next_request = 1;\n\t\tuwsgi.mywid = 1;\n\t\tuwsgi.respawn_delta = uwsgi_now();\n\t}\n\telse {\n\t\t// setup internal signalling system\n\t\tcreate_signal_pipe(uwsgi.shared->worker_signal_pipe);\n\t\tuwsgi.signal_socket = uwsgi.shared->worker_signal_pipe[1];\n\t}\n\n\t// uWSGI is ready\n\tuwsgi_notify_ready();\n\tuwsgi.current_time = uwsgi_now();\n\n\t// here we spawn the workers...\n\tif (!uwsgi.status.is_cheap) {\n\t\tif (uwsgi.cheaper && uwsgi.cheaper_count) {\n\t\t\tint nproc = uwsgi.cheaper_initial;\n\t\t\tif (!nproc)\n\t\t\t\tnproc = uwsgi.cheaper_count;\n\t\t\tfor (i = 1; i <= uwsgi.numproc; i++) {\n\t\t\t\tif (i <= nproc) {\n\t\t\t\t\tif (uwsgi_respawn_worker(i))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tuwsgi.respawn_delta = uwsgi_now();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tuwsgi.workers[i].cheaped = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (i = 2 - uwsgi.master_process; i < uwsgi.numproc + 1; i++) {\n\t\t\t\tif (uwsgi_respawn_worker(i))\n\t\t\t\t\tbreak;\n\t\t\t\tuwsgi.respawn_delta = uwsgi_now();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (uwsgi.safe_pidfile2 && !uwsgi.is_a_reload) {\n\t\tuwsgi_write_pidfile_explicit(uwsgi.safe_pidfile2, masterpid);\n\t}\n\n\t// END OF INITIALIZATION\n\treturn 0;\n\n}\n\n// this lives in a worker thread and periodically scans for memory usage\n// when evil reloaders are in place\nvoid *mem_collector(void *foobar) {\n\t// block all signals\n        sigset_t smask;\n        sigfillset(&smask);\n        pthread_sigmask(SIG_BLOCK, &smask, NULL);\n\tuwsgi_log_verbose(\"mem-collector thread started for worker %d\\n\", uwsgi.mywid);\n\tfor(;;) {\n\t\tsleep(uwsgi.mem_collector_freq);\n\t\tuint64_t rss, vsz;\n\t\tget_memusage(&rss, &vsz);\n\t\tuwsgi.workers[uwsgi.mywid].rss_size = rss;\n\t\tuwsgi.workers[uwsgi.mywid].vsz_size = vsz;\n\t}\n\treturn NULL;\n}\n\nint uwsgi_run() {\n\n\t// !!! from now on, we could be in the master or in a worker !!!\n\tint i;\n\n\tif (getpid() == masterpid && uwsgi.master_process == 1) {\n#ifdef UWSGI_AS_SHARED_LIBRARY\n\t\tint ml_ret = master_loop(uwsgi.argv, uwsgi.environ);\n\t\tif (ml_ret == -1) {\n\t\t\treturn 0;\n\t\t}\n#else\n\t\t(void) master_loop(uwsgi.argv, uwsgi.environ);\n#endif\n\t\t//from now on the process is a real worker\n\t}\n\n#if defined(__linux__) && defined(PR_SET_PDEATHSIG)\n\t// avoid workers running without master at all costs !!! (dangerous)\n\tif (uwsgi.master_process && uwsgi.no_orphans) {\n\t\tif (prctl(PR_SET_PDEATHSIG, SIGKILL)) {\n\t\t\tuwsgi_error(\"uwsgi_run()/prctl()\");\n\t\t}\n\t}\n#endif\n\n\tif (uwsgi.evil_reload_on_rss || uwsgi.evil_reload_on_as) {\n\t\tpthread_t t;\n\t\tpthread_create(&t, NULL, mem_collector, NULL);\n\t}\n\n\n\t// eventually maps (or disable) sockets for the  worker\n\tuwsgi_map_sockets();\n\n\t// eventually set cpu affinity poilicies (OS-dependent)\n\tuwsgi_set_cpu_affinity();\n\n\tif (uwsgi.worker_exec) {\n\t\tchar *w_argv[2];\n\t\tw_argv[0] = uwsgi.worker_exec;\n\t\tw_argv[1] = NULL;\n\n\t\tuwsgi.sockets->arg &= (~O_NONBLOCK);\n\t\tif (fcntl(uwsgi.sockets->fd, F_SETFL, uwsgi.sockets->arg) < 0) {\n\t\t\tuwsgi_error(\"fcntl()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (uwsgi.sockets->fd != 0 && !uwsgi.honour_stdin) {\n\t\t\tif (dup2(uwsgi.sockets->fd, 0) < 0) {\n\t\t\t\tuwsgi_error(\"dup2()\");\n\t\t\t}\n\t\t}\n\t\texecvp(w_argv[0], w_argv);\n\t\t// never here\n\t\tuwsgi_error(\"execvp()\");\n\t\texit(1);\n\t}\n\n\tif (uwsgi.master_as_root) {\n\t\tuwsgi_as_root();\n\t}\n\n\t// set default wsgi_req (for loading apps);\n\tuwsgi.wsgi_req = &uwsgi.workers[uwsgi.mywid].cores[0].req;\n\n\tif (uwsgi.offload_threads > 0) {\n\t\tuwsgi.offload_thread = uwsgi_malloc(sizeof(struct uwsgi_thread *) * uwsgi.offload_threads);\n\t\tfor(i=0;i<uwsgi.offload_threads;i++) {\n\t\t\tuwsgi.offload_thread[i] = uwsgi_offload_thread_start();\n\t\t\tif (!uwsgi.offload_thread[i]) {\n\t\t\t\tuwsgi_log(\"unable to start offload thread %d for worker %d !!!\\n\", i, uwsgi.mywid);\n\t\t\t\tuwsgi.offload_threads = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tuwsgi_log(\"spawned %d offload threads for uWSGI worker %d\\n\", uwsgi.offload_threads, uwsgi.mywid);\n\t}\n\n\t// must be run before running apps\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->post_fork) {\n\t\t\tuwsgi.p[i]->post_fork();\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n                if (uwsgi.gp[i]->post_fork) {\n                        uwsgi.gp[i]->post_fork();\n                }\n        }\n\n\tuwsgi_hooks_run(uwsgi.hook_post_fork, \"post-fork\", 1);\n\n\tif (uwsgi.worker_exec2) {\n                char *w_argv[2];\n                w_argv[0] = uwsgi.worker_exec2;\n                w_argv[1] = NULL;\n\n                uwsgi.sockets->arg &= (~O_NONBLOCK);\n                if (fcntl(uwsgi.sockets->fd, F_SETFL, uwsgi.sockets->arg) < 0) {\n                        uwsgi_error(\"fcntl()\");\n                        exit(1);\n                }\n\n                if (uwsgi.sockets->fd != 0 && !uwsgi.honour_stdin) {\n                        if (dup2(uwsgi.sockets->fd, 0) < 0) {\n                                uwsgi_error(\"dup2()\");\n                        }\n                }\n                execvp(w_argv[0], w_argv);\n                // never here\n                uwsgi_error(\"execvp()\");\n                exit(1);\n        }\n\n\t// must be run before running apps\n\n\t// check for worker override\n        for (i = 0; i < 256; i++) {\n                if (uwsgi.p[i]->worker) {\n                        if (uwsgi.p[i]->worker()) {\n\t\t\t\t_exit(0);\n\t\t\t}\n                }\n        }\n\n        for (i = 0; i < uwsgi.gp_cnt; i++) {\n                if (uwsgi.gp[i]->worker) {\n                        if (uwsgi.gp[i]->worker()) {\n\t\t\t\t_exit(0);\n\t\t\t}\n                }\n        }\n\n\tuwsgi_worker_run();\n\t// never here\n\t_exit(0);\n\n}\n\nvoid uwsgi_worker_run() {\n\n\tint i;\n\n\tif (uwsgi.lazy || uwsgi.lazy_apps) {\n\t\tuwsgi_init_all_apps();\n\t}\n\n\t// some apps could be mounted only on specific workers\n\tuwsgi_init_worker_mount_apps();\n\n\tif (uwsgi.async > 1) {\n\t\t// a stack of unused cores\n        \tuwsgi.async_queue_unused = uwsgi_malloc(sizeof(struct wsgi_request *) * uwsgi.async);\n\n        \t// fill it with default values\n               for (i = 0; i < uwsgi.async; i++) {\n               \tuwsgi.async_queue_unused[i] = &uwsgi.workers[uwsgi.mywid].cores[i].req;\n               }\n\n                // the first available core is the last one\n                uwsgi.async_queue_unused_ptr = uwsgi.async - 1;\n\t}\n\n\t// setup UNIX signals for the worker\n\tif (uwsgi.harakiri_options.workers > 0 && !uwsgi.master_process) {\n\t\tsignal(SIGALRM, (void *) &harakiri);\n\t}\n\tuwsgi_unix_signal(SIGHUP, gracefully_kill);\n\tuwsgi_unix_signal(SIGINT, end_me);\n\tuwsgi_unix_signal(SIGTERM, end_me);\n\n\tuwsgi_unix_signal(SIGUSR1, stats);\n\tsignal(SIGUSR2, (void *) &what_i_am_doing);\n\tif (!uwsgi.ignore_sigpipe) {\n\t\tsignal(SIGPIPE, (void *) &warn_pipe);\n\t}\n\n\t// worker initialization done\n\n\t// run fixup handler\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->fixup) {\n\t\t\tuwsgi.p[i]->fixup();\n\t\t}\n\t}\n\n\tif (uwsgi.chdir2) {\n\t\tuwsgi_log(\"chdir() to %s\\n\", uwsgi.chdir2);\n\t\tif (chdir(uwsgi.chdir2)) {\n\t\t\tuwsgi_error(\"chdir()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\n\t//re - initialize wsgi_req(can be full of init_uwsgi_app data)\n\tfor (i = 0; i < uwsgi.cores; i++) {\n\t\tmemset(&uwsgi.workers[uwsgi.mywid].cores[i].req, 0, sizeof(struct wsgi_request));\n\t\tuwsgi.workers[uwsgi.mywid].cores[i].req.async_id = i;\n\t}\n\n\n\t// eventually remap plugins\n\tif (uwsgi.remap_modifier) {\n\t\tchar *map, *ctx = NULL;\n\t\tuwsgi_foreach_token(uwsgi.remap_modifier, \",\", map, ctx) {\n\t\t\tchar *colon = strchr(map, ':');\n\t\t\tif (colon) {\n\t\t\t\tcolon[0] = 0;\n\t\t\t\tint rm_src = atoi(map);\n\t\t\t\tint rm_dst = atoi(colon + 1);\n\t\t\t\tuwsgi.p[rm_dst]->request = uwsgi.p[rm_src]->request;\n\t\t\t\tuwsgi.p[rm_dst]->after_request = uwsgi.p[rm_src]->after_request;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (uwsgi.cores > 1) {\n\t\tuwsgi.workers[uwsgi.mywid].cores[0].thread_id = pthread_self();\n\t\tpthread_mutex_init(&uwsgi.six_feet_under_lock, NULL);\n\t}\n\n\tuwsgi_ignition();\n\n\t// never here\n\texit(0);\n\n}\n\n\nvoid uwsgi_ignition() {\n\n\tint i;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->hijack_worker) {\n\t\t\tuwsgi.p[i]->hijack_worker();\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->hijack_worker) {\n\t\t\tuwsgi.gp[i]->hijack_worker();\n\t\t}\n\t}\n\n\t// create a pthread key, storing per-thread wsgi_request structure\n\tif (uwsgi.threads > 1) {\n\t\tif (pthread_key_create(&uwsgi.tur_key, NULL)) {\n\t\t\tuwsgi_error(\"pthread_key_create()\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// mark the worker as \"accepting\" (this is a mark used by chain reloading)\n\tuwsgi.workers[uwsgi.mywid].accepting = 1;\n\t// ready to accept request, if i am a vassal signal Emperor about it\n        if (uwsgi.has_emperor && uwsgi.mywid == 1) {\n                char byte = 5;\n                if (write(uwsgi.emperor_fd, &byte, 1) != 1) {\n                        uwsgi_error(\"emperor-i-am-ready-to-accept/write()\");\n\t\t\tuwsgi_log_verbose(\"lost communication with the Emperor, goodbye...\\n\");\n\t\t\tgracefully_kill_them_all(0);\n\t\t\texit(1);\n                }\n        }\n\n\t// run accepting hooks\n\tuwsgi_hooks_run(uwsgi.hook_accepting, \"accepting\", 1);\n\tif (uwsgi.workers[uwsgi.mywid].respawn_count == 1) {\n\t\tuwsgi_hooks_run(uwsgi.hook_accepting_once, \"accepting-once\", 1);\n\t}\n\n\tif (uwsgi.mywid == 1) {\n\t\tuwsgi_hooks_run(uwsgi.hook_accepting1, \"accepting1\", 1);\n\t\tif (uwsgi.workers[uwsgi.mywid].respawn_count == 1) {\n\t\t\tuwsgi_hooks_run(uwsgi.hook_accepting1_once, \"accepting1-once\", 1);\n\t\t}\n\t}\n\n\tif (uwsgi.loop) {\n\t\tvoid (*u_loop) (void) = uwsgi_get_loop(uwsgi.loop);\n\t\tif (!u_loop) {\n\t\t\tuwsgi_log(\"unavailable loop engine !!!\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (uwsgi.mywid == 1) {\n\t\t\tuwsgi_log(\"*** running %s loop engine [addr:%p] ***\\n\", uwsgi.loop, u_loop);\n\t\t}\n\t\tu_loop();\n\t\tuwsgi_log(\"your loop engine died. R.I.P.\\n\");\n\t}\n\telse {\n\t\tif (uwsgi.async < 2) {\n\t\t\tsimple_loop();\n\t\t}\n\t\telse {\n\t\t\tasync_loop();\n\t\t}\n\t}\n\n\t// end of the process...\n\tend_me(0);\n}\n\n/*\n\nwhat happens here ?\n\nwe transform the uwsgi_option structure to a struct option\nfor passing it to getopt_long\nA short options string is built.\n\nThis function could be called multiple times, so it will free previous areas\n\n*/\n\nvoid build_options() {\n\n\tint options_count = 0;\n\tint pos = 0;\n\tint i;\n\t// first count the base options\n\n\tstruct uwsgi_option *op = uwsgi_base_options;\n\twhile (op->name) {\n\t\toptions_count++;\n\t\top++;\n\t}\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->options) {\n\t\t\toptions_count += uwsgi_count_options(uwsgi.p[i]->options);\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->options) {\n\t\t\toptions_count += uwsgi_count_options(uwsgi.gp[i]->options);\n\t\t}\n\t}\n\n\t// add custom options\n\tstruct uwsgi_custom_option *uco = uwsgi.custom_options;\n\twhile (uco) {\n\t\toptions_count++;\n\t\tuco = uco->next;\n\t}\n\n\tif (uwsgi.options)\n\t\tfree(uwsgi.options);\n\n\n\t// rebuild uwsgi.options area\n\tuwsgi.options = uwsgi_calloc(sizeof(struct uwsgi_option) * (options_count + 1));\n\n\top = uwsgi_base_options;\n\twhile (op->name) {\n\t\tmemcpy(&uwsgi.options[pos], op, sizeof(struct uwsgi_option));\n\t\tpos++;\n\t\top++;\n\t}\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->options) {\n\t\t\tint c = uwsgi_count_options(uwsgi.p[i]->options);\n\t\t\tmemcpy(&uwsgi.options[pos], uwsgi.p[i]->options, sizeof(struct uwsgi_option) * c);\n\t\t\tpos += c;\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->options) {\n\t\t\tint c = uwsgi_count_options(uwsgi.gp[i]->options);\n\t\t\tmemcpy(&uwsgi.options[pos], uwsgi.gp[i]->options, sizeof(struct uwsgi_option) * c);\n\t\t\tpos += c;\n\t\t}\n\t}\n\n\tuco = uwsgi.custom_options;\n        while (uco) {\n                uwsgi.options[pos].name = uco->name;\n                if (uco->has_args) {\n                        uwsgi.options[pos].type = required_argument;\n                }\n                else {\n                        uwsgi.options[pos].type = no_argument;\n                }\n                // custom options should be immediate\n                uwsgi.options[pos].flags = UWSGI_OPT_IMMEDIATE;\n                // help shows the option definition\n                uwsgi.options[pos].help = uco->value;\n                uwsgi.options[pos].data = uco;\n                uwsgi.options[pos].func = uwsgi_opt_custom;\n\n                pos++;\n                uco = uco->next;\n        }\n\n\n\tpos = 0;\n\n\tif (uwsgi.long_options)\n\t\tfree(uwsgi.long_options);\n\n\tuwsgi.long_options = uwsgi_calloc(sizeof(struct option) * (options_count + 1));\n\n\tif (uwsgi.short_options)\n\t\tfree(uwsgi.short_options);\n\n\tuwsgi.short_options = uwsgi_calloc((options_count * 3) + 1);\n\n\t// build long_options (this time with custom_options)\n\top = uwsgi.options;\n\twhile (op->name) {\n\t\tuwsgi.long_options[pos].name = op->name;\n\t\tuwsgi.long_options[pos].has_arg = op->type;\n\t\tuwsgi.long_options[pos].flag = 0;\n\t\t// add 1000 to avoid short_options collision\n\t\tuwsgi.long_options[pos].val = 1000 + pos;\n\t\tif (op->shortcut) {\n\t\t\tchar shortcut = (char) op->shortcut;\n\t\t\t// avoid duplicates in short_options\n\t\t\tif (!strchr(uwsgi.short_options, shortcut)) {\n\t\t\t\tstrncat(uwsgi.short_options, &shortcut, 1);\n\t\t\t\tif (op->type == optional_argument) {\n\t\t\t\t\tstrcat(uwsgi.short_options, \"::\");\n\t\t\t\t}\n\t\t\t\telse if (op->type == required_argument) {\n\t\t\t\t\tstrcat(uwsgi.short_options, \":\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\top++;\n\t\tpos++;\n\t}\n}\n\n/*\n\nthis function builds the help output from the uwsgi.options structure\n\n*/\nvoid uwsgi_help(char *opt, char *val, void *none) {\n\n\tsize_t max_size = 0;\n\n\tfprintf(stdout, \"Usage: %s [options...]\\n\", uwsgi.binary_path);\n\n\tstruct uwsgi_option *op = uwsgi.options;\n\twhile (op && op->name) {\n\t\tif (strlen(op->name) > max_size) {\n\t\t\tmax_size = strlen(op->name);\n\t\t}\n\t\top++;\n\t}\n\n\tmax_size++;\n\n\top = uwsgi.options;\n\twhile (op && op->name) {\n\t\tif (op->shortcut) {\n\t\t\tfprintf(stdout, \"    -%c|--%-*s %s\\n\", op->shortcut, (int) max_size - 3, op->name, op->help);\n\t\t}\n\t\telse {\n\t\t\tfprintf(stdout, \"    --%-*s %s\\n\", (int) max_size, op->name, op->help);\n\t\t}\n\t\top++;\n\t}\n\n\texit(0);\n}\n\n/*\n\ninitialize all apps\n\n*/\nvoid uwsgi_init_all_apps() {\n\n\tint i, j;\n\n\tuwsgi_hooks_run(uwsgi.hook_pre_app, \"pre app\", 1);\n\n\t// now run the pre-app scripts\n\tstruct uwsgi_string_list *usl = uwsgi.exec_pre_app;\n\twhile (usl) {\n\t\tuwsgi_log(\"running \\\"%s\\\" (pre app)...\\n\", usl->value);\n\t\tint ret = uwsgi_run_command_and_wait(NULL, usl->value);\n\t\tif (ret != 0) {\n\t\t\tuwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n\t\t\texit(1);\n\t\t}\n\t\tusl = usl->next;\n\t}\n\n\tuwsgi_foreach(usl, uwsgi.call_pre_app) {\n                if (uwsgi_call_symbol(usl->value)) {\n                        uwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n\t\t\texit(1);\n                }\n        }\n\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->init_apps) {\n\t\t\tuwsgi.p[i]->init_apps();\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\t\tif (uwsgi.gp[i]->init_apps) {\n\t\t\tuwsgi.gp[i]->init_apps();\n\t\t}\n\t}\n\n\tstruct uwsgi_string_list *app_mps = uwsgi.mounts;\n\twhile (app_mps) {\n\t\tchar *what = strchr(app_mps->value, '=');\n\t\tif (what) {\n\t\t\twhat[0] = 0;\n\t\t\twhat++;\n\t\t\tfor (j = 0; j < 256; j++) {\n\t\t\t\tif (uwsgi.p[j]->mount_app) {\n\t\t\t\t\tuwsgi_log(\"mounting %s on %s\\n\", what, app_mps->value);\n\t\t\t\t\tif (uwsgi.p[j]->mount_app(app_mps->value, what) != -1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhat--;\n\t\t\twhat[0] = '=';\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"invalid mountpoint: %s\\n\", app_mps->value);\n\t\t\texit(1);\n\t\t}\n\t\tapp_mps = app_mps->next;\n\t}\n\n\t// no app initialized and virtualhosting enabled\n\tif (uwsgi_apps_cnt == 0 && uwsgi.numproc > 0 && !uwsgi.command_mode) {\n\t\tif (uwsgi.need_app) {\n\t\t\tif (!uwsgi.lazy)\n\t\t\t\tuwsgi_log(\"*** no app loaded. GAME OVER ***\\n\");\n\t\t\tif (uwsgi.lazy_apps) {\n\t\t\t\tif (uwsgi.master_process) {\n\t\t\t\t\tif (kill(uwsgi.workers[0].pid, SIGINT)) {\n\t\t\t\t\t\tuwsgi_error(\"kill()\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\texit(UWSGI_FAILED_APP_CODE);\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"*** no app loaded. going in full dynamic mode ***\\n\");\n\t\t}\n\t}\n\n\tuwsgi_hooks_run(uwsgi.hook_post_app, \"post app\", 1);\n\n\tusl = uwsgi.exec_post_app;\n        while (usl) {\n                uwsgi_log(\"running \\\"%s\\\" (post app)...\\n\", usl->value);\n                int ret = uwsgi_run_command_and_wait(NULL, usl->value);\n                if (ret != 0) {\n                        uwsgi_log(\"command \\\"%s\\\" exited with non-zero code: %d\\n\", usl->value, ret);\n                        exit(1);\n                }\n                usl = usl->next;\n        }\n\n\tuwsgi_foreach(usl, uwsgi.call_post_app) {\n                if (uwsgi_call_symbol(usl->value)) {\n                        uwsgi_log(\"unable to call function \\\"%s\\\"\\n\", usl->value);\n                }\n        }\n\n}\n\nvoid uwsgi_init_worker_mount_apps() {\n/*\n\tint i,j;\n\tfor (i = 0; i < uwsgi.mounts_cnt; i++) {\n                char *what = strchr(uwsgi.mounts[i], '=');\n                if (what) {\n                        what[0] = 0;\n                        what++;\n                        for (j = 0; j < 256; j++) {\n                                if (uwsgi.p[j]->mount_app) {\n                                        if (!uwsgi_startswith(uwsgi.mounts[i], \"worker://\", 9)) {\n                        \t\t\tuwsgi_log(\"mounting %s on %s\\n\", what, uwsgi.mounts[i]+9);\n                                                if (uwsgi.p[j]->mount_app(uwsgi.mounts[i] + 9, what, 1) != -1)\n                                                        break;\n                                        }\n                                }\n                        }\n                        what--;\n                        what[0] = '=';\n                }\n                else {\n                        uwsgi_log(\"invalid mountpoint: %s\\n\", uwsgi.mounts[i]);\n                        exit(1);\n                }\n        }\n*/\n\n}\n\nvoid uwsgi_opt_true(char *opt, char *value, void *key) {\n\n\tint *ptr = (int *) key;\n\t*ptr = 1;\n\tif (value) {\n\t\tif (!strcasecmp(\"false\", value) || !strcasecmp(\"off\", value) || !strcasecmp(\"no\", value) || !strcmp(\"0\", value)) {\n\t\t\t*ptr = 0;\n\t\t}\n\t}\n}\n\nvoid uwsgi_opt_false(char *opt, char *value, void *key) {\n\n        int *ptr = (int *) key;\n        *ptr = 0;\n        if (value) {\n                if (!strcasecmp(\"false\", value) || !strcasecmp(\"off\", value) || !strcasecmp(\"no\", value) || !strcmp(\"0\", value)) {\n                        *ptr = 1;\n                }\n        }\n}\n\nvoid uwsgi_opt_set_immediate_gid(char *opt, char *value, void *none) {\n        gid_t gid = 0;\n\tif (is_a_number(value)) gid = atoi(value);\n\tif (gid == 0) {\n\t\tstruct group *ugroup = getgrnam(value);\n                if (ugroup)\n                \tgid = ugroup->gr_gid;\n\t}\n        if (gid <= 0) {\n                uwsgi_log(\"uwsgi_opt_set_immediate_gid(): invalid gid %d\\n\", (int) gid);\n                exit(1);\n        }\n        if (setgid(gid)) {\n                uwsgi_error(\"uwsgi_opt_set_immediate_gid()/setgid()\");\n                exit(1);\n        }\n\n\tif (setgroups(0, NULL)) {\n        \tuwsgi_error(\"uwsgi_opt_set_immediate_gid()/setgroups()\");\n                exit(1);\n        }\n\n\tgid = getgid();\n\tif (!gid) {\n\t\texit(1);\n\t}\n\tuwsgi_log(\"immediate gid: %d\\n\", (int) gid);\n}\n\n\nvoid uwsgi_opt_set_immediate_uid(char *opt, char *value, void *none) {\n\tuid_t uid = 0;\n\tif (is_a_number(value)) uid = atoi(value);\n\tif (uid == 0) {\n\t\tstruct passwd *upasswd = getpwnam(value);\n                if (upasswd)\n                        uid = upasswd->pw_uid;\n\t}\n\tif (uid <= 0) {\n\t\tuwsgi_log(\"uwsgi_opt_set_immediate_uid(): invalid uid %d\\n\", uid);\n\t\texit(1);\n\t}\n\tif (setuid(uid)) {\n\t\tuwsgi_error(\"uwsgi_opt_set_immediate_uid()/setuid()\");\n\t\texit(1);\n\t}\n\n\tuid = getuid();\n\tif (!uid) {\n\t\texit(1);\n\t}\n\tuwsgi_log(\"immediate uid: %d\\n\", (int) uid);\n}\n\nvoid uwsgi_opt_safe_fd(char *opt, char *value, void *foobar) {\n\tint fd = atoi(value);\n\tif (fd < 0) {\n\t\tuwsgi_log(\"invalid file descriptor: %d\\n\", fd);\n\t\texit(1);\n\t}\n\tuwsgi_add_safe_fd(fd);\n}\n\nvoid uwsgi_opt_set_int(char *opt, char *value, void *key) {\n\tint *ptr = (int *) key;\n\tif (value) {\n\t\t*ptr = atoi((char *) value);\n\t}\n\telse {\n\t\t*ptr = 1;\n\t}\n\n\tif (*ptr < 0) {\n\t\tuwsgi_log(\"invalid value for option \\\"%s\\\": must be > 0\\n\", opt);\n\t\texit(1);\n\t}\n}\n\nvoid uwsgi_opt_uid(char *opt, char *value, void *key) {\n\tuid_t uid = 0;\n\tif (is_a_number(value)) uid = atoi(value);\n\tif (!uid) {\n\t\tstruct passwd *p = getpwnam(value);\n\t\tif (p) {\n\t\t\tuid = p->pw_uid;\t\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"unable to find user %s\\n\", value);\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (key)  {\n        \tuid_t *ptr = (uid_t *) key;\n        \t*ptr = uid;\n        }\n}\n\nvoid uwsgi_opt_gid(char *opt, char *value, void *key) {\n        gid_t gid = 0;\n\tif (is_a_number(value)) gid = atoi(value);\n        if (!gid) {\n                struct group *g = getgrnam(value);\n                if (g) {\n                        gid = g->gr_gid;\n                }\n                else {\n                        uwsgi_log(\"unable to find group %s\\n\", value);\n\t\t\texit(1);\n                }\n        }       \n        if (key)  {\n                gid_t *ptr = (gid_t *) key;\n                *ptr = gid;\n        }       \n}     \n\nvoid uwsgi_opt_set_rawint(char *opt, char *value, void *key) {\n\tint *ptr = (int *) key;\n\tif (value) {\n\t\t*ptr = atoi((char *) value);\n\t}\n\telse {\n\t\t*ptr = 1;\n\t}\n}\n\n\nvoid uwsgi_opt_set_64bit(char *opt, char *value, void *key) {\n\tuint64_t *ptr = (uint64_t *) key;\n\n\tif (value) {\n\t\t*ptr = (strtoul(value, NULL, 10));\n\t}\n\telse {\n\t\t*ptr = 1;\n\t}\n}\n\nvoid uwsgi_opt_set_16bit(char *opt, char *value, void *key) {\n        uint16_t *ptr = (uint16_t *) key;\n\n        if (value) {\n\t\tunsigned long n = strtoul(value, NULL, 10);\n\t\tif (n > 65535) n = 65535;\n                *ptr = n;\n        }\n        else {\n                *ptr = 1;\n        }\n}\n\n\nvoid uwsgi_opt_set_megabytes(char *opt, char *value, void *key) {\n\tuint64_t *ptr = (uint64_t *) key;\n\t*ptr = (uint64_t)strtoul(value, NULL, 10) * 1024 * 1024;\n}\n\nvoid uwsgi_opt_set_str(char *opt, char *value, void *key) {\n\tchar **ptr = (char **) key;\n\tif (!value) {\n\t\t*ptr = \"\";\n\t\treturn;\t\n\t}\n\t*ptr = (char *) value;\n}\n\nvoid uwsgi_opt_set_null(char *opt, char *value, void *key) {\n        char **ptr = (char **) key;\n        *ptr = NULL;\n}\n\n\nvoid uwsgi_opt_set_logger(char *opt, char *value, void *prefix) {\n\n\tif (!value)\n\t\tvalue = \"\";\n\n\tif (prefix) {\n\t\tuwsgi_string_new_list(&uwsgi.requested_logger, uwsgi_concat3((char *) prefix, \":\", value));\n\t}\n\telse {\n\t\tuwsgi_string_new_list(&uwsgi.requested_logger, uwsgi_str(value));\n\t}\n}\n\nvoid uwsgi_opt_set_req_logger(char *opt, char *value, void *prefix) {\n\n\tif (!value)\n\t\tvalue = \"\";\n\n\tif (prefix) {\n\t\tuwsgi_string_new_list(&uwsgi.requested_req_logger, uwsgi_concat3((char *) prefix, \":\", value));\n\t}\n\telse {\n\t\tuwsgi_string_new_list(&uwsgi.requested_req_logger, uwsgi_str(value));\n\t}\n}\n\nvoid uwsgi_opt_set_str_spaced(char *opt, char *value, void *key) {\n\tchar **ptr = (char **) key;\n\t*ptr = uwsgi_concat2((char *) value, \" \");\n}\n\nvoid uwsgi_opt_add_string_list(char *opt, char *value, void *list) {\n\tstruct uwsgi_string_list **ptr = (struct uwsgi_string_list **) list;\n\tuwsgi_string_new_list(ptr, value);\n}\n\nvoid uwsgi_opt_add_addr_list(char *opt, char *value, void *list) {\n        struct uwsgi_string_list **ptr = (struct uwsgi_string_list **) list;\n\tint af = AF_INET;\n#ifdef AF_INET6\n\tvoid *ip = uwsgi_malloc(16);\n\tif (strchr(value, ':')) {\n\t\taf = AF_INET6;\n\t}\n#else\n\tvoid *ip = uwsgi_malloc(4);\n#endif\n\t\n\tif (inet_pton(af, value, ip) <= 0) {\n\t\tuwsgi_log(\"%s: invalid address\\n\", opt);\n\t\tuwsgi_error(\"uwsgi_opt_add_addr_list()\");\n\t\texit(1);\n\t}\n\n        struct uwsgi_string_list *usl = uwsgi_string_new_list(ptr, ip);\n\tusl->custom = af;\n\tusl->custom_ptr = value;\n}\n\n\nvoid uwsgi_opt_add_string_list_custom(char *opt, char *value, void *list) {\n\tstruct uwsgi_string_list **ptr = (struct uwsgi_string_list **) list;\n\tstruct uwsgi_string_list *usl = uwsgi_string_new_list(ptr, value);\n\tusl->custom = 1;\n}\n\n#ifdef UWSGI_PCRE\nvoid uwsgi_opt_add_regexp_list(char *opt, char *value, void *list) {\n\tstruct uwsgi_regexp_list **ptr = (struct uwsgi_regexp_list **) list;\n\tuwsgi_regexp_new_list(ptr, value);\n}\n\nvoid uwsgi_opt_add_regexp_custom_list(char *opt, char *value, void *list) {\n\tchar *space = strchr(value, ' ');\n\tif (!space) {\n\t\tuwsgi_log(\"invalid custom regexp syntax: must be <custom> <regexp>\\n\");\n\t\texit(1);\n\t}\n\tchar *custom = uwsgi_concat2n(value, space - value, \"\", 0);\n\tstruct uwsgi_regexp_list **ptr = (struct uwsgi_regexp_list **) list;\n\tuwsgi_regexp_custom_new_list(ptr, space + 1, custom);\n}\n#endif\n\nvoid uwsgi_opt_add_shared_socket(char *opt, char *value, void *protocol) {\n\tstruct uwsgi_socket *us = uwsgi_new_shared_socket(generate_socket_name(value));\n\tif (!strcmp(opt, \"undeferred-shared-socket\")) {\n\t\tus->no_defer = 1;\n\t}\n}\n\nvoid uwsgi_opt_add_socket(char *opt, char *value, void *protocol) {\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi_new_socket(generate_socket_name(value));\n\tuwsgi_sock->name_len = strlen(uwsgi_sock->name);\n\tuwsgi_sock->proto_name = protocol;\n}\n\n#ifdef UWSGI_SSL\nvoid uwsgi_opt_add_ssl_socket(char *opt, char *value, void *protocol) {\n\tchar *client_ca = NULL;\n\n        // build socket, certificate and key file\n        char *sock = uwsgi_str(value);\n        char *crt = strchr(sock, ',');\n        if (!crt) {\n                uwsgi_log(\"invalid https-socket syntax must be socket,crt,key\\n\");\n                exit(1);\n        }\n        *crt = '\\0'; crt++;\n        char *key = strchr(crt, ',');\n        if (!key) {\n                uwsgi_log(\"invalid https-socket syntax must be socket,crt,key\\n\");\n                exit(1);\n        }\n        *key = '\\0'; key++;\n\n        char *ciphers = strchr(key, ',');\n        if (ciphers) {\n                *ciphers = '\\0'; ciphers++;\n                client_ca = strchr(ciphers, ',');\n                if (client_ca) {\n                        *client_ca = '\\0'; client_ca++;\n                }\n        }\n\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi_new_socket(generate_socket_name(sock));\n\tuwsgi_sock->name_len = strlen(uwsgi_sock->name);\n        uwsgi_sock->proto_name = protocol;\n\n        // ok we have the socket, initialize ssl if required\n        if (!uwsgi.ssl_initialized) {\n                uwsgi_ssl_init();\n        }\n\n        // initialize ssl context\n        uwsgi_sock->ssl_ctx = uwsgi_ssl_new_server_context(uwsgi_sock->name, crt, key, ciphers, client_ca);\n        if (!uwsgi_sock->ssl_ctx) {\n                exit(1);\n        }\n}\n#endif\n\nvoid uwsgi_opt_add_socket_no_defer(char *opt, char *value, void *protocol) {\n        struct uwsgi_socket *uwsgi_sock = uwsgi_new_socket(generate_socket_name(value));\n        uwsgi_sock->name_len = strlen(uwsgi_sock->name);\n        uwsgi_sock->proto_name = protocol;\n\tuwsgi_sock->no_defer = 1;\n}\n\nvoid uwsgi_opt_add_lazy_socket(char *opt, char *value, void *protocol) {\n\tstruct uwsgi_socket *uwsgi_sock = uwsgi_new_socket(generate_socket_name(value));\n\tuwsgi_sock->proto_name = protocol;\n\tuwsgi_sock->bound = 1;\n\tuwsgi_sock->lazy = 1;\n}\n\n\nvoid uwsgi_opt_set_placeholder(char *opt, char *value, void *ph) {\n\n\tchar *p = strchr(value, '=');\n\tif (!p) {\n\t\tuwsgi_log(\"invalid placeholder/--set value\\n\");\n\t\texit(1);\n\t}\n\n\tp[0] = 0;\n\tadd_exported_option_do(uwsgi_str(value), p + 1, 0, ph ? 1 : 0);\n\tp[0] = '=';\n\n}\n\nvoid uwsgi_opt_ssa(char *opt, char *value, void *foobar) {\n\tuwsgi_subscription_set_algo(value);\n}\n\n#ifdef UWSGI_SSL\nvoid uwsgi_opt_scd(char *opt, char *value, void *foobar) {\n\t// openssl could not be initialized\n\tif (!uwsgi.ssl_initialized) {\n\t\tuwsgi_ssl_init();\n\t}\n\n\tchar *colon = strchr(value, ':');\n\tif (!colon) {\n\t\tuwsgi_log(\"invalid syntax for '%s', must be: <digest>:<directory>\\n\", opt);\n\t\texit(1);\n\t}\n\n\tchar *algo = uwsgi_concat2n(value, (colon - value), \"\", 0);\n\tuwsgi.subscriptions_sign_check_md = EVP_get_digestbyname(algo);\n\tif (!uwsgi.subscriptions_sign_check_md) {\n\t\tuwsgi_log(\"unable to find digest algorithm: %s\\n\", algo);\n\t\texit(1);\n\t}\n\tfree(algo);\n\n\tuwsgi.subscriptions_sign_check_dir = colon + 1;\n}\n#endif\n\nvoid uwsgi_opt_set_umask(char *opt, char *value, void *mode) {\n\tint error = 0;\n\tmode_t mask = uwsgi_mode_t(value, &error);\n\tif (error) {\n\t\tuwsgi_log(\"invalid umask: %s\\n\", value);\n\t}\n\tumask(mask);\n\n\tuwsgi.do_not_change_umask = 1;\n}\n\nvoid uwsgi_opt_exit(char *opt, char *value, void *none) {\n\tint exit_code = 1;\n\tif (value) {\n\t\texit_code = atoi(value);\n\t}\n\texit(exit_code);\n}\n\nvoid uwsgi_opt_print(char *opt, char *value, void *str) {\n\tif (str) {\n\t\tfprintf(stdout, \"%s\\n\", (char *) str);\n\t\texit(0);\n\t}\n\tfprintf(stdout, \"%s\\n\", value);\n}\n\nvoid uwsgi_opt_set_uid(char *opt, char *value, void *none) {\n\tif (is_a_number(value)) uwsgi.uid = atoi(value);\n\tif (!uwsgi.uid)\n\t\tuwsgi.uidname = value;\n}\n\nvoid uwsgi_opt_set_gid(char *opt, char *value, void *none) {\n\tif (is_a_number(value)) uwsgi.gid = atoi(value);\n\tif (!uwsgi.gid)\n\t\tuwsgi.gidname = value;\n}\n\n#ifdef UWSGI_CAP\nvoid uwsgi_opt_set_cap(char *opt, char *value, void *none) {\n\tuwsgi.cap_count = uwsgi_build_cap(value, &uwsgi.cap);\n\tif (uwsgi.cap_count == 0) {\n\t\tuwsgi_log(\"[security] empty capabilities mask !!!\\n\");\n\t\texit(1);\n\t}\n}\nvoid uwsgi_opt_set_emperor_cap(char *opt, char *value, void *none) {\n\tuwsgi.emperor_cap_count = uwsgi_build_cap(value, &uwsgi.emperor_cap);\n\tif (uwsgi.emperor_cap_count == 0) {\n\t\tuwsgi_log(\"[security] empty capabilities mask !!!\\n\");\n\t\texit(1);\n\t}\n}\n#endif\n#ifdef __linux__\nvoid uwsgi_opt_set_unshare(char *opt, char *value, void *mask) {\n\tuwsgi_build_unshare(value, (int *) mask);\n}\n#endif\n\nvoid uwsgi_opt_set_env(char *opt, char *value, void *none) {\n\tif (putenv(value)) {\n\t\tuwsgi_error(\"putenv()\");\n\t}\n}\n\nvoid uwsgi_opt_unset_env(char *opt, char *value, void *none) {\n#ifdef UNSETENV_VOID\n\tunsetenv(value);\n#else\n\tif (unsetenv(value)) {\n\t\tuwsgi_error(\"unsetenv()\");\n\t}\n#endif\n}\n\nvoid uwsgi_opt_pidfile_signal(char *opt, char *pidfile, void *sig) {\n\n\tlong *signum_fake_ptr = (long *) sig;\n\tint signum = (long) signum_fake_ptr;\n\texit(signal_pidfile(signum, pidfile));\n}\n\nvoid uwsgi_opt_load_dl(char *opt, char *value, void *none) {\n\tif (!dlopen(value, RTLD_NOW | RTLD_GLOBAL)) {\n\t\tuwsgi_log(\"%s\\n\", dlerror());\n\t}\n}\n\nvoid uwsgi_opt_load_plugin(char *opt, char *value, void *none) {\n\n\tchar *plugins_list = uwsgi_concat2(value, \"\");\n\tchar *p, *ctx = NULL;\n\tuwsgi_foreach_token(plugins_list, \",\", p, ctx) {\n#ifdef UWSGI_DEBUG\n\t\tuwsgi_debug(\"loading plugin %s\\n\", p);\n#endif\n\t\tif (uwsgi_load_plugin(-1, p, NULL)) {\n\t\t\tbuild_options();\n\t\t}\n\t\telse if (!uwsgi_startswith(opt, \"need-\", 5)) {\n\t\t\tuwsgi_log(\"unable to load plugin \\\"%s\\\"\\n\", p);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfree(p);\n\tfree(plugins_list);\n}\n\nvoid uwsgi_opt_check_static(char *opt, char *value, void *foobar) {\n\n\tuwsgi_dyn_dict_new(&uwsgi.check_static, value, strlen(value), NULL, 0);\n\tuwsgi_log(\"[uwsgi-static] added check for %s\\n\", value);\n\tuwsgi.build_mime_dict = 1;\n\n}\n\nvoid uwsgi_opt_add_dyn_dict(char *opt, char *value, void *dict) {\n\n\tchar *equal = strchr(value, '=');\n\tif (!equal) {\n\t\tuwsgi_log(\"invalid dictionary syntax for %s\\n\", opt);\n\t\texit(1);\n\t}\n\n\tstruct uwsgi_dyn_dict **udd = (struct uwsgi_dyn_dict **) dict;\n\n\tuwsgi_dyn_dict_new(udd, value, equal - value, equal + 1, strlen(equal + 1));\n\n}\n\n#ifdef UWSGI_PCRE\nvoid uwsgi_opt_add_regexp_dyn_dict(char *opt, char *value, void *dict) {\n\n\tchar *space = strchr(value, ' ');\n\tif (!space) {\n\t\tuwsgi_log(\"invalid dictionary syntax for %s\\n\", opt);\n\t\texit(1);\n\t}\n\n\tstruct uwsgi_dyn_dict **udd = (struct uwsgi_dyn_dict **) dict;\n\n\tstruct uwsgi_dyn_dict *new_udd = uwsgi_dyn_dict_new(udd, value, space - value, space + 1, strlen(space + 1));\n\n\tchar *regexp = uwsgi_concat2n(value, space - value, \"\", 0);\n\n\tif (uwsgi_regexp_build(regexp, &new_udd->pattern, &new_udd->pattern_extra)) {\n\t\texit(1);\n\t}\n\n\tfree(regexp);\n}\n#endif\n\n\nvoid uwsgi_opt_fileserve_mode(char *opt, char *value, void *foobar) {\n\n\tif (!strcasecmp(\"x-sendfile\", value)) {\n\t\tuwsgi.file_serve_mode = 2;\n\t}\n\telse if (!strcasecmp(\"xsendfile\", value)) {\n\t\tuwsgi.file_serve_mode = 2;\n\t}\n\telse if (!strcasecmp(\"x-accel-redirect\", value)) {\n\t\tuwsgi.file_serve_mode = 1;\n\t}\n\telse if (!strcasecmp(\"xaccelredirect\", value)) {\n\t\tuwsgi.file_serve_mode = 1;\n\t}\n\telse if (!strcasecmp(\"nginx\", value)) {\n\t\tuwsgi.file_serve_mode = 1;\n\t}\n\n}\n\nvoid uwsgi_opt_static_map(char *opt, char *value, void *static_maps) {\n\n\tstruct uwsgi_dyn_dict **maps = (struct uwsgi_dyn_dict **) static_maps;\n\tchar *mountpoint = uwsgi_str(value);\n\n\tchar *docroot = strchr(mountpoint, '=');\n\n\tif (!docroot) {\n\t\tuwsgi_log(\"invalid document root in static map, syntax mountpoint=docroot\\n\");\n\t\texit(1);\n\t}\n\tdocroot[0] = 0;\n\tdocroot++;\n\tuwsgi_dyn_dict_new(maps, mountpoint, strlen(mountpoint), docroot, strlen(docroot));\n\tuwsgi_log_initial(\"[uwsgi-static] added mapping for %s => %s\\n\", mountpoint, docroot);\n\tuwsgi.build_mime_dict = 1;\n}\n\n\nint uwsgi_zerg_attach(char *value) {\n\n\tint count = 8;\n\tint zerg_fd = uwsgi_connect(value, 30, 0);\n\tif (zerg_fd < 0) {\n\t\tuwsgi_log(\"--- unable to connect to zerg server %s ---\\n\", value);\n\t\treturn -1;\n\t}\n\n\tint last_count = count;\n\n\tint *zerg = uwsgi_attach_fd(zerg_fd, &count, \"uwsgi-zerg\", 10);\n\tif (zerg == NULL) {\n\t\tif (last_count != count) {\n\t\t\tclose(zerg_fd);\n\t\t\tzerg_fd = uwsgi_connect(value, 30, 0);\n\t\t\tif (zerg_fd < 0) {\n\t\t\t\tuwsgi_log(\"--- unable to connect to zerg server %s ---\\n\", value);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tzerg = uwsgi_attach_fd(zerg_fd, &count, \"uwsgi-zerg\", 10);\n\t\t}\n\t}\n\n\tif (zerg == NULL) {\n\t\tuwsgi_log(\"--- invalid data received from zerg-server ---\\n\");\n\t\tclose(zerg_fd);\n\t\treturn -1;\n\t}\n\n\tif (!uwsgi.zerg) {\n\t\tuwsgi.zerg = zerg;\n\t}\n\telse {\n\t\tint pos = 0;\n\t\tfor (;;) {\n\t\t\tif (uwsgi.zerg[pos] == -1) {\n\t\t\t\tuwsgi.zerg = realloc(uwsgi.zerg, (sizeof(int) * (pos)) + (sizeof(int) * count + 1));\n\t\t\t\tif (!uwsgi.zerg) {\n\t\t\t\t\tuwsgi_error(\"realloc()\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tmemcpy(&uwsgi.zerg[pos], zerg, (sizeof(int) * count + 1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\tfree(zerg);\n\t}\n\n\tclose(zerg_fd);\n\treturn 0;\n}\n\nvoid uwsgi_opt_signal(char *opt, char *value, void *foobar) {\n\tuwsgi_command_signal(value);\n}\n\nvoid uwsgi_opt_log_date(char *opt, char *value, void *foobar) {\n\n\tuwsgi.logdate = 1;\n\tif (value) {\n\t\tif (strcasecmp(\"true\", value) && strcasecmp(\"1\", value) && strcasecmp(\"on\", value) && strcasecmp(\"yes\", value)) {\n\t\t\tuwsgi.log_strftime = value;\n\t\t}\n\t}\n}\n\nvoid uwsgi_opt_chmod_socket(char *opt, char *value, void *foobar) {\n\n\tint i;\n\n\tuwsgi.chmod_socket = 1;\n\tif (value) {\n\t\tif (strlen(value) == 1 && *value == '1') {\n\t\t\treturn;\n\t\t}\n\t\tif (strlen(value) != 3) {\n\t\t\tuwsgi_log(\"invalid chmod value: %s\\n\", value);\n\t\t\texit(1);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (value[i] < '0' || value[i] > '7') {\n\t\t\t\tuwsgi_log(\"invalid chmod value: %s\\n\", value);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tuwsgi.chmod_socket_value = (uwsgi.chmod_socket_value << 3) + (value[0] - '0');\n\t\tuwsgi.chmod_socket_value = (uwsgi.chmod_socket_value << 3) + (value[1] - '0');\n\t\tuwsgi.chmod_socket_value = (uwsgi.chmod_socket_value << 3) + (value[2] - '0');\n\t}\n\n}\n\nvoid uwsgi_opt_logfile_chmod(char *opt, char *value, void *foobar) {\n\n\tint i;\n\n\tif (strlen(value) != 3) {\n\t\tuwsgi_log(\"invalid chmod value: %s\\n\", value);\n\t\texit(1);\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tif (value[i] < '0' || value[i] > '7') {\n\t\t\tuwsgi_log(\"invalid chmod value: %s\\n\", value);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tuwsgi.chmod_logfile_value = (uwsgi.chmod_logfile_value << 3) + (value[0] - '0');\n\tuwsgi.chmod_logfile_value = (uwsgi.chmod_logfile_value << 3) + (value[1] - '0');\n\tuwsgi.chmod_logfile_value = (uwsgi.chmod_logfile_value << 3) + (value[2] - '0');\n\n}\n\nvoid uwsgi_opt_max_vars(char *opt, char *value, void *foobar) {\n\n\tuwsgi.max_vars = atoi(value);\n\tuwsgi.vec_size = 4 + 1 + (4 * uwsgi.max_vars);\n}\n\nvoid uwsgi_opt_deprecated(char *opt, char *value, void *message) {\n\tuwsgi_log(\"[WARNING] option \\\"%s\\\" is deprecated: %s\\n\", opt, (char *) message);\n}\n\nvoid uwsgi_opt_load(char *opt, char *filename, void *none) {\n\n\t// here we need to avoid setting upper magic vars\n\tint orig_magic = uwsgi.magic_table_first_round;\n\tuwsgi.magic_table_first_round = 1;\n\n\tif (uwsgi_endswith(filename, \".ini\")) {\n\t\tuwsgi_opt_load_ini(opt, filename, none);\n\t\tgoto end;\n\t}\n#ifdef UWSGI_XML\n\tif (uwsgi_endswith(filename, \".xml\")) {\n\t\tuwsgi_opt_load_xml(opt, filename, none);\n\t\tgoto end;\n\t}\n#endif\n#ifdef UWSGI_YAML\n\tif (uwsgi_endswith(filename, \".yaml\")) {\n\t\tuwsgi_opt_load_yml(opt, filename, none);\n\t\tgoto end;\n\t}\n\tif (uwsgi_endswith(filename, \".yml\")) {\n\t\tuwsgi_opt_load_yml(opt, filename, none);\n\t\tgoto end;\n\t}\n#endif\n#ifdef UWSGI_JSON\n\tif (uwsgi_endswith(filename, \".json\")) {\n\t\tuwsgi_opt_load_json(opt, filename, none);\n\t\tgoto end;\n\t}\n\tif (uwsgi_endswith(filename, \".js\")) {\n\t\tuwsgi_opt_load_json(opt, filename, none);\n\t\tgoto end;\n\t}\n#endif\n\n\t// fallback to pluggable system\n\tuwsgi_opt_load_config(opt, filename, none);\nend:\n\tuwsgi.magic_table_first_round = orig_magic;\n}\n\nvoid uwsgi_opt_logic(char *opt, char *arg, void *func) {\n\n\tif (uwsgi.logic_opt) {\n\t\tuwsgi_log(\"recursive logic in options is not supported (option = %s)\\n\", opt);\n\t\texit(1);\n\t}\n\tuwsgi.logic_opt = (int (*)(char *, char *)) func;\n\tuwsgi.logic_opt_cycles = 0;\n\tif (arg) {\n\t\tuwsgi.logic_opt_arg = uwsgi_str(arg);\n\t}\n\telse {\n\t\tuwsgi.logic_opt_arg = NULL;\n\t}\n}\n\nvoid uwsgi_opt_noop(char *opt, char *foo, void *bar) {\n}\n\nvoid uwsgi_opt_load_ini(char *opt, char *filename, void *none) {\n\tconfig_magic_table_fill(filename, uwsgi.magic_table);\n\tuwsgi_ini_config(filename, uwsgi.magic_table);\n}\n\nvoid uwsgi_opt_load_config(char *opt, char *filename, void *none) {\n        struct uwsgi_configurator *uc = uwsgi.configurators;\n        while(uc) {\n                if (uwsgi_endswith(filename, uc->name)) {\n                        config_magic_table_fill(filename, uwsgi.magic_table);\n                        uc->func(filename, uwsgi.magic_table);\n                        return;\n                }\n                uc = uc->next;\n        }\n\n\tuwsgi_log(\"unable to load configuration from %s\\n\", filename);\n\texit(1);\n}\n\n#ifdef UWSGI_XML\nvoid uwsgi_opt_load_xml(char *opt, char *filename, void *none) {\n\tconfig_magic_table_fill(filename, uwsgi.magic_table);\n\tuwsgi_xml_config(filename, uwsgi.wsgi_req, uwsgi.magic_table);\n}\n#endif\n\n#ifdef UWSGI_YAML\nvoid uwsgi_opt_load_yml(char *opt, char *filename, void *none) {\n\tconfig_magic_table_fill(filename, uwsgi.magic_table);\n\tuwsgi_yaml_config(filename, uwsgi.magic_table);\n}\n#endif\n\n#ifdef UWSGI_JSON\nvoid uwsgi_opt_load_json(char *opt, char *filename, void *none) {\n\tconfig_magic_table_fill(filename, uwsgi.magic_table);\n\tuwsgi_json_config(filename, uwsgi.magic_table);\n}\n#endif\n\nvoid uwsgi_opt_add_custom_option(char *opt, char *value, void *none) {\n\n\tstruct uwsgi_custom_option *uco = uwsgi.custom_options, *old_uco;\n\n\tif (!uco) {\n\t\tuwsgi.custom_options = uwsgi_malloc(sizeof(struct uwsgi_custom_option));\n\t\tuco = uwsgi.custom_options;\n\t}\n\telse {\n\t\twhile (uco) {\n\t\t\told_uco = uco;\n\t\t\tuco = uco->next;\n\t\t}\n\n\t\tuco = uwsgi_malloc(sizeof(struct uwsgi_custom_option));\n\t\told_uco->next = uco;\n\t}\n\n\tchar *copy = uwsgi_str(value);\n\tchar *equal = strchr(copy, '=');\n\tif (!equal) {\n\t\tuwsgi_log(\"invalid %s syntax, must be newoption=template\\n\", value);\n\t\texit(1);\n\t}\n\t*equal = 0;\n\n\tuco->name = copy;\n\tuco->value = equal + 1;\n\tuco->has_args = 0;\n\t// a little hack, we allow the user to skip the first 2 arguments (yes.. it is silly...but users tend to make silly things...)\n\tif (strstr(uco->value, \"$1\") || strstr(uco->value, \"$2\") || strstr(uco->value, \"$3\")) {\n\t\tuco->has_args = 1;\n\t}\n\tuco->next = NULL;\n\tbuild_options();\n}\n\n\nvoid uwsgi_opt_flock(char *opt, char *filename, void *none) {\n\n\tint fd = open(filename, O_RDWR);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(filename);\n\t\texit(1);\n\t}\n\n\tif (uwsgi_fcntl_is_locked(fd)) {\n\t\tuwsgi_log(\"uWSGI ERROR: %s is locked by another instance\\n\", filename);\n\t\texit(1);\n\t}\n}\n\nvoid uwsgi_opt_flock_wait(char *opt, char *filename, void *none) {\n\n\tint fd = open(filename, O_RDWR);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(filename);\n\t\texit(1);\n\t}\n\n\tif (uwsgi_fcntl_lock(fd)) {\n\t\texit(1);\n\t}\n}\n\n// report CFLAGS used for compiling the server\n// use that values to build external plugins\nvoid uwsgi_opt_cflags(char *opt, char *filename, void *foobar) {\n\tfprintf(stdout, \"%s\\n\", uwsgi_get_cflags());\n\texit(0);\n}\n\nchar *uwsgi_get_cflags() {\n\tsize_t len = sizeof(UWSGI_CFLAGS) -1;\n        char *src = UWSGI_CFLAGS;\n        char *ptr = uwsgi_malloc((len / 2) + 1);\n        char *base = ptr;\n        size_t i;\n        unsigned int u;\n        for (i = 0; i < len; i += 2) {\n                sscanf(src + i, \"%2x\", &u);\n                *ptr++ = (char) u;\n        }\n\t*ptr ++= 0;\n\treturn base;\n}\n\n// report uwsgi.h used for compiling the server\n// use that values to build external plugins\nextern char *uwsgi_dot_h;\nchar *uwsgi_get_dot_h() {\n\tchar *src = uwsgi_dot_h;\n\tsize_t len = strlen(src);\n        char *ptr = uwsgi_malloc((len / 2) + 1);\n        char *base = ptr;\n        size_t i;\n        unsigned int u;\n        for (i = 0; i < len; i += 2) {\n                sscanf(src + i, \"%2x\", &u);\n                *ptr++ = (char) u;\n        }\n#ifdef UWSGI_ZLIB\n\tstruct uwsgi_buffer *ub = uwsgi_zlib_decompress(base, ptr-base);\n\tif (!ub) {\n\t\tfree(base);\n\t\treturn \"\";\n\t}\n\t// add final null byte\n\tuwsgi_buffer_append(ub, \"\\0\", 1);\n\tfree(base);\n\t// base is the final blob\n\tbase = ub->buf;\n\tub->buf = NULL;\n\tuwsgi_buffer_destroy(ub);\n#else\n        // add final null byte\n        *ptr = '\\0';\n#endif\n\treturn base;\n}\nvoid uwsgi_opt_dot_h(char *opt, char *filename, void *foobar) {\n        fprintf(stdout, \"%s\\n\", uwsgi_get_dot_h());\n        exit(0);\n}\n\nextern char *uwsgi_config_py;\nchar *uwsgi_get_config_py() {\n        char *src = uwsgi_config_py;\n        size_t len = strlen(src);\n        char *ptr = uwsgi_malloc((len / 2) + 1);\n        char *base = ptr;\n        size_t i;\n        unsigned int u;\n        for (i = 0; i < len; i += 2) {\n                sscanf(src + i, \"%2x\", &u);\n                *ptr++ = (char) u;\n        }\n#ifdef UWSGI_ZLIB\n        struct uwsgi_buffer *ub = uwsgi_zlib_decompress(base, ptr-base);\n        if (!ub) {\n                free(base);\n                return \"\";\n        }\n        // add final null byte\n        uwsgi_buffer_append(ub, \"\\0\", 1);\n        free(base);\n        // base is the final blob\n        base = ub->buf;\n        ub->buf = NULL;\n        uwsgi_buffer_destroy(ub);\n#else\n        // add final null byte\n        *ptr = '\\0';\n#endif\n        return base;\n}\n\nvoid uwsgi_opt_config_py(char *opt, char *filename, void *foobar) {\n        fprintf(stdout, \"%s\\n\", uwsgi_get_config_py());\n        exit(0);\n}\n\n\nvoid uwsgi_opt_build_plugin(char *opt, char *directory, void *foobar) {\n\tuwsgi_build_plugin(directory);\n\texit(1);\n}\n\nvoid uwsgi_opt_connect_and_read(char *opt, char *address, void *foobar) {\n\n\tchar buf[8192];\n\n\tint fd = uwsgi_connect(address, -1, 0);\n\twhile (fd >= 0) {\n\t\tint ret = uwsgi_waitfd(fd, -1);\n\t\tif (ret <= 0) {\n\t\t\texit(0);\n\t\t}\n\t\tssize_t len = read(fd, buf, 8192);\n\t\tif (len <= 0) {\n\t\t\texit(0);\n\t\t}\n\t\tuwsgi_log(\"%.*s\", (int) len, buf);\n\t}\n\tuwsgi_error(\"uwsgi_connect()\");\n\texit(1);\n}\n\nvoid uwsgi_opt_extract(char *opt, char *address, void *foobar) {\n\n\tsize_t len = 0;\n\tchar *buf;\n\n\tbuf = uwsgi_open_and_read(address, &len, 0, NULL);\n\tif (len > 0) {\n\t\tif (write(1, buf, len) != (ssize_t) len) {\n\t\t\tuwsgi_error(\"write()\");\n\t\t\texit(1);\n\t\t};\n\t};\n\texit(0);\n}\n\nvoid uwsgi_print_sym(char *opt, char *symbol, void *foobar) {\n\tchar **sym = dlsym(RTLD_DEFAULT, symbol);\n\tif (sym) {\n\t\tuwsgi_log(\"%s\", *sym);\n\t\texit(0);\n\t}\n\t\n\tchar *symbol_start = uwsgi_concat2(symbol, \"_start\");\n\tchar *symbol_end = uwsgi_concat2(symbol, \"_end\");\n\n\tchar *sym_s = dlsym(RTLD_DEFAULT, symbol_start);\n\tchar *sym_e = dlsym(RTLD_DEFAULT, symbol_end);\n\n\tif (sym_s && sym_e) {\n\t\tuwsgi_log(\"%.*s\", sym_e - sym_s, sym_s);\n\t}\n\n\texit(0);\n}\n\nvoid uwsgi_update_pidfiles() {\n\tif (uwsgi.pidfile) {\n\t\tuwsgi_write_pidfile(uwsgi.pidfile);\n\t}\n\tif (uwsgi.pidfile2) {\n\t\tuwsgi_write_pidfile(uwsgi.pidfile2);\n\t}\n\tif (uwsgi.safe_pidfile) {\n\t\tuwsgi_write_pidfile(uwsgi.safe_pidfile);\n\t}\n\tif (uwsgi.safe_pidfile2) {\n\t\tuwsgi_write_pidfile(uwsgi.safe_pidfile2);\n\t}\n}\n\nvoid uwsgi_opt_binary_append_data(char *opt, char *value, void *none) {\n\n\tsize_t size;\n\tchar *buf = uwsgi_open_and_read(value, &size, 0, NULL);\n\n\tuint64_t file_len = size;\n\n\tif (write(1, buf, size) != (ssize_t) size) {\n\t\tuwsgi_error(\"uwsgi_opt_binary_append_data()/write()\");\n\t\texit(1);\n\t}\n\n\tif (write(1, &file_len, 8) != 8) {\n\t\tuwsgi_error(\"uwsgi_opt_binary_append_data()/write()\");\n\t\texit(1);\n\t}\n\n\texit(0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/core/plugins.c": "#include \"uwsgi.h\"\n\nextern struct uwsgi_server uwsgi;\n\n#ifdef UWSGI_ELF\nstatic void uwsgi_plugin_parse_section(char *filename) {\n\tsize_t s_len = 0;\n\tchar *buf = uwsgi_elf_section(filename, \"uwsgi\", &s_len);\n\tif (buf) {\n\t\tchar *ctx = NULL;\n\t\tchar *p = strtok_r(buf, \"\\n\", &ctx);\n\t\twhile (p) {\n\t\t\tchar *equal = strchr(p, '=');\n\t\t\tif (equal) {\n\t\t\t\t*equal = 0;\n\t\t\t\tif (!strcmp(p, \"requires\")) {\n\t\t\t\t\tif (!plugin_already_loaded(equal+1)) {\t\n\t\t\t\t\t\tuwsgi_load_plugin(-1, equal + 1, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = strtok_r(NULL, \"\\n\", &ctx);\n\t\t}\n\t\tfree(buf);\n\t}\n}\n#endif\n\nstruct uwsgi_plugin *uwsgi_plugin_get(const char *plugin) {\n\tint i;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tif (uwsgi.p[i]->name) {\n\t\t\tif (!strcmp(plugin, uwsgi.p[i]->name)) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%s plugin already available\\n\", plugin);\n#endif\n\t\t\t\treturn uwsgi.p[i];\n\t\t\t}\n\t\t}\n\t\tif (uwsgi.p[i]->alias) {\n\t\t\tif (!strcmp(plugin, uwsgi.p[i]->alias)) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%s plugin already available\\n\", plugin);\n#endif\n\t\t\t\treturn uwsgi.p[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < uwsgi.gp_cnt; i++) {\n\n\t\tif (uwsgi.gp[i]->name) {\n\t\t\tif (!strcmp(plugin, uwsgi.gp[i]->name)) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%s plugin already available\\n\", plugin);\n#endif\n\t\t\t\treturn uwsgi.p[i];\n\t\t\t}\n\t\t}\n\t\tif (uwsgi.gp[i]->alias) {\n\t\t\tif (!strcmp(plugin, uwsgi.gp[i]->alias)) {\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%s plugin already available\\n\", plugin);\n#endif\n\t\t\t\treturn uwsgi.p[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nint plugin_already_loaded(const char *plugin) {\n\tstruct uwsgi_plugin *up = uwsgi_plugin_get(plugin);\n\tif (up) return 1;\n\treturn 0;\n}\n\n\nvoid *uwsgi_load_plugin(int modifier, char *plugin, char *has_option) {\n\n\tvoid *plugin_handle = NULL;\n\tchar *plugin_abs_path = NULL;\n\tchar *plugin_filename = NULL;\n\n\tint need_free = 0;\n\tchar *plugin_name = uwsgi_strip(uwsgi_str(plugin));\n\tchar *plugin_symbol_name_start;\n\n\tstruct uwsgi_plugin *up;\n\tchar linkpath_buf[1024], linkpath[1024];\n\tint linkpath_size;\n\n\tchar *colon = strchr(plugin_name, ':');\n\tif (colon) {\n\t\tcolon[0] = 0;\n\t\tmodifier = atoi(plugin_name);\n\t\tplugin_name = colon + 1;\n\t\tcolon[0] = ':';\n\t}\n\n\tchar *init_func = strchr(plugin_name, '|');\n\tif (init_func) {\n\t\tinit_func[0] = 0;\n\t\tinit_func++;\t\n\t}\n\n\tif (!uwsgi_endswith(plugin_name, \"_plugin.so\")) {\n\t\tplugin_name = uwsgi_concat2(plugin_name, \"_plugin.so\");\n\t\tneed_free = 1;\n\t}\n\n\tplugin_symbol_name_start = plugin_name;\n\n\t// step 1: check for absolute plugin (stop if it fails)\n\tif (strchr(plugin_name, '/')) {\n#ifdef UWSGI_ELF\n\t\tuwsgi_plugin_parse_section(plugin_name);\n#endif\n\t\tplugin_handle = dlopen(plugin_name, RTLD_NOW | RTLD_GLOBAL);\n\t\tif (!plugin_handle) {\n\t\t\tif (!has_option)\n\t\t\t\tuwsgi_log(\"%s\\n\", dlerror());\n\t\t\tgoto end;\n\t\t}\n\t\tplugin_symbol_name_start = uwsgi_get_last_char(plugin_name, '/');\n\t\tplugin_symbol_name_start++;\n\t\tplugin_abs_path = plugin_name;\n\t\tgoto success;\n\t}\n\n\t// step dir, check for user-supplied plugins directory\n\tstruct uwsgi_string_list *pdir = uwsgi.plugins_dir;\n\twhile (pdir) {\n\t\tplugin_filename = uwsgi_concat3(pdir->value, \"/\", plugin_name);\n#ifdef UWSGI_ELF\n\t\tuwsgi_plugin_parse_section(plugin_filename);\n#endif\n\t\tplugin_handle = dlopen(plugin_filename, RTLD_NOW | RTLD_GLOBAL);\n\t\tif (plugin_handle) {\n\t\t\tplugin_abs_path = plugin_filename;\n\t\t\t//free(plugin_filename);\n\t\t\tgoto success;\n\t\t}\n\t\tfree(plugin_filename);\n\t\tplugin_filename = NULL;\n\t\tpdir = pdir->next;\n\t}\n\n\t// last step: search in compile-time plugin_dir\n\tif (!plugin_handle) {\n\t\tplugin_filename = uwsgi_concat3(UWSGI_PLUGIN_DIR, \"/\", plugin_name);\n#ifdef UWSGI_ELF\n\t\tuwsgi_plugin_parse_section(plugin_filename);\n#endif\n\t\tplugin_handle = dlopen(plugin_filename, RTLD_NOW | RTLD_GLOBAL);\n\t\tplugin_abs_path = plugin_filename;\n\t\t//free(plugin_filename);\n\t}\n\nsuccess:\n\tif (!plugin_handle) {\n\t\tif (!has_option)\n\t\t\tuwsgi_log(\"!!! UNABLE to load uWSGI plugin: %s !!!\\n\", dlerror());\n\t}\n\telse {\n\t\tif (init_func) {\n\t\t\tvoid (*plugin_init_func)() = dlsym(plugin_handle, init_func);\n\t\t\tif (plugin_init_func) {\n\t\t\t\tplugin_init_func();\n\t\t\t}\n\t\t}\n\t\tchar *plugin_entry_symbol = uwsgi_concat2n(plugin_symbol_name_start, strlen(plugin_symbol_name_start) - 3, \"\", 0);\n\t\tup = dlsym(plugin_handle, plugin_entry_symbol);\n\t\tif (!up) {\n\t\t\t// is it a link ?\n\t\t\tmemset(linkpath_buf, 0, 1024);\n\t\t\tmemset(linkpath, 0, 1024);\n\t\t\tif ((linkpath_size = readlink(plugin_abs_path, linkpath_buf, 1023)) > 0) {\n\t\t\t\tdo {\n\t\t\t\t\tlinkpath_buf[linkpath_size] = '\\0';\n\t\t\t\t\tstrncpy(linkpath, linkpath_buf, linkpath_size + 1);\n\t\t\t\t} while ((linkpath_size = readlink(linkpath, linkpath_buf, 1023)) > 0);\n#ifdef UWSGI_DEBUG\n\t\t\t\tuwsgi_log(\"%s\\n\", linkpath);\n#endif\n\t\t\t\tfree(plugin_entry_symbol);\n\t\t\t\tchar *slash = uwsgi_get_last_char(linkpath, '/');\n\t\t\t\tif (!slash) {\n\t\t\t\t\tslash = linkpath;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tslash++;\n\t\t\t\t}\n\t\t\t\tplugin_entry_symbol = uwsgi_concat2n(slash, strlen(slash) - 3, \"\", 0);\n\t\t\t\tup = dlsym(plugin_handle, plugin_entry_symbol);\n\t\t\t}\n\t\t}\n\t\tif (up) {\n\t\t\tif (!up->name) {\n\t\t\t\tuwsgi_log(\"the loaded plugin (%s) has no .name attribute\\n\", plugin_name);\n\t\t\t\tif (dlclose(plugin_handle)) {\n\t\t\t\t\tuwsgi_error(\"dlclose()\");\n\t\t\t\t}\n\t\t\t\tif (need_free)\n\t\t\t\t\tfree(plugin_name);\n\t\t\t\tif (plugin_filename)\n\t\t\t\t\tfree(plugin_filename);\n\t\t\t\tfree(plugin_entry_symbol);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (plugin_already_loaded(up->name)) {\n\t\t\t\tif (dlclose(plugin_handle)) {\n\t\t\t\t\tuwsgi_error(\"dlclose()\");\n\t\t\t\t}\n\t\t\t\tif (need_free)\n\t\t\t\t\tfree(plugin_name);\n\t\t\t\tif (plugin_filename)\n\t\t\t\t\tfree(plugin_filename);\n\t\t\t\tfree(plugin_entry_symbol);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (has_option) {\n\t\t\t\tstruct uwsgi_option *op = up->options;\n\t\t\t\tint found = 0;\n\t\t\t\twhile (op && op->name) {\n\t\t\t\t\tif (!strcmp(has_option, op->name)) {\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\top++;\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tif (dlclose(plugin_handle)) {\n\t\t\t\t\t\tuwsgi_error(\"dlclose()\");\n\t\t\t\t\t}\n\t\t\t\t\tif (need_free)\n\t\t\t\t\t\tfree(plugin_name);\n\t\t\t\t\tif (plugin_filename)\n\t\t\t\t\t\tfree(plugin_filename);\n\t\t\t\t\tfree(plugin_entry_symbol);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (modifier != -1) {\n\t\t\t\tfill_plugin_table(modifier, up);\n\t\t\t\tup->modifier1 = modifier;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfill_plugin_table(up->modifier1, up);\n\t\t\t}\n\t\t\tif (need_free)\n\t\t\t\tfree(plugin_name);\n\t\t\tif (plugin_filename)\n\t\t\t\tfree(plugin_filename);\n\t\t\tfree(plugin_entry_symbol);\n\n\t\t\tif (up->on_load)\n\t\t\t\tup->on_load();\n\t\t\treturn plugin_handle;\n\t\t}\n\t\tif (!has_option)\n\t\t\tuwsgi_log(\"%s\\n\", dlerror());\n\t}\n\nend:\n\tif (need_free)\n\t\tfree(plugin_name);\n\tif (plugin_filename)\n\t\tfree(plugin_filename);\n\n\treturn NULL;\n}\n\nint uwsgi_try_autoload(char *option) {\n\tDIR *d;\n\tstruct dirent *dp;\n\t// step dir, check for user-supplied plugins directory\n\tstruct uwsgi_string_list *pdir = uwsgi.plugins_dir;\n\twhile (pdir) {\n\t\td = opendir(pdir->value);\n\t\tif (d) {\n\t\t\twhile ((dp = readdir(d)) != NULL) {\n\t\t\t\tif (uwsgi_endswith(dp->d_name, \"_plugin.so\")) {\n\t\t\t\t\tchar *filename = uwsgi_concat3(pdir->value, \"/\", dp->d_name);\n\t\t\t\t\tif (uwsgi_load_plugin(-1, filename, option)) {\n\t\t\t\t\t\tuwsgi_log(\"option \\\"%s\\\" found in plugin %s\\n\", option, filename);\n\t\t\t\t\t\tfree(filename);\n\t\t\t\t\t\tclosedir(d);\n\t\t\t\t\t\t// add new options\n\t\t\t\t\t\tbuild_options();\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tfree(filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(d);\n\t\t}\n\t\tpdir = pdir->next;\n\t}\n\n\t// last step: search in compile-time plugin_dir\n\td = opendir(UWSGI_PLUGIN_DIR);\n\tif (!d)\n\t\treturn 0;\n\n\twhile ((dp = readdir(d)) != NULL) {\n\t\tif (uwsgi_endswith(dp->d_name, \"_plugin.so\")) {\n\t\t\tchar *filename = uwsgi_concat3(UWSGI_PLUGIN_DIR, \"/\", dp->d_name);\n\t\t\tif (uwsgi_load_plugin(-1, filename, option)) {\n\t\t\t\tuwsgi_log(\"option \\\"%s\\\" found in plugin %s\\n\", option, filename);\n\t\t\t\tfree(filename);\n\t\t\t\tclosedir(d);\n\t\t\t\t// add new options\n\t\t\t\tbuild_options();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(filename);\n\t\t}\n\t}\n\n\tclosedir(d);\n\n\treturn 0;\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/core/io.c": "#include \"uwsgi.h\"\n\nextern struct uwsgi_server uwsgi;\n\n/*\n\n\tpoll based fd waiter.\n\tUse it for blocking areas (like startup functions)\n\tDO NOT USE IN REQUEST PLUGINS !!!\n\n*/\nint uwsgi_waitfd_event(int fd, int timeout, int event) {\n\n\tint ret;\n\tstruct pollfd upoll;\n\n\tif (!timeout)\n\t\ttimeout = uwsgi.socket_timeout;\n\n\ttimeout = timeout * 1000;\n\tif (timeout < 0)\n\t\ttimeout = -1;\n\n\tupoll.fd = fd;\n\tupoll.events = event;\n\tupoll.revents = 0;\n\tret = poll(&upoll, 1, timeout);\n\n\tif (ret < 0) {\n\t\tuwsgi_error(\"uwsgi_waitfd_event()/poll()\");\n\t}\n\telse if (ret > 0) {\n\t\tif (upoll.revents & event) {\n\t\t\treturn ret;\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n\n/*\n\tconsume data from an fd (blocking)\n*/\nchar *uwsgi_read_fd(int fd, size_t *size, int add_zero) {\n\n\tchar stack_buf[4096];\n\tssize_t len;\n\tchar *buffer = NULL;\n\n\tlen = 1;\n\twhile (len > 0) {\n\t\tlen = read(fd, stack_buf, 4096);\n\t\tif (len > 0) {\n\t\t\t*size += len;\n\t\t\tchar *tmp = realloc(buffer, *size);\n\t\t\tif (!tmp) {\n\t\t\t\tuwsgi_error(\"uwsgi_read_fd()/realloc()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbuffer = tmp;\n\t\t\tmemcpy(buffer + (*size - len), stack_buf, len);\n\t\t}\n\t}\n\n\tif (add_zero) {\n\t\t*size = *size + 1;\n\t\tbuffer = realloc(buffer, *size);\n\t\tif (!buffer) {\n\t\t\tuwsgi_error(\"uwsgi_read_fd()/realloc()\");\n\t\t\texit(1);\n\t\t}\n\t\tbuffer[*size - 1] = 0;\n\t}\n\n\treturn buffer;\n\n}\n\n// simply read the whole content of a file\nchar *uwsgi_simple_file_read(char *filename) {\n\n\tstruct stat sb;\n\tchar *buffer;\n\tssize_t len;\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(filename);\n\t\tgoto end;\n\t}\n\n\tif (fstat(fd, &sb)) {\n\t\tuwsgi_error(\"fstat()\");\n\t\tclose(fd);\n\t\tgoto end;\n\t}\n\n\tbuffer = uwsgi_malloc(sb.st_size + 1);\n\n\tlen = read(fd, buffer, sb.st_size);\n\tif (len != sb.st_size) {\n\t\tuwsgi_error(\"read()\");\n\t\tfree(buffer);\n\t\tclose(fd);\n\t\tgoto end;\n\t}\n\n\tclose(fd);\n\tif (buffer[sb.st_size - 1] == '\\n' || buffer[sb.st_size - 1] == '\\r') {\n\t\tbuffer[sb.st_size - 1] = 0;\n\t}\n\tbuffer[sb.st_size] = 0;\n\treturn buffer;\nend:\n\treturn (char *) \"\";\n\n}\n\nstatic char *uwsgi_scheme_fd(char *url, size_t *size, int add_zero) {\n\tint fd = atoi(url);\n\treturn uwsgi_read_fd(fd, size, add_zero);\n}\n\nstatic char *uwsgi_scheme_exec(char *url, size_t *size, int add_zero) {\n\tint cpipe[2];\n\tif (pipe(cpipe)) {\n\t\tuwsgi_error(\"pipe()\");\n\t\texit(1);\n\t}\n\tuwsgi_run_command(url, NULL, cpipe[1]);\n\tchar *buffer = uwsgi_read_fd(cpipe[0], size, add_zero);\n\tclose(cpipe[0]);\n\tclose(cpipe[1]);\n\treturn buffer;\n}\n\nstatic char *uwsgi_scheme_http(char *url, size_t *size, int add_zero) {\n\tchar byte;\n        int body = 0;\n\tchar *buffer = NULL;\n\n\t\tchar *domain = url;\n\t\tchar *uri = strchr(domain, '/');\n\t\tif (!uri) {\n\t\t\tuwsgi_log(\"invalid http url\\n\");\n\t\t\texit(1);\n\t\t}\n\t\turi[0] = 0;\n\t\tuwsgi_log(\"domain: %s\\n\", domain);\n\n\t\tchar *colon = uwsgi_get_last_char(domain, ':');\n\n\t\tif (colon) {\n\t\t\tcolon[0] = 0;\n\t\t}\n\n\n\t\tchar *ip = uwsgi_resolve_ip(domain);\n\t\tif (!ip) {\n\t\t\tuwsgi_log(\"unable to resolve address %s\\n\", domain);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (colon) {\n\t\t\tcolon[0] = ':';\n\t\t\tip = uwsgi_concat2(ip, colon);\n\t\t}\n\t\telse {\n\t\t\tip = uwsgi_concat2(ip, \":80\");\n\t\t}\n\n\t\tint fd = uwsgi_connect(ip, 0, 0);\n\n\t\tif (fd < 0) {\n\t\t\tuwsgi_error(\"uwsgi_scheme_http()/connect()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tfree(ip);\n\n\t\turi[0] = '/';\n\n\t\tif (write(fd, \"GET \", 4) != 4) { uwsgi_error(\"uwsgi_scheme_http()/write()\"); exit(1);}\n\t\tif (write(fd, uri, strlen(uri)) != (ssize_t) strlen(uri)) { uwsgi_error(\"uwsgi_scheme_http()/write()\"); exit(1);}\n\t\tif (write(fd, \" HTTP/1.0\\r\\n\", 11) != 11) { uwsgi_error(\"uwsgi_scheme_http()/write()\"); exit(1);}\n\t\tif (write(fd, \"Host: \", 6) != 6) { uwsgi_error(\"uwsgi_scheme_http()/write()\"); exit(1);}\n\n\t\turi[0] = 0;\n\t\tif (write(fd, domain, strlen(domain)) != (ssize_t) strlen(domain)) { uwsgi_error(\"uwsgi_scheme_http()/write()\"); exit(1);}\n\t\turi[0] = '/';\n\n\t\tif (write(fd, \"\\r\\nUser-Agent: uWSGI on \", 23) != 23) { uwsgi_error(\"uwsgi_scheme_http()/write()\"); exit(1);}\n\t\tif (write(fd, uwsgi.hostname, uwsgi.hostname_len) != uwsgi.hostname_len) { uwsgi_error(\"uwsgi_scheme_http()/write()\"); exit(1);}\n\t\tif (write(fd, \"\\r\\n\\r\\n\", 4) != 4) { uwsgi_error(\"uwsgi_scheme_http()/write()\"); exit(1);}\n\n\t\tint http_status_code_ptr = 0;\n\n\t\twhile (read(fd, &byte, 1) == 1) {\n\t\t\tif (byte == '\\r' && body == 0) {\n\t\t\t\tbody = 1;\n\t\t\t}\n\t\t\telse if (byte == '\\n' && body == 1) {\n\t\t\t\tbody = 2;\n\t\t\t}\n\t\t\telse if (byte == '\\r' && body == 2) {\n\t\t\t\tbody = 3;\n\t\t\t}\n\t\t\telse if (byte == '\\n' && body == 3) {\n\t\t\t\tbody = 4;\n\t\t\t}\n\t\t\telse if (body == 4) {\n\t\t\t\t*size = *size + 1;\n\t\t\t\tchar *tmp = realloc(buffer, *size);\n\t\t\t\tif (!tmp) {\n\t\t\t\t\tuwsgi_error(\"uwsgi_open_and_read()/realloc()\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tbuffer = tmp;\n\t\t\t\tbuffer[*size - 1] = byte;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbody = 0;\n\t\t\t\thttp_status_code_ptr++;\n\t\t\t\tif (http_status_code_ptr == 10) {\n\t\t\t\t\tif (byte != '2') {\n\t\t\t\t\t\tuwsgi_log(\"Not usable HTTP response: %cxx\\n\", byte);\n\t\t\t\t\t\tif (uwsgi.has_emperor) {\n\t\t\t\t\t\t\texit(UWSGI_EXILE_CODE);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\texit(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclose(fd);\n\n\t\tif (add_zero) {\n\t\t\t*size = *size + 1;\n\t\t\tchar *tmp = realloc(buffer, *size);\n\t\t\tif (!tmp) {\n\t\t\t\tuwsgi_error(\"uwsgi_open_and_read()/realloc()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbuffer = tmp;\n\t\t\tbuffer[*size - 1] = 0;\n\t\t}\n\n\treturn buffer;\n}\n\n\nstatic char *uwsgi_scheme_emperor(char *url, size_t *size, int add_zero) {\n\n\tif (uwsgi.emperor_fd_config < 0) {\n\t\tuwsgi_log(\"this is not a vassal instance\\n\");\n\t\texit(1);\n\t}\n\tssize_t rlen;\n\tstruct uwsgi_header uh;\n\tsize_t remains = 4;\n\tchar *ptr = (char *) &uh;\n\twhile(remains) {\n\t\tint ret = uwsgi_waitfd(uwsgi.emperor_fd_config, 5);\n\t\tif (ret <= 0) {\n\t\t\tuwsgi_log(\"[uwsgi-vassal] error waiting for config header %s !!!\\n\", url);\n\t\t\texit(1);\n\t\t}\n\t\trlen = read(uwsgi.emperor_fd_config, ptr, remains);\n\t\tif (rlen <= 0) {\n\t\t\tuwsgi_log(\"[uwsgi-vassal] error reading config header from %s !!!\\n\", url);\n\t\t\texit(1);\n\t\t}\n\t\tptr+=rlen;\n\t\tremains-=rlen;\n\t}\n\n\tremains = uh.pktsize;\n\tif (!remains) {\n\t\tuwsgi_log(\"[uwsgi-vassal] invalid config from %s\\n\", url);\n\t\texit(1);\n\t}\n\n\tchar *buffer = uwsgi_calloc(remains + add_zero);\n\tptr = buffer;\n\twhile (remains) {\n\t\tint ret = uwsgi_waitfd(uwsgi.emperor_fd_config, 5);\n                if (ret <= 0) {\n                \tuwsgi_log(\"[uwsgi-vassal] error waiting for config %s !!!\\n\", url);\n                        exit(1);\n                }\n\t\trlen = read(uwsgi.emperor_fd_config, ptr, remains);\n\t\tif (rlen <= 0) {\n                \tuwsgi_log(\"[uwsgi-vassal] error reading config from %s !!!\\n\", url);\n                        exit(1);\n                }\n                ptr+=rlen;\n                remains-=rlen;\n\t}\n\n\t*size = uh.pktsize + add_zero;\n\treturn buffer;\n}\n\nstatic char *uwsgi_scheme_data(char *url, size_t *size, int add_zero) {\n\tchar *buffer = NULL;\n\tint fd = open(uwsgi.binary_path, O_RDONLY);\n\tif (fd < 0) {\n\t\tuwsgi_error_open(uwsgi.binary_path);\n\t\texit(1);\n\t}\n\tint slot = atoi(url);\n\tif (slot < 0) {\n\t\tuwsgi_log(\"invalid binary data slot requested\\n\");\n\t\texit(1);\n\t}\n\tuwsgi_log(\"requesting binary data slot %d\\n\", slot);\n\toff_t fo = lseek(fd, 0, SEEK_END);\n\tif (fo < 0) {\n\t\tuwsgi_error(\"lseek()\");\n\t\tuwsgi_log(\"invalid binary data slot requested\\n\");\n\t\texit(1);\n\t}\n\tint i = 0;\n\tuint64_t datasize = 0;\n\tfor (i = 0; i <= slot; i++) {\n\t\tfo = lseek(fd, -8, SEEK_CUR);\n\t\tif (fo < 0) {\n\t\t\tuwsgi_error(\"lseek()\");\n\t\t\tuwsgi_log(\"invalid binary data slot requested\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tssize_t len = read(fd, &datasize, 8);\n\t\tif (len != 8) {\n\t\t\tuwsgi_error(\"read()\");\n\t\t\tuwsgi_log(\"invalid binary data slot requested\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (datasize == 0) {\n\t\t\tuwsgi_log(\"0 size binary data !!!\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfo = lseek(fd, -(datasize + 8), SEEK_CUR);\n\t\tif (fo < 0) {\n\t\t\tuwsgi_error(\"lseek()\");\n\t\t\tuwsgi_log(\"invalid binary data slot requested\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (i == slot) {\n\t\t\t*size = datasize;\n\t\t\tif (add_zero) {\n\t\t\t\t*size += 1;\n\t\t\t}\n\t\t\tbuffer = uwsgi_malloc(*size);\n\t\t\tmemset(buffer, 0, *size);\n\t\t\tlen = read(fd, buffer, datasize);\n\t\t\tif (len != (ssize_t) datasize) {\n\t\t\t\tuwsgi_error(\"read()\");\n\t\t\t\tuwsgi_log(\"invalid binary data slot requested\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t}\n\tclose(fd);\n\n\treturn buffer;\n}\n\nstatic char *uwsgi_scheme_call(char *url, size_t *size, int add_zero) {\n        char *(*func)(void) = dlsym(RTLD_DEFAULT, url);\n\tif (!func) {\n\t\tuwsgi_log(\"unable to find symbol %s\\n\", url);\n                exit(1);\n\t}\n\n\tchar *s = func();\n\tif (!s) {\n\t\tuwsgi_log(\"called symbol %s did not return a string\\n\", url);\n                exit(1);\n\t}\n        *size = strlen(s);\n        if (add_zero) {\n                *size += 1;\n        }\n        char *buffer = uwsgi_malloc(*size);\n        memset(buffer, 0, *size);\n        memcpy(buffer, s, strlen(s));\n\n        return buffer;\n}\n\nstatic char *uwsgi_scheme_callint(char *url, size_t *size, int add_zero) {\n        int (*func)(void) = dlsym(RTLD_DEFAULT, url);\n        if (!func) {\n                uwsgi_log(\"unable to find symbol %s\\n\", url);\n                exit(1);\n        }\n\n\tchar *s = uwsgi_num2str(func());\n        *size = strlen(s);\n        if (add_zero) {\n                *size += 1;\n        }\n        char *buffer = uwsgi_malloc(*size);\n        memset(buffer, 0, *size);\n        memcpy(buffer, s, strlen(s));\n\tfree(s);\n\n        return buffer;\n}\n\n\nstatic char *uwsgi_scheme_sym(char *url, size_t *size, int add_zero) {\n\tvoid *sym_start_ptr = NULL, *sym_end_ptr = NULL;\n\tchar **raw_symbol = dlsym(RTLD_DEFAULT, url);\n\tif (raw_symbol) {\n\t\tsym_start_ptr = *raw_symbol;\n\t\tsym_end_ptr = sym_start_ptr + strlen(sym_start_ptr);\n\t\tgoto found;\n\t}\n\tchar *symbol = uwsgi_concat3(\"_binary_\", url, \"_start\");\n\tsym_start_ptr = dlsym(RTLD_DEFAULT, symbol);\n\tif (!sym_start_ptr) {\n\t\tuwsgi_log(\"unable to find symbol %s\\n\", symbol);\n\t\texit(1);\n\t}\n\tfree(symbol);\n\tsymbol = uwsgi_concat3(\"_binary_\", url, \"_end\");\n\tsym_end_ptr = dlsym(RTLD_DEFAULT, symbol);\n\tif (!sym_end_ptr) {\n\t\tuwsgi_log(\"unable to find symbol %s\\n\", symbol);\n\t\texit(1);\n\t}\n\tfree(symbol);\n\nfound:\n\n\t*size = sym_end_ptr - sym_start_ptr;\n\tif (add_zero) {\n\t\t*size += 1;\n\t}\n\tchar *buffer = uwsgi_malloc(*size);\n\tmemset(buffer, 0, *size);\n\tmemcpy(buffer, sym_start_ptr, sym_end_ptr - sym_start_ptr);\n\n\treturn buffer;\n}\n\nstatic char *uwsgi_scheme_section(char *url, size_t *size, int add_zero) {\n#ifdef UWSGI_ELF\n\tsize_t s_len = 0;\n\tchar *buffer = uwsgi_elf_section(uwsgi.binary_path, url, &s_len);\n\tif (!buffer) {\n\t\tuwsgi_log(\"unable to find section %s in %s\\n\", url + 10, uwsgi.binary_path);\n\t\texit(1);\n\t}\n\t*size = s_len;\n\tif (add_zero)\n\t\t*size += 1;\n\treturn buffer;\n#else\n\tuwsgi_log(\"section:// scheme not supported on this platform\\n\");\n\texit(1);\n#endif\n}\n\nstruct uwsgi_string_list *uwsgi_register_scheme(char *name, char * (*func)(char *, size_t *, int)) {\n\tstruct uwsgi_string_list *usl = NULL;\n\tuwsgi_foreach(usl, uwsgi.schemes) {\n\t\tif (!strcmp(usl->value, name)) goto found;\n\t}\n\n\tusl = uwsgi_string_new_list(&uwsgi.schemes, name); \t\n\nfound:\n\tusl->custom_ptr = func;\n\treturn usl;\n}\n\nchar *uwsgi_open_and_read(char *url, size_t *size, int add_zero, char *magic_table[]) {\n\n        struct stat sb;\n        char *buffer = NULL;\n        ssize_t len;\n        char *magic_buf;\n\tint fd;\n\n\t*size = 0;\n\n        // stdin ?\n        if (!strcmp(url, \"-\")) {\n                buffer = uwsgi_read_fd(0, size, add_zero);\n\t\tgoto end;\n        }\n#ifdef UWSGI_EMBED_CONFIG\n\telse if (url[0] == 0) {\n\t\t*size = &UWSGI_EMBED_CONFIG_END - &UWSGI_EMBED_CONFIG;\n\t\tif (add_zero) {\n\t\t\t*size += 1;\n\t\t}\n\t\tbuffer = uwsgi_malloc(*size);\n\t\tmemset(buffer, 0, *size);\n\t\tmemcpy(buffer, &UWSGI_EMBED_CONFIG, &UWSGI_EMBED_CONFIG_END - &UWSGI_EMBED_CONFIG);\n\t\tgoto end;\n\t}\n#endif\n\n\tstruct uwsgi_string_list *usl = uwsgi_check_scheme(url);\n\tif (!usl) goto fallback;\n\n\tchar *(*func)(char *, size_t *, int) = (char *(*)(char *, size_t *, int)) usl->custom_ptr;\n\tbuffer = func(url + usl->len + 3, size, add_zero);\n\tif (buffer) goto end;\n\t// never here !!!\n\tuwsgi_log(\"unable to parse config file %s\\n\", url);\n\texit(1);\n\t\n\t// fallback to file\nfallback:\n\t\tfd = open(url, O_RDONLY);\n\t\tif (fd < 0) {\n\t\t\tuwsgi_error_open(url);\n\t\t\texit(1);\n\t\t}\n\n\t\tif (fstat(fd, &sb)) {\n\t\t\tuwsgi_error(\"fstat()\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (S_ISFIFO(sb.st_mode)) {\n\t\t\tbuffer = uwsgi_read_fd(fd, size, add_zero);\n\t\t\tclose(fd);\n\t\t\tgoto end;\n\t\t}\n\n\t\t// is it a potential virtual file (/proc, /sys...) ?\n\t\tint is_virtual = 0;\n\t\tif (sb.st_size == 0) {\n\t\t\tis_virtual = 1;\n\t\t\tsb.st_size = 4096;\n\t\t}\n\n\t\tbuffer = uwsgi_malloc(sb.st_size + add_zero);\n\n\t\tlen = read(fd, buffer, sb.st_size);\n\t\tif (!is_virtual) {\n\t\t\tif (len != sb.st_size) {\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (len >= 0) {\n\t\t\t\tsb.st_size = len;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuwsgi_error(\"read()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tclose(fd);\n\n\t\t*size = sb.st_size + add_zero;\n\n\t\tif (add_zero)\n\t\t\tbuffer[sb.st_size] = 0;\n\nend:\n\n\tif (magic_table) {\n\t\t// here we inject blobs\n\t\tstruct uwsgi_string_list *usl = NULL;\n\t\tif (uwsgi.inject_before || uwsgi.inject_after) {\n\t\t\tstruct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);\n\t\t\tuwsgi_foreach(usl, uwsgi.inject_before) {\n\t\t\t\tsize_t rlen = 0;\n\t\t\t\tchar *before = uwsgi_open_and_read(usl->value, &rlen, 0, NULL);\n\t\t\t\tif (uwsgi_buffer_append(ub, before, rlen)) {\n\t\t\t\t\tuwsgi_log(\"unable to inject data in the config file\\n\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\t\n\t\t\t\tfree(before);\n\t\t\t}\n\t\t\tif (uwsgi_buffer_append(ub, buffer, *size - add_zero)) {\n                        \tuwsgi_log(\"unable to inject data in the config file\\n\");\n                                exit(1);\n                        }\n\t\t\tuwsgi_foreach(usl, uwsgi.inject_after) {\n\t\t\t\tsize_t rlen = 0;\n                                char *after = uwsgi_open_and_read(usl->value, &rlen, 0, NULL);\n                                if (uwsgi_buffer_append(ub, after, rlen)) {\n                                        uwsgi_log(\"unable to inject data in the config file\\n\");\n                                        exit(1);\n                                }       \n                                free(after);\n\t\t\t}\n\t\t\tif (add_zero) {\n\t\t\t\tif (uwsgi_buffer_append(ub, \"\\0\", 1)) {\n                                        uwsgi_log(\"unable to inject data in the config file\\n\");\n                                        exit(1);\n                                }\n\t\t\t}\n\t\t\t*size = ub->pos; \n\t\t\t// free resources\n\t\t\tfree(buffer);\n\t\t\tbuffer = ub->buf;\n\t\t\t// aboid destroying buffer\n\t\t\tub->buf = NULL;\n\t\t\tuwsgi_buffer_destroy(ub);\n\t\t}\n\t\tmagic_buf = magic_sub(buffer, *size, size, magic_table);\n\t\tfree(buffer);\n\t\treturn magic_buf;\n\t}\n\n\treturn buffer;\n}\n\n// attach an fd using UNIX sockets\nint *uwsgi_attach_fd(int fd, int *count_ptr, char *code, size_t code_len) {\n\n\tstruct msghdr msg;\n\tssize_t len;\n\tchar *id = NULL;\n\n\tstruct iovec iov;\n\tstruct cmsghdr *cmsg;\n\tint *ret;\n\tint i;\n\tint count = *count_ptr;\n\n\tvoid *msg_control = uwsgi_malloc(CMSG_SPACE(sizeof(int) * count));\n\n\tmemset(msg_control, 0, CMSG_SPACE(sizeof(int) * count));\n\n\tif (code && code_len > 0) {\n\t\t// allocate space for code and num_sockets\n\t\tid = uwsgi_malloc(code_len + sizeof(int));\n\t\tmemset(id, 0, code_len);\n\t\tiov.iov_len = code_len + sizeof(int);\n\t}\n\n\tiov.iov_base = id;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tmsg.msg_control = msg_control;\n\tmsg.msg_controllen = CMSG_SPACE(sizeof(int) * count);\n\n\tmsg.msg_flags = 0;\n\n\tlen = recvmsg(fd, &msg, 0);\n\tif (len <= 0) {\n\t\tuwsgi_error(\"recvmsg()\");\n\t\tfree(msg_control);\n\t\treturn NULL;\n\t}\n\n\tif (code && code_len > 0) {\n\t\tif (uwsgi_strncmp(id, code_len, code, code_len)) {\n\t\t\tfree(msg_control);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((size_t) len == code_len + sizeof(int)) {\n\t\t\tmemcpy(&i, id + code_len, sizeof(int));\n\t\t\tif (i > count) {\n\t\t\t\t*count_ptr = i;\n\t\t\t\tfree(msg_control);\n\t\t\t\tfree(id);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tif (!cmsg) {\n\t\tfree(msg_control);\n\t\treturn NULL;\n\t}\n\n\tif (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {\n\t\tfree(msg_control);\n\t\treturn NULL;\n\t}\n\n\tif ((size_t) (cmsg->cmsg_len - ((char *) CMSG_DATA(cmsg) - (char *) cmsg)) > (size_t) (sizeof(int) * (count + 1))) {\n\t\tuwsgi_log(\"not enough space for sockets data, consider increasing it\\n\");\n\t\tfree(msg_control);\n\t\treturn NULL;\n\t}\n\n\tret = uwsgi_malloc(sizeof(int) * (count + 1));\n\tfor (i = 0; i < count + 1; i++) {\n\t\tret[i] = -1;\n\t}\n\n\tmemcpy(ret, CMSG_DATA(cmsg), cmsg->cmsg_len - ((char *) CMSG_DATA(cmsg) - (char *) cmsg));\n\n\tfree(msg_control);\n\tif (code && code_len > 0) {\n\t\tfree(id);\n\t}\n\n\treturn ret;\n}\n\n// signal free close\nvoid uwsgi_protected_close(int fd) {\n\n\tsigset_t mask, oset;\n\tsigfillset(&mask);\n\tif (sigprocmask(SIG_BLOCK, &mask, &oset)) {\n\t\tuwsgi_error(\"sigprocmask()\");\n\t\texit(1);\n\t}\n\tclose(fd);\n\tif (sigprocmask(SIG_SETMASK, &oset, NULL)) {\n\t\tuwsgi_error(\"sigprocmask()\");\n\t\texit(1);\n\t}\n}\n\n// signal free read\nssize_t uwsgi_protected_read(int fd, void *buf, size_t len) {\n\n\tsigset_t mask, oset;\n\tsigfillset(&mask);\n\tif (sigprocmask(SIG_BLOCK, &mask, &oset)) {\n\t\tuwsgi_error(\"sigprocmask()\");\n\t\texit(1);\n\t}\n\n\tssize_t ret = read(fd, buf, len);\n\n\tif (sigprocmask(SIG_SETMASK, &oset, NULL)) {\n\t\tuwsgi_error(\"sigprocmask()\");\n\t\texit(1);\n\t}\n\treturn ret;\n}\n\n\n// pipe datas from a fd to another (blocking)\nssize_t uwsgi_pipe(int src, int dst, int timeout) {\n\tchar buf[8192];\n\tsize_t written = -1;\n\tssize_t len;\n\n\tfor (;;) {\n\t\tint ret = uwsgi_waitfd(src, timeout);\n\t\tif (ret > 0) {\n\t\t\tlen = read(src, buf, 8192);\n\t\t\tif (len == 0) {\n\t\t\t\treturn written;\n\t\t\t}\n\t\t\telse if (len < 0) {\n\t\t\t\tuwsgi_error(\"read()\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tsize_t remains = len;\n\t\t\twhile (remains > 0) {\n\t\t\t\tint ret = uwsgi_waitfd_write(dst, timeout);\n\t\t\t\tif (ret > 0) {\n\t\t\t\t\tlen = write(dst, buf, remains);\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tremains -= len;\n\t\t\t\t\t\twritten += len;\n\t\t\t\t\t}\n\t\t\t\t\telse if (len == 0) {\n\t\t\t\t\t\treturn written;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuwsgi_error(\"write()\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ret == 0) {\n\t\t\t\t\tgoto timeout;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (ret == 0) {\n\t\t\tgoto timeout;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn written;\ntimeout:\n\tuwsgi_log(\"timeout while piping from %d to %d !!!\\n\", src, dst);\n\treturn -1;\n}\n\n/*\n\teven if it is marked as non-blocking, so not use in request plugins as it uses poll() and not the hooks\n*/\nint uwsgi_write_nb(int fd, char *buf, size_t remains, int timeout) {\n\tchar *ptr = buf;\n\twhile(remains > 0) {\n\t\tint ret = uwsgi_waitfd_write(fd, timeout);\n\t\tif (ret > 0) {\n\t\t\tssize_t len = write(fd, ptr, remains);\n\t\t\tif (len <= 0) {\n\t\t\t\treturn -1;\n\t\t\t} \n\t\t\tptr += len;\n\t\t\tremains -= len;\t\n\t\t\tcontinue;\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n\tthis is like uwsgi_write_nb() but with fast initial write and hooked wait (use it in request plugin)\n*/\nint uwsgi_write_true_nb(int fd, char *buf, size_t remains, int timeout) {\n        char *ptr = buf;\n\tint ret;\n\n        while(remains > 0) {\n\t\terrno = 0;\n\t\tssize_t len = write(fd, ptr, remains);\n\t\tif (len > 0) goto written;\n\t\tif (len == 0) return -1;\t\t\n\t\tif (len < 0) {\n\t\t\tif (uwsgi_is_again()) goto wait;\n\t\t\treturn -1;\n\t\t}\nwait:\n                ret = uwsgi.wait_write_hook(fd, timeout);\n                if (ret > 0) {\n\t\t\tlen = write(fd, ptr, remains);\n\t\t\tif (len > 0) goto written;\n                }\n                return -1;\nwritten:\n                ptr += len;\n                remains -= len;\n                continue;\n        }\n\n        return 0;\n}\n\n\n\n\n// like uwsgi_pipe but with fixed size\nssize_t uwsgi_pipe_sized(int src, int dst, size_t required, int timeout) {\n\tchar buf[8192];\n\tsize_t written = 0;\n\tssize_t len;\n\n\twhile (written < required) {\n\t\tint ret = uwsgi_waitfd(src, timeout);\n\t\tif (ret > 0) {\n\t\t\tlen = read(src, buf, UMIN(8192, required - written));\n\t\t\tif (len == 0) {\n\t\t\t\treturn written;\n\t\t\t}\n\t\t\telse if (len < 0) {\n\t\t\t\tuwsgi_error(\"read()\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tsize_t remains = len;\n\t\t\twhile (remains > 0) {\n\t\t\t\tint ret = uwsgi_waitfd_write(dst, timeout);\n\t\t\t\tif (ret > 0) {\n\t\t\t\t\tlen = write(dst, buf, remains);\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tremains -= len;\n\t\t\t\t\t\twritten += len;\n\t\t\t\t\t}\n\t\t\t\t\telse if (len == 0) {\n\t\t\t\t\t\treturn written;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tuwsgi_error(\"write()\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ret == 0) {\n\t\t\t\t\tgoto timeout;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (ret == 0) {\n\t\t\tgoto timeout;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn written;\ntimeout:\n\tuwsgi_log(\"timeout while piping from %d to %d !!!\\n\", src, dst);\n\treturn -1;\n}\n\n\n// check if an fd is valid\nint uwsgi_valid_fd(int fd) {\n\tint ret = fcntl(fd, F_GETFL);\n\tif (ret == -1) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid uwsgi_close_all_fds(void) {\n\tint i;\n\tfor (i = 3; i < (int) uwsgi.max_fd; i++) {\n#ifdef __APPLE__\n        \tfcntl(i, F_SETFD, FD_CLOEXEC);\n#else\n                close(i);\n#endif\n\t}\n}\n\nint uwsgi_read_uh(int fd, struct uwsgi_header *uh, int timeout) {\n\tchar *ptr = (char *) uh;\n\tsize_t remains = 4;\n\twhile(remains > 0) {\n\t\tint ret = uwsgi_waitfd(fd, timeout);\n\t\tif (ret > 0) {\n\t\t\tssize_t len = read(fd, ptr, remains);\n\t\t\tif (len <= 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tremains -=len;\n\t\t\tptr +=len;\n\t\t\tcontinue;\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint uwsgi_read_nb(int fd, char *buf, size_t remains, int timeout) {\n\tchar *ptr = buf;\n        while(remains > 0) {\n                int ret = uwsgi_waitfd(fd, timeout);\n                if (ret > 0) {\n                        ssize_t len = read(fd, ptr, remains);\n                        if (len <= 0) {\n                                return -1;\n                        }\n                        remains -=len;\n                        ptr +=len;\n                        continue;\n                }\n                return -1;\n        }\n\n        return 0;\n}\n\n/*\n        this is like uwsgi_read_nb() but with fast initial read and hooked wait (use it in request plugin)\n*/\nssize_t uwsgi_read_true_nb(int fd, char *buf, size_t len, int timeout) {\n        int ret;\n\n\terrno = 0;\n\tssize_t rlen = read(fd, buf, len);\n        if (rlen > 0) {\n\t\treturn rlen;\t\n\t}\n        if (rlen == 0) return -1;\n        if (rlen < 0) {\n        \tif (uwsgi_is_again()) goto wait;\n        }\n        return -1;\nwait:\n\terrno = 0;\n        ret = uwsgi.wait_read_hook(fd, timeout);\n        if (ret > 0) {\n\t\terrno = 0;\n        \trlen = read(fd, buf, len);\n                if (rlen > 0) {\n\t\t\treturn rlen;\n                }\n\t\treturn -1;\n\t}\n        return ret;\n}\n\n\n/*\n\tlike the previous one but consume the whole len (if possibile)\n*/\n\nint uwsgi_read_whole_true_nb(int fd, char *buf, size_t remains, int timeout) {\n\tchar *ptr = buf;\n\twhile(remains > 0) {\n\t\tssize_t len = uwsgi_read_true_nb(fd, ptr, remains, timeout);\n\t\tif (len <= 0) return -1;\n\t\tptr += len;\n\t\tremains -= len;\n\t}\n\treturn 0;\n}\n\n/*\n\tthis is a pretty magic function used for reading a full uwsgi response\n\tit is true non blocking, so you can use it in request plugins\n\tbuffer is expected to be at least 4 bytes, rlen is a get/set value\n*/\n\nint uwsgi_read_with_realloc(int fd, char **buffer, size_t *rlen, int timeout, uint8_t *modifier1, uint8_t *modifier2) {\n\tif (*rlen < 4) return -1;\n\tchar *buf = *buffer;\n\tint ret;\n\n\t// start reading the header\n\tchar *ptr = buf;\n\tsize_t remains = 4;\n\twhile(remains > 0) {\n\t\tssize_t len = read(fd, ptr, remains);\n                if (len > 0) goto readok;\n                if (len == 0) return -1;\n                if (len < 0) {\n                        if (uwsgi_is_again()) goto wait;\n                        return -1;\n                }\nwait:\n                ret = uwsgi.wait_read_hook(fd, timeout);\n                if (ret > 0) {\n                        len = read(fd, ptr, remains);\n                        if (len > 0) goto readok;\n                }\n                return -1;\nreadok:\n                ptr += len;\n                remains -= len;\n                continue;\n        }\n\n\tstruct uwsgi_header *uh = (struct uwsgi_header *) buf;\n\tuint16_t pktsize = uh->pktsize;\n\tif (modifier1)\n\t\t*modifier1 = uh->modifier1;\n\tif (modifier2)\n\t\t*modifier2 = uh->modifier2;\n\t\n\tif (pktsize > *rlen) {\n\t\tchar *tmp_buf = realloc(buf, pktsize);\n\t\tif (!tmp_buf) {\n\t\t\tuwsgi_error(\"uwsgi_read_with_realloc()/realloc()\");\n\t\t\treturn -1;\n\t\t}\n\t\t*buffer = tmp_buf;\n\t\tbuf = *buffer;\n\t}\n\n\t*rlen = pktsize;\n\t// read the body\n\tremains = pktsize;\n\tptr = buf;\n\twhile(remains > 0) {\n                ssize_t len = read(fd, ptr, remains);\n                if (len > 0) goto readok2;\n                if (len == 0) return -1;\n                if (len < 0) {\n                        if (uwsgi_is_again()) goto wait2;\n                        return -1;\n                }\nwait2:\n                ret = uwsgi.wait_read_hook(fd, timeout);\n                if (ret > 0) {\n                        len = read(fd, ptr, remains);\n                        if (len > 0) goto readok2;\n                }\n                return -1;\nreadok2:\n                ptr += len;\n                remains -= len;\n                continue;\n        }\n\n\treturn 0;\n\t\n}\n\n/*\n\n\tthis is a commodity (big) function to send a buffer and wsgi_req body to a socket\n\tand to receive back data (and send them to the client)\n\n*/\n\nint uwsgi_proxy_nb(struct wsgi_request *wsgi_req, char *addr, struct uwsgi_buffer *ub, size_t remains, int timeout) {\n\n\tstruct uwsgi_buffer *headers = NULL;\n\n\tif (!ub) {\n\t\treturn -1;\n\t}\n\n\tint fd = uwsgi_connect(addr, 0, 1);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\tint ret = uwsgi.wait_write_hook(fd, timeout);\n\tif (ret <= 0) {\n\t\tgoto end;\n\t}\n\n\t// send the request (+ remaining data)\n\tif (uwsgi_write_true_nb(fd, ub->buf, ub->pos, timeout)) {\n\t\tgoto end;\n\t}\n\n\t// send the body\n\twhile(remains > 0) {\n\t\tssize_t rlen = 0;\n\t\tchar *buf = uwsgi_request_body_read(wsgi_req, 8192, &rlen);\n\t\tif (!buf) {\n\t\t\tgoto end;\n\t\t}\n\t\tif (buf == uwsgi.empty) break;\n\t\t// write data to the node\n\t\tif (uwsgi_write_true_nb(fd, buf, rlen, timeout)) {\n\t\t\tgoto end;\n\t\t}\n\t\tremains -= rlen;\n\t}\n\n\t// read the response\n\theaders = uwsgi_buffer_new(8192);\n\t// max 64k headers\n\tub->limit = UMAX16;\n\tfor(;;) {\n\t\tchar buf[8192];\n\t\tssize_t rlen = uwsgi_read_true_nb(fd, buf, 8192, timeout);\n\t\tif (rlen > 0) {\n\t\t\tif (headers) {\n\t\t\t\tif (uwsgi_buffer_append(headers, buf, rlen)) {\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// check if we have a full HTTP response\n\t\t\t\tif (uwsgi_is_full_http(headers)) {\n\t\t\t\t\tint ret = uwsgi_blob_to_response(wsgi_req, headers->buf, headers->pos);\t\n\t\t\t\t\tif (ret) continue;\n\t\t\t\t\tuwsgi_buffer_destroy(headers);\n\t\t\t\t\theaders = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (uwsgi_response_write_body_do(wsgi_req, buf, rlen)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (headers) uwsgi_buffer_destroy(headers);\n\n\tclose(fd);\n\treturn 0;\nend:\n\tif (headers) uwsgi_buffer_destroy(headers);\n\tclose(fd);\n\treturn -1;\n}\n\nvoid uwsgi_file_write_do(struct uwsgi_string_list *usl) {\n\n\tstruct uwsgi_string_list *fl = usl;\n\twhile(fl) {\n\t\tchar *equal = strchr(fl->value, '=');\n\t\tif (equal) {\n\t\t\t*equal = 0;\n\t\t\tFILE *f = fopen(fl->value, \"w\");\n\t\t\tif (!f) {\n\t\t\t\tuwsgi_error_open(\"uwsgi_file_write_do()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tuwsgi_log(\"writing \\\"%s\\\" to \\\"%s\\\" ...\\n\", equal+1, fl->value);\n\t\t\tif (fprintf(f, \"%s\\n\", equal+1) <= 0 || ferror(f) || fclose(f)) {\n\t\t\t\tuwsgi_error(\"uwsgi_file_write_do()\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tuwsgi_log(\"unable to write empty value for \\\"%s\\\"\\n\", fl->value);\n\t\t\texit(1);\n\t\t}\n\t\t*equal = '=';\t\n\t\tfl = fl->next;\n\t}\n}\n\nint uwsgi_fd_is_safe(int fd) {\n\tint i;\n\tfor(i=0;i<uwsgi.safe_fds_cnt;i++) {\n\t\tif (uwsgi.safe_fds[i] == fd) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid uwsgi_add_safe_fd(int fd) {\n\t// check if the fd is already safe\n\tif (uwsgi_fd_is_safe(fd)) return;\n\n\tsize_t len = sizeof(int) * (uwsgi.safe_fds_cnt+1);\n\tint *tmp = realloc(uwsgi.safe_fds, len);\n\tif (!tmp) {\n\t\tuwsgi_error(\"uwsgi_add_safe_fd()/realloc()\");\n\t\texit(1);\n\t}\n\tuwsgi.safe_fds = tmp;\t\n\tuwsgi.safe_fds[uwsgi.safe_fds_cnt] = fd;\t\n\tuwsgi.safe_fds_cnt++;\n}\n\nint uwsgi_is_again() {\n\tif (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINPROGRESS) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid uwsgi_disconnect(struct wsgi_request *wsgi_req) {\n\tif (wsgi_req->socket) {\n                wsgi_req->socket->proto_close(wsgi_req);\n        }\n        wsgi_req->fd_closed = 1;\n}\n\nint uwsgi_ready_fd(struct wsgi_request *wsgi_req) {\n\tif (wsgi_req->async_ready_fd) return wsgi_req->async_last_ready_fd;\n\treturn -1;\n}\n\nvoid uwsgi_setup_schemes() {\n\tuwsgi_register_scheme(\"emperor\", uwsgi_scheme_emperor);\t\n\tuwsgi_register_scheme(\"http\", uwsgi_scheme_http);\t\n\tuwsgi_register_scheme(\"data\", uwsgi_scheme_data);\t\n\tuwsgi_register_scheme(\"sym\", uwsgi_scheme_sym);\t\n\tuwsgi_register_scheme(\"section\", uwsgi_scheme_section);\t\n\tuwsgi_register_scheme(\"fd\", uwsgi_scheme_fd);\t\n\tuwsgi_register_scheme(\"exec\", uwsgi_scheme_exec);\t\n\tuwsgi_register_scheme(\"call\", uwsgi_scheme_call);\t\n\tuwsgi_register_scheme(\"callint\", uwsgi_scheme_callint);\t\n}\n\nstruct uwsgi_string_list *uwsgi_check_scheme(char *file) {\n\tstruct uwsgi_string_list *usl;\n\tuwsgi_foreach(usl, uwsgi.schemes) {\n\t\tchar *url = uwsgi_concat2(usl->value, \"://\");\n\t\tint ret = uwsgi_startswith(file, url, strlen(url));\n\t\tfree(url);\n\t\tif (!ret) return usl;\n\t}\n\treturn NULL;\n}\n\nvoid uwsgi_remap_fd(int fd, char *filename) {\n\n\tint fdin = open(filename, O_RDWR);\n        if (fdin < 0) {\n                uwsgi_error_open(filename);\n                exit(1);\n        }\n\n        /* stdin */\n        if (fdin != fd) {\n                if (dup2(fdin, fd) < 0) {\n                        uwsgi_error(\"uwsgi_remap_fd()/dup2()\");\n                        exit(1);\n                }\n                close(fdin);\n        }\n}\n\nint uwsgi_is_connected(int fd) {\n\tint soopt;\n        socklen_t solen = sizeof(int);\n\n        if (getsockopt(fd, SOL_SOCKET, SO_ERROR, (void *) (&soopt), &solen) < 0) {\n\t\treturn 0;\n        }\n        /* is something bad ? */\n        if (soopt) return 0;\n\treturn 1;\n}\n\n\nint uwsgi_pass_cred(int fd, char *code, size_t code_len) {\n#ifdef SCM_CREDENTIALS\n\tstruct msghdr cr_msg;\n        struct cmsghdr *cmsg;\n        struct iovec cr_iov;\n        void *cr_msg_control = uwsgi_calloc(CMSG_SPACE(sizeof(struct ucred)));\n\n        cr_iov.iov_base = code;\n        cr_iov.iov_len = code_len;\n\n        cr_msg.msg_name = NULL;\n        cr_msg.msg_namelen = 0;\n\n        cr_msg.msg_iov = &cr_iov;\n        cr_msg.msg_iovlen = 1;\n\n        cr_msg.msg_flags = 0;\n        cr_msg.msg_control = cr_msg_control;\n        cr_msg.msg_controllen = CMSG_SPACE(sizeof(struct ucred));\n\n        cmsg = CMSG_FIRSTHDR(&cr_msg);\n        cmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));\n        cmsg->cmsg_level = SOL_SOCKET;\n        cmsg->cmsg_type = SCM_CREDENTIALS;\n\n        struct ucred *u = (struct ucred*) CMSG_DATA(cmsg);\n\tu->pid = getpid();\t\n\tu->uid = getuid();\t\n\tu->gid = getgid();\t\n\n        if (sendmsg(fd, &cr_msg, 0) < 0) {\n                uwsgi_error(\"uwsgi_pass_cred()/sendmsg()\");\n        \tfree(cr_msg_control);\n\t\treturn -1;\n        }\n\n        free(cr_msg_control);\n\treturn 0;\n#else\n\treturn -1;\n#endif\n}\n\nint uwsgi_pass_cred2(int fd, char *code, size_t code_len, struct sockaddr *addr, size_t addr_len) {\n#ifdef SCM_CREDENTIALS\n        struct msghdr cr_msg;\n        struct cmsghdr *cmsg;\n        struct iovec cr_iov;\n        void *cr_msg_control = uwsgi_calloc(CMSG_SPACE(sizeof(struct ucred)));\n\n        cr_iov.iov_base = code;\n        cr_iov.iov_len = code_len;\n\n        cr_msg.msg_name = addr;\n        cr_msg.msg_namelen = addr_len;\n\n        cr_msg.msg_iov = &cr_iov;\n        cr_msg.msg_iovlen = 1;\n\n        cr_msg.msg_flags = 0;\n        cr_msg.msg_control = cr_msg_control;\n        cr_msg.msg_controllen = CMSG_SPACE(sizeof(struct ucred));\n\n        cmsg = CMSG_FIRSTHDR(&cr_msg);\n        cmsg->cmsg_len = CMSG_LEN(sizeof(struct ucred));\n        cmsg->cmsg_level = SOL_SOCKET;\n        cmsg->cmsg_type = SCM_CREDENTIALS;\n\n        struct ucred *u = (struct ucred*) CMSG_DATA(cmsg);\n        u->pid = getpid();\n        u->uid = getuid();\n        u->gid = getgid();\n\n        if (sendmsg(fd, &cr_msg, 0) < 0) {\n                uwsgi_error(\"uwsgi_pass_cred2()/sendmsg()\");\n                free(cr_msg_control);\n                return -1;\n        }\n\n        free(cr_msg_control);\n        return 0;\n#else\n        return -1;\n#endif\n}\n\n\nint uwsgi_recv_cred(int fd, char *code, size_t code_len, pid_t *pid, uid_t *uid, gid_t *gid) {\n#ifdef SCM_CREDENTIALS\n        struct iovec iov;\n\tint ret = -1;\n\n        void *msg_control = uwsgi_calloc(CMSG_SPACE(sizeof(struct ucred)));\n\n        iov.iov_base = uwsgi_malloc(code_len);\n        iov.iov_len = code_len;\n\n\tstruct msghdr msg;\n        memset(&msg, 0, sizeof(msg));\n\n        msg.msg_name = NULL;\n        msg.msg_namelen = 0;\n\n        msg.msg_iov = &iov;\n        msg.msg_iovlen = 1;\n\n        msg.msg_control = msg_control;\n        msg.msg_controllen = CMSG_SPACE(sizeof(struct ucred));\n\n        ssize_t len = recvmsg(fd, &msg, 0);\n\tif (len <= 0) {\n\t\tuwsgi_error(\"uwsgi_recv_cred()/recvmsg()\");\n\t\tgoto clear;\n\t}\n\n\tstruct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);\n\tif (!cmsg) goto clear;\n\n\tif (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\tgoto clear;\n        }\n\n\tif (uwsgi_strncmp(code, code_len, iov.iov_base, iov.iov_len)) goto clear;\n\n\tstruct ucred *u = (struct ucred *) CMSG_DATA(cmsg);\n\t*pid = u->pid;\n\t*uid = u->uid;\n\t*gid = u->gid;\n\tret = 0;\n\nclear:\n\tfree(msg_control);\n\tfree(iov.iov_base);\n\treturn ret;\n#else\n\treturn -1;\n#endif\n}\n\nssize_t uwsgi_recv_cred2(int fd, char *buf, size_t buf_len, pid_t *pid, uid_t *uid, gid_t *gid) {\n#ifdef SCM_CREDENTIALS\n        struct iovec iov;\n        ssize_t ret = -1;\n\n        void *msg_control = uwsgi_calloc(CMSG_SPACE(sizeof(struct ucred)));\n\n        iov.iov_base = buf;\n        iov.iov_len = buf_len;\n\n        struct msghdr msg;\n        memset(&msg, 0, sizeof(msg));\n\n        msg.msg_name = NULL;\n        msg.msg_namelen = 0;\n\n        msg.msg_iov = &iov;\n        msg.msg_iovlen = 1;\n\n        msg.msg_control = msg_control;\n        msg.msg_controllen = CMSG_SPACE(sizeof(struct ucred));\n\n        ssize_t len = recvmsg(fd, &msg, 0);\n        if (len <= 0) {\n                uwsgi_error(\"uwsgi_recv_cred2()/recvmsg()\");\n                goto clear;\n        }\n\n        struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);\n        if (!cmsg) goto clear;\n\n        if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_CREDENTIALS) {\n                goto clear;\n        }\n\n        struct ucred *u = (struct ucred *) CMSG_DATA(cmsg);\n        *pid = u->pid;\n        *uid = u->uid;\n        *gid = u->gid;\n        ret = len;\n\nclear:\n        free(msg_control);\n        return ret;\n#else\n        return -1;\n#endif\n}\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-uwsgi-2.0.18-3zqyfmll5bnf4z4dwb3laqcto4pt6b3l/spack-src/logo_uWSGI.png"
    ],
    "total_files": 648
}