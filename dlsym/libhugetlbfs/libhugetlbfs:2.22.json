{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libhugetlbfs-2.22-luoey73t25td54drf3kkevrsi2q6jzpq/spack-src/shm.c": "/*\n * libhugetlbfs - Easy use of Linux hugepages\n * Copyright (C) 2005-2006 David Gibson & Adam Litke, IBM Corporation.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <sys/types.h>\n#include \"libhugetlbfs_internal.h\"\n#include \"hugetlbfs.h\"\n#include <sys/syscall.h>\n\n#if defined(SYS_shmget) || defined(SYS_ipc)\n#define HAVE_SHMGET_SYSCALL\n#endif\n\n#ifdef HAVE_SHMGET_SYSCALL\n/*\n * The calls to dlsym() and dlerror() in the shmget() wrapper below force\n * a dependency on libdl.so.  This does not work for static executables\n * as the glibc dynamic library implementation does not automatically\n * have static dl* function stubs linked into static executables.\n *\n * Work around this problem by adding a weak attribute to the declarations\n * of dlsym() and dlerror().  (The declaration is otherwise the same as in\n * <dlfcn.h>).  This allows a static executable to be linked without -ldl.\n * If &dlsym is NULL then this is a static executable and a call to the\n * system shmget() may be performed without worry as there is no dynamic\n * call chain.\n */\nextern void *dlsym (void *__restrict __handle, __const char *__restrict __name)\n\t\t__attribute__((weak)) __THROW __nonnull ((2));\nextern char *dlerror (void) __attribute__((weak)) __THROW;\n\n\n/* call syscall shmget through the generic syscall mechanism */\nstatic int syscall_shmget(key_t key, size_t size, int shmflg)\n{\n#ifdef SYS_shmget\n\treturn syscall(SYS_shmget, key, size, shmflg);\n#else\n\t/*\n\t * Some platforms do not have have a direct shmget syscall.  Instead,\n\t * all SysV IPC calls are funneled through the ipc() system call.\n\t *\n\t * ipc() is expected to only be used by libc implementors, so using\n\t * it has not been smoothed out.  There is no function declaration.\n\t * The needed define for SHMGET is in linux/ipc.h, but that file\n\t * also includes a conflicting definition of ipc_perm.  So,\n\t * just define the needed items here.\n\t *\n\t * When compiling -m32 on x86_64, the ipc glibc wrapper does not\n\t * exist.  Instead, just use SYS_ipc.\n\t *\n\t * The ipc system call below does not set the IPC_64 version flag\n\t * with SHMGET because that would have required more private defines\n\t * and the version number is not used for the SHMGET call.\n\t */\n\t#define SHMGET 23\n\n\treturn syscall(SYS_ipc, SHMGET, key, size, shmflg, (void *)NULL, 0L);\n#endif\n}\n\n#endif /* HAVE_SHMGET_SYSCALL */\n\nint shmget(key_t key, size_t size, int shmflg)\n{\n\tstatic int (*real_shmget)(key_t key, size_t size, int shmflg) = NULL;\n\tchar *error;\n\tint retval;\n\tsize_t aligned_size = size;\n\n\tDEBUG(\"hugetlb_shmem: entering overridden shmget() call\\n\");\n\n\t/* Get a handle to the \"real\" shmget system call */\n\tif (!real_shmget) {\n#ifdef HAVE_SHMGET_SYSCALL\n\t\tif (&dlsym == NULL) {\n\t\t\t/* in a static executable, call shmget directly */\n\t\t\treal_shmget = syscall_shmget;\n\t\t} else\n#endif /* HAVE_SHMGET_SYSCALL */\n\t\t{\n\t\t\treal_shmget = dlsym(RTLD_NEXT, \"shmget\");\n\t\t\tif ((error = dlerror()) != NULL) {\n\t\t\t\tERROR(\"%s\", error);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Align the size and set SHM_HUGETLB on request */\n\tif (__hugetlb_opts.shm_enabled) {\n\t\t/*\n\t\t * Use /proc/meminfo because shm always uses the system\n\t\t * default huge page size.\n\t\t */\n\t\tlong hpage_size = kernel_default_hugepage_size();\n\t\taligned_size = ALIGN(size, hpage_size);\n\t\tif (size != aligned_size) {\n\t\t\tDEBUG(\"hugetlb_shmem: size growth align %zd -> %zd\\n\",\n\t\t\t\tsize, aligned_size);\n\t\t}\n\n\t\tINFO(\"hugetlb_shmem: Adding SHM_HUGETLB flag\\n\");\n\t\tshmflg |= SHM_HUGETLB;\n\t} else {\n\t\tDEBUG(\"hugetlb_shmem: shmget override not requested\\n\");\n\t}\n\n\t/* Call the \"real\" shmget. If hugepages fail, use small pages */\n\tretval = real_shmget(key, aligned_size, shmflg);\n\tif (retval == -1 && __hugetlb_opts.shm_enabled) {\n\t\tWARNING(\"While overriding shmget(%zd) to add SHM_HUGETLB: %s\\n\",\n\t\t\taligned_size, strerror(errno));\n\t\tshmflg &= ~SHM_HUGETLB;\n\t\tretval = real_shmget(key, size, shmflg);\n\t\tWARNING(\"Using small pages for shmget despite HUGETLB_SHM\\n\");\n\t}\n\n\treturn retval;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libhugetlbfs-2.22-luoey73t25td54drf3kkevrsi2q6jzpq/spack-src/tests/empty_mounts.c": "/*\n * libhugetlbfs - Easy use of Linux hugepages\n * Copyright (C) 2005-2006 David Gibson & Adam Litke, IBM Corporation.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <dlfcn.h>\n#include <stdarg.h>\n\n#include <hugetlbfs.h>\n\n#include \"hugetests.h\"\n\n/* We override the normal open, so libhugetlbfs gets an apparently\n * empty /proc/mounts or /etc/mtab */\nint open(const char *path, int flags, ...)\n{\n\tint (*old_open)(const char *, int, ...);\n\tint fd;\n\n\tif ((strcmp(path, \"/proc/mounts\") == 0)\n\t    || (strcmp(path, \"/etc/mtab\") == 0))\n\t\tpath = \"/dev/null\";\n\n\told_open = dlsym(RTLD_NEXT, \"open\");\n\tif (flags & O_CREAT) {\n\t\tva_list ap;\n\n\t\tva_start(ap, flags);\n\t\tfd = (*old_open)(path, flags, va_arg(ap, mode_t));\n\t\tva_end(ap);\n\t\treturn fd;\n\t} else {\n\t\treturn (*old_open)(path, flags);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tint fd;\n\n\ttest_init(argc, argv);\n\n\tfd = hugetlbfs_unlinked_fd();\n\tif (fd < 0)\n\t\tPASS();\n\n\tFAIL(\"Mysteriously found a mount\");\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libhugetlbfs-2.22-luoey73t25td54drf3kkevrsi2q6jzpq/spack-src/tests/large_mounts.c": "/*\n * libhugetlbfs - Easy use of Linux hugepages\n * Copyright (C) 2008 Eric Munson, IBM Corporation.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#define _GNU_SOURCE\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <dlfcn.h>\n#include <stdarg.h>\n#include <errno.h>\n\n#include <hugetlbfs.h>\n\n#include \"hugetests.h\"\n\n#define BUF_SIZE 4096\n#define FILLER \"tmpfs /var/run tmpfs rw,nosuid,nodev,noexec,mode=755 0 0\\n\"\n\nint in_test; /* = 0; */\nint tmp_mounts_fd; /* = 0; */\nFILE *tmp_stream; /* = NULL; */\n\n/*\n * We override the normal open, so we can remember the fd for the\n * mounts file\n */\nint open(const char *path, int flags, ...)\n{\n\tint (*old_open)(const char *, int, ...);\n\tint fd;\n\tva_list ap;\n\n\told_open = dlsym(RTLD_NEXT, \"open\");\n\tif (in_test && strcmp(path, \"/proc/mounts\") == 0)\n\t\treturn tmp_mounts_fd;\n\tva_start(ap, flags);\n\tfd = (old_open)(path, flags, va_arg(ap, mode_t));\n\tva_end(ap);\n\treturn fd;\n}\n\nvoid make_test_mounts()\n{\n\tchar buf[BUF_SIZE];\n\tint mounts_fd;\n\tunsigned int written = 0;\n\tint ret;\n\tint filler_sz;\n\n\tmounts_fd = open(\"/proc/mounts\", O_RDONLY);\n\tif (mounts_fd < 0)\n\t\tFAIL(\"Unable to open /proc/mounts: %s\", strerror(errno));\n\ttmp_stream = tmpfile();\n\tif (!tmp_stream)\n\t\tFAIL(\"Unable to open temporary mounts file: %s\", strerror(errno));\n\n\ttmp_mounts_fd = fileno(tmp_stream);\n\tif (tmp_mounts_fd < 0)\n\t\tFAIL(\"Unable to get file descriptor from stream.\");\n\n\tfiller_sz = strlen(FILLER);\n\n\twhile (written < BUF_SIZE) {\n\t\tif (write(tmp_mounts_fd, FILLER, filler_sz) < 0)\n\t\t\tFAIL(\"Unable to write to temp mounts file: %s\",\n\t\t\t\tstrerror(errno));\n\t\twritten += filler_sz;\n\t}\n\n\twhile ((ret = read(mounts_fd, buf, BUF_SIZE)) > 0)\n\t\tif (write(tmp_mounts_fd, buf, ret) < 0)\n\t\t\tFAIL(\"Unable to write to temp mounts file: %s\",\n\t\t\t\tstrerror(errno));\n\n\tclose(mounts_fd);\n\tif (lseek(tmp_mounts_fd, 0, SEEK_SET) < 0)\n\t\tFAIL(\"Unable to move temp mounts stream to beginning of file: %s\",\n\t\t\tstrerror(errno));\n}\n\nint main(int argc, char *argv[])\n{\n\tint fd;\n\n\tmake_test_mounts();\n\ttest_init(argc, argv);\n\tin_test = 1;\n\n\tfd = hugetlbfs_unlinked_fd();\n\n\tfclose(tmp_stream);\n\tif (fd < 0)\n\t\tFAIL(\"Unable to find mount point\\n\");\n\n\tPASS();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libhugetlbfs-2.22-luoey73t25td54drf3kkevrsi2q6jzpq/spack-src/tests/gethugepagesizes.c": "/*\n * libhugetlbfs - Easy use of Linux hugepages\n * Copyright (C) 2008 Adam Litke, IBM Corporation.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <dlfcn.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <hugetlbfs.h>\n\n#include \"hugetests.h\"\n\nint faked_data = 0;\nchar fake_sysfs[] = \"/tmp/sysfs-XXXXXX\";\nchar fake_meminfo[] = \"/tmp/meminfo-XXXXXX\";\n\n#define REAL_SYSFS_DIR\t\"/sys/kernel/mm/hugepages/\"\nDIR *(*real_opendir)(const char *name);\n\nint (*real_open)(const char *name, int flags, int mode);\n\nenum {\n\tOVERRIDE_OFF,\t\t/* Pass-through to real function */\n\tOVERRIDE_ON,\t\t/* Ovewrride with local function */\n\tOVERRIDE_MISSING,\t/* Emulate missing support */\n};\nint meminfo_state = OVERRIDE_OFF;\nint sysfs_state = OVERRIDE_OFF;\n\n/*\n * Override opendir so we'll open the fake sysfs dir if intended\n */\nDIR *opendir(const char *name)\n{\n\tif (!real_opendir)\n\t\treal_opendir = dlsym(RTLD_NEXT, \"opendir\");\n\n\t/* Only override calls to the sysfs dir */\n\tif (strcmp(name, REAL_SYSFS_DIR))\n\t\treturn real_opendir(name);\n\n\tswitch (sysfs_state) {\n\tcase OVERRIDE_OFF:\n\t\treturn real_opendir(name);\n\tcase OVERRIDE_ON:\n\t\t/* Only safe to override of fake_sysfs was set up */\n\t\tif (faked_data)\n\t\t\treturn real_opendir(fake_sysfs);\n\t\telse\n\t\t\tFAIL(\"Trying to override opendir before initializing \"\n\t\t\t\t\"fake_sysfs directory\\n\");\n\tdefault:\n\t\terrno = ENOENT;\n\t\treturn NULL;\n\t}\n}\n\n#define HPAGE_KB 2048\n#define __HPAGE_STR_QUOTE(val) #val\n#define __HPAGE_STR(val) __HPAGE_STR_QUOTE(val)\n#define HPAGE_STR __HPAGE_STR(HPAGE_KB)\n\n/*\n * Override open to simulate various contents for meminfo\n */\nint open(const char *file, int flags, ...)\n{\n\tint mode = 0;\n\tif (flags & O_CREAT) {\n\t\tva_list arg;\n\t\tva_start(arg, flags);\n\t\tmode = va_arg(arg, int);\n\t\tva_end(arg);\n\t}\n\n\tif (!real_open)\n\t\treal_open = dlsym(RTLD_NEXT, \"open\");\n\n\tswitch (meminfo_state) {\n\t\tcase OVERRIDE_OFF:\n\t\t\tbreak;\n\t\tcase OVERRIDE_ON: {\n\t\t\tchar fname[PATH_MAX];\n\t\t\tsprintf(fname, \"%s/meminfo-hugepages\", fake_meminfo);\n\t\t\tfile = fname;\n\t\t\tbreak;\n\t\t}\n\t\tcase OVERRIDE_MISSING: {\n\t\t\tchar fname[PATH_MAX];\n\t\t\tsprintf(fname, \"%s/meminfo-none\", fake_meminfo);\n\t\t\tfile = fname;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\treturn real_open(file, flags, mode);\n}\n\nvoid cleanup_fake_data(void)\n{\n\tDIR *dir;\n\tstruct dirent *ent;\n\tchar fname[PATH_MAX+1];\n\n\tmeminfo_state = OVERRIDE_OFF;\n\tsysfs_state = OVERRIDE_OFF;\n\n\tfaked_data = 0;\n\tdir = opendir(fake_sysfs);\n\tif (!dir)\n\t\tFAIL(\"opendir %s: %s\", fake_sysfs, strerror(errno));\n\n\twhile ((ent = readdir(dir))) {\n\t\tif (strncmp(ent->d_name, \"hugepages-\", 10))\n\t\t\tcontinue;\n\t\tsnprintf(fname, PATH_MAX, \"%s/%s\", fake_sysfs,\n\t\t\tent->d_name);\n\t\tif (rmdir(fname))\n\t\t\tFAIL(\"rmdir %s: %s\", fake_sysfs, strerror(errno));\n\t}\n\tclosedir(dir);\n\tif (rmdir(fake_sysfs))\n\t\tFAIL(\"rmdir %s: %s\", fake_sysfs, strerror(errno));\n\n\tsprintf(fname, \"%s/meminfo-none\", fake_meminfo);\n\tif (unlink(fname) < 0)\n\t\tFAIL(\"unlink %s: %s\", fname, strerror(errno));\n\tsprintf(fname, \"%s/meminfo-hugepages\", fake_meminfo);\n\tif (unlink(fname) < 0)\n\t\tFAIL(\"unlink %s: %s\", fname, strerror(errno));\n\tif (rmdir(fake_meminfo))\n\t\tFAIL(\"rmdir %s: %s\", fake_meminfo, strerror(errno));\n}\n\nchar *meminfo_base = \"\\\nMemTotal:      4004132 kB\\n\\\nMemFree:       3563748 kB\\n\\\nBuffers:         34804 kB\\n\\\nCached:         252544 kB\\n\\\nSwapCached:          0 kB\\n\\\nActive:         108912 kB\\n\\\nInactive:       187420 kB\\n\\\nSwapTotal:     8008392 kB\\n\\\nSwapFree:      8008392 kB\\n\\\nDirty:               4 kB\\n\\\nWriteback:           0 kB\\n\\\nAnonPages:        9100 kB\\n\\\nMapped:           7908 kB\\n\\\nSlab:            40212 kB\\n\\\nSReclaimable:    33312 kB\\n\\\nSUnreclaim:       6900 kB\\n\\\nPageTables:       1016 kB\\n\\\nNFS_Unstable:        0 kB\\n\\\nBounce:              0 kB\\n\\\nWritebackTmp:        0 kB\\n\\\nCommitLimit:   9974616 kB\\n\\\nCommitted_AS:    29616 kB\\n\\\nVmallocTotal: 34359738367 kB\\n\\\nVmallocUsed:     23760 kB\\n\\\nVmallocChunk: 34359714543 kB\\n\\\n\";\n\nchar *meminfo_huge = \"\\\nHugePages_Total:    35\\n\\\nHugePages_Free:     35\\n\\\nHugePages_Rsvd:      0\\n\\\nHugePages_Surp:      0\\n\\\nHugepagesize:     \" HPAGE_STR \" kB\\n\\\n\";\n\nvoid setup_fake_data(long sizes[], int n_elem)\n{\n\tint old_meminfo_state = meminfo_state;\n\tint old_sysfs_state = sysfs_state;\n\n\tint i;\n\tchar fname[PATH_MAX+1];\n\tint fd;\n\n\tmeminfo_state = OVERRIDE_OFF;\n\tsysfs_state = OVERRIDE_OFF;\n\n\tif (faked_data)\n\t\tcleanup_fake_data();\n\n\t/* Generate some fake sysfs data. */\n\tif (!mkdtemp(fake_sysfs))\n\t\tFAIL(\"mkdtemp: %s\", strerror(errno));\n\tfaked_data = 1;\n\n\tfor (i = 0; i < n_elem; i++) {\n\t\tsnprintf(fname, PATH_MAX, \"%s/hugepages-%lukB\", fake_sysfs,\n\t\t\t\tsizes[i] / 1024);\n\t\tif (mkdir(fname, 0700))\n\t\t\tFAIL(\"mkdir %s: %s\", fname, strerror(errno));\n\t}\n\n\t/* Generate fake meminfo data. */\n\tif (!mkdtemp(fake_meminfo))\n\t\tFAIL(\"mkdtemp: %s\", strerror(errno));\n\n\tsprintf(fname, \"%s/meminfo-none\", fake_meminfo);\n\tfd = open(fname, O_WRONLY|O_CREAT);\n\tif (fd < 0)\n\t\tFAIL(\"open: %s\", strerror(errno));\n\tif (write(fd, meminfo_base,\n\t\t\tstrlen(meminfo_base)) != strlen(meminfo_base))\n\t\tFAIL(\"write: %s\", strerror(errno));\n\tif (close(fd) < 0)\n\t\tFAIL(\"close: %s\", strerror(errno));\n\n\tsprintf(fname, \"%s/meminfo-hugepages\", fake_meminfo);\n\tfd = open(fname, O_WRONLY|O_CREAT);\n\tif (fd < 0)\n\t\tFAIL(\"open: %s\", strerror(errno));\n\tif (write(fd, meminfo_base,\n\t\t\tstrlen(meminfo_base)) != strlen(meminfo_base))\n\t\tFAIL(\"write: %s\", strerror(errno));\n\tif (write(fd, meminfo_huge,\n\t\t\tstrlen(meminfo_huge)) != strlen(meminfo_huge))\n\t\tFAIL(\"write: %s\", strerror(errno));\n\tif (close(fd) < 0)\n\t\tFAIL(\"close: %s\", strerror(errno));\n\n\tmeminfo_state = old_meminfo_state;\n\tsysfs_state = old_sysfs_state;\n}\n\nvoid cleanup(void)\n{\n\tif (faked_data)\n\t\tcleanup_fake_data();\n}\n\nvoid validate_sizes(int line, long actual_sizes[], int actual,\n\t\t    int max, int maxmax,\n\t\t    long expected_sizes[], int expected)\n{\n\tint i, j;\n\n\tverbose_printf(\"Line %d: Expecting sizes:\", line);\n\tfor (i = 0; i < expected; i++)\n\t\tverbose_printf(\" %ld\", expected_sizes[i]);\n\tverbose_printf(\"\\n\");\n\tverbose_printf(\"Line %d: Actual sizes are:\", line);\n\tfor (i = 0; i < actual; i++)\n\t\tverbose_printf(\" %ld\", actual_sizes[i]);\n\tverbose_printf(\"\\n\");\n\n\tif (((expected <= max) && (expected != actual))\n\t    || ((expected > max) && (actual < max)))\n\t\tFAIL(\"Line %i: Wrong number of sizes returned -- expected %i \"\n\t\t     \"got %i\", line, expected, actual);\n\telse if (actual > max)\n\t\tFAIL(\"Line %i: %i sizes returned > maximum %i\",\n\t\t     line, actual, max);\n\n\tfor (i = 0; i < actual; i++) {\n\t\tfor (j = 0; j < expected; j++)\n\t\t\tif (actual_sizes[i] == expected_sizes[j])\n\t\t\t\tbreak;\n\t\tif (j >= expected)\n\t\t\tFAIL(\"Line %i: Actual size %li not found in expected \"\n\t\t\t\t\"results\", line, expected_sizes[i]);\n\t}\n\n\tfor (i = 0; i < actual; i++)\n\t\tfor (j = i+1; j < actual; j++)\n\t\t\tif (actual_sizes[i] == actual_sizes[j])\n\t\t\t\tFAIL(\"Line %i: Duplicate size %li at %i/%i\",\n\t\t\t\t     line, actual_sizes[i], i, j);\n\n\tfor (i = actual; i < maxmax; i++)\n\t\tif (actual_sizes[i] != 42)\n\t\t\tFAIL(\"Line %i: Wrote past official limit at %i\",\n\t\t\t\tline, i);\n}\n\n#define MAX 16\n#define EXPECT_SIZES(func, max, count, expected)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tlong __a[MAX] = { [0 ... MAX-1] = 42 };\t\t\t\t\\\n\tint __na;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__na = func(__a, max);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tvalidate_sizes(__LINE__, __a, __na, max, MAX, expected, count);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__na;\t\t\t\t\t\t\t\t\\\n})\n\n#define INIT_LIST(a, values...)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tlong __e[] = { values };\t\t\t\t\t\\\n\tmemcpy(a, __e, sizeof(__e));\t\t\t\t\t\\\n})\n\nint main(int argc, char *argv[])\n{\n\tint i, fakes_no;\n\tlong expected_sizes[MAX], actual_sizes[MAX], fake_sizes[MAX];\n\tlong base_size = sysconf(_SC_PAGESIZE);\n\n\ttest_init(argc, argv);\n\n\t/*\n\t * ===\n\t * Argment error checking tests\n\t * ===\n\t */\n\tmeminfo_state = OVERRIDE_OFF;\n\tsysfs_state = OVERRIDE_OFF;\n\tkernel_default_hugepage_size_reset();\n\n\tif (gethugepagesizes(actual_sizes, -1) != -1 || errno != EINVAL)\n\t\tFAIL(\"Mishandled params (n_elem < 0)\");\n\tif (gethugepagesizes(NULL, 1) != -1 || errno != EINVAL)\n\t\tFAIL(\"Mishandled params (pagesizes == NULL, n_elem > 0)\");\n\n\tif (getpagesizes(actual_sizes, -1) != -1 || errno != EINVAL)\n\t\tFAIL(\"Mishandled params (n_elem < 0)\");\n\tif (getpagesizes(NULL, 1) != -1 || errno != EINVAL)\n\t\tFAIL(\"Mishandled params (pagesizes == NULL, n_elem > 0)\");\n\n\t/*\n\t * ===\n\t * Test some corner cases using a fake system configuration\n\t * ===\n\t */\n\n\tINIT_LIST(expected_sizes, HPAGE_KB * 1024, 1024 * 1024, 64 * 1024);\n\tfakes_no = 0;\n\tfor (i = 0; i < 3; i++)\n\t\t/* don't include base_size in 'fake' hugepagesizes */\n\t\tif (base_size != expected_sizes[i]) {\n\t\t\tfake_sizes[fakes_no] = expected_sizes[i];\n\t\t\tfakes_no++;\n\t\t}\n\tsetup_fake_data(fake_sizes, fakes_no);\n\n\t/*\n\t * Check handling when /proc/meminfo indicates no huge page support\n\t * and the sysfs heirachy is not present.\n\t */\n\tmeminfo_state = OVERRIDE_MISSING;\n\tsysfs_state = OVERRIDE_MISSING;\n\tkernel_default_hugepage_size_reset();\n\n\tEXPECT_SIZES(gethugepagesizes, MAX, 0, expected_sizes);\n\n\tINIT_LIST(expected_sizes, base_size);\n\tEXPECT_SIZES(getpagesizes, MAX, 1, expected_sizes);\n\n\t/* ... only the meminfo size is returned. */\n\tmeminfo_state = OVERRIDE_ON;\n\tkernel_default_hugepage_size_reset();\n\n\tINIT_LIST(expected_sizes, HPAGE_KB * 1024);\n\tEXPECT_SIZES(gethugepagesizes, MAX, 1, expected_sizes);\n\n\tINIT_LIST(expected_sizes, base_size, HPAGE_KB * 1024);\n\tEXPECT_SIZES(getpagesizes, MAX, 2, expected_sizes);\n\n\t/*\n\t * When sysfs defines additional sizes ...\n\t */\n\tsysfs_state = OVERRIDE_ON;\n\tkernel_default_hugepage_size_reset();\n\n\tmemcpy(expected_sizes, fake_sizes, sizeof(fake_sizes));\n\n\t/* ... make sure all sizes are returned without duplicates */\n\t/* ... while making sure we do not overstep our limit */\n\tEXPECT_SIZES(gethugepagesizes, MAX, fakes_no, expected_sizes);\n\tEXPECT_SIZES(gethugepagesizes, 1, fakes_no, expected_sizes);\n\tEXPECT_SIZES(gethugepagesizes, 2, fakes_no, expected_sizes);\n\tEXPECT_SIZES(gethugepagesizes, 3, fakes_no, expected_sizes);\n\tEXPECT_SIZES(gethugepagesizes, 4, fakes_no, expected_sizes);\n\n\tmemcpy(expected_sizes, fake_sizes, sizeof(fake_sizes));\n\texpected_sizes[fakes_no] = base_size;\n\tEXPECT_SIZES(getpagesizes, MAX, fakes_no + 1, expected_sizes);\n\tEXPECT_SIZES(getpagesizes, 1, fakes_no + 1, expected_sizes);\n\tEXPECT_SIZES(getpagesizes, 2, fakes_no + 1, expected_sizes);\n\tEXPECT_SIZES(getpagesizes, 3, fakes_no + 1, expected_sizes);\n\tEXPECT_SIZES(getpagesizes, 4, fakes_no + 1, expected_sizes);\n\tEXPECT_SIZES(getpagesizes, 5, fakes_no + 1, expected_sizes);\n\n\t/* ... we can check how many sizes are supported. */\n\tif (gethugepagesizes(NULL, 0) != fakes_no)\n\t\tFAIL(\"Unable to check the number of supported sizes\");\n\n\tif (getpagesizes(NULL, 0) != fakes_no + 1)\n\t\tFAIL(\"Unable to check the number of supported sizes\");\n\n\tPASS();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-libhugetlbfs-2.22-luoey73t25td54drf3kkevrsi2q6jzpq/spack-src/tests/meminfo_nohuge.c": "/*\n * libhugetlbfs - Easy use of Linux hugepages\n * Copyright (C) 2005-2006 David Gibson & Adam Litke, IBM Corporation.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <dlfcn.h>\n#include <stdarg.h>\n\n#include <hugetlbfs.h>\n\n#include \"hugetests.h\"\n\n/* We override the normal open, so libhugetlbfs gets a /proc/meminfo\n * which doesn't contain any hugepage information */\nint open(const char *path, int flags, ...)\n{\n\tint (*old_open)(const char *, int, ...);\n\tint fd;\n\n\tif (strcmp(path, \"/proc/meminfo\") == 0) {\n\t\tFILE *f;\n\n\t\tf = popen(\"/bin/grep -vi ^hugepage /proc/meminfo\", \"r\");\n\t\treturn fileno(f);\n\t}\n\n\tif (strcmp(path, \"/proc/mounts\") == 0) {\n\t\tFILE *f;\n\n\t\tf = popen(\"/bin/grep -vi hugetlbfs /proc/mounts\", \"r\");\n\t\treturn fileno(f);\n\t}\n\n\told_open = dlsym(RTLD_NEXT, \"open\");\n\tif (flags & O_CREAT) {\n\t\tva_list ap;\n\n\t\tva_start(ap, flags);\n\t\tfd = (*old_open)(path, flags, va_arg(ap, mode_t));\n\t\tva_end(ap);\n\t\treturn fd;\n\t} else {\n\t\treturn (*old_open)(path, flags);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tlong hpage_size;\n\n\ttest_init(argc, argv);\n\n\thpage_size = gethugepagesize();\n\tif (hpage_size == -1)\n\t\tPASS();\n\n\tFAIL(\"Mysteriously found a hugepage size of %ld\\n\", hpage_size);\n}\n"
    },
    "skipped": [],
    "total_files": 148
}