{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Lib/d/wrapperloader.swg": "/* -----------------------------------------------------------------------------\n * wrapperloader.swg\n *\n * Support code for dynamically linking the C wrapper library from the D\n * wrapper module.\n *\n * The loading code was adapted from the Derelict project and is used with\n * permission from Michael Parker, the original author.\n * ----------------------------------------------------------------------------- */\n\n%pragma(d) wrapperloadercode = %{\nprivate {\n  version(linux) {\n    version = Nix;\n  } else version(darwin) {\n    version = Nix;\n  } else version(OSX) {\n    version = Nix;\n  } else version(FreeBSD) {\n    version = Nix;\n    version = freebsd;\n  } else version(freebsd) {\n    version = Nix;\n  } else version(Unix) {\n    version = Nix;\n  } else version(Posix) {\n    version = Nix;\n  }\n\n  version(Tango) {\n    static import tango.stdc.string;\n    static import tango.stdc.stringz;\n\n    version (PhobosCompatibility) {\n    } else {\n      alias char[] string;\n      alias wchar[] wstring;\n      alias dchar[] dstring;\n    }\n  } else {\n    version(D_Version2) {\n      static import std.conv;\n    }\n    static import std.string;\n    static import std.c.string;\n  }\n\n  version(D_Version2) {\n    mixin(\"alias const(char)* CCPTR;\");\n  } else {\n    alias char* CCPTR;\n  }\n\n  CCPTR swigToCString(string str) {\n    version(Tango) {\n      return tango.stdc.stringz.toStringz(str);\n    } else {\n      return std.string.toStringz(str);\n    }\n  }\n\n  string swigToDString(CCPTR cstr) {\n    version(Tango) {\n      return tango.stdc.stringz.fromStringz(cstr);\n    } else {\n      version(D_Version2) {\n        mixin(\"return std.conv.to!string(cstr);\");\n      } else {\n        return std.c.string.toString(cstr);\n      }\n    }\n  }\n}\n\nclass SwigSwigSharedLibLoadException : Exception {\n  this(in string[] libNames, in string[] reasons) {\n    string msg = \"Failed to load one or more shared libraries:\";\n    foreach(i, n; libNames) {\n      msg ~= \"\\n\\t\" ~ n ~ \" - \";\n      if(i < reasons.length)\n        msg ~= reasons[i];\n      else\n        msg ~= \"Unknown\";\n    }\n    super(msg);\n  }\n}\n\nclass SwigSymbolLoadException : Exception {\n  this(string SwigSharedLibName, string symbolName) {\n    super(\"Failed to load symbol \" ~ symbolName ~ \" from shared library \" ~ SwigSharedLibName);\n    _symbolName = symbolName;\n  }\n\n  string symbolName() {\n    return _symbolName;\n  }\n\nprivate:\n  string _symbolName;\n}\n\nprivate {\n  version(Nix) {\n    version(freebsd) {\n      // the dl* functions are in libc on FreeBSD\n    }\n    else {\n      pragma(lib, \"dl\");\n    }\n\n    version(Tango) {\n      import tango.sys.Common;\n    } else version(linux) {\n      import std.c.linux.linux;\n    } else {\n      extern(C) {\n        const RTLD_NOW = 2;\n\n        void *dlopen(CCPTR file, int mode);\n        int dlclose(void* handle);\n        void *dlsym(void* handle, CCPTR name);\n        CCPTR dlerror();\n      }\n    }\n\n    alias void* SwigSharedLibHandle;\n\n    SwigSharedLibHandle swigLoadSharedLib(string libName) {\n      return dlopen(swigToCString(libName), RTLD_NOW);\n    }\n\n    void swigUnloadSharedLib(SwigSharedLibHandle hlib) {\n      dlclose(hlib);\n    }\n\n    void* swigGetSymbol(SwigSharedLibHandle hlib, string symbolName) {\n      return dlsym(hlib, swigToCString(symbolName));\n    }\n\n    string swigGetErrorStr() {\n      CCPTR err = dlerror();\n      if (err is null) {\n        return \"Unknown Error\";\n      }\n      return swigToDString(err);\n    }\n  } else version(Windows) {\n    alias ushort WORD;\n    alias uint DWORD;\n    alias CCPTR LPCSTR;\n    alias void* HMODULE;\n    alias void* HLOCAL;\n    alias int function() FARPROC;\n    struct VA_LIST {}\n\n    extern (Windows) {\n      HMODULE LoadLibraryA(LPCSTR);\n      FARPROC GetProcAddress(HMODULE, LPCSTR);\n      void FreeLibrary(HMODULE);\n      DWORD GetLastError();\n      DWORD FormatMessageA(DWORD, in void*, DWORD, DWORD, LPCSTR, DWORD, VA_LIST*);\n      HLOCAL LocalFree(HLOCAL);\n    }\n\n    DWORD MAKELANGID(WORD p, WORD s) {\n      return (((cast(WORD)s) << 10) | cast(WORD)p);\n    }\n\n    enum {\n      LANG_NEUTRAL                    = 0,\n      SUBLANG_DEFAULT                 = 1,\n      FORMAT_MESSAGE_ALLOCATE_BUFFER  = 256,\n      FORMAT_MESSAGE_IGNORE_INSERTS   = 512,\n      FORMAT_MESSAGE_FROM_SYSTEM      = 4096\n    }\n\n    alias HMODULE SwigSharedLibHandle;\n\n    SwigSharedLibHandle swigLoadSharedLib(string libName) {\n      return LoadLibraryA(swigToCString(libName));\n    }\n\n    void swigUnloadSharedLib(SwigSharedLibHandle hlib) {\n      FreeLibrary(hlib);\n    }\n\n    void* swigGetSymbol(SwigSharedLibHandle hlib, string symbolName) {\n      return GetProcAddress(hlib, swigToCString(symbolName));\n    }\n\n    string swigGetErrorStr() {\n      DWORD errcode = GetLastError();\n\n      LPCSTR msgBuf;\n      DWORD i = FormatMessageA(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        null,\n        errcode,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        cast(LPCSTR)&msgBuf,\n        0,\n        null);\n\n      string text = swigToDString(msgBuf);\n      LocalFree(cast(HLOCAL)msgBuf);\n\n      if (i >= 2) {\n        i -= 2;\n      }\n      return text[0 .. i];\n    }\n  } else {\n    static assert(0, \"Operating system not supported by the wrapper loading code.\");\n  }\n\n  final class SwigSharedLib {\n    void load(string[] names) {\n      if (_hlib !is null) return;\n\n      string[] failedLibs;\n      string[] reasons;\n\n      foreach(n; names) {\n        _hlib = swigLoadSharedLib(n);\n        if (_hlib is null) {\n          failedLibs ~= n;\n          reasons ~= swigGetErrorStr();\n          continue;\n        }\n        _name = n;\n        break;\n      }\n\n      if (_hlib is null) {\n        throw new SwigSwigSharedLibLoadException(failedLibs, reasons);\n      }\n    }\n\n    void* loadSymbol(string symbolName, bool doThrow = true) {\n      void* sym = swigGetSymbol(_hlib, symbolName);\n      if(doThrow && (sym is null)) {\n        throw new SwigSymbolLoadException(_name, symbolName);\n      }\n      return sym;\n    }\n\n    void unload() {\n      if(_hlib !is null) {\n        swigUnloadSharedLib(_hlib);\n        _hlib = null;\n      }\n    }\n\n  private:\n    string _name;\n    SwigSharedLibHandle _hlib;\n  }\n}\n\nstatic this() {\n  string[] possibleFileNames;\n  version (Posix) {\n    version (OSX) {\n      possibleFileNames ~= [\"lib$wraplibrary.dylib\", \"lib$wraplibrary.bundle\"];\n    }\n    possibleFileNames ~= [\"lib$wraplibrary.so\"];\n  } else version (Windows) {\n    possibleFileNames ~= [\"$wraplibrary.dll\", \"lib$wraplibrary.so\"];\n  } else {\n    static assert(false, \"Operating system not supported by the wrapper loading code.\");\n  }\n\n  auto library = new SwigSharedLib;\n  library.load(possibleFileNames);\n\n  string bindCode(string functionPointer, string symbol) {\n    return functionPointer ~ \" = cast(typeof(\" ~ functionPointer ~\n      \"))library.loadSymbol(`\" ~ symbol ~ \"`);\";\n  }\n\n  //#if !defined(SWIG_D_NO_EXCEPTION_HELPER)\n  mixin(bindCode(\"swigRegisterExceptionCallbacks\", \"SWIGRegisterExceptionCallbacks_$module\"));\n  //#endif // SWIG_D_NO_EXCEPTION_HELPER\n  //#if !defined(SWIG_D_NO_STRING_HELPER)\n  mixin(bindCode(\"swigRegisterStringCallback\", \"SWIGRegisterStringCallback_$module\"));\n  //#endif // SWIG_D_NO_STRING_HELPER\n  $wrapperloaderbindcode\n}\n\n//#if !defined(SWIG_D_NO_EXCEPTION_HELPER)\nextern(C) void function(\n  SwigExceptionCallback exceptionCallback,\n  SwigExceptionCallback illegalArgumentCallback,\n  SwigExceptionCallback illegalElementCallback,\n  SwigExceptionCallback ioCallback,\n  SwigExceptionCallback noSuchElementCallback) swigRegisterExceptionCallbacks;\n//#endif // SWIG_D_NO_EXCEPTION_HELPER\n\n//#if !defined(SWIG_D_NO_STRING_HELPER)\nextern(C) void function(SwigStringCallback callback) swigRegisterStringCallback;\n//#endif // SWIG_D_NO_STRING_HELPER\n%}\n\n%pragma(d) wrapperloaderbindcommand = %{\n  mixin(bindCode(\"$function\", \"$symbol\"));%}\n",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Lib/mzscheme/mzrun.swg": "/* -----------------------------------------------------------------------------\n * mzrun.swg\n * ----------------------------------------------------------------------------- */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <escheme.h>\n#include <assert.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Common SWIG API */\n  \n#define SWIG_ConvertPtr(s, result, type, flags) \\\n  SWIG_MzScheme_ConvertPtr(s, result, type, flags)\n#define SWIG_NewPointerObj(ptr, type, owner) \\\n  SWIG_MzScheme_NewPointerObj((void *)ptr, type, owner)\n#define SWIG_MustGetPtr(s, type, argnum, flags) \\\n  SWIG_MzScheme_MustGetPtr(s, type, argnum, flags, FUNC_NAME, argc, argv)\n\n#define SWIG_contract_assert(expr,msg) \\\n if (!(expr)) { \\\n    char *m=(char *) scheme_malloc(strlen(msg)+1000); \\\n    sprintf(m,\"SWIG contract, assertion failed: function=%s, message=%s\", \\\n            (char *) FUNC_NAME,(char *) msg); \\\n    scheme_signal_error(m); \\\n }\n\n/* Runtime API */\n#define SWIG_GetModule(clientdata) SWIG_MzScheme_GetModule((Scheme_Env *)(clientdata))\n#define SWIG_SetModule(clientdata, pointer) SWIG_MzScheme_SetModule((Scheme_Env *) (clientdata), pointer)\n#define SWIG_MODULE_CLIENTDATA_TYPE Scheme_Env *\n\n/* MzScheme-specific SWIG API */\n  \n#define SWIG_malloc(size) SWIG_MzScheme_Malloc(size, FUNC_NAME)\n#define SWIG_free(mem) free(mem)\n#define SWIG_NewStructFromPtr(ptr,type) \\\n        _swig_convert_struct_##type##(ptr)\n\n#define MAXVALUES 6\n#define swig_make_boolean(b) (b ? scheme_true : scheme_false)\n\nstatic long\nSWIG_convert_integer(Scheme_Object *o,\n\t\t     long lower_bound, long upper_bound, \n\t\t     const char *func_name, int argnum, int argc,\n\t\t     Scheme_Object **argv)\n{\n  long value;\n  int status = scheme_get_int_val(o, &value);\n  if (!status)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  if (value < lower_bound || value > upper_bound)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  return value;\n}\n\nstatic int\nSWIG_is_integer(Scheme_Object *o)\n{\n  long value;\n  return scheme_get_int_val(o, &value);\n}\n\nstatic unsigned long\nSWIG_convert_unsigned_integer(Scheme_Object *o,\n\t\t\t      unsigned long lower_bound, unsigned long upper_bound, \n\t\t\t      const char *func_name, int argnum, int argc,\n\t\t\t      Scheme_Object **argv)\n{\n  unsigned long value;\n  int status = scheme_get_unsigned_int_val(o, &value);\n  if (!status)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  if (value < lower_bound || value > upper_bound)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  return value;\n}\n\nstatic int\nSWIG_is_unsigned_integer(Scheme_Object *o)\n{\n  unsigned long value;\n  return scheme_get_unsigned_int_val(o, &value);\n}\n  \n/* ----------------------------------------------------------------------- \n * mzscheme 30X support code\n * Contributed by Hans Oesterholt\n * ----------------------------------------------------------------------- */\n\n#ifndef SCHEME_STR_VAL\n#define MZSCHEME30X 1\n#endif\n\n#ifdef MZSCHEME30X \n/* \n * This is MZSCHEME 299.100 or higher (30x).  From version 299.100 of\n * mzscheme upwards, strings are in unicode. These functions convert\n * to and from utf8 encodings of these strings.  NB! strlen(s) will be\n * the size in bytes of the string, not the actual length.\n */\n#define SCHEME_STR_VAL(obj)  \t       SCHEME_BYTE_STR_VAL(scheme_char_string_to_byte_string(obj))\n#define SCHEME_STRLEN_VAL(obj)         SCHEME_BYTE_STRLEN_VAL(scheme_char_string_to_byte_string(obj))\n#define SCHEME_STRINGP(obj)            SCHEME_CHAR_STRINGP(obj)\n#define scheme_make_string(s)          scheme_make_utf8_string(s)\n#define scheme_make_sized_string(s,l)  scheme_make_sized_utf8_string(s,l)\n#define scheme_make_sized_offset_string(s,d,l) \\\n                   scheme_make_sized_offset_utf8_string(s,d,l)\n#define SCHEME_MAKE_STRING(s) scheme_make_utf8_string(s)\n#else\n#define SCHEME_MAKE_STRING(s) scheme_make_string_without_copying(s)\n#endif\n/* ----------------------------------------------------------------------- \n * End of mzscheme 30X support code \n * ----------------------------------------------------------------------- */\n  \nstruct swig_mz_proxy {\n  Scheme_Type mztype;\n  swig_type_info *type;\n  void *object;\n};\n\nstatic Scheme_Type swig_type;\n\nstatic void \nmz_free_swig(void *p, void *data) {\n  struct swig_mz_proxy *proxy = (struct swig_mz_proxy *) p;\n  if (SCHEME_NULLP((Scheme_Object*)p) || SCHEME_TYPE((Scheme_Object*)p) != swig_type)\n    return;\n  if (proxy->type) {\n    if (proxy->type->clientdata) {\n      ((Scheme_Prim *)proxy->type->clientdata)(1, (Scheme_Object **)&proxy);\n    }\n  }\n}\n\nstatic Scheme_Object *\nSWIG_MzScheme_NewPointerObj(void *ptr, swig_type_info *type, int owner) {\n  struct swig_mz_proxy *new_proxy;\n  new_proxy = (struct swig_mz_proxy *) scheme_malloc(sizeof(struct swig_mz_proxy));\n  new_proxy->mztype = swig_type;\n  new_proxy->type = type;\n  new_proxy->object = ptr;\n  if (owner) {\n    scheme_add_finalizer(new_proxy, mz_free_swig, NULL);\n  }\n  return (Scheme_Object *) new_proxy;\n}\n\nstatic int\nSWIG_MzScheme_ConvertPtr(Scheme_Object *s, void **result, swig_type_info *type, int flags) {\n  swig_cast_info *cast;\n\n  if (SCHEME_NULLP(s)) {\n    *result = NULL;\n    return 0;\n  } else if (SCHEME_TYPE(s) == swig_type) {\n    struct swig_mz_proxy *proxy = (struct swig_mz_proxy *) s;\n    if (type) {\n      cast = SWIG_TypeCheckStruct(proxy->type, type);\n      if (cast) {\n        int newmemory = 0;\n        *result = SWIG_TypeCast(cast, proxy->object, &newmemory);\n        assert(!newmemory); /* newmemory handling not yet implemented */\n        return 0;\n      } else {\n        return 1;\n      }\n    } else {\n      *result = proxy->object;\n      return 0;\n    }\n  }\n  return 1;\n}\n\nstatic SWIGINLINE void *\nSWIG_MzScheme_MustGetPtr(Scheme_Object *s, swig_type_info *type, \n                         int argnum, int flags, const char *func_name,\n                         int argc, Scheme_Object **argv) {\n  void *result;\n  if (SWIG_MzScheme_ConvertPtr(s, &result, type, flags)) {\n    scheme_wrong_type(func_name, type->str ? type->str : \"void *\", argnum - 1, argc, argv);\n  }\n  return result;\n}\n\nstatic SWIGINLINE void *\nSWIG_MzScheme_Malloc(size_t size, const char *func_name) {\n  void *p = malloc(size);\n  if (p == NULL) {\n    scheme_signal_error(\"swig-memory-error\");\n  } else return p;\n}\n\nstatic Scheme_Object *\nSWIG_MzScheme_PackageValues(int num, Scheme_Object **values) {\n    /* ignore first value if void */\n    if (num > 0 && SCHEME_VOIDP(values[0]))\n\tnum--, values++;\n    if (num == 0) return scheme_void;\n    else if (num == 1) return values[0];\n    else return scheme_values(num, values);\n}\n\n#ifndef scheme_make_inspector\n#define scheme_make_inspector(x,y) \\\n        _scheme_apply(scheme_builtin_value(\"make-inspector\"), x, y)\n#endif\n\n/* Function to create a new struct. */\nstatic Scheme_Object *\nSWIG_MzScheme_new_scheme_struct (Scheme_Env* env, const char* basename, \n\t\t\t\t int num_fields, char** field_names)\n{\n    Scheme_Object *new_type;\n    int count_out, i;\n    Scheme_Object **struct_names;\n    Scheme_Object **vals;\n    Scheme_Object **a = (Scheme_Object**) \\\n        scheme_malloc(num_fields*sizeof(Scheme_Object*));\n    \n    for (i=0; i<num_fields; ++i) {\n        a[i] = (Scheme_Object*) scheme_intern_symbol(field_names[i]);\n    }\n\n    new_type = scheme_make_struct_type(scheme_intern_symbol(basename),\n                                       NULL /*super_type*/,\n                                       scheme_make_inspector(0, NULL),\n                                       num_fields,\n                                       0 /* auto_fields */,\n                                       NULL /* auto_val */,\n                                       NULL /* properties */\n#ifdef MZSCHEME30X\n\t\t\t\t       ,NULL /* Guard */\n#endif\n\t\t\t\t       );\n    struct_names = scheme_make_struct_names(scheme_intern_symbol(basename),\n                                            scheme_build_list(num_fields,a),\n                                            0 /*flags*/, &count_out);\n    vals = scheme_make_struct_values(new_type, struct_names, count_out, 0);\n\n    for (i = 0; i < count_out; i++)\n        scheme_add_global_symbol(struct_names[i], vals[i],env);\n\n    return new_type;\n}\n\n/*** DLOPEN PATCH ******************************************************\n * Contributed by Hans Oesterholt-Dijkema (jan. 2006)\n ***********************************************************************/\n\n#if defined(_WIN32) || defined(__WIN32__)\n#define __OS_WIN32\n#endif\n\n#ifdef __OS_WIN32\n#include <windows.h>\n#else\n#include <dlfcn.h>\n#endif\n\n  static char **mz_dlopen_libraries=NULL;\n  static void **mz_libraries=NULL;\n  static char **mz_dynload_libpaths=NULL;\n\n  static void mz_set_dlopen_libraries(const char *_libs)\n  {\n    int   i,k,n;\n    int   mz_dynload_debug=(1==0);\n    char *extra_paths[1000];\n    char *EP;\n    \n    {\n      char *dbg=getenv(\"MZ_DYNLOAD_DEBUG\");\n      if (dbg!=NULL) {\n\tmz_dynload_debug=atoi(dbg);\n      }\n    }\n\n    {\n      char *ep=getenv(\"MZ_DYNLOAD_LIBPATH\");\n      int   i,k,j;\n      k=0;\n      if (ep!=NULL) {\n\tEP=strdup(ep);\n\tfor(i=0,j=0;EP[i]!='\\0';i++) {\n\t  if (EP[i]==':') {\n\t    EP[i]='\\0';\n\t    extra_paths[k++]=&EP[j];\n\t    j=i+1;\n\t  }\n\t}\n\tif (j!=i) {\n\t  extra_paths[k++]=&EP[j];\n\t}\n      }\n      else {\n\tEP=strdup(\"\");\n      }\n      extra_paths[k]=NULL;\n      k+=1;\n\n      if (mz_dynload_debug) {\n\tfprintf(stderr,\"SWIG:mzscheme:MZ_DYNLOAD_LIBPATH=%s\\n\",(ep==NULL) ? \"(null)\" : ep);\n\tfprintf(stderr,\"SWIG:mzscheme:extra_paths[%d]\\n\",k-1);\n\tfor(i=0;i<k-1;i++) {\n\t  fprintf(stderr,\"SWIG:mzscheme:extra_paths[%d]=%s\\n\",i,extra_paths[i]);\n\t}\n      }\n\n      mz_dynload_libpaths=(char **) malloc(sizeof(char *)*k);\n      for(i=0;i<k;i++) {\n\tif (extra_paths[i]!=NULL) {\n\t  mz_dynload_libpaths[i]=strdup(extra_paths[i]);\n\t}\n\telse {\n\t  mz_dynload_libpaths[i]=NULL;\n\t}\n      }\n\n      if (mz_dynload_debug) {\n\tint i;\n\tfor(i=0;extra_paths[i]!=NULL;i++) {\n\t  fprintf(stderr,\"SWIG:mzscheme:%s\\n\",extra_paths[i]);\n\t}\n      }\n    }\n\n    {\n#ifdef MZ_DYNLOAD_LIBS\n      char *libs=(char *) malloc((strlen(MZ_DYNLOAD_LIBS)+1)*sizeof(char));\n      strcpy(libs,MZ_DYNLOAD_LIBS);\n#else\n      char *libs=(char *) malloc((strlen(_libs)+1)*sizeof(char));\n      strcpy(libs,_libs);\n#endif\n      \n      for(i=0,n=strlen(libs),k=0;i<n;i++) {\n\tif (libs[i]==',') { k+=1; }\n      }\n      k+=1;\n      mz_dlopen_libraries=(char **) malloc(sizeof(char *)*(k+1));\n      mz_dlopen_libraries[0]=libs;\n      for(i=0,k=1,n=strlen(libs);i<n;i++) {\n\tif (libs[i]==',') {\n\t  libs[i]='\\0';\n\t  mz_dlopen_libraries[k++]=&libs[i+1];\n\t  i+=1;\n\t}\n      }\n      \n      if (mz_dynload_debug) {\n\tfprintf(stderr,\"k=%d\\n\",k);\n      }\n      mz_dlopen_libraries[k]=NULL;\n      \n      free(EP);\n    }\n  }\n\n  static void *mz_load_function(char *function)\n  {\n    int mz_dynload_debug=(1==0);\n    \n    {\n      char *dbg=getenv(\"MZ_DYNLOAD_DEBUG\");\n      if (dbg!=NULL) {\n\tmz_dynload_debug=atoi(dbg);\n      }\n    }\n\n    if (mz_dlopen_libraries==NULL) {\n      return NULL;\n    }\n    else {\n      if (mz_libraries==NULL) {\n        int i,n;\n        for(n=0;mz_dlopen_libraries[n]!=NULL;n++);\n\tif (mz_dynload_debug) {\n\t  fprintf(stderr,\"SWIG:mzscheme:n=%d\\n\",n);\n\t}\n        mz_libraries=(void **) malloc(sizeof(void*)*n);\n        for(i=0;i<n;i++) { \n\t  if (mz_dynload_debug) {\n\t   fprintf(stderr,\"SWIG:mzscheme:loading %s\\n\",mz_dlopen_libraries[i]);\n\t  }\n#ifdef __OS_WIN32\n\t  mz_libraries[i]=(void *) LoadLibrary(mz_dlopen_libraries[i]); \n#else\n\t  mz_libraries[i]=(void *) dlopen(mz_dlopen_libraries[i],RTLD_LAZY); \n#endif\n\t  if (mz_libraries[i]==NULL) {\n\t    int k;\n\t    char *libp;\n\t    for(k=0;mz_dynload_libpaths[k]!=NULL && mz_libraries[i]==NULL;k++) {\n\t      int L=strlen(mz_dynload_libpaths[k])+strlen(\"\\\\\")+strlen(mz_dlopen_libraries[i])+1;\n\t      libp=(char *) malloc(L*sizeof(char));\n#ifdef __OS_WIN32\n\t      sprintf(libp,\"%s\\\\%s\",mz_dynload_libpaths[k],mz_dlopen_libraries[i]);\n\t      mz_libraries[i]=(void *) LoadLibrary(libp); \n#else\n\t      sprintf(libp,\"%s/%s\",mz_dynload_libpaths[k],mz_dlopen_libraries[i]);\n\t      mz_libraries[i]=(void *) dlopen(libp,RTLD_LAZY); \n#endif\n\t      if (mz_dynload_debug) {\n\t\tfprintf(stderr,\"SWIG:mzscheme:trying %s --> %p\\n\",libp,mz_libraries[i]);\n\t      }\n\t      free(libp);\n\t    }\n\t  }\n        }\n      }\n      {\n        int i;\n        void *func=NULL;\n\n        for(i=0;mz_dlopen_libraries[i]!=NULL && func==NULL;i++) {\n          if (mz_libraries[i]!=NULL) {\n#ifdef __OS_WIN32\n            func=GetProcAddress(mz_libraries[i],function);\n#else\n            func=dlsym(mz_libraries[i],function);\n#endif\n          }\n\t  if (mz_dynload_debug) {\n\t    fprintf(stderr,\n\t\t    \"SWIG:mzscheme:library:%s;dlopen=%p,function=%s,func=%p\\n\",\n\t\t    mz_dlopen_libraries[i],mz_libraries[i],function,func\n\t\t    );\n\t  }\n        }\n\n        return func;\n      }\n    }\n  }\n\n/*** DLOPEN PATCH ******************************************************\n * Contributed by Hans Oesterholt-Dijkema (jan. 2006)\n ***********************************************************************/\n\n/* The interpreter will store a pointer to this structure in a global\n   variable called swig-runtime-data-type-pointer.  The instance of this\n   struct is only used if no other module has yet been loaded */\nstruct swig_mzscheme_runtime_data {\n  swig_module_info *module_head;\n  Scheme_Type type;\n};\nstatic struct swig_mzscheme_runtime_data swig_mzscheme_runtime_data;\n\n\nstatic swig_module_info *\nSWIG_MzScheme_GetModule(Scheme_Env *env) {\n  Scheme_Object *pointer, *symbol;\n  struct swig_mzscheme_runtime_data *data;\n\n  /* first check if pointer already created */\n  symbol = scheme_intern_symbol(\"swig-runtime-data-type-pointer\" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);\n  pointer = scheme_lookup_global(symbol, env);\n  if (pointer && SCHEME_CPTRP(pointer)) {\n      data = (struct swig_mzscheme_runtime_data *) SCHEME_CPTR_VAL(pointer);\n      swig_type = data->type;\n      return data->module_head;\n  } else {\n      return NULL;\n  }\n}\n\nstatic void\nSWIG_MzScheme_SetModule(Scheme_Env *env, swig_module_info *module) {\n  Scheme_Object *pointer, *symbol;\n  struct swig_mzscheme_runtime_data *data;\n\n  /* first check if pointer already created */\n  symbol = scheme_intern_symbol(\"swig-runtime-data-type-pointer\" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);\n  pointer = scheme_lookup_global(symbol, env);\n  if (pointer && SCHEME_CPTRP(pointer)) {\n    data = (struct swig_mzscheme_runtime_data *) SCHEME_CPTR_VAL(pointer);\n    swig_type = data->type;\n    data->module_head = module;\n  } else {\n    /* create a new type for wrapped pointer values */\n    swig_type = scheme_make_type((char *)\"swig\");\n    swig_mzscheme_runtime_data.module_head = module;\n    swig_mzscheme_runtime_data.type = swig_type;\n    \n    /* create a new pointer */\n#ifndef MZSCHEME30X\n    pointer = scheme_make_cptr((void *) &swig_mzscheme_runtime_data, \"swig_mzscheme_runtime_data\");\n#else\n    pointer = scheme_make_cptr((void *) &swig_mzscheme_runtime_data,\n\t\t\t       scheme_make_byte_string(\"swig_mzscheme_runtime_data\"));\n#endif\n    scheme_add_global_symbol(symbol, pointer, env);\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Doc/Manual/swig16.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Doc/Manual/ch2.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Doc/Manual/SWIGDocumentation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Doc/Manual/ch11.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Doc/Manual/ch11.3.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Doc/Manual/ch12.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Doc/Manual/ch11.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Doc/Manual/ch9.table.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Examples/test-suite/char_constant.i",
        "/tmp/vanessa/spack-stage/spack-stage-swig-2.0.2-2gy47kbs7el4j33g27hhge6d2voac6yq/spack-src/Examples/test-suite/ruby/char_constant_runme.rb"
    ],
    "total_files": 3643
}