{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Lib/d/wrapperloader.swg": "/* -----------------------------------------------------------------------------\n * wrapperloader.swg\n *\n * Support code for dynamically linking the C wrapper library from the D\n * wrapper module.\n *\n * The loading code was adapted from the Derelict project and is used with\n * permission from Michael Parker, the original author.\n * ----------------------------------------------------------------------------- */\n\n%pragma(d) wrapperloadercode = %{\nprivate {\n  version(linux) {\n    version = Nix;\n  } else version(darwin) {\n    version = Nix;\n  } else version(OSX) {\n    version = Nix;\n  } else version(FreeBSD) {\n    version = Nix;\n    version = freebsd;\n  } else version(freebsd) {\n    version = Nix;\n  } else version(Unix) {\n    version = Nix;\n  } else version(Posix) {\n    version = Nix;\n  }\n\n  version(Tango) {\n    static import tango.stdc.string;\n    static import tango.stdc.stringz;\n\n    version (PhobosCompatibility) {\n    } else {\n      alias char[] string;\n      alias wchar[] wstring;\n      alias dchar[] dstring;\n    }\n  } else {\n    version(D_Version2) {\n      static import std.conv;\n    } else {\n      static import std.c.string;\n    }\n    static import std.string;\n  }\n\n  version(D_Version2) {\n    mixin(\"alias const(char)* CCPTR;\");\n  } else {\n    alias char* CCPTR;\n  }\n\n  CCPTR swigToCString(string str) {\n    version(Tango) {\n      return tango.stdc.stringz.toStringz(str);\n    } else {\n      return std.string.toStringz(str);\n    }\n  }\n\n  string swigToDString(CCPTR cstr) {\n    version(Tango) {\n      return tango.stdc.stringz.fromStringz(cstr);\n    } else {\n      version(D_Version2) {\n        mixin(\"return std.conv.to!string(cstr);\");\n      } else {\n        return std.c.string.toString(cstr);\n      }\n    }\n  }\n}\n\nclass SwigSwigSharedLibLoadException : Exception {\n  this(in string[] libNames, in string[] reasons) {\n    string msg = \"Failed to load one or more shared libraries:\";\n    foreach(i, n; libNames) {\n      msg ~= \"\\n\\t\" ~ n ~ \" - \";\n      if(i < reasons.length)\n        msg ~= reasons[i];\n      else\n        msg ~= \"Unknown\";\n    }\n    super(msg);\n  }\n}\n\nclass SwigSymbolLoadException : Exception {\n  this(string SwigSharedLibName, string symbolName) {\n    super(\"Failed to load symbol \" ~ symbolName ~ \" from shared library \" ~ SwigSharedLibName);\n    _symbolName = symbolName;\n  }\n\n  string symbolName() {\n    return _symbolName;\n  }\n\nprivate:\n  string _symbolName;\n}\n\nprivate {\n  version(Nix) {\n    version(freebsd) {\n      // the dl* functions are in libc on FreeBSD\n    }\n    else {\n      pragma(lib, \"dl\");\n    }\n\n    version(Tango) {\n      import tango.sys.Common;\n    } else version(linux) {\n      import core.sys.posix.dlfcn;\n    } else {\n      extern(C) {\n        const RTLD_NOW = 2;\n\n        void *dlopen(CCPTR file, int mode);\n        int dlclose(void* handle);\n        void *dlsym(void* handle, CCPTR name);\n        CCPTR dlerror();\n      }\n    }\n\n    alias void* SwigSharedLibHandle;\n\n    SwigSharedLibHandle swigLoadSharedLib(string libName) {\n      return dlopen(swigToCString(libName), RTLD_NOW);\n    }\n\n    void swigUnloadSharedLib(SwigSharedLibHandle hlib) {\n      dlclose(hlib);\n    }\n\n    void* swigGetSymbol(SwigSharedLibHandle hlib, string symbolName) {\n      return dlsym(hlib, swigToCString(symbolName));\n    }\n\n    string swigGetErrorStr() {\n      CCPTR err = dlerror();\n      if (err is null) {\n        return \"Unknown Error\";\n      }\n      return swigToDString(err);\n    }\n  } else version(Windows) {\n    alias ushort WORD;\n    alias uint DWORD;\n    alias CCPTR LPCSTR;\n    alias void* HMODULE;\n    alias void* HLOCAL;\n    alias int function() FARPROC;\n    struct VA_LIST {}\n\n    extern (Windows) {\n      HMODULE LoadLibraryA(LPCSTR);\n      FARPROC GetProcAddress(HMODULE, LPCSTR);\n      void FreeLibrary(HMODULE);\n      DWORD GetLastError();\n      DWORD FormatMessageA(DWORD, in void*, DWORD, DWORD, LPCSTR, DWORD, VA_LIST*);\n      HLOCAL LocalFree(HLOCAL);\n    }\n\n    DWORD MAKELANGID(WORD p, WORD s) {\n      return (((cast(WORD)s) << 10) | cast(WORD)p);\n    }\n\n    enum {\n      LANG_NEUTRAL                    = 0,\n      SUBLANG_DEFAULT                 = 1,\n      FORMAT_MESSAGE_ALLOCATE_BUFFER  = 256,\n      FORMAT_MESSAGE_IGNORE_INSERTS   = 512,\n      FORMAT_MESSAGE_FROM_SYSTEM      = 4096\n    }\n\n    alias HMODULE SwigSharedLibHandle;\n\n    SwigSharedLibHandle swigLoadSharedLib(string libName) {\n      return LoadLibraryA(swigToCString(libName));\n    }\n\n    void swigUnloadSharedLib(SwigSharedLibHandle hlib) {\n      FreeLibrary(hlib);\n    }\n\n    void* swigGetSymbol(SwigSharedLibHandle hlib, string symbolName) {\n      return GetProcAddress(hlib, swigToCString(symbolName));\n    }\n\n    string swigGetErrorStr() {\n      DWORD errcode = GetLastError();\n\n      LPCSTR msgBuf;\n      DWORD i = FormatMessageA(\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        null,\n        errcode,\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n        cast(LPCSTR)&msgBuf,\n        0,\n        null);\n\n      string text = swigToDString(msgBuf);\n      LocalFree(cast(HLOCAL)msgBuf);\n\n      if (i >= 2) {\n        i -= 2;\n      }\n      return text[0 .. i];\n    }\n  } else {\n    static assert(0, \"Operating system not supported by the wrapper loading code.\");\n  }\n\n  final class SwigSharedLib {\n    void load(string[] names) {\n      if (_hlib !is null) return;\n\n      string[] failedLibs;\n      string[] reasons;\n\n      foreach(n; names) {\n        _hlib = swigLoadSharedLib(n);\n        if (_hlib is null) {\n          failedLibs ~= n;\n          reasons ~= swigGetErrorStr();\n          continue;\n        }\n        _name = n;\n        break;\n      }\n\n      if (_hlib is null) {\n        throw new SwigSwigSharedLibLoadException(failedLibs, reasons);\n      }\n    }\n\n    void* loadSymbol(string symbolName, bool doThrow = true) {\n      void* sym = swigGetSymbol(_hlib, symbolName);\n      if(doThrow && (sym is null)) {\n        throw new SwigSymbolLoadException(_name, symbolName);\n      }\n      return sym;\n    }\n\n    void unload() {\n      if(_hlib !is null) {\n        swigUnloadSharedLib(_hlib);\n        _hlib = null;\n      }\n    }\n\n  private:\n    string _name;\n    SwigSharedLibHandle _hlib;\n  }\n}\n\nstatic this() {\n  string[] possibleFileNames;\n  version (Posix) {\n    version (OSX) {\n      possibleFileNames ~= [\"lib$wraplibrary.dylib\", \"lib$wraplibrary.bundle\"];\n    }\n    possibleFileNames ~= [\"lib$wraplibrary.so\"];\n  } else version (Windows) {\n    possibleFileNames ~= [\"$wraplibrary.dll\", \"lib$wraplibrary.so\"];\n  } else {\n    static assert(false, \"Operating system not supported by the wrapper loading code.\");\n  }\n\n  auto library = new SwigSharedLib;\n  library.load(possibleFileNames);\n\n  string bindCode(string functionPointer, string symbol) {\n    return functionPointer ~ \" = cast(typeof(\" ~ functionPointer ~\n      \"))library.loadSymbol(`\" ~ symbol ~ \"`);\";\n  }\n\n  //#if !defined(SWIG_D_NO_EXCEPTION_HELPER)\n  mixin(bindCode(\"swigRegisterExceptionCallbacks$module\", \"SWIGRegisterExceptionCallbacks_$module\"));\n  //#endif // SWIG_D_NO_EXCEPTION_HELPER\n  //#if !defined(SWIG_D_NO_STRING_HELPER)\n  mixin(bindCode(\"swigRegisterStringCallback$module\", \"SWIGRegisterStringCallback_$module\"));\n  //#endif // SWIG_D_NO_STRING_HELPER\n  $wrapperloaderbindcode\n}\n\n//#if !defined(SWIG_D_NO_EXCEPTION_HELPER)\nextern(C) void function(\n  SwigExceptionCallback exceptionCallback,\n  SwigExceptionCallback illegalArgumentCallback,\n  SwigExceptionCallback illegalElementCallback,\n  SwigExceptionCallback ioCallback,\n  SwigExceptionCallback noSuchElementCallback) swigRegisterExceptionCallbacks$module;\n//#endif // SWIG_D_NO_EXCEPTION_HELPER\n\n//#if !defined(SWIG_D_NO_STRING_HELPER)\nextern(C) void function(SwigStringCallback callback) swigRegisterStringCallback$module;\n//#endif // SWIG_D_NO_STRING_HELPER\n%}\n\n%pragma(d) wrapperloaderbindcommand = %{\n  mixin(bindCode(\"$function\", \"$symbol\"));%}\n",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Lib/mzscheme/mzrun.swg": "/* -----------------------------------------------------------------------------\n * mzrun.swg\n * ----------------------------------------------------------------------------- */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <escheme.h>\n#include <assert.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Common SWIG API */\n  \n#define SWIG_ConvertPtr(s, result, type, flags) \\\n  SWIG_MzScheme_ConvertPtr(s, result, type, flags)\n#define SWIG_NewPointerObj(ptr, type, owner) \\\n  SWIG_MzScheme_NewPointerObj((void *)ptr, type, owner)\n#define SWIG_MustGetPtr(s, type, argnum, flags) \\\n  SWIG_MzScheme_MustGetPtr(s, type, argnum, flags, FUNC_NAME, argc, argv)\n\n#define SWIG_contract_assert(expr,msg) \\\n if (!(expr)) { \\\n    char *m=(char *) scheme_malloc(strlen(msg)+1000); \\\n    sprintf(m,\"SWIG contract, assertion failed: function=%s, message=%s\", \\\n            (char *) FUNC_NAME,(char *) msg); \\\n    scheme_signal_error(m); \\\n }\n\n/* Runtime API */\n#define SWIG_GetModule(clientdata) SWIG_MzScheme_GetModule((Scheme_Env *)(clientdata))\n#define SWIG_SetModule(clientdata, pointer) SWIG_MzScheme_SetModule((Scheme_Env *) (clientdata), pointer)\n#define SWIG_MODULE_CLIENTDATA_TYPE Scheme_Env *\n\n/* MzScheme-specific SWIG API */\n  \n#define SWIG_malloc(size) SWIG_MzScheme_Malloc(size, FUNC_NAME)\n#define SWIG_free(mem) free(mem)\n#define SWIG_NewStructFromPtr(ptr,type) \\\n        _swig_convert_struct_##type##(ptr)\n\n#define MAXVALUES 6\n#define swig_make_boolean(b) (b ? scheme_true : scheme_false)\n\nstatic long\nSWIG_convert_integer(Scheme_Object *o,\n\t\t     long lower_bound, long upper_bound, \n\t\t     const char *func_name, int argnum, int argc,\n\t\t     Scheme_Object **argv)\n{\n  long value;\n  int status = scheme_get_int_val(o, &value);\n  if (!status)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  if (value < lower_bound || value > upper_bound)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  return value;\n}\n\nstatic int\nSWIG_is_integer(Scheme_Object *o)\n{\n  long value;\n  return scheme_get_int_val(o, &value);\n}\n\nstatic unsigned long\nSWIG_convert_unsigned_integer(Scheme_Object *o,\n\t\t\t      unsigned long lower_bound, unsigned long upper_bound, \n\t\t\t      const char *func_name, int argnum, int argc,\n\t\t\t      Scheme_Object **argv)\n{\n  unsigned long value;\n  int status = scheme_get_unsigned_int_val(o, &value);\n  if (!status)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  if (value < lower_bound || value > upper_bound)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  return value;\n}\n\nstatic int\nSWIG_is_unsigned_integer(Scheme_Object *o)\n{\n  unsigned long value;\n  return scheme_get_unsigned_int_val(o, &value);\n}\n  \n/* ----------------------------------------------------------------------- \n * mzscheme 30X support code\n * ----------------------------------------------------------------------- */\n\n#ifndef SCHEME_STR_VAL\n#define MZSCHEME30X 1\n#endif\n\n#ifdef MZSCHEME30X \n/* \n * This is MZSCHEME 299.100 or higher (30x).  From version 299.100 of\n * mzscheme upwards, strings are in unicode. These functions convert\n * to and from utf8 encodings of these strings.  NB! strlen(s) will be\n * the size in bytes of the string, not the actual length.\n */\n#define SCHEME_STR_VAL(obj)  \t       SCHEME_BYTE_STR_VAL(scheme_char_string_to_byte_string(obj))\n#define SCHEME_STRLEN_VAL(obj)         SCHEME_BYTE_STRLEN_VAL(scheme_char_string_to_byte_string(obj))\n#define SCHEME_STRINGP(obj)            SCHEME_CHAR_STRINGP(obj)\n#define scheme_make_string(s)          scheme_make_utf8_string(s)\n#define scheme_make_sized_string(s,l)  scheme_make_sized_utf8_string(s,l)\n#define scheme_make_sized_offset_string(s,d,l) \\\n                   scheme_make_sized_offset_utf8_string(s,d,l)\n#define SCHEME_MAKE_STRING(s) scheme_make_utf8_string(s)\n#else\n#define SCHEME_MAKE_STRING(s) scheme_make_string_without_copying(s)\n#endif\n/* ----------------------------------------------------------------------- \n * End of mzscheme 30X support code \n * ----------------------------------------------------------------------- */\n  \nstruct swig_mz_proxy {\n  Scheme_Type mztype;\n  swig_type_info *type;\n  void *object;\n};\n\nstatic Scheme_Type swig_type;\n\nstatic void \nmz_free_swig(void *p, void *data) {\n  struct swig_mz_proxy *proxy = (struct swig_mz_proxy *) p;\n  if (SCHEME_NULLP((Scheme_Object*)p) || SCHEME_TYPE((Scheme_Object*)p) != swig_type)\n    return;\n  if (proxy->type) {\n    if (proxy->type->clientdata) {\n      ((Scheme_Prim *)proxy->type->clientdata)(1, (Scheme_Object **)&proxy);\n    }\n  }\n}\n\nstatic Scheme_Object *\nSWIG_MzScheme_NewPointerObj(void *ptr, swig_type_info *type, int owner) {\n  struct swig_mz_proxy *new_proxy;\n  new_proxy = (struct swig_mz_proxy *) scheme_malloc(sizeof(struct swig_mz_proxy));\n  new_proxy->mztype = swig_type;\n  new_proxy->type = type;\n  new_proxy->object = ptr;\n  if (owner) {\n    scheme_add_finalizer(new_proxy, mz_free_swig, NULL);\n  }\n  return (Scheme_Object *) new_proxy;\n}\n\nstatic int\nSWIG_MzScheme_ConvertPtr(Scheme_Object *s, void **result, swig_type_info *type, int flags) {\n  swig_cast_info *cast;\n\n  if (SCHEME_NULLP(s)) {\n    *result = NULL;\n    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;\n  } else if (SCHEME_TYPE(s) == swig_type) {\n    struct swig_mz_proxy *proxy = (struct swig_mz_proxy *) s;\n    if (type) {\n      cast = SWIG_TypeCheckStruct(proxy->type, type);\n      if (cast) {\n        int newmemory = 0;\n        *result = SWIG_TypeCast(cast, proxy->object, &newmemory);\n        assert(!newmemory); /* newmemory handling not yet implemented */\n        return 0;\n      } else {\n        return 1;\n      }\n    } else {\n      *result = proxy->object;\n      return 0;\n    }\n  }\n  return 1;\n}\n\nstatic SWIGINLINE void *\nSWIG_MzScheme_MustGetPtr(Scheme_Object *s, swig_type_info *type, \n                         int argnum, int flags, const char *func_name,\n                         int argc, Scheme_Object **argv) {\n  void *result;\n  if (SWIG_MzScheme_ConvertPtr(s, &result, type, flags)) {\n    scheme_wrong_type(func_name, type->str ? type->str : \"void *\", argnum - 1, argc, argv);\n  }\n  return result;\n}\n\nstatic SWIGINLINE void *\nSWIG_MzScheme_Malloc(size_t size, const char *func_name) {\n  void *p = malloc(size);\n  if (p == NULL) {\n    scheme_signal_error(\"swig-memory-error\");\n  } else return p;\n}\n\nstatic Scheme_Object *\nSWIG_MzScheme_PackageValues(int num, Scheme_Object **values) {\n    /* ignore first value if void */\n    if (num > 0 && SCHEME_VOIDP(values[0]))\n\tnum--, values++;\n    if (num == 0) return scheme_void;\n    else if (num == 1) return values[0];\n    else return scheme_values(num, values);\n}\n\n#ifndef scheme_make_inspector\n#define scheme_make_inspector(x,y) \\\n        _scheme_apply(scheme_builtin_value(\"make-inspector\"), x, y)\n#endif\n\n/* Function to create a new struct. */\nstatic Scheme_Object *\nSWIG_MzScheme_new_scheme_struct (Scheme_Env* env, const char* basename, \n\t\t\t\t int num_fields, char** field_names)\n{\n    Scheme_Object *new_type;\n    int count_out, i;\n    Scheme_Object **struct_names;\n    Scheme_Object **vals;\n    Scheme_Object **a = (Scheme_Object**) \\\n        scheme_malloc(num_fields*sizeof(Scheme_Object*));\n    \n    for (i=0; i<num_fields; ++i) {\n        a[i] = (Scheme_Object*) scheme_intern_symbol(field_names[i]);\n    }\n\n    new_type = scheme_make_struct_type(scheme_intern_symbol(basename),\n                                       NULL /*super_type*/,\n                                       scheme_make_inspector(0, NULL),\n                                       num_fields,\n                                       0 /* auto_fields */,\n                                       NULL /* auto_val */,\n                                       NULL /* properties */\n#ifdef MZSCHEME30X\n\t\t\t\t       ,NULL /* Guard */\n#endif\n\t\t\t\t       );\n    struct_names = scheme_make_struct_names(scheme_intern_symbol(basename),\n                                            scheme_build_list(num_fields,a),\n                                            0 /*flags*/, &count_out);\n    vals = scheme_make_struct_values(new_type, struct_names, count_out, 0);\n\n    for (i = 0; i < count_out; i++)\n        scheme_add_global_symbol(struct_names[i], vals[i],env);\n\n    return new_type;\n}\n\n#if defined(_WIN32) || defined(__WIN32__)\n#define __OS_WIN32\n#endif\n\n#ifdef __OS_WIN32\n#include <windows.h>\n#else\n#include <dlfcn.h>\n#endif\n\n  static char **mz_dlopen_libraries=NULL;\n  static void **mz_libraries=NULL;\n  static char **mz_dynload_libpaths=NULL;\n\n  static void mz_set_dlopen_libraries(const char *_libs)\n  {\n    int   i,k,n;\n    int   mz_dynload_debug=(1==0);\n    char *extra_paths[1000];\n    char *EP;\n    \n    {\n      char *dbg=getenv(\"MZ_DYNLOAD_DEBUG\");\n      if (dbg!=NULL) {\n\tmz_dynload_debug=atoi(dbg);\n      }\n    }\n\n    {\n      char *ep=getenv(\"MZ_DYNLOAD_LIBPATH\");\n      int   i,k,j;\n      k=0;\n      if (ep!=NULL) {\n\tEP=strdup(ep);\n\tfor(i=0,j=0;EP[i]!='\\0';i++) {\n\t  if (EP[i]==':') {\n\t    EP[i]='\\0';\n\t    extra_paths[k++]=&EP[j];\n\t    j=i+1;\n\t  }\n\t}\n\tif (j!=i) {\n\t  extra_paths[k++]=&EP[j];\n\t}\n      }\n      else {\n\tEP=strdup(\"\");\n      }\n      extra_paths[k]=NULL;\n      k+=1;\n\n      if (mz_dynload_debug) {\n\tfprintf(stderr,\"SWIG:mzscheme:MZ_DYNLOAD_LIBPATH=%s\\n\",(ep==NULL) ? \"(null)\" : ep);\n\tfprintf(stderr,\"SWIG:mzscheme:extra_paths[%d]\\n\",k-1);\n\tfor(i=0;i<k-1;i++) {\n\t  fprintf(stderr,\"SWIG:mzscheme:extra_paths[%d]=%s\\n\",i,extra_paths[i]);\n\t}\n      }\n\n      mz_dynload_libpaths=(char **) malloc(sizeof(char *)*k);\n      for(i=0;i<k;i++) {\n\tif (extra_paths[i]!=NULL) {\n\t  mz_dynload_libpaths[i]=strdup(extra_paths[i]);\n\t}\n\telse {\n\t  mz_dynload_libpaths[i]=NULL;\n\t}\n      }\n\n      if (mz_dynload_debug) {\n\tint i;\n\tfor(i=0;extra_paths[i]!=NULL;i++) {\n\t  fprintf(stderr,\"SWIG:mzscheme:%s\\n\",extra_paths[i]);\n\t}\n      }\n    }\n\n    {\n#ifdef MZ_DYNLOAD_LIBS\n      char *libs=(char *) malloc((strlen(MZ_DYNLOAD_LIBS)+1)*sizeof(char));\n      strcpy(libs,MZ_DYNLOAD_LIBS);\n#else\n      char *libs=(char *) malloc((strlen(_libs)+1)*sizeof(char));\n      strcpy(libs,_libs);\n#endif\n      \n      for(i=0,n=strlen(libs),k=0;i<n;i++) {\n\tif (libs[i]==',') { k+=1; }\n      }\n      k+=1;\n      mz_dlopen_libraries=(char **) malloc(sizeof(char *)*(k+1));\n      mz_dlopen_libraries[0]=libs;\n      for(i=0,k=1,n=strlen(libs);i<n;i++) {\n\tif (libs[i]==',') {\n\t  libs[i]='\\0';\n\t  mz_dlopen_libraries[k++]=&libs[i+1];\n\t  i+=1;\n\t}\n      }\n      \n      if (mz_dynload_debug) {\n\tfprintf(stderr,\"k=%d\\n\",k);\n      }\n      mz_dlopen_libraries[k]=NULL;\n      \n      free(EP);\n    }\n  }\n\n  static void *mz_load_function(char *function)\n  {\n    int mz_dynload_debug=(1==0);\n    \n    {\n      char *dbg=getenv(\"MZ_DYNLOAD_DEBUG\");\n      if (dbg!=NULL) {\n\tmz_dynload_debug=atoi(dbg);\n      }\n    }\n\n    if (mz_dlopen_libraries==NULL) {\n      return NULL;\n    }\n    else {\n      if (mz_libraries==NULL) {\n        int i,n;\n        for(n=0;mz_dlopen_libraries[n]!=NULL;n++);\n\tif (mz_dynload_debug) {\n\t  fprintf(stderr,\"SWIG:mzscheme:n=%d\\n\",n);\n\t}\n        mz_libraries=(void **) malloc(sizeof(void*)*n);\n        for(i=0;i<n;i++) { \n\t  if (mz_dynload_debug) {\n\t   fprintf(stderr,\"SWIG:mzscheme:loading %s\\n\",mz_dlopen_libraries[i]);\n\t  }\n#ifdef __OS_WIN32\n\t  mz_libraries[i]=(void *) LoadLibrary(mz_dlopen_libraries[i]); \n#else\n\t  mz_libraries[i]=(void *) dlopen(mz_dlopen_libraries[i],RTLD_LAZY); \n#endif\n\t  if (mz_libraries[i]==NULL) {\n\t    int k;\n\t    char *libp;\n\t    for(k=0;mz_dynload_libpaths[k]!=NULL && mz_libraries[i]==NULL;k++) {\n\t      int L=strlen(mz_dynload_libpaths[k])+strlen(\"\\\\\")+strlen(mz_dlopen_libraries[i])+1;\n\t      libp=(char *) malloc(L*sizeof(char));\n#ifdef __OS_WIN32\n\t      sprintf(libp,\"%s\\\\%s\",mz_dynload_libpaths[k],mz_dlopen_libraries[i]);\n\t      mz_libraries[i]=(void *) LoadLibrary(libp); \n#else\n\t      sprintf(libp,\"%s/%s\",mz_dynload_libpaths[k],mz_dlopen_libraries[i]);\n\t      mz_libraries[i]=(void *) dlopen(libp,RTLD_LAZY); \n#endif\n\t      if (mz_dynload_debug) {\n\t\tfprintf(stderr,\"SWIG:mzscheme:trying %s --> %p\\n\",libp,mz_libraries[i]);\n\t      }\n\t      free(libp);\n\t    }\n\t  }\n        }\n      }\n      {\n        int i;\n        void *func=NULL;\n\n        for(i=0;mz_dlopen_libraries[i]!=NULL && func==NULL;i++) {\n          if (mz_libraries[i]!=NULL) {\n#ifdef __OS_WIN32\n            func=GetProcAddress(mz_libraries[i],function);\n#else\n            func=dlsym(mz_libraries[i],function);\n#endif\n          }\n\t  if (mz_dynload_debug) {\n\t    fprintf(stderr,\n\t\t    \"SWIG:mzscheme:library:%s;dlopen=%p,function=%s,func=%p\\n\",\n\t\t    mz_dlopen_libraries[i],mz_libraries[i],function,func\n\t\t    );\n\t  }\n        }\n\n        return func;\n      }\n    }\n  }\n\n/* The interpreter will store a pointer to this structure in a global\n   variable called swig-runtime-data-type-pointer.  The instance of this\n   struct is only used if no other module has yet been loaded */\nstruct swig_mzscheme_runtime_data {\n  swig_module_info *module_head;\n  Scheme_Type type;\n};\nstatic struct swig_mzscheme_runtime_data swig_mzscheme_runtime_data;\n\n\nstatic swig_module_info *\nSWIG_MzScheme_GetModule(Scheme_Env *env) {\n  Scheme_Object *pointer, *symbol;\n  struct swig_mzscheme_runtime_data *data;\n\n  /* first check if pointer already created */\n  symbol = scheme_intern_symbol(\"swig-runtime-data-type-pointer\" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);\n  pointer = scheme_lookup_global(symbol, env);\n  if (pointer && SCHEME_CPTRP(pointer)) {\n      data = (struct swig_mzscheme_runtime_data *) SCHEME_CPTR_VAL(pointer);\n      swig_type = data->type;\n      return data->module_head;\n  } else {\n      return NULL;\n  }\n}\n\nstatic void\nSWIG_MzScheme_SetModule(Scheme_Env *env, swig_module_info *module) {\n  Scheme_Object *pointer, *symbol;\n  struct swig_mzscheme_runtime_data *data;\n\n  /* first check if pointer already created */\n  symbol = scheme_intern_symbol(\"swig-runtime-data-type-pointer\" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);\n  pointer = scheme_lookup_global(symbol, env);\n  if (pointer && SCHEME_CPTRP(pointer)) {\n    data = (struct swig_mzscheme_runtime_data *) SCHEME_CPTR_VAL(pointer);\n    swig_type = data->type;\n    data->module_head = module;\n  } else {\n    /* create a new type for wrapped pointer values */\n    swig_type = scheme_make_type((char *)\"swig\");\n    swig_mzscheme_runtime_data.module_head = module;\n    swig_mzscheme_runtime_data.type = swig_type;\n    \n    /* create a new pointer */\n#ifndef MZSCHEME30X\n    pointer = scheme_make_cptr((void *) &swig_mzscheme_runtime_data, \"swig_mzscheme_runtime_data\");\n#else\n    pointer = scheme_make_cptr((void *) &swig_mzscheme_runtime_data,\n\t\t\t       scheme_make_byte_string(\"swig_mzscheme_runtime_data\"));\n#endif\n    scheme_add_global_symbol(symbol, pointer, env);\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Tools/javascript/v8_shell.cxx": "#include <assert.h>\n#include <fcntl.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <v8.h>\n#include <vector>\n\n#include \"js_shell.h\"\n\ntypedef int (*V8ExtensionInitializer) (v8::Handle<v8::Object> module);\n\n// Note: these typedefs and defines are used to deal with  v8 API changes since version 3.19.00\n\n#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031903)\ntypedef v8::Handle<v8::Value> SwigV8ReturnValue;\ntypedef v8::Arguments SwigV8Arguments;\ntypedef v8::AccessorInfo SwigV8PropertyCallbackInfo;\n#define SWIGV8_RETURN(val) return scope.Close(val)\n#define SWIGV8_RETURN_INFO(val, info) return scope.Close(val)\n#else\ntypedef void SwigV8ReturnValue;\ntypedef v8::FunctionCallbackInfo<v8::Value> SwigV8Arguments;\ntypedef v8::PropertyCallbackInfo<v8::Value> SwigV8PropertyCallbackInfo;\n#define SWIGV8_RETURN(val) args.GetReturnValue().Set(val); return\n#define SWIGV8_RETURN_INFO(val, info) info.GetReturnValue().Set(val); return\n#endif\n\n\n#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032117)\n#define SWIGV8_HANDLESCOPE() v8::HandleScope scope\n#define SWIGV8_HANDLESCOPE_ESC() v8::HandleScope scope\n#define SWIGV8_ESCAPE(val) return scope.Close(val)\n#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032318)\n#define SWIGV8_HANDLESCOPE() v8::HandleScope scope(v8::Isolate::GetCurrent());\n#define SWIGV8_HANDLESCOPE_ESC() v8::HandleScope scope(v8::Isolate::GetCurrent());\n#define SWIGV8_ESCAPE(val) return scope.Close(val)\n#else\n#define SWIGV8_HANDLESCOPE() v8::HandleScope scope(v8::Isolate::GetCurrent());\n#define SWIGV8_HANDLESCOPE_ESC() v8::EscapableHandleScope scope(v8::Isolate::GetCurrent());\n#define SWIGV8_ESCAPE(val) return scope.Escape(val)\n#endif\n\n#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x032318)\n#define SWIGV8_CURRENT_CONTEXT() v8::Context::GetCurrent()\n#define SWIGV8_STRING_NEW(str) v8::String::New(str)\n#define SWIGV8_FUNCTEMPLATE_NEW(func) v8::FunctionTemplate::New(func)\n#define SWIGV8_OBJECT_NEW() v8::Object::New()\n#define SWIGV8_EXTERNAL_NEW(val) v8::External::New(val)\n#define SWIGV8_UNDEFINED() v8::Undefined()\n#else\n#define SWIGV8_CURRENT_CONTEXT() v8::Isolate::GetCurrent()->GetCurrentContext()\n#define SWIGV8_STRING_NEW(str) v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), str)\n#define SWIGV8_FUNCTEMPLATE_NEW(func) v8::FunctionTemplate::New(v8::Isolate::GetCurrent(), func)\n#define SWIGV8_OBJECT_NEW() v8::Object::New(v8::Isolate::GetCurrent())\n#define SWIGV8_EXTERNAL_NEW(val) v8::External::New(v8::Isolate::GetCurrent(), val)\n#define SWIGV8_UNDEFINED() v8::Undefined(v8::Isolate::GetCurrent())\n#endif\n\n\n#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)\ntypedef v8::Persistent<v8::Context> SwigV8Context;\n#else\ntypedef v8::Local<v8::Context> SwigV8Context;\n#endif\n\nclass V8Shell: public JSShell {\n\npublic:\n  V8Shell();\n\n  virtual ~V8Shell();\n\n  virtual bool RunScript(const std::string &scriptPath);\n\n  virtual bool RunShell();\n\n\nprotected:\n\n  virtual bool InitializeEngine();\n\n  virtual bool ExecuteScript(const std::string &source, const std::string &scriptPath);\n\n  virtual bool DisposeEngine();\n\nprivate:\n\n  v8::Handle<v8::Value> Import(const std::string &moduleName);\n\n  SwigV8Context CreateShellContext();\n\n  void ReportException(v8::TryCatch *handler);\n\n  static SwigV8ReturnValue Print(const SwigV8Arguments &args);\n\n  static SwigV8ReturnValue Require(const SwigV8Arguments &args);\n\n  static SwigV8ReturnValue Quit(const SwigV8Arguments &args);\n\n  static SwigV8ReturnValue Version(const SwigV8Arguments &args);\n\n  static const char* ToCString(const v8::String::Utf8Value &value);\n\n};\n\n#ifdef __GNUC__\n#include <dlfcn.h>\n#define LOAD_SYMBOL(handle, name) dlsym(handle, name)\n#else\n#error \"implement dll loading\"\n#endif\n\nV8Shell::V8Shell() {}\n\nV8Shell::~V8Shell() {}\n\nbool V8Shell::RunScript(const std::string &scriptPath) {\n  std::string source = ReadFile(scriptPath);\n\n  v8::Isolate *isolate = v8::Isolate::New();\n  v8::Isolate::Scope isolate_scope(isolate);\n\n  SWIGV8_HANDLESCOPE();\n\n  SwigV8Context context = CreateShellContext();\n\n  if (context.IsEmpty()) {\n      printf(\"Could not create context.\\n\");\n      return false;\n  }\n\n  context->Enter();\n\n  // Store a pointer to this shell for later use\n\n  v8::Handle<v8::Object> global = context->Global();\n  v8::Local<v8::External> __shell__ = SWIGV8_EXTERNAL_NEW((void*) (long) this);\n\n  global->SetHiddenValue(SWIGV8_STRING_NEW(\"__shell__\"), __shell__);\n\n  // Node.js compatibility: make `print` available as `console.log()`\n  ExecuteScript(\"var console = {}; console.log = print;\", \"<console>\");\n\n  bool success = ExecuteScript(source, scriptPath);\n\n  // Cleanup\n\n  context->Exit();\n\n#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)\n    context.Dispose();\n#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)\n    context.Dispose(v8::Isolate::GetCurrent());\n#else\n//    context.Dispose();\n#endif\n\n//  v8::V8::Dispose();\n\n  return success;\n}\n\nbool V8Shell::RunShell() {\n  SWIGV8_HANDLESCOPE();\n\n  SwigV8Context context = CreateShellContext();\n\n  if (context.IsEmpty()) {\n      printf(\"Could not create context.\\n\");\n      return false;\n  }\n\n  context->Enter();\n\n  v8::Context::Scope context_scope(context);\n\n  ExecuteScript(\"var console = {}; console.log = print;\", \"<console>\");\n\n  static const int kBufferSize = 1024;\n  while (true) {\n    char buffer[kBufferSize];\n    printf(\"> \");\n    char *str = fgets(buffer, kBufferSize, stdin);\n    if (str == NULL) break;\n    std::string source(str);\n    ExecuteScript(source, \"(shell)\");\n  }\n  printf(\"\\n\");\n\n  // Cleanup\n\n  context->Exit();\n\n#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031710)\n    context.Dispose();\n#elif (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)\n    context.Dispose(v8::Isolate::GetCurrent());\n#else\n//    context.Dispose();\n#endif\n\n//  v8::V8::Dispose();\n\n  return true;\n}\n\n\nbool V8Shell::InitializeEngine() {\n  return true;\n}\n\nbool V8Shell::ExecuteScript(const std::string &source, const std::string &name) {\n  SWIGV8_HANDLESCOPE();\n\n  v8::TryCatch try_catch;\n  v8::Handle<v8::Script> script = v8::Script::Compile(SWIGV8_STRING_NEW(source.c_str()), SWIGV8_STRING_NEW(name.c_str()));\n\n  // Stop if script is empty\n  if (script.IsEmpty()) {\n    // Print errors that happened during compilation.\n    ReportException(&try_catch);\n    return false;\n  }\n\n  v8::Handle<v8::Value> result = script->Run();\n\n  // Print errors that happened during execution.\n  if (try_catch.HasCaught()) {\n    ReportException(&try_catch);\n    return false;\n  } else {\n    return true;\n  }\n}\n\nbool V8Shell::DisposeEngine() {\n  return true;\n}\n\nSwigV8Context V8Shell::CreateShellContext() {\n  // Create a template for the global object.\n  v8::Handle<v8::ObjectTemplate> global = v8::ObjectTemplate::New();\n\n  // Bind global functions\n  global->Set(SWIGV8_STRING_NEW(\"print\"), SWIGV8_FUNCTEMPLATE_NEW(V8Shell::Print));\n  global->Set(SWIGV8_STRING_NEW(\"quit\"), SWIGV8_FUNCTEMPLATE_NEW(V8Shell::Quit));\n  global->Set(SWIGV8_STRING_NEW(\"require\"), SWIGV8_FUNCTEMPLATE_NEW(V8Shell::Require));\n  global->Set(SWIGV8_STRING_NEW(\"version\"), SWIGV8_FUNCTEMPLATE_NEW(V8Shell::Version));\n\n#if (V8_MAJOR_VERSION-0) < 4 && (SWIG_V8_VERSION < 0x031900)\n  SwigV8Context context = v8::Context::New(NULL, global);\n  return context;\n#else\n  SwigV8Context context = v8::Context::New(v8::Isolate::GetCurrent(), NULL, global);\n  return context;\n#endif\n}\n\nv8::Handle<v8::Value> V8Shell::Import(const std::string &module_path)\n{\n  SWIGV8_HANDLESCOPE_ESC();\n\n  HANDLE library;\n  std::string module_name = LoadModule(module_path, &library);\n\n  std::string symname = std::string(module_name).append(\"_initialize\");\n\n  V8ExtensionInitializer init_function = reinterpret_cast<V8ExtensionInitializer>((long) LOAD_SYMBOL(library, symname.c_str()));\n\n  if(init_function == 0) {\n    printf(\"Could not find initializer function.\");\n\n    return SWIGV8_UNDEFINED();\n  }\n\n  v8::Local<v8::Object> module = SWIGV8_OBJECT_NEW();\n  init_function(module);\n\n  SWIGV8_ESCAPE(module);\n}\n\nSwigV8ReturnValue V8Shell::Print(const SwigV8Arguments &args) {\n  SWIGV8_HANDLESCOPE();\n\n  bool first = true;\n  for (int i = 0; i < args.Length(); i++) {\n\n    if (first) {\n      first = false;\n    } else {\n      printf(\" \");\n    }\n    v8::String::Utf8Value str(args[i]);\n    const char *cstr = V8Shell::ToCString(str);\n    printf(\"%s\", cstr);\n  }\n  printf(\"\\n\");\n  fflush(stdout);\n\n  SWIGV8_RETURN(SWIGV8_UNDEFINED());\n}\n\nSwigV8ReturnValue V8Shell::Require(const SwigV8Arguments &args) {\n  SWIGV8_HANDLESCOPE();\n\n  if (args.Length() != 1) {\n    printf(\"Illegal arguments for `require`\");\n  };\n\n  v8::String::Utf8Value str(args[0]);\n  const char *cstr = V8Shell::ToCString(str);\n  std::string moduleName(cstr);\n\n  v8::Local<v8::Object> global = SWIGV8_CURRENT_CONTEXT()->Global();\n\n  v8::Local<v8::Value> hidden = global->GetHiddenValue(SWIGV8_STRING_NEW(\"__shell__\"));\n  v8::Local<v8::External> __shell__ = v8::Local<v8::External>::Cast(hidden);\n  V8Shell *_this = (V8Shell *) (long) __shell__->Value();\n\n  v8::Handle<v8::Value> module = _this->Import(moduleName);\n\n  SWIGV8_RETURN(module);\n}\n\nSwigV8ReturnValue V8Shell::Quit(const SwigV8Arguments &args) {\n  SWIGV8_HANDLESCOPE();\n\n  int exit_code = args[0]->Int32Value();\n  fflush(stdout);\n  fflush(stderr);\n  exit(exit_code);\n\n  SWIGV8_RETURN(SWIGV8_UNDEFINED());\n}\n\nSwigV8ReturnValue V8Shell::Version(const SwigV8Arguments &args) {\n    SWIGV8_HANDLESCOPE();\n    SWIGV8_RETURN(SWIGV8_STRING_NEW(v8::V8::GetVersion()));\n}\n\nvoid V8Shell::ReportException(v8::TryCatch *try_catch) {\n  SWIGV8_HANDLESCOPE();\n\n  v8::String::Utf8Value exception(try_catch->Exception());\n  const char *exception_string = V8Shell::ToCString(exception);\n  v8::Handle<v8::Message> message = try_catch->Message();\n  if (message.IsEmpty()) {\n    // V8 didn't provide any extra information about this error; just\n    // print the exception.\n    printf(\"%s\\n\", exception_string);\n  } else {\n    // Print (filename):(line number): (message).\n    v8::String::Utf8Value filename(message->GetScriptResourceName());\n    const char *filename_string = V8Shell::ToCString(filename);\n    int linenum = message->GetLineNumber();\n    printf(\"%s:%i: %s\\n\", filename_string, linenum, exception_string);\n    // Print line of source code.\n    v8::String::Utf8Value sourceline(message->GetSourceLine());\n    const char *sourceline_string = V8Shell::ToCString(sourceline);\n    printf(\"%s\\n\", sourceline_string);\n    // Print wavy underline (GetUnderline is deprecated).\n    int start = message->GetStartColumn();\n    for (int i = 0; i < start; i++) {\n      printf(\" \");\n    }\n    int end = message->GetEndColumn();\n    for (int i = start; i < end; i++) {\n      printf(\"^\");\n    }\n    printf(\"\\n\");\n    v8::String::Utf8Value stack_trace(try_catch->StackTrace());\n    if (stack_trace.length() > 0) {\n      const char *stack_trace_string = V8Shell::ToCString(stack_trace);\n      printf(\"%s\\n\", stack_trace_string);\n    }\n  }\n}\n\n// Extracts a C string from a V8 Utf8Value.\nconst char *V8Shell::ToCString(const v8::String::Utf8Value &value) {\n  return *value ? *value : \"<string conversion failed>\";\n}\n\nJSShell *V8Shell_Create() {\n  return new V8Shell();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Tools/javascript/jsc_shell.cxx": "#include <JavaScriptCore/JavaScript.h>\n\n#include \"js_shell.h\"\n\n#include <iostream>\n#include <stdio.h>\n\n#ifdef __GNUC__\n#include <dlfcn.h>\n#define LOAD_SYMBOL(handle, name) dlsym(handle, name)\n#else\n#error \"implement dll loading\"\n#endif\n\nclass JSCShell: public JSShell {\n\ntypedef int (*JSCIntializer)(JSGlobalContextRef context, JSObjectRef *module);\n\npublic:\n\n  JSCShell() {};\n\n  virtual ~JSCShell();\n\nprotected:\n\n  virtual bool InitializeEngine();\n\n  virtual bool ExecuteScript(const std::string& source, const std::string& scriptPath);\n\n  virtual bool DisposeEngine();\n\nprivate:\n\n  JSObjectRef Import(const std::string &moduleName);\n\n  static JSValueRef Print(JSContextRef context, JSObjectRef object, JSObjectRef globalobj, size_t argc, const JSValueRef args[], JSValueRef* ex);\n\n  static JSValueRef Require(JSContextRef context, JSObjectRef object, JSObjectRef globalobj, size_t argc, const JSValueRef args[], JSValueRef* ex);\n\n  static bool RegisterFunction(JSGlobalContextRef context, JSObjectRef object, const char* functionName, JSObjectCallAsFunctionCallback cbFunction);\n\n  static void PrintError(JSContextRef, JSValueRef);\n\nprivate:\n\n  JSGlobalContextRef context;\n};\n\nJSCShell::~JSCShell() {\n  if(context != 0) {\n    JSGlobalContextRelease(context);\n    context = 0;\n  }\n}\n\nbool JSCShell::InitializeEngine() {\n  if(context != 0) {\n    JSGlobalContextRelease(context);\n    context = 0;\n  }\n  // TODO: check for initialization errors\n  context = JSGlobalContextCreate(NULL);\n  if(context == 0) return false;\n  JSObjectRef globalObject = JSContextGetGlobalObject(context);\n\n  // store this for later use\n  JSClassDefinition __shell_classdef__ = JSClassDefinition();\n\n  JSClassRef __shell_class__ = JSClassCreate(&__shell_classdef__);\n  JSObjectRef __shell__ = JSObjectMake(context, __shell_class__, 0);\n  bool success = JSObjectSetPrivate(__shell__, (void*) (long) this);\n  if (!success) {\n    std::cerr << \"Could not register the shell in the Javascript context\" << std::endl;\n    return false;\n  }\n  JSStringRef shellKey = JSStringCreateWithUTF8CString(\"__shell__\");\n  JSObjectSetProperty(context, globalObject, shellKey, __shell__, kJSPropertyAttributeReadOnly, NULL);\n  JSStringRelease(shellKey);\n\n  JSCShell::RegisterFunction(context, globalObject, \"print\", JSCShell::Print);\n  JSCShell::RegisterFunction(context, globalObject, \"require\", JSCShell::Require);\n\n  return true;\n}\n\nbool JSCShell::ExecuteScript(const std::string& source, const std::string& scriptPath) {\n  JSStringRef jsScript;\n  JSStringRef sourceURL;\n  JSValueRef ex;\n  jsScript = JSStringCreateWithUTF8CString(source.c_str());\n  sourceURL = JSStringCreateWithUTF8CString(scriptPath.c_str());\n  JSValueRef jsResult = JSEvaluateScript(context, jsScript, 0, sourceURL, 0, &ex);\n  JSStringRelease(jsScript);\n  if (jsResult == NULL && ex != NULL) {\n      JSCShell::PrintError(context, ex);\n      return false;\n  }\n  return true;\n}\n\nbool JSCShell::DisposeEngine() {\n  JSGlobalContextRelease(context);\n  context = 0;\n  return true;\n}\n\nJSValueRef JSCShell::Print(JSContextRef context, JSObjectRef object,\n                           JSObjectRef globalobj, size_t argc,\n                           const JSValueRef args[], JSValueRef* ex) {\n  if (argc > 0)\n  {\n    JSStringRef string = JSValueToStringCopy(context, args[0], NULL);\n    size_t numChars = JSStringGetMaximumUTF8CStringSize(string);\n    char *stringUTF8 = new char[numChars];\n    JSStringGetUTF8CString(string, stringUTF8, numChars);\n    printf(\"%s\\n\", stringUTF8);\n\n    delete[] stringUTF8;\n  }\n\n  return JSValueMakeUndefined(context);\n}\n\n// Attention: this feature should not create too high expectations.\n// It is only capable of loading things relative to the execution directory\n// and not relative to the parent script.\nJSValueRef JSCShell::Require(JSContextRef context, JSObjectRef object,\n                           JSObjectRef globalObj, size_t argc,\n                           const JSValueRef args[], JSValueRef* ex) {\n  JSObjectRef module;\n\n  JSStringRef shellKey = JSStringCreateWithUTF8CString(\"__shell__\");\n  JSValueRef shellAsVal = JSObjectGetProperty(context, globalObj, shellKey, NULL);\n  JSStringRelease(shellKey);\n  JSObjectRef shell = JSValueToObject(context, shellAsVal, 0);\n  JSCShell *_this = (JSCShell*) (long) JSObjectGetPrivate(shell);\n\n  if (argc > 0)\n  {\n    JSStringRef string = JSValueToStringCopy(context, args[0], NULL);\n    size_t numChars = JSStringGetMaximumUTF8CStringSize(string);\n    char *stringUTF8 = new char[numChars];\n    JSStringGetUTF8CString(string, stringUTF8, numChars);\n\n    std::string modulePath(stringUTF8);\n    module = _this->Import(modulePath);\n\n    delete[] stringUTF8;\n  }\n\n  if (module) {\n    return module;\n  } else {\n    printf(\"Ooops.\\n\");\n    return JSValueMakeUndefined(context);\n  }\n}\n\nJSObjectRef JSCShell::Import(const std::string& module_path) {\n\n  HANDLE library;\n  std::string module_name = LoadModule(module_path, &library);\n\n  if (library == 0) {\n    printf(\"Could not load module.\");\n    return 0;\n  }\n\n  std::string symname = std::string(module_name).append(\"_initialize\");\n\n  JSCIntializer init_function = reinterpret_cast<JSCIntializer>((long) LOAD_SYMBOL(library, symname.c_str()));\n  if(init_function == 0) {\n    printf(\"Could not find module's initializer function.\");\n    return 0;\n  }\n\n  JSObjectRef module;\n  init_function(context, &module);\n\n  return module;\n}\n\nbool JSCShell::RegisterFunction(JSGlobalContextRef context, JSObjectRef object,\n                        const char* functionName, JSObjectCallAsFunctionCallback callback) {\n    JSStringRef js_functionName = JSStringCreateWithUTF8CString(functionName);\n    JSObjectSetProperty(context, object, js_functionName,\n                        JSObjectMakeFunctionWithCallback(context, js_functionName, callback),\n                        kJSPropertyAttributeNone, NULL);\n    JSStringRelease(js_functionName);\n    return true;\n}\n\nvoid JSCShell::PrintError(JSContextRef ctx, JSValueRef err) {\n  char *buffer;\n  size_t length;\n\n  JSStringRef string = JSValueToStringCopy(ctx, err, 0);\n  length = JSStringGetLength(string);\n  buffer   = new char[length+1];\n  JSStringGetUTF8CString(string, buffer, length+1);\n  std::string errMsg(buffer);\n  JSStringRelease(string);\n  delete[] buffer;\n\n  JSObjectRef errObj = JSValueToObject(ctx, err, 0);\n\n  if(errObj == 0) {\n    std::cerr << errMsg << std::endl;\n    return;\n  }\n\n  JSStringRef sourceURLKey = JSStringCreateWithUTF8CString(\"sourceURL\");\n  JSStringRef sourceURLStr = JSValueToStringCopy(ctx, JSObjectGetProperty(ctx, errObj, sourceURLKey, 0), 0);\n  length = JSStringGetLength(sourceURLStr);\n  buffer   = new char[length+1];\n  JSStringGetUTF8CString(sourceURLStr, buffer, length+1);\n  std::string sourceURL(buffer);\n  delete[] buffer;\n  JSStringRelease(sourceURLStr);\n  JSStringRelease(sourceURLKey);\n\n  JSStringRef lineKey = JSStringCreateWithUTF8CString(\"line\");\n  JSValueRef jsLine = JSObjectGetProperty(ctx, errObj, lineKey, 0);\n  int line = (int) JSValueToNumber(ctx, jsLine, 0);\n  JSStringRelease(lineKey);\n\n  std::cerr << sourceURL << \":\" << line << \":\" << errMsg << std::endl;\n}\n\nJSShell* JSCShell_Create() {\n  return new JSCShell();\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Doc/Manual/swig16.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Doc/Manual/ch2.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Doc/Manual/fortran-data.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Doc/Manual/android-simple.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Doc/Manual/android-class.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Examples/test-suite/enum_thorough.i",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Examples/test-suite/char_constant.i",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Examples/test-suite/chartest.i",
        "/tmp/vanessa/spack-stage/spack-stage-swig-4.0.2-fortran-g56ercorgz6iqsj2oxpaerfkjervkynd/spack-src/Examples/test-suite/ruby/char_constant_runme.rb"
    ],
    "total_files": 5410
}