{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Lib/mzscheme/mzrun.swg": "/* -----------------------------------------------------------------------------\n * See the LICENSE file for information on copyright, usage and redistribution\n * of SWIG, and the README file for authors - http://www.swig.org/release.html.\n *\n * mzrun.swg\n * ----------------------------------------------------------------------------- */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <escheme.h>\n#include <assert.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* Common SWIG API */\n  \n#define SWIG_ConvertPtr(s, result, type, flags) \\\n  SWIG_MzScheme_ConvertPtr(s, result, type, flags)\n#define SWIG_NewPointerObj(ptr, type, owner) \\\n  SWIG_MzScheme_NewPointerObj((void *)ptr, type, owner)\n#define SWIG_MustGetPtr(s, type, argnum, flags) \\\n  SWIG_MzScheme_MustGetPtr(s, type, argnum, flags, FUNC_NAME, argc, argv)\n\n#define SWIG_contract_assert(expr,msg) \\\n if (!(expr)) { \\\n    char *m=(char *) scheme_malloc(strlen(msg)+1000); \\\n    sprintf(m,\"SWIG contract, assertion failed: function=%s, message=%s\", \\\n            (char *) FUNC_NAME,(char *) msg); \\\n    scheme_signal_error(m); \\\n }\n\n/* Runtime API */\n#define SWIG_GetModule(clientdata) SWIG_MzScheme_GetModule((Scheme_Env *)(clientdata))\n#define SWIG_SetModule(clientdata, pointer) SWIG_MzScheme_SetModule((Scheme_Env *) (clientdata), pointer)\n#define SWIG_MODULE_CLIENTDATA_TYPE Scheme_Env *\n\n/* MzScheme-specific SWIG API */\n  \n#define SWIG_malloc(size) SWIG_MzScheme_Malloc(size, FUNC_NAME)\n#define SWIG_free(mem) free(mem)\n#define SWIG_NewStructFromPtr(ptr,type) \\\n        _swig_convert_struct_##type##(ptr)\n\n#define MAXVALUES 6\n#define swig_make_boolean(b) (b ? scheme_true : scheme_false)\n\nstatic long\nSWIG_convert_integer(Scheme_Object *o,\n\t\t     long lower_bound, long upper_bound, \n\t\t     const char *func_name, int argnum, int argc,\n\t\t     Scheme_Object **argv)\n{\n  long value;\n  int status = scheme_get_int_val(o, &value);\n  if (!status)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  if (value < lower_bound || value > upper_bound)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  return value;\n}\n\nstatic int\nSWIG_is_integer(Scheme_Object *o)\n{\n  long value;\n  return scheme_get_int_val(o, &value);\n}\n\nstatic unsigned long\nSWIG_convert_unsigned_integer(Scheme_Object *o,\n\t\t\t      unsigned long lower_bound, unsigned long upper_bound, \n\t\t\t      const char *func_name, int argnum, int argc,\n\t\t\t      Scheme_Object **argv)\n{\n  unsigned long value;\n  int status = scheme_get_unsigned_int_val(o, &value);\n  if (!status)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  if (value < lower_bound || value > upper_bound)\n    scheme_wrong_type(func_name, \"integer\", argnum, argc, argv);\n  return value;\n}\n\nstatic int\nSWIG_is_unsigned_integer(Scheme_Object *o)\n{\n  unsigned long value;\n  return scheme_get_unsigned_int_val(o, &value);\n}\n  \n/* ----------------------------------------------------------------------- \n * mzscheme 30X support code\n * Contributed by Hans Oesterholt\n * ----------------------------------------------------------------------- */\n\n#ifndef SCHEME_STR_VAL\n#define MZSCHEME30X 1\n#endif\n\n#ifdef MZSCHEME30X \n/* \n * This is MZSCHEME 299.100 or higher (30x).  From version 299.100 of\n * mzscheme upwards, strings are in unicode. These functions convert\n * to and from utf8 encodings of these strings.  NB! strlen(s) will be\n * the size in bytes of the string, not the actual length.\n */\n#define SCHEME_STR_VAL(obj)  \t       SCHEME_BYTE_STR_VAL(scheme_char_string_to_byte_string(obj))\n#define SCHEME_STRLEN_VAL(obj)         SCHEME_BYTE_STRLEN_VAL(scheme_char_string_to_byte_string(obj))\n#define SCHEME_STRINGP(obj)            SCHEME_CHAR_STRINGP(obj)\n#define scheme_make_string(s)          scheme_make_utf8_string(s)\n#define scheme_make_sized_string(s,l)  scheme_make_sized_utf8_string(s,l)\n#define scheme_make_sized_offset_string(s,d,l) \\\n                   scheme_make_sized_offset_utf8_string(s,d,l)\n#define SCHEME_MAKE_STRING(s) scheme_make_utf8_string(s)\n#else\n#define SCHEME_MAKE_STRING(s) scheme_make_string_without_copying(s)\n#endif\n/* ----------------------------------------------------------------------- \n * End of mzscheme 30X support code \n * ----------------------------------------------------------------------- */\n  \nstruct swig_mz_proxy {\n  Scheme_Type mztype;\n  swig_type_info *type;\n  void *object;\n};\n\nstatic Scheme_Type swig_type;\n\nstatic void \nmz_free_swig(void *p, void *data) {\n  struct swig_mz_proxy *proxy = (struct swig_mz_proxy *) p;\n  if (SCHEME_NULLP((Scheme_Object*)p) || SCHEME_TYPE((Scheme_Object*)p) != swig_type)\n    return;\n  if (proxy->type) {\n    if (proxy->type->clientdata) {\n      ((Scheme_Prim *)proxy->type->clientdata)(1, (Scheme_Object **)&proxy);\n    }\n  }\n}\n\nstatic Scheme_Object *\nSWIG_MzScheme_NewPointerObj(void *ptr, swig_type_info *type, int owner) {\n  struct swig_mz_proxy *new_proxy;\n  new_proxy = (struct swig_mz_proxy *) scheme_malloc(sizeof(struct swig_mz_proxy));\n  new_proxy->mztype = swig_type;\n  new_proxy->type = type;\n  new_proxy->object = ptr;\n  if (owner) {\n    scheme_add_finalizer(new_proxy, mz_free_swig, NULL);\n  }\n  return (Scheme_Object *) new_proxy;\n}\n\nstatic int\nSWIG_MzScheme_ConvertPtr(Scheme_Object *s, void **result, swig_type_info *type, int flags) {\n  swig_cast_info *cast;\n\n  if (SCHEME_NULLP(s)) {\n    *result = NULL;\n    return 0;\n  } else if (SCHEME_TYPE(s) == swig_type) {\n    struct swig_mz_proxy *proxy = (struct swig_mz_proxy *) s;\n    if (type) {\n      cast = SWIG_TypeCheckStruct(proxy->type, type);\n      if (cast) {\n        int newmemory = 0;\n        *result = SWIG_TypeCast(cast, proxy->object, &newmemory);\n        assert(!newmemory); /* newmemory handling not yet implemented */\n        return 0;\n      } else {\n        return 1;\n      }\n    } else {\n      *result = proxy->object;\n      return 0;\n    }\n  }\n  return 1;\n}\n\nstatic SWIGINLINE void *\nSWIG_MzScheme_MustGetPtr(Scheme_Object *s, swig_type_info *type, \n                         int argnum, int flags, const char *func_name,\n                         int argc, Scheme_Object **argv) {\n  void *result;\n  if (SWIG_MzScheme_ConvertPtr(s, &result, type, flags)) {\n    scheme_wrong_type(func_name, type->str ? type->str : \"void *\", argnum - 1, argc, argv);\n  }\n  return result;\n}\n\nstatic SWIGINLINE void *\nSWIG_MzScheme_Malloc(size_t size, const char *func_name) {\n  void *p = malloc(size);\n  if (p == NULL) {\n    scheme_signal_error(\"swig-memory-error\");\n  } else return p;\n}\n\nstatic Scheme_Object *\nSWIG_MzScheme_PackageValues(int num, Scheme_Object **values) {\n    /* ignore first value if void */\n    if (num > 0 && SCHEME_VOIDP(values[0]))\n\tnum--, values++;\n    if (num == 0) return scheme_void;\n    else if (num == 1) return values[0];\n    else return scheme_values(num, values);\n}\n\n#ifndef scheme_make_inspector\n#define scheme_make_inspector(x,y) \\\n        _scheme_apply(scheme_builtin_value(\"make-inspector\"), x, y)\n#endif\n\n/* Function to create a new struct. */\nstatic Scheme_Object *\nSWIG_MzScheme_new_scheme_struct (Scheme_Env* env, const char* basename, \n\t\t\t\t int num_fields, char** field_names)\n{\n    Scheme_Object *new_type;\n    int count_out, i;\n    Scheme_Object **struct_names;\n    Scheme_Object **vals;\n    Scheme_Object **a = (Scheme_Object**) \\\n        scheme_malloc(num_fields*sizeof(Scheme_Object*));\n    \n    for (i=0; i<num_fields; ++i) {\n        a[i] = (Scheme_Object*) scheme_intern_symbol(field_names[i]);\n    }\n\n    new_type = scheme_make_struct_type(scheme_intern_symbol(basename),\n                                       NULL /*super_type*/,\n                                       scheme_make_inspector(0, NULL),\n                                       num_fields,\n                                       0 /* auto_fields */,\n                                       NULL /* auto_val */,\n                                       NULL /* properties */\n#ifdef MZSCHEME30X\n\t\t\t\t       ,NULL /* Guard */\n#endif\n\t\t\t\t       );\n    struct_names = scheme_make_struct_names(scheme_intern_symbol(basename),\n                                            scheme_build_list(num_fields,a),\n                                            0 /*flags*/, &count_out);\n    vals = scheme_make_struct_values(new_type, struct_names, count_out, 0);\n\n    for (i = 0; i < count_out; i++)\n        scheme_add_global_symbol(struct_names[i], vals[i],env);\n\n    return new_type;\n}\n\n/*** DLOPEN PATCH ******************************************************\n * Contributed by Hans Oesterholt-Dijkema (jan. 2006)\n ***********************************************************************/\n\n#if defined(_WIN32) || defined(__WIN32__)\n#define __OS_WIN32\n#endif\n\n#ifdef __OS_WIN32\n#include <windows.h>\n#else\n#include <dlfcn.h>\n#endif\n\n  static char **mz_dlopen_libraries=NULL;\n  static void **mz_libraries=NULL;\n  static char **mz_dynload_libpaths=NULL;\n\n  static void mz_set_dlopen_libraries(const char *_libs)\n  {\n    int   i,k,n;\n    int   mz_dynload_debug=(1==0);\n    char *extra_paths[1000];\n    char *EP;\n    \n    {\n      char *dbg=getenv(\"MZ_DYNLOAD_DEBUG\");\n      if (dbg!=NULL) {\n\tmz_dynload_debug=atoi(dbg);\n      }\n    }\n\n    {\n      char *ep=getenv(\"MZ_DYNLOAD_LIBPATH\");\n      int   i,k,j;\n      k=0;\n      if (ep!=NULL) {\n\tEP=strdup(ep);\n\tfor(i=0,j=0;EP[i]!='\\0';i++) {\n\t  if (EP[i]==':') {\n\t    EP[i]='\\0';\n\t    extra_paths[k++]=&EP[j];\n\t    j=i+1;\n\t  }\n\t}\n\tif (j!=i) {\n\t  extra_paths[k++]=&EP[j];\n\t}\n      }\n      else {\n\tEP=strdup(\"\");\n      }\n      extra_paths[k]=NULL;\n      k+=1;\n\n      if (mz_dynload_debug) {\n\tfprintf(stderr,\"SWIG:mzscheme:MZ_DYNLOAD_LIBPATH=%s\\n\",(ep==NULL) ? \"(null)\" : ep);\n\tfprintf(stderr,\"SWIG:mzscheme:extra_paths[%d]\\n\",k-1);\n\tfor(i=0;i<k-1;i++) {\n\t  fprintf(stderr,\"SWIG:mzscheme:extra_paths[%d]=%s\\n\",i,extra_paths[i]);\n\t}\n      }\n\n      mz_dynload_libpaths=(char **) malloc(sizeof(char *)*k);\n      for(i=0;i<k;i++) {\n\tif (extra_paths[i]!=NULL) {\n\t  mz_dynload_libpaths[i]=strdup(extra_paths[i]);\n\t}\n\telse {\n\t  mz_dynload_libpaths[i]=NULL;\n\t}\n      }\n\n      if (mz_dynload_debug) {\n\tint i;\n\tfor(i=0;extra_paths[i]!=NULL;i++) {\n\t  fprintf(stderr,\"SWIG:mzscheme:%s\\n\",extra_paths[i]);\n\t}\n      }\n    }\n\n    {\n#ifdef MZ_DYNLOAD_LIBS\n      char *libs=(char *) malloc((strlen(MZ_DYNLOAD_LIBS)+1)*sizeof(char));\n      strcpy(libs,MZ_DYNLOAD_LIBS);\n#else\n      char *libs=(char *) malloc((strlen(_libs)+1)*sizeof(char));\n      strcpy(libs,_libs);\n#endif\n      \n      for(i=0,n=strlen(libs),k=0;i<n;i++) {\n\tif (libs[i]==',') { k+=1; }\n      }\n      k+=1;\n      mz_dlopen_libraries=(char **) malloc(sizeof(char *)*(k+1));\n      mz_dlopen_libraries[0]=libs;\n      for(i=0,k=1,n=strlen(libs);i<n;i++) {\n\tif (libs[i]==',') {\n\t  libs[i]='\\0';\n\t  mz_dlopen_libraries[k++]=&libs[i+1];\n\t  i+=1;\n\t}\n      }\n      \n      if (mz_dynload_debug) {\n\tfprintf(stderr,\"k=%d\\n\",k);\n      }\n      mz_dlopen_libraries[k]=NULL;\n      \n      free(EP);\n    }\n  }\n\n  static void *mz_load_function(char *function)\n  {\n    int mz_dynload_debug=(1==0);\n    \n    {\n      char *dbg=getenv(\"MZ_DYNLOAD_DEBUG\");\n      if (dbg!=NULL) {\n\tmz_dynload_debug=atoi(dbg);\n      }\n    }\n\n    if (mz_dlopen_libraries==NULL) {\n      return NULL;\n    }\n    else {\n      if (mz_libraries==NULL) {\n        int i,n;\n        for(n=0;mz_dlopen_libraries[n]!=NULL;n++);\n\tif (mz_dynload_debug) {\n\t  fprintf(stderr,\"SWIG:mzscheme:n=%d\\n\",n);\n\t}\n        mz_libraries=(void **) malloc(sizeof(void*)*n);\n        for(i=0;i<n;i++) { \n\t  if (mz_dynload_debug) {\n\t   fprintf(stderr,\"SWIG:mzscheme:loading %s\\n\",mz_dlopen_libraries[i]);\n\t  }\n#ifdef __OS_WIN32\n\t  mz_libraries[i]=(void *) LoadLibrary(mz_dlopen_libraries[i]); \n#else\n\t  mz_libraries[i]=(void *) dlopen(mz_dlopen_libraries[i],RTLD_LAZY); \n#endif\n\t  if (mz_libraries[i]==NULL) {\n\t    int k;\n\t    char *libp;\n\t    for(k=0;mz_dynload_libpaths[k]!=NULL && mz_libraries[i]==NULL;k++) {\n\t      int L=strlen(mz_dynload_libpaths[k])+strlen(\"\\\\\")+strlen(mz_dlopen_libraries[i])+1;\n\t      libp=(char *) malloc(L*sizeof(char));\n#ifdef __OS_WIN32\n\t      sprintf(libp,\"%s\\\\%s\",mz_dynload_libpaths[k],mz_dlopen_libraries[i]);\n\t      mz_libraries[i]=(void *) LoadLibrary(libp); \n#else\n\t      sprintf(libp,\"%s/%s\",mz_dynload_libpaths[k],mz_dlopen_libraries[i]);\n\t      mz_libraries[i]=(void *) dlopen(libp,RTLD_LAZY); \n#endif\n\t      if (mz_dynload_debug) {\n\t\tfprintf(stderr,\"SWIG:mzscheme:trying %s --> %p\\n\",libp,mz_libraries[i]);\n\t      }\n\t      free(libp);\n\t    }\n\t  }\n        }\n      }\n      {\n        int i;\n        void *func=NULL;\n\n        for(i=0;mz_dlopen_libraries[i]!=NULL && func==NULL;i++) {\n          if (mz_libraries[i]!=NULL) {\n#ifdef __OS_WIN32\n            func=GetProcAddress(mz_libraries[i],function);\n#else\n            func=dlsym(mz_libraries[i],function);\n#endif\n          }\n\t  if (mz_dynload_debug) {\n\t    fprintf(stderr,\n\t\t    \"SWIG:mzscheme:library:%s;dlopen=%p,function=%s,func=%p\\n\",\n\t\t    mz_dlopen_libraries[i],mz_libraries[i],function,func\n\t\t    );\n\t  }\n        }\n\n        return func;\n      }\n    }\n  }\n\n/*** DLOPEN PATCH ******************************************************\n * Contributed by Hans Oesterholt-Dijkema (jan. 2006)\n ***********************************************************************/\n\n/* The interpreter will store a pointer to this structure in a global\n   variable called swig-runtime-data-type-pointer.  The instance of this\n   struct is only used if no other module has yet been loaded */\nstruct swig_mzscheme_runtime_data {\n  swig_module_info *module_head;\n  Scheme_Type type;\n};\nstatic struct swig_mzscheme_runtime_data swig_mzscheme_runtime_data;\n\n\nstatic swig_module_info *\nSWIG_MzScheme_GetModule(Scheme_Env *env) {\n  Scheme_Object *pointer, *symbol;\n  struct swig_mzscheme_runtime_data *data;\n\n  /* first check if pointer already created */\n  symbol = scheme_intern_symbol(\"swig-runtime-data-type-pointer\" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);\n  pointer = scheme_lookup_global(symbol, env);\n  if (pointer && SCHEME_CPTRP(pointer)) {\n      data = (struct swig_mzscheme_runtime_data *) SCHEME_CPTR_VAL(pointer);\n      swig_type = data->type;\n      return data->module_head;\n  } else {\n      return NULL;\n  }\n}\n\nstatic void\nSWIG_MzScheme_SetModule(Scheme_Env *env, swig_module_info *module) {\n  Scheme_Object *pointer, *symbol;\n  struct swig_mzscheme_runtime_data *data;\n\n  /* first check if pointer already created */\n  symbol = scheme_intern_symbol(\"swig-runtime-data-type-pointer\" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);\n  pointer = scheme_lookup_global(symbol, env);\n  if (pointer && SCHEME_CPTRP(pointer)) {\n    data = (struct swig_mzscheme_runtime_data *) SCHEME_CPTR_VAL(pointer);\n    swig_type = data->type;\n    data->module_head = module;\n  } else {\n    /* create a new type for wrapped pointer values */\n    swig_type = scheme_make_type((char *)\"swig\");\n    swig_mzscheme_runtime_data.module_head = module;\n    swig_mzscheme_runtime_data.type = swig_type;\n    \n    /* create a new pointer */\n#ifndef MZSCHEME30X\n    pointer = scheme_make_cptr((void *) &swig_mzscheme_runtime_data, \"swig_mzscheme_runtime_data\");\n#else\n    pointer = scheme_make_cptr((void *) &swig_mzscheme_runtime_data,\n\t\t\t       scheme_make_byte_string(\"swig_mzscheme_runtime_data\"));\n#endif\n    scheme_add_global_symbol(symbol, pointer, env);\n  }\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Doc/Manual/swig16.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Doc/Manual/ch2.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Doc/Manual/SWIGDocumentation.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Doc/Manual/ch11.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Doc/Manual/Java.html",
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Doc/Manual/ch11.3.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Doc/Manual/ch12.1.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Doc/Manual/ch11.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Doc/Manual/ch9.table.2.png",
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Examples/test-suite/char_constant.i",
        "/tmp/vanessa/spack-stage/spack-stage-swig-1.3.40-e2xcravbfwlzqbrf5rks3zdk27c4zg5e/spack-src/Examples/test-suite/ruby/char_constant_runme.rb"
    ],
    "total_files": 3273
}