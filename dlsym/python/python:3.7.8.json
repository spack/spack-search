{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Python/dynload_shlib.c": "\n/* Support for dynamic loading of extension modules */\n\n#include \"Python.h\"\n#include \"internal/pystate.h\"\n#include \"importdl.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#if defined(__NetBSD__)\n#include <sys/param.h>\n#if (NetBSD < 199712)\n#include <nlist.h>\n#include <link.h>\n#define dlerror() \"error in dynamic linking\"\n#endif\n#endif /* NetBSD */\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#if (defined(__OpenBSD__) || defined(__NetBSD__)) && !defined(__ELF__)\n#define LEAD_UNDERSCORE \"_\"\n#else\n#define LEAD_UNDERSCORE \"\"\n#endif\n\n/* The .so extension module ABI tag, supplied by the Makefile via\n   Makefile.pre.in and configure.  This is used to discriminate between\n   incompatible .so files so that extensions for different Python builds can\n   live in the same directory.  E.g. foomodule.cpython-32.so\n*/\n\nconst char *_PyImport_DynLoadFiletab[] = {\n#ifdef __CYGWIN__\n    \".dll\",\n#else  /* !__CYGWIN__ */\n    \".\" SOABI \".so\",\n    \".abi\" PYTHON_ABI_STRING \".so\",\n    \".so\",\n#endif  /* __CYGWIN__ */\n    NULL,\n};\n\nstatic struct {\n    dev_t dev;\n    ino_t ino;\n    void *handle;\n} handles[128];\nstatic int nhandles = 0;\n\n\ndl_funcptr\n_PyImport_FindSharedFuncptr(const char *prefix,\n                            const char *shortname,\n                            const char *pathname, FILE *fp)\n{\n    dl_funcptr p;\n    void *handle;\n    char funcname[258];\n    char pathbuf[260];\n    int dlopenflags=0;\n\n    if (strchr(pathname, '/') == NULL) {\n        /* Prefix bare filename with \"./\" */\n        PyOS_snprintf(pathbuf, sizeof(pathbuf), \"./%-.255s\", pathname);\n        pathname = pathbuf;\n    }\n\n    PyOS_snprintf(funcname, sizeof(funcname),\n                  LEAD_UNDERSCORE \"%.20s_%.200s\", prefix, shortname);\n\n    if (fp != NULL) {\n        int i;\n        struct _Py_stat_struct status;\n        if (_Py_fstat(fileno(fp), &status) == -1)\n            return NULL;\n        for (i = 0; i < nhandles; i++) {\n            if (status.st_dev == handles[i].dev &&\n                status.st_ino == handles[i].ino) {\n                p = (dl_funcptr) dlsym(handles[i].handle,\n                                       funcname);\n                return p;\n            }\n        }\n        if (nhandles < 128) {\n            handles[nhandles].dev = status.st_dev;\n            handles[nhandles].ino = status.st_ino;\n        }\n    }\n\n    dlopenflags = PyThreadState_GET()->interp->dlopenflags;\n\n    handle = dlopen(pathname, dlopenflags);\n\n    if (handle == NULL) {\n        PyObject *mod_name;\n        PyObject *path;\n        PyObject *error_ob;\n        const char *error = dlerror();\n        if (error == NULL)\n            error = \"unknown dlopen() error\";\n        error_ob = PyUnicode_FromString(error);\n        if (error_ob == NULL)\n            return NULL;\n        mod_name = PyUnicode_FromString(shortname);\n        if (mod_name == NULL) {\n            Py_DECREF(error_ob);\n            return NULL;\n        }\n        path = PyUnicode_FromString(pathname);\n        if (path == NULL) {\n            Py_DECREF(error_ob);\n            Py_DECREF(mod_name);\n            return NULL;\n        }\n        PyErr_SetImportError(error_ob, mod_name, path);\n        Py_DECREF(error_ob);\n        Py_DECREF(mod_name);\n        Py_DECREF(path);\n        return NULL;\n    }\n    if (fp != NULL && nhandles < 128)\n        handles[nhandles++].handle = handle;\n    p = (dl_funcptr) dlsym(handle, funcname);\n    return p;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Modules/_ctypes/ctypes_dlfcn.h": "#ifndef _CTYPES_DLFCN_H_\n#define _CTYPES_DLFCN_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MS_WIN32\n\n#include <dlfcn.h>\n\n#ifndef CTYPES_DARWIN_DLFCN\n\n#define ctypes_dlsym dlsym\n#define ctypes_dlerror dlerror\n#define ctypes_dlopen dlopen\n#define ctypes_dlclose dlclose\n#define ctypes_dladdr dladdr\n\n#endif /* !CTYPES_DARWIN_DLFCN */\n\n#endif /* !MS_WIN32 */\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n#endif /* _CTYPES_DLFCN_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Modules/_ctypes/_ctypes.c": "/*\n  ToDo:\n\n  Get rid of the checker (and also the converters) field in PyCFuncPtrObject and\n  StgDictObject, and replace them by slot functions in StgDictObject.\n\n  think about a buffer-like object (memory? bytes?)\n\n  Should POINTER(c_char) and POINTER(c_wchar) have a .value property?\n  What about c_char and c_wchar arrays then?\n\n  Add from_mmap, from_file, from_string metaclass methods.\n\n  Maybe we can get away with from_file (calls read) and with a from_buffer\n  method?\n\n  And what about the to_mmap, to_file, to_str(?) methods?  They would clobber\n  the namespace, probably. So, functions instead? And we already have memmove...\n*/\n\n/*\n\nName                    methods, members, getsets\n==============================================================================\n\nPyCStructType_Type              __new__(), from_address(), __mul__(), from_param()\nUnionType_Type          __new__(), from_address(), __mul__(), from_param()\nPyCPointerType_Type     __new__(), from_address(), __mul__(), from_param(), set_type()\nPyCArrayType_Type               __new__(), from_address(), __mul__(), from_param()\nPyCSimpleType_Type              __new__(), from_address(), __mul__(), from_param()\n\nPyCData_Type\n  Struct_Type           __new__(), __init__()\n  PyCPointer_Type               __new__(), __init__(), _as_parameter_, contents\n  PyCArray_Type         __new__(), __init__(), _as_parameter_, __get/setitem__(), __len__()\n  Simple_Type           __new__(), __init__(), _as_parameter_\n\nPyCField_Type\nPyCStgDict_Type\n\n==============================================================================\n\nclass methods\n-------------\n\nIt has some similarity to the byref() construct compared to pointer()\nfrom_address(addr)\n    - construct an instance from a given memory block (sharing this memory block)\n\nfrom_param(obj)\n    - typecheck and convert a Python object into a C function call parameter\n      The result may be an instance of the type, or an integer or tuple\n      (typecode, value[, obj])\n\ninstance methods/properties\n---------------------------\n\n_as_parameter_\n    - convert self into a C function call parameter\n      This is either an integer, or a 3-tuple (typecode, value, obj)\n\nfunctions\n---------\n\nsizeof(cdata)\n    - return the number of bytes the buffer contains\n\nsizeof(ctype)\n    - return the number of bytes the buffer of an instance would contain\n\nbyref(cdata)\n\naddressof(cdata)\n\npointer(cdata)\n\nPOINTER(ctype)\n\nbytes(cdata)\n    - return the buffer contents as a sequence of bytes (which is currently a string)\n\n*/\n\n/*\n * PyCStgDict_Type\n * PyCStructType_Type\n * UnionType_Type\n * PyCPointerType_Type\n * PyCArrayType_Type\n * PyCSimpleType_Type\n *\n * PyCData_Type\n * Struct_Type\n * Union_Type\n * PyCArray_Type\n * Simple_Type\n * PyCPointer_Type\n * PyCField_Type\n *\n */\n\n#define PY_SSIZE_T_CLEAN\n\n#include \"Python.h\"\n#include \"structmember.h\"\n\n#include <ffi.h>\n#ifdef MS_WIN32\n#include <windows.h>\n#include <malloc.h>\n#ifndef IS_INTRESOURCE\n#define IS_INTRESOURCE(x) (((size_t)(x) >> 16) == 0)\n#endif\n#else\n#include \"ctypes_dlfcn.h\"\n#endif\n#include \"ctypes.h\"\n\nPyObject *PyExc_ArgError = NULL;\n\n/* This dict maps ctypes types to POINTER types */\nPyObject *_ctypes_ptrtype_cache = NULL;\n\nstatic PyTypeObject Simple_Type;\n\n/* a callable object used for unpickling */\nstatic PyObject *_unpickle;\n\n\n\n/****************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *key;\n    PyObject *dict;\n} DictRemoverObject;\n\nstatic void\n_DictRemover_dealloc(PyObject *myself)\n{\n    DictRemoverObject *self = (DictRemoverObject *)myself;\n    Py_XDECREF(self->key);\n    Py_XDECREF(self->dict);\n    Py_TYPE(self)->tp_free(myself);\n}\n\nstatic PyObject *\n_DictRemover_call(PyObject *myself, PyObject *args, PyObject *kw)\n{\n    DictRemoverObject *self = (DictRemoverObject *)myself;\n    if (self->key && self->dict) {\n        if (-1 == PyDict_DelItem(self->dict, self->key))\n            /* XXX Error context */\n            PyErr_WriteUnraisable(Py_None);\n        Py_CLEAR(self->key);\n        Py_CLEAR(self->dict);\n    }\n    Py_RETURN_NONE;\n}\n\nstatic PyTypeObject DictRemover_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.DictRemover\",                      /* tp_name */\n    sizeof(DictRemoverObject),                  /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    _DictRemover_dealloc,                       /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    _DictRemover_call,                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n/* XXX should participate in GC? */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    \"deletes a key from a dictionary\",          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    0,                                          /* tp_free */\n};\n\nint\nPyDict_SetItemProxy(PyObject *dict, PyObject *key, PyObject *item)\n{\n    PyObject *obj;\n    DictRemoverObject *remover;\n    PyObject *proxy;\n    int result;\n\n    obj = _PyObject_CallNoArg((PyObject *)&DictRemover_Type);\n    if (obj == NULL)\n        return -1;\n\n    remover = (DictRemoverObject *)obj;\n    assert(remover->key == NULL);\n    assert(remover->dict == NULL);\n    Py_INCREF(key);\n    remover->key = key;\n    Py_INCREF(dict);\n    remover->dict = dict;\n\n    proxy = PyWeakref_NewProxy(item, obj);\n    Py_DECREF(obj);\n    if (proxy == NULL)\n        return -1;\n\n    result = PyDict_SetItem(dict, key, proxy);\n    Py_DECREF(proxy);\n    return result;\n}\n\nPyObject *\nPyDict_GetItemProxy(PyObject *dict, PyObject *key)\n{\n    PyObject *result;\n    PyObject *item = PyDict_GetItem(dict, key);\n\n    if (item == NULL)\n        return NULL;\n    if (!PyWeakref_CheckProxy(item))\n        return item;\n    result = PyWeakref_GET_OBJECT(item);\n    if (result == Py_None)\n        return NULL;\n    return result;\n}\n\n/******************************************************************/\n\n/*\n  Allocate a memory block for a pep3118 format string, filled with\n  a suitable PEP 3118 type code corresponding to the given ctypes\n  type. Returns NULL on failure, with the error indicator set.\n\n  This produces type codes in the standard size mode (cf. struct module),\n  since the endianness may need to be swapped to a non-native one\n  later on.\n */\nstatic char *\n_ctypes_alloc_format_string_for_type(char code, int big_endian)\n{\n    char *result;\n    char pep_code = '\\0';\n\n    switch (code) {\n#if SIZEOF_INT == 2\n    case 'i': pep_code = 'h'; break;\n    case 'I': pep_code = 'H'; break;\n#elif SIZEOF_INT == 4\n    case 'i': pep_code = 'i'; break;\n    case 'I': pep_code = 'I'; break;\n#elif SIZEOF_INT == 8\n    case 'i': pep_code = 'q'; break;\n    case 'I': pep_code = 'Q'; break;\n#else\n# error SIZEOF_INT has an unexpected value\n#endif /* SIZEOF_INT */\n#if SIZEOF_LONG == 4\n    case 'l': pep_code = 'l'; break;\n    case 'L': pep_code = 'L'; break;\n#elif SIZEOF_LONG == 8\n    case 'l': pep_code = 'q'; break;\n    case 'L': pep_code = 'Q'; break;\n#else\n# error SIZEOF_LONG has an unexpected value\n#endif /* SIZEOF_LONG */\n#if SIZEOF__BOOL == 1\n    case '?': pep_code = '?'; break;\n#elif SIZEOF__BOOL == 2\n    case '?': pep_code = 'H'; break;\n#elif SIZEOF__BOOL == 4\n    case '?': pep_code = 'L'; break;\n#elif SIZEOF__BOOL == 8\n    case '?': pep_code = 'Q'; break;\n#else\n# error SIZEOF__BOOL has an unexpected value\n#endif /* SIZEOF__BOOL */\n    default:\n        /* The standard-size code is the same as the ctypes one */\n        pep_code = code;\n        break;\n    }\n\n    result = PyMem_Malloc(3);\n    if (result == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    result[0] = big_endian ? '>' : '<';\n    result[1] = pep_code;\n    result[2] = '\\0';\n    return result;\n}\n\n/*\n  Allocate a memory block for a pep3118 format string, copy prefix (if\n  non-null) and suffix into it.  Returns NULL on failure, with the error\n  indicator set.  If called with a suffix of NULL the error indicator must\n  already be set.\n */\nchar *\n_ctypes_alloc_format_string(const char *prefix, const char *suffix)\n{\n    size_t len;\n    char *result;\n\n    if (suffix == NULL) {\n        assert(PyErr_Occurred());\n        return NULL;\n    }\n    len = strlen(suffix);\n    if (prefix)\n        len += strlen(prefix);\n    result = PyMem_Malloc(len + 1);\n    if (result == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    if (prefix)\n        strcpy(result, prefix);\n    else\n        result[0] = '\\0';\n    strcat(result, suffix);\n    return result;\n}\n\n/*\n  Allocate a memory block for a pep3118 format string, adding\n  the given prefix (if non-null), an additional shape prefix, and a suffix.\n  Returns NULL on failure, with the error indicator set.  If called with\n  a suffix of NULL the error indicator must already be set.\n */\nchar *\n_ctypes_alloc_format_string_with_shape(int ndim, const Py_ssize_t *shape,\n                                       const char *prefix, const char *suffix)\n{\n    char *new_prefix;\n    char *result;\n    char buf[32];\n    Py_ssize_t prefix_len;\n    int k;\n\n    prefix_len = 32 * ndim + 3;\n    if (prefix)\n        prefix_len += strlen(prefix);\n    new_prefix = PyMem_Malloc(prefix_len);\n    if (new_prefix == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    new_prefix[0] = '\\0';\n    if (prefix)\n        strcpy(new_prefix, prefix);\n    if (ndim > 0) {\n        /* Add the prefix \"(shape[0],shape[1],...,shape[ndim-1])\" */\n        strcat(new_prefix, \"(\");\n        for (k = 0; k < ndim; ++k) {\n            if (k < ndim-1) {\n                sprintf(buf, \"%\"PY_FORMAT_SIZE_T\"d,\", shape[k]);\n            } else {\n                sprintf(buf, \"%\"PY_FORMAT_SIZE_T\"d)\", shape[k]);\n            }\n            strcat(new_prefix, buf);\n        }\n    }\n    result = _ctypes_alloc_format_string(new_prefix, suffix);\n    PyMem_Free(new_prefix);\n    return result;\n}\n\n/*\n  PyCStructType_Type - a meta type/class.  Creating a new class using this one as\n  __metaclass__ will call the constructor StructUnionType_new.  It replaces the\n  tp_dict member with a new instance of StgDict, and initializes the C\n  accessible fields somehow.\n*/\n\nstatic PyCArgObject *\nStructUnionType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n    StgDictObject *stgdict;\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'V';\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for structure/union instances */\n    parg->pffi_type = &stgdict->ffi_type_pointer;\n    /* For structure parameters (by value), parg->value doesn't contain the structure\n       data itself, instead parg->value.p *points* to the structure's data\n       See also _ctypes.c, function _call_function_pointer().\n    */\n    parg->value.p = self->b_ptr;\n    parg->size = self->b_size;\n    Py_INCREF(self);\n    parg->obj = (PyObject *)self;\n    return parg;\n}\n\nstatic PyObject *\nStructUnionType_new(PyTypeObject *type, PyObject *args, PyObject *kwds, int isStruct)\n{\n    PyTypeObject *result;\n    PyObject *fields;\n    StgDictObject *dict;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (!result)\n        return NULL;\n\n    /* keep this for bw compatibility */\n    if (PyDict_GetItemString(result->tp_dict, \"_abstract_\"))\n        return (PyObject *)result;\n\n    dict = (StgDictObject *)_PyObject_CallNoArg((PyObject *)&PyCStgDict_Type);\n    if (!dict) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    if (!isStruct) {\n        dict->flags |= TYPEFLAG_HASUNION;\n    }\n    /* replace the class dict by our updated stgdict, which holds info\n       about storage requirements of the instances */\n    if (-1 == PyDict_Update((PyObject *)dict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)dict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)dict);\n    dict->format = _ctypes_alloc_format_string(NULL, \"B\");\n    if (dict->format == NULL) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    dict->paramfunc = StructUnionType_paramfunc;\n\n    fields = PyDict_GetItemString((PyObject *)dict, \"_fields_\");\n    if (!fields) {\n        StgDictObject *basedict = PyType_stgdict((PyObject *)result->tp_base);\n\n        if (basedict == NULL)\n            return (PyObject *)result;\n        /* copy base dict */\n        if (-1 == PyCStgDict_clone(dict, basedict)) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        dict->flags &= ~DICTFLAG_FINAL; /* clear the 'final' flag in the subclass dict */\n        basedict->flags |= DICTFLAG_FINAL; /* set the 'final' flag in the baseclass dict */\n        return (PyObject *)result;\n    }\n\n    if (-1 == PyObject_SetAttrString((PyObject *)result, \"_fields_\", fields)) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    return (PyObject *)result;\n}\n\nstatic PyObject *\nPyCStructType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    return StructUnionType_new(type, args, kwds, 1);\n}\n\nstatic PyObject *\nUnionType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    return StructUnionType_new(type, args, kwds, 0);\n}\n\nstatic const char from_address_doc[] =\n\"C.from_address(integer) -> C instance\\naccess a C instance at the specified address\";\n\nstatic PyObject *\nCDataType_from_address(PyObject *type, PyObject *value)\n{\n    void *buf;\n    if (!PyLong_Check(value)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"integer expected\");\n        return NULL;\n    }\n    buf = (void *)PyLong_AsVoidPtr(value);\n    if (PyErr_Occurred())\n        return NULL;\n    return PyCData_AtAddress(type, buf);\n}\n\nstatic const char from_buffer_doc[] =\n\"C.from_buffer(object, offset=0) -> C instance\\ncreate a C instance from a writeable buffer\";\n\nstatic int\nKeepRef(CDataObject *target, Py_ssize_t index, PyObject *keep);\n\nstatic PyObject *\nCDataType_from_buffer(PyObject *type, PyObject *args)\n{\n    PyObject *obj;\n    PyObject *mv;\n    PyObject *result;\n    Py_buffer *buffer;\n    Py_ssize_t offset = 0;\n\n    StgDictObject *dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError, \"abstract class\");\n        return NULL;\n    }\n\n    if (!PyArg_ParseTuple(args, \"O|n:from_buffer\", &obj, &offset))\n        return NULL;\n\n    mv = PyMemoryView_FromObject(obj);\n    if (mv == NULL)\n        return NULL;\n\n    buffer = PyMemoryView_GET_BUFFER(mv);\n\n    if (buffer->readonly) {\n        PyErr_SetString(PyExc_TypeError,\n            \"underlying buffer is not writable\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (!PyBuffer_IsContiguous(buffer, 'C')) {\n        PyErr_SetString(PyExc_TypeError,\n            \"underlying buffer is not C contiguous\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (offset < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"offset cannot be negative\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (dict->size > buffer->len - offset) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Buffer size too small \"\n                     \"(%zd instead of at least %zd bytes)\",\n                     buffer->len, dict->size + offset);\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    result = PyCData_AtAddress(type, (char *)buffer->buf + offset);\n    if (result == NULL) {\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (-1 == KeepRef((CDataObject *)result, -1, mv)) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    return result;\n}\n\nstatic const char from_buffer_copy_doc[] =\n\"C.from_buffer_copy(object, offset=0) -> C instance\\ncreate a C instance from a readable buffer\";\n\nstatic PyObject *\nGenericPyCData_new(PyTypeObject *type, PyObject *args, PyObject *kwds);\n\nstatic PyObject *\nCDataType_from_buffer_copy(PyObject *type, PyObject *args)\n{\n    Py_buffer buffer;\n    Py_ssize_t offset = 0;\n    PyObject *result;\n    StgDictObject *dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError, \"abstract class\");\n        return NULL;\n    }\n\n    if (!PyArg_ParseTuple(args, \"y*|n:from_buffer_copy\", &buffer, &offset))\n        return NULL;\n\n    if (offset < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"offset cannot be negative\");\n        PyBuffer_Release(&buffer);\n        return NULL;\n    }\n\n    if (dict->size > buffer.len - offset) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Buffer size too small (%zd instead of at least %zd bytes)\",\n                     buffer.len, dict->size + offset);\n        PyBuffer_Release(&buffer);\n        return NULL;\n    }\n\n    result = GenericPyCData_new((PyTypeObject *)type, NULL, NULL);\n    if (result != NULL) {\n        memcpy(((CDataObject *)result)->b_ptr,\n               (char *)buffer.buf + offset, dict->size);\n    }\n    PyBuffer_Release(&buffer);\n    return result;\n}\n\nstatic const char in_dll_doc[] =\n\"C.in_dll(dll, name) -> C instance\\naccess a C instance in a dll\";\n\nstatic PyObject *\nCDataType_in_dll(PyObject *type, PyObject *args)\n{\n    PyObject *dll;\n    char *name;\n    PyObject *obj;\n    void *handle;\n    void *address;\n\n    if (!PyArg_ParseTuple(args, \"Os:in_dll\", &dll, &name))\n        return NULL;\n\n    obj = PyObject_GetAttrString(dll, \"_handle\");\n    if (!obj)\n        return NULL;\n    if (!PyLong_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the _handle attribute of the second argument must be an integer\");\n        Py_DECREF(obj);\n        return NULL;\n    }\n    handle = (void *)PyLong_AsVoidPtr(obj);\n    Py_DECREF(obj);\n    if (PyErr_Occurred()) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"could not convert the _handle attribute to a pointer\");\n        return NULL;\n    }\n\n#ifdef MS_WIN32\n    address = (void *)GetProcAddress(handle, name);\n    if (!address) {\n        PyErr_Format(PyExc_ValueError,\n                     \"symbol '%s' not found\",\n                     name);\n        return NULL;\n    }\n#else\n    address = (void *)ctypes_dlsym(handle, name);\n    if (!address) {\n#ifdef __CYGWIN__\n/* dlerror() isn't very helpful on cygwin */\n        PyErr_Format(PyExc_ValueError,\n                     \"symbol '%s' not found\",\n                     name);\n#else\n        PyErr_SetString(PyExc_ValueError, ctypes_dlerror());\n#endif\n        return NULL;\n    }\n#endif\n    return PyCData_AtAddress(type, address);\n}\n\nstatic const char from_param_doc[] =\n\"Convert a Python object into a function call parameter.\";\n\nstatic PyObject *\nCDataType_from_param(PyObject *type, PyObject *value)\n{\n    PyObject *as_parameter;\n    int res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n    if (PyCArg_CheckExact(value)) {\n        PyCArgObject *p = (PyCArgObject *)value;\n        PyObject *ob = p->obj;\n        const char *ob_name;\n        StgDictObject *dict;\n        dict = PyType_stgdict(type);\n\n        /* If we got a PyCArgObject, we must check if the object packed in it\n           is an instance of the type's dict->proto */\n        if(dict && ob) {\n            res = PyObject_IsInstance(ob, dict->proto);\n            if (res == -1)\n                return NULL;\n            if (res) {\n                Py_INCREF(value);\n                return value;\n            }\n        }\n        ob_name = (ob) ? Py_TYPE(ob)->tp_name : \"???\";\n        PyErr_Format(PyExc_TypeError,\n                     \"expected %s instance instead of pointer to %s\",\n                     ((PyTypeObject *)type)->tp_name, ob_name);\n        return NULL;\n    }\n\n    as_parameter = PyObject_GetAttrString(value, \"_as_parameter_\");\n    if (as_parameter) {\n        value = CDataType_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"expected %s instance instead of %s\",\n                 ((PyTypeObject *)type)->tp_name,\n                 Py_TYPE(value)->tp_name);\n    return NULL;\n}\n\nstatic PyMethodDef CDataType_methods[] = {\n    { \"from_param\", CDataType_from_param, METH_O, from_param_doc },\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc },\n    { NULL, NULL },\n};\n\nstatic PyObject *\nCDataType_repeat(PyObject *self, Py_ssize_t length)\n{\n    if (length < 0)\n        return PyErr_Format(PyExc_ValueError,\n                            \"Array length must be >= 0, not %zd\",\n                            length);\n    return PyCArrayType_from_ctype(self, length);\n}\n\nstatic PySequenceMethods CDataType_as_sequence = {\n    0,                          /* inquiry sq_length; */\n    0,                          /* binaryfunc sq_concat; */\n    CDataType_repeat,           /* intargfunc sq_repeat; */\n    0,                          /* intargfunc sq_item; */\n    0,                          /* intintargfunc sq_slice; */\n    0,                          /* intobjargproc sq_ass_item; */\n    0,                          /* intintobjargproc sq_ass_slice; */\n    0,                          /* objobjproc sq_contains; */\n\n    0,                          /* binaryfunc sq_inplace_concat; */\n    0,                          /* intargfunc sq_inplace_repeat; */\n};\n\nstatic int\nCDataType_clear(PyTypeObject *self)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)self);\n    if (dict)\n        Py_CLEAR(dict->proto);\n    return PyType_Type.tp_clear((PyObject *)self);\n}\n\nstatic int\nCDataType_traverse(PyTypeObject *self, visitproc visit, void *arg)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)self);\n    if (dict)\n        Py_VISIT(dict->proto);\n    return PyType_Type.tp_traverse((PyObject *)self, visit, arg);\n}\n\nstatic int\nPyCStructType_setattro(PyObject *self, PyObject *key, PyObject *value)\n{\n    /* XXX Should we disallow deleting _fields_? */\n    if (-1 == PyType_Type.tp_setattro(self, key, value))\n        return -1;\n\n    if (value && PyUnicode_Check(key) &&\n        _PyUnicode_EqualToASCIIString(key, \"_fields_\"))\n        return PyCStructUnionType_update_stgdict(self, value, 1);\n    return 0;\n}\n\n\nstatic int\nUnionType_setattro(PyObject *self, PyObject *key, PyObject *value)\n{\n    /* XXX Should we disallow deleting _fields_? */\n    if (-1 == PyObject_GenericSetAttr(self, key, value))\n        return -1;\n\n    if (PyUnicode_Check(key) &&\n        _PyUnicode_EqualToASCIIString(key, \"_fields_\"))\n        return PyCStructUnionType_update_stgdict(self, value, 0);\n    return 0;\n}\n\n\nPyTypeObject PyCStructType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCStructType\",                            /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    PyCStructType_setattro,                     /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for the CData Objects\",           /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCStructType_new,                                  /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic PyTypeObject UnionType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.UnionType\",                        /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    UnionType_setattro,                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for the CData Objects\",           /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    UnionType_new,                              /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n\n/*\n\nThe PyCPointerType_Type metaclass must ensure that the subclass of Pointer can be\ncreated. It must check for a _type_ attribute in the class. Since are no\nruntime created properties, a CField is probably *not* needed ?\n\nclass IntPointer(Pointer):\n    _type_ = \"i\"\n\nThe PyCPointer_Type provides the functionality: a contents method/property, a\nsize property/method, and the sequence protocol.\n\n*/\n\nstatic int\nPyCPointerType_SetProto(StgDictObject *stgdict, PyObject *proto)\n{\n    if (!proto || !PyType_Check(proto)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must be a type\");\n        return -1;\n    }\n    if (!PyType_stgdict(proto)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must have storage info\");\n        return -1;\n    }\n    Py_INCREF(proto);\n    Py_XSETREF(stgdict->proto, proto);\n    return 0;\n}\n\nstatic PyCArgObject *\nPyCPointerType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    Py_INCREF(self);\n    parg->obj = (PyObject *)self;\n    parg->value.p = *(void **)self->b_ptr;\n    return parg;\n}\n\nstatic PyObject *\nPyCPointerType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *proto;\n    PyObject *typedict;\n\n    typedict = PyTuple_GetItem(args, 2);\n    if (!typedict)\n        return NULL;\n/*\n  stgdict items size, align, length contain info about pointers itself,\n  stgdict->proto has info about the pointed to type!\n*/\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        return NULL;\n    stgdict->size = sizeof(void *);\n    stgdict->align = _ctypes_get_fielddesc(\"P\")->pffi_type->alignment;\n    stgdict->length = 1;\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n    stgdict->paramfunc = PyCPointerType_paramfunc;\n    stgdict->flags |= TYPEFLAG_ISPOINTER;\n\n    proto = PyDict_GetItemString(typedict, \"_type_\"); /* Borrowed ref */\n    if (proto && -1 == PyCPointerType_SetProto(stgdict, proto)) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    if (proto) {\n        StgDictObject *itemdict = PyType_stgdict(proto);\n        const char *current_format;\n        /* PyCPointerType_SetProto has verified proto has a stgdict. */\n        assert(itemdict);\n        /* If itemdict->format is NULL, then this is a pointer to an\n           incomplete type.  We create a generic format string\n           'pointer to bytes' in this case.  XXX Better would be to\n           fix the format string later...\n        */\n        current_format = itemdict->format ? itemdict->format : \"B\";\n        if (itemdict->shape != NULL) {\n            /* pointer to an array: the shape needs to be prefixed */\n            stgdict->format = _ctypes_alloc_format_string_with_shape(\n                itemdict->ndim, itemdict->shape, \"&\", current_format);\n        } else {\n            stgdict->format = _ctypes_alloc_format_string(\"&\", current_format);\n        }\n        if (stgdict->format == NULL) {\n            Py_DECREF((PyObject *)stgdict);\n            return NULL;\n        }\n    }\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    return (PyObject *)result;\n}\n\n\nstatic PyObject *\nPyCPointerType_set_type(PyTypeObject *self, PyObject *type)\n{\n    StgDictObject *dict;\n\n    dict = PyType_stgdict((PyObject *)self);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n\n    if (-1 == PyCPointerType_SetProto(dict, type))\n        return NULL;\n\n    if (-1 == PyDict_SetItemString((PyObject *)dict, \"_type_\", type))\n        return NULL;\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *_byref(PyObject *);\n\nstatic PyObject *\nPyCPointerType_from_param(PyObject *type, PyObject *value)\n{\n    StgDictObject *typedict;\n\n    if (value == Py_None) {\n        /* ConvParam will convert to a NULL pointer later */\n        Py_INCREF(value);\n        return value;\n    }\n\n    typedict = PyType_stgdict(type);\n    if (!typedict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n\n    /* If we expect POINTER(<type>), but receive a <type> instance, accept\n       it by calling byref(<type>).\n    */\n    switch (PyObject_IsInstance(value, typedict->proto)) {\n    case 1:\n        Py_INCREF(value); /* _byref steals a refcount */\n        return _byref(value);\n    case -1:\n        return NULL;\n    default:\n        break;\n    }\n\n    if (PointerObject_Check(value) || ArrayObject_Check(value)) {\n        /* Array instances are also pointers when\n           the item types are the same.\n        */\n        StgDictObject *v = PyObject_stgdict(value);\n        assert(v); /* Cannot be NULL for pointer or array objects */\n        int ret = PyObject_IsSubclass(v->proto, typedict->proto);\n        if (ret < 0) {\n            return NULL;\n        }\n        if (ret) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n    return CDataType_from_param(type, value);\n}\n\nstatic PyMethodDef PyCPointerType_methods[] = {\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc},\n    { \"from_param\", (PyCFunction)PyCPointerType_from_param, METH_O, from_param_doc},\n    { \"set_type\", (PyCFunction)PyCPointerType_set_type, METH_O },\n    { NULL, NULL },\n};\n\nPyTypeObject PyCPointerType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCPointerType\",                                   /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for the Pointer Objects\",         /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCPointerType_methods,                     /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCPointerType_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCArrayType_Type\n*/\n/*\n  PyCArrayType_new ensures that the new Array subclass created has a _length_\n  attribute, and a _type_ attribute.\n*/\n\nstatic int\nCharArray_set_raw(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    char *ptr;\n    Py_ssize_t size;\n    Py_buffer view;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"cannot delete attribute\");\n        return -1;\n    }\n    if (PyObject_GetBuffer(value, &view, PyBUF_SIMPLE) < 0)\n        return -1;\n    size = view.len;\n    ptr = view.buf;\n    if (size > self->b_size) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"byte string too long\");\n        goto fail;\n    }\n\n    memcpy(self->b_ptr, ptr, size);\n\n    PyBuffer_Release(&view);\n    return 0;\n fail:\n    PyBuffer_Release(&view);\n    return -1;\n}\n\nstatic PyObject *\nCharArray_get_raw(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    return PyBytes_FromStringAndSize(self->b_ptr, self->b_size);\n}\n\nstatic PyObject *\nCharArray_get_value(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    Py_ssize_t i;\n    char *ptr = self->b_ptr;\n    for (i = 0; i < self->b_size; ++i)\n        if (*ptr++ == '\\0')\n            break;\n    return PyBytes_FromStringAndSize(self->b_ptr, i);\n}\n\nstatic int\nCharArray_set_value(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    char *ptr;\n    Py_ssize_t size;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n\n    if (!PyBytes_Check(value)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"bytes expected instead of %s instance\",\n                     Py_TYPE(value)->tp_name);\n        return -1;\n    } else\n        Py_INCREF(value);\n    size = PyBytes_GET_SIZE(value);\n    if (size > self->b_size) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"byte string too long\");\n        Py_DECREF(value);\n        return -1;\n    }\n\n    ptr = PyBytes_AS_STRING(value);\n    memcpy(self->b_ptr, ptr, size);\n    if (size < self->b_size)\n        self->b_ptr[size] = '\\0';\n    Py_DECREF(value);\n\n    return 0;\n}\n\nstatic PyGetSetDef CharArray_getsets[] = {\n    { \"raw\", (getter)CharArray_get_raw, (setter)CharArray_set_raw,\n      \"value\", NULL },\n    { \"value\", (getter)CharArray_get_value, (setter)CharArray_set_value,\n      \"string value\"},\n    { NULL, NULL }\n};\n\n#ifdef CTYPES_UNICODE\nstatic PyObject *\nWCharArray_get_value(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    Py_ssize_t i;\n    wchar_t *ptr = (wchar_t *)self->b_ptr;\n    for (i = 0; i < self->b_size/(Py_ssize_t)sizeof(wchar_t); ++i)\n        if (*ptr++ == (wchar_t)0)\n            break;\n    return PyUnicode_FromWideChar((wchar_t *)self->b_ptr, i);\n}\n\nstatic int\nWCharArray_set_value(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    Py_ssize_t result = 0;\n    Py_UNICODE *wstr;\n    Py_ssize_t len;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n    if (!PyUnicode_Check(value)) {\n        PyErr_Format(PyExc_TypeError,\n                        \"unicode string expected instead of %s instance\",\n                        Py_TYPE(value)->tp_name);\n        return -1;\n    } else\n        Py_INCREF(value);\n\n    wstr = PyUnicode_AsUnicodeAndSize(value, &len);\n    if (wstr == NULL)\n        return -1;\n    if ((size_t)len > self->b_size/sizeof(wchar_t)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"string too long\");\n        result = -1;\n        goto done;\n    }\n    result = PyUnicode_AsWideChar(value,\n                                  (wchar_t *)self->b_ptr,\n                                  self->b_size/sizeof(wchar_t));\n    if (result >= 0 && (size_t)result < self->b_size/sizeof(wchar_t))\n        ((wchar_t *)self->b_ptr)[result] = (wchar_t)0;\n  done:\n    Py_DECREF(value);\n\n    return result >= 0 ? 0 : -1;\n}\n\nstatic PyGetSetDef WCharArray_getsets[] = {\n    { \"value\", (getter)WCharArray_get_value, (setter)WCharArray_set_value,\n      \"string value\"},\n    { NULL, NULL }\n};\n#endif\n\n/*\n  The next three functions copied from Python's typeobject.c.\n\n  They are used to attach methods, members, or getsets to a type *after* it\n  has been created: Arrays of characters have additional getsets to treat them\n  as strings.\n */\n/*\nstatic int\nadd_methods(PyTypeObject *type, PyMethodDef *meth)\n{\n    PyObject *dict = type->tp_dict;\n    for (; meth->ml_name != NULL; meth++) {\n        PyObject *descr;\n        descr = PyDescr_NewMethod(type, meth);\n        if (descr == NULL)\n            return -1;\n        if (PyDict_SetItemString(dict, meth->ml_name, descr) < 0) {\n            Py_DECREF(descr);\n            return -1;\n        }\n        Py_DECREF(descr);\n    }\n    return 0;\n}\n\nstatic int\nadd_members(PyTypeObject *type, PyMemberDef *memb)\n{\n    PyObject *dict = type->tp_dict;\n    for (; memb->name != NULL; memb++) {\n        PyObject *descr;\n        descr = PyDescr_NewMember(type, memb);\n        if (descr == NULL)\n            return -1;\n        if (PyDict_SetItemString(dict, memb->name, descr) < 0) {\n            Py_DECREF(descr);\n            return -1;\n        }\n        Py_DECREF(descr);\n    }\n    return 0;\n}\n*/\n\nstatic int\nadd_getset(PyTypeObject *type, PyGetSetDef *gsp)\n{\n    PyObject *dict = type->tp_dict;\n    for (; gsp->name != NULL; gsp++) {\n        PyObject *descr;\n        descr = PyDescr_NewGetSet(type, gsp);\n        if (descr == NULL)\n            return -1;\n        if (PyDict_SetItemString(dict, gsp->name, descr) < 0) {\n            Py_DECREF(descr);\n            return -1;\n        }\n        Py_DECREF(descr);\n    }\n    return 0;\n}\n\nstatic PyCArgObject *\nPyCArrayType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *p = PyCArgObject_new();\n    if (p == NULL)\n        return NULL;\n    p->tag = 'P';\n    p->pffi_type = &ffi_type_pointer;\n    p->value.p = (char *)self->b_ptr;\n    Py_INCREF(self);\n    p->obj = (PyObject *)self;\n    return p;\n}\n\nstatic PyObject *\nPyCArrayType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    StgDictObject *itemdict;\n    PyObject *length_attr, *type_attr;\n    Py_ssize_t length;\n    Py_ssize_t itemsize, itemalign;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL)\n        return NULL;\n\n    /* Initialize these variables to NULL so that we can simplify error\n       handling by using Py_XDECREF.  */\n    stgdict = NULL;\n    type_attr = NULL;\n\n    length_attr = PyObject_GetAttrString((PyObject *)result, \"_length_\");\n    if (!length_attr || !PyLong_Check(length_attr)) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_length_' attribute, \"\n                        \"which must be a positive integer\");\n        Py_XDECREF(length_attr);\n        goto error;\n    }\n    length = PyLong_AsSsize_t(length_attr);\n    Py_DECREF(length_attr);\n    if (length == -1 && PyErr_Occurred()) {\n        if (PyErr_ExceptionMatches(PyExc_OverflowError)) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"The '_length_' attribute is too large\");\n        }\n        goto error;\n    }\n\n    type_attr = PyObject_GetAttrString((PyObject *)result, \"_type_\");\n    if (!type_attr) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_type_' attribute\");\n        goto error;\n    }\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        goto error;\n\n    itemdict = PyType_stgdict(type_attr);\n    if (!itemdict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must have storage info\");\n        goto error;\n    }\n\n    assert(itemdict->format);\n    stgdict->format = _ctypes_alloc_format_string(NULL, itemdict->format);\n    if (stgdict->format == NULL)\n        goto error;\n    stgdict->ndim = itemdict->ndim + 1;\n    stgdict->shape = PyMem_Malloc(sizeof(Py_ssize_t) * stgdict->ndim);\n    if (stgdict->shape == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n    stgdict->shape[0] = length;\n    if (stgdict->ndim > 1) {\n        memmove(&stgdict->shape[1], itemdict->shape,\n            sizeof(Py_ssize_t) * (stgdict->ndim - 1));\n    }\n\n    itemsize = itemdict->size;\n    if (itemsize != 0 && length > PY_SSIZE_T_MAX / itemsize) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"array too large\");\n        goto error;\n    }\n\n    itemalign = itemdict->align;\n\n    if (itemdict->flags & (TYPEFLAG_ISPOINTER | TYPEFLAG_HASPOINTER))\n        stgdict->flags |= TYPEFLAG_HASPOINTER;\n\n    stgdict->size = itemsize * length;\n    stgdict->align = itemalign;\n    stgdict->length = length;\n    stgdict->proto = type_attr;\n    type_attr = NULL;\n\n    stgdict->paramfunc = &PyCArrayType_paramfunc;\n\n    /* Arrays are passed as pointers to function calls. */\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict))\n        goto error;\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);  /* steal the reference */\n    stgdict = NULL;\n\n    /* Special case for character arrays.\n       A permanent annoyance: char arrays are also strings!\n    */\n    if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n        if (-1 == add_getset(result, CharArray_getsets))\n            goto error;\n#ifdef CTYPES_UNICODE\n    } else if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n        if (-1 == add_getset(result, WCharArray_getsets))\n            goto error;\n#endif\n    }\n\n    return (PyObject *)result;\nerror:\n    Py_XDECREF((PyObject*)stgdict);\n    Py_XDECREF(type_attr);\n    Py_DECREF(result);\n    return NULL;\n}\n\nPyTypeObject PyCArrayType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCArrayType\",                     /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"metatype for the Array Objects\",           /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCArrayType_new,                                   /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCSimpleType_Type\n*/\n/*\n\nPyCSimpleType_new ensures that the new Simple_Type subclass created has a valid\n_type_ attribute.\n\n*/\n\nstatic const char SIMPLE_TYPE_CHARS[] = \"cbBhHiIlLdfuzZqQPXOv?g\";\n\nstatic PyObject *\nc_wchar_p_from_param(PyObject *type, PyObject *value)\n{\n    PyObject *as_parameter;\n    int res;\n    if (value == Py_None) {\n        Py_RETURN_NONE;\n    }\n    if (PyUnicode_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"Z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'Z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* c_wchar array instance or pointer(c_wchar(...)) */\n        StgDictObject *dt = PyObject_stgdict(value);\n        StgDictObject *dict;\n        assert(dt); /* Cannot be NULL for pointer or array objects */\n        dict = dt && dt->proto ? PyType_stgdict(dt->proto) : NULL;\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"u\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n    if (PyCArg_CheckExact(value)) {\n        /* byref(c_char(...)) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        StgDictObject *dict = PyObject_stgdict(a->obj);\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"u\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n\n    as_parameter = PyObject_GetAttrString(value, \"_as_parameter_\");\n    if (as_parameter) {\n        value = c_wchar_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyObject *\nc_char_p_from_param(PyObject *type, PyObject *value)\n{\n    PyObject *as_parameter;\n    int res;\n    if (value == Py_None) {\n        Py_RETURN_NONE;\n    }\n    if (PyBytes_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* c_char array instance or pointer(c_char(...)) */\n        StgDictObject *dt = PyObject_stgdict(value);\n        StgDictObject *dict;\n        assert(dt); /* Cannot be NULL for pointer or array objects */\n        dict = dt && dt->proto ? PyType_stgdict(dt->proto) : NULL;\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"c\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n    if (PyCArg_CheckExact(value)) {\n        /* byref(c_char(...)) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        StgDictObject *dict = PyObject_stgdict(a->obj);\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"c\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n\n    as_parameter = PyObject_GetAttrString(value, \"_as_parameter_\");\n    if (as_parameter) {\n        value = c_char_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyObject *\nc_void_p_from_param(PyObject *type, PyObject *value)\n{\n    StgDictObject *stgd;\n    PyObject *as_parameter;\n    int res;\n\n/* None */\n    if (value == Py_None) {\n        Py_RETURN_NONE;\n    }\n    /* Should probably allow buffer interface as well */\n/* int, long */\n    if (PyLong_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"P\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'P';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    /* XXX struni: remove later */\n/* bytes */\n    if (PyBytes_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n/* unicode */\n    if (PyUnicode_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"Z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'Z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n/* c_void_p instance (or subclass) */\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        /* c_void_p instances */\n        Py_INCREF(value);\n        return value;\n    }\n/* ctypes array or pointer instance */\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* Any array or pointer is accepted */\n        Py_INCREF(value);\n        return value;\n    }\n/* byref(...) */\n    if (PyCArg_CheckExact(value)) {\n        /* byref(c_xxx()) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        if (a->tag == 'P') {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n/* function pointer */\n    if (PyCFuncPtrObject_Check(value)) {\n        PyCArgObject *parg;\n        PyCFuncPtrObject *func;\n        func = (PyCFuncPtrObject *)value;\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'P';\n        Py_INCREF(value);\n        parg->value.p = *(void **)func->b_ptr;\n        parg->obj = value;\n        return (PyObject *)parg;\n    }\n/* c_char_p, c_wchar_p */\n    stgd = PyObject_stgdict(value);\n    if (stgd && CDataObject_Check(value) && stgd->proto && PyUnicode_Check(stgd->proto)) {\n        PyCArgObject *parg;\n\n        switch (PyUnicode_AsUTF8(stgd->proto)[0]) {\n        case 'z': /* c_char_p */\n        case 'Z': /* c_wchar_p */\n            parg = PyCArgObject_new();\n            if (parg == NULL)\n                return NULL;\n            parg->pffi_type = &ffi_type_pointer;\n            parg->tag = 'Z';\n            Py_INCREF(value);\n            parg->obj = value;\n            /* Remember: b_ptr points to where the pointer is stored! */\n            parg->value.p = *(void **)(((CDataObject *)value)->b_ptr);\n            return (PyObject *)parg;\n        }\n    }\n\n    as_parameter = PyObject_GetAttrString(value, \"_as_parameter_\");\n    if (as_parameter) {\n        value = c_void_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyMethodDef c_void_p_method = { \"from_param\", c_void_p_from_param, METH_O };\nstatic PyMethodDef c_char_p_method = { \"from_param\", c_char_p_from_param, METH_O };\nstatic PyMethodDef c_wchar_p_method = { \"from_param\", c_wchar_p_from_param, METH_O };\n\nstatic PyObject *CreateSwappedType(PyTypeObject *type, PyObject *args, PyObject *kwds,\n                                   PyObject *proto, struct fielddesc *fmt)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *name = PyTuple_GET_ITEM(args, 0);\n    PyObject *newname;\n    PyObject *swapped_args;\n    static PyObject *suffix;\n    Py_ssize_t i;\n\n    swapped_args = PyTuple_New(PyTuple_GET_SIZE(args));\n    if (!swapped_args)\n        return NULL;\n\n    if (suffix == NULL)\n#ifdef WORDS_BIGENDIAN\n        suffix = PyUnicode_InternFromString(\"_le\");\n#else\n        suffix = PyUnicode_InternFromString(\"_be\");\n#endif\n    if (suffix == NULL) {\n        Py_DECREF(swapped_args);\n        return NULL;\n    }\n\n    newname = PyUnicode_Concat(name, suffix);\n    if (newname == NULL) {\n        Py_DECREF(swapped_args);\n        return NULL;\n    }\n\n    PyTuple_SET_ITEM(swapped_args, 0, newname);\n    for (i=1; i<PyTuple_GET_SIZE(args); ++i) {\n        PyObject *v = PyTuple_GET_ITEM(args, i);\n        Py_INCREF(v);\n        PyTuple_SET_ITEM(swapped_args, i, v);\n    }\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, swapped_args, kwds);\n    Py_DECREF(swapped_args);\n    if (result == NULL)\n        return NULL;\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    stgdict->ffi_type_pointer = *fmt->pffi_type;\n    stgdict->align = fmt->pffi_type->alignment;\n    stgdict->length = 0;\n    stgdict->size = fmt->pffi_type->size;\n    stgdict->setfunc = fmt->setfunc_swapped;\n    stgdict->getfunc = fmt->getfunc_swapped;\n\n    Py_INCREF(proto);\n    stgdict->proto = proto;\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    return (PyObject *)result;\n}\n\nstatic PyCArgObject *\nPyCSimpleType_paramfunc(CDataObject *self)\n{\n    StgDictObject *dict;\n    const char *fmt;\n    PyCArgObject *parg;\n    struct fielddesc *fd;\n\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    fmt = PyUnicode_AsUTF8(dict->proto);\n    assert(fmt);\n\n    fd = _ctypes_get_fielddesc(fmt);\n    assert(fd);\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = fmt[0];\n    parg->pffi_type = fd->pffi_type;\n    Py_INCREF(self);\n    parg->obj = (PyObject *)self;\n    memcpy(&parg->value, self->b_ptr, self->b_size);\n    return parg;\n}\n\nstatic PyObject *\nPyCSimpleType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *proto;\n    const char *proto_str;\n    Py_ssize_t proto_len;\n    PyMethodDef *ml;\n    struct fielddesc *fmt;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL)\n        return NULL;\n\n    proto = PyObject_GetAttrString((PyObject *)result, \"_type_\"); /* new ref */\n    if (!proto) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_type_' attribute\");\n  error:\n        Py_XDECREF(proto);\n        Py_XDECREF(result);\n        return NULL;\n    }\n    if (PyUnicode_Check(proto)) {\n        proto_str = PyUnicode_AsUTF8AndSize(proto, &proto_len);\n        if (!proto_str)\n            goto error;\n    } else {\n        PyErr_SetString(PyExc_TypeError,\n            \"class must define a '_type_' string attribute\");\n        goto error;\n    }\n    if (proto_len != 1) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"class must define a '_type_' attribute \"\n                        \"which must be a string of length 1\");\n        goto error;\n    }\n    if (!strchr(SIMPLE_TYPE_CHARS, *proto_str)) {\n        PyErr_Format(PyExc_AttributeError,\n                     \"class must define a '_type_' attribute which must be\\n\"\n                     \"a single character string containing one of '%s'.\",\n                     SIMPLE_TYPE_CHARS);\n        goto error;\n    }\n    fmt = _ctypes_get_fielddesc(proto_str);\n    if (fmt == NULL) {\n        PyErr_Format(PyExc_ValueError,\n                     \"_type_ '%s' not supported\", proto_str);\n        goto error;\n    }\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        goto error;\n\n    stgdict->ffi_type_pointer = *fmt->pffi_type;\n    stgdict->align = fmt->pffi_type->alignment;\n    stgdict->length = 0;\n    stgdict->size = fmt->pffi_type->size;\n    stgdict->setfunc = fmt->setfunc;\n    stgdict->getfunc = fmt->getfunc;\n#ifdef WORDS_BIGENDIAN\n    stgdict->format = _ctypes_alloc_format_string_for_type(proto_str[0], 1);\n#else\n    stgdict->format = _ctypes_alloc_format_string_for_type(proto_str[0], 0);\n#endif\n    if (stgdict->format == NULL) {\n        Py_DECREF(result);\n        Py_DECREF(proto);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    stgdict->paramfunc = PyCSimpleType_paramfunc;\n/*\n    if (result->tp_base != &Simple_Type) {\n        stgdict->setfunc = NULL;\n        stgdict->getfunc = NULL;\n    }\n*/\n\n    /* This consumes the refcount on proto which we have */\n    stgdict->proto = proto;\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    /* Install from_param class methods in ctypes base classes.\n       Overrides the PyCSimpleType_from_param generic method.\n     */\n    if (result->tp_base == &Simple_Type) {\n        switch (*proto_str) {\n        case 'z': /* c_char_p */\n            ml = &c_char_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 'Z': /* c_wchar_p */\n            ml = &c_wchar_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 'P': /* c_void_p */\n            ml = &c_void_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 's':\n        case 'X':\n        case 'O':\n            ml = NULL;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        default:\n            ml = NULL;\n            break;\n        }\n\n        if (ml) {\n            PyObject *meth;\n            int x;\n            meth = PyDescr_NewClassMethod(result, ml);\n            if (!meth) {\n                Py_DECREF(result);\n                return NULL;\n            }\n            x = PyDict_SetItemString(result->tp_dict,\n                                     ml->ml_name,\n                                     meth);\n            Py_DECREF(meth);\n            if (x == -1) {\n                Py_DECREF(result);\n                return NULL;\n            }\n        }\n    }\n\n    if (type == &PyCSimpleType_Type && fmt->setfunc_swapped && fmt->getfunc_swapped) {\n        PyObject *swapped = CreateSwappedType(type, args, kwds,\n                                              proto, fmt);\n        StgDictObject *sw_dict;\n        if (swapped == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        sw_dict = PyType_stgdict(swapped);\n#ifdef WORDS_BIGENDIAN\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_le__\", swapped);\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_be__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_be__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_le__\", swapped);\n        /* We are creating the type for the OTHER endian */\n        sw_dict->format = _ctypes_alloc_format_string(\"<\", stgdict->format+1);\n#else\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_be__\", swapped);\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_le__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_le__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_be__\", swapped);\n        /* We are creating the type for the OTHER endian */\n        sw_dict->format = _ctypes_alloc_format_string(\">\", stgdict->format+1);\n#endif\n        Py_DECREF(swapped);\n        if (PyErr_Occurred()) {\n            Py_DECREF(result);\n            return NULL;\n        }\n    };\n\n    return (PyObject *)result;\n}\n\n/*\n * This is a *class method*.\n * Convert a parameter into something that ConvParam can handle.\n */\nstatic PyObject *\nPyCSimpleType_from_param(PyObject *type, PyObject *value)\n{\n    StgDictObject *dict;\n    const char *fmt;\n    PyCArgObject *parg;\n    struct fielddesc *fd;\n    PyObject *as_parameter;\n    int res;\n\n    /* If the value is already an instance of the requested type,\n       we can use it as is */\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n\n    dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n\n    /* I think we can rely on this being a one-character string */\n    fmt = PyUnicode_AsUTF8(dict->proto);\n    assert(fmt);\n\n    fd = _ctypes_get_fielddesc(fmt);\n    assert(fd);\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = fmt[0];\n    parg->pffi_type = fd->pffi_type;\n    parg->obj = fd->setfunc(&parg->value, value, 0);\n    if (parg->obj)\n        return (PyObject *)parg;\n    PyErr_Clear();\n    Py_DECREF(parg);\n\n    as_parameter = PyObject_GetAttrString(value, \"_as_parameter_\");\n    if (as_parameter) {\n        if (Py_EnterRecursiveCall(\"while processing _as_parameter_\")) {\n            Py_DECREF(as_parameter);\n            return NULL;\n        }\n        value = PyCSimpleType_from_param(type, as_parameter);\n        Py_LeaveRecursiveCall();\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyMethodDef PyCSimpleType_methods[] = {\n    { \"from_param\", PyCSimpleType_from_param, METH_O, from_param_doc },\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc},\n    { NULL, NULL },\n};\n\nPyTypeObject PyCSimpleType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCSimpleType\",                                    /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"metatype for the PyCSimpleType Objects\",           /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCSimpleType_methods,                      /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCSimpleType_new,                                  /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/******************************************************************/\n/*\n  PyCFuncPtrType_Type\n */\n\nstatic PyObject *\nconverters_from_argtypes(PyObject *ob)\n{\n    PyObject *converters;\n    Py_ssize_t i;\n    Py_ssize_t nArgs;\n\n    ob = PySequence_Tuple(ob); /* new reference */\n    if (!ob) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_argtypes_ must be a sequence of types\");\n        return NULL;\n    }\n\n    nArgs = PyTuple_GET_SIZE(ob);\n    converters = PyTuple_New(nArgs);\n    if (!converters) {\n        Py_DECREF(ob);\n        return NULL;\n    }\n\n    /* I have to check if this is correct. Using c_char, which has a size\n       of 1, will be assumed to be pushed as only one byte!\n       Aren't these promoted to integers by the C compiler and pushed as 4 bytes?\n    */\n\n    for (i = 0; i < nArgs; ++i) {\n        PyObject *tp = PyTuple_GET_ITEM(ob, i);\n        PyObject *cnv;\n/*\n *      The following checks, relating to bpo-16575 and bpo-16576, have been\n *      disabled. The reason is that, although there is a definite problem with\n *      how libffi handles unions (https://github.com/libffi/libffi/issues/33),\n *      there are numerous libraries which pass structures containing unions\n *      by values - especially on Windows but examples also exist on Linux\n *      (https://bugs.python.org/msg359834).\n *\n *      It may not be possible to get proper support for unions and bitfields\n *      until support is forthcoming in libffi, but for now, adding the checks\n *      has caused problems in otherwise-working software, which suggests it\n *      is better to disable the checks.\n *\n *      Although specific examples reported relate specifically to unions and\n *      not bitfields, the bitfields check is also being disabled as a\n *      precaution.\n\n        StgDictObject *stgdict = PyType_stgdict(tp);\n\n        if (stgdict != NULL) {\n            if (stgdict->flags & TYPEFLAG_HASUNION) {\n                Py_DECREF(converters);\n                Py_DECREF(ob);\n                if (!PyErr_Occurred()) {\n                    PyErr_Format(PyExc_TypeError,\n                                 \"item %zd in _argtypes_ passes a union by \"\n                                 \"value, which is unsupported.\",\n                                 i + 1);\n                }\n                return NULL;\n            }\n            if (stgdict->flags & TYPEFLAG_HASBITFIELD) {\n                Py_DECREF(converters);\n                Py_DECREF(ob);\n                if (!PyErr_Occurred()) {\n                    PyErr_Format(PyExc_TypeError,\n                                 \"item %zd in _argtypes_ passes a struct/\"\n                                 \"union with a bitfield by value, which is \"\n                                 \"unsupported.\",\n                                 i + 1);\n                }\n                return NULL;\n            }\n        }\n */\n\n        cnv = PyObject_GetAttrString(tp, \"from_param\");\n        if (!cnv)\n            goto argtypes_error_1;\n        PyTuple_SET_ITEM(converters, i, cnv);\n    }\n    Py_DECREF(ob);\n    return converters;\n\n  argtypes_error_1:\n    Py_XDECREF(converters);\n    Py_DECREF(ob);\n    PyErr_Format(PyExc_TypeError,\n                 \"item %zd in _argtypes_ has no from_param method\",\n                 i+1);\n    return NULL;\n}\n\nstatic int\nmake_funcptrtype_dict(StgDictObject *stgdict)\n{\n    PyObject *ob;\n    PyObject *converters = NULL;\n\n    stgdict->align = _ctypes_get_fielddesc(\"P\")->pffi_type->alignment;\n    stgdict->length = 1;\n    stgdict->size = sizeof(void *);\n    stgdict->setfunc = NULL;\n    stgdict->getfunc = NULL;\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n\n    ob = PyDict_GetItemString((PyObject *)stgdict, \"_flags_\");\n    if (!ob || !PyLong_Check(ob)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"class must define _flags_ which must be an integer\");\n        return -1;\n    }\n    stgdict->flags = PyLong_AS_LONG(ob) | TYPEFLAG_ISPOINTER;\n\n    /* _argtypes_ is optional... */\n    ob = PyDict_GetItemString((PyObject *)stgdict, \"_argtypes_\");\n    if (ob) {\n        converters = converters_from_argtypes(ob);\n        if (!converters)\n            goto error;\n        Py_INCREF(ob);\n        stgdict->argtypes = ob;\n        stgdict->converters = converters;\n    }\n\n    ob = PyDict_GetItemString((PyObject *)stgdict, \"_restype_\");\n    if (ob) {\n        if (ob != Py_None && !PyType_stgdict(ob) && !PyCallable_Check(ob)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"_restype_ must be a type, a callable, or None\");\n            return -1;\n        }\n        Py_INCREF(ob);\n        stgdict->restype = ob;\n        stgdict->checker = PyObject_GetAttrString(ob, \"_check_retval_\");\n        if (stgdict->checker == NULL)\n            PyErr_Clear();\n    }\n/* XXX later, maybe.\n    ob = PyDict_GetItemString((PyObject *)stgdict, \"_errcheck_\");\n    if (ob) {\n        if (!PyCallable_Check(ob)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"_errcheck_ must be callable\");\n            return -1;\n        }\n        Py_INCREF(ob);\n        stgdict->errcheck = ob;\n    }\n*/\n    return 0;\n\n  error:\n    Py_XDECREF(converters);\n    return -1;\n\n}\n\nstatic PyCArgObject *\nPyCFuncPtrType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    Py_INCREF(self);\n    parg->obj = (PyObject *)self;\n    parg->value.p = *(void **)self->b_ptr;\n    return parg;\n}\n\nstatic PyObject *\nPyCFuncPtrType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        return NULL;\n\n    stgdict->paramfunc = PyCFuncPtrType_paramfunc;\n    /* We do NOT expose the function signature in the format string.  It\n       is impossible, generally, because the only requirement for the\n       argtypes items is that they have a .from_param method - we do not\n       know the types of the arguments (although, in practice, most\n       argtypes would be a ctypes type).\n    */\n    stgdict->format = _ctypes_alloc_format_string(NULL, \"X{}\");\n    if (stgdict->format == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    stgdict->flags |= TYPEFLAG_ISPOINTER;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    /* replace the class dict by our updated storage dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    if (-1 == make_funcptrtype_dict(stgdict)) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    return (PyObject *)result;\n}\n\nPyTypeObject PyCFuncPtrType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCFuncPtrType\",                           /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for C function pointers\",         /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCFuncPtrType_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/*****************************************************************\n * Code to keep needed objects alive\n */\n\nstatic CDataObject *\nPyCData_GetContainer(CDataObject *self)\n{\n    while (self->b_base)\n        self = self->b_base;\n    if (self->b_objects == NULL) {\n        if (self->b_length) {\n            self->b_objects = PyDict_New();\n            if (self->b_objects == NULL)\n                return NULL;\n        } else {\n            Py_INCREF(Py_None);\n            self->b_objects = Py_None;\n        }\n    }\n    return self;\n}\n\nstatic PyObject *\nGetKeepedObjects(CDataObject *target)\n{\n    CDataObject *container;\n    container = PyCData_GetContainer(target);\n    if (container == NULL)\n        return NULL;\n    return container->b_objects;\n}\n\nstatic PyObject *\nunique_key(CDataObject *target, Py_ssize_t index)\n{\n    char string[256];\n    char *cp = string;\n    size_t bytes_left;\n\n    Py_BUILD_ASSERT(sizeof(string) - 1 > sizeof(Py_ssize_t) * 2);\n    cp += sprintf(cp, \"%x\", Py_SAFE_DOWNCAST(index, Py_ssize_t, int));\n    while (target->b_base) {\n        bytes_left = sizeof(string) - (cp - string) - 1;\n        /* Hex format needs 2 characters per byte */\n        if (bytes_left < sizeof(Py_ssize_t) * 2) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"ctypes object structure too deep\");\n            return NULL;\n        }\n        cp += sprintf(cp, \":%x\", Py_SAFE_DOWNCAST(target->b_index, Py_ssize_t, int));\n        target = target->b_base;\n    }\n    return PyUnicode_FromStringAndSize(string, cp-string);\n}\n\n/*\n * Keep a reference to 'keep' in the 'target', at index 'index'.\n *\n * If 'keep' is None, do nothing.\n *\n * Otherwise create a dictionary (if it does not yet exist) id the root\n * objects 'b_objects' item, which will store the 'keep' object under a unique\n * key.\n *\n * The unique_key helper travels the target's b_base pointer down to the root,\n * building a string containing hex-formatted indexes found during traversal,\n * separated by colons.\n *\n * The index tuple is used as a key into the root object's b_objects dict.\n *\n * Note: This function steals a refcount of the third argument, even if it\n * fails!\n */\nstatic int\nKeepRef(CDataObject *target, Py_ssize_t index, PyObject *keep)\n{\n    int result;\n    CDataObject *ob;\n    PyObject *key;\n\n/* Optimization: no need to store None */\n    if (keep == Py_None) {\n        Py_DECREF(Py_None);\n        return 0;\n    }\n    ob = PyCData_GetContainer(target);\n    if (ob == NULL) {\n        Py_DECREF(keep);\n        return -1;\n    }\n    if (ob->b_objects == NULL || !PyDict_CheckExact(ob->b_objects)) {\n        Py_XSETREF(ob->b_objects, keep); /* refcount consumed */\n        return 0;\n    }\n    key = unique_key(target, index);\n    if (key == NULL) {\n        Py_DECREF(keep);\n        return -1;\n    }\n    result = PyDict_SetItem(ob->b_objects, key, keep);\n    Py_DECREF(key);\n    Py_DECREF(keep);\n    return result;\n}\n\n/******************************************************************/\n/*\n  PyCData_Type\n */\nstatic int\nPyCData_traverse(CDataObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->b_objects);\n    Py_VISIT((PyObject *)self->b_base);\n    return 0;\n}\n\nstatic int\nPyCData_clear(CDataObject *self)\n{\n    Py_CLEAR(self->b_objects);\n    if ((self->b_needsfree)\n        && _CDataObject_HasExternalBuffer(self))\n        PyMem_Free(self->b_ptr);\n    self->b_ptr = NULL;\n    Py_CLEAR(self->b_base);\n    return 0;\n}\n\nstatic void\nPyCData_dealloc(PyObject *self)\n{\n    PyCData_clear((CDataObject *)self);\n    Py_TYPE(self)->tp_free(self);\n}\n\nstatic PyMemberDef PyCData_members[] = {\n    { \"_b_base_\", T_OBJECT,\n      offsetof(CDataObject, b_base), READONLY,\n      \"the base object\" },\n    { \"_b_needsfree_\", T_INT,\n      offsetof(CDataObject, b_needsfree), READONLY,\n      \"whether the object owns the memory or not\" },\n    { \"_objects\", T_OBJECT,\n      offsetof(CDataObject, b_objects), READONLY,\n      \"internal objects tree (NEVER CHANGE THIS OBJECT!)\"},\n    { NULL },\n};\n\nstatic int PyCData_NewGetBuffer(PyObject *myself, Py_buffer *view, int flags)\n{\n    CDataObject *self = (CDataObject *)myself;\n    StgDictObject *dict = PyObject_stgdict(myself);\n    Py_ssize_t i;\n\n    if (view == NULL) return 0;\n\n    view->buf = self->b_ptr;\n    view->obj = myself;\n    Py_INCREF(myself);\n    view->len = self->b_size;\n    view->readonly = 0;\n    /* use default format character if not set */\n    view->format = dict->format ? dict->format : \"B\";\n    view->ndim = dict->ndim;\n    view->shape = dict->shape;\n    view->itemsize = self->b_size;\n    if (view->itemsize) {\n        for (i = 0; i < view->ndim; ++i) {\n            view->itemsize /= dict->shape[i];\n        }\n    }\n    view->strides = NULL;\n    view->suboffsets = NULL;\n    view->internal = NULL;\n    return 0;\n}\n\nstatic PyBufferProcs PyCData_as_buffer = {\n    PyCData_NewGetBuffer,\n    NULL,\n};\n\n/*\n * CData objects are mutable, so they cannot be hashable!\n */\nstatic Py_hash_t\nPyCData_nohash(PyObject *self)\n{\n    PyErr_SetString(PyExc_TypeError, \"unhashable type\");\n    return -1;\n}\n\nstatic PyObject *\nPyCData_reduce(PyObject *myself, PyObject *args)\n{\n    CDataObject *self = (CDataObject *)myself;\n\n    if (PyObject_stgdict(myself)->flags & (TYPEFLAG_ISPOINTER|TYPEFLAG_HASPOINTER)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"ctypes objects containing pointers cannot be pickled\");\n        return NULL;\n    }\n    PyObject *dict = PyObject_GetAttrString(myself, \"__dict__\");\n    if (dict == NULL) {\n        return NULL;\n    }\n    return Py_BuildValue(\"O(O(NN))\", _unpickle, Py_TYPE(myself), dict,\n                         PyBytes_FromStringAndSize(self->b_ptr, self->b_size));\n}\n\nstatic PyObject *\nPyCData_setstate(PyObject *myself, PyObject *args)\n{\n    void *data;\n    Py_ssize_t len;\n    int res;\n    PyObject *dict, *mydict;\n    CDataObject *self = (CDataObject *)myself;\n    if (!PyArg_ParseTuple(args, \"O!s#\",\n                          &PyDict_Type, &dict, &data, &len))\n    {\n        return NULL;\n    }\n    if (len > self->b_size)\n        len = self->b_size;\n    memmove(self->b_ptr, data, len);\n    mydict = PyObject_GetAttrString(myself, \"__dict__\");\n    if (mydict == NULL) {\n        return NULL;\n    }\n    if (!PyDict_Check(mydict)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"%.200s.__dict__ must be a dictionary, not %.200s\",\n                     Py_TYPE(myself)->tp_name, Py_TYPE(mydict)->tp_name);\n        Py_DECREF(mydict);\n        return NULL;\n    }\n    res = PyDict_Update(mydict, dict);\n    Py_DECREF(mydict);\n    if (res == -1)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n/*\n * default __ctypes_from_outparam__ method returns self.\n */\nstatic PyObject *\nPyCData_from_outparam(PyObject *self, PyObject *args)\n{\n    Py_INCREF(self);\n    return self;\n}\n\nstatic PyMethodDef PyCData_methods[] = {\n    { \"__ctypes_from_outparam__\", PyCData_from_outparam, METH_NOARGS, },\n    { \"__reduce__\", PyCData_reduce, METH_NOARGS, },\n    { \"__setstate__\", PyCData_setstate, METH_VARARGS, },\n    { NULL, NULL },\n};\n\nPyTypeObject PyCData_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._CData\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    PyCData_dealloc,                                    /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    PyCData_nohash,                             /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCData_methods,                                    /* tp_methods */\n    PyCData_members,                                    /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic int PyCData_MallocBuffer(CDataObject *obj, StgDictObject *dict)\n{\n    if ((size_t)dict->size <= sizeof(obj->b_value)) {\n        /* No need to call malloc, can use the default buffer */\n        obj->b_ptr = (char *)&obj->b_value;\n        /* The b_needsfree flag does not mean that we actually did\n           call PyMem_Malloc to allocate the memory block; instead it\n           means we are the *owner* of the memory and are responsible\n           for freeing resources associated with the memory.  This is\n           also the reason that b_needsfree is exposed to Python.\n         */\n        obj->b_needsfree = 1;\n    } else {\n        /* In python 2.4, and ctypes 0.9.6, the malloc call took about\n           33% of the creation time for c_int().\n        */\n        obj->b_ptr = (char *)PyMem_Malloc(dict->size);\n        if (obj->b_ptr == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        obj->b_needsfree = 1;\n        memset(obj->b_ptr, 0, dict->size);\n    }\n    obj->b_size = dict->size;\n    return 0;\n}\n\nPyObject *\nPyCData_FromBaseObj(PyObject *type, PyObject *base, Py_ssize_t index, char *adr)\n{\n    CDataObject *cmem;\n    StgDictObject *dict;\n\n    assert(PyType_Check(type));\n    dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n    cmem = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);\n    if (cmem == NULL)\n        return NULL;\n    assert(CDataObject_Check(cmem));\n\n    cmem->b_length = dict->length;\n    cmem->b_size = dict->size;\n    if (base) { /* use base's buffer */\n        assert(CDataObject_Check(base));\n        cmem->b_ptr = adr;\n        cmem->b_needsfree = 0;\n        Py_INCREF(base);\n        cmem->b_base = (CDataObject *)base;\n        cmem->b_index = index;\n    } else { /* copy contents of adr */\n        if (-1 == PyCData_MallocBuffer(cmem, dict)) {\n            Py_DECREF(cmem);\n            return NULL;\n        }\n        memcpy(cmem->b_ptr, adr, dict->size);\n        cmem->b_index = index;\n    }\n    return (PyObject *)cmem;\n}\n\n/*\n Box a memory block into a CData instance.\n*/\nPyObject *\nPyCData_AtAddress(PyObject *type, void *buf)\n{\n    CDataObject *pd;\n    StgDictObject *dict;\n\n    assert(PyType_Check(type));\n    dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n\n    pd = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);\n    if (!pd)\n        return NULL;\n    assert(CDataObject_Check(pd));\n    pd->b_ptr = (char *)buf;\n    pd->b_length = dict->length;\n    pd->b_size = dict->size;\n    return (PyObject *)pd;\n}\n\n/*\n  This function returns TRUE for c_int, c_void_p, and these kind of\n  classes.  FALSE otherwise FALSE also for subclasses of c_int and\n  such.\n*/\nint _ctypes_simple_instance(PyObject *obj)\n{\n    PyTypeObject *type = (PyTypeObject *)obj;\n\n    if (PyCSimpleTypeObject_Check(type))\n        return type->tp_base != &Simple_Type;\n    return 0;\n}\n\nPyObject *\nPyCData_get(PyObject *type, GETFUNC getfunc, PyObject *src,\n          Py_ssize_t index, Py_ssize_t size, char *adr)\n{\n    StgDictObject *dict;\n    if (getfunc)\n        return getfunc(adr, size);\n    assert(type);\n    dict = PyType_stgdict(type);\n    if (dict && dict->getfunc && !_ctypes_simple_instance(type))\n        return dict->getfunc(adr, size);\n    return PyCData_FromBaseObj(type, src, index, adr);\n}\n\n/*\n  Helper function for PyCData_set below.\n*/\nstatic PyObject *\n_PyCData_set(CDataObject *dst, PyObject *type, SETFUNC setfunc, PyObject *value,\n           Py_ssize_t size, char *ptr)\n{\n    CDataObject *src;\n    int err;\n\n    if (setfunc)\n        return setfunc(ptr, value, size);\n\n    if (!CDataObject_Check(value)) {\n        StgDictObject *dict = PyType_stgdict(type);\n        if (dict && dict->setfunc)\n            return dict->setfunc(ptr, value, size);\n        /*\n           If value is a tuple, we try to call the type with the tuple\n           and use the result!\n        */\n        assert(PyType_Check(type));\n        if (PyTuple_Check(value)) {\n            PyObject *ob;\n            PyObject *result;\n            ob = PyObject_CallObject(type, value);\n            if (ob == NULL) {\n                _ctypes_extend_error(PyExc_RuntimeError, \"(%s) \",\n                                  ((PyTypeObject *)type)->tp_name);\n                return NULL;\n            }\n            result = _PyCData_set(dst, type, setfunc, ob,\n                                size, ptr);\n            Py_DECREF(ob);\n            return result;\n        } else if (value == Py_None && PyCPointerTypeObject_Check(type)) {\n            *(void **)ptr = NULL;\n            Py_RETURN_NONE;\n        } else {\n            PyErr_Format(PyExc_TypeError,\n                         \"expected %s instance, got %s\",\n                         ((PyTypeObject *)type)->tp_name,\n                         Py_TYPE(value)->tp_name);\n            return NULL;\n        }\n    }\n    src = (CDataObject *)value;\n\n    err = PyObject_IsInstance(value, type);\n    if (err == -1)\n        return NULL;\n    if (err) {\n        memcpy(ptr,\n               src->b_ptr,\n               size);\n\n        if (PyCPointerTypeObject_Check(type)) {\n            /* XXX */\n        }\n\n        value = GetKeepedObjects(src);\n        if (value == NULL)\n            return NULL;\n\n        Py_INCREF(value);\n        return value;\n    }\n\n    if (PyCPointerTypeObject_Check(type)\n        && ArrayObject_Check(value)) {\n        StgDictObject *p1, *p2;\n        PyObject *keep;\n        p1 = PyObject_stgdict(value);\n        assert(p1); /* Cannot be NULL for array instances */\n        p2 = PyType_stgdict(type);\n        assert(p2); /* Cannot be NULL for pointer types */\n\n        if (p1->proto != p2->proto) {\n            PyErr_Format(PyExc_TypeError,\n                         \"incompatible types, %s instance instead of %s instance\",\n                         Py_TYPE(value)->tp_name,\n                         ((PyTypeObject *)type)->tp_name);\n            return NULL;\n        }\n        *(void **)ptr = src->b_ptr;\n\n        keep = GetKeepedObjects(src);\n        if (keep == NULL)\n            return NULL;\n\n        /*\n          We are assigning an array object to a field which represents\n          a pointer. This has the same effect as converting an array\n          into a pointer. So, again, we have to keep the whole object\n          pointed to (which is the array in this case) alive, and not\n          only it's object list.  So we create a tuple, containing\n          b_objects list PLUS the array itself, and return that!\n        */\n        return PyTuple_Pack(2, keep, value);\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"incompatible types, %s instance instead of %s instance\",\n                 Py_TYPE(value)->tp_name,\n                 ((PyTypeObject *)type)->tp_name);\n    return NULL;\n}\n\n/*\n * Set a slice in object 'dst', which has the type 'type',\n * to the value 'value'.\n */\nint\nPyCData_set(PyObject *dst, PyObject *type, SETFUNC setfunc, PyObject *value,\n          Py_ssize_t index, Py_ssize_t size, char *ptr)\n{\n    CDataObject *mem = (CDataObject *)dst;\n    PyObject *result;\n\n    if (!CDataObject_Check(dst)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"not a ctype instance\");\n        return -1;\n    }\n\n    result = _PyCData_set(mem, type, setfunc, value,\n                        size, ptr);\n    if (result == NULL)\n        return -1;\n\n    /* KeepRef steals a refcount from it's last argument */\n    /* If KeepRef fails, we are stumped.  The dst memory block has already\n       been changed */\n    return KeepRef(mem, index, result);\n}\n\n\n/******************************************************************/\nstatic PyObject *\nGenericPyCData_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    CDataObject *obj;\n    StgDictObject *dict;\n\n    dict = PyType_stgdict((PyObject *)type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n\n    obj = (CDataObject *)type->tp_alloc(type, 0);\n    if (!obj)\n        return NULL;\n\n    obj->b_base = NULL;\n    obj->b_index = 0;\n    obj->b_objects = NULL;\n    obj->b_length = dict->length;\n\n    if (-1 == PyCData_MallocBuffer(obj, dict)) {\n        Py_DECREF(obj);\n        return NULL;\n    }\n    return (PyObject *)obj;\n}\n/*****************************************************************/\n/*\n  PyCFuncPtr_Type\n*/\n\nstatic int\nPyCFuncPtr_set_errcheck(PyCFuncPtrObject *self, PyObject *ob, void *Py_UNUSED(ignored))\n{\n    if (ob && !PyCallable_Check(ob)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the errcheck attribute must be callable\");\n        return -1;\n    }\n    Py_XINCREF(ob);\n    Py_XSETREF(self->errcheck, ob);\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_errcheck(PyCFuncPtrObject *self, void *Py_UNUSED(ignored))\n{\n    if (self->errcheck) {\n        Py_INCREF(self->errcheck);\n        return self->errcheck;\n    }\n    Py_RETURN_NONE;\n}\n\nstatic int\nPyCFuncPtr_set_restype(PyCFuncPtrObject *self, PyObject *ob, void *Py_UNUSED(ignored))\n{\n    if (ob == NULL) {\n        Py_CLEAR(self->restype);\n        Py_CLEAR(self->checker);\n        return 0;\n    }\n    if (ob != Py_None && !PyType_stgdict(ob) && !PyCallable_Check(ob)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"restype must be a type, a callable, or None\");\n        return -1;\n    }\n    Py_INCREF(ob);\n    Py_XSETREF(self->restype, ob);\n    Py_XSETREF(self->checker, PyObject_GetAttrString(ob, \"_check_retval_\"));\n    if (self->checker == NULL)\n        PyErr_Clear();\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_restype(PyCFuncPtrObject *self, void *Py_UNUSED(ignored))\n{\n    StgDictObject *dict;\n    if (self->restype) {\n        Py_INCREF(self->restype);\n        return self->restype;\n    }\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    if (dict->restype) {\n        Py_INCREF(dict->restype);\n        return dict->restype;\n    } else {\n        Py_RETURN_NONE;\n    }\n}\n\nstatic int\nPyCFuncPtr_set_argtypes(PyCFuncPtrObject *self, PyObject *ob, void *Py_UNUSED(ignored))\n{\n    PyObject *converters;\n\n    if (ob == NULL || ob == Py_None) {\n        Py_CLEAR(self->converters);\n        Py_CLEAR(self->argtypes);\n    } else {\n        converters = converters_from_argtypes(ob);\n        if (!converters)\n            return -1;\n        Py_XSETREF(self->converters, converters);\n        Py_INCREF(ob);\n        Py_XSETREF(self->argtypes, ob);\n    }\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_argtypes(PyCFuncPtrObject *self, void *Py_UNUSED(ignored))\n{\n    StgDictObject *dict;\n    if (self->argtypes) {\n        Py_INCREF(self->argtypes);\n        return self->argtypes;\n    }\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    if (dict->argtypes) {\n        Py_INCREF(dict->argtypes);\n        return dict->argtypes;\n    } else {\n        Py_RETURN_NONE;\n    }\n}\n\nstatic PyGetSetDef PyCFuncPtr_getsets[] = {\n    { \"errcheck\", (getter)PyCFuncPtr_get_errcheck, (setter)PyCFuncPtr_set_errcheck,\n      \"a function to check for errors\", NULL },\n    { \"restype\", (getter)PyCFuncPtr_get_restype, (setter)PyCFuncPtr_set_restype,\n      \"specify the result type\", NULL },\n    { \"argtypes\", (getter)PyCFuncPtr_get_argtypes,\n      (setter)PyCFuncPtr_set_argtypes,\n      \"specify the argument types\", NULL },\n    { NULL, NULL }\n};\n\n#ifdef MS_WIN32\nstatic PPROC FindAddress(void *handle, const char *name, PyObject *type)\n{\n#ifdef MS_WIN64\n    /* win64 has no stdcall calling conv, so it should\n       also not have the name mangling of it.\n    */\n    return (PPROC)GetProcAddress(handle, name);\n#else\n    PPROC address;\n    char *mangled_name;\n    int i;\n    StgDictObject *dict;\n\n    address = (PPROC)GetProcAddress(handle, name);\n    if (address)\n        return address;\n    if (((size_t)name & ~0xFFFF) == 0) {\n        return NULL;\n    }\n\n    dict = PyType_stgdict((PyObject *)type);\n    /* It should not happen that dict is NULL, but better be safe */\n    if (dict==NULL || dict->flags & FUNCFLAG_CDECL)\n        return address;\n\n    /* for stdcall, try mangled names:\n       funcname -> _funcname@<n>\n       where n is 0, 4, 8, 12, ..., 128\n     */\n    mangled_name = alloca(strlen(name) + 1 + 1 + 1 + 3); /* \\0 _ @ %d */\n    if (!mangled_name)\n        return NULL;\n    for (i = 0; i < 32; ++i) {\n        sprintf(mangled_name, \"_%s@%d\", name, i*4);\n        address = (PPROC)GetProcAddress(handle, mangled_name);\n        if (address)\n            return address;\n    }\n    return NULL;\n#endif\n}\n#endif\n\n/* Return 1 if usable, 0 else and exception set. */\nstatic int\n_check_outarg_type(PyObject *arg, Py_ssize_t index)\n{\n    StgDictObject *dict;\n\n    if (PyCPointerTypeObject_Check(arg))\n        return 1;\n\n    if (PyCArrayTypeObject_Check(arg))\n        return 1;\n\n    dict = PyType_stgdict(arg);\n    if (dict\n        /* simple pointer types, c_void_p, c_wchar_p, BSTR, ... */\n        && PyUnicode_Check(dict->proto)\n/* We only allow c_void_p, c_char_p and c_wchar_p as a simple output parameter type */\n        && (strchr(\"PzZ\", PyUnicode_AsUTF8(dict->proto)[0]))) {\n        return 1;\n    }\n\n    PyErr_Format(PyExc_TypeError,\n                 \"'out' parameter %d must be a pointer type, not %s\",\n                 Py_SAFE_DOWNCAST(index, Py_ssize_t, int),\n                 PyType_Check(arg) ?\n                 ((PyTypeObject *)arg)->tp_name :\n             Py_TYPE(arg)->tp_name);\n    return 0;\n}\n\n/* Returns 1 on success, 0 on error */\nstatic int\n_validate_paramflags(PyTypeObject *type, PyObject *paramflags)\n{\n    Py_ssize_t i, len;\n    StgDictObject *dict;\n    PyObject *argtypes;\n\n    dict = PyType_stgdict((PyObject *)type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return 0;\n    }\n    argtypes = dict->argtypes;\n\n    if (paramflags == NULL || dict->argtypes == NULL)\n        return 1;\n\n    if (!PyTuple_Check(paramflags)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"paramflags must be a tuple or None\");\n        return 0;\n    }\n\n    len = PyTuple_GET_SIZE(paramflags);\n    if (len != PyTuple_GET_SIZE(dict->argtypes)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"paramflags must have the same length as argtypes\");\n        return 0;\n    }\n\n    for (i = 0; i < len; ++i) {\n        PyObject *item = PyTuple_GET_ITEM(paramflags, i);\n        int flag;\n        char *name;\n        PyObject *defval;\n        PyObject *typ;\n        if (!PyArg_ParseTuple(item, \"i|ZO\", &flag, &name, &defval)) {\n            PyErr_SetString(PyExc_TypeError,\n                   \"paramflags must be a sequence of (int [,string [,value]]) tuples\");\n            return 0;\n        }\n        typ = PyTuple_GET_ITEM(argtypes, i);\n        switch (flag & (PARAMFLAG_FIN | PARAMFLAG_FOUT | PARAMFLAG_FLCID)) {\n        case 0:\n        case PARAMFLAG_FIN:\n        case PARAMFLAG_FIN | PARAMFLAG_FLCID:\n        case PARAMFLAG_FIN | PARAMFLAG_FOUT:\n            break;\n        case PARAMFLAG_FOUT:\n            if (!_check_outarg_type(typ, i+1))\n                return 0;\n            break;\n        default:\n            PyErr_Format(PyExc_TypeError,\n                         \"paramflag value %d not supported\",\n                         flag);\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic int\n_get_name(PyObject *obj, const char **pname)\n{\n#ifdef MS_WIN32\n    if (PyLong_Check(obj)) {\n        /* We have to use MAKEINTRESOURCEA for Windows CE.\n           Works on Windows as well, of course.\n        */\n        *pname = MAKEINTRESOURCEA(PyLong_AsUnsignedLongMask(obj) & 0xFFFF);\n        return 1;\n    }\n#endif\n    if (PyBytes_Check(obj)) {\n        *pname = PyBytes_AS_STRING(obj);\n        return *pname ? 1 : 0;\n    }\n    if (PyUnicode_Check(obj)) {\n        *pname = PyUnicode_AsUTF8(obj);\n        return *pname ? 1 : 0;\n    }\n    PyErr_SetString(PyExc_TypeError,\n                    \"function name must be string, bytes object or integer\");\n    return 0;\n}\n\n\nstatic PyObject *\nPyCFuncPtr_FromDll(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    const char *name;\n    int (* address)(void);\n    PyObject *ftuple;\n    PyObject *dll;\n    PyObject *obj;\n    PyCFuncPtrObject *self;\n    void *handle;\n    PyObject *paramflags = NULL;\n\n    if (!PyArg_ParseTuple(args, \"O|O\", &ftuple, &paramflags))\n        return NULL;\n    if (paramflags == Py_None)\n        paramflags = NULL;\n\n    ftuple = PySequence_Tuple(ftuple);\n    if (!ftuple)\n        /* Here ftuple is a borrowed reference */\n        return NULL;\n\n    if (!PyArg_ParseTuple(ftuple, \"O&O;illegal func_spec argument\",\n                          _get_name, &name, &dll))\n    {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n    obj = PyObject_GetAttrString(dll, \"_handle\");\n    if (!obj) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n    if (!PyLong_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the _handle attribute of the second argument must be an integer\");\n        Py_DECREF(ftuple);\n        Py_DECREF(obj);\n        return NULL;\n    }\n    handle = (void *)PyLong_AsVoidPtr(obj);\n    Py_DECREF(obj);\n    if (PyErr_Occurred()) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"could not convert the _handle attribute to a pointer\");\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n#ifdef MS_WIN32\n    address = FindAddress(handle, name, (PyObject *)type);\n    if (!address) {\n        if (!IS_INTRESOURCE(name))\n            PyErr_Format(PyExc_AttributeError,\n                         \"function '%s' not found\",\n                         name);\n        else\n            PyErr_Format(PyExc_AttributeError,\n                         \"function ordinal %d not found\",\n                         (WORD)(size_t)name);\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n#else\n    address = (PPROC)ctypes_dlsym(handle, name);\n    if (!address) {\n#ifdef __CYGWIN__\n/* dlerror() isn't very helpful on cygwin */\n        PyErr_Format(PyExc_AttributeError,\n                     \"function '%s' not found\",\n                     name);\n#else\n        PyErr_SetString(PyExc_AttributeError, ctypes_dlerror());\n#endif\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n#endif\n    if (!_validate_paramflags(type, paramflags)) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    if (!self) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n    Py_XINCREF(paramflags);\n    self->paramflags = paramflags;\n\n    *(void **)self->b_ptr = address;\n    Py_INCREF(dll);\n    Py_DECREF(ftuple);\n    if (-1 == KeepRef((CDataObject *)self, 0, dll)) {\n        Py_DECREF((PyObject *)self);\n        return NULL;\n    }\n\n    Py_INCREF(self);\n    self->callable = (PyObject *)self;\n    return (PyObject *)self;\n}\n\n#ifdef MS_WIN32\nstatic PyObject *\nPyCFuncPtr_FromVtblIndex(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyCFuncPtrObject *self;\n    int index;\n    char *name = NULL;\n    PyObject *paramflags = NULL;\n    GUID *iid = NULL;\n    Py_ssize_t iid_len = 0;\n\n    if (!PyArg_ParseTuple(args, \"is|Oz#\", &index, &name, &paramflags, &iid, &iid_len))\n        return NULL;\n    if (paramflags == Py_None)\n        paramflags = NULL;\n\n    if (!_validate_paramflags(type, paramflags))\n        return NULL;\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    self->index = index + 0x1000;\n    Py_XINCREF(paramflags);\n    self->paramflags = paramflags;\n    if (iid_len == sizeof(GUID))\n        self->iid = iid;\n    return (PyObject *)self;\n}\n#endif\n\n/*\n  PyCFuncPtr_new accepts different argument lists in addition to the standard\n  _basespec_ keyword arg:\n\n  one argument form\n  \"i\" - function address\n  \"O\" - must be a callable, creates a C callable function\n\n  two or more argument forms (the third argument is a paramflags tuple)\n  \"(sO)|...\" - (function name, dll object (with an integer handle)), paramflags\n  \"(iO)|...\" - (function ordinal, dll object (with an integer handle)), paramflags\n  \"is|...\" - vtable index, method name, creates callable calling COM vtbl\n*/\nstatic PyObject *\nPyCFuncPtr_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyCFuncPtrObject *self;\n    PyObject *callable;\n    StgDictObject *dict;\n    CThunkObject *thunk;\n\n    if (PyTuple_GET_SIZE(args) == 0)\n        return GenericPyCData_new(type, args, kwds);\n\n    if (1 <= PyTuple_GET_SIZE(args) && PyTuple_Check(PyTuple_GET_ITEM(args, 0)))\n        return PyCFuncPtr_FromDll(type, args, kwds);\n\n#ifdef MS_WIN32\n    if (2 <= PyTuple_GET_SIZE(args) && PyLong_Check(PyTuple_GET_ITEM(args, 0)))\n        return PyCFuncPtr_FromVtblIndex(type, args, kwds);\n#endif\n\n    if (1 == PyTuple_GET_SIZE(args)\n        && (PyLong_Check(PyTuple_GET_ITEM(args, 0)))) {\n        CDataObject *ob;\n        void *ptr = PyLong_AsVoidPtr(PyTuple_GET_ITEM(args, 0));\n        if (ptr == NULL && PyErr_Occurred())\n            return NULL;\n        ob = (CDataObject *)GenericPyCData_new(type, args, kwds);\n        if (ob == NULL)\n            return NULL;\n        *(void **)ob->b_ptr = ptr;\n        return (PyObject *)ob;\n    }\n\n    if (!PyArg_ParseTuple(args, \"O\", &callable))\n        return NULL;\n    if (!PyCallable_Check(callable)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"argument must be callable or integer function address\");\n        return NULL;\n    }\n\n    /* XXX XXX This would allow passing additional options.  For COM\n       method *implementations*, we would probably want different\n       behaviour than in 'normal' callback functions: return a HRESULT if\n       an exception occurs in the callback, and print the traceback not\n       only on the console, but also to OutputDebugString() or something\n       like that.\n    */\n/*\n    if (kwds && PyDict_GetItemString(kwds, \"options\")) {\n        ...\n    }\n*/\n\n    dict = PyType_stgdict((PyObject *)type);\n    /* XXXX Fails if we do: 'PyCFuncPtr(lambda x: x)' */\n    if (!dict || !dict->argtypes) {\n        PyErr_SetString(PyExc_TypeError,\n               \"cannot construct instance of this class:\"\n            \" no argtypes\");\n        return NULL;\n    }\n\n    thunk = _ctypes_alloc_callback(callable,\n                                  dict->argtypes,\n                                  dict->restype,\n                                  dict->flags);\n    if (!thunk)\n        return NULL;\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    if (self == NULL) {\n        Py_DECREF(thunk);\n        return NULL;\n    }\n\n    Py_INCREF(callable);\n    self->callable = callable;\n\n    self->thunk = thunk;\n    *(void **)self->b_ptr = (void *)thunk->pcl_exec;\n\n    Py_INCREF((PyObject *)thunk); /* for KeepRef */\n    if (-1 == KeepRef((CDataObject *)self, 0, (PyObject *)thunk)) {\n        Py_DECREF((PyObject *)self);\n        return NULL;\n    }\n    return (PyObject *)self;\n}\n\n\n/*\n  _byref consumes a refcount to its argument\n*/\nstatic PyObject *\n_byref(PyObject *obj)\n{\n    PyCArgObject *parg;\n    if (!CDataObject_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected CData instance\");\n        return NULL;\n    }\n\n    parg = PyCArgObject_new();\n    if (parg == NULL) {\n        Py_DECREF(obj);\n        return NULL;\n    }\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    parg->obj = obj;\n    parg->value.p = ((CDataObject *)obj)->b_ptr;\n    return (PyObject *)parg;\n}\n\nstatic PyObject *\n_get_arg(int *pindex, PyObject *name, PyObject *defval, PyObject *inargs, PyObject *kwds)\n{\n    PyObject *v;\n\n    if (*pindex < PyTuple_GET_SIZE(inargs)) {\n        v = PyTuple_GET_ITEM(inargs, *pindex);\n        ++*pindex;\n        Py_INCREF(v);\n        return v;\n    }\n    if (kwds && name && (v = PyDict_GetItem(kwds, name))) {\n        ++*pindex;\n        Py_INCREF(v);\n        return v;\n    }\n    if (defval) {\n        Py_INCREF(defval);\n        return defval;\n    }\n    /* we can't currently emit a better error message */\n    if (name)\n        PyErr_Format(PyExc_TypeError,\n                     \"required argument '%S' missing\", name);\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"not enough arguments\");\n    return NULL;\n}\n\n/*\n This function implements higher level functionality plus the ability to call\n functions with keyword arguments by looking at parameter flags.  parameter\n flags is a tuple of 1, 2 or 3-tuples.  The first entry in each is an integer\n specifying the direction of the data transfer for this parameter - 'in',\n 'out' or 'inout' (zero means the same as 'in').  The second entry is the\n parameter name, and the third is the default value if the parameter is\n missing in the function call.\n\n This function builds and returns a new tuple 'callargs' which contains the\n parameters to use in the call.  Items on this tuple are copied from the\n 'inargs' tuple for 'in' and 'in, out' parameters, and constructed from the\n 'argtypes' tuple for 'out' parameters.  It also calculates numretvals which\n is the number of return values for the function, outmask/inoutmask are\n bitmasks containing indexes into the callargs tuple specifying which\n parameters have to be returned.  _build_result builds the return value of the\n function.\n*/\nstatic PyObject *\n_build_callargs(PyCFuncPtrObject *self, PyObject *argtypes,\n                PyObject *inargs, PyObject *kwds,\n                int *poutmask, int *pinoutmask, unsigned int *pnumretvals)\n{\n    PyObject *paramflags = self->paramflags;\n    PyObject *callargs;\n    StgDictObject *dict;\n    Py_ssize_t i, len;\n    int inargs_index = 0;\n    /* It's a little bit difficult to determine how many arguments the\n    function call requires/accepts.  For simplicity, we count the consumed\n    args and compare this to the number of supplied args. */\n    Py_ssize_t actual_args;\n\n    *poutmask = 0;\n    *pinoutmask = 0;\n    *pnumretvals = 0;\n\n    /* Trivial cases, where we either return inargs itself, or a slice of it. */\n    if (argtypes == NULL || paramflags == NULL || PyTuple_GET_SIZE(argtypes) == 0) {\n#ifdef MS_WIN32\n        if (self->index)\n            return PyTuple_GetSlice(inargs, 1, PyTuple_GET_SIZE(inargs));\n#endif\n        Py_INCREF(inargs);\n        return inargs;\n    }\n\n    len = PyTuple_GET_SIZE(argtypes);\n    callargs = PyTuple_New(len); /* the argument tuple we build */\n    if (callargs == NULL)\n        return NULL;\n\n#ifdef MS_WIN32\n    /* For a COM method, skip the first arg */\n    if (self->index) {\n        inargs_index = 1;\n    }\n#endif\n    for (i = 0; i < len; ++i) {\n        PyObject *item = PyTuple_GET_ITEM(paramflags, i);\n        PyObject *ob;\n        int flag;\n        PyObject *name = NULL;\n        PyObject *defval = NULL;\n\n        /* This way seems to be ~2 us faster than the PyArg_ParseTuple\n           calls below. */\n        /* We HAVE already checked that the tuple can be parsed with \"i|ZO\", so... */\n        Py_ssize_t tsize = PyTuple_GET_SIZE(item);\n        flag = PyLong_AS_LONG(PyTuple_GET_ITEM(item, 0));\n        name = tsize > 1 ? PyTuple_GET_ITEM(item, 1) : NULL;\n        defval = tsize > 2 ? PyTuple_GET_ITEM(item, 2) : NULL;\n\n        switch (flag & (PARAMFLAG_FIN | PARAMFLAG_FOUT | PARAMFLAG_FLCID)) {\n        case PARAMFLAG_FIN | PARAMFLAG_FLCID:\n            /* ['in', 'lcid'] parameter.  Always taken from defval,\n             if given, else the integer 0. */\n            if (defval == NULL)\n                defval = _PyLong_Zero;\n            Py_INCREF(defval);\n            PyTuple_SET_ITEM(callargs, i, defval);\n            break;\n        case (PARAMFLAG_FIN | PARAMFLAG_FOUT):\n            *pinoutmask |= (1 << i); /* mark as inout arg */\n            (*pnumretvals)++;\n            /* fall through */\n        case 0:\n        case PARAMFLAG_FIN:\n            /* 'in' parameter.  Copy it from inargs. */\n            ob =_get_arg(&inargs_index, name, defval, inargs, kwds);\n            if (ob == NULL)\n                goto error;\n            PyTuple_SET_ITEM(callargs, i, ob);\n            break;\n        case PARAMFLAG_FOUT:\n            /* XXX Refactor this code into a separate function. */\n            /* 'out' parameter.\n               argtypes[i] must be a POINTER to a c type.\n\n               Cannot by supplied in inargs, but a defval will be used\n               if available.  XXX Should we support getting it from kwds?\n            */\n            if (defval) {\n                /* XXX Using mutable objects as defval will\n                   make the function non-threadsafe, unless we\n                   copy the object in each invocation */\n                Py_INCREF(defval);\n                PyTuple_SET_ITEM(callargs, i, defval);\n                *poutmask |= (1 << i); /* mark as out arg */\n                (*pnumretvals)++;\n                break;\n            }\n            ob = PyTuple_GET_ITEM(argtypes, i);\n            dict = PyType_stgdict(ob);\n            if (dict == NULL) {\n                /* Cannot happen: _validate_paramflags()\n                  would not accept such an object */\n                PyErr_Format(PyExc_RuntimeError,\n                             \"NULL stgdict unexpected\");\n                goto error;\n            }\n            if (PyUnicode_Check(dict->proto)) {\n                PyErr_Format(\n                    PyExc_TypeError,\n                    \"%s 'out' parameter must be passed as default value\",\n                    ((PyTypeObject *)ob)->tp_name);\n                goto error;\n            }\n            if (PyCArrayTypeObject_Check(ob))\n                ob = _PyObject_CallNoArg(ob);\n            else\n                /* Create an instance of the pointed-to type */\n                ob = _PyObject_CallNoArg(dict->proto);\n            /*\n               XXX Is the following correct any longer?\n               We must not pass a byref() to the array then but\n               the array instance itself. Then, we cannot retrieve\n               the result from the PyCArgObject.\n            */\n            if (ob == NULL)\n                goto error;\n            /* The .from_param call that will occur later will pass this\n               as a byref parameter. */\n            PyTuple_SET_ITEM(callargs, i, ob);\n            *poutmask |= (1 << i); /* mark as out arg */\n            (*pnumretvals)++;\n            break;\n        default:\n            PyErr_Format(PyExc_ValueError,\n                         \"paramflag %d not yet implemented\", flag);\n            goto error;\n            break;\n        }\n    }\n\n    /* We have counted the arguments we have consumed in 'inargs_index'.  This\n       must be the same as len(inargs) + len(kwds), otherwise we have\n       either too much or not enough arguments. */\n\n    actual_args = PyTuple_GET_SIZE(inargs) + (kwds ? PyDict_GET_SIZE(kwds) : 0);\n    if (actual_args != inargs_index) {\n        /* When we have default values or named parameters, this error\n           message is misleading.  See unittests/test_paramflags.py\n         */\n        PyErr_Format(PyExc_TypeError,\n                     \"call takes exactly %d arguments (%zd given)\",\n                     inargs_index, actual_args);\n        goto error;\n    }\n\n    /* outmask is a bitmask containing indexes into callargs.  Items at\n       these indexes contain values to return.\n     */\n    return callargs;\n  error:\n    Py_DECREF(callargs);\n    return NULL;\n}\n\n/* See also:\n   http://msdn.microsoft.com/library/en-us/com/html/769127a1-1a14-4ed4-9d38-7cf3e571b661.asp\n*/\n/*\n  Build return value of a function.\n\n  Consumes the refcount on result and callargs.\n*/\nstatic PyObject *\n_build_result(PyObject *result, PyObject *callargs,\n              int outmask, int inoutmask, unsigned int numretvals)\n{\n    unsigned int i, index;\n    int bit;\n    PyObject *tup = NULL;\n\n    if (callargs == NULL)\n        return result;\n    if (result == NULL || numretvals == 0) {\n        Py_DECREF(callargs);\n        return result;\n    }\n    Py_DECREF(result);\n\n    /* tup will not be allocated if numretvals == 1 */\n    /* allocate tuple to hold the result */\n    if (numretvals > 1) {\n        tup = PyTuple_New(numretvals);\n        if (tup == NULL) {\n            Py_DECREF(callargs);\n            return NULL;\n        }\n    }\n\n    index = 0;\n    for (bit = 1, i = 0; i < 32; ++i, bit <<= 1) {\n        PyObject *v;\n        if (bit & inoutmask) {\n            v = PyTuple_GET_ITEM(callargs, i);\n            Py_INCREF(v);\n            if (numretvals == 1) {\n                Py_DECREF(callargs);\n                return v;\n            }\n            PyTuple_SET_ITEM(tup, index, v);\n            index++;\n        } else if (bit & outmask) {\n            _Py_IDENTIFIER(__ctypes_from_outparam__);\n\n            v = PyTuple_GET_ITEM(callargs, i);\n            v = _PyObject_CallMethodId(v, &PyId___ctypes_from_outparam__, NULL);\n            if (v == NULL || numretvals == 1) {\n                Py_DECREF(callargs);\n                return v;\n            }\n            PyTuple_SET_ITEM(tup, index, v);\n            index++;\n        }\n        if (index == numretvals)\n            break;\n    }\n\n    Py_DECREF(callargs);\n    return tup;\n}\n\nstatic PyObject *\nPyCFuncPtr_call(PyCFuncPtrObject *self, PyObject *inargs, PyObject *kwds)\n{\n    PyObject *restype;\n    PyObject *converters;\n    PyObject *checker;\n    PyObject *argtypes;\n    StgDictObject *dict = PyObject_stgdict((PyObject *)self);\n    PyObject *result;\n    PyObject *callargs;\n    PyObject *errcheck;\n#ifdef MS_WIN32\n    IUnknown *piunk = NULL;\n#endif\n    void *pProc = NULL;\n\n    int inoutmask;\n    int outmask;\n    unsigned int numretvals;\n\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    restype = self->restype ? self->restype : dict->restype;\n    converters = self->converters ? self->converters : dict->converters;\n    checker = self->checker ? self->checker : dict->checker;\n    argtypes = self->argtypes ? self->argtypes : dict->argtypes;\n/* later, we probably want to have an errcheck field in stgdict */\n    errcheck = self->errcheck /* ? self->errcheck : dict->errcheck */;\n\n\n    pProc = *(void **)self->b_ptr;\n#ifdef MS_WIN32\n    if (self->index) {\n        /* It's a COM method */\n        CDataObject *this;\n        this = (CDataObject *)PyTuple_GetItem(inargs, 0); /* borrowed ref! */\n        if (!this) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"native com method call without 'this' parameter\");\n            return NULL;\n        }\n        if (!CDataObject_Check(this)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"Expected a COM this pointer as first argument\");\n            return NULL;\n        }\n        /* there should be more checks? No, in Python */\n        /* First arg is a pointer to an interface instance */\n        if (!this->b_ptr || *(void **)this->b_ptr == NULL) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"NULL COM pointer access\");\n            return NULL;\n        }\n        piunk = *(IUnknown **)this->b_ptr;\n        if (NULL == piunk->lpVtbl) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"COM method call without VTable\");\n            return NULL;\n        }\n        pProc = ((void **)piunk->lpVtbl)[self->index - 0x1000];\n    }\n#endif\n    callargs = _build_callargs(self, argtypes,\n                               inargs, kwds,\n                               &outmask, &inoutmask, &numretvals);\n    if (callargs == NULL)\n        return NULL;\n\n    if (converters) {\n        int required = Py_SAFE_DOWNCAST(PyTuple_GET_SIZE(converters),\n                                        Py_ssize_t, int);\n        int actual = Py_SAFE_DOWNCAST(PyTuple_GET_SIZE(callargs),\n                                      Py_ssize_t, int);\n\n        if ((dict->flags & FUNCFLAG_CDECL) == FUNCFLAG_CDECL) {\n            /* For cdecl functions, we allow more actual arguments\n               than the length of the argtypes tuple.\n            */\n            if (required > actual) {\n                Py_DECREF(callargs);\n                PyErr_Format(PyExc_TypeError,\n              \"this function takes at least %d argument%s (%d given)\",\n                                 required,\n                                 required == 1 ? \"\" : \"s\",\n                                 actual);\n                return NULL;\n            }\n        } else if (required != actual) {\n            Py_DECREF(callargs);\n            PyErr_Format(PyExc_TypeError,\n                 \"this function takes %d argument%s (%d given)\",\n                     required,\n                     required == 1 ? \"\" : \"s\",\n                     actual);\n            return NULL;\n        }\n    }\n\n    result = _ctypes_callproc(pProc,\n                       callargs,\n#ifdef MS_WIN32\n                       piunk,\n                       self->iid,\n#endif\n                       dict->flags,\n                       converters,\n                       restype,\n                       checker);\n/* The 'errcheck' protocol */\n    if (result != NULL && errcheck) {\n        PyObject *v = PyObject_CallFunctionObjArgs(errcheck,\n                                                   result,\n                                                   self,\n                                                   callargs,\n                                                   NULL);\n        /* If the errcheck function failed, return NULL.\n           If the errcheck function returned callargs unchanged,\n           continue normal processing.\n           If the errcheck function returned something else,\n           use that as result.\n        */\n        if (v == NULL || v != callargs) {\n            Py_DECREF(result);\n            Py_DECREF(callargs);\n            return v;\n        }\n        Py_DECREF(v);\n    }\n\n    return _build_result(result, callargs,\n                         outmask, inoutmask, numretvals);\n}\n\nstatic int\nPyCFuncPtr_traverse(PyCFuncPtrObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->callable);\n    Py_VISIT(self->restype);\n    Py_VISIT(self->checker);\n    Py_VISIT(self->errcheck);\n    Py_VISIT(self->argtypes);\n    Py_VISIT(self->converters);\n    Py_VISIT(self->paramflags);\n    Py_VISIT(self->thunk);\n    return PyCData_traverse((CDataObject *)self, visit, arg);\n}\n\nstatic int\nPyCFuncPtr_clear(PyCFuncPtrObject *self)\n{\n    Py_CLEAR(self->callable);\n    Py_CLEAR(self->restype);\n    Py_CLEAR(self->checker);\n    Py_CLEAR(self->errcheck);\n    Py_CLEAR(self->argtypes);\n    Py_CLEAR(self->converters);\n    Py_CLEAR(self->paramflags);\n    Py_CLEAR(self->thunk);\n    return PyCData_clear((CDataObject *)self);\n}\n\nstatic void\nPyCFuncPtr_dealloc(PyCFuncPtrObject *self)\n{\n    PyCFuncPtr_clear(self);\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic PyObject *\nPyCFuncPtr_repr(PyCFuncPtrObject *self)\n{\n#ifdef MS_WIN32\n    if (self->index)\n        return PyUnicode_FromFormat(\"<COM method offset %d: %s at %p>\",\n                                   self->index - 0x1000,\n                                   Py_TYPE(self)->tp_name,\n                                   self);\n#endif\n    return PyUnicode_FromFormat(\"<%s object at %p>\",\n                               Py_TYPE(self)->tp_name,\n                               self);\n}\n\nstatic int\nPyCFuncPtr_bool(PyCFuncPtrObject *self)\n{\n    return ((*(void **)self->b_ptr != NULL)\n#ifdef MS_WIN32\n        || (self->index != 0)\n#endif\n        );\n}\n\nstatic PyNumberMethods PyCFuncPtr_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)PyCFuncPtr_bool, /* nb_bool */\n};\n\nPyTypeObject PyCFuncPtr_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCFuncPtr\",\n    sizeof(PyCFuncPtrObject),                           /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    (destructor)PyCFuncPtr_dealloc,             /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    (reprfunc)PyCFuncPtr_repr,                  /* tp_repr */\n    &PyCFuncPtr_as_number,                      /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    (ternaryfunc)PyCFuncPtr_call,               /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"Function Pointer\",                         /* tp_doc */\n    (traverseproc)PyCFuncPtr_traverse,          /* tp_traverse */\n    (inquiry)PyCFuncPtr_clear,                  /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    PyCFuncPtr_getsets,                         /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCFuncPtr_new,                             /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/*****************************************************************/\n/*\n  Struct_Type\n*/\n/*\n  This function is called to initialize a Structure or Union with positional\n  arguments. It calls itself recursively for all Structure or Union base\n  classes, then retrieves the _fields_ member to associate the argument\n  position with the correct field name.\n\n  Returns -1 on error, or the index of next argument on success.\n */\nstatic Py_ssize_t\n_init_pos_args(PyObject *self, PyTypeObject *type,\n               PyObject *args, PyObject *kwds,\n               Py_ssize_t index)\n{\n    StgDictObject *dict;\n    PyObject *fields;\n    Py_ssize_t i;\n\n    if (PyType_stgdict((PyObject *)type->tp_base)) {\n        index = _init_pos_args(self, type->tp_base,\n                               args, kwds,\n                               index);\n        if (index == -1)\n            return -1;\n    }\n\n    dict = PyType_stgdict((PyObject *)type);\n    fields = PyDict_GetItemString((PyObject *)dict, \"_fields_\");\n    if (fields == NULL)\n        return index;\n\n    for (i = 0;\n         i < dict->length && (i+index) < PyTuple_GET_SIZE(args);\n         ++i) {\n        PyObject *pair = PySequence_GetItem(fields, i);\n        PyObject *name, *val;\n        int res;\n        if (!pair)\n            return -1;\n        name = PySequence_GetItem(pair, 0);\n        if (!name) {\n            Py_DECREF(pair);\n            return -1;\n        }\n        val = PyTuple_GET_ITEM(args, i + index);\n        if (kwds && PyDict_GetItem(kwds, name)) {\n            PyErr_Format(PyExc_TypeError,\n                         \"duplicate values for field %R\",\n                         name);\n            Py_DECREF(pair);\n            Py_DECREF(name);\n            return -1;\n        }\n\n        res = PyObject_SetAttr(self, name, val);\n        Py_DECREF(pair);\n        Py_DECREF(name);\n        if (res == -1)\n            return -1;\n    }\n    return index + dict->length;\n}\n\nstatic int\nStruct_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n/* Optimization possible: Store the attribute names _fields_[x][0]\n * in C accessible fields somewhere ?\n */\n    if (!PyTuple_Check(args)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"args not a tuple?\");\n        return -1;\n    }\n    if (PyTuple_GET_SIZE(args)) {\n        Py_ssize_t res = _init_pos_args(self, Py_TYPE(self),\n                                        args, kwds, 0);\n        if (res == -1)\n            return -1;\n        if (res < PyTuple_GET_SIZE(args)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"too many initializers\");\n            return -1;\n        }\n    }\n\n    if (kwds) {\n        PyObject *key, *value;\n        Py_ssize_t pos = 0;\n        while(PyDict_Next(kwds, &pos, &key, &value)) {\n            if (-1 == PyObject_SetAttr(self, key, value))\n                return -1;\n        }\n    }\n    return 0;\n}\n\nstatic PyTypeObject Struct_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Structure\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"Structure base class\",                     /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    Struct_init,                                /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic PyTypeObject Union_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Union\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"Union base class\",                         /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    Struct_init,                                /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCArray_Type\n*/\nstatic int\nArray_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    Py_ssize_t i;\n    Py_ssize_t n;\n\n    if (!PyTuple_Check(args)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"args not a tuple?\");\n        return -1;\n    }\n    n = PyTuple_GET_SIZE(args);\n    for (i = 0; i < n; ++i) {\n        PyObject *v;\n        v = PyTuple_GET_ITEM(args, i);\n        if (-1 == PySequence_SetItem((PyObject *)self, i, v))\n            return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *\nArray_item(PyObject *myself, Py_ssize_t index)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t offset, size;\n    StgDictObject *stgdict;\n\n\n    if (index < 0 || index >= self->b_length) {\n        PyErr_SetString(PyExc_IndexError,\n                        \"invalid index\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for array instances */\n    /* Would it be clearer if we got the item size from\n       stgdict->proto's stgdict?\n    */\n    size = stgdict->size / stgdict->length;\n    offset = index * size;\n\n    return PyCData_get(stgdict->proto, stgdict->getfunc, (PyObject *)self,\n                     index, size, self->b_ptr + offset);\n}\n\nstatic PyObject *\nArray_subscript(PyObject *myself, PyObject *item)\n{\n    CDataObject *self = (CDataObject *)myself;\n\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n\n        if (i == -1 && PyErr_Occurred())\n            return NULL;\n        if (i < 0)\n            i += self->b_length;\n        return Array_item(myself, i);\n    }\n    else if (PySlice_Check(item)) {\n        StgDictObject *stgdict, *itemdict;\n        PyObject *proto;\n        PyObject *np;\n        Py_ssize_t start, stop, step, slicelen, i;\n        size_t cur;\n\n        if (PySlice_Unpack(item, &start, &stop, &step) < 0) {\n            return NULL;\n        }\n        slicelen = PySlice_AdjustIndices(self->b_length, &start, &stop, step);\n\n        stgdict = PyObject_stgdict((PyObject *)self);\n        assert(stgdict); /* Cannot be NULL for array object instances */\n        proto = stgdict->proto;\n        itemdict = PyType_stgdict(proto);\n        assert(itemdict); /* proto is the item type of the array, a\n                             ctypes type, so this cannot be NULL */\n\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n            char *ptr = (char *)self->b_ptr;\n            char *dest;\n\n            if (slicelen <= 0)\n                return PyBytes_FromStringAndSize(\"\", 0);\n            if (step == 1) {\n                return PyBytes_FromStringAndSize(ptr + start,\n                                                 slicelen);\n            }\n            dest = (char *)PyMem_Malloc(slicelen);\n\n            if (dest == NULL)\n                return PyErr_NoMemory();\n\n            for (cur = start, i = 0; i < slicelen;\n                 cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n\n            np = PyBytes_FromStringAndSize(dest, slicelen);\n            PyMem_Free(dest);\n            return np;\n        }\n#ifdef CTYPES_UNICODE\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n            wchar_t *ptr = (wchar_t *)self->b_ptr;\n            wchar_t *dest;\n\n            if (slicelen <= 0)\n                return PyUnicode_New(0, 0);\n            if (step == 1) {\n                return PyUnicode_FromWideChar(ptr + start,\n                                              slicelen);\n            }\n\n            dest = PyMem_New(wchar_t, slicelen);\n            if (dest == NULL) {\n                PyErr_NoMemory();\n                return NULL;\n            }\n\n            for (cur = start, i = 0; i < slicelen;\n                 cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n\n            np = PyUnicode_FromWideChar(dest, slicelen);\n            PyMem_Free(dest);\n            return np;\n        }\n#endif\n\n        np = PyList_New(slicelen);\n        if (np == NULL)\n            return NULL;\n\n        for (cur = start, i = 0; i < slicelen;\n             cur += step, i++) {\n            PyObject *v = Array_item(myself, cur);\n            if (v == NULL) {\n                Py_DECREF(np);\n                return NULL;\n            }\n            PyList_SET_ITEM(np, i, v);\n        }\n        return np;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"indices must be integers\");\n        return NULL;\n    }\n\n}\n\nstatic int\nArray_ass_item(PyObject *myself, Py_ssize_t index, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t size, offset;\n    StgDictObject *stgdict;\n    char *ptr;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Array does not support item deletion\");\n        return -1;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for array object instances */\n    if (index < 0 || index >= stgdict->length) {\n        PyErr_SetString(PyExc_IndexError,\n                        \"invalid index\");\n        return -1;\n    }\n    size = stgdict->size / stgdict->length;\n    offset = index * size;\n    ptr = self->b_ptr + offset;\n\n    return PyCData_set((PyObject *)self, stgdict->proto, stgdict->setfunc, value,\n                     index, size, ptr);\n}\n\nstatic int\nArray_ass_subscript(PyObject *myself, PyObject *item, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)myself;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Array does not support item deletion\");\n        return -1;\n    }\n\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n\n        if (i == -1 && PyErr_Occurred())\n            return -1;\n        if (i < 0)\n            i += self->b_length;\n        return Array_ass_item(myself, i, value);\n    }\n    else if (PySlice_Check(item)) {\n        Py_ssize_t start, stop, step, slicelen, otherlen, i;\n        size_t cur;\n\n        if (PySlice_Unpack(item, &start, &stop, &step) < 0) {\n            return -1;\n        }\n        slicelen = PySlice_AdjustIndices(self->b_length, &start, &stop, step);\n        if ((step < 0 && start < stop) ||\n            (step > 0 && start > stop))\n            stop = start;\n\n        otherlen = PySequence_Length(value);\n        if (otherlen != slicelen) {\n            PyErr_SetString(PyExc_ValueError,\n                \"Can only assign sequence of same size\");\n            return -1;\n        }\n        for (cur = start, i = 0; i < otherlen; cur += step, i++) {\n            PyObject *item = PySequence_GetItem(value, i);\n            int result;\n            if (item == NULL)\n                return -1;\n            result = Array_ass_item(myself, cur, item);\n            Py_DECREF(item);\n            if (result == -1)\n                return -1;\n        }\n        return 0;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"indices must be integer\");\n        return -1;\n    }\n}\n\nstatic Py_ssize_t\nArray_length(PyObject *myself)\n{\n    CDataObject *self = (CDataObject *)myself;\n    return self->b_length;\n}\n\nstatic PySequenceMethods Array_as_sequence = {\n    Array_length,                               /* sq_length; */\n    0,                                          /* sq_concat; */\n    0,                                          /* sq_repeat; */\n    Array_item,                                 /* sq_item; */\n    0,                                          /* sq_slice; */\n    Array_ass_item,                             /* sq_ass_item; */\n    0,                                          /* sq_ass_slice; */\n    0,                                          /* sq_contains; */\n\n    0,                                          /* sq_inplace_concat; */\n    0,                                          /* sq_inplace_repeat; */\n};\n\nstatic PyMappingMethods Array_as_mapping = {\n    Array_length,\n    Array_subscript,\n    Array_ass_subscript,\n};\n\nPyTypeObject PyCArray_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Array\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &Array_as_sequence,                         /* tp_as_sequence */\n    &Array_as_mapping,                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Array_init,                       /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\nPyObject *\nPyCArrayType_from_ctype(PyObject *itemtype, Py_ssize_t length)\n{\n    static PyObject *cache;\n    PyObject *key;\n    PyObject *result;\n    char name[256];\n    PyObject *len;\n\n    if (cache == NULL) {\n        cache = PyDict_New();\n        if (cache == NULL)\n            return NULL;\n    }\n    len = PyLong_FromSsize_t(length);\n    if (len == NULL)\n        return NULL;\n    key = PyTuple_Pack(2, itemtype, len);\n    Py_DECREF(len);\n    if (!key)\n        return NULL;\n    result = PyDict_GetItemProxy(cache, key);\n    if (result) {\n        Py_INCREF(result);\n        Py_DECREF(key);\n        return result;\n    }\n\n    if (!PyType_Check(itemtype)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Expected a type object\");\n        Py_DECREF(key);\n        return NULL;\n    }\n#ifdef MS_WIN64\n    sprintf(name, \"%.200s_Array_%Id\",\n        ((PyTypeObject *)itemtype)->tp_name, length);\n#else\n    sprintf(name, \"%.200s_Array_%ld\",\n        ((PyTypeObject *)itemtype)->tp_name, (long)length);\n#endif\n\n    result = PyObject_CallFunction((PyObject *)&PyCArrayType_Type,\n                                   \"s(O){s:n,s:O}\",\n                                   name,\n                                   &PyCArray_Type,\n                                   \"_length_\",\n                                   length,\n                                   \"_type_\",\n                                   itemtype\n        );\n    if (result == NULL) {\n        Py_DECREF(key);\n        return NULL;\n    }\n    if (-1 == PyDict_SetItemProxy(cache, key, result)) {\n        Py_DECREF(key);\n        Py_DECREF(result);\n        return NULL;\n    }\n    Py_DECREF(key);\n    return result;\n}\n\n\n/******************************************************************/\n/*\n  Simple_Type\n*/\n\nstatic int\nSimple_set_value(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    PyObject *result;\n    StgDictObject *dict = PyObject_stgdict((PyObject *)self);\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    assert(dict->setfunc);\n    result = dict->setfunc(self->b_ptr, value, dict->size);\n    if (!result)\n        return -1;\n\n    /* consumes the refcount the setfunc returns */\n    return KeepRef(self, 0, result);\n}\n\nstatic int\nSimple_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    PyObject *value = NULL;\n    if (!PyArg_UnpackTuple(args, \"__init__\", 0, 1, &value))\n        return -1;\n    if (value)\n        return Simple_set_value(self, value, NULL);\n    return 0;\n}\n\nstatic PyObject *\nSimple_get_value(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    StgDictObject *dict;\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    assert(dict->getfunc);\n    return dict->getfunc(self->b_ptr, self->b_size);\n}\n\nstatic PyGetSetDef Simple_getsets[] = {\n    { \"value\", (getter)Simple_get_value, (setter)Simple_set_value,\n      \"current value\", NULL },\n    { NULL, NULL }\n};\n\nstatic PyObject *\nSimple_from_outparm(PyObject *self, PyObject *args)\n{\n    if (_ctypes_simple_instance((PyObject *)Py_TYPE(self))) {\n        Py_INCREF(self);\n        return self;\n    }\n    /* call stgdict->getfunc */\n    return Simple_get_value((CDataObject *)self, NULL);\n}\n\nstatic PyMethodDef Simple_methods[] = {\n    { \"__ctypes_from_outparam__\", Simple_from_outparm, METH_NOARGS, },\n    { NULL, NULL },\n};\n\nstatic int Simple_bool(CDataObject *self)\n{\n    return memcmp(self->b_ptr, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", self->b_size);\n}\n\nstatic PyNumberMethods Simple_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)Simple_bool, /* nb_bool */\n};\n\n/* \"%s(%s)\" % (self.__class__.__name__, self.value) */\nstatic PyObject *\nSimple_repr(CDataObject *self)\n{\n    PyObject *val, *result;\n\n    if (Py_TYPE(self)->tp_base != &Simple_Type) {\n        return PyUnicode_FromFormat(\"<%s object at %p>\",\n                                   Py_TYPE(self)->tp_name, self);\n    }\n\n    val = Simple_get_value(self, NULL);\n    if (val == NULL)\n        return NULL;\n\n    result = PyUnicode_FromFormat(\"%s(%R)\",\n                                  Py_TYPE(self)->tp_name, val);\n    Py_DECREF(val);\n    return result;\n}\n\nstatic PyTypeObject Simple_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._SimpleCData\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    (reprfunc)&Simple_repr,                     /* tp_repr */\n    &Simple_as_number,                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    Simple_methods,                             /* tp_methods */\n    0,                                          /* tp_members */\n    Simple_getsets,                             /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Simple_init,                      /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/******************************************************************/\n/*\n  PyCPointer_Type\n*/\nstatic PyObject *\nPointer_item(PyObject *myself, Py_ssize_t index)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t size;\n    Py_ssize_t offset;\n    StgDictObject *stgdict, *itemdict;\n    PyObject *proto;\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer object instances */\n\n    proto = stgdict->proto;\n    assert(proto);\n    itemdict = PyType_stgdict(proto);\n    assert(itemdict); /* proto is the item type of the pointer, a ctypes\n                         type, so this cannot be NULL */\n\n    size = itemdict->size;\n    offset = index * itemdict->size;\n\n    return PyCData_get(proto, stgdict->getfunc, (PyObject *)self,\n                     index, size, (*(char **)self->b_ptr) + offset);\n}\n\nstatic int\nPointer_ass_item(PyObject *myself, Py_ssize_t index, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t size;\n    Py_ssize_t offset;\n    StgDictObject *stgdict, *itemdict;\n    PyObject *proto;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer does not support item deletion\");\n        return -1;\n    }\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return -1;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer instances */\n\n    proto = stgdict->proto;\n    assert(proto);\n\n    itemdict = PyType_stgdict(proto);\n    assert(itemdict); /* Cannot be NULL because the itemtype of a pointer\n                         is always a ctypes type */\n\n    size = itemdict->size;\n    offset = index * itemdict->size;\n\n    return PyCData_set((PyObject *)self, proto, stgdict->setfunc, value,\n                     index, size, (*(char **)self->b_ptr) + offset);\n}\n\nstatic PyObject *\nPointer_get_contents(CDataObject *self, void *closure)\n{\n    StgDictObject *stgdict;\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer instances */\n    return PyCData_FromBaseObj(stgdict->proto,\n                             (PyObject *)self, 0,\n                             *(void **)self->b_ptr);\n}\n\nstatic int\nPointer_set_contents(CDataObject *self, PyObject *value, void *closure)\n{\n    StgDictObject *stgdict;\n    CDataObject *dst;\n    PyObject *keep;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer does not support item deletion\");\n        return -1;\n    }\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer instances */\n    assert(stgdict->proto);\n    if (!CDataObject_Check(value)) {\n        int res = PyObject_IsInstance(value, stgdict->proto);\n        if (res == -1)\n            return -1;\n        if (!res) {\n            PyErr_Format(PyExc_TypeError,\n                         \"expected %s instead of %s\",\n                         ((PyTypeObject *)(stgdict->proto))->tp_name,\n                         Py_TYPE(value)->tp_name);\n            return -1;\n        }\n    }\n\n    dst = (CDataObject *)value;\n    *(void **)self->b_ptr = dst->b_ptr;\n\n    /*\n       A Pointer instance must keep the value it points to alive.  So, a\n       pointer instance has b_length set to 2 instead of 1, and we set\n       'value' itself as the second item of the b_objects list, additionally.\n    */\n    Py_INCREF(value);\n    if (-1 == KeepRef(self, 1, value))\n        return -1;\n\n    keep = GetKeepedObjects(dst);\n    if (keep == NULL)\n        return -1;\n\n    Py_INCREF(keep);\n    return KeepRef(self, 0, keep);\n}\n\nstatic PyGetSetDef Pointer_getsets[] = {\n    { \"contents\", (getter)Pointer_get_contents,\n      (setter)Pointer_set_contents,\n      \"the object this pointer points to (read-write)\", NULL },\n    { NULL, NULL }\n};\n\nstatic int\nPointer_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    PyObject *value = NULL;\n\n    if (!PyArg_UnpackTuple(args, \"POINTER\", 0, 1, &value))\n        return -1;\n    if (value == NULL)\n        return 0;\n    return Pointer_set_contents(self, value, NULL);\n}\n\nstatic PyObject *\nPointer_new(PyTypeObject *type, PyObject *args, PyObject *kw)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)type);\n    if (!dict || !dict->proto) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Cannot create instance: has no _type_\");\n        return NULL;\n    }\n    return GenericPyCData_new(type, args, kw);\n}\n\nstatic PyObject *\nPointer_subscript(PyObject *myself, PyObject *item)\n{\n    CDataObject *self = (CDataObject *)myself;\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n        if (i == -1 && PyErr_Occurred())\n            return NULL;\n        return Pointer_item(myself, i);\n    }\n    else if (PySlice_Check(item)) {\n        PySliceObject *slice = (PySliceObject *)item;\n        Py_ssize_t start, stop, step;\n        PyObject *np;\n        StgDictObject *stgdict, *itemdict;\n        PyObject *proto;\n        Py_ssize_t i, len;\n        size_t cur;\n\n        /* Since pointers have no length, and we want to apply\n           different semantics to negative indices than normal\n           slicing, we have to dissect the slice object ourselves.*/\n        if (slice->step == Py_None) {\n            step = 1;\n        }\n        else {\n            step = PyNumber_AsSsize_t(slice->step,\n                                      PyExc_ValueError);\n            if (step == -1 && PyErr_Occurred())\n                return NULL;\n            if (step == 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"slice step cannot be zero\");\n                return NULL;\n            }\n        }\n        if (slice->start == Py_None) {\n            if (step < 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"slice start is required \"\n                                \"for step < 0\");\n                return NULL;\n            }\n            start = 0;\n        }\n        else {\n            start = PyNumber_AsSsize_t(slice->start,\n                                       PyExc_ValueError);\n            if (start == -1 && PyErr_Occurred())\n                return NULL;\n        }\n        if (slice->stop == Py_None) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"slice stop is required\");\n            return NULL;\n        }\n        stop = PyNumber_AsSsize_t(slice->stop,\n                                  PyExc_ValueError);\n        if (stop == -1 && PyErr_Occurred())\n            return NULL;\n        if ((step > 0 && start > stop) ||\n            (step < 0 && start < stop))\n            len = 0;\n        else if (step > 0)\n            len = (stop - start - 1) / step + 1;\n        else\n            len = (stop - start + 1) / step + 1;\n\n        stgdict = PyObject_stgdict((PyObject *)self);\n        assert(stgdict); /* Cannot be NULL for pointer instances */\n        proto = stgdict->proto;\n        assert(proto);\n        itemdict = PyType_stgdict(proto);\n        assert(itemdict);\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n            char *ptr = *(char **)self->b_ptr;\n            char *dest;\n\n            if (len <= 0)\n                return PyBytes_FromStringAndSize(\"\", 0);\n            if (step == 1) {\n                return PyBytes_FromStringAndSize(ptr + start,\n                                                 len);\n            }\n            dest = (char *)PyMem_Malloc(len);\n            if (dest == NULL)\n                return PyErr_NoMemory();\n            for (cur = start, i = 0; i < len; cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n            np = PyBytes_FromStringAndSize(dest, len);\n            PyMem_Free(dest);\n            return np;\n        }\n#ifdef CTYPES_UNICODE\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n            wchar_t *ptr = *(wchar_t **)self->b_ptr;\n            wchar_t *dest;\n\n            if (len <= 0)\n                return PyUnicode_New(0, 0);\n            if (step == 1) {\n                return PyUnicode_FromWideChar(ptr + start,\n                                              len);\n            }\n            dest = PyMem_New(wchar_t, len);\n            if (dest == NULL)\n                return PyErr_NoMemory();\n            for (cur = start, i = 0; i < len; cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n            np = PyUnicode_FromWideChar(dest, len);\n            PyMem_Free(dest);\n            return np;\n        }\n#endif\n\n        np = PyList_New(len);\n        if (np == NULL)\n            return NULL;\n\n        for (cur = start, i = 0; i < len; cur += step, i++) {\n            PyObject *v = Pointer_item(myself, cur);\n            PyList_SET_ITEM(np, i, v);\n        }\n        return np;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer indices must be integer\");\n        return NULL;\n    }\n}\n\nstatic PySequenceMethods Pointer_as_sequence = {\n    0,                                          /* inquiry sq_length; */\n    0,                                          /* binaryfunc sq_concat; */\n    0,                                          /* intargfunc sq_repeat; */\n    Pointer_item,                               /* intargfunc sq_item; */\n    0,                                          /* intintargfunc sq_slice; */\n    Pointer_ass_item,                           /* intobjargproc sq_ass_item; */\n    0,                                          /* intintobjargproc sq_ass_slice; */\n    0,                                          /* objobjproc sq_contains; */\n    /* Added in release 2.0 */\n    0,                                          /* binaryfunc sq_inplace_concat; */\n    0,                                          /* intargfunc sq_inplace_repeat; */\n};\n\nstatic PyMappingMethods Pointer_as_mapping = {\n    0,\n    Pointer_subscript,\n};\n\nstatic int\nPointer_bool(CDataObject *self)\n{\n    return (*(void **)self->b_ptr != NULL);\n}\n\nstatic PyNumberMethods Pointer_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)Pointer_bool, /* nb_bool */\n};\n\nPyTypeObject PyCPointer_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._Pointer\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    &Pointer_as_number,                         /* tp_as_number */\n    &Pointer_as_sequence,                       /* tp_as_sequence */\n    &Pointer_as_mapping,                        /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    Pointer_getsets,                            /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Pointer_init,                     /* tp_init */\n    0,                                          /* tp_alloc */\n    Pointer_new,                                /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n *  Module initialization.\n */\n\nstatic const char module_docs[] =\n\"Create and manipulate C compatible data types in Python.\";\n\n#ifdef MS_WIN32\n\nstatic const char comerror_doc[] = \"Raised when a COM method call failed.\";\n\nint\ncomerror_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *hresult, *text, *details;\n    PyObject *a;\n    int status;\n\n    if (!_PyArg_NoKeywords(Py_TYPE(self)->tp_name, kwds))\n        return -1;\n\n    if (!PyArg_ParseTuple(args, \"OOO:COMError\", &hresult, &text, &details))\n        return -1;\n\n    a = PySequence_GetSlice(args, 1, PyTuple_GET_SIZE(args));\n    if (!a)\n        return -1;\n    status = PyObject_SetAttrString(self, \"args\", a);\n    Py_DECREF(a);\n    if (status < 0)\n        return -1;\n\n    if (PyObject_SetAttrString(self, \"hresult\", hresult) < 0)\n        return -1;\n\n    if (PyObject_SetAttrString(self, \"text\", text) < 0)\n        return -1;\n\n    if (PyObject_SetAttrString(self, \"details\", details) < 0)\n        return -1;\n\n    Py_INCREF(args);\n    Py_SETREF(((PyBaseExceptionObject *)self)->args, args);\n\n    return 0;\n}\n\nstatic PyTypeObject PyComError_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.COMError\",         /* tp_name */\n    sizeof(PyBaseExceptionObject), /* tp_basicsize */\n    0,                          /* tp_itemsize */\n    0,                          /* tp_dealloc */\n    0,                          /* tp_print */\n    0,                          /* tp_getattr */\n    0,                          /* tp_setattr */\n    0,                          /* tp_reserved */\n    0,                          /* tp_repr */\n    0,                          /* tp_as_number */\n    0,                          /* tp_as_sequence */\n    0,                          /* tp_as_mapping */\n    0,                          /* tp_hash */\n    0,                          /* tp_call */\n    0,                          /* tp_str */\n    0,                          /* tp_getattro */\n    0,                          /* tp_setattro */\n    0,                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */\n    PyDoc_STR(comerror_doc),    /* tp_doc */\n    0,                          /* tp_traverse */\n    0,                          /* tp_clear */\n    0,                          /* tp_richcompare */\n    0,                          /* tp_weaklistoffset */\n    0,                          /* tp_iter */\n    0,                          /* tp_iternext */\n    0,                          /* tp_methods */\n    0,                          /* tp_members */\n    0,                          /* tp_getset */\n    0,                          /* tp_base */\n    0,                          /* tp_dict */\n    0,                          /* tp_descr_get */\n    0,                          /* tp_descr_set */\n    0,                          /* tp_dictoffset */\n    (initproc)comerror_init,    /* tp_init */\n    0,                          /* tp_alloc */\n    0,                          /* tp_new */\n};\n\n\nstatic int\ncreate_comerror(void)\n{\n    PyComError_Type.tp_base = (PyTypeObject*)PyExc_Exception;\n    if (PyType_Ready(&PyComError_Type) < 0)\n        return -1;\n    Py_INCREF(&PyComError_Type);\n    ComError = (PyObject*)&PyComError_Type;\n    return 0;\n}\n\n#endif\n\nstatic PyObject *\nstring_at(const char *ptr, int size)\n{\n    if (size == -1)\n        return PyBytes_FromStringAndSize(ptr, strlen(ptr));\n    return PyBytes_FromStringAndSize(ptr, size);\n}\n\nstatic int\ncast_check_pointertype(PyObject *arg)\n{\n    StgDictObject *dict;\n\n    if (PyCPointerTypeObject_Check(arg))\n        return 1;\n    if (PyCFuncPtrTypeObject_Check(arg))\n        return 1;\n    dict = PyType_stgdict(arg);\n    if (dict != NULL && dict->proto != NULL) {\n        if (PyUnicode_Check(dict->proto)\n            && (strchr(\"sPzUZXO\", PyUnicode_AsUTF8(dict->proto)[0]))) {\n            /* simple pointer types, c_void_p, c_wchar_p, BSTR, ... */\n            return 1;\n        }\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"cast() argument 2 must be a pointer type, not %s\",\n                 PyType_Check(arg)\n                 ? ((PyTypeObject *)arg)->tp_name\n                 : Py_TYPE(arg)->tp_name);\n    return 0;\n}\n\nstatic PyObject *\ncast(void *ptr, PyObject *src, PyObject *ctype)\n{\n    CDataObject *result;\n    if (0 == cast_check_pointertype(ctype))\n        return NULL;\n    result = (CDataObject *)_PyObject_CallNoArg(ctype);\n    if (result == NULL)\n        return NULL;\n\n    /*\n      The casted objects '_objects' member:\n\n      It must certainly contain the source objects one.\n      It must contain the source object itself.\n     */\n    if (CDataObject_Check(src)) {\n        CDataObject *obj = (CDataObject *)src;\n        CDataObject *container;\n\n        /* PyCData_GetContainer will initialize src.b_objects, we need\n           this so it can be shared */\n        container = PyCData_GetContainer(obj);\n        if (container == NULL)\n            goto failed;\n\n        /* But we need a dictionary! */\n        if (obj->b_objects == Py_None) {\n            Py_DECREF(Py_None);\n            obj->b_objects = PyDict_New();\n            if (obj->b_objects == NULL)\n                goto failed;\n        }\n        Py_XINCREF(obj->b_objects);\n        result->b_objects = obj->b_objects;\n        if (result->b_objects && PyDict_CheckExact(result->b_objects)) {\n            PyObject *index;\n            int rc;\n            index = PyLong_FromVoidPtr((void *)src);\n            if (index == NULL)\n                goto failed;\n            rc = PyDict_SetItem(result->b_objects, index, src);\n            Py_DECREF(index);\n            if (rc == -1)\n                goto failed;\n        }\n    }\n    /* Should we assert that result is a pointer type? */\n    memcpy(result->b_ptr, &ptr, sizeof(void *));\n    return (PyObject *)result;\n\n  failed:\n    Py_DECREF(result);\n    return NULL;\n}\n\n#ifdef CTYPES_UNICODE\nstatic PyObject *\nwstring_at(const wchar_t *ptr, int size)\n{\n    Py_ssize_t ssize = size;\n    if (ssize == -1)\n        ssize = wcslen(ptr);\n    return PyUnicode_FromWideChar(ptr, ssize);\n}\n#endif\n\n\nstatic struct PyModuleDef _ctypesmodule = {\n    PyModuleDef_HEAD_INIT,\n    \"_ctypes\",\n    module_docs,\n    -1,\n    _ctypes_module_methods,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n};\n\nPyMODINIT_FUNC\nPyInit__ctypes(void)\n{\n    PyObject *m;\n\n/* Note:\n   ob_type is the metatype (the 'type'), defaults to PyType_Type,\n   tp_base is the base type, defaults to 'object' aka PyBaseObject_Type.\n*/\n    PyEval_InitThreads();\n    m = PyModule_Create(&_ctypesmodule);\n    if (!m)\n        return NULL;\n\n    _ctypes_ptrtype_cache = PyDict_New();\n    if (_ctypes_ptrtype_cache == NULL)\n        return NULL;\n\n    PyModule_AddObject(m, \"_pointer_type_cache\", (PyObject *)_ctypes_ptrtype_cache);\n\n    _unpickle = PyObject_GetAttrString(m, \"_unpickle\");\n    if (_unpickle == NULL)\n        return NULL;\n\n    if (PyType_Ready(&PyCArg_Type) < 0)\n        return NULL;\n\n    if (PyType_Ready(&PyCThunk_Type) < 0)\n        return NULL;\n\n    /* StgDict is derived from PyDict_Type */\n    PyCStgDict_Type.tp_base = &PyDict_Type;\n    if (PyType_Ready(&PyCStgDict_Type) < 0)\n        return NULL;\n\n    /*************************************************\n     *\n     * Metaclasses\n     */\n\n    PyCStructType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCStructType_Type) < 0)\n        return NULL;\n\n    UnionType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&UnionType_Type) < 0)\n        return NULL;\n\n    PyCPointerType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCPointerType_Type) < 0)\n        return NULL;\n\n    PyCArrayType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCArrayType_Type) < 0)\n        return NULL;\n\n    PyCSimpleType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCSimpleType_Type) < 0)\n        return NULL;\n\n    PyCFuncPtrType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCFuncPtrType_Type) < 0)\n        return NULL;\n\n    /*************************************************\n     *\n     * Classes using a custom metaclass\n     */\n\n    if (PyType_Ready(&PyCData_Type) < 0)\n        return NULL;\n\n    Py_TYPE(&Struct_Type) = &PyCStructType_Type;\n    Struct_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&Struct_Type) < 0)\n        return NULL;\n    Py_INCREF(&Struct_Type);\n    PyModule_AddObject(m, \"Structure\", (PyObject *)&Struct_Type);\n\n    Py_TYPE(&Union_Type) = &UnionType_Type;\n    Union_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&Union_Type) < 0)\n        return NULL;\n    Py_INCREF(&Union_Type);\n    PyModule_AddObject(m, \"Union\", (PyObject *)&Union_Type);\n\n    Py_TYPE(&PyCPointer_Type) = &PyCPointerType_Type;\n    PyCPointer_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&PyCPointer_Type) < 0)\n        return NULL;\n    Py_INCREF(&PyCPointer_Type);\n    PyModule_AddObject(m, \"_Pointer\", (PyObject *)&PyCPointer_Type);\n\n    Py_TYPE(&PyCArray_Type) = &PyCArrayType_Type;\n    PyCArray_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&PyCArray_Type) < 0)\n        return NULL;\n    Py_INCREF(&PyCArray_Type);\n    PyModule_AddObject(m, \"Array\", (PyObject *)&PyCArray_Type);\n\n    Py_TYPE(&Simple_Type) = &PyCSimpleType_Type;\n    Simple_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&Simple_Type) < 0)\n        return NULL;\n    Py_INCREF(&Simple_Type);\n    PyModule_AddObject(m, \"_SimpleCData\", (PyObject *)&Simple_Type);\n\n    Py_TYPE(&PyCFuncPtr_Type) = &PyCFuncPtrType_Type;\n    PyCFuncPtr_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&PyCFuncPtr_Type) < 0)\n        return NULL;\n    Py_INCREF(&PyCFuncPtr_Type);\n    PyModule_AddObject(m, \"CFuncPtr\", (PyObject *)&PyCFuncPtr_Type);\n\n    /*************************************************\n     *\n     * Simple classes\n     */\n\n    /* PyCField_Type is derived from PyBaseObject_Type */\n    if (PyType_Ready(&PyCField_Type) < 0)\n        return NULL;\n\n    /*************************************************\n     *\n     * Other stuff\n     */\n\n    DictRemover_Type.tp_new = PyType_GenericNew;\n    if (PyType_Ready(&DictRemover_Type) < 0)\n        return NULL;\n\n#ifdef MS_WIN32\n    if (create_comerror() < 0)\n        return NULL;\n    PyModule_AddObject(m, \"COMError\", ComError);\n\n    PyModule_AddObject(m, \"FUNCFLAG_HRESULT\", PyLong_FromLong(FUNCFLAG_HRESULT));\n    PyModule_AddObject(m, \"FUNCFLAG_STDCALL\", PyLong_FromLong(FUNCFLAG_STDCALL));\n#endif\n    PyModule_AddObject(m, \"FUNCFLAG_CDECL\", PyLong_FromLong(FUNCFLAG_CDECL));\n    PyModule_AddObject(m, \"FUNCFLAG_USE_ERRNO\", PyLong_FromLong(FUNCFLAG_USE_ERRNO));\n    PyModule_AddObject(m, \"FUNCFLAG_USE_LASTERROR\", PyLong_FromLong(FUNCFLAG_USE_LASTERROR));\n    PyModule_AddObject(m, \"FUNCFLAG_PYTHONAPI\", PyLong_FromLong(FUNCFLAG_PYTHONAPI));\n    PyModule_AddStringConstant(m, \"__version__\", \"1.1.0\");\n\n    PyModule_AddObject(m, \"_memmove_addr\", PyLong_FromVoidPtr(memmove));\n    PyModule_AddObject(m, \"_memset_addr\", PyLong_FromVoidPtr(memset));\n    PyModule_AddObject(m, \"_string_at_addr\", PyLong_FromVoidPtr(string_at));\n    PyModule_AddObject(m, \"_cast_addr\", PyLong_FromVoidPtr(cast));\n#ifdef CTYPES_UNICODE\n    PyModule_AddObject(m, \"_wstring_at_addr\", PyLong_FromVoidPtr(wstring_at));\n#endif\n\n/* If RTLD_LOCAL is not defined (Windows!), set it to zero. */\n#if !HAVE_DECL_RTLD_LOCAL\n#define RTLD_LOCAL 0\n#endif\n\n/* If RTLD_GLOBAL is not defined (cygwin), set it to the same value as\n   RTLD_LOCAL.\n*/\n#if !HAVE_DECL_RTLD_GLOBAL\n#define RTLD_GLOBAL RTLD_LOCAL\n#endif\n\n    PyModule_AddObject(m, \"RTLD_LOCAL\", PyLong_FromLong(RTLD_LOCAL));\n    PyModule_AddObject(m, \"RTLD_GLOBAL\", PyLong_FromLong(RTLD_GLOBAL));\n\n    PyExc_ArgError = PyErr_NewException(\"ctypes.ArgumentError\", NULL, NULL);\n    if (PyExc_ArgError) {\n        Py_INCREF(PyExc_ArgError);\n        PyModule_AddObject(m, \"ArgumentError\", PyExc_ArgError);\n    }\n    return m;\n}\n\n/*\n Local Variables:\n compile-command: \"cd .. && python setup.py -q build -g && python setup.py -q build install --home ~\"\n End:\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Modules/_ctypes/callproc.c": "/*\n * History: First version dated from 3/97, derived from my SCMLIB version\n * for win16.\n */\n/*\n * Related Work:\n *      - calldll       http://www.nightmare.com/software.html\n *      - libffi        http://sourceware.cygnus.com/libffi/\n *      - ffcall        http://clisp.cons.org/~haible/packages-ffcall.html\n *   and, of course, Don Beaudry's MESS package, but this is more ctypes\n *   related.\n */\n\n\n/*\n  How are functions called, and how are parameters converted to C ?\n\n  1. _ctypes.c::PyCFuncPtr_call receives an argument tuple 'inargs' and a\n  keyword dictionary 'kwds'.\n\n  2. After several checks, _build_callargs() is called which returns another\n  tuple 'callargs'.  This may be the same tuple as 'inargs', a slice of\n  'inargs', or a completely fresh tuple, depending on several things (is it a\n  COM method?, are 'paramflags' available?).\n\n  3. _build_callargs also calculates bitarrays containing indexes into\n  the callargs tuple, specifying how to build the return value(s) of\n  the function.\n\n  4. _ctypes_callproc is then called with the 'callargs' tuple.  _ctypes_callproc first\n  allocates two arrays.  The first is an array of 'struct argument' items, the\n  second array has 'void *' entries.\n\n  5. If 'converters' are present (converters is a sequence of argtypes'\n  from_param methods), for each item in 'callargs' converter is called and the\n  result passed to ConvParam.  If 'converters' are not present, each argument\n  is directly passed to ConvParm.\n\n  6. For each arg, ConvParam stores the contained C data (or a pointer to it,\n  for structures) into the 'struct argument' array.\n\n  7. Finally, a loop fills the 'void *' array so that each item points to the\n  data contained in or pointed to by the 'struct argument' array.\n\n  8. The 'void *' argument array is what _call_function_pointer\n  expects. _call_function_pointer then has very little to do - only some\n  libffi specific stuff, then it calls ffi_call.\n\n  So, there are 4 data structures holding processed arguments:\n  - the inargs tuple (in PyCFuncPtr_call)\n  - the callargs tuple (in PyCFuncPtr_call)\n  - the 'struct arguments' array\n  - the 'void *' array\n\n */\n\n#include \"Python.h\"\n#include \"structmember.h\"\n\n#ifdef MS_WIN32\n#include <windows.h>\n#include <tchar.h>\n#else\n#include \"ctypes_dlfcn.h\"\n#endif\n\n#ifdef MS_WIN32\n#include <malloc.h>\n#endif\n\n#include <ffi.h>\n#include \"ctypes.h\"\n#ifdef HAVE_ALLOCA_H\n/* AIX needs alloca.h for alloca() */\n#include <alloca.h>\n#endif\n\n#ifdef _Py_MEMORY_SANITIZER\n#include <sanitizer/msan_interface.h>\n#endif\n\n#if defined(_DEBUG) || defined(__MINGW32__)\n/* Don't use structured exception handling on Windows if this is defined.\n   MingW, AFAIK, doesn't support it.\n*/\n#define DONT_USE_SEH\n#endif\n\n#define CTYPES_CAPSULE_NAME_PYMEM \"_ctypes pymem\"\n\nstatic void pymem_destructor(PyObject *ptr)\n{\n    void *p = PyCapsule_GetPointer(ptr, CTYPES_CAPSULE_NAME_PYMEM);\n    if (p) {\n        PyMem_Free(p);\n    }\n}\n\n/*\n  ctypes maintains thread-local storage that has space for two error numbers:\n  private copies of the system 'errno' value and, on Windows, the system error code\n  accessed by the GetLastError() and SetLastError() api functions.\n\n  Foreign functions created with CDLL(..., use_errno=True), when called, swap\n  the system 'errno' value with the private copy just before the actual\n  function call, and swapped again immediately afterwards.  The 'use_errno'\n  parameter defaults to False, in this case 'ctypes_errno' is not touched.\n\n  On Windows, foreign functions created with CDLL(..., use_last_error=True) or\n  WinDLL(..., use_last_error=True) swap the system LastError value with the\n  ctypes private copy.\n\n  The values are also swapped immeditately before and after ctypes callback\n  functions are called, if the callbacks are constructed using the new\n  optional use_errno parameter set to True: CFUNCTYPE(..., use_errno=TRUE) or\n  WINFUNCTYPE(..., use_errno=True).\n\n  New ctypes functions are provided to access the ctypes private copies from\n  Python:\n\n  - ctypes.set_errno(value) and ctypes.set_last_error(value) store 'value' in\n    the private copy and returns the previous value.\n\n  - ctypes.get_errno() and ctypes.get_last_error() returns the current ctypes\n    private copies value.\n*/\n\n/*\n  This function creates and returns a thread-local Python object that has\n  space to store two integer error numbers; once created the Python object is\n  kept alive in the thread state dictionary as long as the thread itself.\n*/\nPyObject *\n_ctypes_get_errobj(int **pspace)\n{\n    PyObject *dict = PyThreadState_GetDict();\n    PyObject *errobj;\n    static PyObject *error_object_name;\n    if (dict == NULL) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"cannot get thread state\");\n        return NULL;\n    }\n    if (error_object_name == NULL) {\n        error_object_name = PyUnicode_InternFromString(\"ctypes.error_object\");\n        if (error_object_name == NULL)\n            return NULL;\n    }\n    errobj = PyDict_GetItem(dict, error_object_name);\n    if (errobj) {\n        if (!PyCapsule_IsValid(errobj, CTYPES_CAPSULE_NAME_PYMEM)) {\n            PyErr_SetString(PyExc_RuntimeError,\n                \"ctypes.error_object is an invalid capsule\");\n            return NULL;\n        }\n        Py_INCREF(errobj);\n    }\n    else {\n        void *space = PyMem_Malloc(sizeof(int) * 2);\n        if (space == NULL)\n            return NULL;\n        memset(space, 0, sizeof(int) * 2);\n        errobj = PyCapsule_New(space, CTYPES_CAPSULE_NAME_PYMEM, pymem_destructor);\n        if (errobj == NULL) {\n            PyMem_Free(space);\n            return NULL;\n        }\n        if (-1 == PyDict_SetItem(dict, error_object_name,\n                                 errobj)) {\n            Py_DECREF(errobj);\n            return NULL;\n        }\n    }\n    *pspace = (int *)PyCapsule_GetPointer(errobj, CTYPES_CAPSULE_NAME_PYMEM);\n    return errobj;\n}\n\nstatic PyObject *\nget_error_internal(PyObject *self, PyObject *args, int index)\n{\n    int *space;\n    PyObject *errobj = _ctypes_get_errobj(&space);\n    PyObject *result;\n\n    if (errobj == NULL)\n        return NULL;\n    result = PyLong_FromLong(space[index]);\n    Py_DECREF(errobj);\n    return result;\n}\n\nstatic PyObject *\nset_error_internal(PyObject *self, PyObject *args, int index)\n{\n    int new_errno, old_errno;\n    PyObject *errobj;\n    int *space;\n\n    if (!PyArg_ParseTuple(args, \"i\", &new_errno))\n        return NULL;\n    errobj = _ctypes_get_errobj(&space);\n    if (errobj == NULL)\n        return NULL;\n    old_errno = space[index];\n    space[index] = new_errno;\n    Py_DECREF(errobj);\n    return PyLong_FromLong(old_errno);\n}\n\nstatic PyObject *\nget_errno(PyObject *self, PyObject *args)\n{\n    return get_error_internal(self, args, 0);\n}\n\nstatic PyObject *\nset_errno(PyObject *self, PyObject *args)\n{\n    return set_error_internal(self, args, 0);\n}\n\n#ifdef MS_WIN32\n\nstatic PyObject *\nget_last_error(PyObject *self, PyObject *args)\n{\n    return get_error_internal(self, args, 1);\n}\n\nstatic PyObject *\nset_last_error(PyObject *self, PyObject *args)\n{\n    return set_error_internal(self, args, 1);\n}\n\nPyObject *ComError;\n\nstatic WCHAR *FormatError(DWORD code)\n{\n    WCHAR *lpMsgBuf;\n    DWORD n;\n    n = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                       FORMAT_MESSAGE_FROM_SYSTEM |\n                       FORMAT_MESSAGE_IGNORE_INSERTS,\n                       NULL,\n                       code,\n                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */\n               (LPWSTR) &lpMsgBuf,\n               0,\n               NULL);\n    if (n) {\n        while (iswspace(lpMsgBuf[n-1]))\n            --n;\n        lpMsgBuf[n] = L'\\0'; /* rstrip() */\n    }\n    return lpMsgBuf;\n}\n\n#ifndef DONT_USE_SEH\nstatic void SetException(DWORD code, EXCEPTION_RECORD *pr)\n{\n    /* The 'code' is a normal win32 error code so it could be handled by\n    PyErr_SetFromWindowsErr(). However, for some errors, we have additional\n    information not included in the error code. We handle those here and\n    delegate all others to the generic function. */\n    switch (code) {\n    case EXCEPTION_ACCESS_VIOLATION:\n        /* The thread attempted to read from or write\n           to a virtual address for which it does not\n           have the appropriate access. */\n        if (pr->ExceptionInformation[0] == 0)\n            PyErr_Format(PyExc_OSError,\n                         \"exception: access violation reading %p\",\n                         pr->ExceptionInformation[1]);\n        else\n            PyErr_Format(PyExc_OSError,\n                         \"exception: access violation writing %p\",\n                         pr->ExceptionInformation[1]);\n        break;\n\n    case EXCEPTION_BREAKPOINT:\n        /* A breakpoint was encountered. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: breakpoint encountered\");\n        break;\n\n    case EXCEPTION_DATATYPE_MISALIGNMENT:\n        /* The thread attempted to read or write data that is\n           misaligned on hardware that does not provide\n           alignment. For example, 16-bit values must be\n           aligned on 2-byte boundaries, 32-bit values on\n           4-byte boundaries, and so on. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: datatype misalignment\");\n        break;\n\n    case EXCEPTION_SINGLE_STEP:\n        /* A trace trap or other single-instruction mechanism\n           signaled that one instruction has been executed. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: single step\");\n        break;\n\n    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n        /* The thread attempted to access an array element\n           that is out of bounds, and the underlying hardware\n           supports bounds checking. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: array bounds exceeded\");\n        break;\n\n    case EXCEPTION_FLT_DENORMAL_OPERAND:\n        /* One of the operands in a floating-point operation\n           is denormal. A denormal value is one that is too\n           small to represent as a standard floating-point\n           value. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: floating-point operand denormal\");\n        break;\n\n    case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n        /* The thread attempted to divide a floating-point\n           value by a floating-point divisor of zero. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: float divide by zero\");\n        break;\n\n    case EXCEPTION_FLT_INEXACT_RESULT:\n        /* The result of a floating-point operation cannot be\n           represented exactly as a decimal fraction. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: float inexact\");\n        break;\n\n    case EXCEPTION_FLT_INVALID_OPERATION:\n        /* This exception represents any floating-point\n           exception not included in this list. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: float invalid operation\");\n        break;\n\n    case EXCEPTION_FLT_OVERFLOW:\n        /* The exponent of a floating-point operation is\n           greater than the magnitude allowed by the\n           corresponding type. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: float overflow\");\n        break;\n\n    case EXCEPTION_FLT_STACK_CHECK:\n        /* The stack overflowed or underflowed as the result\n           of a floating-point operation. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: stack over/underflow\");\n        break;\n\n    case EXCEPTION_STACK_OVERFLOW:\n        /* The stack overflowed or underflowed as the result\n           of a floating-point operation. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: stack overflow\");\n        break;\n\n    case EXCEPTION_FLT_UNDERFLOW:\n        /* The exponent of a floating-point operation is less\n           than the magnitude allowed by the corresponding\n           type. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: float underflow\");\n        break;\n\n    case EXCEPTION_INT_DIVIDE_BY_ZERO:\n        /* The thread attempted to divide an integer value by\n           an integer divisor of zero. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: integer divide by zero\");\n        break;\n\n    case EXCEPTION_INT_OVERFLOW:\n        /* The result of an integer operation caused a carry\n           out of the most significant bit of the result. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: integer overflow\");\n        break;\n\n    case EXCEPTION_PRIV_INSTRUCTION:\n        /* The thread attempted to execute an instruction\n           whose operation is not allowed in the current\n           machine mode. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: privileged instruction\");\n        break;\n\n    case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n        /* The thread attempted to continue execution after a\n           noncontinuable exception occurred. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: nocontinuable\");\n        break;\n\n    default:\n        PyErr_SetFromWindowsErr(code);\n        break;\n    }\n}\n\nstatic DWORD HandleException(EXCEPTION_POINTERS *ptrs,\n                             DWORD *pdw, EXCEPTION_RECORD *record)\n{\n    *pdw = ptrs->ExceptionRecord->ExceptionCode;\n    *record = *ptrs->ExceptionRecord;\n    /* We don't want to catch breakpoint exceptions, they are used to attach\n     * a debugger to the process.\n     */\n    if (*pdw == EXCEPTION_BREAKPOINT)\n        return EXCEPTION_CONTINUE_SEARCH;\n    return EXCEPTION_EXECUTE_HANDLER;\n}\n#endif\n\nstatic PyObject *\ncheck_hresult(PyObject *self, PyObject *args)\n{\n    HRESULT hr;\n    if (!PyArg_ParseTuple(args, \"i\", &hr))\n        return NULL;\n    if (FAILED(hr))\n        return PyErr_SetFromWindowsErr(hr);\n    return PyLong_FromLong(hr);\n}\n\n#endif\n\n/**************************************************************/\n\nPyCArgObject *\nPyCArgObject_new(void)\n{\n    PyCArgObject *p;\n    p = PyObject_New(PyCArgObject, &PyCArg_Type);\n    if (p == NULL)\n        return NULL;\n    p->pffi_type = NULL;\n    p->tag = '\\0';\n    p->obj = NULL;\n    memset(&p->value, 0, sizeof(p->value));\n    return p;\n}\n\nstatic void\nPyCArg_dealloc(PyCArgObject *self)\n{\n    Py_XDECREF(self->obj);\n    PyObject_Del(self);\n}\n\nstatic int\nis_literal_char(unsigned char c)\n{\n    return c < 128 && _PyUnicode_IsPrintable(c) && c != '\\\\' && c != '\\'';\n}\n\nstatic PyObject *\nPyCArg_repr(PyCArgObject *self)\n{\n    char buffer[256];\n    switch(self->tag) {\n    case 'b':\n    case 'B':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.b);\n        break;\n    case 'h':\n    case 'H':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.h);\n        break;\n    case 'i':\n    case 'I':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.i);\n        break;\n    case 'l':\n    case 'L':\n        sprintf(buffer, \"<cparam '%c' (%ld)>\",\n            self->tag, self->value.l);\n        break;\n\n    case 'q':\n    case 'Q':\n        sprintf(buffer,\n#ifdef MS_WIN32\n            \"<cparam '%c' (%I64d)>\",\n#else\n            \"<cparam '%c' (%lld)>\",\n#endif\n            self->tag, self->value.q);\n        break;\n    case 'd':\n        sprintf(buffer, \"<cparam '%c' (%f)>\",\n            self->tag, self->value.d);\n        break;\n    case 'f':\n        sprintf(buffer, \"<cparam '%c' (%f)>\",\n            self->tag, self->value.f);\n        break;\n\n    case 'c':\n        if (is_literal_char((unsigned char)self->value.c)) {\n            sprintf(buffer, \"<cparam '%c' ('%c')>\",\n                self->tag, self->value.c);\n        }\n        else {\n            sprintf(buffer, \"<cparam '%c' ('\\\\x%02x')>\",\n                self->tag, (unsigned char)self->value.c);\n        }\n        break;\n\n/* Hm, are these 'z' and 'Z' codes useful at all?\n   Shouldn't they be replaced by the functionality of c_string\n   and c_wstring ?\n*/\n    case 'z':\n    case 'Z':\n    case 'P':\n        sprintf(buffer, \"<cparam '%c' (%p)>\",\n            self->tag, self->value.p);\n        break;\n\n    default:\n        if (is_literal_char((unsigned char)self->tag)) {\n            sprintf(buffer, \"<cparam '%c' at %p>\",\n                (unsigned char)self->tag, self);\n        }\n        else {\n            sprintf(buffer, \"<cparam 0x%02x at %p>\",\n                (unsigned char)self->tag, self);\n        }\n        break;\n    }\n    return PyUnicode_FromString(buffer);\n}\n\nstatic PyMemberDef PyCArgType_members[] = {\n    { \"_obj\", T_OBJECT,\n      offsetof(PyCArgObject, obj), READONLY,\n      \"the wrapped object\" },\n    { NULL },\n};\n\nPyTypeObject PyCArg_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"CArgObject\",\n    sizeof(PyCArgObject),\n    0,\n    (destructor)PyCArg_dealloc,                 /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    (reprfunc)PyCArg_repr,                      /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    PyCArgType_members,                         /* tp_members */\n};\n\n/****************************************************************/\n/*\n * Convert a PyObject * into a parameter suitable to pass to an\n * C function call.\n *\n * 1. Python integers are converted to C int and passed by value.\n *    Py_None is converted to a C NULL pointer.\n *\n * 2. 3-tuples are expected to have a format character in the first\n *    item, which must be 'i', 'f', 'd', 'q', or 'P'.\n *    The second item will have to be an integer, float, double, long long\n *    or integer (denoting an address void *), will be converted to the\n *    corresponding C data type and passed by value.\n *\n * 3. Other Python objects are tested for an '_as_parameter_' attribute.\n *    The value of this attribute must be an integer which will be passed\n *    by value, or a 2-tuple or 3-tuple which will be used according\n *    to point 2 above. The third item (if any), is ignored. It is normally\n *    used to keep the object alive where this parameter refers to.\n *    XXX This convention is dangerous - you can construct arbitrary tuples\n *    in Python and pass them. Would it be safer to use a custom container\n *    datatype instead of a tuple?\n *\n * 4. Other Python objects cannot be passed as parameters - an exception is raised.\n *\n * 5. ConvParam will store the converted result in a struct containing format\n *    and value.\n */\n\nunion result {\n    char c;\n    char b;\n    short h;\n    int i;\n    long l;\n    long long q;\n    long double D;\n    double d;\n    float f;\n    void *p;\n};\n\nstruct argument {\n    ffi_type *ffi_type;\n    PyObject *keep;\n    union result value;\n};\n\n/*\n * Convert a single Python object into a PyCArgObject and return it.\n */\nstatic int ConvParam(PyObject *obj, Py_ssize_t index, struct argument *pa)\n{\n    StgDictObject *dict;\n    pa->keep = NULL; /* so we cannot forget it later */\n\n    dict = PyObject_stgdict(obj);\n    if (dict) {\n        PyCArgObject *carg;\n        assert(dict->paramfunc);\n        /* If it has an stgdict, it is a CDataObject */\n        carg = dict->paramfunc((CDataObject *)obj);\n        if (carg == NULL)\n            return -1;\n        pa->ffi_type = carg->pffi_type;\n        memcpy(&pa->value, &carg->value, sizeof(pa->value));\n        pa->keep = (PyObject *)carg;\n        return 0;\n    }\n\n    if (PyCArg_CheckExact(obj)) {\n        PyCArgObject *carg = (PyCArgObject *)obj;\n        pa->ffi_type = carg->pffi_type;\n        Py_INCREF(obj);\n        pa->keep = obj;\n        memcpy(&pa->value, &carg->value, sizeof(pa->value));\n        return 0;\n    }\n\n    /* check for None, integer, string or unicode and use directly if successful */\n    if (obj == Py_None) {\n        pa->ffi_type = &ffi_type_pointer;\n        pa->value.p = NULL;\n        return 0;\n    }\n\n    if (PyLong_Check(obj)) {\n        pa->ffi_type = &ffi_type_sint;\n        pa->value.i = (long)PyLong_AsUnsignedLong(obj);\n        if (pa->value.i == -1 && PyErr_Occurred()) {\n            PyErr_Clear();\n            pa->value.i = PyLong_AsLong(obj);\n            if (pa->value.i == -1 && PyErr_Occurred()) {\n                PyErr_SetString(PyExc_OverflowError,\n                                \"int too long to convert\");\n                return -1;\n            }\n        }\n        return 0;\n    }\n\n    if (PyBytes_Check(obj)) {\n        pa->ffi_type = &ffi_type_pointer;\n        pa->value.p = PyBytes_AsString(obj);\n        Py_INCREF(obj);\n        pa->keep = obj;\n        return 0;\n    }\n\n#ifdef CTYPES_UNICODE\n    if (PyUnicode_Check(obj)) {\n        pa->ffi_type = &ffi_type_pointer;\n        pa->value.p = PyUnicode_AsWideCharString(obj, NULL);\n        if (pa->value.p == NULL)\n            return -1;\n        pa->keep = PyCapsule_New(pa->value.p, CTYPES_CAPSULE_NAME_PYMEM, pymem_destructor);\n        if (!pa->keep) {\n            PyMem_Free(pa->value.p);\n            return -1;\n        }\n        return 0;\n    }\n#endif\n\n    {\n        PyObject *arg;\n        arg = PyObject_GetAttrString(obj, \"_as_parameter_\");\n        /* Which types should we exactly allow here?\n           integers are required for using Python classes\n           as parameters (they have to expose the '_as_parameter_'\n           attribute)\n        */\n        if (arg) {\n            int result;\n            result = ConvParam(arg, index, pa);\n            Py_DECREF(arg);\n            return result;\n        }\n        PyErr_Format(PyExc_TypeError,\n                     \"Don't know how to convert parameter %d\",\n                     Py_SAFE_DOWNCAST(index, Py_ssize_t, int));\n        return -1;\n    }\n}\n\n\nffi_type *_ctypes_get_ffi_type(PyObject *obj)\n{\n    StgDictObject *dict;\n    if (obj == NULL)\n        return &ffi_type_sint;\n    dict = PyType_stgdict(obj);\n    if (dict == NULL)\n        return &ffi_type_sint;\n#if defined(MS_WIN32) && !defined(_WIN32_WCE)\n    /* This little trick works correctly with MSVC.\n       It returns small structures in registers\n    */\n    if (dict->ffi_type_pointer.type == FFI_TYPE_STRUCT) {\n        if (can_return_struct_as_int(dict->ffi_type_pointer.size))\n            return &ffi_type_sint32;\n        else if (can_return_struct_as_sint64 (dict->ffi_type_pointer.size))\n            return &ffi_type_sint64;\n    }\n#endif\n    return &dict->ffi_type_pointer;\n}\n\n\n/*\n * libffi uses:\n *\n * ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi,\n *                         unsigned int nargs,\n *                         ffi_type *rtype,\n *                         ffi_type **atypes);\n *\n * and then\n *\n * void ffi_call(ffi_cif *cif, void *fn, void *rvalue, void **avalues);\n */\nstatic int _call_function_pointer(int flags,\n                                  PPROC pProc,\n                                  void **avalues,\n                                  ffi_type **atypes,\n                                  ffi_type *restype,\n                                  void *resmem,\n                                  int argcount)\n{\n    PyThreadState *_save = NULL; /* For Py_BLOCK_THREADS and Py_UNBLOCK_THREADS */\n    PyObject *error_object = NULL;\n    int *space;\n    ffi_cif cif;\n    int cc;\n#ifdef MS_WIN32\n    int delta;\n#ifndef DONT_USE_SEH\n    DWORD dwExceptionCode = 0;\n    EXCEPTION_RECORD record;\n#endif\n#endif\n    /* XXX check before here */\n    if (restype == NULL) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"No ffi_type for result\");\n        return -1;\n    }\n\n    cc = FFI_DEFAULT_ABI;\n#if defined(MS_WIN32) && !defined(MS_WIN64) && !defined(_WIN32_WCE)\n    if ((flags & FUNCFLAG_CDECL) == 0)\n        cc = FFI_STDCALL;\n#endif\n    if (FFI_OK != ffi_prep_cif(&cif,\n                               cc,\n                               argcount,\n                               restype,\n                               atypes)) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"ffi_prep_cif failed\");\n        return -1;\n    }\n\n    if (flags & (FUNCFLAG_USE_ERRNO | FUNCFLAG_USE_LASTERROR)) {\n        error_object = _ctypes_get_errobj(&space);\n        if (error_object == NULL)\n            return -1;\n    }\n    if ((flags & FUNCFLAG_PYTHONAPI) == 0)\n        Py_UNBLOCK_THREADS\n    if (flags & FUNCFLAG_USE_ERRNO) {\n        int temp = space[0];\n        space[0] = errno;\n        errno = temp;\n    }\n#ifdef MS_WIN32\n    if (flags & FUNCFLAG_USE_LASTERROR) {\n        int temp = space[1];\n        space[1] = GetLastError();\n        SetLastError(temp);\n    }\n#ifndef DONT_USE_SEH\n    __try {\n#endif\n        delta =\n#endif\n                ffi_call(&cif, (void *)pProc, resmem, avalues);\n#ifdef MS_WIN32\n#ifndef DONT_USE_SEH\n    }\n    __except (HandleException(GetExceptionInformation(),\n                              &dwExceptionCode, &record)) {\n        ;\n    }\n#endif\n    if (flags & FUNCFLAG_USE_LASTERROR) {\n        int temp = space[1];\n        space[1] = GetLastError();\n        SetLastError(temp);\n    }\n#endif\n    if (flags & FUNCFLAG_USE_ERRNO) {\n        int temp = space[0];\n        space[0] = errno;\n        errno = temp;\n    }\n    if ((flags & FUNCFLAG_PYTHONAPI) == 0)\n        Py_BLOCK_THREADS\n    Py_XDECREF(error_object);\n#ifdef MS_WIN32\n#ifndef DONT_USE_SEH\n    if (dwExceptionCode) {\n        SetException(dwExceptionCode, &record);\n        return -1;\n    }\n#endif\n#ifdef MS_WIN64\n    if (delta != 0) {\n        PyErr_Format(PyExc_RuntimeError,\n                 \"ffi_call failed with code %d\",\n                 delta);\n        return -1;\n    }\n#else\n    if (delta < 0) {\n        if (flags & FUNCFLAG_CDECL)\n            PyErr_Format(PyExc_ValueError,\n                     \"Procedure called with not enough \"\n                     \"arguments (%d bytes missing) \"\n                     \"or wrong calling convention\",\n                     -delta);\n        else\n            PyErr_Format(PyExc_ValueError,\n                     \"Procedure probably called with not enough \"\n                     \"arguments (%d bytes missing)\",\n                     -delta);\n        return -1;\n    } else if (delta > 0) {\n        PyErr_Format(PyExc_ValueError,\n                 \"Procedure probably called with too many \"\n                 \"arguments (%d bytes in excess)\",\n                 delta);\n        return -1;\n    }\n#endif\n#endif\n    if ((flags & FUNCFLAG_PYTHONAPI) && PyErr_Occurred())\n        return -1;\n    return 0;\n}\n\n/*\n * Convert the C value in result into a Python object, depending on restype.\n *\n * - If restype is NULL, return a Python integer.\n * - If restype is None, return None.\n * - If restype is a simple ctypes type (c_int, c_void_p), call the type's getfunc,\n *   pass the result to checker and return the result.\n * - If restype is another ctypes type, return an instance of that.\n * - Otherwise, call restype and return the result.\n */\nstatic PyObject *GetResult(PyObject *restype, void *result, PyObject *checker)\n{\n    StgDictObject *dict;\n    PyObject *retval, *v;\n\n    if (restype == NULL)\n        return PyLong_FromLong(*(int *)result);\n\n    if (restype == Py_None) {\n        Py_RETURN_NONE;\n    }\n\n    dict = PyType_stgdict(restype);\n    if (dict == NULL)\n        return PyObject_CallFunction(restype, \"i\", *(int *)result);\n\n    if (dict->getfunc && !_ctypes_simple_instance(restype)) {\n        retval = dict->getfunc(result, dict->size);\n        /* If restype is py_object (detected by comparing getfunc with\n           O_get), we have to call Py_DECREF because O_get has already\n           called Py_INCREF.\n        */\n        if (dict->getfunc == _ctypes_get_fielddesc(\"O\")->getfunc) {\n            Py_DECREF(retval);\n        }\n    } else\n        retval = PyCData_FromBaseObj(restype, NULL, 0, result);\n\n    if (!checker || !retval)\n        return retval;\n\n    v = PyObject_CallFunctionObjArgs(checker, retval, NULL);\n    if (v == NULL)\n        _PyTraceback_Add(\"GetResult\", \"_ctypes/callproc.c\", __LINE__-2);\n    Py_DECREF(retval);\n    return v;\n}\n\n/*\n * Raise a new exception 'exc_class', adding additional text to the original\n * exception string.\n */\nvoid _ctypes_extend_error(PyObject *exc_class, const char *fmt, ...)\n{\n    va_list vargs;\n    PyObject *tp, *v, *tb, *s, *cls_str, *msg_str;\n\n    va_start(vargs, fmt);\n    s = PyUnicode_FromFormatV(fmt, vargs);\n    va_end(vargs);\n    if (!s)\n        return;\n\n    PyErr_Fetch(&tp, &v, &tb);\n    PyErr_NormalizeException(&tp, &v, &tb);\n    cls_str = PyObject_Str(tp);\n    if (cls_str) {\n        PyUnicode_AppendAndDel(&s, cls_str);\n        PyUnicode_AppendAndDel(&s, PyUnicode_FromString(\": \"));\n        if (s == NULL)\n            goto error;\n    } else\n        PyErr_Clear();\n    msg_str = PyObject_Str(v);\n    if (msg_str)\n        PyUnicode_AppendAndDel(&s, msg_str);\n    else {\n        PyErr_Clear();\n        PyUnicode_AppendAndDel(&s, PyUnicode_FromString(\"???\"));\n    }\n    if (s == NULL)\n        goto error;\n    PyErr_SetObject(exc_class, s);\nerror:\n    Py_XDECREF(tp);\n    Py_XDECREF(v);\n    Py_XDECREF(tb);\n    Py_XDECREF(s);\n}\n\n\n#ifdef MS_WIN32\n\nstatic PyObject *\nGetComError(HRESULT errcode, GUID *riid, IUnknown *pIunk)\n{\n    HRESULT hr;\n    ISupportErrorInfo *psei = NULL;\n    IErrorInfo *pei = NULL;\n    BSTR descr=NULL, helpfile=NULL, source=NULL;\n    GUID guid;\n    DWORD helpcontext=0;\n    LPOLESTR progid;\n    PyObject *obj;\n    LPOLESTR text;\n\n    /* We absolutely have to release the GIL during COM method calls,\n       otherwise we may get a deadlock!\n    */\n    Py_BEGIN_ALLOW_THREADS\n\n    hr = pIunk->lpVtbl->QueryInterface(pIunk, &IID_ISupportErrorInfo, (void **)&psei);\n    if (FAILED(hr))\n        goto failed;\n\n    hr = psei->lpVtbl->InterfaceSupportsErrorInfo(psei, riid);\n    psei->lpVtbl->Release(psei);\n    if (FAILED(hr))\n        goto failed;\n\n    hr = GetErrorInfo(0, &pei);\n    if (hr != S_OK)\n        goto failed;\n\n    pei->lpVtbl->GetDescription(pei, &descr);\n    pei->lpVtbl->GetGUID(pei, &guid);\n    pei->lpVtbl->GetHelpContext(pei, &helpcontext);\n    pei->lpVtbl->GetHelpFile(pei, &helpfile);\n    pei->lpVtbl->GetSource(pei, &source);\n\n    pei->lpVtbl->Release(pei);\n\n  failed:\n    Py_END_ALLOW_THREADS\n\n    progid = NULL;\n    ProgIDFromCLSID(&guid, &progid);\n\n    text = FormatError(errcode);\n    obj = Py_BuildValue(\n        \"iu(uuuiu)\",\n        errcode,\n        text,\n        descr, source, helpfile, helpcontext,\n        progid);\n    if (obj) {\n        PyErr_SetObject(ComError, obj);\n        Py_DECREF(obj);\n    }\n    LocalFree(text);\n\n    if (descr)\n        SysFreeString(descr);\n    if (helpfile)\n        SysFreeString(helpfile);\n    if (source)\n        SysFreeString(source);\n\n    return NULL;\n}\n#endif\n\n#if (defined(__x86_64__) && (defined(__MINGW64__) || defined(__CYGWIN__))) || \\\n    defined(__aarch64__) || defined(__riscv)\n#define CTYPES_PASS_BY_REF_HACK\n#define POW2(x) (((x & ~(x - 1)) == x) ? x : 0)\n#define IS_PASS_BY_REF(x) (x > 8 || !POW2(x))\n#endif\n\n/*\n * bpo-13097: Max number of arguments _ctypes_callproc will accept.\n *\n * This limit is enforced for the `alloca()` call in `_ctypes_callproc`,\n * to avoid allocating a massive buffer on the stack.\n */\n#define CTYPES_MAX_ARGCOUNT 1024\n\n/*\n * Requirements, must be ensured by the caller:\n * - argtuple is tuple of arguments\n * - argtypes is either NULL, or a tuple of the same size as argtuple\n *\n * - XXX various requirements for restype, not yet collected\n */\nPyObject *_ctypes_callproc(PPROC pProc,\n                    PyObject *argtuple,\n#ifdef MS_WIN32\n                    IUnknown *pIunk,\n                    GUID *iid,\n#endif\n                    int flags,\n                    PyObject *argtypes, /* misleading name: This is a tuple of\n                                           methods, not types: the .from_param\n                                           class methods of the types */\n            PyObject *restype,\n            PyObject *checker)\n{\n    Py_ssize_t i, n, argcount, argtype_count;\n    void *resbuf;\n    struct argument *args, *pa;\n    ffi_type **atypes;\n    ffi_type *rtype;\n    void **avalues;\n    PyObject *retval = NULL;\n\n    n = argcount = PyTuple_GET_SIZE(argtuple);\n#ifdef MS_WIN32\n    /* an optional COM object this pointer */\n    if (pIunk)\n        ++argcount;\n#endif\n\n    if (argcount > CTYPES_MAX_ARGCOUNT)\n    {\n        PyErr_Format(PyExc_ArgError, \"too many arguments (%zi), maximum is %i\",\n                     argcount, CTYPES_MAX_ARGCOUNT);\n        return NULL;\n    }\n\n    args = (struct argument *)alloca(sizeof(struct argument) * argcount);\n    if (!args) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    memset(args, 0, sizeof(struct argument) * argcount);\n    argtype_count = argtypes ? PyTuple_GET_SIZE(argtypes) : 0;\n#ifdef MS_WIN32\n    if (pIunk) {\n        args[0].ffi_type = &ffi_type_pointer;\n        args[0].value.p = pIunk;\n        pa = &args[1];\n    } else\n#endif\n        pa = &args[0];\n\n    /* Convert the arguments */\n    for (i = 0; i < n; ++i, ++pa) {\n        PyObject *converter;\n        PyObject *arg;\n        int err;\n\n        arg = PyTuple_GET_ITEM(argtuple, i);            /* borrowed ref */\n        /* For cdecl functions, we allow more actual arguments\n           than the length of the argtypes tuple.\n           This is checked in _ctypes::PyCFuncPtr_Call\n        */\n        if (argtypes && argtype_count > i) {\n            PyObject *v;\n            converter = PyTuple_GET_ITEM(argtypes, i);\n            v = PyObject_CallFunctionObjArgs(converter, arg, NULL);\n            if (v == NULL) {\n                _ctypes_extend_error(PyExc_ArgError, \"argument %zd: \", i+1);\n                goto cleanup;\n            }\n\n            err = ConvParam(v, i+1, pa);\n            Py_DECREF(v);\n            if (-1 == err) {\n                _ctypes_extend_error(PyExc_ArgError, \"argument %zd: \", i+1);\n                goto cleanup;\n            }\n        } else {\n            err = ConvParam(arg, i+1, pa);\n            if (-1 == err) {\n                _ctypes_extend_error(PyExc_ArgError, \"argument %zd: \", i+1);\n                goto cleanup; /* leaking ? */\n            }\n        }\n    }\n\n    rtype = _ctypes_get_ffi_type(restype);\n    resbuf = alloca(max(rtype->size, sizeof(ffi_arg)));\n\n#ifdef _Py_MEMORY_SANITIZER\n    /* ffi_call actually initializes resbuf, but from asm, which\n     * MemorySanitizer can't detect. Avoid false positives from MSan. */\n    if (resbuf != NULL) {\n        __msan_unpoison(resbuf, max(rtype->size, sizeof(ffi_arg)));\n    }\n#endif\n    avalues = (void **)alloca(sizeof(void *) * argcount);\n    atypes = (ffi_type **)alloca(sizeof(ffi_type *) * argcount);\n    if (!resbuf || !avalues || !atypes) {\n        PyErr_NoMemory();\n        goto cleanup;\n    }\n    for (i = 0; i < argcount; ++i) {\n        atypes[i] = args[i].ffi_type;\n#ifdef CTYPES_PASS_BY_REF_HACK\n        size_t size = atypes[i]->size;\n        if (IS_PASS_BY_REF(size)) {\n            void *tmp = alloca(size);\n            if (atypes[i]->type == FFI_TYPE_STRUCT)\n                memcpy(tmp, args[i].value.p, size);\n            else\n                memcpy(tmp, (void*)&args[i].value, size);\n\n            avalues[i] = tmp;\n        }\n        else\n#endif\n        if (atypes[i]->type == FFI_TYPE_STRUCT)\n            avalues[i] = (void *)args[i].value.p;\n        else\n            avalues[i] = (void *)&args[i].value;\n    }\n\n    if (-1 == _call_function_pointer(flags, pProc, avalues, atypes,\n                                     rtype, resbuf,\n                                     Py_SAFE_DOWNCAST(argcount,\n                                                      Py_ssize_t,\n                                                      int)))\n        goto cleanup;\n\n#ifdef WORDS_BIGENDIAN\n    /* libffi returns the result in a buffer with sizeof(ffi_arg). This\n       causes problems on big endian machines, since the result buffer\n       address cannot simply be used as result pointer, instead we must\n       adjust the pointer value:\n     */\n    /*\n      XXX I should find out and clarify why this is needed at all,\n      especially why adjusting for ffi_type_float must be avoided on\n      64-bit platforms.\n     */\n    if (rtype->type != FFI_TYPE_FLOAT\n        && rtype->type != FFI_TYPE_STRUCT\n        && rtype->size < sizeof(ffi_arg))\n        resbuf = (char *)resbuf + sizeof(ffi_arg) - rtype->size;\n#endif\n\n#ifdef MS_WIN32\n    if (iid && pIunk) {\n        if (*(int *)resbuf & 0x80000000)\n            retval = GetComError(*(HRESULT *)resbuf, iid, pIunk);\n        else\n            retval = PyLong_FromLong(*(int *)resbuf);\n    } else if (flags & FUNCFLAG_HRESULT) {\n        if (*(int *)resbuf & 0x80000000)\n            retval = PyErr_SetFromWindowsErr(*(int *)resbuf);\n        else\n            retval = PyLong_FromLong(*(int *)resbuf);\n    } else\n#endif\n        retval = GetResult(restype, resbuf, checker);\n  cleanup:\n    for (i = 0; i < argcount; ++i)\n        Py_XDECREF(args[i].keep);\n    return retval;\n}\n\nstatic int\n_parse_voidp(PyObject *obj, void **address)\n{\n    *address = PyLong_AsVoidPtr(obj);\n    if (*address == NULL)\n        return 0;\n    return 1;\n}\n\n#ifdef MS_WIN32\n\nstatic const char format_error_doc[] =\n\"FormatError([integer]) -> string\\n\\\n\\n\\\nConvert a win32 error code into a string. If the error code is not\\n\\\ngiven, the return value of a call to GetLastError() is used.\\n\";\nstatic PyObject *format_error(PyObject *self, PyObject *args)\n{\n    PyObject *result;\n    wchar_t *lpMsgBuf;\n    DWORD code = 0;\n    if (!PyArg_ParseTuple(args, \"|i:FormatError\", &code))\n        return NULL;\n    if (code == 0)\n        code = GetLastError();\n    lpMsgBuf = FormatError(code);\n    if (lpMsgBuf) {\n        result = PyUnicode_FromWideChar(lpMsgBuf, wcslen(lpMsgBuf));\n        LocalFree(lpMsgBuf);\n    } else {\n        result = PyUnicode_FromString(\"<no description>\");\n    }\n    return result;\n}\n\nstatic const char load_library_doc[] =\n\"LoadLibrary(name) -> handle\\n\\\n\\n\\\nLoad an executable (usually a DLL), and return a handle to it.\\n\\\nThe handle may be used to locate exported functions in this\\n\\\nmodule.\\n\";\nstatic PyObject *load_library(PyObject *self, PyObject *args)\n{\n    const WCHAR *name;\n    PyObject *nameobj;\n    PyObject *ignored;\n    HMODULE hMod;\n\n    if (!PyArg_ParseTuple(args, \"U|O:LoadLibrary\", &nameobj, &ignored))\n        return NULL;\n\n    name = _PyUnicode_AsUnicode(nameobj);\n    if (!name)\n        return NULL;\n\n    hMod = LoadLibraryW(name);\n    if (!hMod)\n        return PyErr_SetFromWindowsErr(GetLastError());\n#ifdef _WIN64\n    return PyLong_FromVoidPtr(hMod);\n#else\n    return Py_BuildValue(\"i\", hMod);\n#endif\n}\n\nstatic const char free_library_doc[] =\n\"FreeLibrary(handle) -> void\\n\\\n\\n\\\nFree the handle of an executable previously loaded by LoadLibrary.\\n\";\nstatic PyObject *free_library(PyObject *self, PyObject *args)\n{\n    void *hMod;\n    if (!PyArg_ParseTuple(args, \"O&:FreeLibrary\", &_parse_voidp, &hMod))\n        return NULL;\n    if (!FreeLibrary((HMODULE)hMod))\n        return PyErr_SetFromWindowsErr(GetLastError());\n    Py_RETURN_NONE;\n}\n\nstatic const char copy_com_pointer_doc[] =\n\"CopyComPointer(src, dst) -> HRESULT value\\n\";\n\nstatic PyObject *\ncopy_com_pointer(PyObject *self, PyObject *args)\n{\n    PyObject *p1, *p2, *r = NULL;\n    struct argument a, b;\n    IUnknown *src, **pdst;\n    if (!PyArg_ParseTuple(args, \"OO:CopyComPointer\", &p1, &p2))\n        return NULL;\n    a.keep = b.keep = NULL;\n\n    if (-1 == ConvParam(p1, 0, &a) || -1 == ConvParam(p2, 1, &b))\n        goto done;\n    src = (IUnknown *)a.value.p;\n    pdst = (IUnknown **)b.value.p;\n\n    if (pdst == NULL)\n        r = PyLong_FromLong(E_POINTER);\n    else {\n        if (src)\n            src->lpVtbl->AddRef(src);\n        *pdst = src;\n        r = PyLong_FromLong(S_OK);\n    }\n  done:\n    Py_XDECREF(a.keep);\n    Py_XDECREF(b.keep);\n    return r;\n}\n#else\n\nstatic PyObject *py_dl_open(PyObject *self, PyObject *args)\n{\n    PyObject *name, *name2;\n    char *name_str;\n    void * handle;\n#if HAVE_DECL_RTLD_LOCAL\n    int mode = RTLD_NOW | RTLD_LOCAL;\n#else\n    /* cygwin doesn't define RTLD_LOCAL */\n    int mode = RTLD_NOW;\n#endif\n    if (!PyArg_ParseTuple(args, \"O|i:dlopen\", &name, &mode))\n        return NULL;\n    mode |= RTLD_NOW;\n    if (name != Py_None) {\n        if (PyUnicode_FSConverter(name, &name2) == 0)\n            return NULL;\n        if (PyBytes_Check(name2))\n            name_str = PyBytes_AS_STRING(name2);\n        else\n            name_str = PyByteArray_AS_STRING(name2);\n    } else {\n        name_str = NULL;\n        name2 = NULL;\n    }\n    handle = ctypes_dlopen(name_str, mode);\n    Py_XDECREF(name2);\n    if (!handle) {\n        const char *errmsg = ctypes_dlerror();\n        if (!errmsg)\n            errmsg = \"dlopen() error\";\n        PyErr_SetString(PyExc_OSError,\n                               errmsg);\n        return NULL;\n    }\n    return PyLong_FromVoidPtr(handle);\n}\n\nstatic PyObject *py_dl_close(PyObject *self, PyObject *args)\n{\n    void *handle;\n\n    if (!PyArg_ParseTuple(args, \"O&:dlclose\", &_parse_voidp, &handle))\n        return NULL;\n    if (dlclose(handle)) {\n        PyErr_SetString(PyExc_OSError,\n                               ctypes_dlerror());\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *py_dl_sym(PyObject *self, PyObject *args)\n{\n    char *name;\n    void *handle;\n    void *ptr;\n\n    if (!PyArg_ParseTuple(args, \"O&s:dlsym\",\n                          &_parse_voidp, &handle, &name))\n        return NULL;\n    ptr = ctypes_dlsym((void*)handle, name);\n    if (!ptr) {\n        PyErr_SetString(PyExc_OSError,\n                               ctypes_dlerror());\n        return NULL;\n    }\n    return PyLong_FromVoidPtr(ptr);\n}\n#endif\n\n/*\n * Only for debugging so far: So that we can call CFunction instances\n *\n * XXX Needs to accept more arguments: flags, argtypes, restype\n */\nstatic PyObject *\ncall_function(PyObject *self, PyObject *args)\n{\n    void *func;\n    PyObject *arguments;\n    PyObject *result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O!\",\n                          &_parse_voidp, &func,\n                          &PyTuple_Type, &arguments))\n        return NULL;\n\n    result =  _ctypes_callproc((PPROC)func,\n                        arguments,\n#ifdef MS_WIN32\n                        NULL,\n                        NULL,\n#endif\n                        0, /* flags */\n                NULL, /* self->argtypes */\n                NULL, /* self->restype */\n                NULL); /* checker */\n    return result;\n}\n\n/*\n * Only for debugging so far: So that we can call CFunction instances\n *\n * XXX Needs to accept more arguments: flags, argtypes, restype\n */\nstatic PyObject *\ncall_cdeclfunction(PyObject *self, PyObject *args)\n{\n    void *func;\n    PyObject *arguments;\n    PyObject *result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O!\",\n                          &_parse_voidp, &func,\n                          &PyTuple_Type, &arguments))\n        return NULL;\n\n    result =  _ctypes_callproc((PPROC)func,\n                        arguments,\n#ifdef MS_WIN32\n                        NULL,\n                        NULL,\n#endif\n                        FUNCFLAG_CDECL, /* flags */\n                        NULL, /* self->argtypes */\n                        NULL, /* self->restype */\n                        NULL); /* checker */\n    return result;\n}\n\n/*****************************************************************\n * functions\n */\nstatic const char sizeof_doc[] =\n\"sizeof(C type) -> integer\\n\"\n\"sizeof(C instance) -> integer\\n\"\n\"Return the size in bytes of a C instance\";\n\nstatic PyObject *\nsizeof_func(PyObject *self, PyObject *obj)\n{\n    StgDictObject *dict;\n\n    dict = PyType_stgdict(obj);\n    if (dict)\n        return PyLong_FromSsize_t(dict->size);\n\n    if (CDataObject_Check(obj))\n        return PyLong_FromSsize_t(((CDataObject *)obj)->b_size);\n    PyErr_SetString(PyExc_TypeError,\n                    \"this type has no size\");\n    return NULL;\n}\n\nstatic const char alignment_doc[] =\n\"alignment(C type) -> integer\\n\"\n\"alignment(C instance) -> integer\\n\"\n\"Return the alignment requirements of a C instance\";\n\nstatic PyObject *\nalign_func(PyObject *self, PyObject *obj)\n{\n    StgDictObject *dict;\n\n    dict = PyType_stgdict(obj);\n    if (dict)\n        return PyLong_FromSsize_t(dict->align);\n\n    dict = PyObject_stgdict(obj);\n    if (dict)\n        return PyLong_FromSsize_t(dict->align);\n\n    PyErr_SetString(PyExc_TypeError,\n                    \"no alignment info\");\n    return NULL;\n}\n\nstatic const char byref_doc[] =\n\"byref(C instance[, offset=0]) -> byref-object\\n\"\n\"Return a pointer lookalike to a C instance, only usable\\n\"\n\"as function argument\";\n\n/*\n * We must return something which can be converted to a parameter,\n * but still has a reference to self.\n */\nstatic PyObject *\nbyref(PyObject *self, PyObject *args)\n{\n    PyCArgObject *parg;\n    PyObject *obj;\n    PyObject *pyoffset = NULL;\n    Py_ssize_t offset = 0;\n\n    if (!PyArg_UnpackTuple(args, \"byref\", 1, 2,\n                           &obj, &pyoffset))\n        return NULL;\n    if (pyoffset) {\n        offset = PyNumber_AsSsize_t(pyoffset, NULL);\n        if (offset == -1 && PyErr_Occurred())\n            return NULL;\n    }\n    if (!CDataObject_Check(obj)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"byref() argument must be a ctypes instance, not '%s'\",\n                     Py_TYPE(obj)->tp_name);\n        return NULL;\n    }\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    Py_INCREF(obj);\n    parg->obj = obj;\n    parg->value.p = (char *)((CDataObject *)obj)->b_ptr + offset;\n    return (PyObject *)parg;\n}\n\nstatic const char addressof_doc[] =\n\"addressof(C instance) -> integer\\n\"\n\"Return the address of the C instance internal buffer\";\n\nstatic PyObject *\naddressof(PyObject *self, PyObject *obj)\n{\n    if (CDataObject_Check(obj))\n        return PyLong_FromVoidPtr(((CDataObject *)obj)->b_ptr);\n    PyErr_SetString(PyExc_TypeError,\n                    \"invalid type\");\n    return NULL;\n}\n\nstatic int\nconverter(PyObject *obj, void **address)\n{\n    *address = PyLong_AsVoidPtr(obj);\n    return *address != NULL;\n}\n\nstatic PyObject *\nMy_PyObj_FromPtr(PyObject *self, PyObject *args)\n{\n    PyObject *ob;\n    if (!PyArg_ParseTuple(args, \"O&:PyObj_FromPtr\", converter, &ob))\n        return NULL;\n    Py_INCREF(ob);\n    return ob;\n}\n\nstatic PyObject *\nMy_Py_INCREF(PyObject *self, PyObject *arg)\n{\n    Py_INCREF(arg); /* that's what this function is for */\n    Py_INCREF(arg); /* that for returning it */\n    return arg;\n}\n\nstatic PyObject *\nMy_Py_DECREF(PyObject *self, PyObject *arg)\n{\n    Py_DECREF(arg); /* that's what this function is for */\n    Py_INCREF(arg); /* that's for returning it */\n    return arg;\n}\n\nstatic PyObject *\nresize(PyObject *self, PyObject *args)\n{\n    CDataObject *obj;\n    StgDictObject *dict;\n    Py_ssize_t size;\n\n    if (!PyArg_ParseTuple(args,\n                          \"On:resize\",\n                          &obj, &size))\n        return NULL;\n\n    dict = PyObject_stgdict((PyObject *)obj);\n    if (dict == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"excepted ctypes instance\");\n        return NULL;\n    }\n    if (size < dict->size) {\n        PyErr_Format(PyExc_ValueError,\n                     \"minimum size is %zd\",\n                     dict->size);\n        return NULL;\n    }\n    if (obj->b_needsfree == 0) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Memory cannot be resized because this object doesn't own it\");\n        return NULL;\n    }\n    if ((size_t)size <= sizeof(obj->b_value)) {\n        /* internal default buffer is large enough */\n        obj->b_size = size;\n        goto done;\n    }\n    if (!_CDataObject_HasExternalBuffer(obj)) {\n        /* We are currently using the objects default buffer, but it\n           isn't large enough any more. */\n        void *ptr = PyMem_Malloc(size);\n        if (ptr == NULL)\n            return PyErr_NoMemory();\n        memset(ptr, 0, size);\n        memmove(ptr, obj->b_ptr, obj->b_size);\n        obj->b_ptr = ptr;\n        obj->b_size = size;\n    } else {\n        void * ptr = PyMem_Realloc(obj->b_ptr, size);\n        if (ptr == NULL)\n            return PyErr_NoMemory();\n        obj->b_ptr = ptr;\n        obj->b_size = size;\n    }\n  done:\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nunpickle(PyObject *self, PyObject *args)\n{\n    PyObject *typ, *state, *meth, *obj, *result;\n    _Py_IDENTIFIER(__new__);\n    _Py_IDENTIFIER(__setstate__);\n\n    if (!PyArg_ParseTuple(args, \"OO!\", &typ, &PyTuple_Type, &state))\n        return NULL;\n    obj = _PyObject_CallMethodIdObjArgs(typ, &PyId___new__, typ, NULL);\n    if (obj == NULL)\n        return NULL;\n\n    meth = _PyObject_GetAttrId(obj, &PyId___setstate__);\n    if (meth == NULL) {\n        goto error;\n    }\n\n    result = PyObject_Call(meth, state, NULL);\n    Py_DECREF(meth);\n    if (result == NULL) {\n        goto error;\n    }\n    Py_DECREF(result);\n\n    return obj;\n\nerror:\n    Py_DECREF(obj);\n    return NULL;\n}\n\nstatic PyObject *\nPOINTER(PyObject *self, PyObject *cls)\n{\n    PyObject *result;\n    PyTypeObject *typ;\n    PyObject *key;\n    char *buf;\n\n    result = PyDict_GetItem(_ctypes_ptrtype_cache, cls);\n    if (result) {\n        Py_INCREF(result);\n        return result;\n    }\n    if (PyUnicode_CheckExact(cls)) {\n        const char *name = PyUnicode_AsUTF8(cls);\n        if (name == NULL)\n            return NULL;\n        buf = PyMem_Malloc(strlen(name) + 3 + 1);\n        if (buf == NULL)\n            return PyErr_NoMemory();\n        sprintf(buf, \"LP_%s\", name);\n        result = PyObject_CallFunction((PyObject *)Py_TYPE(&PyCPointer_Type),\n                                       \"s(O){}\",\n                                       buf,\n                                       &PyCPointer_Type);\n        PyMem_Free(buf);\n        if (result == NULL)\n            return result;\n        key = PyLong_FromVoidPtr(result);\n        if (key == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n    } else if (PyType_Check(cls)) {\n        typ = (PyTypeObject *)cls;\n        buf = PyMem_Malloc(strlen(typ->tp_name) + 3 + 1);\n        if (buf == NULL)\n            return PyErr_NoMemory();\n        sprintf(buf, \"LP_%s\", typ->tp_name);\n        result = PyObject_CallFunction((PyObject *)Py_TYPE(&PyCPointer_Type),\n                                       \"s(O){sO}\",\n                                       buf,\n                                       &PyCPointer_Type,\n                                       \"_type_\", cls);\n        PyMem_Free(buf);\n        if (result == NULL)\n            return result;\n        Py_INCREF(cls);\n        key = cls;\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"must be a ctypes type\");\n        return NULL;\n    }\n    if (-1 == PyDict_SetItem(_ctypes_ptrtype_cache, key, result)) {\n        Py_DECREF(result);\n        Py_DECREF(key);\n        return NULL;\n    }\n    Py_DECREF(key);\n    return result;\n}\n\nstatic PyObject *\npointer(PyObject *self, PyObject *arg)\n{\n    PyObject *result;\n    PyObject *typ;\n\n    typ = PyDict_GetItem(_ctypes_ptrtype_cache, (PyObject *)Py_TYPE(arg));\n    if (typ)\n        return PyObject_CallFunctionObjArgs(typ, arg, NULL);\n    typ = POINTER(NULL, (PyObject *)Py_TYPE(arg));\n    if (typ == NULL)\n                    return NULL;\n    result = PyObject_CallFunctionObjArgs(typ, arg, NULL);\n    Py_DECREF(typ);\n    return result;\n}\n\nstatic PyObject *\nbuffer_info(PyObject *self, PyObject *arg)\n{\n    StgDictObject *dict = PyType_stgdict(arg);\n    PyObject *shape;\n    Py_ssize_t i;\n\n    if (dict == NULL)\n        dict = PyObject_stgdict(arg);\n    if (dict == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"not a ctypes type or object\");\n        return NULL;\n    }\n    shape = PyTuple_New(dict->ndim);\n    if (shape == NULL)\n        return NULL;\n    for (i = 0; i < (int)dict->ndim; ++i)\n        PyTuple_SET_ITEM(shape, i, PyLong_FromSsize_t(dict->shape[i]));\n\n    if (PyErr_Occurred()) {\n        Py_DECREF(shape);\n        return NULL;\n    }\n    return Py_BuildValue(\"siN\", dict->format, dict->ndim, shape);\n}\n\nPyMethodDef _ctypes_module_methods[] = {\n    {\"get_errno\", get_errno, METH_NOARGS},\n    {\"set_errno\", set_errno, METH_VARARGS},\n    {\"POINTER\", POINTER, METH_O },\n    {\"pointer\", pointer, METH_O },\n    {\"_unpickle\", unpickle, METH_VARARGS },\n    {\"buffer_info\", buffer_info, METH_O, \"Return buffer interface information\"},\n    {\"resize\", resize, METH_VARARGS, \"Resize the memory buffer of a ctypes instance\"},\n#ifdef MS_WIN32\n    {\"get_last_error\", get_last_error, METH_NOARGS},\n    {\"set_last_error\", set_last_error, METH_VARARGS},\n    {\"CopyComPointer\", copy_com_pointer, METH_VARARGS, copy_com_pointer_doc},\n    {\"FormatError\", format_error, METH_VARARGS, format_error_doc},\n    {\"LoadLibrary\", load_library, METH_VARARGS, load_library_doc},\n    {\"FreeLibrary\", free_library, METH_VARARGS, free_library_doc},\n    {\"_check_HRESULT\", check_hresult, METH_VARARGS},\n#else\n    {\"dlopen\", py_dl_open, METH_VARARGS,\n     \"dlopen(name, flag={RTLD_GLOBAL|RTLD_LOCAL}) open a shared library\"},\n    {\"dlclose\", py_dl_close, METH_VARARGS, \"dlclose a library\"},\n    {\"dlsym\", py_dl_sym, METH_VARARGS, \"find symbol in shared library\"},\n#endif\n    {\"alignment\", align_func, METH_O, alignment_doc},\n    {\"sizeof\", sizeof_func, METH_O, sizeof_doc},\n    {\"byref\", byref, METH_VARARGS, byref_doc},\n    {\"addressof\", addressof, METH_O, addressof_doc},\n    {\"call_function\", call_function, METH_VARARGS },\n    {\"call_cdeclfunction\", call_cdeclfunction, METH_VARARGS },\n    {\"PyObj_FromPtr\", My_PyObj_FromPtr, METH_VARARGS },\n    {\"Py_INCREF\", My_Py_INCREF, METH_O },\n    {\"Py_DECREF\", My_Py_DECREF, METH_O },\n    {NULL,      NULL}        /* Sentinel */\n};\n\n/*\n Local Variables:\n compile-command: \"cd .. && python setup.py -q build -g && python setup.py -q build install --home ~\"\n End:\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Modules/_ctypes/darwin/dlfcn.h": "/*\nCopyright (c) 2002 Jorge Acereda  <jacereda@users.sourceforge.net> &\n                   Peter O'Gorman <ogorman@users.sourceforge.net>\n                   \nPortions may be copyright others, see the AUTHORS file included with this\ndistribution.\n\nMaintained by Peter O'Gorman <ogorman@users.sourceforge.net>\n\nBug Reports and other queries should go to <ogorman@users.sourceforge.net>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n#ifndef _DLFCN_H_\n#define _DLFCN_H_\n\n#include <AvailabilityMacros.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/*\n * Structure filled in by dladdr().\n */\n\ntypedef struct dl_info {\n        const char      *dli_fname;     /* Pathname of shared object */\n        void            *dli_fbase;     /* Base address of shared object */\n        const char      *dli_sname;     /* Name of nearest symbol */\n        void            *dli_saddr;     /* Address of nearest symbol */\n} Dl_info;\n\n\n#if MAC_OS_X_VERSION_MIN_REQUIRED <= MAC_OS_X_VERSION_10_2\n#warning CTYPES_DARWIN_DLFCN\n#define CTYPES_DARWIN_DLFCN\nextern void * (*ctypes_dlopen)(const char *path, int mode);\nextern void * (*ctypes_dlsym)(void * handle, const char *symbol);\nextern const char * (*ctypes_dlerror)(void);\nextern int (*ctypes_dlclose)(void * handle);\nextern int (*ctypes_dladdr)(const void *, Dl_info *);\n#else\nextern void * dlopen(const char *path, int mode);\nextern void * dlsym(void * handle, const char *symbol);\nextern const char * dlerror(void);\nextern int dlclose(void * handle);\nextern int dladdr(const void *, Dl_info *);\n#endif\n\n#define RTLD_LAZY\t0x1\n#define RTLD_NOW\t0x2\n#define RTLD_LOCAL\t0x4\n#define RTLD_GLOBAL\t0x8\n#define RTLD_NOLOAD\t0x10\n#define RTLD_NODELETE\t0x80\n\n/* These are from the Mac OS X 10.4 headers */\n#define RTLD_NEXT       ((void *) -1)   /* Search subsequent objects. */\n#define RTLD_DEFAULT    ((void *) -2)   /* Use default search algorithm. */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _DLFCN_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Modules/_ctypes/darwin/dlfcn_simple.c": "/*\nCopyright (c) 2002 Peter O'Gorman <ogorman@users.sourceforge.net>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/* Just to prove that it isn't that hard to add Mac calls to your code :)\n   This works with pretty much everything, including kde3 xemacs and the gimp,\n   I'd guess that it'd work in at least 95% of cases, use this as your starting\n   point, rather than the mess that is dlfcn.c, assuming that your code does not\n   require ref counting or symbol lookups in dependent libraries\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <mach-o/dyld.h>\n#include <AvailabilityMacros.h>\n#include \"dlfcn.h\"\n\n#ifdef CTYPES_DARWIN_DLFCN\n\n#define ERR_STR_LEN 256\n\n#ifndef MAC_OS_X_VERSION_10_3\n#define MAC_OS_X_VERSION_10_3 1030\n#endif\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_3\n#define DARWIN_HAS_DLOPEN\nextern void * dlopen(const char *path, int mode) __attribute__((weak_import));\nextern void * dlsym(void * handle, const char *symbol) __attribute__((weak_import));\nextern const char * dlerror(void) __attribute__((weak_import));\nextern int dlclose(void * handle) __attribute__((weak_import));\nextern int dladdr(const void *, Dl_info *) __attribute__((weak_import));\n#endif /* MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_3 */\n\n#ifndef DARWIN_HAS_DLOPEN\n#define dlopen darwin_dlopen\n#define dlsym darwin_dlsym\n#define dlerror darwin_dlerror\n#define dlclose darwin_dlclose\n#define dladdr darwin_dladdr\n#endif\n\nvoid * (*ctypes_dlopen)(const char *path, int mode);\nvoid * (*ctypes_dlsym)(void * handle, const char *symbol);\nconst char * (*ctypes_dlerror)(void);\nint (*ctypes_dlclose)(void * handle);\nint (*ctypes_dladdr)(const void *, Dl_info *);\n\n#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3\n/* Mac OS X 10.3+ has dlopen, so strip all this dead code to avoid warnings */\n\nstatic void *dlsymIntern(void *handle, const char *symbol);\n\nstatic const char *error(int setget, const char *str, ...);\n\n/* Set and get the error string for use by dlerror */\nstatic const char *error(int setget, const char *str, ...)\n{\n    static char errstr[ERR_STR_LEN];\n    static int err_filled = 0;\n    const char *retval;\n    va_list arg;\n    if (setget == 0)\n    {\n        va_start(arg, str);\n        strncpy(errstr, \"dlcompat: \", ERR_STR_LEN);\n        vsnprintf(errstr + 10, ERR_STR_LEN - 10, str, arg);\n        va_end(arg);\n        err_filled = 1;\n        retval = NULL;\n    }\n    else\n    {\n        if (!err_filled)\n            retval = NULL;\n        else\n            retval = errstr;\n        err_filled = 0;\n    }\n    return retval;\n}\n\n/* darwin_dlopen */\nstatic void *darwin_dlopen(const char *path, int mode)\n{\n    void *module = 0;\n    NSObjectFileImage ofi = 0;\n    NSObjectFileImageReturnCode ofirc;\n\n    /* If we got no path, the app wants the global namespace, use -1 as the marker\n       in this case */\n    if (!path)\n        return (void *)-1;\n\n    /* Create the object file image, works for things linked with the -bundle arg to ld */\n    ofirc = NSCreateObjectFileImageFromFile(path, &ofi);\n    switch (ofirc)\n    {\n        case NSObjectFileImageSuccess:\n            /* It was okay, so use NSLinkModule to link in the image */\n            module = NSLinkModule(ofi, path,\n                                                      NSLINKMODULE_OPTION_RETURN_ON_ERROR\n                                                      | (mode & RTLD_GLOBAL) ? 0 : NSLINKMODULE_OPTION_PRIVATE\n                                                      | (mode & RTLD_LAZY) ? 0 : NSLINKMODULE_OPTION_BINDNOW);\n            NSDestroyObjectFileImage(ofi);\n            break;\n        case NSObjectFileImageInappropriateFile:\n            /* It may have been a dynamic library rather than a bundle, try to load it */\n            module = (void *)NSAddImage(path, NSADDIMAGE_OPTION_RETURN_ON_ERROR);\n            break;\n        default:\n            /* God knows what we got */\n            error(0, \"Can not open \\\"%s\\\"\", path);\n            return 0;\n    }\n    if (!module)\n        error(0, \"Can not open \\\"%s\\\"\", path);\n    return module;\n\n}\n\n/* dlsymIntern is used by dlsym to find the symbol */\nstatic void *dlsymIntern(void *handle, const char *symbol)\n{\n    NSSymbol nssym = 0;\n    /* If the handle is -1, if is the app global context */\n    if (handle == (void *)-1)\n    {\n        /* Global context, use NSLookupAndBindSymbol */\n        if (NSIsSymbolNameDefined(symbol))\n        {\n            nssym = NSLookupAndBindSymbol(symbol);\n        }\n\n    }\n    /* Now see if the handle is a struch mach_header* or not, use NSLookupSymbol in image\n       for libraries, and NSLookupSymbolInModule for bundles */\n    else\n    {\n        /* Check for both possible magic numbers depending on x86/ppc byte order */\n        if ((((struct mach_header *)handle)->magic == MH_MAGIC) ||\n            (((struct mach_header *)handle)->magic == MH_CIGAM))\n        {\n            if (NSIsSymbolNameDefinedInImage((struct mach_header *)handle, symbol))\n            {\n                nssym = NSLookupSymbolInImage((struct mach_header *)handle,\n                                                                          symbol,\n                                                                          NSLOOKUPSYMBOLINIMAGE_OPTION_BIND\n                                                                          | NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);\n            }\n\n        }\n        else\n        {\n            nssym = NSLookupSymbolInModule(handle, symbol);\n        }\n    }\n    if (!nssym)\n    {\n        error(0, \"Symbol \\\"%s\\\" Not found\", symbol);\n        return NULL;\n    }\n    return NSAddressOfSymbol(nssym);\n}\n\nstatic const char *darwin_dlerror(void)\n{\n    return error(1, (char *)NULL);\n}\n\nstatic int darwin_dlclose(void *handle)\n{\n    if ((((struct mach_header *)handle)->magic == MH_MAGIC) ||\n        (((struct mach_header *)handle)->magic == MH_CIGAM))\n    {\n        error(0, \"Can't remove dynamic libraries on darwin\");\n        return 0;\n    }\n    if (!NSUnLinkModule(handle, 0))\n    {\n        error(0, \"unable to unlink module %s\", NSNameOfModule(handle));\n        return 1;\n    }\n    return 0;\n}\n\n\n/* dlsym, prepend the underscore and call dlsymIntern */\nstatic void *darwin_dlsym(void *handle, const char *symbol)\n{\n    static char undersym[257];          /* Saves calls to malloc(3) */\n    int sym_len = strlen(symbol);\n    void *value = NULL;\n    char *malloc_sym = NULL;\n\n    if (sym_len < 256)\n    {\n        snprintf(undersym, 256, \"_%s\", symbol);\n        value = dlsymIntern(handle, undersym);\n    }\n    else\n    {\n        malloc_sym = malloc(sym_len + 2);\n        if (malloc_sym)\n        {\n            sprintf(malloc_sym, \"_%s\", symbol);\n            value = dlsymIntern(handle, malloc_sym);\n            free(malloc_sym);\n        }\n        else\n        {\n            error(0, \"Unable to allocate memory\");\n        }\n    }\n    return value;\n}\n\nstatic int darwin_dladdr(const void *handle, Dl_info *info) {\n    return 0;\n}\n#endif /* MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3 */\n\n#if __GNUC__ < 4\n#pragma CALL_ON_LOAD ctypes_dlfcn_init\n#else\nstatic void __attribute__ ((constructor)) ctypes_dlfcn_init(void);\nstatic\n#endif\nvoid ctypes_dlfcn_init(void) {\n    if (dlopen != NULL) {\n        ctypes_dlsym = dlsym;\n        ctypes_dlopen = dlopen;\n        ctypes_dlerror = dlerror;\n        ctypes_dlclose = dlclose;\n        ctypes_dladdr = dladdr;\n    } else {\n#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3\n        ctypes_dlsym = darwin_dlsym;\n        ctypes_dlopen = darwin_dlopen;\n        ctypes_dlerror = darwin_dlerror;\n        ctypes_dlclose = darwin_dlclose;\n        ctypes_dladdr = darwin_dladdr;\n#endif /* MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3 */\n    }\n}\n\n#endif /* CTYPES_DARWIN_DLFCN */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/ensurepip/_bundled/pip-20.1.1-py2.py3-none-any.whl",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/ensurepip/_bundled/setuptools-47.1.0-py3-none-any.whl",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/sqlite3/test/transactions.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/sqlite3/test/hooks.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/sqlite3/test/types.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/sqlite3/test/factory.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/sqlite3/test/dbapi.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/sqlite3/test/userfunctions.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/sqlite3/test/regression.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/idle.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/plusnode.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/idle_32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/idle_48.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/idle_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/folder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/openfolder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/minusnode.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/tk.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/python.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/idle_48.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/idle_32.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/idle_256.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/idlelib/Icons/idle_16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/testtar.tar",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/zip_cp437_header.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/pstats.pck",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/zipdir.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/badsyntax_pep3120.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/sgml_input.html",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/Sine-1000Hz-300ms.aif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiotest.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/test_source_encoding.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/sndhdrdata/sndhdr.voc",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/sndhdrdata/sndhdr.wav",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/sndhdrdata/sndhdr.8svx",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/sndhdrdata/sndhdr.aifc",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/sndhdrdata/sndhdr.sndt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/sndhdrdata/sndhdr.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/sndhdrdata/sndhdr.aiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/sndhdrdata/sndhdr.hcom",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm8.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm24.wav",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm8.wav",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm24.aiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm8.aiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-alaw.aifc",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm16.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-ulaw.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm32.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm32.aiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm16.wav",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm24.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-ulaw.aifc",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm32.wav",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/audiodata/pluck-pcm16.aiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/encoded_modules/module_iso_8859_1.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/encoded_modules/module_koi8_r.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/test_importlib/zipdata02/ziptestdata.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/test_importlib/zipdata01/ziptestdata.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/test_importlib/data01/utf-16.file",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/test_importlib/namespace_pkgs/top_level_portion1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/test_importlib/namespace_pkgs/nested_portion1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/test_importlib/namespace_pkgs/missing_directory.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/johab.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/shift_jis.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/gb18030.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/euc_jp.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/big5.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/euc_jisx0213.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/big5hkscs.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/euc_kr.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/shift_jisx0213.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/gb2312.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/gbk.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/cjkencodings/cp949.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/test_email/data/PyBanner048.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/test_email/data/audiotest.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.ppm",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.pbm",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.exr",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.ras",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.pgm",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.webp",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/imghdrdata/python.sgi",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/xmltestdata/test.xml",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/test/xmltestdata/test.xml.out",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/distutils/command/wininst-9.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/distutils/command/wininst-8.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/distutils/command/wininst-10.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/distutils/command/wininst-6.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/distutils/command/wininst-14.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/distutils/command/wininst-7.1.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/distutils/command/wininst-10.0-amd64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/distutils/command/wininst-14.0-amd64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Lib/distutils/command/wininst-9.0-amd64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/BuildScript/resources/background.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/IDLE/IDLE.app/Contents/Resources/PythonSource.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/IDLE/IDLE.app/Contents/Resources/PythonCompiled.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/IDLE/IDLE.app/Contents/Resources/IDLE.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Resources/app/Resources/PythonApplet.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Resources/app/Resources/PythonInterpreter.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Resources/iconsrc/IDE.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Resources/iconsrc/PythonApplet.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Resources/iconsrc/PythonSource.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Resources/iconsrc/PackageManager.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Resources/iconsrc/PythonCompiled.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Resources/iconsrc/PythonWSource.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Resources/iconsrc/PythonIcon.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/PythonLauncher/English.lproj/MyDocument.nib/objects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/PythonLauncher/English.lproj/MainMenu.nib/objects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/PythonLauncher/English.lproj/PreferenceWindow.nib/objects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Icons/Python Folder.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Icons/PythonSource.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Icons/Disk Image.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Icons/PythonLauncher.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Icons/PythonCompiled.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Mac/Icons/IDLE.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Tools/test2to3/setup.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Tools/msi/bundle/SideBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Tools/i18n/pygettext.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Doc/library/turtle-star.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Doc/library/hashlib-blake2-tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Doc/library/tulip_coro.dia",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Doc/library/tulip_coro.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Doc/library/turtle-star.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Doc/library/pathlib-inheritance.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Doc/howto/logging_flow.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Doc/using/win_installer.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Doc/tools/static/py.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/Doc/faq/python-video-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/classicAppCompat.cat",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/setup.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/py.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/pythonwx150.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/pythonx50.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/launcher.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/pythonx150.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/pyd.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/python.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/pyd.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/launcher.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/pyc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/setup.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/pythonw.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/pyc.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/py.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/pythonwx44.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/python.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/pythonx44.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/icons/pythonw.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.7.8-2xjwryyopyqn77c2ncxoz3exzifikt7v/spack-src/PC/bdist_wininst/PythonPowered.bmp"
    ],
    "total_files": 3863
}