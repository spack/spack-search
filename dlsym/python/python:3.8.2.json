{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Doc/library/ctypes.rst": ":mod:`ctypes` --- A foreign function library for Python\n=======================================================\n\n.. module:: ctypes\n   :synopsis: A foreign function library for Python.\n\n.. moduleauthor:: Thomas Heller <theller@python.net>\n\n--------------\n\n:mod:`ctypes` is a foreign function library for Python.  It provides C compatible\ndata types, and allows calling functions in DLLs or shared libraries.  It can be\nused to wrap these libraries in pure Python.\n\n\n.. _ctypes-ctypes-tutorial:\n\nctypes tutorial\n---------------\n\nNote: The code samples in this tutorial use :mod:`doctest` to make sure that\nthey actually work.  Since some code samples behave differently under Linux,\nWindows, or Mac OS X, they contain doctest directives in comments.\n\nNote: Some code samples reference the ctypes :class:`c_int` type.  On platforms\nwhere ``sizeof(long) == sizeof(int)`` it is an alias to :class:`c_long`.\nSo, you should not be confused if :class:`c_long` is printed if you would expect\n:class:`c_int` --- they are actually the same type.\n\n.. _ctypes-loading-dynamic-link-libraries:\n\nLoading dynamic link libraries\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll*\nobjects, for loading dynamic link libraries.\n\nYou load libraries by accessing them as attributes of these objects. *cdll*\nloads libraries which export functions using the standard ``cdecl`` calling\nconvention, while *windll* libraries call functions using the ``stdcall``\ncalling convention. *oledll* also uses the ``stdcall`` calling convention, and\nassumes the functions return a Windows :c:type:`HRESULT` error code. The error\ncode is used to automatically raise an :class:`OSError` exception when the\nfunction call fails.\n\n.. versionchanged:: 3.3\n   Windows errors used to raise :exc:`WindowsError`, which is now an alias\n   of :exc:`OSError`.\n\n\nHere are some examples for Windows. Note that ``msvcrt`` is the MS standard C\nlibrary containing most standard C functions, and uses the cdecl calling\nconvention::\n\n   >>> from ctypes import *\n   >>> print(windll.kernel32)  # doctest: +WINDOWS\n   <WinDLL 'kernel32', handle ... at ...>\n   >>> print(cdll.msvcrt)      # doctest: +WINDOWS\n   <CDLL 'msvcrt', handle ... at ...>\n   >>> libc = cdll.msvcrt      # doctest: +WINDOWS\n   >>>\n\nWindows appends the usual ``.dll`` file suffix automatically.\n\n.. note::\n    Accessing the standard C library through ``cdll.msvcrt`` will use an\n    outdated version of the library that may be incompatible with the one\n    being used by Python. Where possible, use native Python functionality,\n    or else import and use the ``msvcrt`` module.\n\nOn Linux, it is required to specify the filename *including* the extension to\nload a library, so attribute access can not be used to load libraries. Either the\n:meth:`LoadLibrary` method of the dll loaders should be used, or you should load\nthe library by creating an instance of CDLL by calling the constructor::\n\n   >>> cdll.LoadLibrary(\"libc.so.6\")  # doctest: +LINUX\n   <CDLL 'libc.so.6', handle ... at ...>\n   >>> libc = CDLL(\"libc.so.6\")       # doctest: +LINUX\n   >>> libc                           # doctest: +LINUX\n   <CDLL 'libc.so.6', handle ... at ...>\n   >>>\n\n.. XXX Add section for Mac OS X.\n\n\n.. _ctypes-accessing-functions-from-loaded-dlls:\n\nAccessing functions from loaded dlls\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFunctions are accessed as attributes of dll objects::\n\n   >>> from ctypes import *\n   >>> libc.printf\n   <_FuncPtr object at 0x...>\n   >>> print(windll.kernel32.GetModuleHandleA)  # doctest: +WINDOWS\n   <_FuncPtr object at 0x...>\n   >>> print(windll.kernel32.MyOwnFunction)     # doctest: +WINDOWS\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n     File \"ctypes.py\", line 239, in __getattr__\n       func = _StdcallFuncPtr(name, self)\n   AttributeError: function 'MyOwnFunction' not found\n   >>>\n\nNote that win32 system dlls like ``kernel32`` and ``user32`` often export ANSI\nas well as UNICODE versions of a function. The UNICODE version is exported with\nan ``W`` appended to the name, while the ANSI version is exported with an ``A``\nappended to the name. The win32 ``GetModuleHandle`` function, which returns a\n*module handle* for a given module name, has the following C prototype, and a\nmacro is used to expose one of them as ``GetModuleHandle`` depending on whether\nUNICODE is defined or not::\n\n   /* ANSI version */\n   HMODULE GetModuleHandleA(LPCSTR lpModuleName);\n   /* UNICODE version */\n   HMODULE GetModuleHandleW(LPCWSTR lpModuleName);\n\n*windll* does not try to select one of them by magic, you must access the\nversion you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW``\nexplicitly, and then call it with bytes or string objects respectively.\n\nSometimes, dlls export functions with names which aren't valid Python\nidentifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use\n:func:`getattr` to retrieve the function::\n\n   >>> getattr(cdll.msvcrt, \"??2@YAPAXI@Z\")  # doctest: +WINDOWS\n   <_FuncPtr object at 0x...>\n   >>>\n\nOn Windows, some dlls export functions not by name but by ordinal. These\nfunctions can be accessed by indexing the dll object with the ordinal number::\n\n   >>> cdll.kernel32[1]  # doctest: +WINDOWS\n   <_FuncPtr object at 0x...>\n   >>> cdll.kernel32[0]  # doctest: +WINDOWS\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n     File \"ctypes.py\", line 310, in __getitem__\n       func = _StdcallFuncPtr(name, self)\n   AttributeError: function ordinal 0 not found\n   >>>\n\n\n.. _ctypes-calling-functions:\n\nCalling functions\n^^^^^^^^^^^^^^^^^\n\nYou can call these functions like any other Python callable. This example uses\nthe ``time()`` function, which returns system time in seconds since the Unix\nepoch, and the ``GetModuleHandleA()`` function, which returns a win32 module\nhandle.\n\nThis example calls both functions with a ``NULL`` pointer (``None`` should be used\nas the ``NULL`` pointer)::\n\n   >>> print(libc.time(None))  # doctest: +SKIP\n   1150640792\n   >>> print(hex(windll.kernel32.GetModuleHandleA(None)))  # doctest: +WINDOWS\n   0x1d000000\n   >>>\n\n:exc:`ValueError` is raised when you call an ``stdcall`` function with the\n``cdecl`` calling convention, or vice versa::\n\n   >>> cdll.kernel32.GetModuleHandleA(None)  # doctest: +WINDOWS\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n   ValueError: Procedure probably called with not enough arguments (4 bytes missing)\n   >>>\n\n   >>> windll.msvcrt.printf(b\"spam\")  # doctest: +WINDOWS\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n   ValueError: Procedure probably called with too many arguments (4 bytes in excess)\n   >>>\n\nTo find out the correct calling convention you have to look into the C header\nfile or the documentation for the function you want to call.\n\nOn Windows, :mod:`ctypes` uses win32 structured exception handling to prevent\ncrashes from general protection faults when functions are called with invalid\nargument values::\n\n   >>> windll.kernel32.GetModuleHandleA(32)  # doctest: +WINDOWS\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n   OSError: exception: access violation reading 0x00000020\n   >>>\n\nThere are, however, enough ways to crash Python with :mod:`ctypes`, so you\nshould be careful anyway.  The :mod:`faulthandler` module can be helpful in\ndebugging crashes (e.g. from segmentation faults produced by erroneous C library\ncalls).\n\n``None``, integers, bytes objects and (unicode) strings are the only native\nPython objects that can directly be used as parameters in these function calls.\n``None`` is passed as a C ``NULL`` pointer, bytes objects and strings are passed\nas pointer to the memory block that contains their data (:c:type:`char *` or\n:c:type:`wchar_t *`).  Python integers are passed as the platforms default C\n:c:type:`int` type, their value is masked to fit into the C type.\n\nBefore we move on calling functions with other parameter types, we have to learn\nmore about :mod:`ctypes` data types.\n\n\n.. _ctypes-fundamental-data-types:\n\nFundamental data types\n^^^^^^^^^^^^^^^^^^^^^^\n\n:mod:`ctypes` defines a number of primitive C compatible data types:\n\n+----------------------+------------------------------------------+----------------------------+\n| ctypes type          | C type                                   | Python type                |\n+======================+==========================================+============================+\n| :class:`c_bool`      | :c:type:`_Bool`                          | bool (1)                   |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_char`      | :c:type:`char`                           | 1-character bytes object   |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_wchar`     | :c:type:`wchar_t`                        | 1-character string         |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_byte`      | :c:type:`char`                           | int                        |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_ubyte`     | :c:type:`unsigned char`                  | int                        |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_short`     | :c:type:`short`                          | int                        |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_ushort`    | :c:type:`unsigned short`                 | int                        |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_int`       | :c:type:`int`                            | int                        |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_uint`      | :c:type:`unsigned int`                   | int                        |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_long`      | :c:type:`long`                           | int                        |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_ulong`     | :c:type:`unsigned long`                  | int                        |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_longlong`  | :c:type:`__int64` or :c:type:`long long` | int                        |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_ulonglong` | :c:type:`unsigned __int64` or            | int                        |\n|                      | :c:type:`unsigned long long`             |                            |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_size_t`    | :c:type:`size_t`                         | int                        |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_ssize_t`   | :c:type:`ssize_t` or                     | int                        |\n|                      | :c:type:`Py_ssize_t`                     |                            |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_float`     | :c:type:`float`                          | float                      |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_double`    | :c:type:`double`                         | float                      |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_longdouble`| :c:type:`long double`                    | float                      |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_char_p`    | :c:type:`char *` (NUL terminated)        | bytes object or ``None``   |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_wchar_p`   | :c:type:`wchar_t *` (NUL terminated)     | string or ``None``         |\n+----------------------+------------------------------------------+----------------------------+\n| :class:`c_void_p`    | :c:type:`void *`                         | int or ``None``            |\n+----------------------+------------------------------------------+----------------------------+\n\n(1)\n   The constructor accepts any object with a truth value.\n\nAll these types can be created by calling them with an optional initializer of\nthe correct type and value::\n\n   >>> c_int()\n   c_long(0)\n   >>> c_wchar_p(\"Hello, World\")\n   c_wchar_p(140018365411392)\n   >>> c_ushort(-3)\n   c_ushort(65533)\n   >>>\n\nSince these types are mutable, their value can also be changed afterwards::\n\n   >>> i = c_int(42)\n   >>> print(i)\n   c_long(42)\n   >>> print(i.value)\n   42\n   >>> i.value = -99\n   >>> print(i.value)\n   -99\n   >>>\n\nAssigning a new value to instances of the pointer types :class:`c_char_p`,\n:class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they\npoint to, *not the contents* of the memory block (of course not, because Python\nbytes objects are immutable)::\n\n   >>> s = \"Hello, World\"\n   >>> c_s = c_wchar_p(s)\n   >>> print(c_s)\n   c_wchar_p(139966785747344)\n   >>> print(c_s.value)\n   Hello World\n   >>> c_s.value = \"Hi, there\"\n   >>> print(c_s)              # the memory location has changed\n   c_wchar_p(139966783348904)\n   >>> print(c_s.value)\n   Hi, there\n   >>> print(s)                # first object is unchanged\n   Hello, World\n   >>>\n\nYou should be careful, however, not to pass them to functions expecting pointers\nto mutable memory. If you need mutable memory blocks, ctypes has a\n:func:`create_string_buffer` function which creates these in various ways.  The\ncurrent memory block contents can be accessed (or changed) with the ``raw``\nproperty; if you want to access it as NUL terminated string, use the ``value``\nproperty::\n\n   >>> from ctypes import *\n   >>> p = create_string_buffer(3)            # create a 3 byte buffer, initialized to NUL bytes\n   >>> print(sizeof(p), repr(p.raw))\n   3 b'\\x00\\x00\\x00'\n   >>> p = create_string_buffer(b\"Hello\")     # create a buffer containing a NUL terminated string\n   >>> print(sizeof(p), repr(p.raw))\n   6 b'Hello\\x00'\n   >>> print(repr(p.value))\n   b'Hello'\n   >>> p = create_string_buffer(b\"Hello\", 10) # create a 10 byte buffer\n   >>> print(sizeof(p), repr(p.raw))\n   10 b'Hello\\x00\\x00\\x00\\x00\\x00'\n   >>> p.value = b\"Hi\"\n   >>> print(sizeof(p), repr(p.raw))\n   10 b'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00'\n   >>>\n\nThe :func:`create_string_buffer` function replaces the :func:`c_buffer` function\n(which is still available as an alias), as well as the :func:`c_string` function\nfrom earlier ctypes releases.  To create a mutable memory block containing\nunicode characters of the C type :c:type:`wchar_t` use the\n:func:`create_unicode_buffer` function.\n\n\n.. _ctypes-calling-functions-continued:\n\nCalling functions, continued\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nNote that printf prints to the real standard output channel, *not* to\n:data:`sys.stdout`, so these examples will only work at the console prompt, not\nfrom within *IDLE* or *PythonWin*::\n\n   >>> printf = libc.printf\n   >>> printf(b\"Hello, %s\\n\", b\"World!\")\n   Hello, World!\n   14\n   >>> printf(b\"Hello, %S\\n\", \"World!\")\n   Hello, World!\n   14\n   >>> printf(b\"%d bottles of beer\\n\", 42)\n   42 bottles of beer\n   19\n   >>> printf(b\"%f bottles of beer\\n\", 42.5)\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n   ArgumentError: argument 2: exceptions.TypeError: Don't know how to convert parameter 2\n   >>>\n\nAs has been mentioned before, all Python types except integers, strings, and\nbytes objects have to be wrapped in their corresponding :mod:`ctypes` type, so\nthat they can be converted to the required C data type::\n\n   >>> printf(b\"An int %d, a double %f\\n\", 1234, c_double(3.14))\n   An int 1234, a double 3.140000\n   31\n   >>>\n\n\n.. _ctypes-calling-functions-with-own-custom-data-types:\n\nCalling functions with your own custom data types\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYou can also customize :mod:`ctypes` argument conversion to allow instances of\nyour own classes be used as function arguments.  :mod:`ctypes` looks for an\n:attr:`_as_parameter_` attribute and uses this as the function argument.  Of\ncourse, it must be one of integer, string, or bytes::\n\n   >>> class Bottles:\n   ...     def __init__(self, number):\n   ...         self._as_parameter_ = number\n   ...\n   >>> bottles = Bottles(42)\n   >>> printf(b\"%d bottles of beer\\n\", bottles)\n   42 bottles of beer\n   19\n   >>>\n\nIf you don't want to store the instance's data in the :attr:`_as_parameter_`\ninstance variable, you could define a :class:`property` which makes the\nattribute available on request.\n\n\n.. _ctypes-specifying-required-argument-types:\n\nSpecifying the required argument types (function prototypes)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIt is possible to specify the required argument types of functions exported from\nDLLs by setting the :attr:`argtypes` attribute.\n\n:attr:`argtypes` must be a sequence of C data types (the ``printf`` function is\nprobably not a good example here, because it takes a variable number and\ndifferent types of parameters depending on the format string, on the other hand\nthis is quite handy to experiment with this feature)::\n\n   >>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]\n   >>> printf(b\"String '%s', Int %d, Double %f\\n\", b\"Hi\", 10, 2.2)\n   String 'Hi', Int 10, Double 2.200000\n   37\n   >>>\n\nSpecifying a format protects against incompatible argument types (just as a\nprototype for a C function), and tries to convert the arguments to valid types::\n\n   >>> printf(b\"%d %d %d\", 1, 2, 3)\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n   ArgumentError: argument 2: exceptions.TypeError: wrong type\n   >>> printf(b\"%s %d %f\\n\", b\"X\", 2, 3)\n   X 2 3.000000\n   13\n   >>>\n\nIf you have defined your own classes which you pass to function calls, you have\nto implement a :meth:`from_param` class method for them to be able to use them\nin the :attr:`argtypes` sequence. The :meth:`from_param` class method receives\nthe Python object passed to the function call, it should do a typecheck or\nwhatever is needed to make sure this object is acceptable, and then return the\nobject itself, its :attr:`_as_parameter_` attribute, or whatever you want to\npass as the C function argument in this case. Again, the result should be an\ninteger, string, bytes, a :mod:`ctypes` instance, or an object with an\n:attr:`_as_parameter_` attribute.\n\n\n.. _ctypes-return-types:\n\nReturn types\n^^^^^^^^^^^^\n\nBy default functions are assumed to return the C :c:type:`int` type.  Other\nreturn types can be specified by setting the :attr:`restype` attribute of the\nfunction object.\n\nHere is a more advanced example, it uses the ``strchr`` function, which expects\na string pointer and a char, and returns a pointer to a string::\n\n   >>> strchr = libc.strchr\n   >>> strchr(b\"abcdef\", ord(\"d\"))  # doctest: +SKIP\n   8059983\n   >>> strchr.restype = c_char_p    # c_char_p is a pointer to a string\n   >>> strchr(b\"abcdef\", ord(\"d\"))\n   b'def'\n   >>> print(strchr(b\"abcdef\", ord(\"x\")))\n   None\n   >>>\n\nIf you want to avoid the ``ord(\"x\")`` calls above, you can set the\n:attr:`argtypes` attribute, and the second argument will be converted from a\nsingle character Python bytes object into a C char::\n\n   >>> strchr.restype = c_char_p\n   >>> strchr.argtypes = [c_char_p, c_char]\n   >>> strchr(b\"abcdef\", b\"d\")\n   'def'\n   >>> strchr(b\"abcdef\", b\"def\")\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n   ArgumentError: argument 2: exceptions.TypeError: one character string expected\n   >>> print(strchr(b\"abcdef\", b\"x\"))\n   None\n   >>> strchr(b\"abcdef\", b\"d\")\n   'def'\n   >>>\n\nYou can also use a callable Python object (a function or a class for example) as\nthe :attr:`restype` attribute, if the foreign function returns an integer.  The\ncallable will be called with the *integer* the C function returns, and the\nresult of this call will be used as the result of your function call. This is\nuseful to check for error return values and automatically raise an exception::\n\n   >>> GetModuleHandle = windll.kernel32.GetModuleHandleA  # doctest: +WINDOWS\n   >>> def ValidHandle(value):\n   ...     if value == 0:\n   ...         raise WinError()\n   ...     return value\n   ...\n   >>>\n   >>> GetModuleHandle.restype = ValidHandle  # doctest: +WINDOWS\n   >>> GetModuleHandle(None)  # doctest: +WINDOWS\n   486539264\n   >>> GetModuleHandle(\"something silly\")  # doctest: +WINDOWS\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n     File \"<stdin>\", line 3, in ValidHandle\n   OSError: [Errno 126] The specified module could not be found.\n   >>>\n\n``WinError`` is a function which will call Windows ``FormatMessage()`` api to\nget the string representation of an error code, and *returns* an exception.\n``WinError`` takes an optional error code parameter, if no one is used, it calls\n:func:`GetLastError` to retrieve it.\n\nPlease note that a much more powerful error checking mechanism is available\nthrough the :attr:`errcheck` attribute; see the reference manual for details.\n\n\n.. _ctypes-passing-pointers:\n\nPassing pointers (or: passing parameters by reference)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSometimes a C api function expects a *pointer* to a data type as parameter,\nprobably to write into the corresponding location, or if the data is too large\nto be passed by value. This is also known as *passing parameters by reference*.\n\n:mod:`ctypes` exports the :func:`byref` function which is used to pass parameters\nby reference.  The same effect can be achieved with the :func:`pointer` function,\nalthough :func:`pointer` does a lot more work since it constructs a real pointer\nobject, so it is faster to use :func:`byref` if you don't need the pointer\nobject in Python itself::\n\n   >>> i = c_int()\n   >>> f = c_float()\n   >>> s = create_string_buffer(b'\\000' * 32)\n   >>> print(i.value, f.value, repr(s.value))\n   0 0.0 b''\n   >>> libc.sscanf(b\"1 3.14 Hello\", b\"%d %f %s\",\n   ...             byref(i), byref(f), s)\n   3\n   >>> print(i.value, f.value, repr(s.value))\n   1 3.1400001049 b'Hello'\n   >>>\n\n\n.. _ctypes-structures-unions:\n\nStructures and unions\n^^^^^^^^^^^^^^^^^^^^^\n\nStructures and unions must derive from the :class:`Structure` and :class:`Union`\nbase classes which are defined in the :mod:`ctypes` module. Each subclass must\ndefine a :attr:`_fields_` attribute.  :attr:`_fields_` must be a list of\n*2-tuples*, containing a *field name* and a *field type*.\n\nThe field type must be a :mod:`ctypes` type like :class:`c_int`, or any other\nderived :mod:`ctypes` type: structure, union, array, pointer.\n\nHere is a simple example of a POINT structure, which contains two integers named\n*x* and *y*, and also shows how to initialize a structure in the constructor::\n\n   >>> from ctypes import *\n   >>> class POINT(Structure):\n   ...     _fields_ = [(\"x\", c_int),\n   ...                 (\"y\", c_int)]\n   ...\n   >>> point = POINT(10, 20)\n   >>> print(point.x, point.y)\n   10 20\n   >>> point = POINT(y=5)\n   >>> print(point.x, point.y)\n   0 5\n   >>> POINT(1, 2, 3)\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n   TypeError: too many initializers\n   >>>\n\nYou can, however, build much more complicated structures.  A structure can\nitself contain other structures by using a structure as a field type.\n\nHere is a RECT structure which contains two POINTs named *upperleft* and\n*lowerright*::\n\n   >>> class RECT(Structure):\n   ...     _fields_ = [(\"upperleft\", POINT),\n   ...                 (\"lowerright\", POINT)]\n   ...\n   >>> rc = RECT(point)\n   >>> print(rc.upperleft.x, rc.upperleft.y)\n   0 5\n   >>> print(rc.lowerright.x, rc.lowerright.y)\n   0 0\n   >>>\n\nNested structures can also be initialized in the constructor in several ways::\n\n   >>> r = RECT(POINT(1, 2), POINT(3, 4))\n   >>> r = RECT((1, 2), (3, 4))\n\nField :term:`descriptor`\\s can be retrieved from the *class*, they are useful\nfor debugging because they can provide useful information::\n\n   >>> print(POINT.x)\n   <Field type=c_long, ofs=0, size=4>\n   >>> print(POINT.y)\n   <Field type=c_long, ofs=4, size=4>\n   >>>\n\n\n.. _ctypes-structureunion-alignment-byte-order:\n\n.. warning::\n\n   :mod:`ctypes` does not support passing unions or structures with bit-fields\n   to functions by value.  While this may work on 32-bit x86, it's not\n   guaranteed by the library to work in the general case.  Unions and\n   structures with bit-fields should always be passed to functions by pointer.\n\nStructure/union alignment and byte order\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nBy default, Structure and Union fields are aligned in the same way the C\ncompiler does it. It is possible to override this behavior by specifying a\n:attr:`_pack_` class attribute in the subclass definition. This must be set to a\npositive integer and specifies the maximum alignment for the fields. This is\nwhat ``#pragma pack(n)`` also does in MSVC.\n\n:mod:`ctypes` uses the native byte order for Structures and Unions.  To build\nstructures with non-native byte order, you can use one of the\n:class:`BigEndianStructure`, :class:`LittleEndianStructure`,\n:class:`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These\nclasses cannot contain pointer fields.\n\n\n.. _ctypes-bit-fields-in-structures-unions:\n\nBit fields in structures and unions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIt is possible to create structures and unions containing bit fields. Bit fields\nare only possible for integer fields, the bit width is specified as the third\nitem in the :attr:`_fields_` tuples::\n\n   >>> class Int(Structure):\n   ...     _fields_ = [(\"first_16\", c_int, 16),\n   ...                 (\"second_16\", c_int, 16)]\n   ...\n   >>> print(Int.first_16)\n   <Field type=c_long, ofs=0:0, bits=16>\n   >>> print(Int.second_16)\n   <Field type=c_long, ofs=0:16, bits=16>\n   >>>\n\n\n.. _ctypes-arrays:\n\nArrays\n^^^^^^\n\nArrays are sequences, containing a fixed number of instances of the same type.\n\nThe recommended way to create array types is by multiplying a data type with a\npositive integer::\n\n   TenPointsArrayType = POINT * 10\n\nHere is an example of a somewhat artificial data type, a structure containing 4\nPOINTs among other stuff::\n\n   >>> from ctypes import *\n   >>> class POINT(Structure):\n   ...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n   ...\n   >>> class MyStruct(Structure):\n   ...     _fields_ = [(\"a\", c_int),\n   ...                 (\"b\", c_float),\n   ...                 (\"point_array\", POINT * 4)]\n   >>>\n   >>> print(len(MyStruct().point_array))\n   4\n   >>>\n\nInstances are created in the usual way, by calling the class::\n\n   arr = TenPointsArrayType()\n   for pt in arr:\n       print(pt.x, pt.y)\n\nThe above code print a series of ``0 0`` lines, because the array contents is\ninitialized to zeros.\n\nInitializers of the correct type can also be specified::\n\n   >>> from ctypes import *\n   >>> TenIntegers = c_int * 10\n   >>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n   >>> print(ii)\n   <c_long_Array_10 object at 0x...>\n   >>> for i in ii: print(i, end=\" \")\n   ...\n   1 2 3 4 5 6 7 8 9 10\n   >>>\n\n\n.. _ctypes-pointers:\n\nPointers\n^^^^^^^^\n\nPointer instances are created by calling the :func:`pointer` function on a\n:mod:`ctypes` type::\n\n   >>> from ctypes import *\n   >>> i = c_int(42)\n   >>> pi = pointer(i)\n   >>>\n\nPointer instances have a :attr:`~_Pointer.contents` attribute which\nreturns the object to which the pointer points, the ``i`` object above::\n\n   >>> pi.contents\n   c_long(42)\n   >>>\n\nNote that :mod:`ctypes` does not have OOR (original object return), it constructs a\nnew, equivalent object each time you retrieve an attribute::\n\n   >>> pi.contents is i\n   False\n   >>> pi.contents is pi.contents\n   False\n   >>>\n\nAssigning another :class:`c_int` instance to the pointer's contents attribute\nwould cause the pointer to point to the memory location where this is stored::\n\n   >>> i = c_int(99)\n   >>> pi.contents = i\n   >>> pi.contents\n   c_long(99)\n   >>>\n\n.. XXX Document dereferencing pointers, and that it is preferred over the\n   .contents attribute.\n\nPointer instances can also be indexed with integers::\n\n   >>> pi[0]\n   99\n   >>>\n\nAssigning to an integer index changes the pointed to value::\n\n   >>> print(i)\n   c_long(99)\n   >>> pi[0] = 22\n   >>> print(i)\n   c_long(22)\n   >>>\n\nIt is also possible to use indexes different from 0, but you must know what\nyou're doing, just as in C: You can access or change arbitrary memory locations.\nGenerally you only use this feature if you receive a pointer from a C function,\nand you *know* that the pointer actually points to an array instead of a single\nitem.\n\nBehind the scenes, the :func:`pointer` function does more than simply create\npointer instances, it has to create pointer *types* first. This is done with the\n:func:`POINTER` function, which accepts any :mod:`ctypes` type, and returns a\nnew type::\n\n   >>> PI = POINTER(c_int)\n   >>> PI\n   <class 'ctypes.LP_c_long'>\n   >>> PI(42)\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n   TypeError: expected c_long instead of int\n   >>> PI(c_int(42))\n   <ctypes.LP_c_long object at 0x...>\n   >>>\n\nCalling the pointer type without an argument creates a ``NULL`` pointer.\n``NULL`` pointers have a ``False`` boolean value::\n\n   >>> null_ptr = POINTER(c_int)()\n   >>> print(bool(null_ptr))\n   False\n   >>>\n\n:mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but dereferencing\ninvalid non-\\ ``NULL`` pointers would crash Python)::\n\n   >>> null_ptr[0]\n   Traceback (most recent call last):\n       ....\n   ValueError: NULL pointer access\n   >>>\n\n   >>> null_ptr[0] = 1234\n   Traceback (most recent call last):\n       ....\n   ValueError: NULL pointer access\n   >>>\n\n\n.. _ctypes-type-conversions:\n\nType conversions\n^^^^^^^^^^^^^^^^\n\nUsually, ctypes does strict type checking.  This means, if you have\n``POINTER(c_int)`` in the :attr:`argtypes` list of a function or as the type of\na member field in a structure definition, only instances of exactly the same\ntype are accepted.  There are some exceptions to this rule, where ctypes accepts\nother objects.  For example, you can pass compatible array instances instead of\npointer types.  So, for ``POINTER(c_int)``, ctypes accepts an array of c_int::\n\n   >>> class Bar(Structure):\n   ...     _fields_ = [(\"count\", c_int), (\"values\", POINTER(c_int))]\n   ...\n   >>> bar = Bar()\n   >>> bar.values = (c_int * 3)(1, 2, 3)\n   >>> bar.count = 3\n   >>> for i in range(bar.count):\n   ...     print(bar.values[i])\n   ...\n   1\n   2\n   3\n   >>>\n\nIn addition, if a function argument is explicitly declared to be a pointer type\n(such as ``POINTER(c_int)``) in :attr:`argtypes`, an object of the pointed\ntype (``c_int`` in this case) can be passed to the function.  ctypes will apply\nthe required :func:`byref` conversion in this case automatically.\n\nTo set a POINTER type field to ``NULL``, you can assign ``None``::\n\n   >>> bar.values = None\n   >>>\n\n.. XXX list other conversions...\n\nSometimes you have instances of incompatible types.  In C, you can cast one type\ninto another type.  :mod:`ctypes` provides a :func:`cast` function which can be\nused in the same way.  The ``Bar`` structure defined above accepts\n``POINTER(c_int)`` pointers or :class:`c_int` arrays for its ``values`` field,\nbut not instances of other types::\n\n   >>> bar.values = (c_byte * 4)()\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n   TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long instance\n   >>>\n\nFor these cases, the :func:`cast` function is handy.\n\nThe :func:`cast` function can be used to cast a ctypes instance into a pointer\nto a different ctypes data type.  :func:`cast` takes two parameters, a ctypes\nobject that is or can be converted to a pointer of some kind, and a ctypes\npointer type.  It returns an instance of the second argument, which references\nthe same memory block as the first argument::\n\n   >>> a = (c_byte * 4)()\n   >>> cast(a, POINTER(c_int))\n   <ctypes.LP_c_long object at ...>\n   >>>\n\nSo, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` the\nstructure::\n\n   >>> bar = Bar()\n   >>> bar.values = cast((c_byte * 4)(), POINTER(c_int))\n   >>> print(bar.values[0])\n   0\n   >>>\n\n\n.. _ctypes-incomplete-types:\n\nIncomplete Types\n^^^^^^^^^^^^^^^^\n\n*Incomplete Types* are structures, unions or arrays whose members are not yet\nspecified. In C, they are specified by forward declarations, which are defined\nlater::\n\n   struct cell; /* forward declaration */\n\n   struct cell {\n       char *name;\n       struct cell *next;\n   };\n\nThe straightforward translation into ctypes code would be this, but it does not\nwork::\n\n   >>> class cell(Structure):\n   ...     _fields_ = [(\"name\", c_char_p),\n   ...                 (\"next\", POINTER(cell))]\n   ...\n   Traceback (most recent call last):\n     File \"<stdin>\", line 1, in <module>\n     File \"<stdin>\", line 2, in cell\n   NameError: name 'cell' is not defined\n   >>>\n\nbecause the new ``class cell`` is not available in the class statement itself.\nIn :mod:`ctypes`, we can define the ``cell`` class and set the :attr:`_fields_`\nattribute later, after the class statement::\n\n   >>> from ctypes import *\n   >>> class cell(Structure):\n   ...     pass\n   ...\n   >>> cell._fields_ = [(\"name\", c_char_p),\n   ...                  (\"next\", POINTER(cell))]\n   >>>\n\nLet's try it. We create two instances of ``cell``, and let them point to each\nother, and finally follow the pointer chain a few times::\n\n   >>> c1 = cell()\n   >>> c1.name = \"foo\"\n   >>> c2 = cell()\n   >>> c2.name = \"bar\"\n   >>> c1.next = pointer(c2)\n   >>> c2.next = pointer(c1)\n   >>> p = c1\n   >>> for i in range(8):\n   ...     print(p.name, end=\" \")\n   ...     p = p.next[0]\n   ...\n   foo bar foo bar foo bar foo bar\n   >>>\n\n\n.. _ctypes-callback-functions:\n\nCallback functions\n^^^^^^^^^^^^^^^^^^\n\n:mod:`ctypes` allows creating C callable function pointers from Python callables.\nThese are sometimes called *callback functions*.\n\nFirst, you must create a class for the callback function. The class knows the\ncalling convention, the return type, and the number and types of arguments this\nfunction will receive.\n\nThe :func:`CFUNCTYPE` factory function creates types for callback functions\nusing the ``cdecl`` calling convention. On Windows, the :func:`WINFUNCTYPE`\nfactory function creates types for callback functions using the ``stdcall``\ncalling convention.\n\nBoth of these factory functions are called with the result type as first\nargument, and the callback functions expected argument types as the remaining\narguments.\n\nI will present an example here which uses the standard C library's\n:c:func:`qsort` function, that is used to sort items with the help of a callback\nfunction.  :c:func:`qsort` will be used to sort an array of integers::\n\n   >>> IntArray5 = c_int * 5\n   >>> ia = IntArray5(5, 1, 7, 33, 99)\n   >>> qsort = libc.qsort\n   >>> qsort.restype = None\n   >>>\n\n:func:`qsort` must be called with a pointer to the data to sort, the number of\nitems in the data array, the size of one item, and a pointer to the comparison\nfunction, the callback. The callback will then be called with two pointers to\nitems, and it must return a negative integer if the first item is smaller than\nthe second, a zero if they are equal, and a positive integer otherwise.\n\nSo our callback function receives pointers to integers, and must return an\ninteger. First we create the ``type`` for the callback function::\n\n   >>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n   >>>\n\nTo get started, here is a simple callback that shows the values it gets\npassed::\n\n   >>> def py_cmp_func(a, b):\n   ...     print(\"py_cmp_func\", a[0], b[0])\n   ...     return 0\n   ...\n   >>> cmp_func = CMPFUNC(py_cmp_func)\n   >>>\n\nThe result::\n\n   >>> qsort(ia, len(ia), sizeof(c_int), cmp_func)  # doctest: +LINUX\n   py_cmp_func 5 1\n   py_cmp_func 33 99\n   py_cmp_func 7 33\n   py_cmp_func 5 7\n   py_cmp_func 1 7\n   >>>\n\nNow we can actually compare the two items and return a useful result::\n\n   >>> def py_cmp_func(a, b):\n   ...     print(\"py_cmp_func\", a[0], b[0])\n   ...     return a[0] - b[0]\n   ...\n   >>>\n   >>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) # doctest: +LINUX\n   py_cmp_func 5 1\n   py_cmp_func 33 99\n   py_cmp_func 7 33\n   py_cmp_func 1 7\n   py_cmp_func 5 7\n   >>>\n\nAs we can easily check, our array is sorted now::\n\n   >>> for i in ia: print(i, end=\" \")\n   ...\n   1 5 7 33 99\n   >>>\n\nThe function factories can be used as decorator factories, so we may as well\nwrite::\n\n   >>> @CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n   ... def py_cmp_func(a, b):\n   ...     print(\"py_cmp_func\", a[0], b[0])\n   ...     return a[0] - b[0]\n   ...\n   >>> qsort(ia, len(ia), sizeof(c_int), py_cmp_func)\n   py_cmp_func 5 1\n   py_cmp_func 33 99\n   py_cmp_func 7 33\n   py_cmp_func 1 7\n   py_cmp_func 5 7\n   >>>\n\n.. note::\n\n   Make sure you keep references to :func:`CFUNCTYPE` objects as long as they\n   are used from C code. :mod:`ctypes` doesn't, and if you don't, they may be\n   garbage collected, crashing your program when a callback is made.\n\n   Also, note that if the callback function is called in a thread created\n   outside of Python's control (e.g. by the foreign code that calls the\n   callback), ctypes creates a new dummy Python thread on every invocation. This\n   behavior is correct for most purposes, but it means that values stored with\n   :class:`threading.local` will *not* survive across different callbacks, even when\n   those calls are made from the same C thread.\n\n.. _ctypes-accessing-values-exported-from-dlls:\n\nAccessing values exported from dlls\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSome shared libraries not only export functions, they also export variables. An\nexample in the Python library itself is the :c:data:`Py_OptimizeFlag`, an integer\nset to 0, 1, or 2, depending on the :option:`-O` or :option:`-OO` flag given on\nstartup.\n\n:mod:`ctypes` can access values like this with the :meth:`in_dll` class methods of\nthe type.  *pythonapi* is a predefined symbol giving access to the Python C\napi::\n\n   >>> opt_flag = c_int.in_dll(pythonapi, \"Py_OptimizeFlag\")\n   >>> print(opt_flag)\n   c_long(0)\n   >>>\n\nIf the interpreter would have been started with :option:`-O`, the sample would\nhave printed ``c_long(1)``, or ``c_long(2)`` if :option:`-OO` would have been\nspecified.\n\nAn extended example which also demonstrates the use of pointers accesses the\n:c:data:`PyImport_FrozenModules` pointer exported by Python.\n\nQuoting the docs for that value:\n\n   This pointer is initialized to point to an array of :c:type:`struct _frozen`\n   records, terminated by one whose members are all ``NULL`` or zero.  When a frozen\n   module is imported, it is searched in this table.  Third-party code could play\n   tricks with this to provide a dynamically created collection of frozen modules.\n\nSo manipulating this pointer could even prove useful. To restrict the example\nsize, we show only how this table can be read with :mod:`ctypes`::\n\n   >>> from ctypes import *\n   >>>\n   >>> class struct_frozen(Structure):\n   ...     _fields_ = [(\"name\", c_char_p),\n   ...                 (\"code\", POINTER(c_ubyte)),\n   ...                 (\"size\", c_int)]\n   ...\n   >>>\n\nWe have defined the :c:type:`struct _frozen` data type, so we can get the pointer\nto the table::\n\n   >>> FrozenTable = POINTER(struct_frozen)\n   >>> table = FrozenTable.in_dll(pythonapi, \"PyImport_FrozenModules\")\n   >>>\n\nSince ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, we\ncan iterate over it, but we just have to make sure that our loop terminates,\nbecause pointers have no size. Sooner or later it would probably crash with an\naccess violation or whatever, so it's better to break out of the loop when we\nhit the ``NULL`` entry::\n\n   >>> for item in table:\n   ...     if item.name is None:\n   ...         break\n   ...     print(item.name.decode(\"ascii\"), item.size)\n   ...\n   _frozen_importlib 31764\n   _frozen_importlib_external 41499\n   __hello__ 161\n   __phello__ -161\n   __phello__.spam 161\n   >>>\n\nThe fact that standard Python has a frozen module and a frozen package\n(indicated by the negative ``size`` member) is not well known, it is only used\nfor testing. Try it out with ``import __hello__`` for example.\n\n\n.. _ctypes-surprises:\n\nSurprises\n^^^^^^^^^\n\nThere are some edges in :mod:`ctypes` where you might expect something other\nthan what actually happens.\n\nConsider the following example::\n\n   >>> from ctypes import *\n   >>> class POINT(Structure):\n   ...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n   ...\n   >>> class RECT(Structure):\n   ...     _fields_ = (\"a\", POINT), (\"b\", POINT)\n   ...\n   >>> p1 = POINT(1, 2)\n   >>> p2 = POINT(3, 4)\n   >>> rc = RECT(p1, p2)\n   >>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n   1 2 3 4\n   >>> # now swap the two points\n   >>> rc.a, rc.b = rc.b, rc.a\n   >>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n   3 4 3 4\n   >>>\n\nHm. We certainly expected the last statement to print ``3 4 1 2``. What\nhappened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::\n\n   >>> temp0, temp1 = rc.b, rc.a\n   >>> rc.a = temp0\n   >>> rc.b = temp1\n   >>>\n\nNote that ``temp0`` and ``temp1`` are objects still using the internal buffer of\nthe ``rc`` object above. So executing ``rc.a = temp0`` copies the buffer\ncontents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes the\ncontents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't have\nthe expected effect.\n\nKeep in mind that retrieving sub-objects from Structure, Unions, and Arrays\ndoesn't *copy* the sub-object, instead it retrieves a wrapper object accessing\nthe root-object's underlying buffer.\n\nAnother example that may behave differently from what one would expect is this::\n\n   >>> s = c_char_p()\n   >>> s.value = b\"abc def ghi\"\n   >>> s.value\n   b'abc def ghi'\n   >>> s.value is s.value\n   False\n   >>>\n\n.. note::\n\n   Objects instantiated from :class:`c_char_p` can only have their value set to bytes\n   or integers.\n\nWhy is it printing ``False``?  ctypes instances are objects containing a memory\nblock plus some :term:`descriptor`\\s accessing the contents of the memory.\nStoring a Python object in the memory block does not store the object itself,\ninstead the ``contents`` of the object is stored.  Accessing the contents again\nconstructs a new Python object each time!\n\n\n.. _ctypes-variable-sized-data-types:\n\nVariable-sized data types\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\n:mod:`ctypes` provides some support for variable-sized arrays and structures.\n\nThe :func:`resize` function can be used to resize the memory buffer of an\nexisting ctypes object.  The function takes the object as first argument, and\nthe requested size in bytes as the second argument.  The memory block cannot be\nmade smaller than the natural memory block specified by the objects type, a\n:exc:`ValueError` is raised if this is tried::\n\n   >>> short_array = (c_short * 4)()\n   >>> print(sizeof(short_array))\n   8\n   >>> resize(short_array, 4)\n   Traceback (most recent call last):\n       ...\n   ValueError: minimum size is 8\n   >>> resize(short_array, 32)\n   >>> sizeof(short_array)\n   32\n   >>> sizeof(type(short_array))\n   8\n   >>>\n\nThis is nice and fine, but how would one access the additional elements\ncontained in this array?  Since the type still only knows about 4 elements, we\nget errors accessing other elements::\n\n   >>> short_array[:]\n   [0, 0, 0, 0]\n   >>> short_array[7]\n   Traceback (most recent call last):\n       ...\n   IndexError: invalid index\n   >>>\n\nAnother way to use variable-sized data types with :mod:`ctypes` is to use the\ndynamic nature of Python, and (re-)define the data type after the required size\nis already known, on a case by case basis.\n\n\n.. _ctypes-ctypes-reference:\n\nctypes reference\n----------------\n\n\n.. _ctypes-finding-shared-libraries:\n\nFinding shared libraries\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhen programming in a compiled language, shared libraries are accessed when\ncompiling/linking a program, and when the program is run.\n\nThe purpose of the :func:`find_library` function is to locate a library in a way\nsimilar to what the compiler or runtime loader does (on platforms with several\nversions of a shared library the most recent should be loaded), while the ctypes\nlibrary loaders act like when a program is run, and call the runtime loader\ndirectly.\n\nThe :mod:`ctypes.util` module provides a function which can help to determine\nthe library to load.\n\n\n.. data:: find_library(name)\n   :module: ctypes.util\n   :noindex:\n\n   Try to find a library and return a pathname.  *name* is the library name without\n   any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version number (this\n   is the form used for the posix linker option :option:`!-l`).  If no library can\n   be found, returns ``None``.\n\nThe exact functionality is system dependent.\n\nOn Linux, :func:`find_library` tries to run external programs\n(``/sbin/ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library file.\nIt returns the filename of the library file.\n\n.. versionchanged:: 3.6\n   On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is used\n   when searching for libraries, if a library cannot be found by any other means.\n\nHere are some examples::\n\n   >>> from ctypes.util import find_library\n   >>> find_library(\"m\")\n   'libm.so.6'\n   >>> find_library(\"c\")\n   'libc.so.6'\n   >>> find_library(\"bz2\")\n   'libbz2.so.1.0'\n   >>>\n\nOn OS X, :func:`find_library` tries several predefined naming schemes and paths\nto locate the library, and returns a full pathname if successful::\n\n   >>> from ctypes.util import find_library\n   >>> find_library(\"c\")\n   '/usr/lib/libc.dylib'\n   >>> find_library(\"m\")\n   '/usr/lib/libm.dylib'\n   >>> find_library(\"bz2\")\n   '/usr/lib/libbz2.dylib'\n   >>> find_library(\"AGL\")\n   '/System/Library/Frameworks/AGL.framework/AGL'\n   >>>\n\nOn Windows, :func:`find_library` searches along the system search path, and\nreturns the full pathname, but since there is no predefined naming scheme a call\nlike ``find_library(\"c\")`` will fail and return ``None``.\n\nIf wrapping a shared library with :mod:`ctypes`, it *may* be better to determine\nthe shared library name at development time, and hardcode that into the wrapper\nmodule instead of using :func:`find_library` to locate the library at runtime.\n\n\n.. _ctypes-loading-shared-libraries:\n\nLoading shared libraries\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nThere are several ways to load shared libraries into the Python process.  One\nway is to instantiate one of the following classes:\n\n\n.. class:: CDLL(name, mode=DEFAULT_MODE, handle=None, use_errno=False, use_last_error=False, winmode=0)\n\n   Instances of this class represent loaded shared libraries. Functions in these\n   libraries use the standard C calling convention, and are assumed to return\n   :c:type:`int`.\n\n\n.. class:: OleDLL(name, mode=DEFAULT_MODE, handle=None, use_errno=False, use_last_error=False, winmode=0)\n\n   Windows only: Instances of this class represent loaded shared libraries,\n   functions in these libraries use the ``stdcall`` calling convention, and are\n   assumed to return the windows specific :class:`HRESULT` code.  :class:`HRESULT`\n   values contain information specifying whether the function call failed or\n   succeeded, together with additional error code.  If the return value signals a\n   failure, an :class:`OSError` is automatically raised.\n\n   .. versionchanged:: 3.3\n      :exc:`WindowsError` used to be raised.\n\n\n.. class:: WinDLL(name, mode=DEFAULT_MODE, handle=None, use_errno=False, use_last_error=False, winmode=0)\n\n   Windows only: Instances of this class represent loaded shared libraries,\n   functions in these libraries use the ``stdcall`` calling convention, and are\n   assumed to return :c:type:`int` by default.\n\n   On Windows CE only the standard calling convention is used, for convenience the\n   :class:`WinDLL` and :class:`OleDLL` use the standard calling convention on this\n   platform.\n\nThe Python :term:`global interpreter lock` is released before calling any\nfunction exported by these libraries, and reacquired afterwards.\n\n\n.. class:: PyDLL(name, mode=DEFAULT_MODE, handle=None)\n\n   Instances of this class behave like :class:`CDLL` instances, except that the\n   Python GIL is *not* released during the function call, and after the function\n   execution the Python error flag is checked. If the error flag is set, a Python\n   exception is raised.\n\n   Thus, this is only useful to call Python C api functions directly.\n\nAll these classes can be instantiated by calling them with at least one\nargument, the pathname of the shared library.  If you have an existing handle to\nan already loaded shared library, it can be passed as the ``handle`` named\nparameter, otherwise the underlying platforms ``dlopen`` or ``LoadLibrary``\nfunction is used to load the library into the process, and to get a handle to\nit.\n\nThe *mode* parameter can be used to specify how the library is loaded.  For\ndetails, consult the :manpage:`dlopen(3)` manpage.  On Windows, *mode* is\nignored.  On posix systems, RTLD_NOW is always added, and is not\nconfigurable.\n\nThe *use_errno* parameter, when set to true, enables a ctypes mechanism that\nallows accessing the system :data:`errno` error number in a safe way.\n:mod:`ctypes` maintains a thread-local copy of the systems :data:`errno`\nvariable; if you call foreign functions created with ``use_errno=True`` then the\n:data:`errno` value before the function call is swapped with the ctypes private\ncopy, the same happens immediately after the function call.\n\nThe function :func:`ctypes.get_errno` returns the value of the ctypes private\ncopy, and the function :func:`ctypes.set_errno` changes the ctypes private copy\nto a new value and returns the former value.\n\nThe *use_last_error* parameter, when set to true, enables the same mechanism for\nthe Windows error code which is managed by the :func:`GetLastError` and\n:func:`SetLastError` Windows API functions; :func:`ctypes.get_last_error` and\n:func:`ctypes.set_last_error` are used to request and change the ctypes private\ncopy of the windows error code.\n\nThe *winmode* parameter is used on Windows to specify how the library is loaded\n(since *mode* is ignored). It takes any value that is valid for the Win32 API\n``LoadLibraryEx`` flags parameter. When omitted, the default is to use the flags\nthat result in the most secure DLL load to avoiding issues such as DLL\nhijacking. Passing the full path to the DLL is the safest way to ensure the\ncorrect library and dependencies are loaded.\n\n.. versionchanged:: 3.8\n   Added *winmode* parameter.\n\n\n.. data:: RTLD_GLOBAL\n   :noindex:\n\n   Flag to use as *mode* parameter.  On platforms where this flag is not available,\n   it is defined as the integer zero.\n\n\n.. data:: RTLD_LOCAL\n   :noindex:\n\n   Flag to use as *mode* parameter.  On platforms where this is not available, it\n   is the same as *RTLD_GLOBAL*.\n\n\n.. data:: DEFAULT_MODE\n   :noindex:\n\n   The default mode which is used to load shared libraries.  On OSX 10.3, this is\n   *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*.\n\nInstances of these classes have no public methods.  Functions exported by the\nshared library can be accessed as attributes or by index.  Please note that\naccessing the function through an attribute caches the result and therefore\naccessing it repeatedly returns the same object each time.  On the other hand,\naccessing it through an index returns a new object each time::\n\n   >>> from ctypes import CDLL\n   >>> libc = CDLL(\"libc.so.6\")  # On Linux\n   >>> libc.time == libc.time\n   True\n   >>> libc['time'] == libc['time']\n   False\n\nThe following public attributes are available, their name starts with an\nunderscore to not clash with exported function names:\n\n\n.. attribute:: PyDLL._handle\n\n   The system handle used to access the library.\n\n\n.. attribute:: PyDLL._name\n\n   The name of the library passed in the constructor.\n\nShared libraries can also be loaded by using one of the prefabricated objects,\nwhich are instances of the :class:`LibraryLoader` class, either by calling the\n:meth:`LoadLibrary` method, or by retrieving the library as attribute of the\nloader instance.\n\n\n.. class:: LibraryLoader(dlltype)\n\n   Class which loads shared libraries.  *dlltype* should be one of the\n   :class:`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types.\n\n   :meth:`__getattr__` has special behavior: It allows loading a shared library by\n   accessing it as attribute of a library loader instance.  The result is cached,\n   so repeated attribute accesses return the same library each time.\n\n   .. method:: LoadLibrary(name)\n\n      Load a shared library into the process and return it.  This method always\n      returns a new instance of the library.\n\n\nThese prefabricated library loaders are available:\n\n.. data:: cdll\n   :noindex:\n\n   Creates :class:`CDLL` instances.\n\n\n.. data:: windll\n   :noindex:\n\n   Windows only: Creates :class:`WinDLL` instances.\n\n\n.. data:: oledll\n   :noindex:\n\n   Windows only: Creates :class:`OleDLL` instances.\n\n\n.. data:: pydll\n   :noindex:\n\n   Creates :class:`PyDLL` instances.\n\n\nFor accessing the C Python api directly, a ready-to-use Python shared library\nobject is available:\n\n.. data:: pythonapi\n   :noindex:\n\n   An instance of :class:`PyDLL` that exposes Python C API functions as\n   attributes.  Note that all these functions are assumed to return C\n   :c:type:`int`, which is of course not always the truth, so you have to assign\n   the correct :attr:`restype` attribute to use these functions.\n\n.. audit-event:: ctypes.dlopen name ctypes.LibraryLoader\n\n   Loading a library through any of these objects raises an\n   :ref:`auditing event <auditing>` ``ctypes.dlopen`` with string argument\n   ``name``, the name used to load the library.\n\n.. audit-event:: ctypes.dlsym library,name ctypes.LibraryLoader\n\n   Accessing a function on a loaded library raises an auditing event\n   ``ctypes.dlsym`` with arguments ``library`` (the library object) and ``name``\n   (the symbol's name as a string or integer).\n\n.. audit-event:: ctypes.dlsym/handle handle,name ctypes.LibraryLoader\n\n   In cases when only the library handle is available rather than the object,\n   accessing a function raises an auditing event ``ctypes.dlsym/handle`` with\n   arguments ``handle`` (the raw library handle) and ``name``.\n\n.. _ctypes-foreign-functions:\n\nForeign functions\n^^^^^^^^^^^^^^^^^\n\nAs explained in the previous section, foreign functions can be accessed as\nattributes of loaded shared libraries.  The function objects created in this way\nby default accept any number of arguments, accept any ctypes data instances as\narguments, and return the default result type specified by the library loader.\nThey are instances of a private class:\n\n\n.. class:: _FuncPtr\n\n   Base class for C callable foreign functions.\n\n   Instances of foreign functions are also C compatible data types; they\n   represent C function pointers.\n\n   This behavior can be customized by assigning to special attributes of the\n   foreign function object.\n\n   .. attribute:: restype\n\n      Assign a ctypes type to specify the result type of the foreign function.\n      Use ``None`` for :c:type:`void`, a function not returning anything.\n\n      It is possible to assign a callable Python object that is not a ctypes\n      type, in this case the function is assumed to return a C :c:type:`int`, and\n      the callable will be called with this integer, allowing further\n      processing or error checking.  Using this is deprecated, for more flexible\n      post processing or error checking use a ctypes data type as\n      :attr:`restype` and assign a callable to the :attr:`errcheck` attribute.\n\n   .. attribute:: argtypes\n\n      Assign a tuple of ctypes types to specify the argument types that the\n      function accepts.  Functions using the ``stdcall`` calling convention can\n      only be called with the same number of arguments as the length of this\n      tuple; functions using the C calling convention accept additional,\n      unspecified arguments as well.\n\n      When a foreign function is called, each actual argument is passed to the\n      :meth:`from_param` class method of the items in the :attr:`argtypes`\n      tuple, this method allows adapting the actual argument to an object that\n      the foreign function accepts.  For example, a :class:`c_char_p` item in\n      the :attr:`argtypes` tuple will convert a string passed as argument into\n      a bytes object using ctypes conversion rules.\n\n      New: It is now possible to put items in argtypes which are not ctypes\n      types, but each item must have a :meth:`from_param` method which returns a\n      value usable as argument (integer, string, ctypes instance).  This allows\n      defining adapters that can adapt custom objects as function parameters.\n\n   .. attribute:: errcheck\n\n      Assign a Python function or another callable to this attribute. The\n      callable will be called with three or more arguments:\n\n      .. function:: callable(result, func, arguments)\n         :noindex:\n         :module:\n\n         *result* is what the foreign function returns, as specified by the\n         :attr:`restype` attribute.\n\n         *func* is the foreign function object itself, this allows reusing the\n         same callable object to check or post process the results of several\n         functions.\n\n         *arguments* is a tuple containing the parameters originally passed to\n         the function call, this allows specializing the behavior on the\n         arguments used.\n\n      The object that this function returns will be returned from the\n      foreign function call, but it can also check the result value\n      and raise an exception if the foreign function call failed.\n\n\n.. exception:: ArgumentError\n\n   This exception is raised when a foreign function call cannot convert one of the\n   passed arguments.\n\n\n.. audit-event:: ctypes.seh_exception code foreign-functions\n\n   On Windows, when a foreign function call raises a system exception (for\n   example, due to an access violation), it will be captured and replaced with\n   a suitable Python exception. Further, an auditing event\n   ``ctypes.seh_exception`` with argument ``code`` will be raised, allowing an\n   audit hook to replace the exception with its own.\n\n.. audit-event:: ctypes.call_function func_pointer,arguments ctype-foreign-functions\n\n   Some ways to invoke foreign function calls may raise an auditing event\n   ``ctypes.call_function`` with arguments ``function pointer`` and ``arguments``.\n\n.. _ctypes-function-prototypes:\n\nFunction prototypes\n^^^^^^^^^^^^^^^^^^^\n\nForeign functions can also be created by instantiating function prototypes.\nFunction prototypes are similar to function prototypes in C; they describe a\nfunction (return type, argument types, calling convention) without defining an\nimplementation.  The factory functions must be called with the desired result\ntype and the argument types of the function, and can be used as decorator\nfactories, and as such, be applied to functions through the ``@wrapper`` syntax.\nSee :ref:`ctypes-callback-functions` for examples.\n\n\n.. function:: CFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)\n\n   The returned function prototype creates functions that use the standard C\n   calling convention.  The function will release the GIL during the call.  If\n   *use_errno* is set to true, the ctypes private copy of the system\n   :data:`errno` variable is exchanged with the real :data:`errno` value before\n   and after the call; *use_last_error* does the same for the Windows error\n   code.\n\n\n.. function:: WINFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)\n\n   Windows only: The returned function prototype creates functions that use the\n   ``stdcall`` calling convention, except on Windows CE where\n   :func:`WINFUNCTYPE` is the same as :func:`CFUNCTYPE`.  The function will\n   release the GIL during the call.  *use_errno* and *use_last_error* have the\n   same meaning as above.\n\n\n.. function:: PYFUNCTYPE(restype, *argtypes)\n\n   The returned function prototype creates functions that use the Python calling\n   convention.  The function will *not* release the GIL during the call.\n\nFunction prototypes created by these factory functions can be instantiated in\ndifferent ways, depending on the type and number of the parameters in the call:\n\n\n   .. function:: prototype(address)\n      :noindex:\n      :module:\n\n      Returns a foreign function at the specified address which must be an integer.\n\n\n   .. function:: prototype(callable)\n      :noindex:\n      :module:\n\n      Create a C callable function (a callback function) from a Python *callable*.\n\n\n   .. function:: prototype(func_spec[, paramflags])\n      :noindex:\n      :module:\n\n      Returns a foreign function exported by a shared library. *func_spec* must\n      be a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of\n      the exported function as string, or the ordinal of the exported function\n      as small integer.  The second item is the shared library instance.\n\n\n   .. function:: prototype(vtbl_index, name[, paramflags[, iid]])\n      :noindex:\n      :module:\n\n      Returns a foreign function that will call a COM method. *vtbl_index* is\n      the index into the virtual function table, a small non-negative\n      integer. *name* is name of the COM method. *iid* is an optional pointer to\n      the interface identifier which is used in extended error reporting.\n\n      COM methods use a special calling convention: They require a pointer to\n      the COM interface as first argument, in addition to those parameters that\n      are specified in the :attr:`argtypes` tuple.\n\n   The optional *paramflags* parameter creates foreign function wrappers with much\n   more functionality than the features described above.\n\n   *paramflags* must be a tuple of the same length as :attr:`argtypes`.\n\n   Each item in this tuple contains further information about a parameter, it must\n   be a tuple containing one, two, or three items.\n\n   The first item is an integer containing a combination of direction\n   flags for the parameter:\n\n      1\n         Specifies an input parameter to the function.\n\n      2\n         Output parameter.  The foreign function fills in a value.\n\n      4\n         Input parameter which defaults to the integer zero.\n\n   The optional second item is the parameter name as string.  If this is specified,\n   the foreign function can be called with named parameters.\n\n   The optional third item is the default value for this parameter.\n\nThis example demonstrates how to wrap the Windows ``MessageBoxW`` function so\nthat it supports default parameters and named arguments. The C declaration from\nthe windows header file is this::\n\n   WINUSERAPI int WINAPI\n   MessageBoxW(\n       HWND hWnd,\n       LPCWSTR lpText,\n       LPCWSTR lpCaption,\n       UINT uType);\n\nHere is the wrapping with :mod:`ctypes`::\n\n   >>> from ctypes import c_int, WINFUNCTYPE, windll\n   >>> from ctypes.wintypes import HWND, LPCWSTR, UINT\n   >>> prototype = WINFUNCTYPE(c_int, HWND, LPCWSTR, LPCWSTR, UINT)\n   >>> paramflags = (1, \"hwnd\", 0), (1, \"text\", \"Hi\"), (1, \"caption\", \"Hello from ctypes\"), (1, \"flags\", 0)\n   >>> MessageBox = prototype((\"MessageBoxW\", windll.user32), paramflags)\n\nThe ``MessageBox`` foreign function can now be called in these ways::\n\n   >>> MessageBox()\n   >>> MessageBox(text=\"Spam, spam, spam\")\n   >>> MessageBox(flags=2, text=\"foo bar\")\n\nA second example demonstrates output parameters.  The win32 ``GetWindowRect``\nfunction retrieves the dimensions of a specified window by copying them into\n``RECT`` structure that the caller has to supply.  Here is the C declaration::\n\n   WINUSERAPI BOOL WINAPI\n   GetWindowRect(\n        HWND hWnd,\n        LPRECT lpRect);\n\nHere is the wrapping with :mod:`ctypes`::\n\n   >>> from ctypes import POINTER, WINFUNCTYPE, windll, WinError\n   >>> from ctypes.wintypes import BOOL, HWND, RECT\n   >>> prototype = WINFUNCTYPE(BOOL, HWND, POINTER(RECT))\n   >>> paramflags = (1, \"hwnd\"), (2, \"lprect\")\n   >>> GetWindowRect = prototype((\"GetWindowRect\", windll.user32), paramflags)\n   >>>\n\nFunctions with output parameters will automatically return the output parameter\nvalue if there is a single one, or a tuple containing the output parameter\nvalues when there are more than one, so the GetWindowRect function now returns a\nRECT instance, when called.\n\nOutput parameters can be combined with the :attr:`errcheck` protocol to do\nfurther output processing and error checking.  The win32 ``GetWindowRect`` api\nfunction returns a ``BOOL`` to signal success or failure, so this function could\ndo the error checking, and raises an exception when the api call failed::\n\n   >>> def errcheck(result, func, args):\n   ...     if not result:\n   ...         raise WinError()\n   ...     return args\n   ...\n   >>> GetWindowRect.errcheck = errcheck\n   >>>\n\nIf the :attr:`errcheck` function returns the argument tuple it receives\nunchanged, :mod:`ctypes` continues the normal processing it does on the output\nparameters.  If you want to return a tuple of window coordinates instead of a\n``RECT`` instance, you can retrieve the fields in the function and return them\ninstead, the normal processing will no longer take place::\n\n   >>> def errcheck(result, func, args):\n   ...     if not result:\n   ...         raise WinError()\n   ...     rc = args[1]\n   ...     return rc.left, rc.top, rc.bottom, rc.right\n   ...\n   >>> GetWindowRect.errcheck = errcheck\n   >>>\n\n\n.. _ctypes-utility-functions:\n\nUtility functions\n^^^^^^^^^^^^^^^^^\n\n.. function:: addressof(obj)\n\n   Returns the address of the memory buffer as integer.  *obj* must be an\n   instance of a ctypes type.\n\n   .. audit-event:: ctypes.addressof obj ctypes.addressof\n\n\n.. function:: alignment(obj_or_type)\n\n   Returns the alignment requirements of a ctypes type. *obj_or_type* must be a\n   ctypes type or instance.\n\n\n.. function:: byref(obj[, offset])\n\n   Returns a light-weight pointer to *obj*, which must be an instance of a\n   ctypes type.  *offset* defaults to zero, and must be an integer that will be\n   added to the internal pointer value.\n\n   ``byref(obj, offset)`` corresponds to this C code::\n\n      (((char *)&obj) + offset)\n\n   The returned object can only be used as a foreign function call parameter.\n   It behaves similar to ``pointer(obj)``, but the construction is a lot faster.\n\n\n.. function:: cast(obj, type)\n\n   This function is similar to the cast operator in C. It returns a new instance\n   of *type* which points to the same memory block as *obj*.  *type* must be a\n   pointer type, and *obj* must be an object that can be interpreted as a\n   pointer.\n\n\n.. function:: create_string_buffer(init_or_size, size=None)\n\n   This function creates a mutable character buffer. The returned object is a\n   ctypes array of :class:`c_char`.\n\n   *init_or_size* must be an integer which specifies the size of the array, or a\n   bytes object which will be used to initialize the array items.\n\n   If a bytes object is specified as first argument, the buffer is made one item\n   larger than its length so that the last element in the array is a NUL\n   termination character. An integer can be passed as second argument which allows\n   specifying the size of the array if the length of the bytes should not be used.\n\n   .. audit-event:: ctypes.create_string_buffer init,size ctypes.create_string_buffer\n\n\n.. function:: create_unicode_buffer(init_or_size, size=None)\n\n   This function creates a mutable unicode character buffer. The returned object is\n   a ctypes array of :class:`c_wchar`.\n\n   *init_or_size* must be an integer which specifies the size of the array, or a\n   string which will be used to initialize the array items.\n\n   If a string is specified as first argument, the buffer is made one item\n   larger than the length of the string so that the last element in the array is a\n   NUL termination character. An integer can be passed as second argument which\n   allows specifying the size of the array if the length of the string should not\n   be used.\n\n   .. audit-event:: ctypes.create_unicode_buffer init,size ctypes.create_unicode_buffer\n\n\n.. function:: DllCanUnloadNow()\n\n   Windows only: This function is a hook which allows implementing in-process\n   COM servers with ctypes.  It is called from the DllCanUnloadNow function that\n   the _ctypes extension dll exports.\n\n\n.. function:: DllGetClassObject()\n\n   Windows only: This function is a hook which allows implementing in-process\n   COM servers with ctypes.  It is called from the DllGetClassObject function\n   that the ``_ctypes`` extension dll exports.\n\n\n.. function:: find_library(name)\n   :module: ctypes.util\n\n   Try to find a library and return a pathname.  *name* is the library name\n   without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version\n   number (this is the form used for the posix linker option :option:`!-l`).  If\n   no library can be found, returns ``None``.\n\n   The exact functionality is system dependent.\n\n\n.. function:: find_msvcrt()\n   :module: ctypes.util\n\n   Windows only: return the filename of the VC runtime library used by Python,\n   and by the extension modules.  If the name of the library cannot be\n   determined, ``None`` is returned.\n\n   If you need to free memory, for example, allocated by an extension module\n   with a call to the ``free(void *)``, it is important that you use the\n   function in the same library that allocated the memory.\n\n\n.. function:: FormatError([code])\n\n   Windows only: Returns a textual description of the error code *code*.  If no\n   error code is specified, the last error code is used by calling the Windows\n   api function GetLastError.\n\n\n.. function:: GetLastError()\n\n   Windows only: Returns the last error code set by Windows in the calling thread.\n   This function calls the Windows `GetLastError()` function directly,\n   it does not return the ctypes-private copy of the error code.\n\n.. function:: get_errno()\n\n   Returns the current value of the ctypes-private copy of the system\n   :data:`errno` variable in the calling thread.\n\n   .. audit-event:: ctypes.get_errno \"\" ctypes.get_errno\n\n.. function:: get_last_error()\n\n   Windows only: returns the current value of the ctypes-private copy of the system\n   :data:`LastError` variable in the calling thread.\n\n   .. audit-event:: ctypes.get_last_error \"\" ctypes.get_last_error\n\n.. function:: memmove(dst, src, count)\n\n   Same as the standard C memmove library function: copies *count* bytes from\n   *src* to *dst*. *dst* and *src* must be integers or ctypes instances that can\n   be converted to pointers.\n\n\n.. function:: memset(dst, c, count)\n\n   Same as the standard C memset library function: fills the memory block at\n   address *dst* with *count* bytes of value *c*. *dst* must be an integer\n   specifying an address, or a ctypes instance.\n\n\n.. function:: POINTER(type)\n\n   This factory function creates and returns a new ctypes pointer type. Pointer\n   types are cached and reused internally, so calling this function repeatedly is\n   cheap. *type* must be a ctypes type.\n\n\n.. function:: pointer(obj)\n\n   This function creates a new pointer instance, pointing to *obj*. The returned\n   object is of the type ``POINTER(type(obj))``.\n\n   Note: If you just want to pass a pointer to an object to a foreign function\n   call, you should use ``byref(obj)`` which is much faster.\n\n\n.. function:: resize(obj, size)\n\n   This function resizes the internal memory buffer of *obj*, which must be an\n   instance of a ctypes type.  It is not possible to make the buffer smaller\n   than the native size of the objects type, as given by ``sizeof(type(obj))``,\n   but it is possible to enlarge the buffer.\n\n\n.. function:: set_errno(value)\n\n   Set the current value of the ctypes-private copy of the system :data:`errno`\n   variable in the calling thread to *value* and return the previous value.\n\n   .. audit-event:: ctypes.set_errno errno ctypes.set_errno\n\n\n.. function:: set_last_error(value)\n\n   Windows only: set the current value of the ctypes-private copy of the system\n   :data:`LastError` variable in the calling thread to *value* and return the\n   previous value.\n\n   .. audit-event:: ctypes.set_last_error error ctypes.set_last_error\n\n\n.. function:: sizeof(obj_or_type)\n\n   Returns the size in bytes of a ctypes type or instance memory buffer.\n   Does the same as the C ``sizeof`` operator.\n\n\n.. function:: string_at(address, size=-1)\n\n   This function returns the C string starting at memory address *address* as a bytes\n   object. If size is specified, it is used as size, otherwise the string is assumed\n   to be zero-terminated.\n\n   .. audit-event:: ctypes.string_at address,size ctypes.string_at\n\n\n.. function:: WinError(code=None, descr=None)\n\n   Windows only: this function is probably the worst-named thing in ctypes. It\n   creates an instance of OSError.  If *code* is not specified,\n   ``GetLastError`` is called to determine the error code. If *descr* is not\n   specified, :func:`FormatError` is called to get a textual description of the\n   error.\n\n   .. versionchanged:: 3.3\n      An instance of :exc:`WindowsError` used to be created.\n\n\n.. function:: wstring_at(address, size=-1)\n\n   This function returns the wide character string starting at memory address\n   *address* as a string.  If *size* is specified, it is used as the number of\n   characters of the string, otherwise the string is assumed to be\n   zero-terminated.\n\n   .. audit-event:: ctypes.wstring_at address,size ctypes.wstring_at\n\n\n.. _ctypes-data-types:\n\nData types\n^^^^^^^^^^\n\n\n.. class:: _CData\n\n   This non-public class is the common base class of all ctypes data types.\n   Among other things, all ctypes type instances contain a memory block that\n   hold C compatible data; the address of the memory block is returned by the\n   :func:`addressof` helper function. Another instance variable is exposed as\n   :attr:`_objects`; this contains other Python objects that need to be kept\n   alive in case the memory block contains pointers.\n\n   Common methods of ctypes data types, these are all class methods (to be\n   exact, they are methods of the :term:`metaclass`):\n\n   .. method:: _CData.from_buffer(source[, offset])\n\n      This method returns a ctypes instance that shares the buffer of the\n      *source* object.  The *source* object must support the writeable buffer\n      interface.  The optional *offset* parameter specifies an offset into the\n      source buffer in bytes; the default is zero.  If the source buffer is not\n      large enough a :exc:`ValueError` is raised.\n\n      .. audit-event:: ctypes.cdata/buffer pointer,size,offset ctypes._CData.from_buffer\n\n   .. method:: _CData.from_buffer_copy(source[, offset])\n\n      This method creates a ctypes instance, copying the buffer from the\n      *source* object buffer which must be readable.  The optional *offset*\n      parameter specifies an offset into the source buffer in bytes; the default\n      is zero.  If the source buffer is not large enough a :exc:`ValueError` is\n      raised.\n\n      .. audit-event:: ctypes.cdata/buffer pointer,size,offset ctypes._CData.from_buffer_copy\n\n   .. method:: from_address(address)\n\n      This method returns a ctypes type instance using the memory specified by\n      *address* which must be an integer.\n\n      .. audit-event:: ctypes.cdata address ctypes._CData.from_address\n\n         This method, and others that indirectly call this method, raises an\n         :ref:`auditing event <auditing>` ``ctypes.cdata`` with argument\n         ``address``.\n\n   .. method:: from_param(obj)\n\n      This method adapts *obj* to a ctypes type.  It is called with the actual\n      object used in a foreign function call when the type is present in the\n      foreign function's :attr:`argtypes` tuple; it must return an object that\n      can be used as a function call parameter.\n\n      All ctypes data types have a default implementation of this classmethod\n      that normally returns *obj* if that is an instance of the type.  Some\n      types accept other objects as well.\n\n   .. method:: in_dll(library, name)\n\n      This method returns a ctypes type instance exported by a shared\n      library. *name* is the name of the symbol that exports the data, *library*\n      is the loaded shared library.\n\n   Common instance variables of ctypes data types:\n\n   .. attribute:: _b_base_\n\n      Sometimes ctypes data instances do not own the memory block they contain,\n      instead they share part of the memory block of a base object.  The\n      :attr:`_b_base_` read-only member is the root ctypes object that owns the\n      memory block.\n\n   .. attribute:: _b_needsfree_\n\n      This read-only variable is true when the ctypes data instance has\n      allocated the memory block itself, false otherwise.\n\n   .. attribute:: _objects\n\n      This member is either ``None`` or a dictionary containing Python objects\n      that need to be kept alive so that the memory block contents is kept\n      valid.  This object is only exposed for debugging; never modify the\n      contents of this dictionary.\n\n\n.. _ctypes-fundamental-data-types-2:\n\nFundamental data types\n^^^^^^^^^^^^^^^^^^^^^^\n\n.. class:: _SimpleCData\n\n   This non-public class is the base class of all fundamental ctypes data\n   types. It is mentioned here because it contains the common attributes of the\n   fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of\n   :class:`_CData`, so it inherits their methods and attributes. ctypes data\n   types that are not and do not contain pointers can now be pickled.\n\n   Instances have a single attribute:\n\n   .. attribute:: value\n\n      This attribute contains the actual value of the instance. For integer and\n      pointer types, it is an integer, for character types, it is a single\n      character bytes object or string, for character pointer types it is a\n      Python bytes object or string.\n\n      When the ``value`` attribute is retrieved from a ctypes instance, usually\n      a new object is returned each time.  :mod:`ctypes` does *not* implement\n      original object return, always a new object is constructed.  The same is\n      true for all other ctypes object instances.\n\n\nFundamental data types, when returned as foreign function call results, or, for\nexample, by retrieving structure field members or array items, are transparently\nconverted to native Python types.  In other words, if a foreign function has a\n:attr:`restype` of :class:`c_char_p`, you will always receive a Python bytes\nobject, *not* a :class:`c_char_p` instance.\n\n.. XXX above is false, it actually returns a Unicode string\n\nSubclasses of fundamental data types do *not* inherit this behavior. So, if a\nforeign functions :attr:`restype` is a subclass of :class:`c_void_p`, you will\nreceive an instance of this subclass from the function call. Of course, you can\nget the value of the pointer by accessing the ``value`` attribute.\n\nThese are the fundamental ctypes data types:\n\n.. class:: c_byte\n\n   Represents the C :c:type:`signed char` datatype, and interprets the value as\n   small integer.  The constructor accepts an optional integer initializer; no\n   overflow checking is done.\n\n\n.. class:: c_char\n\n   Represents the C :c:type:`char` datatype, and interprets the value as a single\n   character.  The constructor accepts an optional string initializer, the\n   length of the string must be exactly one character.\n\n\n.. class:: c_char_p\n\n   Represents the C :c:type:`char *` datatype when it points to a zero-terminated\n   string.  For a general character pointer that may also point to binary data,\n   ``POINTER(c_char)`` must be used.  The constructor accepts an integer\n   address, or a bytes object.\n\n\n.. class:: c_double\n\n   Represents the C :c:type:`double` datatype.  The constructor accepts an\n   optional float initializer.\n\n\n.. class:: c_longdouble\n\n   Represents the C :c:type:`long double` datatype.  The constructor accepts an\n   optional float initializer.  On platforms where ``sizeof(long double) ==\n   sizeof(double)`` it is an alias to :class:`c_double`.\n\n.. class:: c_float\n\n   Represents the C :c:type:`float` datatype.  The constructor accepts an\n   optional float initializer.\n\n\n.. class:: c_int\n\n   Represents the C :c:type:`signed int` datatype.  The constructor accepts an\n   optional integer initializer; no overflow checking is done.  On platforms\n   where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`.\n\n\n.. class:: c_int8\n\n   Represents the C 8-bit :c:type:`signed int` datatype.  Usually an alias for\n   :class:`c_byte`.\n\n\n.. class:: c_int16\n\n   Represents the C 16-bit :c:type:`signed int` datatype.  Usually an alias for\n   :class:`c_short`.\n\n\n.. class:: c_int32\n\n   Represents the C 32-bit :c:type:`signed int` datatype.  Usually an alias for\n   :class:`c_int`.\n\n\n.. class:: c_int64\n\n   Represents the C 64-bit :c:type:`signed int` datatype.  Usually an alias for\n   :class:`c_longlong`.\n\n\n.. class:: c_long\n\n   Represents the C :c:type:`signed long` datatype.  The constructor accepts an\n   optional integer initializer; no overflow checking is done.\n\n\n.. class:: c_longlong\n\n   Represents the C :c:type:`signed long long` datatype.  The constructor accepts\n   an optional integer initializer; no overflow checking is done.\n\n\n.. class:: c_short\n\n   Represents the C :c:type:`signed short` datatype.  The constructor accepts an\n   optional integer initializer; no overflow checking is done.\n\n\n.. class:: c_size_t\n\n   Represents the C :c:type:`size_t` datatype.\n\n\n.. class:: c_ssize_t\n\n   Represents the C :c:type:`ssize_t` datatype.\n\n   .. versionadded:: 3.2\n\n\n.. class:: c_ubyte\n\n   Represents the C :c:type:`unsigned char` datatype, it interprets the value as\n   small integer.  The constructor accepts an optional integer initializer; no\n   overflow checking is done.\n\n\n.. class:: c_uint\n\n   Represents the C :c:type:`unsigned int` datatype.  The constructor accepts an\n   optional integer initializer; no overflow checking is done.  On platforms\n   where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`.\n\n\n.. class:: c_uint8\n\n   Represents the C 8-bit :c:type:`unsigned int` datatype.  Usually an alias for\n   :class:`c_ubyte`.\n\n\n.. class:: c_uint16\n\n   Represents the C 16-bit :c:type:`unsigned int` datatype.  Usually an alias for\n   :class:`c_ushort`.\n\n\n.. class:: c_uint32\n\n   Represents the C 32-bit :c:type:`unsigned int` datatype.  Usually an alias for\n   :class:`c_uint`.\n\n\n.. class:: c_uint64\n\n   Represents the C 64-bit :c:type:`unsigned int` datatype.  Usually an alias for\n   :class:`c_ulonglong`.\n\n\n.. class:: c_ulong\n\n   Represents the C :c:type:`unsigned long` datatype.  The constructor accepts an\n   optional integer initializer; no overflow checking is done.\n\n\n.. class:: c_ulonglong\n\n   Represents the C :c:type:`unsigned long long` datatype.  The constructor\n   accepts an optional integer initializer; no overflow checking is done.\n\n\n.. class:: c_ushort\n\n   Represents the C :c:type:`unsigned short` datatype.  The constructor accepts\n   an optional integer initializer; no overflow checking is done.\n\n\n.. class:: c_void_p\n\n   Represents the C :c:type:`void *` type.  The value is represented as integer.\n   The constructor accepts an optional integer initializer.\n\n\n.. class:: c_wchar\n\n   Represents the C :c:type:`wchar_t` datatype, and interprets the value as a\n   single character unicode string.  The constructor accepts an optional string\n   initializer, the length of the string must be exactly one character.\n\n\n.. class:: c_wchar_p\n\n   Represents the C :c:type:`wchar_t *` datatype, which must be a pointer to a\n   zero-terminated wide character string.  The constructor accepts an integer\n   address, or a string.\n\n\n.. class:: c_bool\n\n   Represent the C :c:type:`bool` datatype (more accurately, :c:type:`_Bool` from\n   C99).  Its value can be ``True`` or ``False``, and the constructor accepts any object\n   that has a truth value.\n\n\n.. class:: HRESULT\n\n   Windows only: Represents a :c:type:`HRESULT` value, which contains success or\n   error information for a function or method call.\n\n\n.. class:: py_object\n\n   Represents the C :c:type:`PyObject *` datatype.  Calling this without an\n   argument creates a ``NULL`` :c:type:`PyObject *` pointer.\n\nThe :mod:`ctypes.wintypes` module provides quite some other Windows specific\ndata types, for example :c:type:`HWND`, :c:type:`WPARAM`, or :c:type:`DWORD`.  Some\nuseful structures like :c:type:`MSG` or :c:type:`RECT` are also defined.\n\n\n.. _ctypes-structured-data-types:\n\nStructured data types\n^^^^^^^^^^^^^^^^^^^^^\n\n\n.. class:: Union(*args, **kw)\n\n   Abstract base class for unions in native byte order.\n\n\n.. class:: BigEndianStructure(*args, **kw)\n\n   Abstract base class for structures in *big endian* byte order.\n\n\n.. class:: LittleEndianStructure(*args, **kw)\n\n   Abstract base class for structures in *little endian* byte order.\n\nStructures with non-native byte order cannot contain pointer type fields, or any\nother data types containing pointer type fields.\n\n\n.. class:: Structure(*args, **kw)\n\n   Abstract base class for structures in *native* byte order.\n\n   Concrete structure and union types must be created by subclassing one of these\n   types, and at least define a :attr:`_fields_` class variable. :mod:`ctypes` will\n   create :term:`descriptor`\\s which allow reading and writing the fields by direct\n   attribute accesses.  These are the\n\n\n   .. attribute:: _fields_\n\n      A sequence defining the structure fields.  The items must be 2-tuples or\n      3-tuples.  The first item is the name of the field, the second item\n      specifies the type of the field; it can be any ctypes data type.\n\n      For integer type fields like :class:`c_int`, a third optional item can be\n      given.  It must be a small positive integer defining the bit width of the\n      field.\n\n      Field names must be unique within one structure or union.  This is not\n      checked, only one field can be accessed when names are repeated.\n\n      It is possible to define the :attr:`_fields_` class variable *after* the\n      class statement that defines the Structure subclass, this allows creating\n      data types that directly or indirectly reference themselves::\n\n         class List(Structure):\n             pass\n         List._fields_ = [(\"pnext\", POINTER(List)),\n                          ...\n                         ]\n\n      The :attr:`_fields_` class variable must, however, be defined before the\n      type is first used (an instance is created, :func:`sizeof` is called on it,\n      and so on).  Later assignments to the :attr:`_fields_` class variable will\n      raise an AttributeError.\n\n      It is possible to define sub-subclasses of structure types, they inherit\n      the fields of the base class plus the :attr:`_fields_` defined in the\n      sub-subclass, if any.\n\n\n   .. attribute:: _pack_\n\n      An optional small integer that allows overriding the alignment of\n      structure fields in the instance.  :attr:`_pack_` must already be defined\n      when :attr:`_fields_` is assigned, otherwise it will have no effect.\n\n\n   .. attribute:: _anonymous_\n\n      An optional sequence that lists the names of unnamed (anonymous) fields.\n      :attr:`_anonymous_` must be already defined when :attr:`_fields_` is\n      assigned, otherwise it will have no effect.\n\n      The fields listed in this variable must be structure or union type fields.\n      :mod:`ctypes` will create descriptors in the structure type that allows\n      accessing the nested fields directly, without the need to create the\n      structure or union field.\n\n      Here is an example type (Windows)::\n\n         class _U(Union):\n             _fields_ = [(\"lptdesc\", POINTER(TYPEDESC)),\n                         (\"lpadesc\", POINTER(ARRAYDESC)),\n                         (\"hreftype\", HREFTYPE)]\n\n         class TYPEDESC(Structure):\n             _anonymous_ = (\"u\",)\n             _fields_ = [(\"u\", _U),\n                         (\"vt\", VARTYPE)]\n\n\n      The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field\n      specifies which one of the union fields is valid.  Since the ``u`` field\n      is defined as anonymous field, it is now possible to access the members\n      directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc``\n      are equivalent, but the former is faster since it does not need to create\n      a temporary union instance::\n\n         td = TYPEDESC()\n         td.vt = VT_PTR\n         td.lptdesc = POINTER(some_type)\n         td.u.lptdesc = POINTER(some_type)\n\n   It is possible to define sub-subclasses of structures, they inherit the\n   fields of the base class.  If the subclass definition has a separate\n   :attr:`_fields_` variable, the fields specified in this are appended to the\n   fields of the base class.\n\n   Structure and union constructors accept both positional and keyword\n   arguments.  Positional arguments are used to initialize member fields in the\n   same order as they are appear in :attr:`_fields_`.  Keyword arguments in the\n   constructor are interpreted as attribute assignments, so they will initialize\n   :attr:`_fields_` with the same name, or create new attributes for names not\n   present in :attr:`_fields_`.\n\n\n.. _ctypes-arrays-pointers:\n\nArrays and pointers\n^^^^^^^^^^^^^^^^^^^\n\n.. class:: Array(\\*args)\n\n   Abstract base class for arrays.\n\n   The recommended way to create concrete array types is by multiplying any\n   :mod:`ctypes` data type with a positive integer.  Alternatively, you can subclass\n   this type and define :attr:`_length_` and :attr:`_type_` class variables.\n   Array elements can be read and written using standard\n   subscript and slice accesses; for slice reads, the resulting object is\n   *not* itself an :class:`Array`.\n\n\n   .. attribute:: _length_\n\n        A positive integer specifying the number of elements in the array.\n        Out-of-range subscripts result in an :exc:`IndexError`. Will be\n        returned by :func:`len`.\n\n\n   .. attribute:: _type_\n\n        Specifies the type of each element in the array.\n\n\n   Array subclass constructors accept positional arguments, used to\n   initialize the elements in order.\n\n\n.. class:: _Pointer\n\n   Private, abstract base class for pointers.\n\n   Concrete pointer types are created by calling :func:`POINTER` with the\n   type that will be pointed to; this is done automatically by\n   :func:`pointer`.\n\n   If a pointer points to an array, its elements can be read and\n   written using standard subscript and slice accesses.  Pointer objects\n   have no size, so :func:`len` will raise :exc:`TypeError`.  Negative\n   subscripts will read from the memory *before* the pointer (as in C), and\n   out-of-range subscripts will probably crash with an access violation (if\n   you're lucky).\n\n\n   .. attribute:: _type_\n\n        Specifies the type pointed to.\n\n   .. attribute:: contents\n\n        Returns the object to which to pointer points.  Assigning to this\n        attribute changes the pointer to point to the assigned object.\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Python/dynload_shlib.c": "\n/* Support for dynamic loading of extension modules */\n\n#include \"Python.h\"\n#include \"pycore_pystate.h\"\n#include \"importdl.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#if defined(__NetBSD__)\n#include <sys/param.h>\n#if (NetBSD < 199712)\n#include <nlist.h>\n#include <link.h>\n#define dlerror() \"error in dynamic linking\"\n#endif\n#endif /* NetBSD */\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#if (defined(__OpenBSD__) || defined(__NetBSD__)) && !defined(__ELF__)\n#define LEAD_UNDERSCORE \"_\"\n#else\n#define LEAD_UNDERSCORE \"\"\n#endif\n\n/* The .so extension module ABI tag, supplied by the Makefile via\n   Makefile.pre.in and configure.  This is used to discriminate between\n   incompatible .so files so that extensions for different Python builds can\n   live in the same directory.  E.g. foomodule.cpython-32.so\n*/\n\nconst char *_PyImport_DynLoadFiletab[] = {\n#ifdef __CYGWIN__\n    \".dll\",\n#else  /* !__CYGWIN__ */\n    \".\" SOABI \".so\",\n#ifdef ALT_SOABI\n    \".\" ALT_SOABI \".so\",\n#endif\n    \".abi\" PYTHON_ABI_STRING \".so\",\n    \".so\",\n#endif  /* __CYGWIN__ */\n    NULL,\n};\n\nstatic struct {\n    dev_t dev;\n    ino_t ino;\n    void *handle;\n} handles[128];\nstatic int nhandles = 0;\n\n\ndl_funcptr\n_PyImport_FindSharedFuncptr(const char *prefix,\n                            const char *shortname,\n                            const char *pathname, FILE *fp)\n{\n    dl_funcptr p;\n    void *handle;\n    char funcname[258];\n    char pathbuf[260];\n    int dlopenflags=0;\n\n    if (strchr(pathname, '/') == NULL) {\n        /* Prefix bare filename with \"./\" */\n        PyOS_snprintf(pathbuf, sizeof(pathbuf), \"./%-.255s\", pathname);\n        pathname = pathbuf;\n    }\n\n    PyOS_snprintf(funcname, sizeof(funcname),\n                  LEAD_UNDERSCORE \"%.20s_%.200s\", prefix, shortname);\n\n    if (fp != NULL) {\n        int i;\n        struct _Py_stat_struct status;\n        if (_Py_fstat(fileno(fp), &status) == -1)\n            return NULL;\n        for (i = 0; i < nhandles; i++) {\n            if (status.st_dev == handles[i].dev &&\n                status.st_ino == handles[i].ino) {\n                p = (dl_funcptr) dlsym(handles[i].handle,\n                                       funcname);\n                return p;\n            }\n        }\n        if (nhandles < 128) {\n            handles[nhandles].dev = status.st_dev;\n            handles[nhandles].ino = status.st_ino;\n        }\n    }\n\n    dlopenflags = _PyInterpreterState_Get()->dlopenflags;\n\n    handle = dlopen(pathname, dlopenflags);\n\n    if (handle == NULL) {\n        PyObject *mod_name;\n        PyObject *path;\n        PyObject *error_ob;\n        const char *error = dlerror();\n        if (error == NULL)\n            error = \"unknown dlopen() error\";\n        error_ob = PyUnicode_FromString(error);\n        if (error_ob == NULL)\n            return NULL;\n        mod_name = PyUnicode_FromString(shortname);\n        if (mod_name == NULL) {\n            Py_DECREF(error_ob);\n            return NULL;\n        }\n        path = PyUnicode_FromString(pathname);\n        if (path == NULL) {\n            Py_DECREF(error_ob);\n            Py_DECREF(mod_name);\n            return NULL;\n        }\n        PyErr_SetImportError(error_ob, mod_name, path);\n        Py_DECREF(error_ob);\n        Py_DECREF(mod_name);\n        Py_DECREF(path);\n        return NULL;\n    }\n    if (fp != NULL && nhandles < 128)\n        handles[nhandles++].handle = handle;\n    p = (dl_funcptr) dlsym(handle, funcname);\n    return p;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Modules/_ctypes/ctypes_dlfcn.h": "#ifndef _CTYPES_DLFCN_H_\n#define _CTYPES_DLFCN_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MS_WIN32\n\n#include <dlfcn.h>\n\n#ifndef CTYPES_DARWIN_DLFCN\n\n#define ctypes_dlsym dlsym\n#define ctypes_dlerror dlerror\n#define ctypes_dlopen dlopen\n#define ctypes_dlclose dlclose\n#define ctypes_dladdr dladdr\n\n#endif /* !CTYPES_DARWIN_DLFCN */\n\n#endif /* !MS_WIN32 */\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n#endif /* _CTYPES_DLFCN_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Modules/_ctypes/_ctypes.c": "/*\n  ToDo:\n\n  Get rid of the checker (and also the converters) field in PyCFuncPtrObject and\n  StgDictObject, and replace them by slot functions in StgDictObject.\n\n  think about a buffer-like object (memory? bytes?)\n\n  Should POINTER(c_char) and POINTER(c_wchar) have a .value property?\n  What about c_char and c_wchar arrays then?\n\n  Add from_mmap, from_file, from_string metaclass methods.\n\n  Maybe we can get away with from_file (calls read) and with a from_buffer\n  method?\n\n  And what about the to_mmap, to_file, to_str(?) methods?  They would clobber\n  the namespace, probably. So, functions instead? And we already have memmove...\n*/\n\n/*\n\nName                    methods, members, getsets\n==============================================================================\n\nPyCStructType_Type              __new__(), from_address(), __mul__(), from_param()\nUnionType_Type          __new__(), from_address(), __mul__(), from_param()\nPyCPointerType_Type     __new__(), from_address(), __mul__(), from_param(), set_type()\nPyCArrayType_Type               __new__(), from_address(), __mul__(), from_param()\nPyCSimpleType_Type              __new__(), from_address(), __mul__(), from_param()\n\nPyCData_Type\n  Struct_Type           __new__(), __init__()\n  PyCPointer_Type               __new__(), __init__(), _as_parameter_, contents\n  PyCArray_Type         __new__(), __init__(), _as_parameter_, __get/setitem__(), __len__()\n  Simple_Type           __new__(), __init__(), _as_parameter_\n\nPyCField_Type\nPyCStgDict_Type\n\n==============================================================================\n\nclass methods\n-------------\n\nIt has some similarity to the byref() construct compared to pointer()\nfrom_address(addr)\n    - construct an instance from a given memory block (sharing this memory block)\n\nfrom_param(obj)\n    - typecheck and convert a Python object into a C function call parameter\n      The result may be an instance of the type, or an integer or tuple\n      (typecode, value[, obj])\n\ninstance methods/properties\n---------------------------\n\n_as_parameter_\n    - convert self into a C function call parameter\n      This is either an integer, or a 3-tuple (typecode, value, obj)\n\nfunctions\n---------\n\nsizeof(cdata)\n    - return the number of bytes the buffer contains\n\nsizeof(ctype)\n    - return the number of bytes the buffer of an instance would contain\n\nbyref(cdata)\n\naddressof(cdata)\n\npointer(cdata)\n\nPOINTER(ctype)\n\nbytes(cdata)\n    - return the buffer contents as a sequence of bytes (which is currently a string)\n\n*/\n\n/*\n * PyCStgDict_Type\n * PyCStructType_Type\n * UnionType_Type\n * PyCPointerType_Type\n * PyCArrayType_Type\n * PyCSimpleType_Type\n *\n * PyCData_Type\n * Struct_Type\n * Union_Type\n * PyCArray_Type\n * Simple_Type\n * PyCPointer_Type\n * PyCField_Type\n *\n */\n\n#define PY_SSIZE_T_CLEAN\n\n#include \"Python.h\"\n#include \"structmember.h\"\n\n#include <ffi.h>\n#ifdef MS_WIN32\n#include <windows.h>\n#include <malloc.h>\n#ifndef IS_INTRESOURCE\n#define IS_INTRESOURCE(x) (((size_t)(x) >> 16) == 0)\n#endif\n#else\n#include \"ctypes_dlfcn.h\"\n#endif\n#include \"ctypes.h\"\n\nPyObject *PyExc_ArgError = NULL;\n\n/* This dict maps ctypes types to POINTER types */\nPyObject *_ctypes_ptrtype_cache = NULL;\n\nstatic PyTypeObject Simple_Type;\n\n/* a callable object used for unpickling */\nstatic PyObject *_unpickle;\n\n\n\n/****************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *key;\n    PyObject *dict;\n} DictRemoverObject;\n\nstatic void\n_DictRemover_dealloc(PyObject *myself)\n{\n    DictRemoverObject *self = (DictRemoverObject *)myself;\n    Py_XDECREF(self->key);\n    Py_XDECREF(self->dict);\n    Py_TYPE(self)->tp_free(myself);\n}\n\nstatic PyObject *\n_DictRemover_call(PyObject *myself, PyObject *args, PyObject *kw)\n{\n    DictRemoverObject *self = (DictRemoverObject *)myself;\n    if (self->key && self->dict) {\n        if (-1 == PyDict_DelItem(self->dict, self->key)) {\n            _PyErr_WriteUnraisableMsg(\"on calling _ctypes.DictRemover\", NULL);\n        }\n        Py_CLEAR(self->key);\n        Py_CLEAR(self->dict);\n    }\n    Py_RETURN_NONE;\n}\n\nstatic PyTypeObject DictRemover_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.DictRemover\",                      /* tp_name */\n    sizeof(DictRemoverObject),                  /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    _DictRemover_dealloc,                       /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    _DictRemover_call,                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n/* XXX should participate in GC? */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    \"deletes a key from a dictionary\",          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    0,                                          /* tp_free */\n};\n\nint\nPyDict_SetItemProxy(PyObject *dict, PyObject *key, PyObject *item)\n{\n    PyObject *obj;\n    DictRemoverObject *remover;\n    PyObject *proxy;\n    int result;\n\n    obj = _PyObject_CallNoArg((PyObject *)&DictRemover_Type);\n    if (obj == NULL)\n        return -1;\n\n    remover = (DictRemoverObject *)obj;\n    assert(remover->key == NULL);\n    assert(remover->dict == NULL);\n    Py_INCREF(key);\n    remover->key = key;\n    Py_INCREF(dict);\n    remover->dict = dict;\n\n    proxy = PyWeakref_NewProxy(item, obj);\n    Py_DECREF(obj);\n    if (proxy == NULL)\n        return -1;\n\n    result = PyDict_SetItem(dict, key, proxy);\n    Py_DECREF(proxy);\n    return result;\n}\n\nPyObject *\nPyDict_GetItemProxy(PyObject *dict, PyObject *key)\n{\n    PyObject *result;\n    PyObject *item = PyDict_GetItemWithError(dict, key);\n\n    if (item == NULL)\n        return NULL;\n    if (!PyWeakref_CheckProxy(item))\n        return item;\n    result = PyWeakref_GET_OBJECT(item);\n    if (result == Py_None)\n        return NULL;\n    return result;\n}\n\n/******************************************************************/\n\n/*\n  Allocate a memory block for a pep3118 format string, filled with\n  a suitable PEP 3118 type code corresponding to the given ctypes\n  type. Returns NULL on failure, with the error indicator set.\n\n  This produces type codes in the standard size mode (cf. struct module),\n  since the endianness may need to be swapped to a non-native one\n  later on.\n */\nstatic char *\n_ctypes_alloc_format_string_for_type(char code, int big_endian)\n{\n    char *result;\n    char pep_code = '\\0';\n\n    switch (code) {\n#if SIZEOF_INT == 2\n    case 'i': pep_code = 'h'; break;\n    case 'I': pep_code = 'H'; break;\n#elif SIZEOF_INT == 4\n    case 'i': pep_code = 'i'; break;\n    case 'I': pep_code = 'I'; break;\n#elif SIZEOF_INT == 8\n    case 'i': pep_code = 'q'; break;\n    case 'I': pep_code = 'Q'; break;\n#else\n# error SIZEOF_INT has an unexpected value\n#endif /* SIZEOF_INT */\n#if SIZEOF_LONG == 4\n    case 'l': pep_code = 'l'; break;\n    case 'L': pep_code = 'L'; break;\n#elif SIZEOF_LONG == 8\n    case 'l': pep_code = 'q'; break;\n    case 'L': pep_code = 'Q'; break;\n#else\n# error SIZEOF_LONG has an unexpected value\n#endif /* SIZEOF_LONG */\n#if SIZEOF__BOOL == 1\n    case '?': pep_code = '?'; break;\n#elif SIZEOF__BOOL == 2\n    case '?': pep_code = 'H'; break;\n#elif SIZEOF__BOOL == 4\n    case '?': pep_code = 'L'; break;\n#elif SIZEOF__BOOL == 8\n    case '?': pep_code = 'Q'; break;\n#else\n# error SIZEOF__BOOL has an unexpected value\n#endif /* SIZEOF__BOOL */\n    default:\n        /* The standard-size code is the same as the ctypes one */\n        pep_code = code;\n        break;\n    }\n\n    result = PyMem_Malloc(3);\n    if (result == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n\n    result[0] = big_endian ? '>' : '<';\n    result[1] = pep_code;\n    result[2] = '\\0';\n    return result;\n}\n\n/*\n  Allocate a memory block for a pep3118 format string, copy prefix (if\n  non-null) and suffix into it.  Returns NULL on failure, with the error\n  indicator set.  If called with a suffix of NULL the error indicator must\n  already be set.\n */\nchar *\n_ctypes_alloc_format_string(const char *prefix, const char *suffix)\n{\n    size_t len;\n    char *result;\n\n    if (suffix == NULL) {\n        assert(PyErr_Occurred());\n        return NULL;\n    }\n    len = strlen(suffix);\n    if (prefix)\n        len += strlen(prefix);\n    result = PyMem_Malloc(len + 1);\n    if (result == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    if (prefix)\n        strcpy(result, prefix);\n    else\n        result[0] = '\\0';\n    strcat(result, suffix);\n    return result;\n}\n\n/*\n  Allocate a memory block for a pep3118 format string, adding\n  the given prefix (if non-null), an additional shape prefix, and a suffix.\n  Returns NULL on failure, with the error indicator set.  If called with\n  a suffix of NULL the error indicator must already be set.\n */\nchar *\n_ctypes_alloc_format_string_with_shape(int ndim, const Py_ssize_t *shape,\n                                       const char *prefix, const char *suffix)\n{\n    char *new_prefix;\n    char *result;\n    char buf[32];\n    Py_ssize_t prefix_len;\n    int k;\n\n    prefix_len = 32 * ndim + 3;\n    if (prefix)\n        prefix_len += strlen(prefix);\n    new_prefix = PyMem_Malloc(prefix_len);\n    if (new_prefix == NULL) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    new_prefix[0] = '\\0';\n    if (prefix)\n        strcpy(new_prefix, prefix);\n    if (ndim > 0) {\n        /* Add the prefix \"(shape[0],shape[1],...,shape[ndim-1])\" */\n        strcat(new_prefix, \"(\");\n        for (k = 0; k < ndim; ++k) {\n            if (k < ndim-1) {\n                sprintf(buf, \"%\"PY_FORMAT_SIZE_T\"d,\", shape[k]);\n            } else {\n                sprintf(buf, \"%\"PY_FORMAT_SIZE_T\"d)\", shape[k]);\n            }\n            strcat(new_prefix, buf);\n        }\n    }\n    result = _ctypes_alloc_format_string(new_prefix, suffix);\n    PyMem_Free(new_prefix);\n    return result;\n}\n\n/* StructParamObject and StructParam_Type are used in _ctypes_callproc()\n   for argument.keep to call PyMem_Free(ptr) on Py_DECREF(argument).\n\n   StructUnionType_paramfunc() creates such object when a ctypes Structure is\n   passed by copy to a C function. */\ntypedef struct {\n    PyObject_HEAD\n    void *ptr;\n} StructParamObject;\n\n\nstatic void\nStructParam_dealloc(PyObject *myself)\n{\n    StructParamObject *self = (StructParamObject *)myself;\n    PyMem_Free(self->ptr);\n    Py_TYPE(self)->tp_free(myself);\n}\n\n\nstatic PyTypeObject StructParam_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    .tp_name = \"_ctypes.StructParam_Type\",\n    .tp_basicsize = sizeof(StructParamObject),\n    .tp_dealloc = StructParam_dealloc,\n    .tp_flags = Py_TPFLAGS_DEFAULT,\n};\n\n\n/*\n  PyCStructType_Type - a meta type/class.  Creating a new class using this one as\n  __metaclass__ will call the constructor StructUnionType_new.  It replaces the\n  tp_dict member with a new instance of StgDict, and initializes the C\n  accessible fields somehow.\n*/\n\nstatic PyCArgObject *\nStructUnionType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n    PyObject *obj;\n    StgDictObject *stgdict;\n    void *ptr;\n\n    if ((size_t)self->b_size > sizeof(void*)) {\n        ptr = PyMem_Malloc(self->b_size);\n        if (ptr == NULL) {\n            return NULL;\n        }\n        memcpy(ptr, self->b_ptr, self->b_size);\n\n        /* Create a Python object which calls PyMem_Free(ptr) in\n           its deallocator. The object will be destroyed\n           at _ctypes_callproc() cleanup. */\n        obj = (&StructParam_Type)->tp_alloc(&StructParam_Type, 0);\n        if (obj == NULL) {\n            PyMem_Free(ptr);\n            return NULL;\n        }\n\n        StructParamObject *struct_param = (StructParamObject *)obj;\n        struct_param->ptr = ptr;\n    } else {\n        ptr = self->b_ptr;\n        obj = (PyObject *)self;\n        Py_INCREF(obj);\n    }\n\n    parg = PyCArgObject_new();\n    if (parg == NULL) {\n        Py_DECREF(obj);\n        return NULL;\n    }\n\n    parg->tag = 'V';\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for structure/union instances */\n    parg->pffi_type = &stgdict->ffi_type_pointer;\n    parg->value.p = ptr;\n    parg->size = self->b_size;\n    parg->obj = obj;\n    return parg;\n}\n\nstatic PyObject *\nStructUnionType_new(PyTypeObject *type, PyObject *args, PyObject *kwds, int isStruct)\n{\n    PyTypeObject *result;\n    PyObject *fields;\n    StgDictObject *dict;\n    _Py_IDENTIFIER(_abstract_);\n    _Py_IDENTIFIER(_fields_);\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (!result)\n        return NULL;\n\n    /* keep this for bw compatibility */\n    if (_PyDict_GetItemIdWithError(result->tp_dict, &PyId__abstract_))\n        return (PyObject *)result;\n    if (PyErr_Occurred()) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    dict = (StgDictObject *)_PyObject_CallNoArg((PyObject *)&PyCStgDict_Type);\n    if (!dict) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    if (!isStruct) {\n        dict->flags |= TYPEFLAG_HASUNION;\n    }\n    /* replace the class dict by our updated stgdict, which holds info\n       about storage requirements of the instances */\n    if (-1 == PyDict_Update((PyObject *)dict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)dict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)dict);\n    dict->format = _ctypes_alloc_format_string(NULL, \"B\");\n    if (dict->format == NULL) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    dict->paramfunc = StructUnionType_paramfunc;\n\n    fields = _PyDict_GetItemIdWithError((PyObject *)dict, &PyId__fields_);\n    if (fields) {\n        if (_PyObject_SetAttrId((PyObject *)result, &PyId__fields_, fields) < 0) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        return (PyObject *)result;\n    }\n    else if (PyErr_Occurred()) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    else {\n        StgDictObject *basedict = PyType_stgdict((PyObject *)result->tp_base);\n\n        if (basedict == NULL)\n            return (PyObject *)result;\n        /* copy base dict */\n        if (-1 == PyCStgDict_clone(dict, basedict)) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        dict->flags &= ~DICTFLAG_FINAL; /* clear the 'final' flag in the subclass dict */\n        basedict->flags |= DICTFLAG_FINAL; /* set the 'final' flag in the baseclass dict */\n        return (PyObject *)result;\n    }\n}\n\nstatic PyObject *\nPyCStructType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    return StructUnionType_new(type, args, kwds, 1);\n}\n\nstatic PyObject *\nUnionType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    return StructUnionType_new(type, args, kwds, 0);\n}\n\nstatic const char from_address_doc[] =\n\"C.from_address(integer) -> C instance\\naccess a C instance at the specified address\";\n\nstatic PyObject *\nCDataType_from_address(PyObject *type, PyObject *value)\n{\n    void *buf;\n    if (!PyLong_Check(value)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"integer expected\");\n        return NULL;\n    }\n    buf = (void *)PyLong_AsVoidPtr(value);\n    if (PyErr_Occurred())\n        return NULL;\n    return PyCData_AtAddress(type, buf);\n}\n\nstatic const char from_buffer_doc[] =\n\"C.from_buffer(object, offset=0) -> C instance\\ncreate a C instance from a writeable buffer\";\n\nstatic int\nKeepRef(CDataObject *target, Py_ssize_t index, PyObject *keep);\n\nstatic PyObject *\nCDataType_from_buffer(PyObject *type, PyObject *args)\n{\n    PyObject *obj;\n    PyObject *mv;\n    PyObject *result;\n    Py_buffer *buffer;\n    Py_ssize_t offset = 0;\n\n    StgDictObject *dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError, \"abstract class\");\n        return NULL;\n    }\n\n    if (!PyArg_ParseTuple(args, \"O|n:from_buffer\", &obj, &offset))\n        return NULL;\n\n    mv = PyMemoryView_FromObject(obj);\n    if (mv == NULL)\n        return NULL;\n\n    buffer = PyMemoryView_GET_BUFFER(mv);\n\n    if (buffer->readonly) {\n        PyErr_SetString(PyExc_TypeError,\n            \"underlying buffer is not writable\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (!PyBuffer_IsContiguous(buffer, 'C')) {\n        PyErr_SetString(PyExc_TypeError,\n            \"underlying buffer is not C contiguous\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (offset < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"offset cannot be negative\");\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (dict->size > buffer->len - offset) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Buffer size too small \"\n                     \"(%zd instead of at least %zd bytes)\",\n                     buffer->len, dict->size + offset);\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (PySys_Audit(\"ctypes.cdata/buffer\", \"nnn\",\n                    (Py_ssize_t)buffer->buf, buffer->len, offset) < 0) {\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    result = PyCData_AtAddress(type, (char *)buffer->buf + offset);\n    if (result == NULL) {\n        Py_DECREF(mv);\n        return NULL;\n    }\n\n    if (-1 == KeepRef((CDataObject *)result, -1, mv)) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    return result;\n}\n\nstatic const char from_buffer_copy_doc[] =\n\"C.from_buffer_copy(object, offset=0) -> C instance\\ncreate a C instance from a readable buffer\";\n\nstatic PyObject *\nGenericPyCData_new(PyTypeObject *type, PyObject *args, PyObject *kwds);\n\nstatic PyObject *\nCDataType_from_buffer_copy(PyObject *type, PyObject *args)\n{\n    Py_buffer buffer;\n    Py_ssize_t offset = 0;\n    PyObject *result;\n    StgDictObject *dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError, \"abstract class\");\n        return NULL;\n    }\n\n    if (!PyArg_ParseTuple(args, \"y*|n:from_buffer_copy\", &buffer, &offset))\n        return NULL;\n\n    if (offset < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"offset cannot be negative\");\n        PyBuffer_Release(&buffer);\n        return NULL;\n    }\n\n    if (dict->size > buffer.len - offset) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Buffer size too small (%zd instead of at least %zd bytes)\",\n                     buffer.len, dict->size + offset);\n        PyBuffer_Release(&buffer);\n        return NULL;\n    }\n\n    if (PySys_Audit(\"ctypes.cdata/buffer\", \"nnn\",\n                    (Py_ssize_t)buffer.buf, buffer.len, offset) < 0) {\n        PyBuffer_Release(&buffer);\n        return NULL;\n    }\n\n    result = GenericPyCData_new((PyTypeObject *)type, NULL, NULL);\n    if (result != NULL) {\n        memcpy(((CDataObject *)result)->b_ptr,\n               (char *)buffer.buf + offset, dict->size);\n    }\n    PyBuffer_Release(&buffer);\n    return result;\n}\n\nstatic const char in_dll_doc[] =\n\"C.in_dll(dll, name) -> C instance\\naccess a C instance in a dll\";\n\nstatic PyObject *\nCDataType_in_dll(PyObject *type, PyObject *args)\n{\n    PyObject *dll;\n    char *name;\n    PyObject *obj;\n    void *handle;\n    void *address;\n\n    if (!PyArg_ParseTuple(args, \"Os:in_dll\", &dll, &name))\n        return NULL;\n    if (PySys_Audit(\"ctypes.dlsym\", \"O\", args) < 0) {\n        return NULL;\n    }\n\n    obj = PyObject_GetAttrString(dll, \"_handle\");\n    if (!obj)\n        return NULL;\n    if (!PyLong_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the _handle attribute of the second argument must be an integer\");\n        Py_DECREF(obj);\n        return NULL;\n    }\n    handle = (void *)PyLong_AsVoidPtr(obj);\n    Py_DECREF(obj);\n    if (PyErr_Occurred()) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"could not convert the _handle attribute to a pointer\");\n        return NULL;\n    }\n\n#ifdef MS_WIN32\n    Py_BEGIN_ALLOW_THREADS\n    address = (void *)GetProcAddress(handle, name);\n    Py_END_ALLOW_THREADS\n    if (!address) {\n        PyErr_Format(PyExc_ValueError,\n                     \"symbol '%s' not found\",\n                     name);\n        return NULL;\n    }\n#else\n    address = (void *)ctypes_dlsym(handle, name);\n    if (!address) {\n#ifdef __CYGWIN__\n/* dlerror() isn't very helpful on cygwin */\n        PyErr_Format(PyExc_ValueError,\n                     \"symbol '%s' not found\",\n                     name);\n#else\n        PyErr_SetString(PyExc_ValueError, ctypes_dlerror());\n#endif\n        return NULL;\n    }\n#endif\n    return PyCData_AtAddress(type, address);\n}\n\nstatic const char from_param_doc[] =\n\"Convert a Python object into a function call parameter.\";\n\nstatic PyObject *\nCDataType_from_param(PyObject *type, PyObject *value)\n{\n    _Py_IDENTIFIER(_as_parameter_);\n    PyObject *as_parameter;\n    int res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n    if (PyCArg_CheckExact(value)) {\n        PyCArgObject *p = (PyCArgObject *)value;\n        PyObject *ob = p->obj;\n        const char *ob_name;\n        StgDictObject *dict;\n        dict = PyType_stgdict(type);\n\n        /* If we got a PyCArgObject, we must check if the object packed in it\n           is an instance of the type's dict->proto */\n        if(dict && ob) {\n            res = PyObject_IsInstance(ob, dict->proto);\n            if (res == -1)\n                return NULL;\n            if (res) {\n                Py_INCREF(value);\n                return value;\n            }\n        }\n        ob_name = (ob) ? Py_TYPE(ob)->tp_name : \"???\";\n        PyErr_Format(PyExc_TypeError,\n                     \"expected %s instance instead of pointer to %s\",\n                     ((PyTypeObject *)type)->tp_name, ob_name);\n        return NULL;\n    }\n\n    if (_PyObject_LookupAttrId(value, &PyId__as_parameter_, &as_parameter) < 0) {\n        return NULL;\n    }\n    if (as_parameter) {\n        value = CDataType_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"expected %s instance instead of %s\",\n                 ((PyTypeObject *)type)->tp_name,\n                 Py_TYPE(value)->tp_name);\n    return NULL;\n}\n\nstatic PyMethodDef CDataType_methods[] = {\n    { \"from_param\", CDataType_from_param, METH_O, from_param_doc },\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc },\n    { NULL, NULL },\n};\n\nstatic PyObject *\nCDataType_repeat(PyObject *self, Py_ssize_t length)\n{\n    if (length < 0)\n        return PyErr_Format(PyExc_ValueError,\n                            \"Array length must be >= 0, not %zd\",\n                            length);\n    return PyCArrayType_from_ctype(self, length);\n}\n\nstatic PySequenceMethods CDataType_as_sequence = {\n    0,                          /* inquiry sq_length; */\n    0,                          /* binaryfunc sq_concat; */\n    CDataType_repeat,           /* intargfunc sq_repeat; */\n    0,                          /* intargfunc sq_item; */\n    0,                          /* intintargfunc sq_slice; */\n    0,                          /* intobjargproc sq_ass_item; */\n    0,                          /* intintobjargproc sq_ass_slice; */\n    0,                          /* objobjproc sq_contains; */\n\n    0,                          /* binaryfunc sq_inplace_concat; */\n    0,                          /* intargfunc sq_inplace_repeat; */\n};\n\nstatic int\nCDataType_clear(PyTypeObject *self)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)self);\n    if (dict)\n        Py_CLEAR(dict->proto);\n    return PyType_Type.tp_clear((PyObject *)self);\n}\n\nstatic int\nCDataType_traverse(PyTypeObject *self, visitproc visit, void *arg)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)self);\n    if (dict)\n        Py_VISIT(dict->proto);\n    return PyType_Type.tp_traverse((PyObject *)self, visit, arg);\n}\n\nstatic int\nPyCStructType_setattro(PyObject *self, PyObject *key, PyObject *value)\n{\n    /* XXX Should we disallow deleting _fields_? */\n    if (-1 == PyType_Type.tp_setattro(self, key, value))\n        return -1;\n\n    if (value && PyUnicode_Check(key) &&\n        _PyUnicode_EqualToASCIIString(key, \"_fields_\"))\n        return PyCStructUnionType_update_stgdict(self, value, 1);\n    return 0;\n}\n\n\nstatic int\nUnionType_setattro(PyObject *self, PyObject *key, PyObject *value)\n{\n    /* XXX Should we disallow deleting _fields_? */\n    if (-1 == PyObject_GenericSetAttr(self, key, value))\n        return -1;\n\n    if (PyUnicode_Check(key) &&\n        _PyUnicode_EqualToASCIIString(key, \"_fields_\"))\n        return PyCStructUnionType_update_stgdict(self, value, 0);\n    return 0;\n}\n\n\nPyTypeObject PyCStructType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCStructType\",                            /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    PyCStructType_setattro,                     /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for the CData Objects\",           /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCStructType_new,                                  /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic PyTypeObject UnionType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.UnionType\",                        /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    UnionType_setattro,                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for the CData Objects\",           /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    UnionType_new,                              /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n\n/*\n\nThe PyCPointerType_Type metaclass must ensure that the subclass of Pointer can be\ncreated. It must check for a _type_ attribute in the class. Since are no\nruntime created properties, a CField is probably *not* needed ?\n\nclass IntPointer(Pointer):\n    _type_ = \"i\"\n\nThe PyCPointer_Type provides the functionality: a contents method/property, a\nsize property/method, and the sequence protocol.\n\n*/\n\nstatic int\nPyCPointerType_SetProto(StgDictObject *stgdict, PyObject *proto)\n{\n    if (!proto || !PyType_Check(proto)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must be a type\");\n        return -1;\n    }\n    if (!PyType_stgdict(proto)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must have storage info\");\n        return -1;\n    }\n    Py_INCREF(proto);\n    Py_XSETREF(stgdict->proto, proto);\n    return 0;\n}\n\nstatic PyCArgObject *\nPyCPointerType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    Py_INCREF(self);\n    parg->obj = (PyObject *)self;\n    parg->value.p = *(void **)self->b_ptr;\n    return parg;\n}\n\nstatic PyObject *\nPyCPointerType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *proto;\n    PyObject *typedict;\n    _Py_IDENTIFIER(_type_);\n\n    typedict = PyTuple_GetItem(args, 2);\n    if (!typedict)\n        return NULL;\n/*\n  stgdict items size, align, length contain info about pointers itself,\n  stgdict->proto has info about the pointed to type!\n*/\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        return NULL;\n    stgdict->size = sizeof(void *);\n    stgdict->align = _ctypes_get_fielddesc(\"P\")->pffi_type->alignment;\n    stgdict->length = 1;\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n    stgdict->paramfunc = PyCPointerType_paramfunc;\n    stgdict->flags |= TYPEFLAG_ISPOINTER;\n\n    proto = _PyDict_GetItemIdWithError(typedict, &PyId__type_); /* Borrowed ref */\n    if (proto) {\n        StgDictObject *itemdict;\n        const char *current_format;\n        if (-1 == PyCPointerType_SetProto(stgdict, proto)) {\n            Py_DECREF((PyObject *)stgdict);\n            return NULL;\n        }\n        itemdict = PyType_stgdict(proto);\n        /* PyCPointerType_SetProto has verified proto has a stgdict. */\n        assert(itemdict);\n        /* If itemdict->format is NULL, then this is a pointer to an\n           incomplete type.  We create a generic format string\n           'pointer to bytes' in this case.  XXX Better would be to\n           fix the format string later...\n        */\n        current_format = itemdict->format ? itemdict->format : \"B\";\n        if (itemdict->shape != NULL) {\n            /* pointer to an array: the shape needs to be prefixed */\n            stgdict->format = _ctypes_alloc_format_string_with_shape(\n                itemdict->ndim, itemdict->shape, \"&\", current_format);\n        } else {\n            stgdict->format = _ctypes_alloc_format_string(\"&\", current_format);\n        }\n        if (stgdict->format == NULL) {\n            Py_DECREF((PyObject *)stgdict);\n            return NULL;\n        }\n    }\n    else if (PyErr_Occurred()) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    return (PyObject *)result;\n}\n\n\nstatic PyObject *\nPyCPointerType_set_type(PyTypeObject *self, PyObject *type)\n{\n    StgDictObject *dict;\n    _Py_IDENTIFIER(_type_);\n\n    dict = PyType_stgdict((PyObject *)self);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n\n    if (-1 == PyCPointerType_SetProto(dict, type))\n        return NULL;\n\n    if (-1 == _PyDict_SetItemId((PyObject *)dict, &PyId__type_, type))\n        return NULL;\n\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *_byref(PyObject *);\n\nstatic PyObject *\nPyCPointerType_from_param(PyObject *type, PyObject *value)\n{\n    StgDictObject *typedict;\n\n    if (value == Py_None) {\n        /* ConvParam will convert to a NULL pointer later */\n        Py_INCREF(value);\n        return value;\n    }\n\n    typedict = PyType_stgdict(type);\n    if (!typedict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n\n    /* If we expect POINTER(<type>), but receive a <type> instance, accept\n       it by calling byref(<type>).\n    */\n    switch (PyObject_IsInstance(value, typedict->proto)) {\n    case 1:\n        Py_INCREF(value); /* _byref steals a refcount */\n        return _byref(value);\n    case -1:\n        return NULL;\n    default:\n        break;\n    }\n\n    if (PointerObject_Check(value) || ArrayObject_Check(value)) {\n        /* Array instances are also pointers when\n           the item types are the same.\n        */\n        StgDictObject *v = PyObject_stgdict(value);\n        assert(v); /* Cannot be NULL for pointer or array objects */\n        int ret = PyObject_IsSubclass(v->proto, typedict->proto);\n        if (ret < 0) {\n            return NULL;\n        }\n        if (ret) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n    return CDataType_from_param(type, value);\n}\n\nstatic PyMethodDef PyCPointerType_methods[] = {\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc},\n    { \"from_param\", (PyCFunction)PyCPointerType_from_param, METH_O, from_param_doc},\n    { \"set_type\", (PyCFunction)PyCPointerType_set_type, METH_O },\n    { NULL, NULL },\n};\n\nPyTypeObject PyCPointerType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCPointerType\",                                   /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for the Pointer Objects\",         /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCPointerType_methods,                     /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCPointerType_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCArrayType_Type\n*/\n/*\n  PyCArrayType_new ensures that the new Array subclass created has a _length_\n  attribute, and a _type_ attribute.\n*/\n\nstatic int\nCharArray_set_raw(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    char *ptr;\n    Py_ssize_t size;\n    Py_buffer view;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_AttributeError, \"cannot delete attribute\");\n        return -1;\n    }\n    if (PyObject_GetBuffer(value, &view, PyBUF_SIMPLE) < 0)\n        return -1;\n    size = view.len;\n    ptr = view.buf;\n    if (size > self->b_size) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"byte string too long\");\n        goto fail;\n    }\n\n    memcpy(self->b_ptr, ptr, size);\n\n    PyBuffer_Release(&view);\n    return 0;\n fail:\n    PyBuffer_Release(&view);\n    return -1;\n}\n\nstatic PyObject *\nCharArray_get_raw(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    return PyBytes_FromStringAndSize(self->b_ptr, self->b_size);\n}\n\nstatic PyObject *\nCharArray_get_value(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    Py_ssize_t i;\n    char *ptr = self->b_ptr;\n    for (i = 0; i < self->b_size; ++i)\n        if (*ptr++ == '\\0')\n            break;\n    return PyBytes_FromStringAndSize(self->b_ptr, i);\n}\n\nstatic int\nCharArray_set_value(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    char *ptr;\n    Py_ssize_t size;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n\n    if (!PyBytes_Check(value)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"bytes expected instead of %s instance\",\n                     Py_TYPE(value)->tp_name);\n        return -1;\n    } else\n        Py_INCREF(value);\n    size = PyBytes_GET_SIZE(value);\n    if (size > self->b_size) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"byte string too long\");\n        Py_DECREF(value);\n        return -1;\n    }\n\n    ptr = PyBytes_AS_STRING(value);\n    memcpy(self->b_ptr, ptr, size);\n    if (size < self->b_size)\n        self->b_ptr[size] = '\\0';\n    Py_DECREF(value);\n\n    return 0;\n}\n\nstatic PyGetSetDef CharArray_getsets[] = {\n    { \"raw\", (getter)CharArray_get_raw, (setter)CharArray_set_raw,\n      \"value\", NULL },\n    { \"value\", (getter)CharArray_get_value, (setter)CharArray_set_value,\n      \"string value\"},\n    { NULL, NULL }\n};\n\n#ifdef CTYPES_UNICODE\nstatic PyObject *\nWCharArray_get_value(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    Py_ssize_t i;\n    wchar_t *ptr = (wchar_t *)self->b_ptr;\n    for (i = 0; i < self->b_size/(Py_ssize_t)sizeof(wchar_t); ++i)\n        if (*ptr++ == (wchar_t)0)\n            break;\n    return PyUnicode_FromWideChar((wchar_t *)self->b_ptr, i);\n}\n\nstatic int\nWCharArray_set_value(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    Py_ssize_t result = 0;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n    if (!PyUnicode_Check(value)) {\n        PyErr_Format(PyExc_TypeError,\n                        \"unicode string expected instead of %s instance\",\n                        Py_TYPE(value)->tp_name);\n        return -1;\n    } else\n        Py_INCREF(value);\n\n    Py_ssize_t len = PyUnicode_AsWideChar(value, NULL, 0);\n    if (len < 0) {\n        return -1;\n    }\n    // PyUnicode_AsWideChar() returns number of wchars including trailing null byte,\n    // when it is called with NULL.\n    if (((size_t)len-1) > self->b_size/sizeof(wchar_t)) {\n        PyErr_SetString(PyExc_ValueError, \"string too long\");\n        result = -1;\n        goto done;\n    }\n    result = PyUnicode_AsWideChar(value,\n                                  (wchar_t *)self->b_ptr,\n                                  self->b_size/sizeof(wchar_t));\n    if (result >= 0 && (size_t)result < self->b_size/sizeof(wchar_t))\n        ((wchar_t *)self->b_ptr)[result] = (wchar_t)0;\n  done:\n    Py_DECREF(value);\n\n    return result >= 0 ? 0 : -1;\n}\n\nstatic PyGetSetDef WCharArray_getsets[] = {\n    { \"value\", (getter)WCharArray_get_value, (setter)WCharArray_set_value,\n      \"string value\"},\n    { NULL, NULL }\n};\n#endif\n\n/*\n  The next three functions copied from Python's typeobject.c.\n\n  They are used to attach methods, members, or getsets to a type *after* it\n  has been created: Arrays of characters have additional getsets to treat them\n  as strings.\n */\n/*\nstatic int\nadd_methods(PyTypeObject *type, PyMethodDef *meth)\n{\n    PyObject *dict = type->tp_dict;\n    for (; meth->ml_name != NULL; meth++) {\n        PyObject *descr;\n        descr = PyDescr_NewMethod(type, meth);\n        if (descr == NULL)\n            return -1;\n        if (PyDict_SetItemString(dict, meth->ml_name, descr) < 0) {\n            Py_DECREF(descr);\n            return -1;\n        }\n        Py_DECREF(descr);\n    }\n    return 0;\n}\n\nstatic int\nadd_members(PyTypeObject *type, PyMemberDef *memb)\n{\n    PyObject *dict = type->tp_dict;\n    for (; memb->name != NULL; memb++) {\n        PyObject *descr;\n        descr = PyDescr_NewMember(type, memb);\n        if (descr == NULL)\n            return -1;\n        if (PyDict_SetItemString(dict, memb->name, descr) < 0) {\n            Py_DECREF(descr);\n            return -1;\n        }\n        Py_DECREF(descr);\n    }\n    return 0;\n}\n*/\n\nstatic int\nadd_getset(PyTypeObject *type, PyGetSetDef *gsp)\n{\n    PyObject *dict = type->tp_dict;\n    for (; gsp->name != NULL; gsp++) {\n        PyObject *descr;\n        descr = PyDescr_NewGetSet(type, gsp);\n        if (descr == NULL)\n            return -1;\n        if (PyDict_SetItemString(dict, gsp->name, descr) < 0) {\n            Py_DECREF(descr);\n            return -1;\n        }\n        Py_DECREF(descr);\n    }\n    return 0;\n}\n\nstatic PyCArgObject *\nPyCArrayType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *p = PyCArgObject_new();\n    if (p == NULL)\n        return NULL;\n    p->tag = 'P';\n    p->pffi_type = &ffi_type_pointer;\n    p->value.p = (char *)self->b_ptr;\n    Py_INCREF(self);\n    p->obj = (PyObject *)self;\n    return p;\n}\n\nstatic PyObject *\nPyCArrayType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    _Py_IDENTIFIER(_length_);\n    _Py_IDENTIFIER(_type_);\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    StgDictObject *itemdict;\n    PyObject *length_attr, *type_attr;\n    Py_ssize_t length;\n    Py_ssize_t itemsize, itemalign;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL)\n        return NULL;\n\n    /* Initialize these variables to NULL so that we can simplify error\n       handling by using Py_XDECREF.  */\n    stgdict = NULL;\n    type_attr = NULL;\n\n    if (_PyObject_LookupAttrId((PyObject *)result, &PyId__length_, &length_attr) < 0) {\n        goto error;\n    }\n    if (!length_attr) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_length_' attribute\");\n        goto error;\n    }\n\n    if (!PyLong_Check(length_attr)) {\n        Py_DECREF(length_attr);\n        PyErr_SetString(PyExc_TypeError,\n                        \"The '_length_' attribute must be an integer\");\n        goto error;\n    }\n\n    if (_PyLong_Sign(length_attr) == -1) {\n        Py_DECREF(length_attr);\n        PyErr_SetString(PyExc_ValueError,\n                        \"The '_length_' attribute must not be negative\");\n        goto error;\n    }\n\n    length = PyLong_AsSsize_t(length_attr);\n    Py_DECREF(length_attr);\n    if (length == -1 && PyErr_Occurred()) {\n        if (PyErr_ExceptionMatches(PyExc_OverflowError)) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"The '_length_' attribute is too large\");\n        }\n        goto error;\n    }\n\n    if (_PyObject_LookupAttrId((PyObject *)result, &PyId__type_, &type_attr) < 0) {\n        goto error;\n    }\n    if (!type_attr) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_type_' attribute\");\n        goto error;\n    }\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        goto error;\n\n    itemdict = PyType_stgdict(type_attr);\n    if (!itemdict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must have storage info\");\n        goto error;\n    }\n\n    assert(itemdict->format);\n    stgdict->format = _ctypes_alloc_format_string(NULL, itemdict->format);\n    if (stgdict->format == NULL)\n        goto error;\n    stgdict->ndim = itemdict->ndim + 1;\n    stgdict->shape = PyMem_Malloc(sizeof(Py_ssize_t) * stgdict->ndim);\n    if (stgdict->shape == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n    stgdict->shape[0] = length;\n    if (stgdict->ndim > 1) {\n        memmove(&stgdict->shape[1], itemdict->shape,\n            sizeof(Py_ssize_t) * (stgdict->ndim - 1));\n    }\n\n    itemsize = itemdict->size;\n    if (itemsize != 0 && length > PY_SSIZE_T_MAX / itemsize) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"array too large\");\n        goto error;\n    }\n\n    itemalign = itemdict->align;\n\n    if (itemdict->flags & (TYPEFLAG_ISPOINTER | TYPEFLAG_HASPOINTER))\n        stgdict->flags |= TYPEFLAG_HASPOINTER;\n\n    stgdict->size = itemsize * length;\n    stgdict->align = itemalign;\n    stgdict->length = length;\n    stgdict->proto = type_attr;\n    type_attr = NULL;\n\n    stgdict->paramfunc = &PyCArrayType_paramfunc;\n\n    /* Arrays are passed as pointers to function calls. */\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict))\n        goto error;\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);  /* steal the reference */\n    stgdict = NULL;\n\n    /* Special case for character arrays.\n       A permanent annoyance: char arrays are also strings!\n    */\n    if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n        if (-1 == add_getset(result, CharArray_getsets))\n            goto error;\n#ifdef CTYPES_UNICODE\n    } else if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n        if (-1 == add_getset(result, WCharArray_getsets))\n            goto error;\n#endif\n    }\n\n    return (PyObject *)result;\nerror:\n    Py_XDECREF((PyObject*)stgdict);\n    Py_XDECREF(type_attr);\n    Py_DECREF(result);\n    return NULL;\n}\n\nPyTypeObject PyCArrayType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCArrayType\",                     /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"metatype for the Array Objects\",           /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCArrayType_new,                                   /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCSimpleType_Type\n*/\n/*\n\nPyCSimpleType_new ensures that the new Simple_Type subclass created has a valid\n_type_ attribute.\n\n*/\n\nstatic const char SIMPLE_TYPE_CHARS[] = \"cbBhHiIlLdfuzZqQPXOv?g\";\n\nstatic PyObject *\nc_wchar_p_from_param(PyObject *type, PyObject *value)\n{\n    _Py_IDENTIFIER(_as_parameter_);\n    PyObject *as_parameter;\n    int res;\n    if (value == Py_None) {\n        Py_RETURN_NONE;\n    }\n    if (PyUnicode_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"Z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'Z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* c_wchar array instance or pointer(c_wchar(...)) */\n        StgDictObject *dt = PyObject_stgdict(value);\n        StgDictObject *dict;\n        assert(dt); /* Cannot be NULL for pointer or array objects */\n        dict = dt && dt->proto ? PyType_stgdict(dt->proto) : NULL;\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"u\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n    if (PyCArg_CheckExact(value)) {\n        /* byref(c_char(...)) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        StgDictObject *dict = PyObject_stgdict(a->obj);\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"u\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n\n    if (_PyObject_LookupAttrId(value, &PyId__as_parameter_, &as_parameter) < 0) {\n        return NULL;\n    }\n    if (as_parameter) {\n        value = c_wchar_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyObject *\nc_char_p_from_param(PyObject *type, PyObject *value)\n{\n    _Py_IDENTIFIER(_as_parameter_);\n    PyObject *as_parameter;\n    int res;\n    if (value == Py_None) {\n        Py_RETURN_NONE;\n    }\n    if (PyBytes_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* c_char array instance or pointer(c_char(...)) */\n        StgDictObject *dt = PyObject_stgdict(value);\n        StgDictObject *dict;\n        assert(dt); /* Cannot be NULL for pointer or array objects */\n        dict = dt && dt->proto ? PyType_stgdict(dt->proto) : NULL;\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"c\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n    if (PyCArg_CheckExact(value)) {\n        /* byref(c_char(...)) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        StgDictObject *dict = PyObject_stgdict(a->obj);\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"c\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n\n    if (_PyObject_LookupAttrId(value, &PyId__as_parameter_, &as_parameter) < 0) {\n        return NULL;\n    }\n    if (as_parameter) {\n        value = c_char_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyObject *\nc_void_p_from_param(PyObject *type, PyObject *value)\n{\n    _Py_IDENTIFIER(_as_parameter_);\n    StgDictObject *stgd;\n    PyObject *as_parameter;\n    int res;\n\n/* None */\n    if (value == Py_None) {\n        Py_RETURN_NONE;\n    }\n    /* Should probably allow buffer interface as well */\n/* int, long */\n    if (PyLong_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"P\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'P';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    /* XXX struni: remove later */\n/* bytes */\n    if (PyBytes_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n/* unicode */\n    if (PyUnicode_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"Z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'Z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n/* c_void_p instance (or subclass) */\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        /* c_void_p instances */\n        Py_INCREF(value);\n        return value;\n    }\n/* ctypes array or pointer instance */\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* Any array or pointer is accepted */\n        Py_INCREF(value);\n        return value;\n    }\n/* byref(...) */\n    if (PyCArg_CheckExact(value)) {\n        /* byref(c_xxx()) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        if (a->tag == 'P') {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n/* function pointer */\n    if (PyCFuncPtrObject_Check(value)) {\n        PyCArgObject *parg;\n        PyCFuncPtrObject *func;\n        func = (PyCFuncPtrObject *)value;\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'P';\n        Py_INCREF(value);\n        parg->value.p = *(void **)func->b_ptr;\n        parg->obj = value;\n        return (PyObject *)parg;\n    }\n/* c_char_p, c_wchar_p */\n    stgd = PyObject_stgdict(value);\n    if (stgd && CDataObject_Check(value) && stgd->proto && PyUnicode_Check(stgd->proto)) {\n        PyCArgObject *parg;\n\n        switch (PyUnicode_AsUTF8(stgd->proto)[0]) {\n        case 'z': /* c_char_p */\n        case 'Z': /* c_wchar_p */\n            parg = PyCArgObject_new();\n            if (parg == NULL)\n                return NULL;\n            parg->pffi_type = &ffi_type_pointer;\n            parg->tag = 'Z';\n            Py_INCREF(value);\n            parg->obj = value;\n            /* Remember: b_ptr points to where the pointer is stored! */\n            parg->value.p = *(void **)(((CDataObject *)value)->b_ptr);\n            return (PyObject *)parg;\n        }\n    }\n\n    if (_PyObject_LookupAttrId(value, &PyId__as_parameter_, &as_parameter) < 0) {\n        return NULL;\n    }\n    if (as_parameter) {\n        value = c_void_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyMethodDef c_void_p_method = { \"from_param\", c_void_p_from_param, METH_O };\nstatic PyMethodDef c_char_p_method = { \"from_param\", c_char_p_from_param, METH_O };\nstatic PyMethodDef c_wchar_p_method = { \"from_param\", c_wchar_p_from_param, METH_O };\n\nstatic PyObject *CreateSwappedType(PyTypeObject *type, PyObject *args, PyObject *kwds,\n                                   PyObject *proto, struct fielddesc *fmt)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *name = PyTuple_GET_ITEM(args, 0);\n    PyObject *newname;\n    PyObject *swapped_args;\n    static PyObject *suffix;\n    Py_ssize_t i;\n\n    swapped_args = PyTuple_New(PyTuple_GET_SIZE(args));\n    if (!swapped_args)\n        return NULL;\n\n    if (suffix == NULL)\n#ifdef WORDS_BIGENDIAN\n        suffix = PyUnicode_InternFromString(\"_le\");\n#else\n        suffix = PyUnicode_InternFromString(\"_be\");\n#endif\n    if (suffix == NULL) {\n        Py_DECREF(swapped_args);\n        return NULL;\n    }\n\n    newname = PyUnicode_Concat(name, suffix);\n    if (newname == NULL) {\n        Py_DECREF(swapped_args);\n        return NULL;\n    }\n\n    PyTuple_SET_ITEM(swapped_args, 0, newname);\n    for (i=1; i<PyTuple_GET_SIZE(args); ++i) {\n        PyObject *v = PyTuple_GET_ITEM(args, i);\n        Py_INCREF(v);\n        PyTuple_SET_ITEM(swapped_args, i, v);\n    }\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, swapped_args, kwds);\n    Py_DECREF(swapped_args);\n    if (result == NULL)\n        return NULL;\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    stgdict->ffi_type_pointer = *fmt->pffi_type;\n    stgdict->align = fmt->pffi_type->alignment;\n    stgdict->length = 0;\n    stgdict->size = fmt->pffi_type->size;\n    stgdict->setfunc = fmt->setfunc_swapped;\n    stgdict->getfunc = fmt->getfunc_swapped;\n\n    Py_INCREF(proto);\n    stgdict->proto = proto;\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    return (PyObject *)result;\n}\n\nstatic PyCArgObject *\nPyCSimpleType_paramfunc(CDataObject *self)\n{\n    StgDictObject *dict;\n    const char *fmt;\n    PyCArgObject *parg;\n    struct fielddesc *fd;\n\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    fmt = PyUnicode_AsUTF8(dict->proto);\n    assert(fmt);\n\n    fd = _ctypes_get_fielddesc(fmt);\n    assert(fd);\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = fmt[0];\n    parg->pffi_type = fd->pffi_type;\n    Py_INCREF(self);\n    parg->obj = (PyObject *)self;\n    memcpy(&parg->value, self->b_ptr, self->b_size);\n    return parg;\n}\n\nstatic PyObject *\nPyCSimpleType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    _Py_IDENTIFIER(_type_);\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *proto;\n    const char *proto_str;\n    Py_ssize_t proto_len;\n    PyMethodDef *ml;\n    struct fielddesc *fmt;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL)\n        return NULL;\n\n    if (_PyObject_LookupAttrId((PyObject *)result, &PyId__type_, &proto) < 0) {\n        return NULL;\n    }\n    if (!proto) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_type_' attribute\");\n  error:\n        Py_XDECREF(proto);\n        Py_DECREF(result);\n        return NULL;\n    }\n    if (PyUnicode_Check(proto)) {\n        proto_str = PyUnicode_AsUTF8AndSize(proto, &proto_len);\n        if (!proto_str)\n            goto error;\n    } else {\n        PyErr_SetString(PyExc_TypeError,\n            \"class must define a '_type_' string attribute\");\n        goto error;\n    }\n    if (proto_len != 1) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"class must define a '_type_' attribute \"\n                        \"which must be a string of length 1\");\n        goto error;\n    }\n    if (!strchr(SIMPLE_TYPE_CHARS, *proto_str)) {\n        PyErr_Format(PyExc_AttributeError,\n                     \"class must define a '_type_' attribute which must be\\n\"\n                     \"a single character string containing one of '%s'.\",\n                     SIMPLE_TYPE_CHARS);\n        goto error;\n    }\n    fmt = _ctypes_get_fielddesc(proto_str);\n    if (fmt == NULL) {\n        PyErr_Format(PyExc_ValueError,\n                     \"_type_ '%s' not supported\", proto_str);\n        goto error;\n    }\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        goto error;\n\n    stgdict->ffi_type_pointer = *fmt->pffi_type;\n    stgdict->align = fmt->pffi_type->alignment;\n    stgdict->length = 0;\n    stgdict->size = fmt->pffi_type->size;\n    stgdict->setfunc = fmt->setfunc;\n    stgdict->getfunc = fmt->getfunc;\n#ifdef WORDS_BIGENDIAN\n    stgdict->format = _ctypes_alloc_format_string_for_type(proto_str[0], 1);\n#else\n    stgdict->format = _ctypes_alloc_format_string_for_type(proto_str[0], 0);\n#endif\n    if (stgdict->format == NULL) {\n        Py_DECREF(result);\n        Py_DECREF(proto);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    stgdict->paramfunc = PyCSimpleType_paramfunc;\n/*\n    if (result->tp_base != &Simple_Type) {\n        stgdict->setfunc = NULL;\n        stgdict->getfunc = NULL;\n    }\n*/\n\n    /* This consumes the refcount on proto which we have */\n    stgdict->proto = proto;\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    /* Install from_param class methods in ctypes base classes.\n       Overrides the PyCSimpleType_from_param generic method.\n     */\n    if (result->tp_base == &Simple_Type) {\n        switch (*proto_str) {\n        case 'z': /* c_char_p */\n            ml = &c_char_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 'Z': /* c_wchar_p */\n            ml = &c_wchar_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 'P': /* c_void_p */\n            ml = &c_void_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 's':\n        case 'X':\n        case 'O':\n            ml = NULL;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        default:\n            ml = NULL;\n            break;\n        }\n\n        if (ml) {\n            PyObject *meth;\n            int x;\n            meth = PyDescr_NewClassMethod(result, ml);\n            if (!meth) {\n                Py_DECREF(result);\n                return NULL;\n            }\n            x = PyDict_SetItemString(result->tp_dict,\n                                     ml->ml_name,\n                                     meth);\n            Py_DECREF(meth);\n            if (x == -1) {\n                Py_DECREF(result);\n                return NULL;\n            }\n        }\n    }\n\n    if (type == &PyCSimpleType_Type && fmt->setfunc_swapped && fmt->getfunc_swapped) {\n        PyObject *swapped = CreateSwappedType(type, args, kwds,\n                                              proto, fmt);\n        StgDictObject *sw_dict;\n        if (swapped == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        sw_dict = PyType_stgdict(swapped);\n#ifdef WORDS_BIGENDIAN\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_le__\", swapped);\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_be__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_be__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_le__\", swapped);\n        /* We are creating the type for the OTHER endian */\n        sw_dict->format = _ctypes_alloc_format_string(\"<\", stgdict->format+1);\n#else\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_be__\", swapped);\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_le__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_le__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_be__\", swapped);\n        /* We are creating the type for the OTHER endian */\n        sw_dict->format = _ctypes_alloc_format_string(\">\", stgdict->format+1);\n#endif\n        Py_DECREF(swapped);\n        if (PyErr_Occurred()) {\n            Py_DECREF(result);\n            return NULL;\n        }\n    };\n\n    return (PyObject *)result;\n}\n\n/*\n * This is a *class method*.\n * Convert a parameter into something that ConvParam can handle.\n */\nstatic PyObject *\nPyCSimpleType_from_param(PyObject *type, PyObject *value)\n{\n    _Py_IDENTIFIER(_as_parameter_);\n    StgDictObject *dict;\n    const char *fmt;\n    PyCArgObject *parg;\n    struct fielddesc *fd;\n    PyObject *as_parameter;\n    int res;\n\n    /* If the value is already an instance of the requested type,\n       we can use it as is */\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n\n    dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n\n    /* I think we can rely on this being a one-character string */\n    fmt = PyUnicode_AsUTF8(dict->proto);\n    assert(fmt);\n\n    fd = _ctypes_get_fielddesc(fmt);\n    assert(fd);\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = fmt[0];\n    parg->pffi_type = fd->pffi_type;\n    parg->obj = fd->setfunc(&parg->value, value, 0);\n    if (parg->obj)\n        return (PyObject *)parg;\n    PyErr_Clear();\n    Py_DECREF(parg);\n\n    if (_PyObject_LookupAttrId(value, &PyId__as_parameter_, &as_parameter) < 0) {\n        return NULL;\n    }\n    if (as_parameter) {\n        if (Py_EnterRecursiveCall(\"while processing _as_parameter_\")) {\n            Py_DECREF(as_parameter);\n            return NULL;\n        }\n        value = PyCSimpleType_from_param(type, as_parameter);\n        Py_LeaveRecursiveCall();\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyMethodDef PyCSimpleType_methods[] = {\n    { \"from_param\", PyCSimpleType_from_param, METH_O, from_param_doc },\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc},\n    { NULL, NULL },\n};\n\nPyTypeObject PyCSimpleType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCSimpleType\",                                    /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"metatype for the PyCSimpleType Objects\",           /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCSimpleType_methods,                      /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCSimpleType_new,                                  /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/******************************************************************/\n/*\n  PyCFuncPtrType_Type\n */\n\nstatic PyObject *\nconverters_from_argtypes(PyObject *ob)\n{\n    _Py_IDENTIFIER(from_param);\n    PyObject *converters;\n    Py_ssize_t i;\n    Py_ssize_t nArgs;\n\n    ob = PySequence_Tuple(ob); /* new reference */\n    if (!ob) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_argtypes_ must be a sequence of types\");\n        return NULL;\n    }\n\n    nArgs = PyTuple_GET_SIZE(ob);\n    converters = PyTuple_New(nArgs);\n    if (!converters) {\n        Py_DECREF(ob);\n        return NULL;\n    }\n\n    /* I have to check if this is correct. Using c_char, which has a size\n       of 1, will be assumed to be pushed as only one byte!\n       Aren't these promoted to integers by the C compiler and pushed as 4 bytes?\n    */\n\n    for (i = 0; i < nArgs; ++i) {\n        PyObject *cnv;\n        PyObject *tp = PyTuple_GET_ITEM(ob, i);\n/*\n *      The following checks, relating to bpo-16575 and bpo-16576, have been\n *      disabled. The reason is that, although there is a definite problem with\n *      how libffi handles unions (https://github.com/libffi/libffi/issues/33),\n *      there are numerous libraries which pass structures containing unions\n *      by values - especially on Windows but examples also exist on Linux\n *      (https://bugs.python.org/msg359834).\n *\n *      It may not be possible to get proper support for unions and bitfields\n *      until support is forthcoming in libffi, but for now, adding the checks\n *      has caused problems in otherwise-working software, which suggests it\n *      is better to disable the checks.\n *\n *      Although specific examples reported relate specifically to unions and\n *      not bitfields, the bitfields check is also being disabled as a\n *      precaution.\n\n        StgDictObject *stgdict = PyType_stgdict(tp);\n\n        if (stgdict != NULL) {\n            if (stgdict->flags & TYPEFLAG_HASUNION) {\n                Py_DECREF(converters);\n                Py_DECREF(ob);\n                if (!PyErr_Occurred()) {\n                    PyErr_Format(PyExc_TypeError,\n                                 \"item %zd in _argtypes_ passes a union by \"\n                                 \"value, which is unsupported.\",\n                                 i + 1);\n                }\n                return NULL;\n            }\n            if (stgdict->flags & TYPEFLAG_HASBITFIELD) {\n                Py_DECREF(converters);\n                Py_DECREF(ob);\n                if (!PyErr_Occurred()) {\n                    PyErr_Format(PyExc_TypeError,\n                                 \"item %zd in _argtypes_ passes a struct/\"\n                                 \"union with a bitfield by value, which is \"\n                                 \"unsupported.\",\n                                 i + 1);\n                }\n                return NULL;\n            }\n        }\n */\n\n        if (_PyObject_LookupAttrId(tp, &PyId_from_param, &cnv) <= 0) {\n            Py_DECREF(converters);\n            Py_DECREF(ob);\n            if (!PyErr_Occurred()) {\n                PyErr_Format(PyExc_TypeError,\n                             \"item %zd in _argtypes_ has no from_param method\",\n                             i+1);\n            }\n            return NULL;\n        }\n        PyTuple_SET_ITEM(converters, i, cnv);\n    }\n    Py_DECREF(ob);\n    return converters;\n}\n\nstatic int\nmake_funcptrtype_dict(StgDictObject *stgdict)\n{\n    PyObject *ob;\n    PyObject *converters = NULL;\n    _Py_IDENTIFIER(_flags_);\n    _Py_IDENTIFIER(_argtypes_);\n    _Py_IDENTIFIER(_restype_);\n    _Py_IDENTIFIER(_check_retval_);\n\n    stgdict->align = _ctypes_get_fielddesc(\"P\")->pffi_type->alignment;\n    stgdict->length = 1;\n    stgdict->size = sizeof(void *);\n    stgdict->setfunc = NULL;\n    stgdict->getfunc = NULL;\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n\n    ob = _PyDict_GetItemIdWithError((PyObject *)stgdict, &PyId__flags_);\n    if (!ob || !PyLong_Check(ob)) {\n        if (!PyErr_Occurred()) {\n            PyErr_SetString(PyExc_TypeError,\n                \"class must define _flags_ which must be an integer\");\n        }\n        return -1;\n    }\n    stgdict->flags = PyLong_AsUnsignedLongMask(ob) | TYPEFLAG_ISPOINTER;\n\n    /* _argtypes_ is optional... */\n    ob = _PyDict_GetItemIdWithError((PyObject *)stgdict, &PyId__argtypes_);\n    if (ob) {\n        converters = converters_from_argtypes(ob);\n        if (!converters)\n            return -1;\n        Py_INCREF(ob);\n        stgdict->argtypes = ob;\n        stgdict->converters = converters;\n    }\n    else if (PyErr_Occurred()) {\n        return -1;\n    }\n\n    ob = _PyDict_GetItemIdWithError((PyObject *)stgdict, &PyId__restype_);\n    if (ob) {\n        if (ob != Py_None && !PyType_stgdict(ob) && !PyCallable_Check(ob)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"_restype_ must be a type, a callable, or None\");\n            return -1;\n        }\n        Py_INCREF(ob);\n        stgdict->restype = ob;\n        if (_PyObject_LookupAttrId(ob, &PyId__check_retval_,\n                                   &stgdict->checker) < 0)\n        {\n            return -1;\n        }\n    }\n    else if (PyErr_Occurred()) {\n        return -1;\n    }\n/* XXX later, maybe.\n    ob = _PyDict_GetItemIdWithError((PyObject *)stgdict, &PyId__errcheck_);\n    if (ob) {\n        if (!PyCallable_Check(ob)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"_errcheck_ must be callable\");\n            return -1;\n        }\n        Py_INCREF(ob);\n        stgdict->errcheck = ob;\n    }\n    else if (PyErr_Occurred()) {\n        return -1;\n    }\n*/\n    return 0;\n}\n\nstatic PyCArgObject *\nPyCFuncPtrType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    Py_INCREF(self);\n    parg->obj = (PyObject *)self;\n    parg->value.p = *(void **)self->b_ptr;\n    return parg;\n}\n\nstatic PyObject *\nPyCFuncPtrType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        return NULL;\n\n    stgdict->paramfunc = PyCFuncPtrType_paramfunc;\n    /* We do NOT expose the function signature in the format string.  It\n       is impossible, generally, because the only requirement for the\n       argtypes items is that they have a .from_param method - we do not\n       know the types of the arguments (although, in practice, most\n       argtypes would be a ctypes type).\n    */\n    stgdict->format = _ctypes_alloc_format_string(NULL, \"X{}\");\n    if (stgdict->format == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    stgdict->flags |= TYPEFLAG_ISPOINTER;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    /* replace the class dict by our updated storage dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_SETREF(result->tp_dict, (PyObject *)stgdict);\n\n    if (-1 == make_funcptrtype_dict(stgdict)) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    return (PyObject *)result;\n}\n\nPyTypeObject PyCFuncPtrType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCFuncPtrType\",                           /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for C function pointers\",         /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCFuncPtrType_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/*****************************************************************\n * Code to keep needed objects alive\n */\n\nstatic CDataObject *\nPyCData_GetContainer(CDataObject *self)\n{\n    while (self->b_base)\n        self = self->b_base;\n    if (self->b_objects == NULL) {\n        if (self->b_length) {\n            self->b_objects = PyDict_New();\n            if (self->b_objects == NULL)\n                return NULL;\n        } else {\n            Py_INCREF(Py_None);\n            self->b_objects = Py_None;\n        }\n    }\n    return self;\n}\n\nstatic PyObject *\nGetKeepedObjects(CDataObject *target)\n{\n    CDataObject *container;\n    container = PyCData_GetContainer(target);\n    if (container == NULL)\n        return NULL;\n    return container->b_objects;\n}\n\nstatic PyObject *\nunique_key(CDataObject *target, Py_ssize_t index)\n{\n    char string[256];\n    char *cp = string;\n    size_t bytes_left;\n\n    Py_BUILD_ASSERT(sizeof(string) - 1 > sizeof(Py_ssize_t) * 2);\n    cp += sprintf(cp, \"%x\", Py_SAFE_DOWNCAST(index, Py_ssize_t, int));\n    while (target->b_base) {\n        bytes_left = sizeof(string) - (cp - string) - 1;\n        /* Hex format needs 2 characters per byte */\n        if (bytes_left < sizeof(Py_ssize_t) * 2) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"ctypes object structure too deep\");\n            return NULL;\n        }\n        cp += sprintf(cp, \":%x\", Py_SAFE_DOWNCAST(target->b_index, Py_ssize_t, int));\n        target = target->b_base;\n    }\n    return PyUnicode_FromStringAndSize(string, cp-string);\n}\n\n/*\n * Keep a reference to 'keep' in the 'target', at index 'index'.\n *\n * If 'keep' is None, do nothing.\n *\n * Otherwise create a dictionary (if it does not yet exist) id the root\n * objects 'b_objects' item, which will store the 'keep' object under a unique\n * key.\n *\n * The unique_key helper travels the target's b_base pointer down to the root,\n * building a string containing hex-formatted indexes found during traversal,\n * separated by colons.\n *\n * The index tuple is used as a key into the root object's b_objects dict.\n *\n * Note: This function steals a refcount of the third argument, even if it\n * fails!\n */\nstatic int\nKeepRef(CDataObject *target, Py_ssize_t index, PyObject *keep)\n{\n    int result;\n    CDataObject *ob;\n    PyObject *key;\n\n/* Optimization: no need to store None */\n    if (keep == Py_None) {\n        Py_DECREF(Py_None);\n        return 0;\n    }\n    ob = PyCData_GetContainer(target);\n    if (ob == NULL) {\n        Py_DECREF(keep);\n        return -1;\n    }\n    if (ob->b_objects == NULL || !PyDict_CheckExact(ob->b_objects)) {\n        Py_XSETREF(ob->b_objects, keep); /* refcount consumed */\n        return 0;\n    }\n    key = unique_key(target, index);\n    if (key == NULL) {\n        Py_DECREF(keep);\n        return -1;\n    }\n    result = PyDict_SetItem(ob->b_objects, key, keep);\n    Py_DECREF(key);\n    Py_DECREF(keep);\n    return result;\n}\n\n/******************************************************************/\n/*\n  PyCData_Type\n */\nstatic int\nPyCData_traverse(CDataObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->b_objects);\n    Py_VISIT((PyObject *)self->b_base);\n    return 0;\n}\n\nstatic int\nPyCData_clear(CDataObject *self)\n{\n    Py_CLEAR(self->b_objects);\n    if ((self->b_needsfree)\n        && _CDataObject_HasExternalBuffer(self))\n        PyMem_Free(self->b_ptr);\n    self->b_ptr = NULL;\n    Py_CLEAR(self->b_base);\n    return 0;\n}\n\nstatic void\nPyCData_dealloc(PyObject *self)\n{\n    PyCData_clear((CDataObject *)self);\n    Py_TYPE(self)->tp_free(self);\n}\n\nstatic PyMemberDef PyCData_members[] = {\n    { \"_b_base_\", T_OBJECT,\n      offsetof(CDataObject, b_base), READONLY,\n      \"the base object\" },\n    { \"_b_needsfree_\", T_INT,\n      offsetof(CDataObject, b_needsfree), READONLY,\n      \"whether the object owns the memory or not\" },\n    { \"_objects\", T_OBJECT,\n      offsetof(CDataObject, b_objects), READONLY,\n      \"internal objects tree (NEVER CHANGE THIS OBJECT!)\"},\n    { NULL },\n};\n\nstatic int PyCData_NewGetBuffer(PyObject *myself, Py_buffer *view, int flags)\n{\n    CDataObject *self = (CDataObject *)myself;\n    StgDictObject *dict = PyObject_stgdict(myself);\n    Py_ssize_t i;\n\n    if (view == NULL) return 0;\n\n    view->buf = self->b_ptr;\n    view->obj = myself;\n    Py_INCREF(myself);\n    view->len = self->b_size;\n    view->readonly = 0;\n    /* use default format character if not set */\n    view->format = dict->format ? dict->format : \"B\";\n    view->ndim = dict->ndim;\n    view->shape = dict->shape;\n    view->itemsize = self->b_size;\n    if (view->itemsize) {\n        for (i = 0; i < view->ndim; ++i) {\n            view->itemsize /= dict->shape[i];\n        }\n    }\n    view->strides = NULL;\n    view->suboffsets = NULL;\n    view->internal = NULL;\n    return 0;\n}\n\nstatic PyBufferProcs PyCData_as_buffer = {\n    PyCData_NewGetBuffer,\n    NULL,\n};\n\n/*\n * CData objects are mutable, so they cannot be hashable!\n */\nstatic Py_hash_t\nPyCData_nohash(PyObject *self)\n{\n    PyErr_SetString(PyExc_TypeError, \"unhashable type\");\n    return -1;\n}\n\nstatic PyObject *\nPyCData_reduce(PyObject *myself, PyObject *args)\n{\n    CDataObject *self = (CDataObject *)myself;\n\n    if (PyObject_stgdict(myself)->flags & (TYPEFLAG_ISPOINTER|TYPEFLAG_HASPOINTER)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"ctypes objects containing pointers cannot be pickled\");\n        return NULL;\n    }\n    PyObject *dict = PyObject_GetAttrString(myself, \"__dict__\");\n    if (dict == NULL) {\n        return NULL;\n    }\n    return Py_BuildValue(\"O(O(NN))\", _unpickle, Py_TYPE(myself), dict,\n                         PyBytes_FromStringAndSize(self->b_ptr, self->b_size));\n}\n\nstatic PyObject *\nPyCData_setstate(PyObject *myself, PyObject *args)\n{\n    void *data;\n    Py_ssize_t len;\n    int res;\n    PyObject *dict, *mydict;\n    CDataObject *self = (CDataObject *)myself;\n    if (!PyArg_ParseTuple(args, \"O!s#\",\n                          &PyDict_Type, &dict, &data, &len))\n    {\n        return NULL;\n    }\n    if (len > self->b_size)\n        len = self->b_size;\n    memmove(self->b_ptr, data, len);\n    mydict = PyObject_GetAttrString(myself, \"__dict__\");\n    if (mydict == NULL) {\n        return NULL;\n    }\n    if (!PyDict_Check(mydict)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"%.200s.__dict__ must be a dictionary, not %.200s\",\n                     Py_TYPE(myself)->tp_name, Py_TYPE(mydict)->tp_name);\n        Py_DECREF(mydict);\n        return NULL;\n    }\n    res = PyDict_Update(mydict, dict);\n    Py_DECREF(mydict);\n    if (res == -1)\n        return NULL;\n    Py_RETURN_NONE;\n}\n\n/*\n * default __ctypes_from_outparam__ method returns self.\n */\nstatic PyObject *\nPyCData_from_outparam(PyObject *self, PyObject *args)\n{\n    Py_INCREF(self);\n    return self;\n}\n\nstatic PyMethodDef PyCData_methods[] = {\n    { \"__ctypes_from_outparam__\", PyCData_from_outparam, METH_NOARGS, },\n    { \"__reduce__\", PyCData_reduce, METH_NOARGS, },\n    { \"__setstate__\", PyCData_setstate, METH_VARARGS, },\n    { NULL, NULL },\n};\n\nPyTypeObject PyCData_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._CData\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    PyCData_dealloc,                                    /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    PyCData_nohash,                             /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCData_methods,                                    /* tp_methods */\n    PyCData_members,                                    /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic int PyCData_MallocBuffer(CDataObject *obj, StgDictObject *dict)\n{\n    if ((size_t)dict->size <= sizeof(obj->b_value)) {\n        /* No need to call malloc, can use the default buffer */\n        obj->b_ptr = (char *)&obj->b_value;\n        /* The b_needsfree flag does not mean that we actually did\n           call PyMem_Malloc to allocate the memory block; instead it\n           means we are the *owner* of the memory and are responsible\n           for freeing resources associated with the memory.  This is\n           also the reason that b_needsfree is exposed to Python.\n         */\n        obj->b_needsfree = 1;\n    } else {\n        /* In python 2.4, and ctypes 0.9.6, the malloc call took about\n           33% of the creation time for c_int().\n        */\n        obj->b_ptr = (char *)PyMem_Malloc(dict->size);\n        if (obj->b_ptr == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        obj->b_needsfree = 1;\n        memset(obj->b_ptr, 0, dict->size);\n    }\n    obj->b_size = dict->size;\n    return 0;\n}\n\nPyObject *\nPyCData_FromBaseObj(PyObject *type, PyObject *base, Py_ssize_t index, char *adr)\n{\n    CDataObject *cmem;\n    StgDictObject *dict;\n\n    assert(PyType_Check(type));\n    dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n    cmem = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);\n    if (cmem == NULL)\n        return NULL;\n    assert(CDataObject_Check(cmem));\n\n    cmem->b_length = dict->length;\n    cmem->b_size = dict->size;\n    if (base) { /* use base's buffer */\n        assert(CDataObject_Check(base));\n        cmem->b_ptr = adr;\n        cmem->b_needsfree = 0;\n        Py_INCREF(base);\n        cmem->b_base = (CDataObject *)base;\n        cmem->b_index = index;\n    } else { /* copy contents of adr */\n        if (-1 == PyCData_MallocBuffer(cmem, dict)) {\n            Py_DECREF(cmem);\n            return NULL;\n        }\n        memcpy(cmem->b_ptr, adr, dict->size);\n        cmem->b_index = index;\n    }\n    return (PyObject *)cmem;\n}\n\n/*\n Box a memory block into a CData instance.\n*/\nPyObject *\nPyCData_AtAddress(PyObject *type, void *buf)\n{\n    CDataObject *pd;\n    StgDictObject *dict;\n\n    if (PySys_Audit(\"ctypes.cdata\", \"n\", (Py_ssize_t)buf) < 0) {\n        return NULL;\n    }\n\n    assert(PyType_Check(type));\n    dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n\n    pd = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);\n    if (!pd)\n        return NULL;\n    assert(CDataObject_Check(pd));\n    pd->b_ptr = (char *)buf;\n    pd->b_length = dict->length;\n    pd->b_size = dict->size;\n    return (PyObject *)pd;\n}\n\n/*\n  This function returns TRUE for c_int, c_void_p, and these kind of\n  classes.  FALSE otherwise FALSE also for subclasses of c_int and\n  such.\n*/\nint _ctypes_simple_instance(PyObject *obj)\n{\n    PyTypeObject *type = (PyTypeObject *)obj;\n\n    if (PyCSimpleTypeObject_Check(type))\n        return type->tp_base != &Simple_Type;\n    return 0;\n}\n\nPyObject *\nPyCData_get(PyObject *type, GETFUNC getfunc, PyObject *src,\n          Py_ssize_t index, Py_ssize_t size, char *adr)\n{\n    StgDictObject *dict;\n    if (getfunc)\n        return getfunc(adr, size);\n    assert(type);\n    dict = PyType_stgdict(type);\n    if (dict && dict->getfunc && !_ctypes_simple_instance(type))\n        return dict->getfunc(adr, size);\n    return PyCData_FromBaseObj(type, src, index, adr);\n}\n\n/*\n  Helper function for PyCData_set below.\n*/\nstatic PyObject *\n_PyCData_set(CDataObject *dst, PyObject *type, SETFUNC setfunc, PyObject *value,\n           Py_ssize_t size, char *ptr)\n{\n    CDataObject *src;\n    int err;\n\n    if (setfunc)\n        return setfunc(ptr, value, size);\n\n    if (!CDataObject_Check(value)) {\n        StgDictObject *dict = PyType_stgdict(type);\n        if (dict && dict->setfunc)\n            return dict->setfunc(ptr, value, size);\n        /*\n           If value is a tuple, we try to call the type with the tuple\n           and use the result!\n        */\n        assert(PyType_Check(type));\n        if (PyTuple_Check(value)) {\n            PyObject *ob;\n            PyObject *result;\n            ob = PyObject_CallObject(type, value);\n            if (ob == NULL) {\n                _ctypes_extend_error(PyExc_RuntimeError, \"(%s) \",\n                                  ((PyTypeObject *)type)->tp_name);\n                return NULL;\n            }\n            result = _PyCData_set(dst, type, setfunc, ob,\n                                size, ptr);\n            Py_DECREF(ob);\n            return result;\n        } else if (value == Py_None && PyCPointerTypeObject_Check(type)) {\n            *(void **)ptr = NULL;\n            Py_RETURN_NONE;\n        } else {\n            PyErr_Format(PyExc_TypeError,\n                         \"expected %s instance, got %s\",\n                         ((PyTypeObject *)type)->tp_name,\n                         Py_TYPE(value)->tp_name);\n            return NULL;\n        }\n    }\n    src = (CDataObject *)value;\n\n    err = PyObject_IsInstance(value, type);\n    if (err == -1)\n        return NULL;\n    if (err) {\n        memcpy(ptr,\n               src->b_ptr,\n               size);\n\n        if (PyCPointerTypeObject_Check(type)) {\n            /* XXX */\n        }\n\n        value = GetKeepedObjects(src);\n        if (value == NULL)\n            return NULL;\n\n        Py_INCREF(value);\n        return value;\n    }\n\n    if (PyCPointerTypeObject_Check(type)\n        && ArrayObject_Check(value)) {\n        StgDictObject *p1, *p2;\n        PyObject *keep;\n        p1 = PyObject_stgdict(value);\n        assert(p1); /* Cannot be NULL for array instances */\n        p2 = PyType_stgdict(type);\n        assert(p2); /* Cannot be NULL for pointer types */\n\n        if (p1->proto != p2->proto) {\n            PyErr_Format(PyExc_TypeError,\n                         \"incompatible types, %s instance instead of %s instance\",\n                         Py_TYPE(value)->tp_name,\n                         ((PyTypeObject *)type)->tp_name);\n            return NULL;\n        }\n        *(void **)ptr = src->b_ptr;\n\n        keep = GetKeepedObjects(src);\n        if (keep == NULL)\n            return NULL;\n\n        /*\n          We are assigning an array object to a field which represents\n          a pointer. This has the same effect as converting an array\n          into a pointer. So, again, we have to keep the whole object\n          pointed to (which is the array in this case) alive, and not\n          only it's object list.  So we create a tuple, containing\n          b_objects list PLUS the array itself, and return that!\n        */\n        return PyTuple_Pack(2, keep, value);\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"incompatible types, %s instance instead of %s instance\",\n                 Py_TYPE(value)->tp_name,\n                 ((PyTypeObject *)type)->tp_name);\n    return NULL;\n}\n\n/*\n * Set a slice in object 'dst', which has the type 'type',\n * to the value 'value'.\n */\nint\nPyCData_set(PyObject *dst, PyObject *type, SETFUNC setfunc, PyObject *value,\n          Py_ssize_t index, Py_ssize_t size, char *ptr)\n{\n    CDataObject *mem = (CDataObject *)dst;\n    PyObject *result;\n\n    if (!CDataObject_Check(dst)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"not a ctype instance\");\n        return -1;\n    }\n\n    result = _PyCData_set(mem, type, setfunc, value,\n                        size, ptr);\n    if (result == NULL)\n        return -1;\n\n    /* KeepRef steals a refcount from it's last argument */\n    /* If KeepRef fails, we are stumped.  The dst memory block has already\n       been changed */\n    return KeepRef(mem, index, result);\n}\n\n\n/******************************************************************/\nstatic PyObject *\nGenericPyCData_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    CDataObject *obj;\n    StgDictObject *dict;\n\n    dict = PyType_stgdict((PyObject *)type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n\n    obj = (CDataObject *)type->tp_alloc(type, 0);\n    if (!obj)\n        return NULL;\n\n    obj->b_base = NULL;\n    obj->b_index = 0;\n    obj->b_objects = NULL;\n    obj->b_length = dict->length;\n\n    if (-1 == PyCData_MallocBuffer(obj, dict)) {\n        Py_DECREF(obj);\n        return NULL;\n    }\n    return (PyObject *)obj;\n}\n/*****************************************************************/\n/*\n  PyCFuncPtr_Type\n*/\n\nstatic int\nPyCFuncPtr_set_errcheck(PyCFuncPtrObject *self, PyObject *ob, void *Py_UNUSED(ignored))\n{\n    if (ob && !PyCallable_Check(ob)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the errcheck attribute must be callable\");\n        return -1;\n    }\n    Py_XINCREF(ob);\n    Py_XSETREF(self->errcheck, ob);\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_errcheck(PyCFuncPtrObject *self, void *Py_UNUSED(ignored))\n{\n    if (self->errcheck) {\n        Py_INCREF(self->errcheck);\n        return self->errcheck;\n    }\n    Py_RETURN_NONE;\n}\n\nstatic int\nPyCFuncPtr_set_restype(PyCFuncPtrObject *self, PyObject *ob, void *Py_UNUSED(ignored))\n{\n    _Py_IDENTIFIER(_check_retval_);\n    PyObject *checker, *oldchecker;\n    if (ob == NULL) {\n        oldchecker = self->checker;\n        self->checker = NULL;\n        Py_CLEAR(self->restype);\n        Py_XDECREF(oldchecker);\n        return 0;\n    }\n    if (ob != Py_None && !PyType_stgdict(ob) && !PyCallable_Check(ob)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"restype must be a type, a callable, or None\");\n        return -1;\n    }\n    if (_PyObject_LookupAttrId(ob, &PyId__check_retval_, &checker) < 0) {\n        return -1;\n    }\n    oldchecker = self->checker;\n    self->checker = checker;\n    Py_INCREF(ob);\n    Py_XSETREF(self->restype, ob);\n    Py_XDECREF(oldchecker);\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_restype(PyCFuncPtrObject *self, void *Py_UNUSED(ignored))\n{\n    StgDictObject *dict;\n    if (self->restype) {\n        Py_INCREF(self->restype);\n        return self->restype;\n    }\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    if (dict->restype) {\n        Py_INCREF(dict->restype);\n        return dict->restype;\n    } else {\n        Py_RETURN_NONE;\n    }\n}\n\nstatic int\nPyCFuncPtr_set_argtypes(PyCFuncPtrObject *self, PyObject *ob, void *Py_UNUSED(ignored))\n{\n    PyObject *converters;\n\n    if (ob == NULL || ob == Py_None) {\n        Py_CLEAR(self->converters);\n        Py_CLEAR(self->argtypes);\n    } else {\n        converters = converters_from_argtypes(ob);\n        if (!converters)\n            return -1;\n        Py_XSETREF(self->converters, converters);\n        Py_INCREF(ob);\n        Py_XSETREF(self->argtypes, ob);\n    }\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_argtypes(PyCFuncPtrObject *self, void *Py_UNUSED(ignored))\n{\n    StgDictObject *dict;\n    if (self->argtypes) {\n        Py_INCREF(self->argtypes);\n        return self->argtypes;\n    }\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    if (dict->argtypes) {\n        Py_INCREF(dict->argtypes);\n        return dict->argtypes;\n    } else {\n        Py_RETURN_NONE;\n    }\n}\n\nstatic PyGetSetDef PyCFuncPtr_getsets[] = {\n    { \"errcheck\", (getter)PyCFuncPtr_get_errcheck, (setter)PyCFuncPtr_set_errcheck,\n      \"a function to check for errors\", NULL },\n    { \"restype\", (getter)PyCFuncPtr_get_restype, (setter)PyCFuncPtr_set_restype,\n      \"specify the result type\", NULL },\n    { \"argtypes\", (getter)PyCFuncPtr_get_argtypes,\n      (setter)PyCFuncPtr_set_argtypes,\n      \"specify the argument types\", NULL },\n    { NULL, NULL }\n};\n\n#ifdef MS_WIN32\nstatic PPROC FindAddress(void *handle, const char *name, PyObject *type)\n{\n    PPROC address;\n#ifdef MS_WIN64\n    /* win64 has no stdcall calling conv, so it should\n       also not have the name mangling of it.\n    */\n    Py_BEGIN_ALLOW_THREADS\n    address = (PPROC)GetProcAddress(handle, name);\n    Py_END_ALLOW_THREADS\n    return address;\n#else\n    char *mangled_name;\n    int i;\n    StgDictObject *dict;\n\n    Py_BEGIN_ALLOW_THREADS\n    address = (PPROC)GetProcAddress(handle, name);\n    Py_END_ALLOW_THREADS\n    if (address)\n        return address;\n    if (((size_t)name & ~0xFFFF) == 0) {\n        return NULL;\n    }\n\n    dict = PyType_stgdict((PyObject *)type);\n    /* It should not happen that dict is NULL, but better be safe */\n    if (dict==NULL || dict->flags & FUNCFLAG_CDECL)\n        return address;\n\n    /* for stdcall, try mangled names:\n       funcname -> _funcname@<n>\n       where n is 0, 4, 8, 12, ..., 128\n     */\n    mangled_name = alloca(strlen(name) + 1 + 1 + 1 + 3); /* \\0 _ @ %d */\n    if (!mangled_name)\n        return NULL;\n    for (i = 0; i < 32; ++i) {\n        sprintf(mangled_name, \"_%s@%d\", name, i*4);\n        Py_BEGIN_ALLOW_THREADS\n        address = (PPROC)GetProcAddress(handle, mangled_name);\n        Py_END_ALLOW_THREADS\n        if (address)\n            return address;\n    }\n    return NULL;\n#endif\n}\n#endif\n\n/* Return 1 if usable, 0 else and exception set. */\nstatic int\n_check_outarg_type(PyObject *arg, Py_ssize_t index)\n{\n    StgDictObject *dict;\n\n    if (PyCPointerTypeObject_Check(arg))\n        return 1;\n\n    if (PyCArrayTypeObject_Check(arg))\n        return 1;\n\n    dict = PyType_stgdict(arg);\n    if (dict\n        /* simple pointer types, c_void_p, c_wchar_p, BSTR, ... */\n        && PyUnicode_Check(dict->proto)\n/* We only allow c_void_p, c_char_p and c_wchar_p as a simple output parameter type */\n        && (strchr(\"PzZ\", PyUnicode_AsUTF8(dict->proto)[0]))) {\n        return 1;\n    }\n\n    PyErr_Format(PyExc_TypeError,\n                 \"'out' parameter %d must be a pointer type, not %s\",\n                 Py_SAFE_DOWNCAST(index, Py_ssize_t, int),\n                 PyType_Check(arg) ?\n                 ((PyTypeObject *)arg)->tp_name :\n             Py_TYPE(arg)->tp_name);\n    return 0;\n}\n\n/* Returns 1 on success, 0 on error */\nstatic int\n_validate_paramflags(PyTypeObject *type, PyObject *paramflags)\n{\n    Py_ssize_t i, len;\n    StgDictObject *dict;\n    PyObject *argtypes;\n\n    dict = PyType_stgdict((PyObject *)type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return 0;\n    }\n    argtypes = dict->argtypes;\n\n    if (paramflags == NULL || dict->argtypes == NULL)\n        return 1;\n\n    if (!PyTuple_Check(paramflags)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"paramflags must be a tuple or None\");\n        return 0;\n    }\n\n    len = PyTuple_GET_SIZE(paramflags);\n    if (len != PyTuple_GET_SIZE(dict->argtypes)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"paramflags must have the same length as argtypes\");\n        return 0;\n    }\n\n    for (i = 0; i < len; ++i) {\n        PyObject *item = PyTuple_GET_ITEM(paramflags, i);\n        int flag;\n        char *name;\n        PyObject *defval;\n        PyObject *typ;\n        if (!PyArg_ParseTuple(item, \"i|ZO\", &flag, &name, &defval)) {\n            PyErr_SetString(PyExc_TypeError,\n                   \"paramflags must be a sequence of (int [,string [,value]]) tuples\");\n            return 0;\n        }\n        typ = PyTuple_GET_ITEM(argtypes, i);\n        switch (flag & (PARAMFLAG_FIN | PARAMFLAG_FOUT | PARAMFLAG_FLCID)) {\n        case 0:\n        case PARAMFLAG_FIN:\n        case PARAMFLAG_FIN | PARAMFLAG_FLCID:\n        case PARAMFLAG_FIN | PARAMFLAG_FOUT:\n            break;\n        case PARAMFLAG_FOUT:\n            if (!_check_outarg_type(typ, i+1))\n                return 0;\n            break;\n        default:\n            PyErr_Format(PyExc_TypeError,\n                         \"paramflag value %d not supported\",\n                         flag);\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic int\n_get_name(PyObject *obj, const char **pname)\n{\n#ifdef MS_WIN32\n    if (PyLong_Check(obj)) {\n        /* We have to use MAKEINTRESOURCEA for Windows CE.\n           Works on Windows as well, of course.\n        */\n        *pname = MAKEINTRESOURCEA(PyLong_AsUnsignedLongMask(obj) & 0xFFFF);\n        return 1;\n    }\n#endif\n    if (PyBytes_Check(obj)) {\n        *pname = PyBytes_AS_STRING(obj);\n        return *pname ? 1 : 0;\n    }\n    if (PyUnicode_Check(obj)) {\n        *pname = PyUnicode_AsUTF8(obj);\n        return *pname ? 1 : 0;\n    }\n    PyErr_SetString(PyExc_TypeError,\n                    \"function name must be string, bytes object or integer\");\n    return 0;\n}\n\n\nstatic PyObject *\nPyCFuncPtr_FromDll(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    const char *name;\n    int (* address)(void);\n    PyObject *ftuple;\n    PyObject *dll;\n    PyObject *obj;\n    PyCFuncPtrObject *self;\n    void *handle;\n    PyObject *paramflags = NULL;\n\n    if (!PyArg_ParseTuple(args, \"O|O\", &ftuple, &paramflags))\n        return NULL;\n    if (paramflags == Py_None)\n        paramflags = NULL;\n\n    ftuple = PySequence_Tuple(ftuple);\n    if (!ftuple)\n        /* Here ftuple is a borrowed reference */\n        return NULL;\n\n    if (!PyArg_ParseTuple(ftuple, \"O&O;illegal func_spec argument\",\n                          _get_name, &name, &dll))\n    {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n#ifdef MS_WIN32\n    if (PySys_Audit(\"ctypes.dlsym\",\n                    ((uintptr_t)name & ~0xFFFF) ? \"Os\" : \"On\",\n                    dll, name) < 0) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n#else\n    if (PySys_Audit(\"ctypes.dlsym\", \"Os\", dll, name) < 0) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n#endif\n\n    obj = PyObject_GetAttrString(dll, \"_handle\");\n    if (!obj) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n    if (!PyLong_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the _handle attribute of the second argument must be an integer\");\n        Py_DECREF(ftuple);\n        Py_DECREF(obj);\n        return NULL;\n    }\n    handle = (void *)PyLong_AsVoidPtr(obj);\n    Py_DECREF(obj);\n    if (PyErr_Occurred()) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"could not convert the _handle attribute to a pointer\");\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n#ifdef MS_WIN32\n    address = FindAddress(handle, name, (PyObject *)type);\n    if (!address) {\n        if (!IS_INTRESOURCE(name))\n            PyErr_Format(PyExc_AttributeError,\n                         \"function '%s' not found\",\n                         name);\n        else\n            PyErr_Format(PyExc_AttributeError,\n                         \"function ordinal %d not found\",\n                         (WORD)(size_t)name);\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n#else\n    address = (PPROC)ctypes_dlsym(handle, name);\n    if (!address) {\n#ifdef __CYGWIN__\n/* dlerror() isn't very helpful on cygwin */\n        PyErr_Format(PyExc_AttributeError,\n                     \"function '%s' not found\",\n                     name);\n#else\n        PyErr_SetString(PyExc_AttributeError, ctypes_dlerror());\n#endif\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n#endif\n    if (!_validate_paramflags(type, paramflags)) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    if (!self) {\n        Py_DECREF(ftuple);\n        return NULL;\n    }\n\n    Py_XINCREF(paramflags);\n    self->paramflags = paramflags;\n\n    *(void **)self->b_ptr = address;\n    Py_INCREF(dll);\n    Py_DECREF(ftuple);\n    if (-1 == KeepRef((CDataObject *)self, 0, dll)) {\n        Py_DECREF((PyObject *)self);\n        return NULL;\n    }\n\n    Py_INCREF(self);\n    self->callable = (PyObject *)self;\n    return (PyObject *)self;\n}\n\n#ifdef MS_WIN32\nstatic PyObject *\nPyCFuncPtr_FromVtblIndex(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyCFuncPtrObject *self;\n    int index;\n    char *name = NULL;\n    PyObject *paramflags = NULL;\n    GUID *iid = NULL;\n    Py_ssize_t iid_len = 0;\n\n    if (!PyArg_ParseTuple(args, \"is|Oz#\", &index, &name, &paramflags, &iid, &iid_len))\n        return NULL;\n    if (paramflags == Py_None)\n        paramflags = NULL;\n\n    if (!_validate_paramflags(type, paramflags))\n        return NULL;\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    self->index = index + 0x1000;\n    Py_XINCREF(paramflags);\n    self->paramflags = paramflags;\n    if (iid_len == sizeof(GUID))\n        self->iid = iid;\n    return (PyObject *)self;\n}\n#endif\n\n/*\n  PyCFuncPtr_new accepts different argument lists in addition to the standard\n  _basespec_ keyword arg:\n\n  one argument form\n  \"i\" - function address\n  \"O\" - must be a callable, creates a C callable function\n\n  two or more argument forms (the third argument is a paramflags tuple)\n  \"(sO)|...\" - (function name, dll object (with an integer handle)), paramflags\n  \"(iO)|...\" - (function ordinal, dll object (with an integer handle)), paramflags\n  \"is|...\" - vtable index, method name, creates callable calling COM vtbl\n*/\nstatic PyObject *\nPyCFuncPtr_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyCFuncPtrObject *self;\n    PyObject *callable;\n    StgDictObject *dict;\n    CThunkObject *thunk;\n\n    if (PyTuple_GET_SIZE(args) == 0)\n        return GenericPyCData_new(type, args, kwds);\n\n    if (1 <= PyTuple_GET_SIZE(args) && PyTuple_Check(PyTuple_GET_ITEM(args, 0)))\n        return PyCFuncPtr_FromDll(type, args, kwds);\n\n#ifdef MS_WIN32\n    if (2 <= PyTuple_GET_SIZE(args) && PyLong_Check(PyTuple_GET_ITEM(args, 0)))\n        return PyCFuncPtr_FromVtblIndex(type, args, kwds);\n#endif\n\n    if (1 == PyTuple_GET_SIZE(args)\n        && (PyLong_Check(PyTuple_GET_ITEM(args, 0)))) {\n        CDataObject *ob;\n        void *ptr = PyLong_AsVoidPtr(PyTuple_GET_ITEM(args, 0));\n        if (ptr == NULL && PyErr_Occurred())\n            return NULL;\n        ob = (CDataObject *)GenericPyCData_new(type, args, kwds);\n        if (ob == NULL)\n            return NULL;\n        *(void **)ob->b_ptr = ptr;\n        return (PyObject *)ob;\n    }\n\n    if (!PyArg_ParseTuple(args, \"O\", &callable))\n        return NULL;\n    if (!PyCallable_Check(callable)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"argument must be callable or integer function address\");\n        return NULL;\n    }\n\n    /* XXX XXX This would allow passing additional options.  For COM\n       method *implementations*, we would probably want different\n       behaviour than in 'normal' callback functions: return a HRESULT if\n       an exception occurs in the callback, and print the traceback not\n       only on the console, but also to OutputDebugString() or something\n       like that.\n    */\n/*\n    if (kwds && _PyDict_GetItemIdWithError(kwds, &PyId_options)) {\n        ...\n    }\n    else if (PyErr_Occurred()) {\n        return NULL;\n    }\n*/\n\n    dict = PyType_stgdict((PyObject *)type);\n    /* XXXX Fails if we do: 'PyCFuncPtr(lambda x: x)' */\n    if (!dict || !dict->argtypes) {\n        PyErr_SetString(PyExc_TypeError,\n               \"cannot construct instance of this class:\"\n            \" no argtypes\");\n        return NULL;\n    }\n\n    thunk = _ctypes_alloc_callback(callable,\n                                  dict->argtypes,\n                                  dict->restype,\n                                  dict->flags);\n    if (!thunk)\n        return NULL;\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    if (self == NULL) {\n        Py_DECREF(thunk);\n        return NULL;\n    }\n\n    Py_INCREF(callable);\n    self->callable = callable;\n\n    self->thunk = thunk;\n    *(void **)self->b_ptr = (void *)thunk->pcl_exec;\n\n    Py_INCREF((PyObject *)thunk); /* for KeepRef */\n    if (-1 == KeepRef((CDataObject *)self, 0, (PyObject *)thunk)) {\n        Py_DECREF((PyObject *)self);\n        return NULL;\n    }\n    return (PyObject *)self;\n}\n\n\n/*\n  _byref consumes a refcount to its argument\n*/\nstatic PyObject *\n_byref(PyObject *obj)\n{\n    PyCArgObject *parg;\n    if (!CDataObject_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected CData instance\");\n        return NULL;\n    }\n\n    parg = PyCArgObject_new();\n    if (parg == NULL) {\n        Py_DECREF(obj);\n        return NULL;\n    }\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    parg->obj = obj;\n    parg->value.p = ((CDataObject *)obj)->b_ptr;\n    return (PyObject *)parg;\n}\n\nstatic PyObject *\n_get_arg(int *pindex, PyObject *name, PyObject *defval, PyObject *inargs, PyObject *kwds)\n{\n    PyObject *v;\n\n    if (*pindex < PyTuple_GET_SIZE(inargs)) {\n        v = PyTuple_GET_ITEM(inargs, *pindex);\n        ++*pindex;\n        Py_INCREF(v);\n        return v;\n    }\n    if (kwds && name) {\n        v = PyDict_GetItemWithError(kwds, name);\n        if (v) {\n            ++*pindex;\n            Py_INCREF(v);\n            return v;\n        }\n        else if (PyErr_Occurred()) {\n            return NULL;\n        }\n    }\n    if (defval) {\n        Py_INCREF(defval);\n        return defval;\n    }\n    /* we can't currently emit a better error message */\n    if (name)\n        PyErr_Format(PyExc_TypeError,\n                     \"required argument '%S' missing\", name);\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"not enough arguments\");\n    return NULL;\n}\n\n/*\n This function implements higher level functionality plus the ability to call\n functions with keyword arguments by looking at parameter flags.  parameter\n flags is a tuple of 1, 2 or 3-tuples.  The first entry in each is an integer\n specifying the direction of the data transfer for this parameter - 'in',\n 'out' or 'inout' (zero means the same as 'in').  The second entry is the\n parameter name, and the third is the default value if the parameter is\n missing in the function call.\n\n This function builds and returns a new tuple 'callargs' which contains the\n parameters to use in the call.  Items on this tuple are copied from the\n 'inargs' tuple for 'in' and 'in, out' parameters, and constructed from the\n 'argtypes' tuple for 'out' parameters.  It also calculates numretvals which\n is the number of return values for the function, outmask/inoutmask are\n bitmasks containing indexes into the callargs tuple specifying which\n parameters have to be returned.  _build_result builds the return value of the\n function.\n*/\nstatic PyObject *\n_build_callargs(PyCFuncPtrObject *self, PyObject *argtypes,\n                PyObject *inargs, PyObject *kwds,\n                int *poutmask, int *pinoutmask, unsigned int *pnumretvals)\n{\n    PyObject *paramflags = self->paramflags;\n    PyObject *callargs;\n    StgDictObject *dict;\n    Py_ssize_t i, len;\n    int inargs_index = 0;\n    /* It's a little bit difficult to determine how many arguments the\n    function call requires/accepts.  For simplicity, we count the consumed\n    args and compare this to the number of supplied args. */\n    Py_ssize_t actual_args;\n\n    *poutmask = 0;\n    *pinoutmask = 0;\n    *pnumretvals = 0;\n\n    /* Trivial cases, where we either return inargs itself, or a slice of it. */\n    if (argtypes == NULL || paramflags == NULL || PyTuple_GET_SIZE(argtypes) == 0) {\n#ifdef MS_WIN32\n        if (self->index)\n            return PyTuple_GetSlice(inargs, 1, PyTuple_GET_SIZE(inargs));\n#endif\n        Py_INCREF(inargs);\n        return inargs;\n    }\n\n    len = PyTuple_GET_SIZE(argtypes);\n    callargs = PyTuple_New(len); /* the argument tuple we build */\n    if (callargs == NULL)\n        return NULL;\n\n#ifdef MS_WIN32\n    /* For a COM method, skip the first arg */\n    if (self->index) {\n        inargs_index = 1;\n    }\n#endif\n    for (i = 0; i < len; ++i) {\n        PyObject *item = PyTuple_GET_ITEM(paramflags, i);\n        PyObject *ob;\n        unsigned int flag;\n        PyObject *name = NULL;\n        PyObject *defval = NULL;\n\n        /* This way seems to be ~2 us faster than the PyArg_ParseTuple\n           calls below. */\n        /* We HAVE already checked that the tuple can be parsed with \"i|ZO\", so... */\n        Py_ssize_t tsize = PyTuple_GET_SIZE(item);\n        flag = PyLong_AsUnsignedLongMask(PyTuple_GET_ITEM(item, 0));\n        name = tsize > 1 ? PyTuple_GET_ITEM(item, 1) : NULL;\n        defval = tsize > 2 ? PyTuple_GET_ITEM(item, 2) : NULL;\n\n        switch (flag & (PARAMFLAG_FIN | PARAMFLAG_FOUT | PARAMFLAG_FLCID)) {\n        case PARAMFLAG_FIN | PARAMFLAG_FLCID:\n            /* ['in', 'lcid'] parameter.  Always taken from defval,\n             if given, else the integer 0. */\n            if (defval == NULL)\n                defval = _PyLong_Zero;\n            Py_INCREF(defval);\n            PyTuple_SET_ITEM(callargs, i, defval);\n            break;\n        case (PARAMFLAG_FIN | PARAMFLAG_FOUT):\n            *pinoutmask |= (1 << i); /* mark as inout arg */\n            (*pnumretvals)++;\n            /* fall through */\n        case 0:\n        case PARAMFLAG_FIN:\n            /* 'in' parameter.  Copy it from inargs. */\n            ob =_get_arg(&inargs_index, name, defval, inargs, kwds);\n            if (ob == NULL)\n                goto error;\n            PyTuple_SET_ITEM(callargs, i, ob);\n            break;\n        case PARAMFLAG_FOUT:\n            /* XXX Refactor this code into a separate function. */\n            /* 'out' parameter.\n               argtypes[i] must be a POINTER to a c type.\n\n               Cannot by supplied in inargs, but a defval will be used\n               if available.  XXX Should we support getting it from kwds?\n            */\n            if (defval) {\n                /* XXX Using mutable objects as defval will\n                   make the function non-threadsafe, unless we\n                   copy the object in each invocation */\n                Py_INCREF(defval);\n                PyTuple_SET_ITEM(callargs, i, defval);\n                *poutmask |= (1 << i); /* mark as out arg */\n                (*pnumretvals)++;\n                break;\n            }\n            ob = PyTuple_GET_ITEM(argtypes, i);\n            dict = PyType_stgdict(ob);\n            if (dict == NULL) {\n                /* Cannot happen: _validate_paramflags()\n                  would not accept such an object */\n                PyErr_Format(PyExc_RuntimeError,\n                             \"NULL stgdict unexpected\");\n                goto error;\n            }\n            if (PyUnicode_Check(dict->proto)) {\n                PyErr_Format(\n                    PyExc_TypeError,\n                    \"%s 'out' parameter must be passed as default value\",\n                    ((PyTypeObject *)ob)->tp_name);\n                goto error;\n            }\n            if (PyCArrayTypeObject_Check(ob))\n                ob = _PyObject_CallNoArg(ob);\n            else\n                /* Create an instance of the pointed-to type */\n                ob = _PyObject_CallNoArg(dict->proto);\n            /*\n               XXX Is the following correct any longer?\n               We must not pass a byref() to the array then but\n               the array instance itself. Then, we cannot retrieve\n               the result from the PyCArgObject.\n            */\n            if (ob == NULL)\n                goto error;\n            /* The .from_param call that will occur later will pass this\n               as a byref parameter. */\n            PyTuple_SET_ITEM(callargs, i, ob);\n            *poutmask |= (1 << i); /* mark as out arg */\n            (*pnumretvals)++;\n            break;\n        default:\n            PyErr_Format(PyExc_ValueError,\n                         \"paramflag %u not yet implemented\", flag);\n            goto error;\n            break;\n        }\n    }\n\n    /* We have counted the arguments we have consumed in 'inargs_index'.  This\n       must be the same as len(inargs) + len(kwds), otherwise we have\n       either too much or not enough arguments. */\n\n    actual_args = PyTuple_GET_SIZE(inargs) + (kwds ? PyDict_GET_SIZE(kwds) : 0);\n    if (actual_args != inargs_index) {\n        /* When we have default values or named parameters, this error\n           message is misleading.  See unittests/test_paramflags.py\n         */\n        PyErr_Format(PyExc_TypeError,\n                     \"call takes exactly %d arguments (%zd given)\",\n                     inargs_index, actual_args);\n        goto error;\n    }\n\n    /* outmask is a bitmask containing indexes into callargs.  Items at\n       these indexes contain values to return.\n     */\n    return callargs;\n  error:\n    Py_DECREF(callargs);\n    return NULL;\n}\n\n/* See also:\n   http://msdn.microsoft.com/library/en-us/com/html/769127a1-1a14-4ed4-9d38-7cf3e571b661.asp\n*/\n/*\n  Build return value of a function.\n\n  Consumes the refcount on result and callargs.\n*/\nstatic PyObject *\n_build_result(PyObject *result, PyObject *callargs,\n              int outmask, int inoutmask, unsigned int numretvals)\n{\n    unsigned int i, index;\n    int bit;\n    PyObject *tup = NULL;\n\n    if (callargs == NULL)\n        return result;\n    if (result == NULL || numretvals == 0) {\n        Py_DECREF(callargs);\n        return result;\n    }\n    Py_DECREF(result);\n\n    /* tup will not be allocated if numretvals == 1 */\n    /* allocate tuple to hold the result */\n    if (numretvals > 1) {\n        tup = PyTuple_New(numretvals);\n        if (tup == NULL) {\n            Py_DECREF(callargs);\n            return NULL;\n        }\n    }\n\n    index = 0;\n    for (bit = 1, i = 0; i < 32; ++i, bit <<= 1) {\n        PyObject *v;\n        if (bit & inoutmask) {\n            v = PyTuple_GET_ITEM(callargs, i);\n            Py_INCREF(v);\n            if (numretvals == 1) {\n                Py_DECREF(callargs);\n                return v;\n            }\n            PyTuple_SET_ITEM(tup, index, v);\n            index++;\n        } else if (bit & outmask) {\n            _Py_IDENTIFIER(__ctypes_from_outparam__);\n\n            v = PyTuple_GET_ITEM(callargs, i);\n            v = _PyObject_CallMethodId(v, &PyId___ctypes_from_outparam__, NULL);\n            if (v == NULL || numretvals == 1) {\n                Py_DECREF(callargs);\n                return v;\n            }\n            PyTuple_SET_ITEM(tup, index, v);\n            index++;\n        }\n        if (index == numretvals)\n            break;\n    }\n\n    Py_DECREF(callargs);\n    return tup;\n}\n\nstatic PyObject *\nPyCFuncPtr_call(PyCFuncPtrObject *self, PyObject *inargs, PyObject *kwds)\n{\n    PyObject *restype;\n    PyObject *converters;\n    PyObject *checker;\n    PyObject *argtypes;\n    StgDictObject *dict = PyObject_stgdict((PyObject *)self);\n    PyObject *result;\n    PyObject *callargs;\n    PyObject *errcheck;\n#ifdef MS_WIN32\n    IUnknown *piunk = NULL;\n#endif\n    void *pProc = NULL;\n\n    int inoutmask;\n    int outmask;\n    unsigned int numretvals;\n\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    restype = self->restype ? self->restype : dict->restype;\n    converters = self->converters ? self->converters : dict->converters;\n    checker = self->checker ? self->checker : dict->checker;\n    argtypes = self->argtypes ? self->argtypes : dict->argtypes;\n/* later, we probably want to have an errcheck field in stgdict */\n    errcheck = self->errcheck /* ? self->errcheck : dict->errcheck */;\n\n\n    pProc = *(void **)self->b_ptr;\n#ifdef MS_WIN32\n    if (self->index) {\n        /* It's a COM method */\n        CDataObject *this;\n        this = (CDataObject *)PyTuple_GetItem(inargs, 0); /* borrowed ref! */\n        if (!this) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"native com method call without 'this' parameter\");\n            return NULL;\n        }\n        if (!CDataObject_Check(this)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"Expected a COM this pointer as first argument\");\n            return NULL;\n        }\n        /* there should be more checks? No, in Python */\n        /* First arg is a pointer to an interface instance */\n        if (!this->b_ptr || *(void **)this->b_ptr == NULL) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"NULL COM pointer access\");\n            return NULL;\n        }\n        piunk = *(IUnknown **)this->b_ptr;\n        if (NULL == piunk->lpVtbl) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"COM method call without VTable\");\n            return NULL;\n        }\n        pProc = ((void **)piunk->lpVtbl)[self->index - 0x1000];\n    }\n#endif\n    callargs = _build_callargs(self, argtypes,\n                               inargs, kwds,\n                               &outmask, &inoutmask, &numretvals);\n    if (callargs == NULL)\n        return NULL;\n\n    if (converters) {\n        int required = Py_SAFE_DOWNCAST(PyTuple_GET_SIZE(converters),\n                                        Py_ssize_t, int);\n        int actual = Py_SAFE_DOWNCAST(PyTuple_GET_SIZE(callargs),\n                                      Py_ssize_t, int);\n\n        if ((dict->flags & FUNCFLAG_CDECL) == FUNCFLAG_CDECL) {\n            /* For cdecl functions, we allow more actual arguments\n               than the length of the argtypes tuple.\n            */\n            if (required > actual) {\n                Py_DECREF(callargs);\n                PyErr_Format(PyExc_TypeError,\n              \"this function takes at least %d argument%s (%d given)\",\n                                 required,\n                                 required == 1 ? \"\" : \"s\",\n                                 actual);\n                return NULL;\n            }\n        } else if (required != actual) {\n            Py_DECREF(callargs);\n            PyErr_Format(PyExc_TypeError,\n                 \"this function takes %d argument%s (%d given)\",\n                     required,\n                     required == 1 ? \"\" : \"s\",\n                     actual);\n            return NULL;\n        }\n    }\n\n    result = _ctypes_callproc(pProc,\n                       callargs,\n#ifdef MS_WIN32\n                       piunk,\n                       self->iid,\n#endif\n                       dict->flags,\n                       converters,\n                       restype,\n                       checker);\n/* The 'errcheck' protocol */\n    if (result != NULL && errcheck) {\n        PyObject *v = PyObject_CallFunctionObjArgs(errcheck,\n                                                   result,\n                                                   self,\n                                                   callargs,\n                                                   NULL);\n        /* If the errcheck function failed, return NULL.\n           If the errcheck function returned callargs unchanged,\n           continue normal processing.\n           If the errcheck function returned something else,\n           use that as result.\n        */\n        if (v == NULL || v != callargs) {\n            Py_DECREF(result);\n            Py_DECREF(callargs);\n            return v;\n        }\n        Py_DECREF(v);\n    }\n\n    return _build_result(result, callargs,\n                         outmask, inoutmask, numretvals);\n}\n\nstatic int\nPyCFuncPtr_traverse(PyCFuncPtrObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->callable);\n    Py_VISIT(self->restype);\n    Py_VISIT(self->checker);\n    Py_VISIT(self->errcheck);\n    Py_VISIT(self->argtypes);\n    Py_VISIT(self->converters);\n    Py_VISIT(self->paramflags);\n    Py_VISIT(self->thunk);\n    return PyCData_traverse((CDataObject *)self, visit, arg);\n}\n\nstatic int\nPyCFuncPtr_clear(PyCFuncPtrObject *self)\n{\n    Py_CLEAR(self->callable);\n    Py_CLEAR(self->restype);\n    Py_CLEAR(self->checker);\n    Py_CLEAR(self->errcheck);\n    Py_CLEAR(self->argtypes);\n    Py_CLEAR(self->converters);\n    Py_CLEAR(self->paramflags);\n    Py_CLEAR(self->thunk);\n    return PyCData_clear((CDataObject *)self);\n}\n\nstatic void\nPyCFuncPtr_dealloc(PyCFuncPtrObject *self)\n{\n    PyCFuncPtr_clear(self);\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic PyObject *\nPyCFuncPtr_repr(PyCFuncPtrObject *self)\n{\n#ifdef MS_WIN32\n    if (self->index)\n        return PyUnicode_FromFormat(\"<COM method offset %d: %s at %p>\",\n                                   self->index - 0x1000,\n                                   Py_TYPE(self)->tp_name,\n                                   self);\n#endif\n    return PyUnicode_FromFormat(\"<%s object at %p>\",\n                               Py_TYPE(self)->tp_name,\n                               self);\n}\n\nstatic int\nPyCFuncPtr_bool(PyCFuncPtrObject *self)\n{\n    return ((*(void **)self->b_ptr != NULL)\n#ifdef MS_WIN32\n        || (self->index != 0)\n#endif\n        );\n}\n\nstatic PyNumberMethods PyCFuncPtr_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)PyCFuncPtr_bool, /* nb_bool */\n};\n\nPyTypeObject PyCFuncPtr_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCFuncPtr\",\n    sizeof(PyCFuncPtrObject),                           /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    (destructor)PyCFuncPtr_dealloc,             /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    (reprfunc)PyCFuncPtr_repr,                  /* tp_repr */\n    &PyCFuncPtr_as_number,                      /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    (ternaryfunc)PyCFuncPtr_call,               /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"Function Pointer\",                         /* tp_doc */\n    (traverseproc)PyCFuncPtr_traverse,          /* tp_traverse */\n    (inquiry)PyCFuncPtr_clear,                  /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    PyCFuncPtr_getsets,                         /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCFuncPtr_new,                             /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/*****************************************************************/\n/*\n  Struct_Type\n*/\n/*\n  This function is called to initialize a Structure or Union with positional\n  arguments. It calls itself recursively for all Structure or Union base\n  classes, then retrieves the _fields_ member to associate the argument\n  position with the correct field name.\n\n  Returns -1 on error, or the index of next argument on success.\n */\nstatic Py_ssize_t\n_init_pos_args(PyObject *self, PyTypeObject *type,\n               PyObject *args, PyObject *kwds,\n               Py_ssize_t index)\n{\n    StgDictObject *dict;\n    PyObject *fields;\n    Py_ssize_t i;\n    _Py_IDENTIFIER(_fields_);\n\n    if (PyType_stgdict((PyObject *)type->tp_base)) {\n        index = _init_pos_args(self, type->tp_base,\n                               args, kwds,\n                               index);\n        if (index == -1)\n            return -1;\n    }\n\n    dict = PyType_stgdict((PyObject *)type);\n    fields = _PyDict_GetItemIdWithError((PyObject *)dict, &PyId__fields_);\n    if (fields == NULL) {\n        if (PyErr_Occurred()) {\n            return -1;\n        }\n        return index;\n    }\n\n    for (i = 0;\n         i < dict->length && (i+index) < PyTuple_GET_SIZE(args);\n         ++i) {\n        PyObject *pair = PySequence_GetItem(fields, i);\n        PyObject *name, *val;\n        int res;\n        if (!pair)\n            return -1;\n        name = PySequence_GetItem(pair, 0);\n        if (!name) {\n            Py_DECREF(pair);\n            return -1;\n        }\n        val = PyTuple_GET_ITEM(args, i + index);\n        if (kwds) {\n            if (PyDict_GetItemWithError(kwds, name)) {\n                PyErr_Format(PyExc_TypeError,\n                            \"duplicate values for field %R\",\n                            name);\n                Py_DECREF(pair);\n                Py_DECREF(name);\n                return -1;\n            }\n            else if (PyErr_Occurred()) {\n                Py_DECREF(pair);\n                Py_DECREF(name);\n                return -1;\n            }\n        }\n\n        res = PyObject_SetAttr(self, name, val);\n        Py_DECREF(pair);\n        Py_DECREF(name);\n        if (res == -1)\n            return -1;\n    }\n    return index + dict->length;\n}\n\nstatic int\nStruct_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n/* Optimization possible: Store the attribute names _fields_[x][0]\n * in C accessible fields somewhere ?\n */\n    if (!PyTuple_Check(args)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"args not a tuple?\");\n        return -1;\n    }\n    if (PyTuple_GET_SIZE(args)) {\n        Py_ssize_t res = _init_pos_args(self, Py_TYPE(self),\n                                        args, kwds, 0);\n        if (res == -1)\n            return -1;\n        if (res < PyTuple_GET_SIZE(args)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"too many initializers\");\n            return -1;\n        }\n    }\n\n    if (kwds) {\n        PyObject *key, *value;\n        Py_ssize_t pos = 0;\n        while(PyDict_Next(kwds, &pos, &key, &value)) {\n            if (-1 == PyObject_SetAttr(self, key, value))\n                return -1;\n        }\n    }\n    return 0;\n}\n\nstatic PyTypeObject Struct_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Structure\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"Structure base class\",                     /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    Struct_init,                                /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic PyTypeObject Union_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Union\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"Union base class\",                         /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    Struct_init,                                /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCArray_Type\n*/\nstatic int\nArray_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    Py_ssize_t i;\n    Py_ssize_t n;\n\n    if (!PyTuple_Check(args)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"args not a tuple?\");\n        return -1;\n    }\n    n = PyTuple_GET_SIZE(args);\n    for (i = 0; i < n; ++i) {\n        PyObject *v;\n        v = PyTuple_GET_ITEM(args, i);\n        if (-1 == PySequence_SetItem((PyObject *)self, i, v))\n            return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *\nArray_item(PyObject *myself, Py_ssize_t index)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t offset, size;\n    StgDictObject *stgdict;\n\n\n    if (index < 0 || index >= self->b_length) {\n        PyErr_SetString(PyExc_IndexError,\n                        \"invalid index\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for array instances */\n    /* Would it be clearer if we got the item size from\n       stgdict->proto's stgdict?\n    */\n    size = stgdict->size / stgdict->length;\n    offset = index * size;\n\n    return PyCData_get(stgdict->proto, stgdict->getfunc, (PyObject *)self,\n                     index, size, self->b_ptr + offset);\n}\n\nstatic PyObject *\nArray_subscript(PyObject *myself, PyObject *item)\n{\n    CDataObject *self = (CDataObject *)myself;\n\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n\n        if (i == -1 && PyErr_Occurred())\n            return NULL;\n        if (i < 0)\n            i += self->b_length;\n        return Array_item(myself, i);\n    }\n    else if (PySlice_Check(item)) {\n        StgDictObject *stgdict, *itemdict;\n        PyObject *proto;\n        PyObject *np;\n        Py_ssize_t start, stop, step, slicelen, i;\n        size_t cur;\n\n        if (PySlice_Unpack(item, &start, &stop, &step) < 0) {\n            return NULL;\n        }\n        slicelen = PySlice_AdjustIndices(self->b_length, &start, &stop, step);\n\n        stgdict = PyObject_stgdict((PyObject *)self);\n        assert(stgdict); /* Cannot be NULL for array object instances */\n        proto = stgdict->proto;\n        itemdict = PyType_stgdict(proto);\n        assert(itemdict); /* proto is the item type of the array, a\n                             ctypes type, so this cannot be NULL */\n\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n            char *ptr = (char *)self->b_ptr;\n            char *dest;\n\n            if (slicelen <= 0)\n                return PyBytes_FromStringAndSize(\"\", 0);\n            if (step == 1) {\n                return PyBytes_FromStringAndSize(ptr + start,\n                                                 slicelen);\n            }\n            dest = (char *)PyMem_Malloc(slicelen);\n\n            if (dest == NULL)\n                return PyErr_NoMemory();\n\n            for (cur = start, i = 0; i < slicelen;\n                 cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n\n            np = PyBytes_FromStringAndSize(dest, slicelen);\n            PyMem_Free(dest);\n            return np;\n        }\n#ifdef CTYPES_UNICODE\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n            wchar_t *ptr = (wchar_t *)self->b_ptr;\n            wchar_t *dest;\n\n            if (slicelen <= 0)\n                return PyUnicode_New(0, 0);\n            if (step == 1) {\n                return PyUnicode_FromWideChar(ptr + start,\n                                              slicelen);\n            }\n\n            dest = PyMem_New(wchar_t, slicelen);\n            if (dest == NULL) {\n                PyErr_NoMemory();\n                return NULL;\n            }\n\n            for (cur = start, i = 0; i < slicelen;\n                 cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n\n            np = PyUnicode_FromWideChar(dest, slicelen);\n            PyMem_Free(dest);\n            return np;\n        }\n#endif\n\n        np = PyList_New(slicelen);\n        if (np == NULL)\n            return NULL;\n\n        for (cur = start, i = 0; i < slicelen;\n             cur += step, i++) {\n            PyObject *v = Array_item(myself, cur);\n            if (v == NULL) {\n                Py_DECREF(np);\n                return NULL;\n            }\n            PyList_SET_ITEM(np, i, v);\n        }\n        return np;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"indices must be integers\");\n        return NULL;\n    }\n\n}\n\nstatic int\nArray_ass_item(PyObject *myself, Py_ssize_t index, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t size, offset;\n    StgDictObject *stgdict;\n    char *ptr;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Array does not support item deletion\");\n        return -1;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for array object instances */\n    if (index < 0 || index >= stgdict->length) {\n        PyErr_SetString(PyExc_IndexError,\n                        \"invalid index\");\n        return -1;\n    }\n    size = stgdict->size / stgdict->length;\n    offset = index * size;\n    ptr = self->b_ptr + offset;\n\n    return PyCData_set((PyObject *)self, stgdict->proto, stgdict->setfunc, value,\n                     index, size, ptr);\n}\n\nstatic int\nArray_ass_subscript(PyObject *myself, PyObject *item, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)myself;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Array does not support item deletion\");\n        return -1;\n    }\n\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n\n        if (i == -1 && PyErr_Occurred())\n            return -1;\n        if (i < 0)\n            i += self->b_length;\n        return Array_ass_item(myself, i, value);\n    }\n    else if (PySlice_Check(item)) {\n        Py_ssize_t start, stop, step, slicelen, otherlen, i;\n        size_t cur;\n\n        if (PySlice_Unpack(item, &start, &stop, &step) < 0) {\n            return -1;\n        }\n        slicelen = PySlice_AdjustIndices(self->b_length, &start, &stop, step);\n        if ((step < 0 && start < stop) ||\n            (step > 0 && start > stop))\n            stop = start;\n\n        otherlen = PySequence_Length(value);\n        if (otherlen != slicelen) {\n            PyErr_SetString(PyExc_ValueError,\n                \"Can only assign sequence of same size\");\n            return -1;\n        }\n        for (cur = start, i = 0; i < otherlen; cur += step, i++) {\n            PyObject *item = PySequence_GetItem(value, i);\n            int result;\n            if (item == NULL)\n                return -1;\n            result = Array_ass_item(myself, cur, item);\n            Py_DECREF(item);\n            if (result == -1)\n                return -1;\n        }\n        return 0;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"indices must be integer\");\n        return -1;\n    }\n}\n\nstatic Py_ssize_t\nArray_length(PyObject *myself)\n{\n    CDataObject *self = (CDataObject *)myself;\n    return self->b_length;\n}\n\nstatic PySequenceMethods Array_as_sequence = {\n    Array_length,                               /* sq_length; */\n    0,                                          /* sq_concat; */\n    0,                                          /* sq_repeat; */\n    Array_item,                                 /* sq_item; */\n    0,                                          /* sq_slice; */\n    Array_ass_item,                             /* sq_ass_item; */\n    0,                                          /* sq_ass_slice; */\n    0,                                          /* sq_contains; */\n\n    0,                                          /* sq_inplace_concat; */\n    0,                                          /* sq_inplace_repeat; */\n};\n\nstatic PyMappingMethods Array_as_mapping = {\n    Array_length,\n    Array_subscript,\n    Array_ass_subscript,\n};\n\nPyTypeObject PyCArray_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Array\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &Array_as_sequence,                         /* tp_as_sequence */\n    &Array_as_mapping,                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Array_init,                       /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\nPyObject *\nPyCArrayType_from_ctype(PyObject *itemtype, Py_ssize_t length)\n{\n    static PyObject *cache;\n    PyObject *key;\n    PyObject *result;\n    char name[256];\n    PyObject *len;\n\n    if (cache == NULL) {\n        cache = PyDict_New();\n        if (cache == NULL)\n            return NULL;\n    }\n    len = PyLong_FromSsize_t(length);\n    if (len == NULL)\n        return NULL;\n    key = PyTuple_Pack(2, itemtype, len);\n    Py_DECREF(len);\n    if (!key)\n        return NULL;\n    result = PyDict_GetItemProxy(cache, key);\n    if (result) {\n        Py_INCREF(result);\n        Py_DECREF(key);\n        return result;\n    }\n    else if (PyErr_Occurred()) {\n        Py_DECREF(key);\n        return NULL;\n    }\n\n    if (!PyType_Check(itemtype)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Expected a type object\");\n        Py_DECREF(key);\n        return NULL;\n    }\n#ifdef MS_WIN64\n    sprintf(name, \"%.200s_Array_%Id\",\n        ((PyTypeObject *)itemtype)->tp_name, length);\n#else\n    sprintf(name, \"%.200s_Array_%ld\",\n        ((PyTypeObject *)itemtype)->tp_name, (long)length);\n#endif\n\n    result = PyObject_CallFunction((PyObject *)&PyCArrayType_Type,\n                                   \"s(O){s:n,s:O}\",\n                                   name,\n                                   &PyCArray_Type,\n                                   \"_length_\",\n                                   length,\n                                   \"_type_\",\n                                   itemtype\n        );\n    if (result == NULL) {\n        Py_DECREF(key);\n        return NULL;\n    }\n    if (-1 == PyDict_SetItemProxy(cache, key, result)) {\n        Py_DECREF(key);\n        Py_DECREF(result);\n        return NULL;\n    }\n    Py_DECREF(key);\n    return result;\n}\n\n\n/******************************************************************/\n/*\n  Simple_Type\n*/\n\nstatic int\nSimple_set_value(CDataObject *self, PyObject *value, void *Py_UNUSED(ignored))\n{\n    PyObject *result;\n    StgDictObject *dict = PyObject_stgdict((PyObject *)self);\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    assert(dict->setfunc);\n    result = dict->setfunc(self->b_ptr, value, dict->size);\n    if (!result)\n        return -1;\n\n    /* consumes the refcount the setfunc returns */\n    return KeepRef(self, 0, result);\n}\n\nstatic int\nSimple_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    PyObject *value = NULL;\n    if (!PyArg_UnpackTuple(args, \"__init__\", 0, 1, &value))\n        return -1;\n    if (value)\n        return Simple_set_value(self, value, NULL);\n    return 0;\n}\n\nstatic PyObject *\nSimple_get_value(CDataObject *self, void *Py_UNUSED(ignored))\n{\n    StgDictObject *dict;\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    assert(dict->getfunc);\n    return dict->getfunc(self->b_ptr, self->b_size);\n}\n\nstatic PyGetSetDef Simple_getsets[] = {\n    { \"value\", (getter)Simple_get_value, (setter)Simple_set_value,\n      \"current value\", NULL },\n    { NULL, NULL }\n};\n\nstatic PyObject *\nSimple_from_outparm(PyObject *self, PyObject *args)\n{\n    if (_ctypes_simple_instance((PyObject *)Py_TYPE(self))) {\n        Py_INCREF(self);\n        return self;\n    }\n    /* call stgdict->getfunc */\n    return Simple_get_value((CDataObject *)self, NULL);\n}\n\nstatic PyMethodDef Simple_methods[] = {\n    { \"__ctypes_from_outparam__\", Simple_from_outparm, METH_NOARGS, },\n    { NULL, NULL },\n};\n\nstatic int Simple_bool(CDataObject *self)\n{\n    return memcmp(self->b_ptr, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", self->b_size);\n}\n\nstatic PyNumberMethods Simple_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)Simple_bool, /* nb_bool */\n};\n\n/* \"%s(%s)\" % (self.__class__.__name__, self.value) */\nstatic PyObject *\nSimple_repr(CDataObject *self)\n{\n    PyObject *val, *result;\n\n    if (Py_TYPE(self)->tp_base != &Simple_Type) {\n        return PyUnicode_FromFormat(\"<%s object at %p>\",\n                                   Py_TYPE(self)->tp_name, self);\n    }\n\n    val = Simple_get_value(self, NULL);\n    if (val == NULL)\n        return NULL;\n\n    result = PyUnicode_FromFormat(\"%s(%R)\",\n                                  Py_TYPE(self)->tp_name, val);\n    Py_DECREF(val);\n    return result;\n}\n\nstatic PyTypeObject Simple_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._SimpleCData\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    (reprfunc)&Simple_repr,                     /* tp_repr */\n    &Simple_as_number,                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    Simple_methods,                             /* tp_methods */\n    0,                                          /* tp_members */\n    Simple_getsets,                             /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Simple_init,                      /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/******************************************************************/\n/*\n  PyCPointer_Type\n*/\nstatic PyObject *\nPointer_item(PyObject *myself, Py_ssize_t index)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t size;\n    Py_ssize_t offset;\n    StgDictObject *stgdict, *itemdict;\n    PyObject *proto;\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer object instances */\n\n    proto = stgdict->proto;\n    assert(proto);\n    itemdict = PyType_stgdict(proto);\n    assert(itemdict); /* proto is the item type of the pointer, a ctypes\n                         type, so this cannot be NULL */\n\n    size = itemdict->size;\n    offset = index * itemdict->size;\n\n    return PyCData_get(proto, stgdict->getfunc, (PyObject *)self,\n                     index, size, (*(char **)self->b_ptr) + offset);\n}\n\nstatic int\nPointer_ass_item(PyObject *myself, Py_ssize_t index, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)myself;\n    Py_ssize_t size;\n    Py_ssize_t offset;\n    StgDictObject *stgdict, *itemdict;\n    PyObject *proto;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer does not support item deletion\");\n        return -1;\n    }\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return -1;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer instances */\n\n    proto = stgdict->proto;\n    assert(proto);\n\n    itemdict = PyType_stgdict(proto);\n    assert(itemdict); /* Cannot be NULL because the itemtype of a pointer\n                         is always a ctypes type */\n\n    size = itemdict->size;\n    offset = index * itemdict->size;\n\n    return PyCData_set((PyObject *)self, proto, stgdict->setfunc, value,\n                     index, size, (*(char **)self->b_ptr) + offset);\n}\n\nstatic PyObject *\nPointer_get_contents(CDataObject *self, void *closure)\n{\n    StgDictObject *stgdict;\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer instances */\n    return PyCData_FromBaseObj(stgdict->proto,\n                             (PyObject *)self, 0,\n                             *(void **)self->b_ptr);\n}\n\nstatic int\nPointer_set_contents(CDataObject *self, PyObject *value, void *closure)\n{\n    StgDictObject *stgdict;\n    CDataObject *dst;\n    PyObject *keep;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer does not support item deletion\");\n        return -1;\n    }\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer instances */\n    assert(stgdict->proto);\n    if (!CDataObject_Check(value)) {\n        int res = PyObject_IsInstance(value, stgdict->proto);\n        if (res == -1)\n            return -1;\n        if (!res) {\n            PyErr_Format(PyExc_TypeError,\n                         \"expected %s instead of %s\",\n                         ((PyTypeObject *)(stgdict->proto))->tp_name,\n                         Py_TYPE(value)->tp_name);\n            return -1;\n        }\n    }\n\n    dst = (CDataObject *)value;\n    *(void **)self->b_ptr = dst->b_ptr;\n\n    /*\n       A Pointer instance must keep the value it points to alive.  So, a\n       pointer instance has b_length set to 2 instead of 1, and we set\n       'value' itself as the second item of the b_objects list, additionally.\n    */\n    Py_INCREF(value);\n    if (-1 == KeepRef(self, 1, value))\n        return -1;\n\n    keep = GetKeepedObjects(dst);\n    if (keep == NULL)\n        return -1;\n\n    Py_INCREF(keep);\n    return KeepRef(self, 0, keep);\n}\n\nstatic PyGetSetDef Pointer_getsets[] = {\n    { \"contents\", (getter)Pointer_get_contents,\n      (setter)Pointer_set_contents,\n      \"the object this pointer points to (read-write)\", NULL },\n    { NULL, NULL }\n};\n\nstatic int\nPointer_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    PyObject *value = NULL;\n\n    if (!PyArg_UnpackTuple(args, \"POINTER\", 0, 1, &value))\n        return -1;\n    if (value == NULL)\n        return 0;\n    return Pointer_set_contents(self, value, NULL);\n}\n\nstatic PyObject *\nPointer_new(PyTypeObject *type, PyObject *args, PyObject *kw)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)type);\n    if (!dict || !dict->proto) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Cannot create instance: has no _type_\");\n        return NULL;\n    }\n    return GenericPyCData_new(type, args, kw);\n}\n\nstatic PyObject *\nPointer_subscript(PyObject *myself, PyObject *item)\n{\n    CDataObject *self = (CDataObject *)myself;\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n        if (i == -1 && PyErr_Occurred())\n            return NULL;\n        return Pointer_item(myself, i);\n    }\n    else if (PySlice_Check(item)) {\n        PySliceObject *slice = (PySliceObject *)item;\n        Py_ssize_t start, stop, step;\n        PyObject *np;\n        StgDictObject *stgdict, *itemdict;\n        PyObject *proto;\n        Py_ssize_t i, len, cur;\n\n        /* Since pointers have no length, and we want to apply\n           different semantics to negative indices than normal\n           slicing, we have to dissect the slice object ourselves.*/\n        if (slice->step == Py_None) {\n            step = 1;\n        }\n        else {\n            step = PyNumber_AsSsize_t(slice->step,\n                                      PyExc_ValueError);\n            if (step == -1 && PyErr_Occurred())\n                return NULL;\n            if (step == 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"slice step cannot be zero\");\n                return NULL;\n            }\n        }\n        if (slice->start == Py_None) {\n            if (step < 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"slice start is required \"\n                                \"for step < 0\");\n                return NULL;\n            }\n            start = 0;\n        }\n        else {\n            start = PyNumber_AsSsize_t(slice->start,\n                                       PyExc_ValueError);\n            if (start == -1 && PyErr_Occurred())\n                return NULL;\n        }\n        if (slice->stop == Py_None) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"slice stop is required\");\n            return NULL;\n        }\n        stop = PyNumber_AsSsize_t(slice->stop,\n                                  PyExc_ValueError);\n        if (stop == -1 && PyErr_Occurred())\n            return NULL;\n        if ((step > 0 && start > stop) ||\n            (step < 0 && start < stop))\n            len = 0;\n        else if (step > 0)\n            len = (stop - start - 1) / step + 1;\n        else\n            len = (stop - start + 1) / step + 1;\n\n        stgdict = PyObject_stgdict((PyObject *)self);\n        assert(stgdict); /* Cannot be NULL for pointer instances */\n        proto = stgdict->proto;\n        assert(proto);\n        itemdict = PyType_stgdict(proto);\n        assert(itemdict);\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n            char *ptr = *(char **)self->b_ptr;\n            char *dest;\n\n            if (len <= 0)\n                return PyBytes_FromStringAndSize(\"\", 0);\n            if (step == 1) {\n                return PyBytes_FromStringAndSize(ptr + start,\n                                                 len);\n            }\n            dest = (char *)PyMem_Malloc(len);\n            if (dest == NULL)\n                return PyErr_NoMemory();\n            for (cur = start, i = 0; i < len; cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n            np = PyBytes_FromStringAndSize(dest, len);\n            PyMem_Free(dest);\n            return np;\n        }\n#ifdef CTYPES_UNICODE\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n            wchar_t *ptr = *(wchar_t **)self->b_ptr;\n            wchar_t *dest;\n\n            if (len <= 0)\n                return PyUnicode_New(0, 0);\n            if (step == 1) {\n                return PyUnicode_FromWideChar(ptr + start,\n                                              len);\n            }\n            dest = PyMem_New(wchar_t, len);\n            if (dest == NULL)\n                return PyErr_NoMemory();\n            for (cur = start, i = 0; i < len; cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n            np = PyUnicode_FromWideChar(dest, len);\n            PyMem_Free(dest);\n            return np;\n        }\n#endif\n\n        np = PyList_New(len);\n        if (np == NULL)\n            return NULL;\n\n        for (cur = start, i = 0; i < len; cur += step, i++) {\n            PyObject *v = Pointer_item(myself, cur);\n            PyList_SET_ITEM(np, i, v);\n        }\n        return np;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer indices must be integer\");\n        return NULL;\n    }\n}\n\nstatic PySequenceMethods Pointer_as_sequence = {\n    0,                                          /* inquiry sq_length; */\n    0,                                          /* binaryfunc sq_concat; */\n    0,                                          /* intargfunc sq_repeat; */\n    Pointer_item,                               /* intargfunc sq_item; */\n    0,                                          /* intintargfunc sq_slice; */\n    Pointer_ass_item,                           /* intobjargproc sq_ass_item; */\n    0,                                          /* intintobjargproc sq_ass_slice; */\n    0,                                          /* objobjproc sq_contains; */\n    /* Added in release 2.0 */\n    0,                                          /* binaryfunc sq_inplace_concat; */\n    0,                                          /* intargfunc sq_inplace_repeat; */\n};\n\nstatic PyMappingMethods Pointer_as_mapping = {\n    0,\n    Pointer_subscript,\n};\n\nstatic int\nPointer_bool(CDataObject *self)\n{\n    return (*(void **)self->b_ptr != NULL);\n}\n\nstatic PyNumberMethods Pointer_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)Pointer_bool, /* nb_bool */\n};\n\nPyTypeObject PyCPointer_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._Pointer\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    0,                                          /* tp_repr */\n    &Pointer_as_number,                         /* tp_as_number */\n    &Pointer_as_sequence,                       /* tp_as_sequence */\n    &Pointer_as_mapping,                        /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    Pointer_getsets,                            /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Pointer_init,                     /* tp_init */\n    0,                                          /* tp_alloc */\n    Pointer_new,                                /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n *  Module initialization.\n */\n\nstatic const char module_docs[] =\n\"Create and manipulate C compatible data types in Python.\";\n\n#ifdef MS_WIN32\n\nstatic const char comerror_doc[] = \"Raised when a COM method call failed.\";\n\nint\ncomerror_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *hresult, *text, *details;\n    PyObject *a;\n    int status;\n\n    if (!_PyArg_NoKeywords(Py_TYPE(self)->tp_name, kwds))\n        return -1;\n\n    if (!PyArg_ParseTuple(args, \"OOO:COMError\", &hresult, &text, &details))\n        return -1;\n\n    a = PySequence_GetSlice(args, 1, PyTuple_GET_SIZE(args));\n    if (!a)\n        return -1;\n    status = PyObject_SetAttrString(self, \"args\", a);\n    Py_DECREF(a);\n    if (status < 0)\n        return -1;\n\n    if (PyObject_SetAttrString(self, \"hresult\", hresult) < 0)\n        return -1;\n\n    if (PyObject_SetAttrString(self, \"text\", text) < 0)\n        return -1;\n\n    if (PyObject_SetAttrString(self, \"details\", details) < 0)\n        return -1;\n\n    Py_INCREF(args);\n    Py_SETREF(((PyBaseExceptionObject *)self)->args, args);\n\n    return 0;\n}\n\nstatic PyTypeObject PyComError_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.COMError\",         /* tp_name */\n    sizeof(PyBaseExceptionObject), /* tp_basicsize */\n    0,                          /* tp_itemsize */\n    0,                          /* tp_dealloc */\n    0,                          /* tp_vectorcall_offset */\n    0,                          /* tp_getattr */\n    0,                          /* tp_setattr */\n    0,                          /* tp_as_async */\n    0,                          /* tp_repr */\n    0,                          /* tp_as_number */\n    0,                          /* tp_as_sequence */\n    0,                          /* tp_as_mapping */\n    0,                          /* tp_hash */\n    0,                          /* tp_call */\n    0,                          /* tp_str */\n    0,                          /* tp_getattro */\n    0,                          /* tp_setattro */\n    0,                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */\n    PyDoc_STR(comerror_doc),    /* tp_doc */\n    0,                          /* tp_traverse */\n    0,                          /* tp_clear */\n    0,                          /* tp_richcompare */\n    0,                          /* tp_weaklistoffset */\n    0,                          /* tp_iter */\n    0,                          /* tp_iternext */\n    0,                          /* tp_methods */\n    0,                          /* tp_members */\n    0,                          /* tp_getset */\n    0,                          /* tp_base */\n    0,                          /* tp_dict */\n    0,                          /* tp_descr_get */\n    0,                          /* tp_descr_set */\n    0,                          /* tp_dictoffset */\n    (initproc)comerror_init,    /* tp_init */\n    0,                          /* tp_alloc */\n    0,                          /* tp_new */\n};\n\n\nstatic int\ncreate_comerror(void)\n{\n    PyComError_Type.tp_base = (PyTypeObject*)PyExc_Exception;\n    if (PyType_Ready(&PyComError_Type) < 0)\n        return -1;\n    Py_INCREF(&PyComError_Type);\n    ComError = (PyObject*)&PyComError_Type;\n    return 0;\n}\n\n#endif\n\nstatic PyObject *\nstring_at(const char *ptr, int size)\n{\n    if (PySys_Audit(\"ctypes.string_at\", \"ni\", (Py_ssize_t)ptr, size) < 0) {\n        return NULL;\n    }\n    if (size == -1)\n        return PyBytes_FromStringAndSize(ptr, strlen(ptr));\n    return PyBytes_FromStringAndSize(ptr, size);\n}\n\nstatic int\ncast_check_pointertype(PyObject *arg)\n{\n    StgDictObject *dict;\n\n    if (PyCPointerTypeObject_Check(arg))\n        return 1;\n    if (PyCFuncPtrTypeObject_Check(arg))\n        return 1;\n    dict = PyType_stgdict(arg);\n    if (dict != NULL && dict->proto != NULL) {\n        if (PyUnicode_Check(dict->proto)\n            && (strchr(\"sPzUZXO\", PyUnicode_AsUTF8(dict->proto)[0]))) {\n            /* simple pointer types, c_void_p, c_wchar_p, BSTR, ... */\n            return 1;\n        }\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"cast() argument 2 must be a pointer type, not %s\",\n                 PyType_Check(arg)\n                 ? ((PyTypeObject *)arg)->tp_name\n                 : Py_TYPE(arg)->tp_name);\n    return 0;\n}\n\nstatic PyObject *\ncast(void *ptr, PyObject *src, PyObject *ctype)\n{\n    CDataObject *result;\n    if (0 == cast_check_pointertype(ctype))\n        return NULL;\n    result = (CDataObject *)_PyObject_CallNoArg(ctype);\n    if (result == NULL)\n        return NULL;\n\n    /*\n      The casted objects '_objects' member:\n\n      It must certainly contain the source objects one.\n      It must contain the source object itself.\n     */\n    if (CDataObject_Check(src)) {\n        CDataObject *obj = (CDataObject *)src;\n        CDataObject *container;\n\n        /* PyCData_GetContainer will initialize src.b_objects, we need\n           this so it can be shared */\n        container = PyCData_GetContainer(obj);\n        if (container == NULL)\n            goto failed;\n\n        /* But we need a dictionary! */\n        if (obj->b_objects == Py_None) {\n            Py_DECREF(Py_None);\n            obj->b_objects = PyDict_New();\n            if (obj->b_objects == NULL)\n                goto failed;\n        }\n        Py_XINCREF(obj->b_objects);\n        result->b_objects = obj->b_objects;\n        if (result->b_objects && PyDict_CheckExact(result->b_objects)) {\n            PyObject *index;\n            int rc;\n            index = PyLong_FromVoidPtr((void *)src);\n            if (index == NULL)\n                goto failed;\n            rc = PyDict_SetItem(result->b_objects, index, src);\n            Py_DECREF(index);\n            if (rc == -1)\n                goto failed;\n        }\n    }\n    /* Should we assert that result is a pointer type? */\n    memcpy(result->b_ptr, &ptr, sizeof(void *));\n    return (PyObject *)result;\n\n  failed:\n    Py_DECREF(result);\n    return NULL;\n}\n\n#ifdef CTYPES_UNICODE\nstatic PyObject *\nwstring_at(const wchar_t *ptr, int size)\n{\n    Py_ssize_t ssize = size;\n    if (PySys_Audit(\"ctypes.wstring_at\", \"nn\", (Py_ssize_t)ptr, ssize) < 0) {\n        return NULL;\n    }\n    if (ssize == -1)\n        ssize = wcslen(ptr);\n    return PyUnicode_FromWideChar(ptr, ssize);\n}\n#endif\n\n\nstatic struct PyModuleDef _ctypesmodule = {\n    PyModuleDef_HEAD_INIT,\n    \"_ctypes\",\n    module_docs,\n    -1,\n    _ctypes_module_methods,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n};\n\nPyMODINIT_FUNC\nPyInit__ctypes(void)\n{\n    PyObject *m;\n\n/* Note:\n   ob_type is the metatype (the 'type'), defaults to PyType_Type,\n   tp_base is the base type, defaults to 'object' aka PyBaseObject_Type.\n*/\n    PyEval_InitThreads();\n    m = PyModule_Create(&_ctypesmodule);\n    if (!m)\n        return NULL;\n\n    _ctypes_ptrtype_cache = PyDict_New();\n    if (_ctypes_ptrtype_cache == NULL)\n        return NULL;\n\n    PyModule_AddObject(m, \"_pointer_type_cache\", (PyObject *)_ctypes_ptrtype_cache);\n\n    _unpickle = PyObject_GetAttrString(m, \"_unpickle\");\n    if (_unpickle == NULL)\n        return NULL;\n\n    if (PyType_Ready(&PyCArg_Type) < 0)\n        return NULL;\n\n    if (PyType_Ready(&PyCThunk_Type) < 0)\n        return NULL;\n\n    /* StgDict is derived from PyDict_Type */\n    PyCStgDict_Type.tp_base = &PyDict_Type;\n    if (PyType_Ready(&PyCStgDict_Type) < 0)\n        return NULL;\n\n    /*************************************************\n     *\n     * Metaclasses\n     */\n\n    PyCStructType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCStructType_Type) < 0)\n        return NULL;\n\n    UnionType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&UnionType_Type) < 0)\n        return NULL;\n\n    PyCPointerType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCPointerType_Type) < 0)\n        return NULL;\n\n    PyCArrayType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCArrayType_Type) < 0)\n        return NULL;\n\n    PyCSimpleType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCSimpleType_Type) < 0)\n        return NULL;\n\n    PyCFuncPtrType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCFuncPtrType_Type) < 0)\n        return NULL;\n\n    /*************************************************\n     *\n     * Classes using a custom metaclass\n     */\n\n    if (PyType_Ready(&PyCData_Type) < 0)\n        return NULL;\n\n    Py_TYPE(&Struct_Type) = &PyCStructType_Type;\n    Struct_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&Struct_Type) < 0)\n        return NULL;\n    Py_INCREF(&Struct_Type);\n    PyModule_AddObject(m, \"Structure\", (PyObject *)&Struct_Type);\n\n    Py_TYPE(&Union_Type) = &UnionType_Type;\n    Union_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&Union_Type) < 0)\n        return NULL;\n    Py_INCREF(&Union_Type);\n    PyModule_AddObject(m, \"Union\", (PyObject *)&Union_Type);\n\n    Py_TYPE(&PyCPointer_Type) = &PyCPointerType_Type;\n    PyCPointer_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&PyCPointer_Type) < 0)\n        return NULL;\n    Py_INCREF(&PyCPointer_Type);\n    PyModule_AddObject(m, \"_Pointer\", (PyObject *)&PyCPointer_Type);\n\n    Py_TYPE(&PyCArray_Type) = &PyCArrayType_Type;\n    PyCArray_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&PyCArray_Type) < 0)\n        return NULL;\n    Py_INCREF(&PyCArray_Type);\n    PyModule_AddObject(m, \"Array\", (PyObject *)&PyCArray_Type);\n\n    Py_TYPE(&Simple_Type) = &PyCSimpleType_Type;\n    Simple_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&Simple_Type) < 0)\n        return NULL;\n    Py_INCREF(&Simple_Type);\n    PyModule_AddObject(m, \"_SimpleCData\", (PyObject *)&Simple_Type);\n\n    Py_TYPE(&PyCFuncPtr_Type) = &PyCFuncPtrType_Type;\n    PyCFuncPtr_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&PyCFuncPtr_Type) < 0)\n        return NULL;\n    Py_INCREF(&PyCFuncPtr_Type);\n    PyModule_AddObject(m, \"CFuncPtr\", (PyObject *)&PyCFuncPtr_Type);\n\n    /*************************************************\n     *\n     * Simple classes\n     */\n\n    /* PyCField_Type is derived from PyBaseObject_Type */\n    if (PyType_Ready(&PyCField_Type) < 0)\n        return NULL;\n\n    /*************************************************\n     *\n     * Other stuff\n     */\n\n    DictRemover_Type.tp_new = PyType_GenericNew;\n    if (PyType_Ready(&DictRemover_Type) < 0)\n        return NULL;\n\n    if (PyType_Ready(&StructParam_Type) < 0) {\n        return NULL;\n    }\n\n#ifdef MS_WIN32\n    if (create_comerror() < 0)\n        return NULL;\n    PyModule_AddObject(m, \"COMError\", ComError);\n\n    PyModule_AddObject(m, \"FUNCFLAG_HRESULT\", PyLong_FromLong(FUNCFLAG_HRESULT));\n    PyModule_AddObject(m, \"FUNCFLAG_STDCALL\", PyLong_FromLong(FUNCFLAG_STDCALL));\n#endif\n    PyModule_AddObject(m, \"FUNCFLAG_CDECL\", PyLong_FromLong(FUNCFLAG_CDECL));\n    PyModule_AddObject(m, \"FUNCFLAG_USE_ERRNO\", PyLong_FromLong(FUNCFLAG_USE_ERRNO));\n    PyModule_AddObject(m, \"FUNCFLAG_USE_LASTERROR\", PyLong_FromLong(FUNCFLAG_USE_LASTERROR));\n    PyModule_AddObject(m, \"FUNCFLAG_PYTHONAPI\", PyLong_FromLong(FUNCFLAG_PYTHONAPI));\n    PyModule_AddStringConstant(m, \"__version__\", \"1.1.0\");\n\n    PyModule_AddObject(m, \"_memmove_addr\", PyLong_FromVoidPtr(memmove));\n    PyModule_AddObject(m, \"_memset_addr\", PyLong_FromVoidPtr(memset));\n    PyModule_AddObject(m, \"_string_at_addr\", PyLong_FromVoidPtr(string_at));\n    PyModule_AddObject(m, \"_cast_addr\", PyLong_FromVoidPtr(cast));\n#ifdef CTYPES_UNICODE\n    PyModule_AddObject(m, \"_wstring_at_addr\", PyLong_FromVoidPtr(wstring_at));\n#endif\n\n/* If RTLD_LOCAL is not defined (Windows!), set it to zero. */\n#if !HAVE_DECL_RTLD_LOCAL\n#define RTLD_LOCAL 0\n#endif\n\n/* If RTLD_GLOBAL is not defined (cygwin), set it to the same value as\n   RTLD_LOCAL.\n*/\n#if !HAVE_DECL_RTLD_GLOBAL\n#define RTLD_GLOBAL RTLD_LOCAL\n#endif\n\n    PyModule_AddObject(m, \"RTLD_LOCAL\", PyLong_FromLong(RTLD_LOCAL));\n    PyModule_AddObject(m, \"RTLD_GLOBAL\", PyLong_FromLong(RTLD_GLOBAL));\n\n    PyExc_ArgError = PyErr_NewException(\"ctypes.ArgumentError\", NULL, NULL);\n    if (PyExc_ArgError) {\n        Py_INCREF(PyExc_ArgError);\n        PyModule_AddObject(m, \"ArgumentError\", PyExc_ArgError);\n    }\n    return m;\n}\n\n/*\n Local Variables:\n compile-command: \"cd .. && python setup.py -q build -g && python setup.py -q build install --home ~\"\n End:\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Modules/_ctypes/callproc.c": "/*\n * History: First version dated from 3/97, derived from my SCMLIB version\n * for win16.\n */\n/*\n * Related Work:\n *      - calldll       http://www.nightmare.com/software.html\n *      - libffi        http://sourceware.cygnus.com/libffi/\n *      - ffcall        http://clisp.cons.org/~haible/packages-ffcall.html\n *   and, of course, Don Beaudry's MESS package, but this is more ctypes\n *   related.\n */\n\n\n/*\n  How are functions called, and how are parameters converted to C ?\n\n  1. _ctypes.c::PyCFuncPtr_call receives an argument tuple 'inargs' and a\n  keyword dictionary 'kwds'.\n\n  2. After several checks, _build_callargs() is called which returns another\n  tuple 'callargs'.  This may be the same tuple as 'inargs', a slice of\n  'inargs', or a completely fresh tuple, depending on several things (is it a\n  COM method?, are 'paramflags' available?).\n\n  3. _build_callargs also calculates bitarrays containing indexes into\n  the callargs tuple, specifying how to build the return value(s) of\n  the function.\n\n  4. _ctypes_callproc is then called with the 'callargs' tuple.  _ctypes_callproc first\n  allocates two arrays.  The first is an array of 'struct argument' items, the\n  second array has 'void *' entries.\n\n  5. If 'converters' are present (converters is a sequence of argtypes'\n  from_param methods), for each item in 'callargs' converter is called and the\n  result passed to ConvParam.  If 'converters' are not present, each argument\n  is directly passed to ConvParm.\n\n  6. For each arg, ConvParam stores the contained C data (or a pointer to it,\n  for structures) into the 'struct argument' array.\n\n  7. Finally, a loop fills the 'void *' array so that each item points to the\n  data contained in or pointed to by the 'struct argument' array.\n\n  8. The 'void *' argument array is what _call_function_pointer\n  expects. _call_function_pointer then has very little to do - only some\n  libffi specific stuff, then it calls ffi_call.\n\n  So, there are 4 data structures holding processed arguments:\n  - the inargs tuple (in PyCFuncPtr_call)\n  - the callargs tuple (in PyCFuncPtr_call)\n  - the 'struct arguments' array\n  - the 'void *' array\n\n */\n\n#include \"Python.h\"\n#include \"structmember.h\"\n\n#ifdef MS_WIN32\n#include <windows.h>\n#include <tchar.h>\n#else\n#include \"ctypes_dlfcn.h\"\n#endif\n\n#ifdef MS_WIN32\n#include <malloc.h>\n#endif\n\n#include <ffi.h>\n#include \"ctypes.h\"\n#ifdef HAVE_ALLOCA_H\n/* AIX needs alloca.h for alloca() */\n#include <alloca.h>\n#endif\n\n#ifdef _Py_MEMORY_SANITIZER\n#include <sanitizer/msan_interface.h>\n#endif\n\n#if defined(_DEBUG) || defined(__MINGW32__)\n/* Don't use structured exception handling on Windows if this is defined.\n   MingW, AFAIK, doesn't support it.\n*/\n#define DONT_USE_SEH\n#endif\n\n#define CTYPES_CAPSULE_NAME_PYMEM \"_ctypes pymem\"\n\nstatic void pymem_destructor(PyObject *ptr)\n{\n    void *p = PyCapsule_GetPointer(ptr, CTYPES_CAPSULE_NAME_PYMEM);\n    if (p) {\n        PyMem_Free(p);\n    }\n}\n\n/*\n  ctypes maintains thread-local storage that has space for two error numbers:\n  private copies of the system 'errno' value and, on Windows, the system error code\n  accessed by the GetLastError() and SetLastError() api functions.\n\n  Foreign functions created with CDLL(..., use_errno=True), when called, swap\n  the system 'errno' value with the private copy just before the actual\n  function call, and swapped again immediately afterwards.  The 'use_errno'\n  parameter defaults to False, in this case 'ctypes_errno' is not touched.\n\n  On Windows, foreign functions created with CDLL(..., use_last_error=True) or\n  WinDLL(..., use_last_error=True) swap the system LastError value with the\n  ctypes private copy.\n\n  The values are also swapped immediately before and after ctypes callback\n  functions are called, if the callbacks are constructed using the new\n  optional use_errno parameter set to True: CFUNCTYPE(..., use_errno=TRUE) or\n  WINFUNCTYPE(..., use_errno=True).\n\n  New ctypes functions are provided to access the ctypes private copies from\n  Python:\n\n  - ctypes.set_errno(value) and ctypes.set_last_error(value) store 'value' in\n    the private copy and returns the previous value.\n\n  - ctypes.get_errno() and ctypes.get_last_error() returns the current ctypes\n    private copies value.\n*/\n\n/*\n  This function creates and returns a thread-local Python object that has\n  space to store two integer error numbers; once created the Python object is\n  kept alive in the thread state dictionary as long as the thread itself.\n*/\nPyObject *\n_ctypes_get_errobj(int **pspace)\n{\n    PyObject *dict = PyThreadState_GetDict();\n    PyObject *errobj;\n    static PyObject *error_object_name;\n    if (dict == NULL) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"cannot get thread state\");\n        return NULL;\n    }\n    if (error_object_name == NULL) {\n        error_object_name = PyUnicode_InternFromString(\"ctypes.error_object\");\n        if (error_object_name == NULL)\n            return NULL;\n    }\n    errobj = PyDict_GetItemWithError(dict, error_object_name);\n    if (errobj) {\n        if (!PyCapsule_IsValid(errobj, CTYPES_CAPSULE_NAME_PYMEM)) {\n            PyErr_SetString(PyExc_RuntimeError,\n                \"ctypes.error_object is an invalid capsule\");\n            return NULL;\n        }\n        Py_INCREF(errobj);\n    }\n    else if (!PyErr_Occurred()) {\n        void *space = PyMem_Malloc(sizeof(int) * 2);\n        if (space == NULL)\n            return NULL;\n        memset(space, 0, sizeof(int) * 2);\n        errobj = PyCapsule_New(space, CTYPES_CAPSULE_NAME_PYMEM, pymem_destructor);\n        if (errobj == NULL) {\n            PyMem_Free(space);\n            return NULL;\n        }\n        if (-1 == PyDict_SetItem(dict, error_object_name,\n                                 errobj)) {\n            Py_DECREF(errobj);\n            return NULL;\n        }\n    }\n    else {\n        return NULL;\n    }\n    *pspace = (int *)PyCapsule_GetPointer(errobj, CTYPES_CAPSULE_NAME_PYMEM);\n    return errobj;\n}\n\nstatic PyObject *\nget_error_internal(PyObject *self, PyObject *args, int index)\n{\n    int *space;\n    PyObject *errobj = _ctypes_get_errobj(&space);\n    PyObject *result;\n\n    if (errobj == NULL)\n        return NULL;\n    result = PyLong_FromLong(space[index]);\n    Py_DECREF(errobj);\n    return result;\n}\n\nstatic PyObject *\nset_error_internal(PyObject *self, PyObject *args, int index)\n{\n    int new_errno, old_errno;\n    PyObject *errobj;\n    int *space;\n\n    if (!PyArg_ParseTuple(args, \"i\", &new_errno)) {\n        return NULL;\n    }\n    errobj = _ctypes_get_errobj(&space);\n    if (errobj == NULL)\n        return NULL;\n    old_errno = space[index];\n    space[index] = new_errno;\n    Py_DECREF(errobj);\n    return PyLong_FromLong(old_errno);\n}\n\nstatic PyObject *\nget_errno(PyObject *self, PyObject *args)\n{\n    if (PySys_Audit(\"ctypes.get_errno\", NULL) < 0) {\n        return NULL;\n    }\n    return get_error_internal(self, args, 0);\n}\n\nstatic PyObject *\nset_errno(PyObject *self, PyObject *args)\n{\n    if (PySys_Audit(\"ctypes.set_errno\", \"O\", args) < 0) {\n        return NULL;\n    }\n    return set_error_internal(self, args, 0);\n}\n\n#ifdef MS_WIN32\n\nstatic PyObject *\nget_last_error(PyObject *self, PyObject *args)\n{\n    if (PySys_Audit(\"ctypes.get_last_error\", NULL) < 0) {\n        return NULL;\n    }\n    return get_error_internal(self, args, 1);\n}\n\nstatic PyObject *\nset_last_error(PyObject *self, PyObject *args)\n{\n    if (PySys_Audit(\"ctypes.set_last_error\", \"O\", args) < 0) {\n        return NULL;\n    }\n    return set_error_internal(self, args, 1);\n}\n\nPyObject *ComError;\n\nstatic WCHAR *FormatError(DWORD code)\n{\n    WCHAR *lpMsgBuf;\n    DWORD n;\n    n = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                       FORMAT_MESSAGE_FROM_SYSTEM |\n                       FORMAT_MESSAGE_IGNORE_INSERTS,\n                       NULL,\n                       code,\n                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */\n               (LPWSTR) &lpMsgBuf,\n               0,\n               NULL);\n    if (n) {\n        while (iswspace(lpMsgBuf[n-1]))\n            --n;\n        lpMsgBuf[n] = L'\\0'; /* rstrip() */\n    }\n    return lpMsgBuf;\n}\n\n#ifndef DONT_USE_SEH\nstatic void SetException(DWORD code, EXCEPTION_RECORD *pr)\n{\n    if (PySys_Audit(\"ctypes.seh_exception\", \"I\", code) < 0) {\n        /* An exception was set by the audit hook */\n        return;\n    }\n\n    /* The 'code' is a normal win32 error code so it could be handled by\n    PyErr_SetFromWindowsErr(). However, for some errors, we have additional\n    information not included in the error code. We handle those here and\n    delegate all others to the generic function. */\n    switch (code) {\n    case EXCEPTION_ACCESS_VIOLATION:\n        /* The thread attempted to read from or write\n           to a virtual address for which it does not\n           have the appropriate access. */\n        if (pr->ExceptionInformation[0] == 0)\n            PyErr_Format(PyExc_OSError,\n                         \"exception: access violation reading %p\",\n                         pr->ExceptionInformation[1]);\n        else\n            PyErr_Format(PyExc_OSError,\n                         \"exception: access violation writing %p\",\n                         pr->ExceptionInformation[1]);\n        break;\n\n    case EXCEPTION_BREAKPOINT:\n        /* A breakpoint was encountered. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: breakpoint encountered\");\n        break;\n\n    case EXCEPTION_DATATYPE_MISALIGNMENT:\n        /* The thread attempted to read or write data that is\n           misaligned on hardware that does not provide\n           alignment. For example, 16-bit values must be\n           aligned on 2-byte boundaries, 32-bit values on\n           4-byte boundaries, and so on. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: datatype misalignment\");\n        break;\n\n    case EXCEPTION_SINGLE_STEP:\n        /* A trace trap or other single-instruction mechanism\n           signaled that one instruction has been executed. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: single step\");\n        break;\n\n    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n        /* The thread attempted to access an array element\n           that is out of bounds, and the underlying hardware\n           supports bounds checking. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: array bounds exceeded\");\n        break;\n\n    case EXCEPTION_FLT_DENORMAL_OPERAND:\n        /* One of the operands in a floating-point operation\n           is denormal. A denormal value is one that is too\n           small to represent as a standard floating-point\n           value. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: floating-point operand denormal\");\n        break;\n\n    case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n        /* The thread attempted to divide a floating-point\n           value by a floating-point divisor of zero. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: float divide by zero\");\n        break;\n\n    case EXCEPTION_FLT_INEXACT_RESULT:\n        /* The result of a floating-point operation cannot be\n           represented exactly as a decimal fraction. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: float inexact\");\n        break;\n\n    case EXCEPTION_FLT_INVALID_OPERATION:\n        /* This exception represents any floating-point\n           exception not included in this list. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: float invalid operation\");\n        break;\n\n    case EXCEPTION_FLT_OVERFLOW:\n        /* The exponent of a floating-point operation is\n           greater than the magnitude allowed by the\n           corresponding type. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: float overflow\");\n        break;\n\n    case EXCEPTION_FLT_STACK_CHECK:\n        /* The stack overflowed or underflowed as the result\n           of a floating-point operation. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: stack over/underflow\");\n        break;\n\n    case EXCEPTION_STACK_OVERFLOW:\n        /* The stack overflowed or underflowed as the result\n           of a floating-point operation. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: stack overflow\");\n        break;\n\n    case EXCEPTION_FLT_UNDERFLOW:\n        /* The exponent of a floating-point operation is less\n           than the magnitude allowed by the corresponding\n           type. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: float underflow\");\n        break;\n\n    case EXCEPTION_INT_DIVIDE_BY_ZERO:\n        /* The thread attempted to divide an integer value by\n           an integer divisor of zero. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: integer divide by zero\");\n        break;\n\n    case EXCEPTION_INT_OVERFLOW:\n        /* The result of an integer operation caused a carry\n           out of the most significant bit of the result. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: integer overflow\");\n        break;\n\n    case EXCEPTION_PRIV_INSTRUCTION:\n        /* The thread attempted to execute an instruction\n           whose operation is not allowed in the current\n           machine mode. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: privileged instruction\");\n        break;\n\n    case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n        /* The thread attempted to continue execution after a\n           noncontinuable exception occurred. */\n        PyErr_SetString(PyExc_OSError,\n                        \"exception: nocontinuable\");\n        break;\n\n    default:\n        PyErr_SetFromWindowsErr(code);\n        break;\n    }\n}\n\nstatic DWORD HandleException(EXCEPTION_POINTERS *ptrs,\n                             DWORD *pdw, EXCEPTION_RECORD *record)\n{\n    *pdw = ptrs->ExceptionRecord->ExceptionCode;\n    *record = *ptrs->ExceptionRecord;\n    /* We don't want to catch breakpoint exceptions, they are used to attach\n     * a debugger to the process.\n     */\n    if (*pdw == EXCEPTION_BREAKPOINT)\n        return EXCEPTION_CONTINUE_SEARCH;\n    return EXCEPTION_EXECUTE_HANDLER;\n}\n#endif\n\nstatic PyObject *\ncheck_hresult(PyObject *self, PyObject *args)\n{\n    HRESULT hr;\n    if (!PyArg_ParseTuple(args, \"i\", &hr))\n        return NULL;\n    if (FAILED(hr))\n        return PyErr_SetFromWindowsErr(hr);\n    return PyLong_FromLong(hr);\n}\n\n#endif\n\n/**************************************************************/\n\nPyCArgObject *\nPyCArgObject_new(void)\n{\n    PyCArgObject *p;\n    p = PyObject_New(PyCArgObject, &PyCArg_Type);\n    if (p == NULL)\n        return NULL;\n    p->pffi_type = NULL;\n    p->tag = '\\0';\n    p->obj = NULL;\n    memset(&p->value, 0, sizeof(p->value));\n    return p;\n}\n\nstatic void\nPyCArg_dealloc(PyCArgObject *self)\n{\n    Py_XDECREF(self->obj);\n    PyObject_Del(self);\n}\n\nstatic int\nis_literal_char(unsigned char c)\n{\n    return c < 128 && _PyUnicode_IsPrintable(c) && c != '\\\\' && c != '\\'';\n}\n\nstatic PyObject *\nPyCArg_repr(PyCArgObject *self)\n{\n    char buffer[256];\n    switch(self->tag) {\n    case 'b':\n    case 'B':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.b);\n        break;\n    case 'h':\n    case 'H':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.h);\n        break;\n    case 'i':\n    case 'I':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.i);\n        break;\n    case 'l':\n    case 'L':\n        sprintf(buffer, \"<cparam '%c' (%ld)>\",\n            self->tag, self->value.l);\n        break;\n\n    case 'q':\n    case 'Q':\n        sprintf(buffer,\n#ifdef MS_WIN32\n            \"<cparam '%c' (%I64d)>\",\n#else\n            \"<cparam '%c' (%lld)>\",\n#endif\n            self->tag, self->value.q);\n        break;\n    case 'd':\n        sprintf(buffer, \"<cparam '%c' (%f)>\",\n            self->tag, self->value.d);\n        break;\n    case 'f':\n        sprintf(buffer, \"<cparam '%c' (%f)>\",\n            self->tag, self->value.f);\n        break;\n\n    case 'c':\n        if (is_literal_char((unsigned char)self->value.c)) {\n            sprintf(buffer, \"<cparam '%c' ('%c')>\",\n                self->tag, self->value.c);\n        }\n        else {\n            sprintf(buffer, \"<cparam '%c' ('\\\\x%02x')>\",\n                self->tag, (unsigned char)self->value.c);\n        }\n        break;\n\n/* Hm, are these 'z' and 'Z' codes useful at all?\n   Shouldn't they be replaced by the functionality of c_string\n   and c_wstring ?\n*/\n    case 'z':\n    case 'Z':\n    case 'P':\n        sprintf(buffer, \"<cparam '%c' (%p)>\",\n            self->tag, self->value.p);\n        break;\n\n    default:\n        if (is_literal_char((unsigned char)self->tag)) {\n            sprintf(buffer, \"<cparam '%c' at %p>\",\n                (unsigned char)self->tag, (void *)self);\n        }\n        else {\n            sprintf(buffer, \"<cparam 0x%02x at %p>\",\n                (unsigned char)self->tag, (void *)self);\n        }\n        break;\n    }\n    return PyUnicode_FromString(buffer);\n}\n\nstatic PyMemberDef PyCArgType_members[] = {\n    { \"_obj\", T_OBJECT,\n      offsetof(PyCArgObject, obj), READONLY,\n      \"the wrapped object\" },\n    { NULL },\n};\n\nPyTypeObject PyCArg_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"CArgObject\",\n    sizeof(PyCArgObject),\n    0,\n    (destructor)PyCArg_dealloc,                 /* tp_dealloc */\n    0,                                          /* tp_vectorcall_offset */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_as_async */\n    (reprfunc)PyCArg_repr,                      /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    PyCArgType_members,                         /* tp_members */\n};\n\n/****************************************************************/\n/*\n * Convert a PyObject * into a parameter suitable to pass to an\n * C function call.\n *\n * 1. Python integers are converted to C int and passed by value.\n *    Py_None is converted to a C NULL pointer.\n *\n * 2. 3-tuples are expected to have a format character in the first\n *    item, which must be 'i', 'f', 'd', 'q', or 'P'.\n *    The second item will have to be an integer, float, double, long long\n *    or integer (denoting an address void *), will be converted to the\n *    corresponding C data type and passed by value.\n *\n * 3. Other Python objects are tested for an '_as_parameter_' attribute.\n *    The value of this attribute must be an integer which will be passed\n *    by value, or a 2-tuple or 3-tuple which will be used according\n *    to point 2 above. The third item (if any), is ignored. It is normally\n *    used to keep the object alive where this parameter refers to.\n *    XXX This convention is dangerous - you can construct arbitrary tuples\n *    in Python and pass them. Would it be safer to use a custom container\n *    datatype instead of a tuple?\n *\n * 4. Other Python objects cannot be passed as parameters - an exception is raised.\n *\n * 5. ConvParam will store the converted result in a struct containing format\n *    and value.\n */\n\nunion result {\n    char c;\n    char b;\n    short h;\n    int i;\n    long l;\n    long long q;\n    long double D;\n    double d;\n    float f;\n    void *p;\n};\n\nstruct argument {\n    ffi_type *ffi_type;\n    PyObject *keep;\n    union result value;\n};\n\n/*\n * Convert a single Python object into a PyCArgObject and return it.\n */\nstatic int ConvParam(PyObject *obj, Py_ssize_t index, struct argument *pa)\n{\n    StgDictObject *dict;\n    pa->keep = NULL; /* so we cannot forget it later */\n\n    dict = PyObject_stgdict(obj);\n    if (dict) {\n        PyCArgObject *carg;\n        assert(dict->paramfunc);\n        /* If it has an stgdict, it is a CDataObject */\n        carg = dict->paramfunc((CDataObject *)obj);\n        if (carg == NULL)\n            return -1;\n        pa->ffi_type = carg->pffi_type;\n        memcpy(&pa->value, &carg->value, sizeof(pa->value));\n        pa->keep = (PyObject *)carg;\n        return 0;\n    }\n\n    if (PyCArg_CheckExact(obj)) {\n        PyCArgObject *carg = (PyCArgObject *)obj;\n        pa->ffi_type = carg->pffi_type;\n        Py_INCREF(obj);\n        pa->keep = obj;\n        memcpy(&pa->value, &carg->value, sizeof(pa->value));\n        return 0;\n    }\n\n    /* check for None, integer, string or unicode and use directly if successful */\n    if (obj == Py_None) {\n        pa->ffi_type = &ffi_type_pointer;\n        pa->value.p = NULL;\n        return 0;\n    }\n\n    if (PyLong_Check(obj)) {\n        pa->ffi_type = &ffi_type_sint;\n        pa->value.i = (long)PyLong_AsUnsignedLong(obj);\n        if (pa->value.i == -1 && PyErr_Occurred()) {\n            PyErr_Clear();\n            pa->value.i = PyLong_AsLong(obj);\n            if (pa->value.i == -1 && PyErr_Occurred()) {\n                PyErr_SetString(PyExc_OverflowError,\n                                \"int too long to convert\");\n                return -1;\n            }\n        }\n        return 0;\n    }\n\n    if (PyBytes_Check(obj)) {\n        pa->ffi_type = &ffi_type_pointer;\n        pa->value.p = PyBytes_AsString(obj);\n        Py_INCREF(obj);\n        pa->keep = obj;\n        return 0;\n    }\n\n#ifdef CTYPES_UNICODE\n    if (PyUnicode_Check(obj)) {\n        pa->ffi_type = &ffi_type_pointer;\n        pa->value.p = PyUnicode_AsWideCharString(obj, NULL);\n        if (pa->value.p == NULL)\n            return -1;\n        pa->keep = PyCapsule_New(pa->value.p, CTYPES_CAPSULE_NAME_PYMEM, pymem_destructor);\n        if (!pa->keep) {\n            PyMem_Free(pa->value.p);\n            return -1;\n        }\n        return 0;\n    }\n#endif\n\n    {\n        _Py_IDENTIFIER(_as_parameter_);\n        PyObject *arg;\n        if (_PyObject_LookupAttrId(obj, &PyId__as_parameter_, &arg) < 0) {\n            return -1;\n        }\n        /* Which types should we exactly allow here?\n           integers are required for using Python classes\n           as parameters (they have to expose the '_as_parameter_'\n           attribute)\n        */\n        if (arg) {\n            int result;\n            result = ConvParam(arg, index, pa);\n            Py_DECREF(arg);\n            return result;\n        }\n        PyErr_Format(PyExc_TypeError,\n                     \"Don't know how to convert parameter %d\",\n                     Py_SAFE_DOWNCAST(index, Py_ssize_t, int));\n        return -1;\n    }\n}\n\n#if defined(MS_WIN32) && !defined(_WIN32_WCE)\n/*\nPer: https://msdn.microsoft.com/en-us/library/7572ztz4.aspx\nTo be returned by value in RAX, user-defined types must have a length \nof 1, 2, 4, 8, 16, 32, or 64 bits\n*/\nint can_return_struct_as_int(size_t s)\n{\n    return s == 1 || s == 2 || s == 4;\n}\n\nint can_return_struct_as_sint64(size_t s)\n{\n#ifdef _M_ARM\n    // 8 byte structs cannot be returned in a register on ARM32\n    return 0;\n#else\n    return s == 8;\n#endif\n}\n#endif\n\n\nffi_type *_ctypes_get_ffi_type(PyObject *obj)\n{\n    StgDictObject *dict;\n    if (obj == NULL)\n        return &ffi_type_sint;\n    dict = PyType_stgdict(obj);\n    if (dict == NULL)\n        return &ffi_type_sint;\n#if defined(MS_WIN32) && !defined(_WIN32_WCE)\n    /* This little trick works correctly with MSVC.\n       It returns small structures in registers\n    */\n    if (dict->ffi_type_pointer.type == FFI_TYPE_STRUCT) {\n        if (can_return_struct_as_int(dict->ffi_type_pointer.size))\n            return &ffi_type_sint32;\n        else if (can_return_struct_as_sint64 (dict->ffi_type_pointer.size))\n            return &ffi_type_sint64;\n    }\n#endif\n    return &dict->ffi_type_pointer;\n}\n\n\n/*\n * libffi uses:\n *\n * ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi,\n *                         unsigned int nargs,\n *                         ffi_type *rtype,\n *                         ffi_type **atypes);\n *\n * and then\n *\n * void ffi_call(ffi_cif *cif, void *fn, void *rvalue, void **avalues);\n */\nstatic int _call_function_pointer(int flags,\n                                  PPROC pProc,\n                                  void **avalues,\n                                  ffi_type **atypes,\n                                  ffi_type *restype,\n                                  void *resmem,\n                                  int argcount)\n{\n    PyThreadState *_save = NULL; /* For Py_BLOCK_THREADS and Py_UNBLOCK_THREADS */\n    PyObject *error_object = NULL;\n    int *space;\n    ffi_cif cif;\n    int cc;\n#if defined(MS_WIN32) && !defined(DONT_USE_SEH)\n    DWORD dwExceptionCode = 0;\n    EXCEPTION_RECORD record;\n#endif\n    /* XXX check before here */\n    if (restype == NULL) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"No ffi_type for result\");\n        return -1;\n    }\n\n    cc = FFI_DEFAULT_ABI;\n#if defined(MS_WIN32) && !defined(MS_WIN64) && !defined(_WIN32_WCE) && !defined(_M_ARM)\n    if ((flags & FUNCFLAG_CDECL) == 0)\n        cc = FFI_STDCALL;\n#endif\n    if (FFI_OK != ffi_prep_cif(&cif,\n                               cc,\n                               argcount,\n                               restype,\n                               atypes)) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"ffi_prep_cif failed\");\n        return -1;\n    }\n\n    if (flags & (FUNCFLAG_USE_ERRNO | FUNCFLAG_USE_LASTERROR)) {\n        error_object = _ctypes_get_errobj(&space);\n        if (error_object == NULL)\n            return -1;\n    }\n    if ((flags & FUNCFLAG_PYTHONAPI) == 0)\n        Py_UNBLOCK_THREADS\n    if (flags & FUNCFLAG_USE_ERRNO) {\n        int temp = space[0];\n        space[0] = errno;\n        errno = temp;\n    }\n#ifdef MS_WIN32\n    if (flags & FUNCFLAG_USE_LASTERROR) {\n        int temp = space[1];\n        space[1] = GetLastError();\n        SetLastError(temp);\n    }\n#ifndef DONT_USE_SEH\n    __try {\n#endif\n#endif\n                ffi_call(&cif, (void *)pProc, resmem, avalues);\n#ifdef MS_WIN32\n#ifndef DONT_USE_SEH\n    }\n    __except (HandleException(GetExceptionInformation(),\n                              &dwExceptionCode, &record)) {\n        ;\n    }\n#endif\n    if (flags & FUNCFLAG_USE_LASTERROR) {\n        int temp = space[1];\n        space[1] = GetLastError();\n        SetLastError(temp);\n    }\n#endif\n    if (flags & FUNCFLAG_USE_ERRNO) {\n        int temp = space[0];\n        space[0] = errno;\n        errno = temp;\n    }\n    if ((flags & FUNCFLAG_PYTHONAPI) == 0)\n        Py_BLOCK_THREADS\n    Py_XDECREF(error_object);\n#ifdef MS_WIN32\n#ifndef DONT_USE_SEH\n    if (dwExceptionCode) {\n        SetException(dwExceptionCode, &record);\n        return -1;\n    }\n#endif\n#endif\n    if ((flags & FUNCFLAG_PYTHONAPI) && PyErr_Occurred())\n        return -1;\n    return 0;\n}\n\n/*\n * Convert the C value in result into a Python object, depending on restype.\n *\n * - If restype is NULL, return a Python integer.\n * - If restype is None, return None.\n * - If restype is a simple ctypes type (c_int, c_void_p), call the type's getfunc,\n *   pass the result to checker and return the result.\n * - If restype is another ctypes type, return an instance of that.\n * - Otherwise, call restype and return the result.\n */\nstatic PyObject *GetResult(PyObject *restype, void *result, PyObject *checker)\n{\n    StgDictObject *dict;\n    PyObject *retval, *v;\n\n    if (restype == NULL)\n        return PyLong_FromLong(*(int *)result);\n\n    if (restype == Py_None) {\n        Py_RETURN_NONE;\n    }\n\n    dict = PyType_stgdict(restype);\n    if (dict == NULL)\n        return PyObject_CallFunction(restype, \"i\", *(int *)result);\n\n    if (dict->getfunc && !_ctypes_simple_instance(restype)) {\n        retval = dict->getfunc(result, dict->size);\n        /* If restype is py_object (detected by comparing getfunc with\n           O_get), we have to call Py_DECREF because O_get has already\n           called Py_INCREF.\n        */\n        if (dict->getfunc == _ctypes_get_fielddesc(\"O\")->getfunc) {\n            Py_DECREF(retval);\n        }\n    } else\n        retval = PyCData_FromBaseObj(restype, NULL, 0, result);\n\n    if (!checker || !retval)\n        return retval;\n\n    v = PyObject_CallFunctionObjArgs(checker, retval, NULL);\n    if (v == NULL)\n        _PyTraceback_Add(\"GetResult\", \"_ctypes/callproc.c\", __LINE__-2);\n    Py_DECREF(retval);\n    return v;\n}\n\n/*\n * Raise a new exception 'exc_class', adding additional text to the original\n * exception string.\n */\nvoid _ctypes_extend_error(PyObject *exc_class, const char *fmt, ...)\n{\n    va_list vargs;\n    PyObject *tp, *v, *tb, *s, *cls_str, *msg_str;\n\n    va_start(vargs, fmt);\n    s = PyUnicode_FromFormatV(fmt, vargs);\n    va_end(vargs);\n    if (!s)\n        return;\n\n    PyErr_Fetch(&tp, &v, &tb);\n    PyErr_NormalizeException(&tp, &v, &tb);\n    cls_str = PyObject_Str(tp);\n    if (cls_str) {\n        PyUnicode_AppendAndDel(&s, cls_str);\n        PyUnicode_AppendAndDel(&s, PyUnicode_FromString(\": \"));\n        if (s == NULL)\n            goto error;\n    } else\n        PyErr_Clear();\n    msg_str = PyObject_Str(v);\n    if (msg_str)\n        PyUnicode_AppendAndDel(&s, msg_str);\n    else {\n        PyErr_Clear();\n        PyUnicode_AppendAndDel(&s, PyUnicode_FromString(\"???\"));\n    }\n    if (s == NULL)\n        goto error;\n    PyErr_SetObject(exc_class, s);\nerror:\n    Py_XDECREF(tp);\n    Py_XDECREF(v);\n    Py_XDECREF(tb);\n    Py_XDECREF(s);\n}\n\n\n#ifdef MS_WIN32\n\nstatic PyObject *\nGetComError(HRESULT errcode, GUID *riid, IUnknown *pIunk)\n{\n    HRESULT hr;\n    ISupportErrorInfo *psei = NULL;\n    IErrorInfo *pei = NULL;\n    BSTR descr=NULL, helpfile=NULL, source=NULL;\n    GUID guid;\n    DWORD helpcontext=0;\n    LPOLESTR progid;\n    PyObject *obj;\n    LPOLESTR text;\n\n    /* We absolutely have to release the GIL during COM method calls,\n       otherwise we may get a deadlock!\n    */\n    Py_BEGIN_ALLOW_THREADS\n\n    hr = pIunk->lpVtbl->QueryInterface(pIunk, &IID_ISupportErrorInfo, (void **)&psei);\n    if (FAILED(hr))\n        goto failed;\n\n    hr = psei->lpVtbl->InterfaceSupportsErrorInfo(psei, riid);\n    psei->lpVtbl->Release(psei);\n    if (FAILED(hr))\n        goto failed;\n\n    hr = GetErrorInfo(0, &pei);\n    if (hr != S_OK)\n        goto failed;\n\n    pei->lpVtbl->GetDescription(pei, &descr);\n    pei->lpVtbl->GetGUID(pei, &guid);\n    pei->lpVtbl->GetHelpContext(pei, &helpcontext);\n    pei->lpVtbl->GetHelpFile(pei, &helpfile);\n    pei->lpVtbl->GetSource(pei, &source);\n\n    pei->lpVtbl->Release(pei);\n\n  failed:\n    Py_END_ALLOW_THREADS\n\n    progid = NULL;\n    ProgIDFromCLSID(&guid, &progid);\n\n    text = FormatError(errcode);\n    obj = Py_BuildValue(\n        \"iu(uuuiu)\",\n        errcode,\n        text,\n        descr, source, helpfile, helpcontext,\n        progid);\n    if (obj) {\n        PyErr_SetObject(ComError, obj);\n        Py_DECREF(obj);\n    }\n    LocalFree(text);\n\n    if (descr)\n        SysFreeString(descr);\n    if (helpfile)\n        SysFreeString(helpfile);\n    if (source)\n        SysFreeString(source);\n\n    return NULL;\n}\n#endif\n\n#if (defined(__x86_64__) && (defined(__MINGW64__) || defined(__CYGWIN__))) || \\\n    defined(__aarch64__) || defined(__riscv)\n#define CTYPES_PASS_BY_REF_HACK\n#define POW2(x) (((x & ~(x - 1)) == x) ? x : 0)\n#define IS_PASS_BY_REF(x) (x > 8 || !POW2(x))\n#endif\n\n/*\n * Requirements, must be ensured by the caller:\n * - argtuple is tuple of arguments\n * - argtypes is either NULL, or a tuple of the same size as argtuple\n *\n * - XXX various requirements for restype, not yet collected\n */\nPyObject *_ctypes_callproc(PPROC pProc,\n                    PyObject *argtuple,\n#ifdef MS_WIN32\n                    IUnknown *pIunk,\n                    GUID *iid,\n#endif\n                    int flags,\n                    PyObject *argtypes, /* misleading name: This is a tuple of\n                                           methods, not types: the .from_param\n                                           class methods of the types */\n            PyObject *restype,\n            PyObject *checker)\n{\n    Py_ssize_t i, n, argcount, argtype_count;\n    void *resbuf;\n    struct argument *args, *pa;\n    ffi_type **atypes;\n    ffi_type *rtype;\n    void **avalues;\n    PyObject *retval = NULL;\n\n    n = argcount = PyTuple_GET_SIZE(argtuple);\n#ifdef MS_WIN32\n    /* an optional COM object this pointer */\n    if (pIunk)\n        ++argcount;\n#endif\n\n    args = (struct argument *)alloca(sizeof(struct argument) * argcount);\n    if (!args) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    memset(args, 0, sizeof(struct argument) * argcount);\n    argtype_count = argtypes ? PyTuple_GET_SIZE(argtypes) : 0;\n#ifdef MS_WIN32\n    if (pIunk) {\n        args[0].ffi_type = &ffi_type_pointer;\n        args[0].value.p = pIunk;\n        pa = &args[1];\n    } else\n#endif\n        pa = &args[0];\n\n    /* Convert the arguments */\n    for (i = 0; i < n; ++i, ++pa) {\n        PyObject *converter;\n        PyObject *arg;\n        int err;\n\n        arg = PyTuple_GET_ITEM(argtuple, i);            /* borrowed ref */\n        /* For cdecl functions, we allow more actual arguments\n           than the length of the argtypes tuple.\n           This is checked in _ctypes::PyCFuncPtr_Call\n        */\n        if (argtypes && argtype_count > i) {\n            PyObject *v;\n            converter = PyTuple_GET_ITEM(argtypes, i);\n            v = PyObject_CallFunctionObjArgs(converter, arg, NULL);\n            if (v == NULL) {\n                _ctypes_extend_error(PyExc_ArgError, \"argument %zd: \", i+1);\n                goto cleanup;\n            }\n\n            err = ConvParam(v, i+1, pa);\n            Py_DECREF(v);\n            if (-1 == err) {\n                _ctypes_extend_error(PyExc_ArgError, \"argument %zd: \", i+1);\n                goto cleanup;\n            }\n        } else {\n            err = ConvParam(arg, i+1, pa);\n            if (-1 == err) {\n                _ctypes_extend_error(PyExc_ArgError, \"argument %zd: \", i+1);\n                goto cleanup; /* leaking ? */\n            }\n        }\n    }\n\n    rtype = _ctypes_get_ffi_type(restype);\n    resbuf = alloca(max(rtype->size, sizeof(ffi_arg)));\n\n#ifdef _Py_MEMORY_SANITIZER\n    /* ffi_call actually initializes resbuf, but from asm, which\n     * MemorySanitizer can't detect. Avoid false positives from MSan. */\n    if (resbuf != NULL) {\n        __msan_unpoison(resbuf, max(rtype->size, sizeof(ffi_arg)));\n    }\n#endif\n    avalues = (void **)alloca(sizeof(void *) * argcount);\n    atypes = (ffi_type **)alloca(sizeof(ffi_type *) * argcount);\n    if (!resbuf || !avalues || !atypes) {\n        PyErr_NoMemory();\n        goto cleanup;\n    }\n    for (i = 0; i < argcount; ++i) {\n        atypes[i] = args[i].ffi_type;\n#ifdef CTYPES_PASS_BY_REF_HACK\n        size_t size = atypes[i]->size;\n        if (IS_PASS_BY_REF(size)) {\n            void *tmp = alloca(size);\n            if (atypes[i]->type == FFI_TYPE_STRUCT)\n                memcpy(tmp, args[i].value.p, size);\n            else\n                memcpy(tmp, (void*)&args[i].value, size);\n\n            avalues[i] = tmp;\n        }\n        else\n#endif\n        if (atypes[i]->type == FFI_TYPE_STRUCT)\n            avalues[i] = (void *)args[i].value.p;\n        else\n            avalues[i] = (void *)&args[i].value;\n    }\n\n    if (-1 == _call_function_pointer(flags, pProc, avalues, atypes,\n                                     rtype, resbuf,\n                                     Py_SAFE_DOWNCAST(argcount,\n                                                      Py_ssize_t,\n                                                      int)))\n        goto cleanup;\n\n#ifdef WORDS_BIGENDIAN\n    /* libffi returns the result in a buffer with sizeof(ffi_arg). This\n       causes problems on big endian machines, since the result buffer\n       address cannot simply be used as result pointer, instead we must\n       adjust the pointer value:\n     */\n    /*\n      XXX I should find out and clarify why this is needed at all,\n      especially why adjusting for ffi_type_float must be avoided on\n      64-bit platforms.\n     */\n    if (rtype->type != FFI_TYPE_FLOAT\n        && rtype->type != FFI_TYPE_STRUCT\n        && rtype->size < sizeof(ffi_arg))\n        resbuf = (char *)resbuf + sizeof(ffi_arg) - rtype->size;\n#endif\n\n#ifdef MS_WIN32\n    if (iid && pIunk) {\n        if (*(int *)resbuf & 0x80000000)\n            retval = GetComError(*(HRESULT *)resbuf, iid, pIunk);\n        else\n            retval = PyLong_FromLong(*(int *)resbuf);\n    } else if (flags & FUNCFLAG_HRESULT) {\n        if (*(int *)resbuf & 0x80000000)\n            retval = PyErr_SetFromWindowsErr(*(int *)resbuf);\n        else\n            retval = PyLong_FromLong(*(int *)resbuf);\n    } else\n#endif\n        retval = GetResult(restype, resbuf, checker);\n  cleanup:\n    for (i = 0; i < argcount; ++i)\n        Py_XDECREF(args[i].keep);\n    return retval;\n}\n\nstatic int\n_parse_voidp(PyObject *obj, void **address)\n{\n    *address = PyLong_AsVoidPtr(obj);\n    if (*address == NULL)\n        return 0;\n    return 1;\n}\n\n#ifdef MS_WIN32\n\nstatic const char format_error_doc[] =\n\"FormatError([integer]) -> string\\n\\\n\\n\\\nConvert a win32 error code into a string. If the error code is not\\n\\\ngiven, the return value of a call to GetLastError() is used.\\n\";\nstatic PyObject *format_error(PyObject *self, PyObject *args)\n{\n    PyObject *result;\n    wchar_t *lpMsgBuf;\n    DWORD code = 0;\n    if (!PyArg_ParseTuple(args, \"|i:FormatError\", &code))\n        return NULL;\n    if (code == 0)\n        code = GetLastError();\n    lpMsgBuf = FormatError(code);\n    if (lpMsgBuf) {\n        result = PyUnicode_FromWideChar(lpMsgBuf, wcslen(lpMsgBuf));\n        LocalFree(lpMsgBuf);\n    } else {\n        result = PyUnicode_FromString(\"<no description>\");\n    }\n    return result;\n}\n\nstatic const char load_library_doc[] =\n\"LoadLibrary(name, load_flags) -> handle\\n\\\n\\n\\\nLoad an executable (usually a DLL), and return a handle to it.\\n\\\nThe handle may be used to locate exported functions in this\\n\\\nmodule. load_flags are as defined for LoadLibraryEx in the\\n\\\nWindows API.\\n\";\nstatic PyObject *load_library(PyObject *self, PyObject *args)\n{\n    const WCHAR *name;\n    PyObject *nameobj;\n    int load_flags = 0;\n    HMODULE hMod;\n    DWORD err;\n\n    if (!PyArg_ParseTuple(args, \"U|i:LoadLibrary\", &nameobj, &load_flags))\n        return NULL;\n\n    name = _PyUnicode_AsUnicode(nameobj);\n    if (!name)\n        return NULL;\n\n    if (PySys_Audit(\"ctypes.dlopen\", \"O\", nameobj) < 0) {\n        return NULL;\n    }\n\n    Py_BEGIN_ALLOW_THREADS\n    /* bpo-36085: Limit DLL search directories to avoid pre-loading\n     * attacks and enable use of the AddDllDirectory function.\n     */\n    hMod = LoadLibraryExW(name, NULL, (DWORD)load_flags);\n    err = hMod ? 0 : GetLastError();\n    Py_END_ALLOW_THREADS\n\n    if (err == ERROR_MOD_NOT_FOUND) {\n        PyErr_Format(PyExc_FileNotFoundError,\n                     (\"Could not find module '%.500S' (or one of its \"\n                      \"dependencies). Try using the full path with \"\n                      \"constructor syntax.\"),\n                     nameobj);\n        return NULL;\n    } else if (err) {\n        return PyErr_SetFromWindowsErr(err);\n    }\n#ifdef _WIN64\n    return PyLong_FromVoidPtr(hMod);\n#else\n    return Py_BuildValue(\"i\", hMod);\n#endif\n}\n\nstatic const char free_library_doc[] =\n\"FreeLibrary(handle) -> void\\n\\\n\\n\\\nFree the handle of an executable previously loaded by LoadLibrary.\\n\";\nstatic PyObject *free_library(PyObject *self, PyObject *args)\n{\n    void *hMod;\n    BOOL result;\n    DWORD err;\n    if (!PyArg_ParseTuple(args, \"O&:FreeLibrary\", &_parse_voidp, &hMod))\n        return NULL;\n\n    Py_BEGIN_ALLOW_THREADS\n    result = FreeLibrary((HMODULE)hMod);\n    err = result ? 0 : GetLastError();\n    Py_END_ALLOW_THREADS\n\n    if (!result) {\n        return PyErr_SetFromWindowsErr(err);\n    }\n    Py_RETURN_NONE;\n}\n\nstatic const char copy_com_pointer_doc[] =\n\"CopyComPointer(src, dst) -> HRESULT value\\n\";\n\nstatic PyObject *\ncopy_com_pointer(PyObject *self, PyObject *args)\n{\n    PyObject *p1, *p2, *r = NULL;\n    struct argument a, b;\n    IUnknown *src, **pdst;\n    if (!PyArg_ParseTuple(args, \"OO:CopyComPointer\", &p1, &p2))\n        return NULL;\n    a.keep = b.keep = NULL;\n\n    if (-1 == ConvParam(p1, 0, &a) || -1 == ConvParam(p2, 1, &b))\n        goto done;\n    src = (IUnknown *)a.value.p;\n    pdst = (IUnknown **)b.value.p;\n\n    if (pdst == NULL)\n        r = PyLong_FromLong(E_POINTER);\n    else {\n        if (src)\n            src->lpVtbl->AddRef(src);\n        *pdst = src;\n        r = PyLong_FromLong(S_OK);\n    }\n  done:\n    Py_XDECREF(a.keep);\n    Py_XDECREF(b.keep);\n    return r;\n}\n#else\n\nstatic PyObject *py_dl_open(PyObject *self, PyObject *args)\n{\n    PyObject *name, *name2;\n    char *name_str;\n    void * handle;\n#if HAVE_DECL_RTLD_LOCAL\n    int mode = RTLD_NOW | RTLD_LOCAL;\n#else\n    /* cygwin doesn't define RTLD_LOCAL */\n    int mode = RTLD_NOW;\n#endif\n    if (!PyArg_ParseTuple(args, \"O|i:dlopen\", &name, &mode))\n        return NULL;\n    mode |= RTLD_NOW;\n    if (name != Py_None) {\n        if (PyUnicode_FSConverter(name, &name2) == 0)\n            return NULL;\n        if (PyBytes_Check(name2))\n            name_str = PyBytes_AS_STRING(name2);\n        else\n            name_str = PyByteArray_AS_STRING(name2);\n    } else {\n        name_str = NULL;\n        name2 = NULL;\n    }\n    if (PySys_Audit(\"ctypes.dlopen\", \"s\", name_str) < 0) {\n        return NULL;\n    }\n    handle = ctypes_dlopen(name_str, mode);\n    Py_XDECREF(name2);\n    if (!handle) {\n        const char *errmsg = ctypes_dlerror();\n        if (!errmsg)\n            errmsg = \"dlopen() error\";\n        PyErr_SetString(PyExc_OSError,\n                               errmsg);\n        return NULL;\n    }\n    return PyLong_FromVoidPtr(handle);\n}\n\nstatic PyObject *py_dl_close(PyObject *self, PyObject *args)\n{\n    void *handle;\n\n    if (!PyArg_ParseTuple(args, \"O&:dlclose\", &_parse_voidp, &handle))\n        return NULL;\n    if (dlclose(handle)) {\n        PyErr_SetString(PyExc_OSError,\n                               ctypes_dlerror());\n        return NULL;\n    }\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *py_dl_sym(PyObject *self, PyObject *args)\n{\n    char *name;\n    void *handle;\n    void *ptr;\n\n    if (!PyArg_ParseTuple(args, \"O&s:dlsym\",\n                          &_parse_voidp, &handle, &name))\n        return NULL;\n    if (PySys_Audit(\"ctypes.dlsym/handle\", \"O\", args) < 0) {\n        return NULL;\n    }\n    ptr = ctypes_dlsym((void*)handle, name);\n    if (!ptr) {\n        PyErr_SetString(PyExc_OSError,\n                               ctypes_dlerror());\n        return NULL;\n    }\n    return PyLong_FromVoidPtr(ptr);\n}\n#endif\n\n/*\n * Only for debugging so far: So that we can call CFunction instances\n *\n * XXX Needs to accept more arguments: flags, argtypes, restype\n */\nstatic PyObject *\ncall_function(PyObject *self, PyObject *args)\n{\n    void *func;\n    PyObject *arguments;\n    PyObject *result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O!\",\n                          &_parse_voidp, &func,\n                          &PyTuple_Type, &arguments))\n        return NULL;\n    if (PySys_Audit(\"ctypes.call_function\", \"nO\",\n                    (Py_ssize_t)func, arguments) < 0) {\n        return NULL;\n    }\n\n    result =  _ctypes_callproc((PPROC)func,\n                        arguments,\n#ifdef MS_WIN32\n                        NULL,\n                        NULL,\n#endif\n                        0, /* flags */\n                NULL, /* self->argtypes */\n                NULL, /* self->restype */\n                NULL); /* checker */\n    return result;\n}\n\n/*\n * Only for debugging so far: So that we can call CFunction instances\n *\n * XXX Needs to accept more arguments: flags, argtypes, restype\n */\nstatic PyObject *\ncall_cdeclfunction(PyObject *self, PyObject *args)\n{\n    void *func;\n    PyObject *arguments;\n    PyObject *result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O!\",\n                          &_parse_voidp, &func,\n                          &PyTuple_Type, &arguments))\n        return NULL;\n    if (PySys_Audit(\"ctypes.call_function\", \"nO\",\n                    (Py_ssize_t)func, arguments) < 0) {\n        return NULL;\n    }\n\n    result =  _ctypes_callproc((PPROC)func,\n                        arguments,\n#ifdef MS_WIN32\n                        NULL,\n                        NULL,\n#endif\n                        FUNCFLAG_CDECL, /* flags */\n                        NULL, /* self->argtypes */\n                        NULL, /* self->restype */\n                        NULL); /* checker */\n    return result;\n}\n\n/*****************************************************************\n * functions\n */\nstatic const char sizeof_doc[] =\n\"sizeof(C type) -> integer\\n\"\n\"sizeof(C instance) -> integer\\n\"\n\"Return the size in bytes of a C instance\";\n\nstatic PyObject *\nsizeof_func(PyObject *self, PyObject *obj)\n{\n    StgDictObject *dict;\n\n    dict = PyType_stgdict(obj);\n    if (dict)\n        return PyLong_FromSsize_t(dict->size);\n\n    if (CDataObject_Check(obj))\n        return PyLong_FromSsize_t(((CDataObject *)obj)->b_size);\n    PyErr_SetString(PyExc_TypeError,\n                    \"this type has no size\");\n    return NULL;\n}\n\nstatic const char alignment_doc[] =\n\"alignment(C type) -> integer\\n\"\n\"alignment(C instance) -> integer\\n\"\n\"Return the alignment requirements of a C instance\";\n\nstatic PyObject *\nalign_func(PyObject *self, PyObject *obj)\n{\n    StgDictObject *dict;\n\n    dict = PyType_stgdict(obj);\n    if (dict)\n        return PyLong_FromSsize_t(dict->align);\n\n    dict = PyObject_stgdict(obj);\n    if (dict)\n        return PyLong_FromSsize_t(dict->align);\n\n    PyErr_SetString(PyExc_TypeError,\n                    \"no alignment info\");\n    return NULL;\n}\n\nstatic const char byref_doc[] =\n\"byref(C instance[, offset=0]) -> byref-object\\n\"\n\"Return a pointer lookalike to a C instance, only usable\\n\"\n\"as function argument\";\n\n/*\n * We must return something which can be converted to a parameter,\n * but still has a reference to self.\n */\nstatic PyObject *\nbyref(PyObject *self, PyObject *args)\n{\n    PyCArgObject *parg;\n    PyObject *obj;\n    PyObject *pyoffset = NULL;\n    Py_ssize_t offset = 0;\n\n    if (!PyArg_UnpackTuple(args, \"byref\", 1, 2,\n                           &obj, &pyoffset))\n        return NULL;\n    if (pyoffset) {\n        offset = PyNumber_AsSsize_t(pyoffset, NULL);\n        if (offset == -1 && PyErr_Occurred())\n            return NULL;\n    }\n    if (!CDataObject_Check(obj)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"byref() argument must be a ctypes instance, not '%s'\",\n                     Py_TYPE(obj)->tp_name);\n        return NULL;\n    }\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    Py_INCREF(obj);\n    parg->obj = obj;\n    parg->value.p = (char *)((CDataObject *)obj)->b_ptr + offset;\n    return (PyObject *)parg;\n}\n\nstatic const char addressof_doc[] =\n\"addressof(C instance) -> integer\\n\"\n\"Return the address of the C instance internal buffer\";\n\nstatic PyObject *\naddressof(PyObject *self, PyObject *obj)\n{\n    if (!CDataObject_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"invalid type\");\n        return NULL;\n    }\n    if (PySys_Audit(\"ctypes.addressof\", \"(O)\", obj) < 0) {\n        return NULL;\n    }\n    return PyLong_FromVoidPtr(((CDataObject *)obj)->b_ptr);\n}\n\nstatic int\nconverter(PyObject *obj, void **address)\n{\n    *address = PyLong_AsVoidPtr(obj);\n    return *address != NULL;\n}\n\nstatic PyObject *\nMy_PyObj_FromPtr(PyObject *self, PyObject *args)\n{\n    PyObject *ob;\n    if (!PyArg_ParseTuple(args, \"O&:PyObj_FromPtr\", converter, &ob)) {\n        return NULL;\n    }\n    if (PySys_Audit(\"ctypes.PyObj_FromPtr\", \"(O)\", ob) < 0) {\n        return NULL;\n    }\n    Py_INCREF(ob);\n    return ob;\n}\n\nstatic PyObject *\nMy_Py_INCREF(PyObject *self, PyObject *arg)\n{\n    Py_INCREF(arg); /* that's what this function is for */\n    Py_INCREF(arg); /* that for returning it */\n    return arg;\n}\n\nstatic PyObject *\nMy_Py_DECREF(PyObject *self, PyObject *arg)\n{\n    Py_DECREF(arg); /* that's what this function is for */\n    Py_INCREF(arg); /* that's for returning it */\n    return arg;\n}\n\nstatic PyObject *\nresize(PyObject *self, PyObject *args)\n{\n    CDataObject *obj;\n    StgDictObject *dict;\n    Py_ssize_t size;\n\n    if (!PyArg_ParseTuple(args,\n                          \"On:resize\",\n                          &obj, &size))\n        return NULL;\n\n    dict = PyObject_stgdict((PyObject *)obj);\n    if (dict == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"excepted ctypes instance\");\n        return NULL;\n    }\n    if (size < dict->size) {\n        PyErr_Format(PyExc_ValueError,\n                     \"minimum size is %zd\",\n                     dict->size);\n        return NULL;\n    }\n    if (obj->b_needsfree == 0) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Memory cannot be resized because this object doesn't own it\");\n        return NULL;\n    }\n    if ((size_t)size <= sizeof(obj->b_value)) {\n        /* internal default buffer is large enough */\n        obj->b_size = size;\n        goto done;\n    }\n    if (!_CDataObject_HasExternalBuffer(obj)) {\n        /* We are currently using the objects default buffer, but it\n           isn't large enough any more. */\n        void *ptr = PyMem_Malloc(size);\n        if (ptr == NULL)\n            return PyErr_NoMemory();\n        memset(ptr, 0, size);\n        memmove(ptr, obj->b_ptr, obj->b_size);\n        obj->b_ptr = ptr;\n        obj->b_size = size;\n    } else {\n        void * ptr = PyMem_Realloc(obj->b_ptr, size);\n        if (ptr == NULL)\n            return PyErr_NoMemory();\n        obj->b_ptr = ptr;\n        obj->b_size = size;\n    }\n  done:\n    Py_RETURN_NONE;\n}\n\nstatic PyObject *\nunpickle(PyObject *self, PyObject *args)\n{\n    PyObject *typ, *state, *meth, *obj, *result;\n    _Py_IDENTIFIER(__new__);\n    _Py_IDENTIFIER(__setstate__);\n\n    if (!PyArg_ParseTuple(args, \"OO!\", &typ, &PyTuple_Type, &state))\n        return NULL;\n    obj = _PyObject_CallMethodIdObjArgs(typ, &PyId___new__, typ, NULL);\n    if (obj == NULL)\n        return NULL;\n\n    meth = _PyObject_GetAttrId(obj, &PyId___setstate__);\n    if (meth == NULL) {\n        goto error;\n    }\n\n    result = PyObject_Call(meth, state, NULL);\n    Py_DECREF(meth);\n    if (result == NULL) {\n        goto error;\n    }\n    Py_DECREF(result);\n\n    return obj;\n\nerror:\n    Py_DECREF(obj);\n    return NULL;\n}\n\nstatic PyObject *\nPOINTER(PyObject *self, PyObject *cls)\n{\n    PyObject *result;\n    PyTypeObject *typ;\n    PyObject *key;\n    char *buf;\n\n    result = PyDict_GetItemWithError(_ctypes_ptrtype_cache, cls);\n    if (result) {\n        Py_INCREF(result);\n        return result;\n    }\n    else if (PyErr_Occurred()) {\n        return NULL;\n    }\n    if (PyUnicode_CheckExact(cls)) {\n        const char *name = PyUnicode_AsUTF8(cls);\n        if (name == NULL)\n            return NULL;\n        buf = PyMem_Malloc(strlen(name) + 3 + 1);\n        if (buf == NULL)\n            return PyErr_NoMemory();\n        sprintf(buf, \"LP_%s\", name);\n        result = PyObject_CallFunction((PyObject *)Py_TYPE(&PyCPointer_Type),\n                                       \"s(O){}\",\n                                       buf,\n                                       &PyCPointer_Type);\n        PyMem_Free(buf);\n        if (result == NULL)\n            return result;\n        key = PyLong_FromVoidPtr(result);\n        if (key == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n    } else if (PyType_Check(cls)) {\n        typ = (PyTypeObject *)cls;\n        buf = PyMem_Malloc(strlen(typ->tp_name) + 3 + 1);\n        if (buf == NULL)\n            return PyErr_NoMemory();\n        sprintf(buf, \"LP_%s\", typ->tp_name);\n        result = PyObject_CallFunction((PyObject *)Py_TYPE(&PyCPointer_Type),\n                                       \"s(O){sO}\",\n                                       buf,\n                                       &PyCPointer_Type,\n                                       \"_type_\", cls);\n        PyMem_Free(buf);\n        if (result == NULL)\n            return result;\n        Py_INCREF(cls);\n        key = cls;\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"must be a ctypes type\");\n        return NULL;\n    }\n    if (-1 == PyDict_SetItem(_ctypes_ptrtype_cache, key, result)) {\n        Py_DECREF(result);\n        Py_DECREF(key);\n        return NULL;\n    }\n    Py_DECREF(key);\n    return result;\n}\n\nstatic PyObject *\npointer(PyObject *self, PyObject *arg)\n{\n    PyObject *result;\n    PyObject *typ;\n\n    typ = PyDict_GetItemWithError(_ctypes_ptrtype_cache, (PyObject *)Py_TYPE(arg));\n    if (typ) {\n        return PyObject_CallFunctionObjArgs(typ, arg, NULL);\n    }\n    else if (PyErr_Occurred()) {\n        return NULL;\n    }\n    typ = POINTER(NULL, (PyObject *)Py_TYPE(arg));\n    if (typ == NULL)\n        return NULL;\n    result = PyObject_CallFunctionObjArgs(typ, arg, NULL);\n    Py_DECREF(typ);\n    return result;\n}\n\nstatic PyObject *\nbuffer_info(PyObject *self, PyObject *arg)\n{\n    StgDictObject *dict = PyType_stgdict(arg);\n    PyObject *shape;\n    Py_ssize_t i;\n\n    if (dict == NULL)\n        dict = PyObject_stgdict(arg);\n    if (dict == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"not a ctypes type or object\");\n        return NULL;\n    }\n    shape = PyTuple_New(dict->ndim);\n    if (shape == NULL)\n        return NULL;\n    for (i = 0; i < (int)dict->ndim; ++i)\n        PyTuple_SET_ITEM(shape, i, PyLong_FromSsize_t(dict->shape[i]));\n\n    if (PyErr_Occurred()) {\n        Py_DECREF(shape);\n        return NULL;\n    }\n    return Py_BuildValue(\"siN\", dict->format, dict->ndim, shape);\n}\n\nPyMethodDef _ctypes_module_methods[] = {\n    {\"get_errno\", get_errno, METH_NOARGS},\n    {\"set_errno\", set_errno, METH_VARARGS},\n    {\"POINTER\", POINTER, METH_O },\n    {\"pointer\", pointer, METH_O },\n    {\"_unpickle\", unpickle, METH_VARARGS },\n    {\"buffer_info\", buffer_info, METH_O, \"Return buffer interface information\"},\n    {\"resize\", resize, METH_VARARGS, \"Resize the memory buffer of a ctypes instance\"},\n#ifdef MS_WIN32\n    {\"get_last_error\", get_last_error, METH_NOARGS},\n    {\"set_last_error\", set_last_error, METH_VARARGS},\n    {\"CopyComPointer\", copy_com_pointer, METH_VARARGS, copy_com_pointer_doc},\n    {\"FormatError\", format_error, METH_VARARGS, format_error_doc},\n    {\"LoadLibrary\", load_library, METH_VARARGS, load_library_doc},\n    {\"FreeLibrary\", free_library, METH_VARARGS, free_library_doc},\n    {\"_check_HRESULT\", check_hresult, METH_VARARGS},\n#else\n    {\"dlopen\", py_dl_open, METH_VARARGS,\n     \"dlopen(name, flag={RTLD_GLOBAL|RTLD_LOCAL}) open a shared library\"},\n    {\"dlclose\", py_dl_close, METH_VARARGS, \"dlclose a library\"},\n    {\"dlsym\", py_dl_sym, METH_VARARGS, \"find symbol in shared library\"},\n#endif\n    {\"alignment\", align_func, METH_O, alignment_doc},\n    {\"sizeof\", sizeof_func, METH_O, sizeof_doc},\n    {\"byref\", byref, METH_VARARGS, byref_doc},\n    {\"addressof\", addressof, METH_O, addressof_doc},\n    {\"call_function\", call_function, METH_VARARGS },\n    {\"call_cdeclfunction\", call_cdeclfunction, METH_VARARGS },\n    {\"PyObj_FromPtr\", My_PyObj_FromPtr, METH_VARARGS },\n    {\"Py_INCREF\", My_Py_INCREF, METH_O },\n    {\"Py_DECREF\", My_Py_DECREF, METH_O },\n    {NULL,      NULL}        /* Sentinel */\n};\n\n/*\n Local Variables:\n compile-command: \"cd .. && python setup.py -q build -g && python setup.py -q build install --home ~\"\n End:\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Modules/_ctypes/darwin/dlfcn.h": "/*\nCopyright (c) 2002 Jorge Acereda  <jacereda@users.sourceforge.net> &\n                   Peter O'Gorman <ogorman@users.sourceforge.net>\n                   \nPortions may be copyright others, see the AUTHORS file included with this\ndistribution.\n\nMaintained by Peter O'Gorman <ogorman@users.sourceforge.net>\n\nBug Reports and other queries should go to <ogorman@users.sourceforge.net>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n#ifndef _DLFCN_H_\n#define _DLFCN_H_\n\n#include <AvailabilityMacros.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/*\n * Structure filled in by dladdr().\n */\n\ntypedef struct dl_info {\n        const char      *dli_fname;     /* Pathname of shared object */\n        void            *dli_fbase;     /* Base address of shared object */\n        const char      *dli_sname;     /* Name of nearest symbol */\n        void            *dli_saddr;     /* Address of nearest symbol */\n} Dl_info;\n\n\n#if MAC_OS_X_VERSION_MIN_REQUIRED <= MAC_OS_X_VERSION_10_2\n#warning CTYPES_DARWIN_DLFCN\n#define CTYPES_DARWIN_DLFCN\nextern void * (*ctypes_dlopen)(const char *path, int mode);\nextern void * (*ctypes_dlsym)(void * handle, const char *symbol);\nextern const char * (*ctypes_dlerror)(void);\nextern int (*ctypes_dlclose)(void * handle);\nextern int (*ctypes_dladdr)(const void *, Dl_info *);\n#else\nextern void * dlopen(const char *path, int mode);\nextern void * dlsym(void * handle, const char *symbol);\nextern const char * dlerror(void);\nextern int dlclose(void * handle);\nextern int dladdr(const void *, Dl_info *);\n#endif\n\n#define RTLD_LAZY\t0x1\n#define RTLD_NOW\t0x2\n#define RTLD_LOCAL\t0x4\n#define RTLD_GLOBAL\t0x8\n#define RTLD_NOLOAD\t0x10\n#define RTLD_NODELETE\t0x80\n\n/* These are from the Mac OS X 10.4 headers */\n#define RTLD_NEXT       ((void *) -1)   /* Search subsequent objects. */\n#define RTLD_DEFAULT    ((void *) -2)   /* Use default search algorithm. */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _DLFCN_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Modules/_ctypes/darwin/dlfcn_simple.c": "/*\nCopyright (c) 2002 Peter O'Gorman <ogorman@users.sourceforge.net>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/* Just to prove that it isn't that hard to add Mac calls to your code :)\n   This works with pretty much everything, including kde3 xemacs and the gimp,\n   I'd guess that it'd work in at least 95% of cases, use this as your starting\n   point, rather than the mess that is dlfcn.c, assuming that your code does not\n   require ref counting or symbol lookups in dependent libraries\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <mach-o/dyld.h>\n#include <AvailabilityMacros.h>\n#include \"dlfcn.h\"\n\n#ifdef CTYPES_DARWIN_DLFCN\n\n#define ERR_STR_LEN 256\n\n#ifndef MAC_OS_X_VERSION_10_3\n#define MAC_OS_X_VERSION_10_3 1030\n#endif\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_3\n#define DARWIN_HAS_DLOPEN\nextern void * dlopen(const char *path, int mode) __attribute__((weak_import));\nextern void * dlsym(void * handle, const char *symbol) __attribute__((weak_import));\nextern const char * dlerror(void) __attribute__((weak_import));\nextern int dlclose(void * handle) __attribute__((weak_import));\nextern int dladdr(const void *, Dl_info *) __attribute__((weak_import));\n#endif /* MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_3 */\n\n#ifndef DARWIN_HAS_DLOPEN\n#define dlopen darwin_dlopen\n#define dlsym darwin_dlsym\n#define dlerror darwin_dlerror\n#define dlclose darwin_dlclose\n#define dladdr darwin_dladdr\n#endif\n\nvoid * (*ctypes_dlopen)(const char *path, int mode);\nvoid * (*ctypes_dlsym)(void * handle, const char *symbol);\nconst char * (*ctypes_dlerror)(void);\nint (*ctypes_dlclose)(void * handle);\nint (*ctypes_dladdr)(const void *, Dl_info *);\n\n#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3\n/* Mac OS X 10.3+ has dlopen, so strip all this dead code to avoid warnings */\n\nstatic void *dlsymIntern(void *handle, const char *symbol);\n\nstatic const char *error(int setget, const char *str, ...);\n\n/* Set and get the error string for use by dlerror */\nstatic const char *error(int setget, const char *str, ...)\n{\n    static char errstr[ERR_STR_LEN];\n    static int err_filled = 0;\n    const char *retval;\n    va_list arg;\n    if (setget == 0)\n    {\n        va_start(arg, str);\n        strncpy(errstr, \"dlcompat: \", ERR_STR_LEN);\n        vsnprintf(errstr + 10, ERR_STR_LEN - 10, str, arg);\n        va_end(arg);\n        err_filled = 1;\n        retval = NULL;\n    }\n    else\n    {\n        if (!err_filled)\n            retval = NULL;\n        else\n            retval = errstr;\n        err_filled = 0;\n    }\n    return retval;\n}\n\n/* darwin_dlopen */\nstatic void *darwin_dlopen(const char *path, int mode)\n{\n    void *module = 0;\n    NSObjectFileImage ofi = 0;\n    NSObjectFileImageReturnCode ofirc;\n\n    /* If we got no path, the app wants the global namespace, use -1 as the marker\n       in this case */\n    if (!path)\n        return (void *)-1;\n\n    /* Create the object file image, works for things linked with the -bundle arg to ld */\n    ofirc = NSCreateObjectFileImageFromFile(path, &ofi);\n    switch (ofirc)\n    {\n        case NSObjectFileImageSuccess:\n            /* It was okay, so use NSLinkModule to link in the image */\n            module = NSLinkModule(ofi, path,\n                                                      NSLINKMODULE_OPTION_RETURN_ON_ERROR\n                                                      | (mode & RTLD_GLOBAL) ? 0 : NSLINKMODULE_OPTION_PRIVATE\n                                                      | (mode & RTLD_LAZY) ? 0 : NSLINKMODULE_OPTION_BINDNOW);\n            NSDestroyObjectFileImage(ofi);\n            break;\n        case NSObjectFileImageInappropriateFile:\n            /* It may have been a dynamic library rather than a bundle, try to load it */\n            module = (void *)NSAddImage(path, NSADDIMAGE_OPTION_RETURN_ON_ERROR);\n            break;\n        default:\n            /* God knows what we got */\n            error(0, \"Can not open \\\"%s\\\"\", path);\n            return 0;\n    }\n    if (!module)\n        error(0, \"Can not open \\\"%s\\\"\", path);\n    return module;\n\n}\n\n/* dlsymIntern is used by dlsym to find the symbol */\nstatic void *dlsymIntern(void *handle, const char *symbol)\n{\n    NSSymbol nssym = 0;\n    /* If the handle is -1, if is the app global context */\n    if (handle == (void *)-1)\n    {\n        /* Global context, use NSLookupAndBindSymbol */\n        if (NSIsSymbolNameDefined(symbol))\n        {\n            nssym = NSLookupAndBindSymbol(symbol);\n        }\n\n    }\n    /* Now see if the handle is a struch mach_header* or not, use NSLookupSymbol in image\n       for libraries, and NSLookupSymbolInModule for bundles */\n    else\n    {\n        /* Check for both possible magic numbers depending on x86/ppc byte order */\n        if ((((struct mach_header *)handle)->magic == MH_MAGIC) ||\n            (((struct mach_header *)handle)->magic == MH_CIGAM))\n        {\n            if (NSIsSymbolNameDefinedInImage((struct mach_header *)handle, symbol))\n            {\n                nssym = NSLookupSymbolInImage((struct mach_header *)handle,\n                                                                          symbol,\n                                                                          NSLOOKUPSYMBOLINIMAGE_OPTION_BIND\n                                                                          | NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);\n            }\n\n        }\n        else\n        {\n            nssym = NSLookupSymbolInModule(handle, symbol);\n        }\n    }\n    if (!nssym)\n    {\n        error(0, \"Symbol \\\"%s\\\" Not found\", symbol);\n        return NULL;\n    }\n    return NSAddressOfSymbol(nssym);\n}\n\nstatic const char *darwin_dlerror(void)\n{\n    return error(1, (char *)NULL);\n}\n\nstatic int darwin_dlclose(void *handle)\n{\n    if ((((struct mach_header *)handle)->magic == MH_MAGIC) ||\n        (((struct mach_header *)handle)->magic == MH_CIGAM))\n    {\n        error(0, \"Can't remove dynamic libraries on darwin\");\n        return 0;\n    }\n    if (!NSUnLinkModule(handle, 0))\n    {\n        error(0, \"unable to unlink module %s\", NSNameOfModule(handle));\n        return 1;\n    }\n    return 0;\n}\n\n\n/* dlsym, prepend the underscore and call dlsymIntern */\nstatic void *darwin_dlsym(void *handle, const char *symbol)\n{\n    static char undersym[257];          /* Saves calls to malloc(3) */\n    int sym_len = strlen(symbol);\n    void *value = NULL;\n    char *malloc_sym = NULL;\n\n    if (sym_len < 256)\n    {\n        snprintf(undersym, 256, \"_%s\", symbol);\n        value = dlsymIntern(handle, undersym);\n    }\n    else\n    {\n        malloc_sym = malloc(sym_len + 2);\n        if (malloc_sym)\n        {\n            sprintf(malloc_sym, \"_%s\", symbol);\n            value = dlsymIntern(handle, malloc_sym);\n            free(malloc_sym);\n        }\n        else\n        {\n            error(0, \"Unable to allocate memory\");\n        }\n    }\n    return value;\n}\n\nstatic int darwin_dladdr(const void *handle, Dl_info *info) {\n    return 0;\n}\n#endif /* MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3 */\n\n#if __GNUC__ < 4\n#pragma CALL_ON_LOAD ctypes_dlfcn_init\n#else\nstatic void __attribute__ ((constructor)) ctypes_dlfcn_init(void);\nstatic\n#endif\nvoid ctypes_dlfcn_init(void) {\n    if (dlopen != NULL) {\n        ctypes_dlsym = dlsym;\n        ctypes_dlopen = dlopen;\n        ctypes_dlerror = dlerror;\n        ctypes_dlclose = dlclose;\n        ctypes_dladdr = dladdr;\n    } else {\n#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3\n        ctypes_dlsym = darwin_dlsym;\n        ctypes_dlopen = darwin_dlopen;\n        ctypes_dlerror = darwin_dlerror;\n        ctypes_dlclose = darwin_dlclose;\n        ctypes_dladdr = darwin_dladdr;\n#endif /* MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3 */\n    }\n}\n\n#endif /* CTYPES_DARWIN_DLFCN */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/ensurepip/_bundled/pip-19.2.3-py2.py3-none-any.whl",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/ensurepip/_bundled/setuptools-41.2.0-py2.py3-none-any.whl",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/sqlite3/test/transactions.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/sqlite3/test/hooks.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/sqlite3/test/types.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/sqlite3/test/factory.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/sqlite3/test/dbapi.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/sqlite3/test/userfunctions.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/sqlite3/test/regression.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/idle.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/plusnode.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/idle_32.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/idle_48.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/idle_16.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/folder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/openfolder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/minusnode.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/tk.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/python.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/idle.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/idle_48.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/idle_32.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/idlelib/Icons/idle_16.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/testtar.tar",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/zip_cp437_header.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/pstats.pck",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/zipdir.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/badsyntax_pep3120.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/sgml_input.html",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/Sine-1000Hz-300ms.aif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiotest.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/test_source_encoding.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/sndhdrdata/sndhdr.voc",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/sndhdrdata/sndhdr.wav",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/sndhdrdata/sndhdr.8svx",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/sndhdrdata/sndhdr.aifc",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/sndhdrdata/sndhdr.sndt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/sndhdrdata/sndhdr.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/sndhdrdata/sndhdr.aiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/sndhdrdata/sndhdr.hcom",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm8.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm24.wav",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm8.wav",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm24.aiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm8.aiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-alaw.aifc",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm16.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-ulaw.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm32.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm32.aiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm16.wav",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm24.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-ulaw.aifc",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm32.wav",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/audiodata/pluck-pcm16.aiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/encoded_modules/module_iso_8859_1.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/encoded_modules/module_koi8_r.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/test_importlib/data/example-21.12-py3-none-any.whl",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/test_importlib/data/example-21.12-py3.6.egg",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/test_importlib/zipdata02/ziptestdata.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/test_importlib/zipdata01/ziptestdata.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/test_importlib/data01/utf-16.file",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/test_importlib/namespace_pkgs/top_level_portion1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/test_importlib/namespace_pkgs/nested_portion1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/test_importlib/namespace_pkgs/missing_directory.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/johab.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/shift_jis.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/gb18030.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/euc_jp.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/big5.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/euc_jisx0213.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/big5hkscs.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/euc_kr.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/shift_jisx0213.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/gb2312.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/gbk.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/cjkencodings/cp949.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/test_email/data/PyBanner048.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/test_email/data/audiotest.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.ppm",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.pbm",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.exr",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.ras",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.pgm",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.webp",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/imghdrdata/python.sgi",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/xmltestdata/test.xml",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/test/xmltestdata/test.xml.out",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/distutils/command/wininst-9.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/distutils/command/wininst-8.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/distutils/command/wininst-10.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/distutils/command/wininst-6.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/distutils/command/wininst-14.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/distutils/command/wininst-7.1.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/distutils/command/wininst-10.0-amd64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/distutils/command/wininst-14.0-amd64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Lib/distutils/command/wininst-9.0-amd64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/BuildScript/resources/background.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/IDLE/IDLE.app/Contents/Resources/PythonSource.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/IDLE/IDLE.app/Contents/Resources/PythonCompiled.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/IDLE/IDLE.app/Contents/Resources/IDLE.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Resources/app/Resources/PythonApplet.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Resources/app/Resources/PythonInterpreter.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Resources/iconsrc/IDE.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Resources/iconsrc/PythonApplet.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Resources/iconsrc/PythonSource.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Resources/iconsrc/PackageManager.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Resources/iconsrc/PythonCompiled.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Resources/iconsrc/PythonWSource.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Resources/iconsrc/PythonIcon.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/PythonLauncher/English.lproj/MyDocument.nib/objects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/PythonLauncher/English.lproj/MainMenu.nib/objects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/PythonLauncher/English.lproj/PreferenceWindow.nib/objects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Icons/Python Folder.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Icons/PythonSource.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Icons/Disk Image.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Icons/PythonLauncher.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Icons/PythonCompiled.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Mac/Icons/IDLE.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Tools/test2to3/setup.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Tools/msi/bundle/SideBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Tools/i18n/pygettext.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Doc/library/turtle-star.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Doc/library/hashlib-blake2-tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Doc/library/tulip_coro.dia",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Doc/library/tulip_coro.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Doc/library/turtle-star.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Doc/library/pathlib-inheritance.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Doc/howto/logging_flow.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Doc/using/win_installer.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/Doc/faq/python-video-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/classicAppCompat.cat",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/setup.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/py.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/py.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/pythonwx150.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/pythonx50.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/launcher.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/pythonx150.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/pyd.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/python.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/pyd.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/launcher.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/pyc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/setup.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/pythonw.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/pyc.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/py.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/pythonwx44.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/python.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/pythonx44.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/icons/pythonw.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.8.2-xnbz3fwkjjoatscgqorajp6tilm5k5j5/spack-src/PC/bdist_wininst/PythonPowered.bmp"
    ],
    "total_files": 3999
}