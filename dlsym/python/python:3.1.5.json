{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/os2emx/dlfcn.h": "/* -*- C -*- ***********************************************\nCopyright 1991-1995 by Stichting Mathematisch Centrum, Amsterdam,\nThe Netherlands.\n\n                        All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the names of Stichting Mathematisch\nCentrum or CWI or Corporation for National Research Initiatives or\nCNRI not be used in advertising or publicity pertaining to\ndistribution of the software without specific, written prior\npermission.\n\nWhile CWI is the initial source for this software, a modified version\nis made available by the Corporation for National Research Initiatives\n(CNRI) at the Internet address ftp://ftp.python.org.\n\nSTICHTING MATHEMATISCH CENTRUM AND CNRI DISCLAIM ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH\nCENTRUM OR CNRI BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\nDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\nPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n\n******************************************************************/\n\n/* This library implements dlopen() - Unix-like dynamic linking\n * emulation functions for OS/2 using DosLoadModule() and company.\n */\n\n#ifndef _DLFCN_H\n#define _DLFCN_H\n\n/* load a dynamic-link library and return handle */\nvoid *dlopen(char *filename, int flags);\n\n/* return a pointer to the `symbol' in DLL */\nvoid *dlsym(void *handle, char *symbol);\n\n/* free dynamically-linked library */\nint dlclose(void *handle);\n\n/* return a string describing last occurred dl error */\nchar *dlerror(void);\n\n#endif /* !_DLFCN_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/os2emx/python27.def": "LIBRARY python26 INITINSTANCE TERMINSTANCE \nDESCRIPTION \"Python 2.6 Core DLL\" \nPROTMODE \nDATA MULTIPLE NONSHARED \nEXPORTS \n\n; From python26_s.lib(config)\n  \"_PyImport_Inittab\"\n\n; From python26_s.lib(dlfcn)\n;  \"dlopen\"\n;  \"dlsym\"\n;  \"dlclose\"\n;  \"dlerror\"\n\n; From python26_s.lib(getpathp)\n  \"Py_GetProgramFullPath\"\n  \"Py_GetPrefix\"\n  \"Py_GetExecPrefix\"\n  \"Py_GetPath\"\n\n; From python26_s.lib(getbuildinfo)\n  \"Py_GetBuildInfo\"\n  \"_Py_svnversion\"\n\n; From python26_s.lib(main)\n  \"Py_Main\"\n  \"Py_GetArgcArgv\"\n\n; From python26_s.lib(acceler)\n  \"PyGrammar_AddAccelerators\"\n  \"PyGrammar_RemoveAccelerators\"\n\n; From python26_s.lib(grammar1)\n  \"PyGrammar_FindDFA\"\n  \"PyGrammar_LabelRepr\"\n\n; From python26_s.lib(listnode)\n  \"PyNode_ListTree\"\n\n; From python26_s.lib(node)\n  \"PyNode_New\"\n  \"PyNode_AddChild\"\n  \"PyNode_Free\"\n\n; From python26_s.lib(parser)\n  \"PyParser_AddToken\"\n  \"PyParser_New\"\n  \"PyParser_Delete\"\n\n; From python26_s.lib(parsetok)\n  \"PyParser_ParseString\"\n  \"PyParser_ParseStringFlagsFilename\"\n  \"PyParser_ParseFile\"\n  \"PyParser_ParseFileFlags\"\n  \"PyParser_ParseStringFlags\"\n\n; From python26_s.lib(bitset)\n  \"_Py_newbitset\"\n  \"_Py_delbitset\"\n  \"_Py_addbit\"\n  \"_Py_samebitset\"\n  \"_Py_mergebitset\"\n\n; From python26_s.lib(metagrammar)\n  \"_Py_meta_grammar\"\n  \"Py_meta_grammar\"\n\n; From python26_s.lib(tokenizer)\n  \"PyToken_OneChar\"\n  \"PyToken_TwoChars\"\n  \"PyToken_ThreeChars\"\n  \"PyTokenizer_FromString\"\n  \"PyTokenizer_Free\"\n  \"PyTokenizer_FromFile\"\n  \"PyTokenizer_Get\"\n  \"_PyParser_TokenNames\"\n\n; From python26_s.lib(myreadline)\n  \"_PyOS_ReadlineTState\"\n  \"PyOS_ReadlineFunctionPointer\"\n  \"PyOS_StdioReadline\"\n  \"PyOS_Readline\"\n  \"PyOS_InputHook\"\n\n; From python26_s.lib(abstract)\n  \"_PyObject_LengthHint\"\n  \"PyMapping_Size\"\n  \"PyObject_CallMethod\"\n  \"PyObject_GetItem\"\n  \"PySequence_GetItem\"\n  \"PyObject_SetItem\"\n  \"PySequence_SetItem\"\n  \"PyObject_DelItem\"\n  \"PySequence_DelItem\"\n  \"PyNumber_Multiply\"\n  \"PyNumber_InPlaceAdd\"\n  \"PyNumber_InPlaceMultiply\"\n  \"PyNumber_Int\"\n  \"PyNumber_Long\"\n  \"PyNumber_Float\"\n  \"PySequence_Concat\"\n  \"PySequence_Repeat\"\n  \"PySequence_InPlaceConcat\"\n  \"PySequence_InPlaceRepeat\"\n  \"PySequence_GetSlice\"\n  \"PySequence_SetSlice\"\n  \"PySequence_Tuple\"\n  \"PyObject_GetIter\"\n  \"PyIter_Next\"\n  \"PySequence_Fast\"\n  \"_PySequence_IterSearch\"\n  \"PyObject_CallFunction\"\n  \"_PyObject_CallFunction_SizeT\"\n  \"_PyObject_CallMethod_SizeT\"\n  \"PyObject_CallMethodObjArgs\"\n  \"PyObject_CallFunctionObjArgs\"\n  \"PyObject_Cmp\"\n  \"PyObject_Call\"\n  \"PyObject_CallObject\"\n  \"PyObject_Type\"\n  \"PyObject_Size\"\n  \"PyObject_Length\"\n  \"PyObject_DelItemString\"\n  \"PyObject_AsCharBuffer\"\n  \"PyObject_CheckReadBuffer\"\n  \"PyObject_AsReadBuffer\"\n  \"PyObject_AsWriteBuffer\"\n  \"PyNumber_Check\"\n  \"PyNumber_Add\"\n  \"PyNumber_Subtract\"\n  \"PyNumber_Divide\"\n  \"PyNumber_FloorDivide\"\n  \"PyNumber_TrueDivide\"\n  \"PyNumber_Remainder\"\n  \"PyNumber_Divmod\"\n  \"PyNumber_Power\"\n  \"PyNumber_Negative\"\n  \"PyNumber_Positive\"\n  \"PyNumber_Absolute\"\n  \"PyNumber_Invert\"\n  \"PyNumber_Lshift\"\n  \"PyNumber_Rshift\"\n  \"PyNumber_And\"\n  \"PyNumber_Xor\"\n  \"PyNumber_Or\"\n  \"PyNumber_Index\"\n  \"PyNumber_InPlaceSubtract\"\n  \"PyNumber_InPlaceDivide\"\n  \"PyNumber_InPlaceFloorDivide\"\n  \"PyNumber_InPlaceTrueDivide\"\n  \"PyNumber_InPlaceRemainder\"\n  \"PyNumber_InPlacePower\"\n  \"PyNumber_InPlaceLshift\"\n  \"PyNumber_InPlaceRshift\"\n  \"PyNumber_InPlaceAnd\"\n  \"PyNumber_InPlaceXor\"\n  \"PyNumber_InPlaceOr\"\n  \"PySequence_Check\"\n  \"PySequence_Size\"\n  \"PySequence_Length\"\n  \"PySequence_DelSlice\"\n  \"PySequence_List\"\n  \"PySequence_Count\"\n  \"PySequence_Contains\"\n  \"PySequence_In\"\n  \"PySequence_Index\"\n  \"PyMapping_Check\"\n  \"PyMapping_Length\"\n  \"PyMapping_HasKeyString\"\n  \"PyMapping_HasKey\"\n  \"PyMapping_GetItemString\"\n  \"PyMapping_SetItemString\"\n  \"PyObject_IsInstance\"\n  \"PyObject_IsSubclass\"\n\n; From python26_s.lib(boolobject)\n  \"PyBool_FromLong\"\n  \"PyBool_Type\"\n  \"_Py_ZeroStruct\"\n  \"_Py_TrueStruct\"\n\n; From python26_s.lib(bufferobject)\n  \"PyBuffer_FromObject\"\n  \"PyBuffer_FromReadWriteObject\"\n  \"PyBuffer_FromMemory\"\n  \"PyBuffer_FromReadWriteMemory\"\n  \"PyBuffer_New\"\n  \"PyBuffer_Type\"\n\n; From python26_s.lib(cellobject)\n  \"PyCell_New\"\n  \"PyCell_Get\"\n  \"PyCell_Set\"\n  \"PyCell_Type\"\n\n; From python26_s.lib(classobject)\n  \"PyClass_New\"\n  \"PyClass_IsSubclass\"\n  \"PyInstance_New\"\n  \"PyInstance_NewRaw\"\n  \"PyMethod_New\"\n  \"PyMethod_Function\"\n  \"PyMethod_Self\"\n  \"PyMethod_Class\"\n  \"_PyInstance_Lookup\"\n  \"PyMethod_Fini\"\n  \"PyClass_Type\"\n  \"PyInstance_Type\"\n  \"PyMethod_Type\"\n\n; From python26_s.lib(capsule)\n  \"PyCapsule_GetContext\"\n  \"PyCapsule_GetDestructor\"\n  \"PyCapsule_GetName\"\n  \"PyCapsule_GetPointer\"\n  \"PyCapsule_Import\"\n  \"PyCapsule_IsValid\"\n  \"PyCapsule_New\"\n  \"PyCapsule_SetContext\"\n  \"PyCapsule_SetDestructor\"\n  \"PyCapsule_SetName\"\n  \"PyCapsule_SetPointer\"\n\n; From python26_s.lib(cobject)\n  \"PyCObject_FromVoidPtr\"\n  \"PyCObject_FromVoidPtrAndDesc\"\n  \"PyCObject_AsVoidPtr\"\n  \"PyCObject_GetDesc\"\n  \"PyCObject_Import\"\n  \"PyCObject_SetVoidPtr\"\n  \"PyCObject_Type\"\n\n; From python26_s.lib(codeobject)\n  \"PyCode_New\"\n  \"PyCode_Addr2Line\"\n  \"PyCode_CheckLineNumber\"\n  \"PyCode_Type\"\n\n; From python26_s.lib(complexobject)\n  \"_Py_c_pow\"\n  \"_Py_c_sum\"\n  \"_Py_c_diff\"\n  \"_Py_c_neg\"\n  \"_Py_c_prod\"\n  \"_Py_c_quot\"\n  \"PyComplex_FromCComplex\"\n  \"PyComplex_FromDoubles\"\n  \"PyComplex_RealAsDouble\"\n  \"PyComplex_ImagAsDouble\"\n  \"PyComplex_AsCComplex\"\n  \"PyComplex_Type\"\n\n; From python26_s.lib(descrobject)\n  \"PyWrapper_New\"\n  \"PyDescr_NewMethod\"\n  \"PyDescr_NewClassMethod\"\n  \"PyDescr_NewMember\"\n  \"PyDescr_NewGetSet\"\n  \"PyDescr_NewWrapper\"\n  \"PyDictProxy_New\"\n  \"PyWrapperDescr_Type\"\n  \"PyProperty_Type\"\n\n; From python26_s.lib(dictobject)\n  \"PyDict_New\"\n  \"PyDict_GetItem\"\n  \"PyDict_SetItem\"\n  \"PyDict_DelItem\"\n  \"PyDict_Clear\"\n  \"PyDict_MergeFromSeq2\"\n  \"PyDict_Merge\"\n  \"PyDict_Keys\"\n  \"PyDict_Values\"\n  \"PyDict_Contains\"\n  \"PyDict_Next\"\n  \"PyDict_Items\"\n  \"PyDict_Size\"\n  \"PyDict_Copy\"\n  \"PyDict_Update\"\n  \"PyDict_GetItemString\"\n  \"PyDict_SetItemString\"\n  \"PyDict_DelItemString\"\n  \"PyDict_Type\"\n  \"PyDictIterKey_Type\"\n  \"PyDictIterValue_Type\"\n  \"PyDictIterItem_Type\"\n\n; From python26_s.lib(enumobject)\n  \"PyEnum_Type\"\n  \"PyReversed_Type\"\n\n; From python26_s.lib(fileobject)\n  \"PyFile_FromString\"\n  \"Py_UniversalNewlineFread\"\n  \"PyFile_GetLine\"\n  \"PyFile_SoftSpace\"\n  \"PyFile_WriteObject\"\n  \"PyFile_WriteString\"\n  \"PyObject_AsFileDescriptor\"\n  \"Py_UniversalNewlineFgets\"\n  \"PyFile_SetBufSize\"\n  \"PyFile_SetEncoding\"\n  \"PyFile_FromFile\"\n  \"PyFile_AsFile\"\n  \"PyFile_Name\"\n  \"PyFile_Type\"\n\n; From python26_s.lib(floatobject)\n  \"PyFloat_FromString\"\n  \"PyFloat_AsDouble\"\n  \"PyFloat_Fini\"\n  \"_PyFloat_Pack4\"\n  \"_PyFloat_Pack8\"\n  \"_PyFloat_Unpack4\"\n  \"_PyFloat_Unpack8\"\n  \"PyFloat_FromDouble\"\n  \"PyFloat_AsReprString\"\n  \"PyFloat_AsString\"\n  \"_PyFloat_Init\"\n  \"PyFloat_AsStringEx\"\n  \"PyFloat_Type\"\n\n; From python26_s.lib(frameobject)\n  \"PyFrame_New\"\n  \"PyFrame_FastToLocals\"\n  \"PyFrame_LocalsToFast\"\n  \"_PyFrame_Init\"\n  \"PyFrame_Fini\"\n  \"PyFrame_BlockSetup\"\n  \"PyFrame_BlockPop\"\n  \"PyFrame_Type\"\n\n; From python26_s.lib(funcobject)\n  \"PyFunction_New\"\n  \"PyFunction_GetCode\"\n  \"PyFunction_GetGlobals\"\n  \"PyFunction_GetModule\"\n  \"PyFunction_GetDefaults\"\n  \"PyFunction_SetDefaults\"\n  \"PyFunction_GetClosure\"\n  \"PyFunction_SetClosure\"\n  \"PyClassMethod_New\"\n  \"PyStaticMethod_New\"\n  \"PyFunction_Type\"\n  \"PyClassMethod_Type\"\n  \"PyStaticMethod_Type\"\n\n; From python26_s.lib(genobject)\n  \"PyGen_New\"\n  \"PyGen_NeedsFinalizing\"\n  \"PyGen_Type\"\n\n; From python26_s.lib(intobject)\n  \"PyInt_AsLong\"\n  \"PyInt_AsUnsignedLongMask\"\n  \"PyInt_AsUnsignedLongLongMask\"\n  \"PyInt_FromString\"\n  \"PyInt_AsSsize_t\"\n  \"PyInt_Fini\"\n  \"PyInt_FromUnicode\"\n  \"PyInt_FromLong\"\n  \"PyInt_FromSize_t\"\n  \"PyInt_FromSsize_t\"\n  \"PyInt_GetMax\"\n  \"_PyInt_Init\"\n  \"PyInt_Type\"\n\n; From python26_s.lib(iterobject)\n  \"PySeqIter_New\"\n  \"PyCallIter_New\"\n  \"PySeqIter_Type\"\n  \"PyCallIter_Type\"\n\n; From python26_s.lib(listobject)\n  \"PyList_New\"\n  \"PyList_Append\"\n  \"PyList_Size\"\n  \"PyList_GetItem\"\n  \"PyList_SetItem\"\n  \"PyList_Insert\"\n  \"PyList_GetSlice\"\n  \"PyList_SetSlice\"\n  \"PyList_Sort\"\n  \"PyList_Reverse\"\n  \"PyList_AsTuple\"\n  \"_PyList_Extend\"\n  \"PyList_Fini\"\n  \"PyList_Type\"\n  \"PyListIter_Type\"\n  \"PyListRevIter_Type\"\n\n; From python26_s.lib(longobject)\n  \"PyLong_FromDouble\"\n  \"PyLong_AsLong\"\n  \"_PyLong_AsSsize_t\"\n  \"PyLong_AsUnsignedLong\"\n  \"_PyLong_FromByteArray\"\n  \"_PyLong_AsByteArray\"\n  \"PyLong_AsDouble\"\n  \"PyLong_FromLongLong\"\n  \"PyLong_AsLongLong\"\n  \"PyLong_FromString\"\n  \"PyLong_FromLong\"\n  \"PyLong_FromUnsignedLong\"\n  \"PyLong_AsUnsignedLongMask\"\n  \"_PyLong_FromSize_t\"\n  \"_PyLong_FromSsize_t\"\n  \"_PyLong_AsScaledDouble\"\n  \"PyLong_FromVoidPtr\"\n  \"PyLong_AsVoidPtr\"\n  \"PyLong_FromUnsignedLongLong\"\n  \"PyLong_AsUnsignedLongLong\"\n  \"PyLong_AsUnsignedLongLongMask\"\n  \"PyLong_FromUnicode\"\n  \"_PyLong_Sign\"\n  \"_PyLong_NumBits\"\n  \"_PyLong_New\"\n  \"_PyLong_Copy\"\n  \"PyLong_Type\"\n  \"_PyLong_DigitValue\"\n\n; From python26_s.lib(methodobject)\n  \"PyCFunction_Call\"\n  \"Py_FindMethodInChain\"\n  \"PyCFunction_GetFunction\"\n  \"PyCFunction_GetSelf\"\n  \"PyCFunction_GetFlags\"\n  \"Py_FindMethod\"\n  \"PyCFunction_NewEx\"\n  \"PyCFunction_Fini\"\n  \"PyCFunction_New\"\n  \"PyCFunction_Type\"\n\n; From python26_s.lib(moduleobject)\n  \"PyModule_New\"\n  \"_PyModule_Clear\"\n  \"PyModule_GetDict\"\n  \"PyModule_GetName\"\n  \"PyModule_GetFilename\"\n  \"PyModule_Type\"\n\n; From python26_s.lib(object)\n  \"Py_DivisionWarningFlag\"\n  \"PyObject_Str\"\n  \"PyObject_Repr\"\n  \"_PyObject_Str\"\n  \"PyObject_Unicode\"\n  \"PyObject_GetAttr\"\n  \"PyObject_IsTrue\"\n  \"PyNumber_CoerceEx\"\n  \"PyObject_Compare\"\n  \"PyObject_RichCompare\"\n  \"_Py_HashDouble\"\n  \"PyObject_Hash\"\n  \"PyObject_SetAttr\"\n  \"PyObject_GenericGetAttr\"\n  \"PyObject_GenericSetAttr\"\n  \"PyCallable_Check\"\n  \"PyObject_Dir\"\n  \"PyMem_Malloc\"\n  \"PyMem_Realloc\"\n  \"PyMem_Free\"\n  \"PyObject_Print\"\n  \"_PyObject_Dump\"\n  \"PyObject_RichCompareBool\"\n  \"PyObject_GetAttrString\"\n  \"PyObject_SetAttrString\"\n  \"PyObject_HasAttrString\"\n  \"PyObject_HasAttr\"\n  \"_PyObject_GetDictPtr\"\n  \"PyObject_SelfIter\"\n  \"PyObject_Not\"\n  \"PyNumber_Coerce\"\n  \"Py_ReprEnter\"\n  \"Py_ReprLeave\"\n  \"_Py_HashPointer\"\n  \"Py_IncRef\"\n  \"Py_DecRef\"\n  \"_PyTrash_deposit_object\"\n  \"_PyTrash_destroy_chain\"\n  \"PyObject_Init\"\n  \"PyObject_InitVar\"\n  \"_PyObject_New\"\n  \"_PyObject_NewVar\"\n  \"_PyObject_Del\"\n  \"_Py_ReadyTypes\"\n  \"_Py_SwappedOp\"\n  \"_Py_NotImplementedStruct\"\n  \"_Py_NoneStruct\"\n  \"_Py_cobject_hack\"\n  \"_Py_abstract_hack\"\n  \"_PyTrash_delete_nesting\"\n  \"_PyTrash_delete_later\"\n\n; From python26_s.lib(obmalloc)\n  \"PyObject_Malloc\"\n  \"PyObject_Free\"\n  \"PyObject_Realloc\"\n\n; From python26_s.lib(rangeobject)\n  \"PyRange_Type\"\n\n; From python26_s.lib(setobject)\n  \"PySet_Pop\"\n  \"PySet_New\"\n  \"PyFrozenSet_New\"\n  \"PySet_Size\"\n  \"PySet_Clear\"\n  \"PySet_Contains\"\n  \"PySet_Discard\"\n  \"PySet_Add\"\n  \"_PySet_Next\"\n  \"_PySet_Update\"\n  \"PySet_Fini\"\n  \"PySet_Type\"\n  \"PyFrozenSet_Type\"\n\n; From python26_s.lib(sliceobject)\n  \"_PySlice_FromIndices\"\n  \"PySlice_GetIndices\"\n  \"PySlice_GetIndicesEx\"\n  \"PySlice_New\"\n  \"_Py_EllipsisObject\"\n  \"PySlice_Type\"\n\n; From python26_s.lib(stringobject)\n  \"PyString_FromStringAndSize\"\n  \"PyString_InternInPlace\"\n  \"PyString_FromString\"\n  \"PyString_FromFormatV\"\n  \"PyString_AsString\"\n  \"_PyString_Resize\"\n  \"PyString_FromFormat\"\n  \"PyString_AsDecodedString\"\n  \"PyString_AsEncodedString\"\n  \"PyString_DecodeEscape\"\n  \"PyString_Repr\"\n  \"PyString_AsStringAndSize\"\n  \"_PyString_FormatLong\"\n  \"PyString_Format\"\n  \"_Py_ReleaseInternedStrings\"\n  \"PyString_Size\"\n  \"PyString_Concat\"\n  \"PyString_ConcatAndDel\"\n  \"_PyString_Eq\"\n  \"PyString_InternImmortal\"\n  \"PyString_InternFromString\"\n  \"_PyString_Join\"\n  \"PyString_Decode\"\n  \"PyString_Encode\"\n  \"PyString_AsEncodedObject\"\n  \"PyString_AsDecodedObject\"\n  \"PyString_Fini\"\n  \"PyString_Type\"\n  \"PyBaseString_Type\"\n\n; From python26_s.lib(structseq)\n  \"PyStructSequence_InitType\"\n  \"PyStructSequence_New\"\n  \"PyStructSequence_UnnamedField\"\n\n; From python26_s.lib(tupleobject)\n  \"PyTuple_New\"\n  \"PyTuple_Pack\"\n  \"_PyTuple_Resize\"\n  \"PyTuple_Size\"\n  \"PyTuple_GetItem\"\n  \"PyTuple_SetItem\"\n  \"PyTuple_GetSlice\"\n  \"PyTuple_Fini\"\n  \"PyTuple_Type\"\n  \"PyTupleIter_Type\"\n\n; From python26_s.lib(typeobject)\n  \"PyType_IsSubtype\"\n  \"_PyType_Lookup\"\n  \"PyType_Ready\"\n  \"PyType_GenericAlloc\"\n  \"_PyObject_SlotCompare\"\n  \"PyType_GenericNew\"\n  \"PyType_Type\"\n  \"PyBaseObject_Type\"\n  \"PySuper_Type\"\n\n; From python26_s.lib(unicodeobject)\n  \"PyUnicodeUCS2_Resize\"\n  \"PyUnicodeUCS2_FromOrdinal\"\n  \"PyUnicodeUCS2_FromObject\"\n  \"PyUnicodeUCS2_FromEncodedObject\"\n  \"PyUnicodeUCS2_Decode\"\n  \"PyUnicodeUCS2_GetDefaultEncoding\"\n  \"PyUnicodeUCS2_DecodeUTF8\"\n  \"PyUnicodeUCS2_DecodeLatin1\"\n  \"PyUnicodeUCS2_DecodeASCII\"\n  \"PyUnicodeUCS2_AsEncodedString\"\n  \"PyUnicodeUCS2_AsUTF8String\"\n  \"PyUnicodeUCS2_AsLatin1String\"\n  \"PyUnicodeUCS2_AsASCIIString\"\n  \"PyUnicode_DecodeUTF7\"\n  \"PyUnicode_EncodeUTF7\"\n  \"PyUnicodeUCS2_DecodeUTF8Stateful\"\n  \"PyUnicodeUCS2_EncodeUTF8\"\n  \"PyUnicodeUCS2_DecodeUTF16Stateful\"\n  \"PyUnicodeUCS2_AsUTF16String\"\n  \"PyUnicodeUCS2_DecodeUnicodeEscape\"\n  \"PyUnicodeUCS2_DecodeRawUnicodeEscape\"\n  \"PyUnicodeUCS2_EncodeRawUnicodeEscape\"\n  \"_PyUnicode_DecodeUnicodeInternal\"\n  \"PyUnicodeUCS2_DecodeCharmap\"\n  \"PyUnicode_BuildEncodingMap\"\n  \"PyUnicodeUCS2_EncodeCharmap\"\n  \"PyUnicodeUCS2_TranslateCharmap\"\n  \"PyUnicodeUCS2_EncodeDecimal\"\n  \"PyUnicodeUCS2_Count\"\n  \"PyUnicodeUCS2_Find\"\n  \"PyUnicodeUCS2_Join\"\n  \"PyUnicodeUCS2_Splitlines\"\n  \"PyUnicodeUCS2_Compare\"\n  \"PyUnicodeUCS2_Contains\"\n  \"PyUnicodeUCS2_Concat\"\n  \"_PyUnicode_XStrip\"\n  \"PyUnicodeUCS2_Replace\"\n  \"PyUnicodeUCS2_Split\"\n  \"PyUnicodeUCS2_RSplit\"\n  \"PyUnicodeUCS2_Format\"\n  \"_PyUnicodeUCS2_Init\"\n  \"_PyUnicodeUCS2_Fini\"\n  \"PyUnicodeUCS2_FromUnicode\"\n  \"PyUnicodeUCS2_AsUnicode\"\n  \"PyUnicodeUCS2_GetSize\"\n  \"PyUnicodeUCS2_GetMax\"\n  \"_PyUnicodeUCS2_AsDefaultEncodedString\"\n  \"PyUnicodeUCS2_SetDefaultEncoding\"\n  \"PyUnicodeUCS2_Encode\"\n  \"PyUnicodeUCS2_AsEncodedObject\"\n  \"PyUnicodeUCS2_DecodeUTF16\"\n  \"PyUnicodeUCS2_EncodeUTF16\"\n  \"PyUnicodeUCS2_AsUnicodeEscapeString\"\n  \"PyUnicodeUCS2_EncodeUnicodeEscape\"\n  \"PyUnicodeUCS2_AsRawUnicodeEscapeString\"\n  \"PyUnicodeUCS2_EncodeLatin1\"\n  \"PyUnicodeUCS2_EncodeASCII\"\n  \"PyUnicodeUCS2_AsCharmapString\"\n  \"PyUnicodeUCS2_Partition\"\n  \"PyUnicodeUCS2_RPartition\"\n  \"PyUnicodeUCS2_Translate\"\n  \"PyUnicodeUCS2_Tailmatch\"\n  \"PyUnicode_AsDecodedObject\"\n  \"PyUnicode_Type\"\n\n; From python26_s.lib(unicodectype)\n  \"_PyUnicode_TypeRecords\"\n  \"_PyUnicodeUCS2_ToNumeric\"\n  \"_PyUnicodeUCS2_IsLowercase\"\n  \"_PyUnicodeUCS2_IsUppercase\"\n  \"_PyUnicodeUCS2_IsTitlecase\"\n  \"_PyUnicodeUCS2_IsWhitespace\"\n  \"_PyUnicodeUCS2_IsLinebreak\"\n  \"_PyUnicodeUCS2_ToLowercase\"\n  \"_PyUnicodeUCS2_ToUppercase\"\n  \"_PyUnicodeUCS2_ToTitlecase\"\n  \"_PyUnicodeUCS2_ToDecimalDigit\"\n  \"_PyUnicodeUCS2_ToDigit\"\n  \"_PyUnicodeUCS2_IsDecimalDigit\"\n  \"_PyUnicodeUCS2_IsDigit\"\n  \"_PyUnicodeUCS2_IsNumeric\"\n  \"_PyUnicodeUCS2_IsAlpha\"\n\n; From python26_s.lib(weakrefobject)\n  \"PyWeakref_NewRef\"\n  \"PyWeakref_NewProxy\"\n  \"PyObject_ClearWeakRefs\"\n  \"PyWeakref_GetObject\"\n  \"_PyWeakref_GetWeakrefCount\"\n  \"_PyWeakref_ClearRef\"\n  \"_PyWeakref_RefType\"\n  \"_PyWeakref_ProxyType\"\n  \"_PyWeakref_CallableProxyType\"\n\n; From python26_s.lib(Python-ast)\n;  \"init_ast\"\n  \"Module\"\n  \"Interactive\"\n  \"Expression\"\n  \"Suite\"\n  \"FunctionDef\"\n  \"ClassDef\"\n  \"Return\"\n  \"Delete\"\n  \"Assign\"\n  \"AugAssign\"\n  \"Print\"\n  \"For\"\n  \"While\"\n  \"If\"\n  \"With\"\n  \"Raise\"\n  \"TryExcept\"\n  \"TryFinally\"\n  \"Assert\"\n  \"Import\"\n  \"ImportFrom\"\n  \"Exec\"\n  \"Global\"\n  \"Expr\"\n  \"Pass\"\n  \"Break\"\n  \"Continue\"\n  \"BoolOp\"\n  \"BinOp\"\n  \"UnaryOp\"\n  \"Lambda\"\n  \"IfExp\"\n  \"Dict\"\n  \"ListComp\"\n  \"GeneratorExp\"\n  \"Yield\"\n  \"Compare\"\n  \"Call\"\n  \"Repr\"\n  \"Num\"\n  \"Str\"\n  \"Attribute\"\n  \"Subscript\"\n  \"Name\"\n  \"List\"\n  \"Tuple\"\n  \"Ellipsis\"\n  \"Slice\"\n  \"ExtSlice\"\n  \"Index\"\n  \"comprehension\"\n  \"excepthandler\"\n  \"arguments\"\n  \"keyword\"\n  \"alias\"\n  \"PyAST_mod2obj\"\n\n; From python26_s.lib(asdl)\n  \"asdl_seq_new\"\n  \"asdl_int_seq_new\"\n\n; From python26_s.lib(ast)\n  \"PyAST_FromNode\"\n\n; From python26_s.lib(bltinmodule)\n  \"_PyBuiltin_Init\"\n  \"Py_FileSystemDefaultEncoding\"\n\n; From python26_s.lib(exceptions)\n  \"PyUnicodeEncodeError_GetStart\"\n  \"PyUnicodeDecodeError_GetStart\"\n  \"PyUnicodeEncodeError_GetEnd\"\n  \"PyUnicodeDecodeError_GetEnd\"\n  \"_PyExc_Init\"\n  \"PyUnicodeDecodeError_Create\"\n  \"PyUnicodeEncodeError_Create\"\n  \"PyUnicodeTranslateError_Create\"\n  \"PyUnicodeEncodeError_GetEncoding\"\n  \"PyUnicodeDecodeError_GetEncoding\"\n  \"PyUnicodeEncodeError_GetObject\"\n  \"PyUnicodeDecodeError_GetObject\"\n  \"PyUnicodeTranslateError_GetObject\"\n  \"PyUnicodeTranslateError_GetStart\"\n  \"PyUnicodeEncodeError_SetStart\"\n  \"PyUnicodeDecodeError_SetStart\"\n  \"PyUnicodeTranslateError_SetStart\"\n  \"PyUnicodeTranslateError_GetEnd\"\n  \"PyUnicodeEncodeError_SetEnd\"\n  \"PyUnicodeDecodeError_SetEnd\"\n  \"PyUnicodeTranslateError_SetEnd\"\n  \"PyUnicodeEncodeError_GetReason\"\n  \"PyUnicodeDecodeError_GetReason\"\n  \"PyUnicodeTranslateError_GetReason\"\n  \"PyUnicodeEncodeError_SetReason\"\n  \"PyUnicodeDecodeError_SetReason\"\n  \"PyUnicodeTranslateError_SetReason\"\n  \"_PyExc_Fini\"\n  \"PyExc_BaseException\"\n  \"PyExc_Exception\"\n  \"PyExc_StandardError\"\n  \"PyExc_TypeError\"\n  \"PyExc_StopIteration\"\n  \"PyExc_GeneratorExit\"\n  \"PyExc_SystemExit\"\n  \"PyExc_KeyboardInterrupt\"\n  \"PyExc_ImportError\"\n  \"PyExc_EnvironmentError\"\n  \"PyExc_IOError\"\n  \"PyExc_OSError\"\n  \"PyExc_EOFError\"\n  \"PyExc_RuntimeError\"\n  \"PyExc_NotImplementedError\"\n  \"PyExc_NameError\"\n  \"PyExc_UnboundLocalError\"\n  \"PyExc_AttributeError\"\n  \"PyExc_IndexError\"\n  \"PyExc_SyntaxError\"\n  \"PyExc_IndentationError\"\n  \"PyExc_TabError\"\n  \"PyExc_LookupError\"\n  \"PyExc_KeyError\"\n  \"PyExc_ValueError\"\n  \"PyExc_UnicodeError\"\n  \"PyExc_UnicodeEncodeError\"\n  \"PyExc_UnicodeDecodeError\"\n  \"PyExc_UnicodeTranslateError\"\n  \"PyExc_AssertionError\"\n  \"PyExc_ArithmeticError\"\n  \"PyExc_FloatingPointError\"\n  \"PyExc_OverflowError\"\n  \"PyExc_ZeroDivisionError\"\n  \"PyExc_SystemError\"\n  \"PyExc_ReferenceError\"\n  \"PyExc_MemoryError\"\n  \"PyExc_Warning\"\n  \"PyExc_UserWarning\"\n  \"PyExc_DeprecationWarning\"\n  \"PyExc_PendingDeprecationWarning\"\n  \"PyExc_SyntaxWarning\"\n  \"PyExc_RuntimeWarning\"\n  \"PyExc_FutureWarning\"\n  \"PyExc_ImportWarning\"\n  \"PyExc_MemoryErrorInst\"\n\n; From python26_s.lib(ceval)\n  \"PyEval_EvalFrameEx\"\n  \"PyEval_CallObjectWithKeywords\"\n  \"PyEval_EvalCodeEx\"\n  \"PyEval_GetFrame\"\n  \"PyEval_CallObject\"\n  \"PyEval_SetProfile\"\n  \"PyEval_SetTrace\"\n  \"PyEval_GetBuiltins\"\n  \"PyEval_GetGlobals\"\n  \"PyEval_GetLocals\"\n  \"PyEval_GetRestricted\"\n  \"PyEval_MergeCompilerFlags\"\n  \"Py_FlushLine\"\n  \"Py_AddPendingCall\"\n  \"Py_MakePendingCalls\"\n  \"Py_SetRecursionLimit\"\n  \"Py_GetRecursionLimit\"\n  \"_Py_CheckRecursiveCall\"\n  \"PyEval_GetFuncName\"\n  \"PyEval_GetFuncDesc\"\n  \"PyEval_GetCallStats\"\n  \"PyEval_EvalFrame\"\n  \"PyEval_SaveThread\"\n  \"PyEval_RestoreThread\"\n  \"PyEval_ThreadsInitialized\"\n  \"PyEval_InitThreads\"\n  \"PyEval_AcquireLock\"\n  \"PyEval_ReleaseLock\"\n  \"PyEval_AcquireThread\"\n  \"PyEval_ReleaseThread\"\n  \"PyEval_ReInitThreads\"\n  \"_PyEval_SliceIndex\"\n  \"PyEval_EvalCode\"\n  \"_PyEval_CallTracing\"\n  \"_Py_CheckRecursionLimit\"\n  \"_Py_CheckInterval\"\n  \"_Py_Ticker\"\n\n; From python26_s.lib(compile)\n  \"_Py_Mangle\"\n  \"PyAST_Compile\"\n  \"PyNode_Compile\"\n  \"Py_OptimizeFlag\"\n\n; From python26_s.lib(codecs)\n  \"_PyCodec_Lookup\"\n  \"PyCodec_Encode\"\n  \"PyCodec_Decode\"\n  \"PyCodec_IgnoreErrors\"\n  \"PyCodec_ReplaceErrors\"\n  \"PyCodec_XMLCharRefReplaceErrors\"\n  \"PyCodec_BackslashReplaceErrors\"\n  \"PyCodec_Register\"\n  \"PyCodec_Encoder\"\n  \"PyCodec_Decoder\"\n  \"PyCodec_IncrementalEncoder\"\n  \"PyCodec_IncrementalDecoder\"\n  \"PyCodec_StreamReader\"\n  \"PyCodec_StreamWriter\"\n  \"PyCodec_RegisterError\"\n  \"PyCodec_LookupError\"\n  \"PyCodec_StrictErrors\"\n\n; From python26_s.lib(errors)\n  \"PyErr_SetNone\"\n  \"PyErr_SetString\"\n  \"PyErr_GivenExceptionMatches\"\n  \"PyErr_NormalizeException\"\n  \"PyErr_Fetch\"\n  \"PyErr_Clear\"\n  \"PyErr_NoMemory\"\n  \"PyErr_SetFromErrnoWithFilenameObject\"\n  \"PyErr_Format\"\n  \"PyErr_NewException\"\n  \"PyErr_WriteUnraisable\"\n  \"PyErr_SyntaxLocation\"\n  \"PyErr_ProgramText\"\n  \"PyErr_SetObject\"\n  \"PyErr_Occurred\"\n  \"PyErr_Restore\"\n  \"PyErr_ExceptionMatches\"\n  \"PyErr_BadArgument\"\n  \"PyErr_SetFromErrno\"\n  \"PyErr_SetFromErrnoWithFilename\"\n  \"PyErr_BadInternalCall\"\n  \"_PyErr_BadInternalCall\"\n  \"PyErr_Warn\"\n  \"PyErr_WarnExplicit\"\n\n; From python26_s.lib(frozen)\n  \"PyImport_FrozenModules\"\n\n; From python26_s.lib(frozenmain)\n  \"Py_FrozenMain\"\n\n; From python26_s.lib(future)\n  \"PyFuture_FromAST\"\n\n; From python26_s.lib(getargs)\n  \"PyArg_Parse\"\n  \"_PyArg_Parse_SizeT\"\n  \"PyArg_ParseTuple\"\n  \"_PyArg_ParseTuple_SizeT\"\n  \"PyArg_ParseTupleAndKeywords\"\n  \"_PyArg_ParseTupleAndKeywords_SizeT\"\n  \"PyArg_UnpackTuple\"\n  \"_PyArg_NoKeywords\"\n  \"PyArg_VaParse\"\n  \"PyArg_VaParseTupleAndKeywords\"\n  \"_PyArg_VaParse_SizeT\"\n  \"_PyArg_VaParseTupleAndKeywords_SizeT\"\n\n; From python26_s.lib(getcompiler)\n  \"Py_GetCompiler\"\n\n; From python26_s.lib(getcopyright)\n  \"Py_GetCopyright\"\n\n; From python26_s.lib(getplatform)\n  \"Py_GetPlatform\"\n\n; From python26_s.lib(getversion)\n  \"Py_GetVersion\"\n\n; From python26_s.lib(graminit)\n  \"_PyParser_Grammar\"\n\n; From python26_s.lib(import)\n  \"_PyImport_Init\"\n  \"_PyImportHooks_Init\"\n  \"PyImport_ImportModule\"\n  \"PyImport_Cleanup\"\n  \"_PyImport_FixupExtension\"\n  \"PyImport_AddModule\"\n  \"PyImport_ExecCodeModuleEx\"\n  \"PyImport_ImportFrozenModule\"\n  \"PyImport_ImportModuleEx\"\n  \"PyImport_ImportModuleLevel\"\n  \"PyImport_ReloadModule\"\n  \"PyImport_Import\"\n;  \"initimp\"\n  \"_PyImport_Fini\"\n  \"PyImport_GetMagicNumber\"\n  \"PyImport_ExecCodeModule\"\n  \"PyImport_GetModuleDict\"\n  \"_PyImport_FindModule\"\n  \"_PyImport_IsScript\"\n  \"_PyImport_ReInitLock\"\n  \"_PyImport_FindExtension\"\n  \"PyImport_AppendInittab\"\n  \"PyImport_ExtendInittab\"\n  \"PyImport_Inittab\"\n  \"_PyImport_Filetab\"\n\n; From python26_s.lib(importdl)\n  \"_PyImport_LoadDynamicModule\"\n\n; From python26_s.lib(marshal)\n  \"PyMarshal_ReadLongFromFile\"\n  \"PyMarshal_WriteObjectToString\"\n  \"PyMarshal_WriteLongToFile\"\n  \"PyMarshal_WriteObjectToFile\"\n  \"PyMarshal_ReadShortFromFile\"\n  \"PyMarshal_ReadObjectFromFile\"\n  \"PyMarshal_ReadLastObjectFromFile\"\n  \"PyMarshal_ReadObjectFromString\"\n  \"PyMarshal_Init\"\n\n; From python26_s.lib(modsupport)\n  \"Py_InitModule4\"\n  \"Py_BuildValue\"\n  \"_Py_BuildValue_SizeT\"\n  \"PyEval_CallFunction\"\n  \"PyEval_CallMethod\"\n  \"_Py_VaBuildValue_SizeT\"\n  \"Py_VaBuildValue\"\n  \"PyModule_AddObject\"\n  \"PyModule_AddIntConstant\"\n  \"PyModule_AddStringConstant\"\n  \"_Py_PackageContext\"\n\n; From python26_s.lib(mysnprintf)\n  \"PyOS_snprintf\"\n  \"PyOS_vsnprintf\"\n\n; From python26_s.lib(mystrtoul)\n  \"PyOS_strtoul\"\n  \"PyOS_strtol\"\n\n; From python26_s.lib(pyarena)\n  \"PyArena_New\"\n  \"PyArena_Free\"\n  \"PyArena_Malloc\"\n  \"PyArena_AddPyObject\"\n\n; From python26_s.lib(pyfpe)\n  \"PyFPE_dummy\"\n\n; From python26_s.lib(pystate)\n  \"PyInterpreterState_Clear\"\n  \"PyThreadState_Clear\"\n  \"_PyThread_CurrentFrames\"\n  \"PyGILState_Ensure\"\n  \"PyGILState_Release\"\n  \"PyInterpreterState_New\"\n  \"PyInterpreterState_Delete\"\n  \"PyThreadState_Delete\"\n  \"PyThreadState_New\"\n  \"PyThreadState_DeleteCurrent\"\n  \"PyThreadState_Get\"\n  \"PyThreadState_Swap\"\n  \"PyThreadState_GetDict\"\n  \"PyThreadState_SetAsyncExc\"\n  \"PyGILState_GetThisThreadState\"\n  \"PyInterpreterState_Head\"\n  \"PyInterpreterState_Next\"\n  \"PyInterpreterState_ThreadHead\"\n  \"PyThreadState_Next\"\n  \"_PyGILState_Init\"\n  \"_PyGILState_Fini\"\n  \"_PyThreadState_Current\"\n  \"_PyThreadState_GetFrame\"\n\n; From python26_s.lib(pystrtod)\n  \"PyOS_ascii_strtod\"\n  \"PyOS_ascii_formatd\"\n  \"PyOS_ascii_atof\"\n\n; From python26_s.lib(pythonrun)\n  \"Py_IgnoreEnvironmentFlag\"\n  \"Py_DebugFlag\"\n  \"Py_VerboseFlag\"\n  \"Py_NoSiteFlag\"\n  \"Py_InteractiveFlag\"\n  \"Py_FrozenFlag\"\n  \"Py_InitializeEx\"\n  \"Py_FatalError\"\n  \"Py_NewInterpreter\"\n  \"PyErr_Print\"\n  \"PyRun_InteractiveOneFlags\"\n  \"PyParser_ASTFromFile\"\n  \"PyRun_SimpleFileExFlags\"\n  \"PyRun_FileExFlags\"\n  \"Py_Exit\"\n  \"PyErr_PrintEx\"\n  \"PyErr_Display\"\n  \"Py_SetProgramName\"\n  \"Py_GetProgramName\"\n  \"Py_SetPythonHome\"\n  \"Py_GetPythonHome\"\n  \"Py_Initialize\"\n  \"Py_Finalize\"\n  \"Py_IsInitialized\"\n  \"Py_EndInterpreter\"\n  \"PyRun_AnyFileFlags\"\n  \"Py_FdIsInteractive\"\n  \"PyRun_InteractiveLoopFlags\"\n  \"PyRun_AnyFileExFlags\"\n  \"PyRun_SimpleStringFlags\"\n  \"PyRun_StringFlags\"\n  \"PyParser_ASTFromString\"\n  \"PyParser_SimpleParseStringFlags\"\n  \"PyParser_SimpleParseFileFlags\"\n  \"Py_CompileStringFlags\"\n  \"Py_SymtableString\"\n  \"Py_AtExit\"\n  \"PyOS_getsig\"\n  \"PyOS_setsig\"\n  \"PyParser_SetError\"\n  \"PyModule_GetWarningsModule\"\n  \"PyParser_SimpleParseStringFlagsFilename\"\n  \"PyParser_SimpleParseStringFilename\"\n  \"PyParser_SimpleParseFile\"\n  \"PyParser_SimpleParseString\"\n  \"PyRun_AnyFile\"\n  \"PyRun_AnyFileEx\"\n  \"PyRun_File\"\n  \"PyRun_FileEx\"\n  \"PyRun_FileFlags\"\n  \"PyRun_SimpleFile\"\n  \"PyRun_SimpleFileEx\"\n  \"PyRun_String\"\n  \"PyRun_SimpleString\"\n  \"Py_CompileString\"\n  \"PyRun_InteractiveOne\"\n  \"PyRun_InteractiveLoop\"\n  \"Py_UseClassExceptionsFlag\"\n  \"Py_UnicodeFlag\"\n  \"_Py_QnewFlag\"\n\n; From python26_s.lib(structmember)\n  \"PyMember_Get\"\n  \"PyMember_GetOne\"\n  \"PyMember_SetOne\"\n  \"PyMember_Set\"\n\n; From python26_s.lib(symtable)\n  \"PySymtable_Build\"\n  \"PySymtable_Free\"\n  \"PyST_GetScope\"\n  \"PySymtable_Lookup\"\n  \"PySTEntry_Type\"\n\n; From python26_s.lib(sysmodule)\n  \"_PySys_Init\"\n  \"PySys_WriteStderr\"\n  \"PySys_SetPath\"\n  \"PySys_SetArgv\"\n  \"PySys_WriteStdout\"\n  \"Py_SubversionRevision\"\n  \"Py_SubversionShortBranch\"\n  \"PySys_GetObject\"\n  \"PySys_SetObject\"\n  \"PySys_GetFile\"\n  \"PySys_ResetWarnOptions\"\n  \"PySys_AddWarnOption\"\n\n; From python26_s.lib(traceback)\n  \"PyTraceBack_Here\"\n  \"PyTraceBack_Print\"\n  \"PyTraceBack_Type\"\n\n; From python26_s.lib(getopt)\n  \"_PyOS_GetOpt\"\n  \"_PyOS_opterr\"\n  \"_PyOS_optind\"\n  \"_PyOS_optarg\"\n\n; From python26_s.lib(dynload_shlib)\n  \"_PyImport_DynLoadFiletab\"\n  \"_PyImport_GetDynLoadFunc\"\n\n; From python26_s.lib(thread)\n  \"PyThread_delete_key_value\"\n  \"PyThread_init_thread\"\n  \"PyThread_start_new_thread\"\n  \"PyThread_exit_thread\"\n  \"PyThread_get_thread_ident\"\n  \"PyThread_allocate_lock\"\n  \"PyThread_free_lock\"\n  \"PyThread_acquire_lock\"\n  \"PyThread_release_lock\"\n  \"PyThread_get_stacksize\"\n  \"PyThread_set_stacksize\"\n  \"PyThread_create_key\"\n  \"PyThread_delete_key\"\n  \"PyThread_set_key_value\"\n  \"PyThread_get_key_value\"\n  \"PyThread__exit_thread\"\n\n; From python26_s.lib(gcmodule)\n;  \"initgc\"\n  \"_PyObject_GC_New\"\n  \"_PyObject_GC_NewVar\"\n  \"PyGC_Collect\"\n  \"_PyObject_GC_Resize\"\n  \"_PyObject_GC_Malloc\"\n  \"PyObject_GC_Track\"\n  \"PyObject_GC_UnTrack\"\n  \"PyObject_GC_Del\"\n  \"_PyGC_Dump\"\n  \"_PyObject_GC_Track\"\n  \"_PyObject_GC_UnTrack\"\n  \"_PyObject_GC_Del\"\n  \"_PyGC_generation0\"\n\n; From python26_s.lib(signalmodule)\n;  \"initsignal\"\n  \"PyErr_CheckSignals\"\n  \"PyErr_SetInterrupt\"\n  \"PyOS_FiniInterrupts\"\n  \"PyOS_InterruptOccurred\"\n  \"PyOS_InitInterrupts\"\n  \"PyOS_AfterFork\"\n\n; From python26_s.lib(posixmodule)\n;  \"initos2\"\n\n; From python26_s.lib(_threadmodule)\n;  \"init_thread\"\n\n; From python26_s.lib(arraymodule)\n;  \"initarray\"\n;  \"array_methods\"\n\n; From python26_s.lib(binascii)\n;  \"initbinascii\"\n\n; From python26_s.lib(cmathmodule)\n;  \"initcmath\"\n\n; From python26_s.lib(_codecsmodule)\n;  \"init_codecs\"\n\n; From python26_s.lib(collectionsmodule)\n;  \"initcollections\"\n  \"dequeiter_type\"\n  \"dequereviter_type\"\n\n; From python26_s.lib(cPickle)\n;  \"initcPickle\"\n;  \"fast_save_leave\"\n\n; From python26_s.lib(_csv)\n;  \"init_csv\"\n\n; From python26_s.lib(datetimemodule)\n;  \"initdatetime\"\n\n; From python26_s.lib(dlmodule)\n;  \"initdl\"\n\n; From python26_s.lib(errnomodule)\n;  \"initerrno\"\n\n; From python26_s.lib(fcntlmodule)\n;  \"initfcntl\"\n\n; From python26_s.lib(_functoolsmodule)\n;  \"init_functools\"\n\n; From python26_s.lib(_heapqmodule)\n;  \"init_heapq\"\n\n; From python26_s.lib(imageop)\n;  \"initimageop\"\n\n; From python26_s.lib(itertoolsmodule)\n;  \"inititertools\"\n\n; From python26_s.lib(_localemodule)\n;  \"init_locale\"\n\n; From python26_s.lib(mathmodule)\n;  \"initmath\"\n\n; From python26_s.lib(md5)\n  \"md5_finish\"\n  \"md5_init\"\n  \"md5_append\"\n\n; From python26_s.lib(md5module)\n;  \"init_md5\"\n\n; From python26_s.lib(operator)\n;  \"initoperator\"\n\n; From python26_s.lib(_randommodule)\n;  \"init_random\"\n\n; From python26_s.lib(rgbimgmodule)\n;  \"initrgbimg\"\n\n; From python26_s.lib(shamodule)\n;  \"init_sha\"\n\n; From python26_s.lib(sha256module)\n;  \"init_sha256\"\n\n; From python26_s.lib(sha512module)\n;  \"init_sha512\"\n\n; From python26_s.lib(_sre)\n;  \"init_sre\"\n\n; From python26_s.lib(stropmodule)\n;  \"initstrop\"\n\n; From python26_s.lib(_struct)\n;  \"init_struct\"\n\n; From python26_s.lib(symtablemodule)\n;  \"init_symtable\"\n\n; From python26_s.lib(termios)\n;  \"inittermios\"\n\n; From python26_s.lib(timemodule)\n;  \"inittime\"\n  \"_PyTime_DoubleToTimet\"\n;  \"inittimezone\"\n\n; From python26_s.lib(timingmodule)\n;  \"inittiming\"\n\n; From python26_s.lib(_weakref)\n;  \"init_weakref\"\n\n; From python26_s.lib(xxsubtype)\n;  \"initxxsubtype\"\n\n; From python26_s.lib(zipimport)\n;  \"initzipimport\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/os2emx/dlfcn.c": "/* -*- C -*- ***********************************************\nCopyright 1991-1995 by Stichting Mathematisch Centrum, Amsterdam,\nThe Netherlands.\n\n                        All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the names of Stichting Mathematisch\nCentrum or CWI or Corporation for National Research Initiatives or\nCNRI not be used in advertising or publicity pertaining to\ndistribution of the software without specific, written prior\npermission.\n\nWhile CWI is the initial source for this software, a modified version\nis made available by the Corporation for National Research Initiatives\n(CNRI) at the Internet address ftp://ftp.python.org.\n\nSTICHTING MATHEMATISCH CENTRUM AND CNRI DISCLAIM ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH\nCENTRUM OR CNRI BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL\nDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\nPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n\n******************************************************************/\n\n/* This library implements dlopen() - Unix-like dynamic linking\n * emulation functions for OS/2 using DosLoadModule() and company.\n */\n\n#define INCL_DOS\n#define INCL_DOSERRORS\n#define INCL_DOSSESMGR\n#define INCL_WINPROGRAMLIST\n#define INCL_WINFRAMEMGR\n#include <os2.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <malloc.h>\n\ntypedef struct _track_rec {\n    char *name;\n    HMODULE handle;\n    void *id;\n    struct _track_rec *next;\n} tDLLchain, *DLLchain;\n\nstatic DLLchain dlload = NULL;  /* A simple chained list of DLL names */\nstatic char dlerr [256];        /* last error text string */\nstatic void *last_id;\n\nstatic DLLchain find_id(void *id)\n{\n    DLLchain tmp;\n\n    for (tmp = dlload; tmp; tmp = tmp->next)\n        if (id == tmp->id)\n            return tmp;\n\n    return NULL;\n}\n\n/* load a dynamic-link library and return handle */\nvoid *dlopen(char *filename, int flags)\n{\n    HMODULE hm;\n    DLLchain tmp;\n    char err[256];\n    char *errtxt;\n    int rc = 0, set_chain = 0;\n\n    for (tmp = dlload; tmp; tmp = tmp->next)\n        if (strnicmp(tmp->name, filename, 999) == 0)\n            break;\n\n    if (!tmp)\n    {\n        tmp = (DLLchain) malloc(sizeof(tDLLchain));\n        if (!tmp)\n            goto nomem;\n        tmp->name = strdup(filename);\n        tmp->next = dlload;\n        set_chain = 1;\n    }\n\n    switch (rc = DosLoadModule((PSZ)&err, sizeof(err), filename, &hm))\n    {\n        case NO_ERROR:\n            tmp->handle = hm;\n            if (set_chain)\n            {\n                do\n                    last_id++;\n                while ((last_id == 0) || (find_id(last_id)));\n                tmp->id = last_id;\n                dlload = tmp;\n            }\n            return tmp->id;\n        case ERROR_FILE_NOT_FOUND:\n        case ERROR_PATH_NOT_FOUND:\n            errtxt = \"module `%s' not found\";\n            break;\n        case ERROR_TOO_MANY_OPEN_FILES:\n        case ERROR_NOT_ENOUGH_MEMORY:\n        case ERROR_SHARING_BUFFER_EXCEEDED:\nnomem:\n            errtxt = \"out of system resources\";\n            break;\n        case ERROR_ACCESS_DENIED:\n            errtxt = \"access denied\";\n            break;\n        case ERROR_BAD_FORMAT:\n        case ERROR_INVALID_SEGMENT_NUMBER:\n        case ERROR_INVALID_ORDINAL:\n        case ERROR_INVALID_MODULETYPE:\n        case ERROR_INVALID_EXE_SIGNATURE:\n        case ERROR_EXE_MARKED_INVALID:\n        case ERROR_ITERATED_DATA_EXCEEDS_64K:\n        case ERROR_INVALID_MINALLOCSIZE:\n        case ERROR_INVALID_SEGDPL:\n        case ERROR_AUTODATASEG_EXCEEDS_64K:\n        case ERROR_RELOCSRC_CHAIN_EXCEEDS_SEGLIMIT:\n            errtxt = \"invalid module format\";\n            break;\n        case ERROR_INVALID_NAME:\n            errtxt = \"filename doesn't match module name\";\n            break;\n        case ERROR_SHARING_VIOLATION:\n        case ERROR_LOCK_VIOLATION:\n            errtxt = \"sharing violation\";\n            break;\n        case ERROR_INIT_ROUTINE_FAILED:\n            errtxt = \"module initialization failed\";\n            break;\n        default:\n            errtxt = \"cause `%s', error code = %d\";\n            break;\n    }\n    snprintf(dlerr, sizeof(dlerr), errtxt, &err, rc);\n    if (tmp)\n    {\n        if (tmp->name)\n            free(tmp->name);\n        free(tmp);\n    }\n    return 0;\n}\n\n/* return a pointer to the `symbol' in DLL */\nvoid *dlsym(void *handle, char *symbol)\n{\n    int rc = 0;\n    PFN addr;\n    char *errtxt;\n    int symord = 0;\n    DLLchain tmp = find_id(handle);\n\n    if (!tmp)\n        goto inv_handle;\n\n    if (*symbol == '#')\n        symord = atoi(symbol + 1);\n\n    switch (rc = DosQueryProcAddr(tmp->handle, symord, symbol, &addr))\n    {\n        case NO_ERROR:\n            return (void *)addr;\n        case ERROR_INVALID_HANDLE:\ninv_handle:\n            errtxt = \"invalid module handle\";\n            break;\n        case ERROR_PROC_NOT_FOUND:\n        case ERROR_INVALID_NAME:\n            errtxt = \"no symbol `%s' in module\";\n            break;\n        default:\n            errtxt = \"symbol `%s', error code = %d\";\n            break;\n    }\n    snprintf(dlerr, sizeof(dlerr), errtxt, symbol, rc);\n    return NULL;\n}\n\n/* free dynamically-linked library */\nint dlclose(void *handle)\n{\n    int rc;\n    DLLchain tmp = find_id(handle);\n\n    if (!tmp)\n        goto inv_handle;\n\n    switch (rc = DosFreeModule(tmp->handle))\n    {\n        case NO_ERROR:\n            free(tmp->name);\n            dlload = tmp->next;\n            free(tmp);\n            return 0;\n        case ERROR_INVALID_HANDLE:\ninv_handle:\n            strcpy(dlerr, \"invalid module handle\");\n            return -1;\n        case ERROR_INVALID_ACCESS:\n            strcpy(dlerr, \"access denied\");\n            return -1;\n        default:\n            return -1;\n    }\n}\n\n/* return a string describing last occurred dl error */\nchar *dlerror()\n{\n    return dlerr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Python/dynload_shlib.c": "\n/* Support for dynamic loading of extension modules */\n\n#include \"Python.h\"\n#include \"importdl.h\"\n\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#if defined(__NetBSD__)\n#include <sys/param.h>\n#if (NetBSD < 199712)\n#include <nlist.h>\n#include <link.h>\n#define dlerror() \"error in dynamic linking\"\n#endif\n#endif /* NetBSD */\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#else\n#if defined(PYOS_OS2) && defined(PYCC_GCC)\n#include \"dlfcn.h\"\n#endif\n#endif\n\n#if (defined(__OpenBSD__) || defined(__NetBSD__)) && !defined(__ELF__)\n#define LEAD_UNDERSCORE \"_\"\n#else\n#define LEAD_UNDERSCORE \"\"\n#endif\n\n\nconst struct filedescr _PyImport_DynLoadFiletab[] = {\n#ifdef __CYGWIN__\n    {\".dll\", \"rb\", C_EXTENSION},\n    {\"module.dll\", \"rb\", C_EXTENSION},\n#else\n#if defined(PYOS_OS2) && defined(PYCC_GCC)\n    {\".pyd\", \"rb\", C_EXTENSION},\n    {\".dll\", \"rb\", C_EXTENSION},\n#else\n#ifdef __VMS\n    {\".exe\", \"rb\", C_EXTENSION},\n    {\".EXE\", \"rb\", C_EXTENSION},\n    {\"module.exe\", \"rb\", C_EXTENSION},\n    {\"MODULE.EXE\", \"rb\", C_EXTENSION},\n#else\n    {\".so\", \"rb\", C_EXTENSION},\n    {\"module.so\", \"rb\", C_EXTENSION},\n#endif\n#endif\n#endif\n    {0, 0}\n};\n\nstatic struct {\n    dev_t dev;\n#ifdef __VMS\n    ino_t ino[3];\n#else\n    ino_t ino;\n#endif\n    void *handle;\n} handles[128];\nstatic int nhandles = 0;\n\n\ndl_funcptr _PyImport_GetDynLoadFunc(const char *fqname, const char *shortname,\n                                    const char *pathname, FILE *fp)\n{\n    dl_funcptr p;\n    void *handle;\n    char funcname[258];\n    char pathbuf[260];\n    int dlopenflags=0;\n\n    if (strchr(pathname, '/') == NULL) {\n        /* Prefix bare filename with \"./\" */\n        PyOS_snprintf(pathbuf, sizeof(pathbuf), \"./%-.255s\", pathname);\n        pathname = pathbuf;\n    }\n\n    PyOS_snprintf(funcname, sizeof(funcname),\n                  LEAD_UNDERSCORE \"PyInit_%.200s\", shortname);\n\n    if (fp != NULL) {\n        int i;\n        struct stat statb;\n        fstat(fileno(fp), &statb);\n        for (i = 0; i < nhandles; i++) {\n            if (statb.st_dev == handles[i].dev &&\n                statb.st_ino == handles[i].ino) {\n                p = (dl_funcptr) dlsym(handles[i].handle,\n                                       funcname);\n                return p;\n            }\n        }\n        if (nhandles < 128) {\n            handles[nhandles].dev = statb.st_dev;\n#ifdef __VMS\n            handles[nhandles].ino[0] = statb.st_ino[0];\n            handles[nhandles].ino[1] = statb.st_ino[1];\n            handles[nhandles].ino[2] = statb.st_ino[2];\n#else\n            handles[nhandles].ino = statb.st_ino;\n#endif\n        }\n    }\n\n#if !(defined(PYOS_OS2) && defined(PYCC_GCC))\n    dlopenflags = PyThreadState_GET()->interp->dlopenflags;\n#endif\n\n    if (Py_VerboseFlag)\n        PySys_WriteStderr(\"dlopen(\\\"%s\\\", %x);\\n\", pathname,\n                          dlopenflags);\n\n#ifdef __VMS\n    /* VMS currently don't allow a pathname, use a logical name instead */\n    /* Concatenate 'python_module_' and shortname */\n    /* so \"import vms.bar\" will use the logical python_module_bar */\n    /* As C module use only one name space this is probably not a */\n    /* important limitation */\n    PyOS_snprintf(pathbuf, sizeof(pathbuf), \"python_module_%-.200s\",\n                  shortname);\n    pathname = pathbuf;\n#endif\n\n    handle = dlopen(pathname, dlopenflags);\n\n    if (handle == NULL) {\n        const char *error = dlerror();\n        if (error == NULL)\n            error = \"unknown dlopen() error\";\n        PyErr_SetString(PyExc_ImportError, error);\n        return NULL;\n    }\n    if (fp != NULL && nhandles < 128)\n        handles[nhandles++].handle = handle;\n    p = (dl_funcptr) dlsym(handle, funcname);\n    return p;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_ctypes/ctypes_dlfcn.h": "/*****************************************************************\n  This file should be kept compatible with Python 2.3, see PEP 291.\n *****************************************************************/\n\n#ifndef _CTYPES_DLFCN_H_\n#define _CTYPES_DLFCN_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n\n#ifndef MS_WIN32\n\n#include <dlfcn.h>\n\n#ifndef CTYPES_DARWIN_DLFCN\n\n#define ctypes_dlsym dlsym\n#define ctypes_dlerror dlerror\n#define ctypes_dlopen dlopen\n#define ctypes_dlclose dlclose\n#define ctypes_dladdr dladdr\n\n#endif /* !CTYPES_DARWIN_DLFCN */\n\n#endif /* !MS_WIN32 */\n\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n#endif /* _CTYPES_DLFCN_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_ctypes/_ctypes.c": "/*\n  ToDo:\n\n  Get rid of the checker (and also the converters) field in PyCFuncPtrObject and\n  StgDictObject, and replace them by slot functions in StgDictObject.\n\n  think about a buffer-like object (memory? bytes?)\n\n  Should POINTER(c_char) and POINTER(c_wchar) have a .value property?\n  What about c_char and c_wchar arrays then?\n\n  Add from_mmap, from_file, from_string metaclass methods.\n\n  Maybe we can get away with from_file (calls read) and with a from_buffer\n  method?\n\n  And what about the to_mmap, to_file, to_str(?) methods?  They would clobber\n  the namespace, probably. So, functions instead? And we already have memmove...\n*/\n\n/*\n\nName                    methods, members, getsets\n==============================================================================\n\nPyCStructType_Type              __new__(), from_address(), __mul__(), from_param()\nUnionType_Type          __new__(), from_address(), __mul__(), from_param()\nPyCPointerType_Type     __new__(), from_address(), __mul__(), from_param(), set_type()\nPyCArrayType_Type               __new__(), from_address(), __mul__(), from_param()\nPyCSimpleType_Type              __new__(), from_address(), __mul__(), from_param()\n\nPyCData_Type\n  Struct_Type           __new__(), __init__()\n  PyCPointer_Type               __new__(), __init__(), _as_parameter_, contents\n  PyCArray_Type         __new__(), __init__(), _as_parameter_, __get/setitem__(), __len__()\n  Simple_Type           __new__(), __init__(), _as_parameter_\n\nPyCField_Type\nPyCStgDict_Type\n\n==============================================================================\n\nclass methods\n-------------\n\nIt has some similarity to the byref() construct compared to pointer()\nfrom_address(addr)\n    - construct an instance from a given memory block (sharing this memory block)\n\nfrom_param(obj)\n    - typecheck and convert a Python object into a C function call parameter\n      the result may be an instance of the type, or an integer or tuple\n      (typecode, value[, obj])\n\ninstance methods/properties\n---------------------------\n\n_as_parameter_\n    - convert self into a C function call parameter\n      This is either an integer, or a 3-tuple (typecode, value, obj)\n\nfunctions\n---------\n\nsizeof(cdata)\n    - return the number of bytes the buffer contains\n\nsizeof(ctype)\n    - return the number of bytes the buffer of an instance would contain\n\nbyref(cdata)\n\naddressof(cdata)\n\npointer(cdata)\n\nPOINTER(ctype)\n\nbytes(cdata)\n    - return the buffer contents as a sequence of bytes (which is currently a string)\n\n*/\n\n/*\n * PyCStgDict_Type\n * PyCStructType_Type\n * UnionType_Type\n * PyCPointerType_Type\n * PyCArrayType_Type\n * PyCSimpleType_Type\n *\n * PyCData_Type\n * Struct_Type\n * Union_Type\n * PyCArray_Type\n * Simple_Type\n * PyCPointer_Type\n * PyCField_Type\n *\n */\n\n#define PY_SSIZE_T_CLEAN\n\n#include \"Python.h\"\n#include \"structmember.h\"\n\n#include <ffi.h>\n#ifdef MS_WIN32\n#include <windows.h>\n#include <malloc.h>\n#ifndef IS_INTRESOURCE\n#define IS_INTRESOURCE(x) (((size_t)(x) >> 16) == 0)\n#endif\n# ifdef _WIN32_WCE\n/* Unlike desktop Windows, WinCE has both W and A variants of\n   GetProcAddress, but the default W version is not what we want */\n#  undef GetProcAddress\n#  define GetProcAddress GetProcAddressA\n# endif\n#else\n#include \"ctypes_dlfcn.h\"\n#endif\n#include \"ctypes.h\"\n\nPyObject *PyExc_ArgError;\n\n/* This dict maps ctypes types to POINTER types */\nPyObject *_ctypes_ptrtype_cache;\n\nstatic PyTypeObject Simple_Type;\n\n/* a callable object used for unpickling */\nstatic PyObject *_unpickle;\n\nchar *_ctypes_conversion_encoding = NULL;\nchar *_ctypes_conversion_errors = NULL;\n\n\n/****************************************************************/\n\ntypedef struct {\n    PyObject_HEAD\n    PyObject *key;\n    PyObject *dict;\n} DictRemoverObject;\n\nstatic void\n_DictRemover_dealloc(PyObject *_self)\n{\n    DictRemoverObject *self = (DictRemoverObject *)_self;\n    Py_XDECREF(self->key);\n    Py_XDECREF(self->dict);\n    Py_TYPE(self)->tp_free(_self);\n}\n\nstatic PyObject *\n_DictRemover_call(PyObject *_self, PyObject *args, PyObject *kw)\n{\n    DictRemoverObject *self = (DictRemoverObject *)_self;\n    if (self->key && self->dict) {\n        if (-1 == PyDict_DelItem(self->dict, self->key))\n            /* XXX Error context */\n            PyErr_WriteUnraisable(Py_None);\n        Py_DECREF(self->key);\n        self->key = NULL;\n        Py_DECREF(self->dict);\n        self->dict = NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyTypeObject DictRemover_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.DictRemover\",                      /* tp_name */\n    sizeof(DictRemoverObject),                  /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    _DictRemover_dealloc,                       /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    _DictRemover_call,                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n/* XXX should participate in GC? */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    \"deletes a key from a dictionary\",          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    0,                                          /* tp_free */\n};\n\nint\nPyDict_SetItemProxy(PyObject *dict, PyObject *key, PyObject *item)\n{\n    PyObject *obj;\n    DictRemoverObject *remover;\n    PyObject *proxy;\n    int result;\n\n    obj = PyObject_CallObject((PyObject *)&DictRemover_Type, NULL);\n    if (obj == NULL)\n        return -1;\n\n    remover = (DictRemoverObject *)obj;\n    assert(remover->key == NULL);\n    assert(remover->dict == NULL);\n    Py_INCREF(key);\n    remover->key = key;\n    Py_INCREF(dict);\n    remover->dict = dict;\n\n    proxy = PyWeakref_NewProxy(item, obj);\n    Py_DECREF(obj);\n    if (proxy == NULL)\n        return -1;\n\n    result = PyDict_SetItem(dict, key, proxy);\n    Py_DECREF(proxy);\n    return result;\n}\n\nPyObject *\nPyDict_GetItemProxy(PyObject *dict, PyObject *key)\n{\n    PyObject *result;\n    PyObject *item = PyDict_GetItem(dict, key);\n\n    if (item == NULL)\n        return NULL;\n    if (!PyWeakref_CheckProxy(item))\n        return item;\n    result = PyWeakref_GET_OBJECT(item);\n    if (result == Py_None)\n        return NULL;\n    return result;\n}\n\n/******************************************************************/\n/*\n  Allocate a memory block for a pep3118 format string, copy prefix (if\n  non-null) and suffix into it.  Returns NULL on failure, with the error\n  indicator set.  If called with a suffix of NULL the error indicator must\n  already be set.\n */\nchar *\n_ctypes_alloc_format_string(const char *prefix, const char *suffix)\n{\n    size_t len;\n    char *result;\n\n    if (suffix == NULL) {\n        assert(PyErr_Occurred());\n        return NULL;\n    }\n    len = strlen(suffix);\n    if (prefix)\n        len += strlen(prefix);\n    result = PyMem_Malloc(len + 1);\n    if (result == NULL)\n        return NULL;\n    if (prefix)\n        strcpy(result, prefix);\n    else\n        result[0] = '\\0';\n    strcat(result, suffix);\n    return result;\n}\n\n/*\n  PyCStructType_Type - a meta type/class.  Creating a new class using this one as\n  __metaclass__ will call the contructor StructUnionType_new.  It replaces the\n  tp_dict member with a new instance of StgDict, and initializes the C\n  accessible fields somehow.\n*/\n\nstatic PyCArgObject *\nStructUnionType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n    StgDictObject *stgdict;\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'V';\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for structure/union instances */\n    parg->pffi_type = &stgdict->ffi_type_pointer;\n    /* For structure parameters (by value), parg->value doesn't contain the structure\n       data itself, instead parg->value.p *points* to the structure's data\n       See also _ctypes.c, function _call_function_pointer().\n    */\n    parg->value.p = self->b_ptr;\n    parg->size = self->b_size;\n    Py_INCREF(self);\n    parg->obj = (PyObject *)self;\n    return parg;\n}\n\nstatic PyObject *\nStructUnionType_new(PyTypeObject *type, PyObject *args, PyObject *kwds, int isStruct)\n{\n    PyTypeObject *result;\n    PyObject *fields;\n    StgDictObject *dict;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (!result)\n        return NULL;\n\n    /* keep this for bw compatibility */\n    if (PyDict_GetItemString(result->tp_dict, \"_abstract_\"))\n        return (PyObject *)result;\n\n    dict = (StgDictObject *)PyObject_CallObject((PyObject *)&PyCStgDict_Type, NULL);\n    if (!dict) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    /* replace the class dict by our updated stgdict, which holds info\n       about storage requirements of the instances */\n    if (-1 == PyDict_Update((PyObject *)dict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)dict);\n        return NULL;\n    }\n    Py_DECREF(result->tp_dict);\n    result->tp_dict = (PyObject *)dict;\n    dict->format = _ctypes_alloc_format_string(NULL, \"B\");\n    if (dict->format == NULL) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    dict->paramfunc = StructUnionType_paramfunc;\n\n    fields = PyDict_GetItemString((PyObject *)dict, \"_fields_\");\n    if (!fields) {\n        StgDictObject *basedict = PyType_stgdict((PyObject *)result->tp_base);\n\n        if (basedict == NULL)\n            return (PyObject *)result;\n        /* copy base dict */\n        if (-1 == PyCStgDict_clone(dict, basedict)) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        dict->flags &= ~DICTFLAG_FINAL; /* clear the 'final' flag in the subclass dict */\n        basedict->flags |= DICTFLAG_FINAL; /* set the 'final' flag in the baseclass dict */\n        return (PyObject *)result;\n    }\n\n    if (-1 == PyObject_SetAttrString((PyObject *)result, \"_fields_\", fields)) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    return (PyObject *)result;\n}\n\nstatic PyObject *\nPyCStructType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    return StructUnionType_new(type, args, kwds, 1);\n}\n\nstatic PyObject *\nUnionType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    return StructUnionType_new(type, args, kwds, 0);\n}\n\nstatic char from_address_doc[] =\n\"C.from_address(integer) -> C instance\\naccess a C instance at the specified address\";\n\nstatic PyObject *\nCDataType_from_address(PyObject *type, PyObject *value)\n{\n    void *buf;\n    if (!PyLong_Check(value)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"integer expected\");\n        return NULL;\n    }\n    buf = (void *)PyLong_AsVoidPtr(value);\n    if (PyErr_Occurred())\n        return NULL;\n    return PyCData_AtAddress(type, buf);\n}\n\nstatic char from_buffer_doc[] =\n\"C.from_buffer(object, offset=0) -> C instance\\ncreate a C instance from a writeable buffer\";\n\nstatic int\nKeepRef(CDataObject *target, Py_ssize_t index, PyObject *keep);\n\nstatic PyObject *\nCDataType_from_buffer(PyObject *type, PyObject *args)\n{\n    void *buffer;\n    Py_ssize_t buffer_len;\n    Py_ssize_t offset = 0;\n    PyObject *obj, *result;\n    StgDictObject *dict = PyType_stgdict(type);\n    assert (dict);\n\n    if (!PyArg_ParseTuple(args,\n#if (PY_VERSION_HEX < 0x02050000)\n                          \"O|i:from_buffer\",\n#else\n                          \"O|n:from_buffer\",\n#endif\n                          &obj, &offset))\n        return NULL;\n\n    if (-1 == PyObject_AsWriteBuffer(obj, &buffer, &buffer_len))\n        return NULL;\n\n    if (offset < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"offset cannot be negative\");\n        return NULL;\n    }\n    if (dict->size > buffer_len - offset) {\n        PyErr_Format(PyExc_ValueError,\n#if (PY_VERSION_HEX < 0x02050000)\n                     \"Buffer size too small (%d instead of at least %d bytes)\",\n#else\n                     \"Buffer size too small (%zd instead of at least %zd bytes)\",\n#endif\n                     buffer_len, dict->size + offset);\n        return NULL;\n    }\n\n    result = PyCData_AtAddress(type, (char *)buffer + offset);\n    if (result == NULL)\n        return NULL;\n\n    Py_INCREF(obj);\n    if (-1 == KeepRef((CDataObject *)result, -1, obj)) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    return result;\n}\n\nstatic char from_buffer_copy_doc[] =\n\"C.from_buffer_copy(object, offset=0) -> C instance\\ncreate a C instance from a readable buffer\";\n\nstatic PyObject *\nGenericPyCData_new(PyTypeObject *type, PyObject *args, PyObject *kwds);\n\nstatic PyObject *\nCDataType_from_buffer_copy(PyObject *type, PyObject *args)\n{\n    const void *buffer;\n    Py_ssize_t buffer_len;\n    Py_ssize_t offset = 0;\n    PyObject *obj, *result;\n    StgDictObject *dict = PyType_stgdict(type);\n    assert (dict);\n\n    if (!PyArg_ParseTuple(args,\n#if (PY_VERSION_HEX < 0x02050000)\n                          \"O|i:from_buffer\",\n#else\n                          \"O|n:from_buffer\",\n#endif\n                          &obj, &offset))\n        return NULL;\n\n    if (-1 == PyObject_AsReadBuffer(obj, (const void**)&buffer, &buffer_len))\n        return NULL;\n\n    if (offset < 0) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"offset cannot be negative\");\n        return NULL;\n    }\n\n    if (dict->size > buffer_len - offset) {\n        PyErr_Format(PyExc_ValueError,\n#if (PY_VERSION_HEX < 0x02050000)\n                     \"Buffer size too small (%d instead of at least %d bytes)\",\n#else\n                     \"Buffer size too small (%zd instead of at least %zd bytes)\",\n#endif\n                     buffer_len, dict->size + offset);\n        return NULL;\n    }\n\n    result = GenericPyCData_new((PyTypeObject *)type, NULL, NULL);\n    if (result == NULL)\n        return NULL;\n    memcpy(((CDataObject *)result)->b_ptr,\n           (char *)buffer+offset, dict->size);\n    return result;\n}\n\nstatic char in_dll_doc[] =\n\"C.in_dll(dll, name) -> C instance\\naccess a C instance in a dll\";\n\nstatic PyObject *\nCDataType_in_dll(PyObject *type, PyObject *args)\n{\n    PyObject *dll;\n    char *name;\n    PyObject *obj;\n    void *handle;\n    void *address;\n\n    if (!PyArg_ParseTuple(args, \"Os:in_dll\", &dll, &name))\n        return NULL;\n\n    obj = PyObject_GetAttrString(dll, \"_handle\");\n    if (!obj)\n        return NULL;\n    if (!PyLong_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the _handle attribute of the second argument must be an integer\");\n        Py_DECREF(obj);\n        return NULL;\n    }\n    handle = (void *)PyLong_AsVoidPtr(obj);\n    Py_DECREF(obj);\n    if (PyErr_Occurred()) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"could not convert the _handle attribute to a pointer\");\n        return NULL;\n    }\n\n#ifdef MS_WIN32\n    address = (void *)GetProcAddress(handle, name);\n    if (!address) {\n        PyErr_Format(PyExc_ValueError,\n                     \"symbol '%s' not found\",\n                     name);\n        return NULL;\n    }\n#else\n    address = (void *)ctypes_dlsym(handle, name);\n    if (!address) {\n#ifdef __CYGWIN__\n/* dlerror() isn't very helpful on cygwin */\n        PyErr_Format(PyExc_ValueError,\n                     \"symbol '%s' not found (%s) \",\n                     name);\n#else\n        PyErr_SetString(PyExc_ValueError, ctypes_dlerror());\n#endif\n        return NULL;\n    }\n#endif\n    return PyCData_AtAddress(type, address);\n}\n\nstatic char from_param_doc[] =\n\"Convert a Python object into a function call parameter.\";\n\nstatic PyObject *\nCDataType_from_param(PyObject *type, PyObject *value)\n{\n    PyObject *as_parameter;\n    int res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n    if (PyCArg_CheckExact(value)) {\n        PyCArgObject *p = (PyCArgObject *)value;\n        PyObject *ob = p->obj;\n        const char *ob_name;\n        StgDictObject *dict;\n        dict = PyType_stgdict(type);\n\n        /* If we got a PyCArgObject, we must check if the object packed in it\n           is an instance of the type's dict->proto */\n        if(dict && ob) {\n            res = PyObject_IsInstance(ob, dict->proto);\n            if (res == -1)\n                return NULL;\n            if (res) {\n                Py_INCREF(value);\n                return value;\n            }\n        }\n        ob_name = (ob) ? Py_TYPE(ob)->tp_name : \"???\";\n        PyErr_Format(PyExc_TypeError,\n                     \"expected %s instance instead of pointer to %s\",\n                     ((PyTypeObject *)type)->tp_name, ob_name);\n        return NULL;\n    }\n\n    as_parameter = PyObject_GetAttrString(value, \"_as_parameter_\");\n    if (as_parameter) {\n        value = CDataType_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"expected %s instance instead of %s\",\n                 ((PyTypeObject *)type)->tp_name,\n                 Py_TYPE(value)->tp_name);\n    return NULL;\n}\n\nstatic PyMethodDef CDataType_methods[] = {\n    { \"from_param\", CDataType_from_param, METH_O, from_param_doc },\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc },\n    { NULL, NULL },\n};\n\nstatic PyObject *\nCDataType_repeat(PyObject *self, Py_ssize_t length)\n{\n    if (length < 0)\n        return PyErr_Format(PyExc_ValueError,\n                            \"Array length must be >= 0, not %zd\",\n                            length);\n    return PyCArrayType_from_ctype(self, length);\n}\n\nstatic PySequenceMethods CDataType_as_sequence = {\n    0,                          /* inquiry sq_length; */\n    0,                          /* binaryfunc sq_concat; */\n    CDataType_repeat,           /* intargfunc sq_repeat; */\n    0,                          /* intargfunc sq_item; */\n    0,                          /* intintargfunc sq_slice; */\n    0,                          /* intobjargproc sq_ass_item; */\n    0,                          /* intintobjargproc sq_ass_slice; */\n    0,                          /* objobjproc sq_contains; */\n\n    0,                          /* binaryfunc sq_inplace_concat; */\n    0,                          /* intargfunc sq_inplace_repeat; */\n};\n\nstatic int\nCDataType_clear(PyTypeObject *self)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)self);\n    if (dict)\n        Py_CLEAR(dict->proto);\n    return PyType_Type.tp_clear((PyObject *)self);\n}\n\nstatic int\nCDataType_traverse(PyTypeObject *self, visitproc visit, void *arg)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)self);\n    if (dict)\n        Py_VISIT(dict->proto);\n    return PyType_Type.tp_traverse((PyObject *)self, visit, arg);\n}\n\nstatic int\nPyCStructType_setattro(PyObject *self, PyObject *key, PyObject *value)\n{\n    /* XXX Should we disallow deleting _fields_? */\n    if (-1 == PyType_Type.tp_setattro(self, key, value))\n        return -1;\n\n    if (value && PyUnicode_Check(key) &&\n        /* XXX struni _PyUnicode_AsString can fail (also in other places)! */\n        0 == strcmp(_PyUnicode_AsString(key), \"_fields_\"))\n        return PyCStructUnionType_update_stgdict(self, value, 1);\n    return 0;\n}\n\n\nstatic int\nUnionType_setattro(PyObject *self, PyObject *key, PyObject *value)\n{\n    /* XXX Should we disallow deleting _fields_? */\n    if (-1 == PyObject_GenericSetAttr(self, key, value))\n        return -1;\n\n    if (PyUnicode_Check(key) &&\n        0 == strcmp(_PyUnicode_AsString(key), \"_fields_\"))\n        return PyCStructUnionType_update_stgdict(self, value, 0);\n    return 0;\n}\n\n\nPyTypeObject PyCStructType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCStructType\",                            /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    PyCStructType_setattro,                     /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for the CData Objects\",           /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCStructType_new,                                  /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic PyTypeObject UnionType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.UnionType\",                        /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    UnionType_setattro,                         /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for the CData Objects\",           /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    UnionType_new,                              /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n\n/*\n\nThe PyCPointerType_Type metaclass must ensure that the subclass of Pointer can be\ncreated. It must check for a _type_ attribute in the class. Since are no\nruntime created properties, a CField is probably *not* needed ?\n\nclass IntPointer(Pointer):\n    _type_ = \"i\"\n\nThe PyCPointer_Type provides the functionality: a contents method/property, a\nsize property/method, and the sequence protocol.\n\n*/\n\nstatic int\nPyCPointerType_SetProto(StgDictObject *stgdict, PyObject *proto)\n{\n    if (!proto || !PyType_Check(proto)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must be a type\");\n        return -1;\n    }\n    if (!PyType_stgdict(proto)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must have storage info\");\n        return -1;\n    }\n    Py_INCREF(proto);\n    Py_XDECREF(stgdict->proto);\n    stgdict->proto = proto;\n    return 0;\n}\n\nstatic PyCArgObject *\nPyCPointerType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    Py_INCREF(self);\n    parg->obj = (PyObject *)self;\n    parg->value.p = *(void **)self->b_ptr;\n    return parg;\n}\n\nstatic PyObject *\nPyCPointerType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *proto;\n    PyObject *typedict;\n\n    typedict = PyTuple_GetItem(args, 2);\n    if (!typedict)\n        return NULL;\n/*\n  stgdict items size, align, length contain info about pointers itself,\n  stgdict->proto has info about the pointed to type!\n*/\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        return NULL;\n    stgdict->size = sizeof(void *);\n    stgdict->align = _ctypes_get_fielddesc(\"P\")->pffi_type->alignment;\n    stgdict->length = 1;\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n    stgdict->paramfunc = PyCPointerType_paramfunc;\n    stgdict->flags |= TYPEFLAG_ISPOINTER;\n\n    proto = PyDict_GetItemString(typedict, \"_type_\"); /* Borrowed ref */\n    if (proto && -1 == PyCPointerType_SetProto(stgdict, proto)) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    if (proto) {\n        StgDictObject *itemdict = PyType_stgdict(proto);\n        assert(itemdict);\n        /* If itemdict->format is NULL, then this is a pointer to an\n           incomplete type.  We create a generic format string\n           'pointer to bytes' in this case.  XXX Better would be to\n           fix the format string later...\n        */\n        stgdict->format = _ctypes_alloc_format_string(\"&\",\n                      itemdict->format ? itemdict->format : \"B\");\n        if (stgdict->format == NULL) {\n            Py_DECREF((PyObject *)stgdict);\n            return NULL;\n        }\n    }\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_DECREF(result->tp_dict);\n    result->tp_dict = (PyObject *)stgdict;\n\n    return (PyObject *)result;\n}\n\n\nstatic PyObject *\nPyCPointerType_set_type(PyTypeObject *self, PyObject *type)\n{\n    StgDictObject *dict;\n\n    dict = PyType_stgdict((PyObject *)self);\n    assert(dict);\n\n    if (-1 == PyCPointerType_SetProto(dict, type))\n        return NULL;\n\n    if (-1 == PyDict_SetItemString((PyObject *)dict, \"_type_\", type))\n        return NULL;\n\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *_byref(PyObject *);\n\nstatic PyObject *\nPyCPointerType_from_param(PyObject *type, PyObject *value)\n{\n    StgDictObject *typedict;\n\n    if (value == Py_None) {\n        /* ConvParam will convert to a NULL pointer later */\n        Py_INCREF(value);\n        return value;\n    }\n\n    typedict = PyType_stgdict(type);\n    assert(typedict); /* Cannot be NULL for pointer types */\n\n    /* If we expect POINTER(<type>), but receive a <type> instance, accept\n       it by calling byref(<type>).\n    */\n    switch (PyObject_IsInstance(value, typedict->proto)) {\n    case 1:\n        Py_INCREF(value); /* _byref steals a refcount */\n        return _byref(value);\n    case -1:\n        return NULL;\n    default:\n        break;\n    }\n\n    if (PointerObject_Check(value) || ArrayObject_Check(value)) {\n        /* Array instances are also pointers when\n           the item types are the same.\n        */\n        StgDictObject *v = PyObject_stgdict(value);\n        assert(v); /* Cannot be NULL for pointer or array objects */\n        if (PyObject_IsSubclass(v->proto, typedict->proto)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n    return CDataType_from_param(type, value);\n}\n\nstatic PyMethodDef PyCPointerType_methods[] = {\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc},\n    { \"from_param\", (PyCFunction)PyCPointerType_from_param, METH_O, from_param_doc},\n    { \"set_type\", (PyCFunction)PyCPointerType_set_type, METH_O },\n    { NULL, NULL },\n};\n\nPyTypeObject PyCPointerType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCPointerType\",                                   /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for the Pointer Objects\",         /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCPointerType_methods,                     /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCPointerType_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCArrayType_Type\n*/\n/*\n  PyCArrayType_new ensures that the new Array subclass created has a _length_\n  attribute, and a _type_ attribute.\n*/\n\nstatic int\nCharArray_set_raw(CDataObject *self, PyObject *value)\n{\n    char *ptr;\n    Py_ssize_t size;\n    Py_buffer view;\n\n    if (PyObject_GetBuffer(value, &view, PyBUF_SIMPLE) < 0)\n        return -1;\n    size = view.len;\n    ptr = view.buf;\n    if (size > self->b_size) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"string too long\");\n        goto fail;\n    }\n\n    memcpy(self->b_ptr, ptr, size);\n\n    PyBuffer_Release(&view);\n    return 0;\n fail:\n    PyBuffer_Release(&view);\n    return -1;\n}\n\nstatic PyObject *\nCharArray_get_raw(CDataObject *self)\n{\n    return PyBytes_FromStringAndSize(self->b_ptr, self->b_size);\n}\n\nstatic PyObject *\nCharArray_get_value(CDataObject *self)\n{\n    int i;\n    char *ptr = self->b_ptr;\n    for (i = 0; i < self->b_size; ++i)\n        if (*ptr++ == '\\0')\n            break;\n    return PyBytes_FromStringAndSize(self->b_ptr, i);\n}\n\nstatic int\nCharArray_set_value(CDataObject *self, PyObject *value)\n{\n    char *ptr;\n    Py_ssize_t size;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n\n    if (PyUnicode_Check(value)) {\n        value = PyUnicode_AsEncodedString(value,\n                                          _ctypes_conversion_encoding,\n                                          _ctypes_conversion_errors);\n        if (!value)\n            return -1;\n    } else if (!PyBytes_Check(value)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"str/bytes expected instead of %s instance\",\n                     Py_TYPE(value)->tp_name);\n        return -1;\n    } else\n        Py_INCREF(value);\n    size = PyBytes_GET_SIZE(value);\n    if (size > self->b_size) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"string too long\");\n        Py_DECREF(value);\n        return -1;\n    }\n\n    ptr = PyBytes_AS_STRING(value);\n    memcpy(self->b_ptr, ptr, size);\n    if (size < self->b_size)\n        self->b_ptr[size] = '\\0';\n    Py_DECREF(value);\n\n    return 0;\n}\n\nstatic PyGetSetDef CharArray_getsets[] = {\n    { \"raw\", (getter)CharArray_get_raw, (setter)CharArray_set_raw,\n      \"value\", NULL },\n    { \"value\", (getter)CharArray_get_value, (setter)CharArray_set_value,\n      \"string value\"},\n    { NULL, NULL }\n};\n\n#ifdef CTYPES_UNICODE\nstatic PyObject *\nWCharArray_get_value(CDataObject *self)\n{\n    unsigned int i;\n    wchar_t *ptr = (wchar_t *)self->b_ptr;\n    for (i = 0; i < self->b_size/sizeof(wchar_t); ++i)\n        if (*ptr++ == (wchar_t)0)\n            break;\n    return PyUnicode_FromWideChar((wchar_t *)self->b_ptr, i);\n}\n\nstatic int\nWCharArray_set_value(CDataObject *self, PyObject *value)\n{\n    Py_ssize_t result = 0;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n    if (PyBytes_Check(value)) {\n        value = PyUnicode_FromEncodedObject(value,\n                                            _ctypes_conversion_encoding,\n                                            _ctypes_conversion_errors);\n        if (!value)\n            return -1;\n    } else if (!PyUnicode_Check(value)) {\n        PyErr_Format(PyExc_TypeError,\n                        \"unicode string expected instead of %s instance\",\n                        Py_TYPE(value)->tp_name);\n        return -1;\n    } else\n        Py_INCREF(value);\n    if ((unsigned)PyUnicode_GET_SIZE(value) > self->b_size/sizeof(wchar_t)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"string too long\");\n        result = -1;\n        goto done;\n    }\n    result = PyUnicode_AsWideChar((PyUnicodeObject *)value,\n                                  (wchar_t *)self->b_ptr,\n                                  self->b_size/sizeof(wchar_t));\n    if (result >= 0 && (size_t)result < self->b_size/sizeof(wchar_t))\n        ((wchar_t *)self->b_ptr)[result] = (wchar_t)0;\n  done:\n    Py_DECREF(value);\n\n    return result >= 0 ? 0 : -1;\n}\n\nstatic PyGetSetDef WCharArray_getsets[] = {\n    { \"value\", (getter)WCharArray_get_value, (setter)WCharArray_set_value,\n      \"string value\"},\n    { NULL, NULL }\n};\n#endif\n\n/*\n  The next three functions copied from Python's typeobject.c.\n\n  They are used to attach methods, members, or getsets to a type *after* it\n  has been created: Arrays of characters have additional getsets to treat them\n  as strings.\n */\n/*\nstatic int\nadd_methods(PyTypeObject *type, PyMethodDef *meth)\n{\n    PyObject *dict = type->tp_dict;\n    for (; meth->ml_name != NULL; meth++) {\n        PyObject *descr;\n        descr = PyDescr_NewMethod(type, meth);\n        if (descr == NULL)\n            return -1;\n        if (PyDict_SetItemString(dict,meth->ml_name, descr) < 0)\n            return -1;\n        Py_DECREF(descr);\n    }\n    return 0;\n}\n\nstatic int\nadd_members(PyTypeObject *type, PyMemberDef *memb)\n{\n    PyObject *dict = type->tp_dict;\n    for (; memb->name != NULL; memb++) {\n        PyObject *descr;\n        descr = PyDescr_NewMember(type, memb);\n        if (descr == NULL)\n            return -1;\n        if (PyDict_SetItemString(dict, memb->name, descr) < 0)\n            return -1;\n        Py_DECREF(descr);\n    }\n    return 0;\n}\n*/\n\nstatic int\nadd_getset(PyTypeObject *type, PyGetSetDef *gsp)\n{\n    PyObject *dict = type->tp_dict;\n    for (; gsp->name != NULL; gsp++) {\n        PyObject *descr;\n        descr = PyDescr_NewGetSet(type, gsp);\n        if (descr == NULL)\n            return -1;\n        if (PyDict_SetItemString(dict, gsp->name, descr) < 0)\n            return -1;\n        Py_DECREF(descr);\n    }\n    return 0;\n}\n\nstatic PyCArgObject *\nPyCArrayType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *p = PyCArgObject_new();\n    if (p == NULL)\n        return NULL;\n    p->tag = 'P';\n    p->pffi_type = &ffi_type_pointer;\n    p->value.p = (char *)self->b_ptr;\n    Py_INCREF(self);\n    p->obj = (PyObject *)self;\n    return p;\n}\n\nstatic PyObject *\nPyCArrayType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    StgDictObject *itemdict;\n    PyObject *proto;\n    PyObject *typedict;\n    long length;\n    int overflow;\n    Py_ssize_t itemsize, itemalign;\n    char buf[32];\n\n    typedict = PyTuple_GetItem(args, 2);\n    if (!typedict)\n        return NULL;\n\n    proto = PyDict_GetItemString(typedict, \"_length_\"); /* Borrowed ref */\n    if (!proto || !PyLong_Check(proto)) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_length_' attribute, \"\n                        \"which must be a positive integer\");\n        return NULL;\n    }\n    length = PyLong_AsLongAndOverflow(proto, &overflow);\n    if (overflow) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"The '_length_' attribute is too large\");\n        return NULL;\n    }\n\n    proto = PyDict_GetItemString(typedict, \"_type_\"); /* Borrowed ref */\n    if (!proto) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_type_' attribute\");\n        return NULL;\n    }\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        return NULL;\n\n    itemdict = PyType_stgdict(proto);\n    if (!itemdict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_type_ must have storage info\");\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    assert(itemdict->format);\n    if (itemdict->format[0] == '(') {\n        sprintf(buf, \"(%ld,\", length);\n        stgdict->format = _ctypes_alloc_format_string(buf, itemdict->format+1);\n    } else {\n        sprintf(buf, \"(%ld)\", length);\n        stgdict->format = _ctypes_alloc_format_string(buf, itemdict->format);\n    }\n    if (stgdict->format == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    stgdict->ndim = itemdict->ndim + 1;\n    stgdict->shape = PyMem_Malloc(sizeof(Py_ssize_t *) * stgdict->ndim);\n    if (stgdict->shape == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    stgdict->shape[0] = length;\n    memmove(&stgdict->shape[1], itemdict->shape,\n        sizeof(Py_ssize_t) * (stgdict->ndim - 1));\n\n    itemsize = itemdict->size;\n    if (length * itemsize < 0) {\n        PyErr_SetString(PyExc_OverflowError,\n                        \"array too large\");\n        return NULL;\n    }\n\n    itemalign = itemdict->align;\n\n    if (itemdict->flags & (TYPEFLAG_ISPOINTER | TYPEFLAG_HASPOINTER))\n        stgdict->flags |= TYPEFLAG_HASPOINTER;\n\n    stgdict->size = itemsize * length;\n    stgdict->align = itemalign;\n    stgdict->length = length;\n    Py_INCREF(proto);\n    stgdict->proto = proto;\n\n    stgdict->paramfunc = &PyCArrayType_paramfunc;\n\n    /* Arrays are passed as pointers to function calls. */\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL)\n        return NULL;\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_DECREF(result->tp_dict);\n    result->tp_dict = (PyObject *)stgdict;\n\n    /* Special case for character arrays.\n       A permanent annoyance: char arrays are also strings!\n    */\n    if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n        if (-1 == add_getset(result, CharArray_getsets))\n            return NULL;\n#ifdef CTYPES_UNICODE\n    } else if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n        if (-1 == add_getset(result, WCharArray_getsets))\n            return NULL;\n#endif\n    }\n\n    return (PyObject *)result;\n}\n\nPyTypeObject PyCArrayType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCArrayType\",                     /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"metatype for the Array Objects\",           /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCArrayType_new,                                   /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCSimpleType_Type\n*/\n/*\n\nPyCSimpleType_new ensures that the new Simple_Type subclass created has a valid\n_type_ attribute.\n\n*/\n\nstatic char *SIMPLE_TYPE_CHARS = \"cbBhHiIlLdfuzZqQPXOv?g\";\n\nstatic PyObject *\nc_wchar_p_from_param(PyObject *type, PyObject *value)\n{\n    PyObject *as_parameter;\n    int res;\n    if (value == Py_None) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    if (PyUnicode_Check(value) || PyBytes_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"Z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'Z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* c_wchar array instance or pointer(c_wchar(...)) */\n        StgDictObject *dt = PyObject_stgdict(value);\n        StgDictObject *dict;\n        assert(dt); /* Cannot be NULL for pointer or array objects */\n        dict = dt && dt->proto ? PyType_stgdict(dt->proto) : NULL;\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"u\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n    if (PyCArg_CheckExact(value)) {\n        /* byref(c_char(...)) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        StgDictObject *dict = PyObject_stgdict(a->obj);\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"u\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n\n    as_parameter = PyObject_GetAttrString(value, \"_as_parameter_\");\n    if (as_parameter) {\n        value = c_wchar_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyObject *\nc_char_p_from_param(PyObject *type, PyObject *value)\n{\n    PyObject *as_parameter;\n    int res;\n    if (value == Py_None) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    if (PyBytes_Check(value) || PyUnicode_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* c_char array instance or pointer(c_char(...)) */\n        StgDictObject *dt = PyObject_stgdict(value);\n        StgDictObject *dict;\n        assert(dt); /* Cannot be NULL for pointer or array objects */\n        dict = dt && dt->proto ? PyType_stgdict(dt->proto) : NULL;\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"c\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n    if (PyCArg_CheckExact(value)) {\n        /* byref(c_char(...)) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        StgDictObject *dict = PyObject_stgdict(a->obj);\n        if (dict && (dict->setfunc == _ctypes_get_fielddesc(\"c\")->setfunc)) {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n\n    as_parameter = PyObject_GetAttrString(value, \"_as_parameter_\");\n    if (as_parameter) {\n        value = c_char_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyObject *\nc_void_p_from_param(PyObject *type, PyObject *value)\n{\n    StgDictObject *stgd;\n    PyObject *as_parameter;\n    int res;\n\n/* None */\n    if (value == Py_None) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n    /* Should probably allow buffer interface as well */\n/* int, long */\n    if (PyLong_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"P\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'P';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n    /* XXX struni: remove later */\n/* string */\n    if (PyBytes_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n/* bytes */\n    if (PyByteArray_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n/* unicode */\n    if (PyUnicode_Check(value)) {\n        PyCArgObject *parg;\n        struct fielddesc *fd = _ctypes_get_fielddesc(\"Z\");\n\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'Z';\n        parg->obj = fd->setfunc(&parg->value, value, 0);\n        if (parg->obj == NULL) {\n            Py_DECREF(parg);\n            return NULL;\n        }\n        return (PyObject *)parg;\n    }\n/* c_void_p instance (or subclass) */\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        /* c_void_p instances */\n        Py_INCREF(value);\n        return value;\n    }\n/* ctypes array or pointer instance */\n    if (ArrayObject_Check(value) || PointerObject_Check(value)) {\n        /* Any array or pointer is accepted */\n        Py_INCREF(value);\n        return value;\n    }\n/* byref(...) */\n    if (PyCArg_CheckExact(value)) {\n        /* byref(c_xxx()) */\n        PyCArgObject *a = (PyCArgObject *)value;\n        if (a->tag == 'P') {\n            Py_INCREF(value);\n            return value;\n        }\n    }\n/* function pointer */\n    if (PyCFuncPtrObject_Check(value)) {\n        PyCArgObject *parg;\n        PyCFuncPtrObject *func;\n        func = (PyCFuncPtrObject *)value;\n        parg = PyCArgObject_new();\n        if (parg == NULL)\n            return NULL;\n        parg->pffi_type = &ffi_type_pointer;\n        parg->tag = 'P';\n        Py_INCREF(value);\n        parg->value.p = *(void **)func->b_ptr;\n        parg->obj = value;\n        return (PyObject *)parg;\n    }\n/* c_char_p, c_wchar_p */\n    stgd = PyObject_stgdict(value);\n    if (stgd && CDataObject_Check(value) && stgd->proto && PyUnicode_Check(stgd->proto)) {\n        PyCArgObject *parg;\n\n        switch (_PyUnicode_AsString(stgd->proto)[0]) {\n        case 'z': /* c_char_p */\n        case 'Z': /* c_wchar_p */\n            parg = PyCArgObject_new();\n            if (parg == NULL)\n                return NULL;\n            parg->pffi_type = &ffi_type_pointer;\n            parg->tag = 'Z';\n            Py_INCREF(value);\n            parg->obj = value;\n            /* Remember: b_ptr points to where the pointer is stored! */\n            parg->value.p = *(void **)(((CDataObject *)value)->b_ptr);\n            return (PyObject *)parg;\n        }\n    }\n\n    as_parameter = PyObject_GetAttrString(value, \"_as_parameter_\");\n    if (as_parameter) {\n        value = c_void_p_from_param(type, as_parameter);\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    /* XXX better message */\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyMethodDef c_void_p_method = { \"from_param\", c_void_p_from_param, METH_O };\nstatic PyMethodDef c_char_p_method = { \"from_param\", c_char_p_from_param, METH_O };\nstatic PyMethodDef c_wchar_p_method = { \"from_param\", c_wchar_p_from_param, METH_O };\n\nstatic PyObject *CreateSwappedType(PyTypeObject *type, PyObject *args, PyObject *kwds,\n                                   PyObject *proto, struct fielddesc *fmt)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *name = PyTuple_GET_ITEM(args, 0);\n    PyObject *newname;\n    PyObject *swapped_args;\n    static PyObject *suffix;\n    Py_ssize_t i;\n\n    swapped_args = PyTuple_New(PyTuple_GET_SIZE(args));\n    if (!swapped_args)\n        return NULL;\n\n    if (suffix == NULL)\n#ifdef WORDS_BIGENDIAN\n        suffix = PyUnicode_InternFromString(\"_le\");\n#else\n        suffix = PyUnicode_InternFromString(\"_be\");\n#endif\n\n    newname = PyUnicode_Concat(name, suffix);\n    if (newname == NULL) {\n        return NULL;\n    }\n\n    PyTuple_SET_ITEM(swapped_args, 0, newname);\n    for (i=1; i<PyTuple_GET_SIZE(args); ++i) {\n        PyObject *v = PyTuple_GET_ITEM(args, i);\n        Py_INCREF(v);\n        PyTuple_SET_ITEM(swapped_args, i, v);\n    }\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, swapped_args, kwds);\n    Py_DECREF(swapped_args);\n    if (result == NULL)\n        return NULL;\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict) /* XXX leaks result! */\n        return NULL;\n\n    stgdict->ffi_type_pointer = *fmt->pffi_type;\n    stgdict->align = fmt->pffi_type->alignment;\n    stgdict->length = 0;\n    stgdict->size = fmt->pffi_type->size;\n    stgdict->setfunc = fmt->setfunc_swapped;\n    stgdict->getfunc = fmt->getfunc_swapped;\n\n    Py_INCREF(proto);\n    stgdict->proto = proto;\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_DECREF(result->tp_dict);\n    result->tp_dict = (PyObject *)stgdict;\n\n    return (PyObject *)result;\n}\n\nstatic PyCArgObject *\nPyCSimpleType_paramfunc(CDataObject *self)\n{\n    StgDictObject *dict;\n    char *fmt;\n    PyCArgObject *parg;\n    struct fielddesc *fd;\n\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    fmt = _PyUnicode_AsString(dict->proto);\n    assert(fmt);\n\n    fd = _ctypes_get_fielddesc(fmt);\n    assert(fd);\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = fmt[0];\n    parg->pffi_type = fd->pffi_type;\n    Py_INCREF(self);\n    parg->obj = (PyObject *)self;\n    memcpy(&parg->value, self->b_ptr, self->b_size);\n    return parg;\n}\n\nstatic PyObject *\nPyCSimpleType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n    PyObject *proto;\n    const char *proto_str;\n    Py_ssize_t proto_len;\n    PyMethodDef *ml;\n    struct fielddesc *fmt;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL)\n        return NULL;\n\n    proto = PyObject_GetAttrString((PyObject *)result, \"_type_\"); /* new ref */\n    if (!proto) {\n        PyErr_SetString(PyExc_AttributeError,\n                        \"class must define a '_type_' attribute\");\n  error:\n        Py_XDECREF(proto);\n        Py_XDECREF(result);\n        return NULL;\n    }\n    if (PyUnicode_Check(proto)) {\n        PyObject *v = _PyUnicode_AsDefaultEncodedString(proto, NULL);\n        if (!v)\n            goto error;\n        proto_str = PyBytes_AS_STRING(v);\n        proto_len = PyBytes_GET_SIZE(v);\n    } else {\n        PyErr_SetString(PyExc_TypeError,\n            \"class must define a '_type_' string attribute\");\n        goto error;\n    }\n    if (proto_len != 1) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"class must define a '_type_' attribute \"\n                        \"which must be a string of length 1\");\n        goto error;\n    }\n    if (!strchr(SIMPLE_TYPE_CHARS, *proto_str)) {\n        PyErr_Format(PyExc_AttributeError,\n                     \"class must define a '_type_' attribute which must be\\n\"\n                     \"a single character string containing one of '%s'.\",\n                     SIMPLE_TYPE_CHARS);\n        goto error;\n    }\n    fmt = _ctypes_get_fielddesc(proto_str);\n    if (fmt == NULL) {\n        PyErr_Format(PyExc_ValueError,\n                     \"_type_ '%s' not supported\", proto_str);\n        goto error;\n    }\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        goto error;\n\n    stgdict->ffi_type_pointer = *fmt->pffi_type;\n    stgdict->align = fmt->pffi_type->alignment;\n    stgdict->length = 0;\n    stgdict->size = fmt->pffi_type->size;\n    stgdict->setfunc = fmt->setfunc;\n    stgdict->getfunc = fmt->getfunc;\n#ifdef WORDS_BIGENDIAN\n    stgdict->format = _ctypes_alloc_format_string(\">\", proto_str);\n#else\n    stgdict->format = _ctypes_alloc_format_string(\"<\", proto_str);\n#endif\n    if (stgdict->format == NULL) {\n        Py_DECREF(result);\n        Py_DECREF(proto);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    stgdict->paramfunc = PyCSimpleType_paramfunc;\n/*\n    if (result->tp_base != &Simple_Type) {\n        stgdict->setfunc = NULL;\n        stgdict->getfunc = NULL;\n    }\n*/\n\n    /* This consumes the refcount on proto which we have */\n    stgdict->proto = proto;\n\n    /* replace the class dict by our updated spam dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_DECREF(result->tp_dict);\n    result->tp_dict = (PyObject *)stgdict;\n\n    /* Install from_param class methods in ctypes base classes.\n       Overrides the PyCSimpleType_from_param generic method.\n     */\n    if (result->tp_base == &Simple_Type) {\n        switch (*proto_str) {\n        case 'z': /* c_char_p */\n            ml = &c_char_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 'Z': /* c_wchar_p */\n            ml = &c_wchar_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 'P': /* c_void_p */\n            ml = &c_void_p_method;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        case 's':\n        case 'X':\n        case 'O':\n            ml = NULL;\n            stgdict->flags |= TYPEFLAG_ISPOINTER;\n            break;\n        default:\n            ml = NULL;\n            break;\n        }\n\n        if (ml) {\n            PyObject *meth;\n            int x;\n            meth = PyDescr_NewClassMethod(result, ml);\n            if (!meth)\n                return NULL;\n            x = PyDict_SetItemString(result->tp_dict,\n                                     ml->ml_name,\n                                     meth);\n            Py_DECREF(meth);\n            if (x == -1) {\n                Py_DECREF(result);\n                return NULL;\n            }\n        }\n    }\n\n    if (type == &PyCSimpleType_Type && fmt->setfunc_swapped && fmt->getfunc_swapped) {\n        PyObject *swapped = CreateSwappedType(type, args, kwds,\n                                              proto, fmt);\n        StgDictObject *sw_dict;\n        if (swapped == NULL) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        sw_dict = PyType_stgdict(swapped);\n#ifdef WORDS_BIGENDIAN\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_le__\", swapped);\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_be__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_be__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_le__\", swapped);\n        /* We are creating the type for the OTHER endian */\n        sw_dict->format = _ctypes_alloc_format_string(\"<\", stgdict->format+1);\n#else\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_be__\", swapped);\n        PyObject_SetAttrString((PyObject *)result, \"__ctype_le__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_le__\", (PyObject *)result);\n        PyObject_SetAttrString(swapped, \"__ctype_be__\", swapped);\n        /* We are creating the type for the OTHER endian */\n        sw_dict->format = _ctypes_alloc_format_string(\">\", stgdict->format+1);\n#endif\n        Py_DECREF(swapped);\n        if (PyErr_Occurred()) {\n            Py_DECREF(result);\n            return NULL;\n        }\n    };\n\n    return (PyObject *)result;\n}\n\n/*\n * This is a *class method*.\n * Convert a parameter into something that ConvParam can handle.\n */\nstatic PyObject *\nPyCSimpleType_from_param(PyObject *type, PyObject *value)\n{\n    StgDictObject *dict;\n    char *fmt;\n    PyCArgObject *parg;\n    struct fielddesc *fd;\n    PyObject *as_parameter;\n    int res;\n\n    /* If the value is already an instance of the requested type,\n       we can use it as is */\n    res = PyObject_IsInstance(value, type);\n    if (res == -1)\n        return NULL;\n    if (res) {\n        Py_INCREF(value);\n        return value;\n    }\n\n    dict = PyType_stgdict(type);\n    assert(dict);\n\n    /* I think we can rely on this being a one-character string */\n    fmt = _PyUnicode_AsString(dict->proto);\n    assert(fmt);\n\n    fd = _ctypes_get_fielddesc(fmt);\n    assert(fd);\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = fmt[0];\n    parg->pffi_type = fd->pffi_type;\n    parg->obj = fd->setfunc(&parg->value, value, 0);\n    if (parg->obj)\n        return (PyObject *)parg;\n    PyErr_Clear();\n    Py_DECREF(parg);\n\n    as_parameter = PyObject_GetAttrString(value, \"_as_parameter_\");\n    if (as_parameter) {\n        if (Py_EnterRecursiveCall(\"while processing _as_parameter_\")) {\n            Py_DECREF(as_parameter);\n            return NULL;\n        }\n        value = PyCSimpleType_from_param(type, as_parameter);\n        Py_LeaveRecursiveCall();\n        Py_DECREF(as_parameter);\n        return value;\n    }\n    PyErr_SetString(PyExc_TypeError,\n                    \"wrong type\");\n    return NULL;\n}\n\nstatic PyMethodDef PyCSimpleType_methods[] = {\n    { \"from_param\", PyCSimpleType_from_param, METH_O, from_param_doc },\n    { \"from_address\", CDataType_from_address, METH_O, from_address_doc },\n    { \"from_buffer\", CDataType_from_buffer, METH_VARARGS, from_buffer_doc, },\n    { \"from_buffer_copy\", CDataType_from_buffer_copy, METH_VARARGS, from_buffer_copy_doc, },\n    { \"in_dll\", CDataType_in_dll, METH_VARARGS, in_dll_doc},\n    { NULL, NULL },\n};\n\nPyTypeObject PyCSimpleType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCSimpleType\",                                    /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,             /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"metatype for the PyCSimpleType Objects\",           /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCSimpleType_methods,                      /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCSimpleType_new,                                  /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/******************************************************************/\n/*\n  PyCFuncPtrType_Type\n */\n\nstatic PyObject *\nconverters_from_argtypes(PyObject *ob)\n{\n    PyObject *converters;\n    Py_ssize_t i;\n    Py_ssize_t nArgs;\n\n    ob = PySequence_Tuple(ob); /* new reference */\n    if (!ob) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"_argtypes_ must be a sequence of types\");\n        return NULL;\n    }\n\n    nArgs = PyTuple_GET_SIZE(ob);\n    converters = PyTuple_New(nArgs);\n    if (!converters)\n        return NULL;\n\n    /* I have to check if this is correct. Using c_char, which has a size\n       of 1, will be assumed to be pushed as only one byte!\n       Aren't these promoted to integers by the C compiler and pushed as 4 bytes?\n    */\n\n    for (i = 0; i < nArgs; ++i) {\n        PyObject *tp = PyTuple_GET_ITEM(ob, i);\n        PyObject *cnv = PyObject_GetAttrString(tp, \"from_param\");\n        if (!cnv)\n            goto argtypes_error_1;\n        PyTuple_SET_ITEM(converters, i, cnv);\n    }\n    Py_DECREF(ob);\n    return converters;\n\n  argtypes_error_1:\n    Py_XDECREF(converters);\n    Py_DECREF(ob);\n    PyErr_Format(PyExc_TypeError,\n                 \"item %zd in _argtypes_ has no from_param method\",\n                 i+1);\n    return NULL;\n}\n\nstatic int\nmake_funcptrtype_dict(StgDictObject *stgdict)\n{\n    PyObject *ob;\n    PyObject *converters = NULL;\n\n    stgdict->align = _ctypes_get_fielddesc(\"P\")->pffi_type->alignment;\n    stgdict->length = 1;\n    stgdict->size = sizeof(void *);\n    stgdict->setfunc = NULL;\n    stgdict->getfunc = NULL;\n    stgdict->ffi_type_pointer = ffi_type_pointer;\n\n    ob = PyDict_GetItemString((PyObject *)stgdict, \"_flags_\");\n    if (!ob || !PyLong_Check(ob)) {\n        PyErr_SetString(PyExc_TypeError,\n            \"class must define _flags_ which must be an integer\");\n        return -1;\n    }\n    stgdict->flags = PyLong_AS_LONG(ob) | TYPEFLAG_ISPOINTER;\n\n    /* _argtypes_ is optional... */\n    ob = PyDict_GetItemString((PyObject *)stgdict, \"_argtypes_\");\n    if (ob) {\n        converters = converters_from_argtypes(ob);\n        if (!converters)\n            goto error;\n        Py_INCREF(ob);\n        stgdict->argtypes = ob;\n        stgdict->converters = converters;\n    }\n\n    ob = PyDict_GetItemString((PyObject *)stgdict, \"_restype_\");\n    if (ob) {\n        if (ob != Py_None && !PyType_stgdict(ob) && !PyCallable_Check(ob)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"_restype_ must be a type, a callable, or None\");\n            return -1;\n        }\n        Py_INCREF(ob);\n        stgdict->restype = ob;\n        stgdict->checker = PyObject_GetAttrString(ob, \"_check_retval_\");\n        if (stgdict->checker == NULL)\n            PyErr_Clear();\n    }\n/* XXX later, maybe.\n    ob = PyDict_GetItemString((PyObject *)stgdict, \"_errcheck_\");\n    if (ob) {\n        if (!PyCallable_Check(ob)) {\n            PyErr_SetString(PyExc_TypeError,\n                \"_errcheck_ must be callable\");\n            return -1;\n        }\n        Py_INCREF(ob);\n        stgdict->errcheck = ob;\n    }\n*/\n    return 0;\n\n  error:\n    Py_XDECREF(converters);\n    return -1;\n\n}\n\nstatic PyCArgObject *\nPyCFuncPtrType_paramfunc(CDataObject *self)\n{\n    PyCArgObject *parg;\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    Py_INCREF(self);\n    parg->obj = (PyObject *)self;\n    parg->value.p = *(void **)self->b_ptr;\n    return parg;\n}\n\nstatic PyObject *\nPyCFuncPtrType_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyTypeObject *result;\n    StgDictObject *stgdict;\n\n    stgdict = (StgDictObject *)PyObject_CallObject(\n        (PyObject *)&PyCStgDict_Type, NULL);\n    if (!stgdict)\n        return NULL;\n\n    stgdict->paramfunc = PyCFuncPtrType_paramfunc;\n    /* We do NOT expose the function signature in the format string.  It\n       is impossible, generally, because the only requirement for the\n       argtypes items is that they have a .from_param method - we do not\n       know the types of the arguments (although, in practice, most\n       argtypes would be a ctypes type).\n    */\n    stgdict->format = _ctypes_alloc_format_string(NULL, \"X{}\");\n    stgdict->flags |= TYPEFLAG_ISPOINTER;\n\n    /* create the new instance (which is a class,\n       since we are a metatype!) */\n    result = (PyTypeObject *)PyType_Type.tp_new(type, args, kwds);\n    if (result == NULL) {\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n\n    /* replace the class dict by our updated storage dict */\n    if (-1 == PyDict_Update((PyObject *)stgdict, result->tp_dict)) {\n        Py_DECREF(result);\n        Py_DECREF((PyObject *)stgdict);\n        return NULL;\n    }\n    Py_DECREF(result->tp_dict);\n    result->tp_dict = (PyObject *)stgdict;\n\n    if (-1 == make_funcptrtype_dict(stgdict)) {\n        Py_DECREF(result);\n        return NULL;\n    }\n\n    return (PyObject *)result;\n}\n\nPyTypeObject PyCFuncPtrType_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCFuncPtrType\",                           /* tp_name */\n    0,                                          /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &CDataType_as_sequence,                     /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */\n    \"metatype for C function pointers\",         /* tp_doc */\n    (traverseproc)CDataType_traverse,           /* tp_traverse */\n    (inquiry)CDataType_clear,                   /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    CDataType_methods,                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCFuncPtrType_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/*****************************************************************\n * Code to keep needed objects alive\n */\n\nstatic CDataObject *\nPyCData_GetContainer(CDataObject *self)\n{\n    while (self->b_base)\n        self = self->b_base;\n    if (self->b_objects == NULL) {\n        if (self->b_length) {\n            self->b_objects = PyDict_New();\n        } else {\n            Py_INCREF(Py_None);\n            self->b_objects = Py_None;\n        }\n    }\n    return self;\n}\n\nstatic PyObject *\nGetKeepedObjects(CDataObject *target)\n{\n    return PyCData_GetContainer(target)->b_objects;\n}\n\nstatic PyObject *\nunique_key(CDataObject *target, Py_ssize_t index)\n{\n    char string[256];\n    char *cp = string;\n    size_t bytes_left;\n\n    assert(sizeof(string) - 1 > sizeof(Py_ssize_t) * 2);\n    cp += sprintf(cp, \"%x\", Py_SAFE_DOWNCAST(index, Py_ssize_t, int));\n    while (target->b_base) {\n        bytes_left = sizeof(string) - (cp - string) - 1;\n        /* Hex format needs 2 characters per byte */\n        if (bytes_left < sizeof(Py_ssize_t) * 2) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"ctypes object structure too deep\");\n            return NULL;\n        }\n        cp += sprintf(cp, \":%x\", Py_SAFE_DOWNCAST(target->b_index, Py_ssize_t, int));\n        target = target->b_base;\n    }\n    return PyUnicode_FromStringAndSize(string, cp-string);\n}\n\n/*\n * Keep a reference to 'keep' in the 'target', at index 'index'.\n *\n * If 'keep' is None, do nothing.\n *\n * Otherwise create a dictionary (if it does not yet exist) id the root\n * objects 'b_objects' item, which will store the 'keep' object under a unique\n * key.\n *\n * The unique_key helper travels the target's b_base pointer down to the root,\n * building a string containing hex-formatted indexes found during traversal,\n * separated by colons.\n *\n * The index tuple is used as a key into the root object's b_objects dict.\n *\n * Note: This function steals a refcount of the third argument, even if it\n * fails!\n */\nstatic int\nKeepRef(CDataObject *target, Py_ssize_t index, PyObject *keep)\n{\n    int result;\n    CDataObject *ob;\n    PyObject *key;\n\n/* Optimization: no need to store None */\n    if (keep == Py_None) {\n        Py_DECREF(Py_None);\n        return 0;\n    }\n    ob = PyCData_GetContainer(target);\n    if (ob->b_objects == NULL || !PyDict_CheckExact(ob->b_objects)) {\n        Py_XDECREF(ob->b_objects);\n        ob->b_objects = keep; /* refcount consumed */\n        return 0;\n    }\n    key = unique_key(target, index);\n    if (key == NULL) {\n        Py_DECREF(keep);\n        return -1;\n    }\n    result = PyDict_SetItem(ob->b_objects, key, keep);\n    Py_DECREF(key);\n    Py_DECREF(keep);\n    return result;\n}\n\n/******************************************************************/\n/*\n  PyCData_Type\n */\nstatic int\nPyCData_traverse(CDataObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->b_objects);\n    Py_VISIT((PyObject *)self->b_base);\n    return 0;\n}\n\nstatic int\nPyCData_clear(CDataObject *self)\n{\n    StgDictObject *dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    Py_CLEAR(self->b_objects);\n    if ((self->b_needsfree)\n        && ((size_t)dict->size > sizeof(self->b_value)))\n        PyMem_Free(self->b_ptr);\n    self->b_ptr = NULL;\n    Py_CLEAR(self->b_base);\n    return 0;\n}\n\nstatic void\nPyCData_dealloc(PyObject *self)\n{\n    PyCData_clear((CDataObject *)self);\n    Py_TYPE(self)->tp_free(self);\n}\n\nstatic PyMemberDef PyCData_members[] = {\n    { \"_b_base_\", T_OBJECT,\n      offsetof(CDataObject, b_base), READONLY,\n      \"the base object\" },\n    { \"_b_needsfree_\", T_INT,\n      offsetof(CDataObject, b_needsfree), READONLY,\n      \"whether the object owns the memory or not\" },\n    { \"_objects\", T_OBJECT,\n      offsetof(CDataObject, b_objects), READONLY,\n      \"internal objects tree (NEVER CHANGE THIS OBJECT!)\"},\n    { NULL },\n};\n\nstatic int PyCData_NewGetBuffer(PyObject *_self, Py_buffer *view, int flags)\n{\n    CDataObject *self = (CDataObject *)_self;\n    StgDictObject *dict = PyObject_stgdict(_self);\n    Py_ssize_t i;\n\n    if (view == NULL) return 0;\n\n    view->buf = self->b_ptr;\n    view->obj = _self;\n    Py_INCREF(_self);\n    view->len = self->b_size;\n    view->readonly = 0;\n    /* use default format character if not set */\n    view->format = dict->format ? dict->format : \"B\";\n    view->ndim = dict->ndim;\n    view->shape = dict->shape;\n    view->itemsize = self->b_size;\n    for (i = 0; i < view->ndim; ++i) {\n        view->itemsize /= dict->shape[i];\n    }\n    view->strides = NULL;\n    view->suboffsets = NULL;\n    view->internal = NULL;\n    return 0;\n}\n\nstatic PyBufferProcs PyCData_as_buffer = {\n    PyCData_NewGetBuffer,\n    NULL,\n};\n\n/*\n * CData objects are mutable, so they cannot be hashable!\n */\nstatic long\nPyCData_nohash(PyObject *self)\n{\n    PyErr_SetString(PyExc_TypeError, \"unhashable type\");\n    return -1;\n}\n\nstatic PyObject *\nPyCData_reduce(PyObject *_self, PyObject *args)\n{\n    CDataObject *self = (CDataObject *)_self;\n\n    if (PyObject_stgdict(_self)->flags & (TYPEFLAG_ISPOINTER|TYPEFLAG_HASPOINTER)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"ctypes objects containing pointers cannot be pickled\");\n        return NULL;\n    }\n    return Py_BuildValue(\"O(O(NN))\",\n                         _unpickle,\n                         Py_TYPE(_self),\n                         PyObject_GetAttrString(_self, \"__dict__\"),\n                         PyBytes_FromStringAndSize(self->b_ptr, self->b_size));\n}\n\nstatic PyObject *\nPyCData_setstate(PyObject *_self, PyObject *args)\n{\n    void *data;\n    Py_ssize_t len;\n    int res;\n    PyObject *dict, *mydict;\n    CDataObject *self = (CDataObject *)_self;\n    if (!PyArg_ParseTuple(args, \"Os#\", &dict, &data, &len))\n        return NULL;\n    if (len > self->b_size)\n        len = self->b_size;\n    memmove(self->b_ptr, data, len);\n    mydict = PyObject_GetAttrString(_self, \"__dict__\");\n    res = PyDict_Update(mydict, dict);\n    Py_DECREF(mydict);\n    if (res == -1)\n        return NULL;\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\n/*\n * default __ctypes_from_outparam__ method returns self.\n */\nstatic PyObject *\nPyCData_from_outparam(PyObject *self, PyObject *args)\n{\n    Py_INCREF(self);\n    return self;\n}\n\nstatic PyMethodDef PyCData_methods[] = {\n    { \"__ctypes_from_outparam__\", PyCData_from_outparam, METH_NOARGS, },\n    { \"__reduce__\", PyCData_reduce, METH_NOARGS, },\n    { \"__setstate__\", PyCData_setstate, METH_VARARGS, },\n    { NULL, NULL },\n};\n\nPyTypeObject PyCData_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._CData\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    PyCData_dealloc,                                    /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    PyCData_nohash,                             /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    PyCData_methods,                                    /* tp_methods */\n    PyCData_members,                                    /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    0,                                          /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic int PyCData_MallocBuffer(CDataObject *obj, StgDictObject *dict)\n{\n    if ((size_t)dict->size <= sizeof(obj->b_value)) {\n        /* No need to call malloc, can use the default buffer */\n        obj->b_ptr = (char *)&obj->b_value;\n        /* The b_needsfree flag does not mean that we actually did\n           call PyMem_Malloc to allocate the memory block; instead it\n           means we are the *owner* of the memory and are responsible\n           for freeing resources associated with the memory.  This is\n           also the reason that b_needsfree is exposed to Python.\n         */\n        obj->b_needsfree = 1;\n    } else {\n        /* In python 2.4, and ctypes 0.9.6, the malloc call took about\n           33% of the creation time for c_int().\n        */\n        obj->b_ptr = (char *)PyMem_Malloc(dict->size);\n        if (obj->b_ptr == NULL) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        obj->b_needsfree = 1;\n        memset(obj->b_ptr, 0, dict->size);\n    }\n    obj->b_size = dict->size;\n    return 0;\n}\n\nPyObject *\nPyCData_FromBaseObj(PyObject *type, PyObject *base, Py_ssize_t index, char *adr)\n{\n    CDataObject *cmem;\n    StgDictObject *dict;\n\n    assert(PyType_Check(type));\n    dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n    cmem = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);\n    if (cmem == NULL)\n        return NULL;\n    assert(CDataObject_Check(cmem));\n\n    cmem->b_length = dict->length;\n    cmem->b_size = dict->size;\n    if (base) { /* use base's buffer */\n        assert(CDataObject_Check(base));\n        cmem->b_ptr = adr;\n        cmem->b_needsfree = 0;\n        Py_INCREF(base);\n        cmem->b_base = (CDataObject *)base;\n        cmem->b_index = index;\n    } else { /* copy contents of adr */\n        if (-1 == PyCData_MallocBuffer(cmem, dict)) {\n            return NULL;\n            Py_DECREF(cmem);\n        }\n        memcpy(cmem->b_ptr, adr, dict->size);\n        cmem->b_index = index;\n    }\n    return (PyObject *)cmem;\n}\n\n/*\n Box a memory block into a CData instance.\n*/\nPyObject *\nPyCData_AtAddress(PyObject *type, void *buf)\n{\n    CDataObject *pd;\n    StgDictObject *dict;\n\n    assert(PyType_Check(type));\n    dict = PyType_stgdict(type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n\n    pd = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);\n    if (!pd)\n        return NULL;\n    assert(CDataObject_Check(pd));\n    pd->b_ptr = (char *)buf;\n    pd->b_length = dict->length;\n    pd->b_size = dict->size;\n    return (PyObject *)pd;\n}\n\n/*\n  This function returns TRUE for c_int, c_void_p, and these kind of\n  classes.  FALSE otherwise FALSE also for subclasses of c_int and\n  such.\n*/\nint _ctypes_simple_instance(PyObject *obj)\n{\n    PyTypeObject *type = (PyTypeObject *)obj;\n\n    if (PyCSimpleTypeObject_Check(type))\n        return type->tp_base != &Simple_Type;\n    return 0;\n}\n\nPyObject *\nPyCData_get(PyObject *type, GETFUNC getfunc, PyObject *src,\n          Py_ssize_t index, Py_ssize_t size, char *adr)\n{\n    StgDictObject *dict;\n    if (getfunc)\n        return getfunc(adr, size);\n    assert(type);\n    dict = PyType_stgdict(type);\n    if (dict && dict->getfunc && !_ctypes_simple_instance(type))\n        return dict->getfunc(adr, size);\n    return PyCData_FromBaseObj(type, src, index, adr);\n}\n\n/*\n  Helper function for PyCData_set below.\n*/\nstatic PyObject *\n_PyCData_set(CDataObject *dst, PyObject *type, SETFUNC setfunc, PyObject *value,\n           Py_ssize_t size, char *ptr)\n{\n    CDataObject *src;\n    int err;\n\n    if (setfunc)\n        return setfunc(ptr, value, size);\n\n    if (!CDataObject_Check(value)) {\n        StgDictObject *dict = PyType_stgdict(type);\n        if (dict && dict->setfunc)\n            return dict->setfunc(ptr, value, size);\n        /*\n           If value is a tuple, we try to call the type with the tuple\n           and use the result!\n        */\n        assert(PyType_Check(type));\n        if (PyTuple_Check(value)) {\n            PyObject *ob;\n            PyObject *result;\n            ob = PyObject_CallObject(type, value);\n            if (ob == NULL) {\n                _ctypes_extend_error(PyExc_RuntimeError, \"(%s) \",\n                                  ((PyTypeObject *)type)->tp_name);\n                return NULL;\n            }\n            result = _PyCData_set(dst, type, setfunc, ob,\n                                size, ptr);\n            Py_DECREF(ob);\n            return result;\n        } else if (value == Py_None && PyCPointerTypeObject_Check(type)) {\n            *(void **)ptr = NULL;\n            Py_INCREF(Py_None);\n            return Py_None;\n        } else {\n            PyErr_Format(PyExc_TypeError,\n                         \"expected %s instance, got %s\",\n                         ((PyTypeObject *)type)->tp_name,\n                         Py_TYPE(value)->tp_name);\n            return NULL;\n        }\n    }\n    src = (CDataObject *)value;\n\n    err = PyObject_IsInstance(value, type);\n    if (err == -1)\n        return NULL;\n    if (err) {\n        memcpy(ptr,\n               src->b_ptr,\n               size);\n\n        if (PyCPointerTypeObject_Check(type))\n            /* XXX */;\n\n        value = GetKeepedObjects(src);\n        Py_INCREF(value);\n        return value;\n    }\n\n    if (PyCPointerTypeObject_Check(type)\n        && ArrayObject_Check(value)) {\n        StgDictObject *p1, *p2;\n        PyObject *keep;\n        p1 = PyObject_stgdict(value);\n        assert(p1); /* Cannot be NULL for array instances */\n        p2 = PyType_stgdict(type);\n        assert(p2); /* Cannot be NULL for pointer types */\n\n        if (p1->proto != p2->proto) {\n            PyErr_Format(PyExc_TypeError,\n                         \"incompatible types, %s instance instead of %s instance\",\n                         Py_TYPE(value)->tp_name,\n                         ((PyTypeObject *)type)->tp_name);\n            return NULL;\n        }\n        *(void **)ptr = src->b_ptr;\n\n        keep = GetKeepedObjects(src);\n        /*\n          We are assigning an array object to a field which represents\n          a pointer. This has the same effect as converting an array\n          into a pointer. So, again, we have to keep the whole object\n          pointed to (which is the array in this case) alive, and not\n          only it's object list.  So we create a tuple, containing\n          b_objects list PLUS the array itself, and return that!\n        */\n        return PyTuple_Pack(2, keep, value);\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"incompatible types, %s instance instead of %s instance\",\n                 Py_TYPE(value)->tp_name,\n                 ((PyTypeObject *)type)->tp_name);\n    return NULL;\n}\n\n/*\n * Set a slice in object 'dst', which has the type 'type',\n * to the value 'value'.\n */\nint\nPyCData_set(PyObject *dst, PyObject *type, SETFUNC setfunc, PyObject *value,\n          Py_ssize_t index, Py_ssize_t size, char *ptr)\n{\n    CDataObject *mem = (CDataObject *)dst;\n    PyObject *result;\n\n    if (!CDataObject_Check(dst)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"not a ctype instance\");\n        return -1;\n    }\n\n    result = _PyCData_set(mem, type, setfunc, value,\n                        size, ptr);\n    if (result == NULL)\n        return -1;\n\n    /* KeepRef steals a refcount from it's last argument */\n    /* If KeepRef fails, we are stumped.  The dst memory block has already\n       been changed */\n    return KeepRef(mem, index, result);\n}\n\n\n/******************************************************************/\nstatic PyObject *\nGenericPyCData_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    CDataObject *obj;\n    StgDictObject *dict;\n\n    dict = PyType_stgdict((PyObject *)type);\n    if (!dict) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"abstract class\");\n        return NULL;\n    }\n    dict->flags |= DICTFLAG_FINAL;\n\n    obj = (CDataObject *)type->tp_alloc(type, 0);\n    if (!obj)\n        return NULL;\n\n    obj->b_base = NULL;\n    obj->b_index = 0;\n    obj->b_objects = NULL;\n    obj->b_length = dict->length;\n\n    if (-1 == PyCData_MallocBuffer(obj, dict)) {\n        Py_DECREF(obj);\n        return NULL;\n    }\n    return (PyObject *)obj;\n}\n/*****************************************************************/\n/*\n  PyCFuncPtr_Type\n*/\n\nstatic int\nPyCFuncPtr_set_errcheck(PyCFuncPtrObject *self, PyObject *ob)\n{\n    if (ob && !PyCallable_Check(ob)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the errcheck attribute must be callable\");\n        return -1;\n    }\n    Py_XDECREF(self->errcheck);\n    Py_XINCREF(ob);\n    self->errcheck = ob;\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_errcheck(PyCFuncPtrObject *self)\n{\n    if (self->errcheck) {\n        Py_INCREF(self->errcheck);\n        return self->errcheck;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic int\nPyCFuncPtr_set_restype(PyCFuncPtrObject *self, PyObject *ob)\n{\n    if (ob == NULL) {\n        Py_XDECREF(self->restype);\n        self->restype = NULL;\n        Py_XDECREF(self->checker);\n        self->checker = NULL;\n        return 0;\n    }\n    if (ob != Py_None && !PyType_stgdict(ob) && !PyCallable_Check(ob)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"restype must be a type, a callable, or None\");\n        return -1;\n    }\n    Py_XDECREF(self->checker);\n    Py_XDECREF(self->restype);\n    Py_INCREF(ob);\n    self->restype = ob;\n    self->checker = PyObject_GetAttrString(ob, \"_check_retval_\");\n    if (self->checker == NULL)\n        PyErr_Clear();\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_restype(PyCFuncPtrObject *self)\n{\n    StgDictObject *dict;\n    if (self->restype) {\n        Py_INCREF(self->restype);\n        return self->restype;\n    }\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    if (dict->restype) {\n        Py_INCREF(dict->restype);\n        return dict->restype;\n    } else {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n}\n\nstatic int\nPyCFuncPtr_set_argtypes(PyCFuncPtrObject *self, PyObject *ob)\n{\n    PyObject *converters;\n\n    if (ob == NULL || ob == Py_None) {\n        Py_XDECREF(self->converters);\n        self->converters = NULL;\n        Py_XDECREF(self->argtypes);\n        self->argtypes = NULL;\n    } else {\n        converters = converters_from_argtypes(ob);\n        if (!converters)\n            return -1;\n        Py_XDECREF(self->converters);\n        self->converters = converters;\n        Py_XDECREF(self->argtypes);\n        Py_INCREF(ob);\n        self->argtypes = ob;\n    }\n    return 0;\n}\n\nstatic PyObject *\nPyCFuncPtr_get_argtypes(PyCFuncPtrObject *self)\n{\n    StgDictObject *dict;\n    if (self->argtypes) {\n        Py_INCREF(self->argtypes);\n        return self->argtypes;\n    }\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    if (dict->argtypes) {\n        Py_INCREF(dict->argtypes);\n        return dict->argtypes;\n    } else {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n}\n\nstatic PyGetSetDef PyCFuncPtr_getsets[] = {\n    { \"errcheck\", (getter)PyCFuncPtr_get_errcheck, (setter)PyCFuncPtr_set_errcheck,\n      \"a function to check for errors\", NULL },\n    { \"restype\", (getter)PyCFuncPtr_get_restype, (setter)PyCFuncPtr_set_restype,\n      \"specify the result type\", NULL },\n    { \"argtypes\", (getter)PyCFuncPtr_get_argtypes,\n      (setter)PyCFuncPtr_set_argtypes,\n      \"specify the argument types\", NULL },\n    { NULL, NULL }\n};\n\n#ifdef MS_WIN32\nstatic PPROC FindAddress(void *handle, char *name, PyObject *type)\n{\n#ifdef MS_WIN64\n    /* win64 has no stdcall calling conv, so it should\n       also not have the name mangling of it.\n    */\n    return (PPROC)GetProcAddress(handle, name);\n#else\n    PPROC address;\n    char *mangled_name;\n    int i;\n    StgDictObject *dict;\n\n    address = (PPROC)GetProcAddress(handle, name);\n    if (address)\n        return address;\n    if (((size_t)name & ~0xFFFF) == 0) {\n        return NULL;\n    }\n\n    dict = PyType_stgdict((PyObject *)type);\n    /* It should not happen that dict is NULL, but better be safe */\n    if (dict==NULL || dict->flags & FUNCFLAG_CDECL)\n        return address;\n\n    /* for stdcall, try mangled names:\n       funcname -> _funcname@<n>\n       where n is 0, 4, 8, 12, ..., 128\n     */\n    mangled_name = alloca(strlen(name) + 1 + 1 + 1 + 3); /* \\0 _ @ %d */\n    if (!mangled_name)\n        return NULL;\n    for (i = 0; i < 32; ++i) {\n        sprintf(mangled_name, \"_%s@%d\", name, i*4);\n        address = (PPROC)GetProcAddress(handle, mangled_name);\n        if (address)\n            return address;\n    }\n    return NULL;\n#endif\n}\n#endif\n\n/* Return 1 if usable, 0 else and exception set. */\nstatic int\n_check_outarg_type(PyObject *arg, Py_ssize_t index)\n{\n    StgDictObject *dict;\n\n    if (PyCPointerTypeObject_Check(arg))\n        return 1;\n\n    if (PyCArrayTypeObject_Check(arg))\n        return 1;\n\n    dict = PyType_stgdict(arg);\n    if (dict\n        /* simple pointer types, c_void_p, c_wchar_p, BSTR, ... */\n        && PyUnicode_Check(dict->proto)\n/* We only allow c_void_p, c_char_p and c_wchar_p as a simple output parameter type */\n        && (strchr(\"PzZ\", _PyUnicode_AsString(dict->proto)[0]))) {\n        return 1;\n    }\n\n    PyErr_Format(PyExc_TypeError,\n                 \"'out' parameter %d must be a pointer type, not %s\",\n                 Py_SAFE_DOWNCAST(index, Py_ssize_t, int),\n                 PyType_Check(arg) ?\n                 ((PyTypeObject *)arg)->tp_name :\n             Py_TYPE(arg)->tp_name);\n    return 0;\n}\n\n/* Returns 1 on success, 0 on error */\nstatic int\n_validate_paramflags(PyTypeObject *type, PyObject *paramflags)\n{\n    Py_ssize_t i, len;\n    StgDictObject *dict;\n    PyObject *argtypes;\n\n    dict = PyType_stgdict((PyObject *)type);\n    assert(dict); /* Cannot be NULL. 'type' is a PyCFuncPtr type. */\n    argtypes = dict->argtypes;\n\n    if (paramflags == NULL || dict->argtypes == NULL)\n        return 1;\n\n    if (!PyTuple_Check(paramflags)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"paramflags must be a tuple or None\");\n        return 0;\n    }\n\n    len = PyTuple_GET_SIZE(paramflags);\n    if (len != PyTuple_GET_SIZE(dict->argtypes)) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"paramflags must have the same length as argtypes\");\n        return 0;\n    }\n\n    for (i = 0; i < len; ++i) {\n        PyObject *item = PyTuple_GET_ITEM(paramflags, i);\n        int flag;\n        char *name;\n        PyObject *defval;\n        PyObject *typ;\n        if (!PyArg_ParseTuple(item, \"i|ZO\", &flag, &name, &defval)) {\n            PyErr_SetString(PyExc_TypeError,\n                   \"paramflags must be a sequence of (int [,string [,value]]) tuples\");\n            return 0;\n        }\n        typ = PyTuple_GET_ITEM(argtypes, i);\n        switch (flag & (PARAMFLAG_FIN | PARAMFLAG_FOUT | PARAMFLAG_FLCID)) {\n        case 0:\n        case PARAMFLAG_FIN:\n        case PARAMFLAG_FIN | PARAMFLAG_FLCID:\n        case PARAMFLAG_FIN | PARAMFLAG_FOUT:\n            break;\n        case PARAMFLAG_FOUT:\n            if (!_check_outarg_type(typ, i+1))\n                return 0;\n            break;\n        default:\n            PyErr_Format(PyExc_TypeError,\n                         \"paramflag value %d not supported\",\n                         flag);\n            return 0;\n        }\n    }\n    return 1;\n}\n\nstatic int\n_get_name(PyObject *obj, char **pname)\n{\n#ifdef MS_WIN32\n    if (PyLong_Check(obj)) {\n        /* We have to use MAKEINTRESOURCEA for Windows CE.\n           Works on Windows as well, of course.\n        */\n        *pname = MAKEINTRESOURCEA(PyLong_AsUnsignedLongMask(obj) & 0xFFFF);\n        return 1;\n    }\n#endif\n    if (PyBytes_Check(obj)) {\n        *pname = PyBytes_AS_STRING(obj);\n        return *pname ? 1 : 0;\n    }\n    if (PyUnicode_Check(obj)) {\n        *pname = _PyUnicode_AsString(obj);\n        return *pname ? 1 : 0;\n    }\n    PyErr_SetString(PyExc_TypeError,\n                    \"function name must be string or integer\");\n    return 0;\n}\n\n\nstatic PyObject *\nPyCFuncPtr_FromDll(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    char *name;\n    int (* address)(void);\n    PyObject *dll;\n    PyObject *obj;\n    PyCFuncPtrObject *self;\n    void *handle;\n    PyObject *paramflags = NULL;\n\n    if (!PyArg_ParseTuple(args, \"(O&O)|O\", _get_name, &name, &dll, &paramflags))\n        return NULL;\n    if (paramflags == Py_None)\n        paramflags = NULL;\n\n    obj = PyObject_GetAttrString(dll, \"_handle\");\n    if (!obj)\n        return NULL;\n    if (!PyLong_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"the _handle attribute of the second argument must be an integer\");\n        Py_DECREF(obj);\n        return NULL;\n    }\n    handle = (void *)PyLong_AsVoidPtr(obj);\n    Py_DECREF(obj);\n    if (PyErr_Occurred()) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"could not convert the _handle attribute to a pointer\");\n        return NULL;\n    }\n\n#ifdef MS_WIN32\n    address = FindAddress(handle, name, (PyObject *)type);\n    if (!address) {\n        if (!IS_INTRESOURCE(name))\n            PyErr_Format(PyExc_AttributeError,\n                         \"function '%s' not found\",\n                         name);\n        else\n            PyErr_Format(PyExc_AttributeError,\n                         \"function ordinal %d not found\",\n                         (WORD)(size_t)name);\n        return NULL;\n    }\n#else\n    address = (PPROC)ctypes_dlsym(handle, name);\n    if (!address) {\n#ifdef __CYGWIN__\n/* dlerror() isn't very helpful on cygwin */\n        PyErr_Format(PyExc_AttributeError,\n                     \"function '%s' not found (%s) \",\n                     name);\n#else\n        PyErr_SetString(PyExc_AttributeError, ctypes_dlerror());\n#endif\n        return NULL;\n    }\n#endif\n    if (!_validate_paramflags(type, paramflags))\n        return NULL;\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    if (!self)\n        return NULL;\n\n    Py_XINCREF(paramflags);\n    self->paramflags = paramflags;\n\n    *(void **)self->b_ptr = address;\n\n    Py_INCREF((PyObject *)dll); /* for KeepRef */\n    if (-1 == KeepRef((CDataObject *)self, 0, dll)) {\n        Py_DECREF((PyObject *)self);\n        return NULL;\n    }\n\n    Py_INCREF(self);\n    self->callable = (PyObject *)self;\n    return (PyObject *)self;\n}\n\n#ifdef MS_WIN32\nstatic PyObject *\nPyCFuncPtr_FromVtblIndex(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyCFuncPtrObject *self;\n    int index;\n    char *name = NULL;\n    PyObject *paramflags = NULL;\n    GUID *iid = NULL;\n    Py_ssize_t iid_len = 0;\n\n    if (!PyArg_ParseTuple(args, \"is|Oz#\", &index, &name, &paramflags, &iid, &iid_len))\n        return NULL;\n    if (paramflags == Py_None)\n        paramflags = NULL;\n\n    if (!_validate_paramflags(type, paramflags))\n        return NULL;\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    self->index = index + 0x1000;\n    Py_XINCREF(paramflags);\n    self->paramflags = paramflags;\n    if (iid_len == sizeof(GUID))\n        self->iid = iid;\n    return (PyObject *)self;\n}\n#endif\n\n/*\n  PyCFuncPtr_new accepts different argument lists in addition to the standard\n  _basespec_ keyword arg:\n\n  one argument form\n  \"i\" - function address\n  \"O\" - must be a callable, creates a C callable function\n\n  two or more argument forms (the third argument is a paramflags tuple)\n  \"(sO)|...\" - (function name, dll object (with an integer handle)), paramflags\n  \"(iO)|...\" - (function ordinal, dll object (with an integer handle)), paramflags\n  \"is|...\" - vtable index, method name, creates callable calling COM vtbl\n*/\nstatic PyObject *\nPyCFuncPtr_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n    PyCFuncPtrObject *self;\n    PyObject *callable;\n    StgDictObject *dict;\n    CThunkObject *thunk;\n\n    if (PyTuple_GET_SIZE(args) == 0)\n        return GenericPyCData_new(type, args, kwds);\n\n    if (1 <= PyTuple_GET_SIZE(args) && PyTuple_Check(PyTuple_GET_ITEM(args, 0)))\n        return PyCFuncPtr_FromDll(type, args, kwds);\n\n#ifdef MS_WIN32\n    if (2 <= PyTuple_GET_SIZE(args) && PyLong_Check(PyTuple_GET_ITEM(args, 0)))\n        return PyCFuncPtr_FromVtblIndex(type, args, kwds);\n#endif\n\n    if (1 == PyTuple_GET_SIZE(args)\n        && (PyLong_Check(PyTuple_GET_ITEM(args, 0)))) {\n        CDataObject *ob;\n        void *ptr = PyLong_AsVoidPtr(PyTuple_GET_ITEM(args, 0));\n        if (ptr == NULL && PyErr_Occurred())\n            return NULL;\n        ob = (CDataObject *)GenericPyCData_new(type, args, kwds);\n        if (ob == NULL)\n            return NULL;\n        *(void **)ob->b_ptr = ptr;\n        return (PyObject *)ob;\n    }\n\n    if (!PyArg_ParseTuple(args, \"O\", &callable))\n        return NULL;\n    if (!PyCallable_Check(callable)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"argument must be callable or integer function address\");\n        return NULL;\n    }\n\n    /* XXX XXX This would allow to pass additional options.  For COM\n       method *implementations*, we would probably want different\n       behaviour than in 'normal' callback functions: return a HRESULT if\n       an exception occurs in the callback, and print the traceback not\n       only on the console, but also to OutputDebugString() or something\n       like that.\n    */\n/*\n    if (kwds && PyDict_GetItemString(kwds, \"options\")) {\n        ...\n    }\n*/\n\n    dict = PyType_stgdict((PyObject *)type);\n    /* XXXX Fails if we do: 'PyCFuncPtr(lambda x: x)' */\n    if (!dict || !dict->argtypes) {\n        PyErr_SetString(PyExc_TypeError,\n               \"cannot construct instance of this class:\"\n            \" no argtypes\");\n        return NULL;\n    }\n\n    thunk = _ctypes_alloc_callback(callable,\n                                  dict->argtypes,\n                                  dict->restype,\n                                  dict->flags);\n    if (!thunk)\n        return NULL;\n\n    self = (PyCFuncPtrObject *)GenericPyCData_new(type, args, kwds);\n    if (self == NULL) {\n        Py_DECREF(thunk);\n        return NULL;\n    }\n\n    Py_INCREF(callable);\n    self->callable = callable;\n\n    self->thunk = thunk;\n    *(void **)self->b_ptr = (void *)thunk->pcl;\n\n    Py_INCREF((PyObject *)thunk); /* for KeepRef */\n    if (-1 == KeepRef((CDataObject *)self, 0, (PyObject *)thunk)) {\n        Py_DECREF((PyObject *)self);\n        return NULL;\n    }\n    return (PyObject *)self;\n}\n\n\n/*\n  _byref consumes a refcount to its argument\n*/\nstatic PyObject *\n_byref(PyObject *obj)\n{\n    PyCArgObject *parg;\n    if (!CDataObject_Check(obj)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"expected CData instance\");\n        return NULL;\n    }\n\n    parg = PyCArgObject_new();\n    if (parg == NULL) {\n        Py_DECREF(obj);\n        return NULL;\n    }\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    parg->obj = obj;\n    parg->value.p = ((CDataObject *)obj)->b_ptr;\n    return (PyObject *)parg;\n}\n\nstatic PyObject *\n_get_arg(int *pindex, PyObject *name, PyObject *defval, PyObject *inargs, PyObject *kwds)\n{\n    PyObject *v;\n\n    if (*pindex < PyTuple_GET_SIZE(inargs)) {\n        v = PyTuple_GET_ITEM(inargs, *pindex);\n        ++*pindex;\n        Py_INCREF(v);\n        return v;\n    }\n    if (kwds && (v = PyDict_GetItem(kwds, name))) {\n        ++*pindex;\n        Py_INCREF(v);\n        return v;\n    }\n    if (defval) {\n        Py_INCREF(defval);\n        return defval;\n    }\n    /* we can't currently emit a better error message */\n    if (name)\n        PyErr_Format(PyExc_TypeError,\n                     \"required argument '%S' missing\", name);\n    else\n        PyErr_Format(PyExc_TypeError,\n                     \"not enough arguments\");\n    return NULL;\n}\n\n/*\n This function implements higher level functionality plus the ability to call\n functions with keyword arguments by looking at parameter flags.  parameter\n flags is a tuple of 1, 2 or 3-tuples.  The first entry in each is an integer\n specifying the direction of the data transfer for this parameter - 'in',\n 'out' or 'inout' (zero means the same as 'in').  The second entry is the\n parameter name, and the third is the default value if the parameter is\n missing in the function call.\n\n This function builds and returns a new tuple 'callargs' which contains the\n parameters to use in the call.  Items on this tuple are copied from the\n 'inargs' tuple for 'in' and 'in, out' parameters, and constructed from the\n 'argtypes' tuple for 'out' parameters.  It also calculates numretvals which\n is the number of return values for the function, outmask/inoutmask are\n bitmasks containing indexes into the callargs tuple specifying which\n parameters have to be returned.  _build_result builds the return value of the\n function.\n*/\nstatic PyObject *\n_build_callargs(PyCFuncPtrObject *self, PyObject *argtypes,\n                PyObject *inargs, PyObject *kwds,\n                int *poutmask, int *pinoutmask, unsigned int *pnumretvals)\n{\n    PyObject *paramflags = self->paramflags;\n    PyObject *callargs;\n    StgDictObject *dict;\n    Py_ssize_t i, len;\n    int inargs_index = 0;\n    /* It's a little bit difficult to determine how many arguments the\n    function call requires/accepts.  For simplicity, we count the consumed\n    args and compare this to the number of supplied args. */\n    Py_ssize_t actual_args;\n\n    *poutmask = 0;\n    *pinoutmask = 0;\n    *pnumretvals = 0;\n\n    /* Trivial cases, where we either return inargs itself, or a slice of it. */\n    if (argtypes == NULL || paramflags == NULL || PyTuple_GET_SIZE(argtypes) == 0) {\n#ifdef MS_WIN32\n        if (self->index)\n            return PyTuple_GetSlice(inargs, 1, PyTuple_GET_SIZE(inargs));\n#endif\n        Py_INCREF(inargs);\n        return inargs;\n    }\n\n    len = PyTuple_GET_SIZE(argtypes);\n    callargs = PyTuple_New(len); /* the argument tuple we build */\n    if (callargs == NULL)\n        return NULL;\n\n#ifdef MS_WIN32\n    /* For a COM method, skip the first arg */\n    if (self->index) {\n        inargs_index = 1;\n    }\n#endif\n    for (i = 0; i < len; ++i) {\n        PyObject *item = PyTuple_GET_ITEM(paramflags, i);\n        PyObject *ob;\n        int flag;\n        PyObject *name = NULL;\n        PyObject *defval = NULL;\n\n        /* This way seems to be ~2 us faster than the PyArg_ParseTuple\n           calls below. */\n        /* We HAVE already checked that the tuple can be parsed with \"i|ZO\", so... */\n        Py_ssize_t tsize = PyTuple_GET_SIZE(item);\n        flag = PyLong_AS_LONG(PyTuple_GET_ITEM(item, 0));\n        name = tsize > 1 ? PyTuple_GET_ITEM(item, 1) : NULL;\n        defval = tsize > 2 ? PyTuple_GET_ITEM(item, 2) : NULL;\n\n        switch (flag & (PARAMFLAG_FIN | PARAMFLAG_FOUT | PARAMFLAG_FLCID)) {\n        case PARAMFLAG_FIN | PARAMFLAG_FLCID:\n            /* ['in', 'lcid'] parameter.  Always taken from defval,\n             if given, else the integer 0. */\n            if (defval == NULL) {\n                defval = PyLong_FromLong(0);\n                if (defval == NULL)\n                    goto error;\n            } else\n                Py_INCREF(defval);\n            PyTuple_SET_ITEM(callargs, i, defval);\n            break;\n        case (PARAMFLAG_FIN | PARAMFLAG_FOUT):\n            *pinoutmask |= (1 << i); /* mark as inout arg */\n            (*pnumretvals)++;\n            /* fall through to PARAMFLAG_FIN... */\n        case 0:\n        case PARAMFLAG_FIN:\n            /* 'in' parameter.  Copy it from inargs. */\n            ob =_get_arg(&inargs_index, name, defval, inargs, kwds);\n            if (ob == NULL)\n                goto error;\n            PyTuple_SET_ITEM(callargs, i, ob);\n            break;\n        case PARAMFLAG_FOUT:\n            /* XXX Refactor this code into a separate function. */\n            /* 'out' parameter.\n               argtypes[i] must be a POINTER to a c type.\n\n               Cannot by supplied in inargs, but a defval will be used\n               if available.  XXX Should we support getting it from kwds?\n            */\n            if (defval) {\n                /* XXX Using mutable objects as defval will\n                   make the function non-threadsafe, unless we\n                   copy the object in each invocation */\n                Py_INCREF(defval);\n                PyTuple_SET_ITEM(callargs, i, defval);\n                *poutmask |= (1 << i); /* mark as out arg */\n                (*pnumretvals)++;\n                break;\n            }\n            ob = PyTuple_GET_ITEM(argtypes, i);\n            dict = PyType_stgdict(ob);\n            if (dict == NULL) {\n                /* Cannot happen: _validate_paramflags()\n                  would not accept such an object */\n                PyErr_Format(PyExc_RuntimeError,\n                             \"NULL stgdict unexpected\");\n                goto error;\n            }\n            if (PyUnicode_Check(dict->proto)) {\n                PyErr_Format(\n                    PyExc_TypeError,\n                    \"%s 'out' parameter must be passed as default value\",\n                    ((PyTypeObject *)ob)->tp_name);\n                goto error;\n            }\n            if (PyCArrayTypeObject_Check(ob))\n                ob = PyObject_CallObject(ob, NULL);\n            else\n                /* Create an instance of the pointed-to type */\n                ob = PyObject_CallObject(dict->proto, NULL);\n            /*\n               XXX Is the following correct any longer?\n               We must not pass a byref() to the array then but\n               the array instance itself. Then, we cannot retrive\n               the result from the PyCArgObject.\n            */\n            if (ob == NULL)\n                goto error;\n            /* The .from_param call that will ocurr later will pass this\n               as a byref parameter. */\n            PyTuple_SET_ITEM(callargs, i, ob);\n            *poutmask |= (1 << i); /* mark as out arg */\n            (*pnumretvals)++;\n            break;\n        default:\n            PyErr_Format(PyExc_ValueError,\n                         \"paramflag %d not yet implemented\", flag);\n            goto error;\n            break;\n        }\n    }\n\n    /* We have counted the arguments we have consumed in 'inargs_index'.  This\n       must be the same as len(inargs) + len(kwds), otherwise we have\n       either too much or not enough arguments. */\n\n    actual_args = PyTuple_GET_SIZE(inargs) + (kwds ? PyDict_Size(kwds) : 0);\n    if (actual_args != inargs_index) {\n        /* When we have default values or named parameters, this error\n           message is misleading.  See unittests/test_paramflags.py\n         */\n        PyErr_Format(PyExc_TypeError,\n                     \"call takes exactly %d arguments (%zd given)\",\n                     inargs_index, actual_args);\n        goto error;\n    }\n\n    /* outmask is a bitmask containing indexes into callargs.  Items at\n       these indexes contain values to return.\n     */\n    return callargs;\n  error:\n    Py_DECREF(callargs);\n    return NULL;\n}\n\n/* See also:\n   http://msdn.microsoft.com/library/en-us/com/html/769127a1-1a14-4ed4-9d38-7cf3e571b661.asp\n*/\n/*\n  Build return value of a function.\n\n  Consumes the refcount on result and callargs.\n*/\nstatic PyObject *\n_build_result(PyObject *result, PyObject *callargs,\n              int outmask, int inoutmask, unsigned int numretvals)\n{\n    unsigned int i, index;\n    int bit;\n    PyObject *tup = NULL;\n\n    if (callargs == NULL)\n        return result;\n    if (result == NULL || numretvals == 0) {\n        Py_DECREF(callargs);\n        return result;\n    }\n    Py_DECREF(result);\n\n    /* tup will not be allocated if numretvals == 1 */\n    /* allocate tuple to hold the result */\n    if (numretvals > 1) {\n        tup = PyTuple_New(numretvals);\n        if (tup == NULL) {\n            Py_DECREF(callargs);\n            return NULL;\n        }\n    }\n\n    index = 0;\n    for (bit = 1, i = 0; i < 32; ++i, bit <<= 1) {\n        PyObject *v;\n        if (bit & inoutmask) {\n            v = PyTuple_GET_ITEM(callargs, i);\n            Py_INCREF(v);\n            if (numretvals == 1) {\n                Py_DECREF(callargs);\n                return v;\n            }\n            PyTuple_SET_ITEM(tup, index, v);\n            index++;\n        } else if (bit & outmask) {\n            v = PyTuple_GET_ITEM(callargs, i);\n            v = PyObject_CallMethod(v, \"__ctypes_from_outparam__\", NULL);\n            if (v == NULL || numretvals == 1) {\n                Py_DECREF(callargs);\n                return v;\n            }\n            PyTuple_SET_ITEM(tup, index, v);\n            index++;\n        }\n        if (index == numretvals)\n            break;\n    }\n\n    Py_DECREF(callargs);\n    return tup;\n}\n\nstatic PyObject *\nPyCFuncPtr_call(PyCFuncPtrObject *self, PyObject *inargs, PyObject *kwds)\n{\n    PyObject *restype;\n    PyObject *converters;\n    PyObject *checker;\n    PyObject *argtypes;\n    StgDictObject *dict = PyObject_stgdict((PyObject *)self);\n    PyObject *result;\n    PyObject *callargs;\n    PyObject *errcheck;\n#ifdef MS_WIN32\n    IUnknown *piunk = NULL;\n#endif\n    void *pProc = NULL;\n\n    int inoutmask;\n    int outmask;\n    unsigned int numretvals;\n\n    assert(dict); /* Cannot be NULL for PyCFuncPtrObject instances */\n    restype = self->restype ? self->restype : dict->restype;\n    converters = self->converters ? self->converters : dict->converters;\n    checker = self->checker ? self->checker : dict->checker;\n    argtypes = self->argtypes ? self->argtypes : dict->argtypes;\n/* later, we probably want to have an errcheck field in stgdict */\n    errcheck = self->errcheck /* ? self->errcheck : dict->errcheck */;\n\n\n    pProc = *(void **)self->b_ptr;\n#ifdef MS_WIN32\n    if (self->index) {\n        /* It's a COM method */\n        CDataObject *this;\n        this = (CDataObject *)PyTuple_GetItem(inargs, 0); /* borrowed ref! */\n        if (!this) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"native com method call without 'this' parameter\");\n            return NULL;\n        }\n        if (!CDataObject_Check(this)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"Expected a COM this pointer as first argument\");\n            return NULL;\n        }\n        /* there should be more checks? No, in Python */\n        /* First arg is an pointer to an interface instance */\n        if (!this->b_ptr || *(void **)this->b_ptr == NULL) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"NULL COM pointer access\");\n            return NULL;\n        }\n        piunk = *(IUnknown **)this->b_ptr;\n        if (NULL == piunk->lpVtbl) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"COM method call without VTable\");\n            return NULL;\n        }\n        pProc = ((void **)piunk->lpVtbl)[self->index - 0x1000];\n    }\n#endif\n    callargs = _build_callargs(self, argtypes,\n                               inargs, kwds,\n                               &outmask, &inoutmask, &numretvals);\n    if (callargs == NULL)\n        return NULL;\n\n    if (converters) {\n        int required = Py_SAFE_DOWNCAST(PyTuple_GET_SIZE(converters),\n                                        Py_ssize_t, int);\n        int actual = Py_SAFE_DOWNCAST(PyTuple_GET_SIZE(callargs),\n                                      Py_ssize_t, int);\n\n        if ((dict->flags & FUNCFLAG_CDECL) == FUNCFLAG_CDECL) {\n            /* For cdecl functions, we allow more actual arguments\n               than the length of the argtypes tuple.\n            */\n            if (required > actual) {\n                Py_DECREF(callargs);\n                PyErr_Format(PyExc_TypeError,\n              \"this function takes at least %d argument%s (%d given)\",\n                                 required,\n                                 required == 1 ? \"\" : \"s\",\n                                 actual);\n                return NULL;\n            }\n        } else if (required != actual) {\n            Py_DECREF(callargs);\n            PyErr_Format(PyExc_TypeError,\n                 \"this function takes %d argument%s (%d given)\",\n                     required,\n                     required == 1 ? \"\" : \"s\",\n                     actual);\n            return NULL;\n        }\n    }\n\n    result = _ctypes_callproc(pProc,\n                       callargs,\n#ifdef MS_WIN32\n                       piunk,\n                       self->iid,\n#endif\n                       dict->flags,\n                       converters,\n                       restype,\n                       checker);\n/* The 'errcheck' protocol */\n    if (result != NULL && errcheck) {\n        PyObject *v = PyObject_CallFunctionObjArgs(errcheck,\n                                                   result,\n                                                   self,\n                                                   callargs,\n                                                   NULL);\n        /* If the errcheck funtion failed, return NULL.\n           If the errcheck function returned callargs unchanged,\n           continue normal processing.\n           If the errcheck function returned something else,\n           use that as result.\n        */\n        if (v == NULL || v != callargs) {\n            Py_DECREF(result);\n            Py_DECREF(callargs);\n            return v;\n        }\n        Py_DECREF(v);\n    }\n\n    return _build_result(result, callargs,\n                         outmask, inoutmask, numretvals);\n}\n\nstatic int\nPyCFuncPtr_traverse(PyCFuncPtrObject *self, visitproc visit, void *arg)\n{\n    Py_VISIT(self->callable);\n    Py_VISIT(self->restype);\n    Py_VISIT(self->checker);\n    Py_VISIT(self->errcheck);\n    Py_VISIT(self->argtypes);\n    Py_VISIT(self->converters);\n    Py_VISIT(self->paramflags);\n    Py_VISIT(self->thunk);\n    return PyCData_traverse((CDataObject *)self, visit, arg);\n}\n\nstatic int\nPyCFuncPtr_clear(PyCFuncPtrObject *self)\n{\n    Py_CLEAR(self->callable);\n    Py_CLEAR(self->restype);\n    Py_CLEAR(self->checker);\n    Py_CLEAR(self->errcheck);\n    Py_CLEAR(self->argtypes);\n    Py_CLEAR(self->converters);\n    Py_CLEAR(self->paramflags);\n    Py_CLEAR(self->thunk);\n    return PyCData_clear((CDataObject *)self);\n}\n\nstatic void\nPyCFuncPtr_dealloc(PyCFuncPtrObject *self)\n{\n    PyCFuncPtr_clear(self);\n    Py_TYPE(self)->tp_free((PyObject *)self);\n}\n\nstatic PyObject *\nPyCFuncPtr_repr(PyCFuncPtrObject *self)\n{\n#ifdef MS_WIN32\n    if (self->index)\n        return PyUnicode_FromFormat(\"<COM method offset %d: %s at %p>\",\n                                   self->index - 0x1000,\n                                   Py_TYPE(self)->tp_name,\n                                   self);\n#endif\n    return PyUnicode_FromFormat(\"<%s object at %p>\",\n                               Py_TYPE(self)->tp_name,\n                               self);\n}\n\nstatic int\nPyCFuncPtr_bool(PyCFuncPtrObject *self)\n{\n    return ((*(void **)self->b_ptr != NULL)\n#ifdef MS_WIN32\n        || (self->index != 0)\n#endif\n        );\n}\n\nstatic PyNumberMethods PyCFuncPtr_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)PyCFuncPtr_bool, /* nb_bool */\n};\n\nPyTypeObject PyCFuncPtr_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.PyCFuncPtr\",\n    sizeof(PyCFuncPtrObject),                           /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    (destructor)PyCFuncPtr_dealloc,             /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    (reprfunc)PyCFuncPtr_repr,                  /* tp_repr */\n    &PyCFuncPtr_as_number,                      /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    (ternaryfunc)PyCFuncPtr_call,               /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"Function Pointer\",                         /* tp_doc */\n    (traverseproc)PyCFuncPtr_traverse,          /* tp_traverse */\n    (inquiry)PyCFuncPtr_clear,                  /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    PyCFuncPtr_getsets,                         /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    0,                                          /* tp_init */\n    0,                                          /* tp_alloc */\n    PyCFuncPtr_new,                             /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/*****************************************************************/\n/*\n  Struct_Type\n*/\n/*\n  This function is called to initialize a Structure or Union with positional\n  arguments. It calls itself recursively for all Structure or Union base\n  classes, then retrieves the _fields_ member to associate the argument\n  position with the correct field name.\n\n  Returns -1 on error, or the index of next argument on success.\n */\nstatic int\n_init_pos_args(PyObject *self, PyTypeObject *type,\n               PyObject *args, PyObject *kwds,\n               int index)\n{\n    StgDictObject *dict;\n    PyObject *fields;\n    int i;\n\n    if (PyType_stgdict((PyObject *)type->tp_base)) {\n        index = _init_pos_args(self, type->tp_base,\n                               args, kwds,\n                               index);\n        if (index == -1)\n            return -1;\n    }\n\n    dict = PyType_stgdict((PyObject *)type);\n    fields = PyDict_GetItemString((PyObject *)dict, \"_fields_\");\n    if (fields == NULL)\n        return index;\n\n    for (i = 0;\n         i < dict->length && (i+index) < PyTuple_GET_SIZE(args);\n         ++i) {\n        PyObject *pair = PySequence_GetItem(fields, i);\n        PyObject *name, *val;\n        int res;\n        if (!pair)\n            return -1;\n        name = PySequence_GetItem(pair, 0);\n        if (!name) {\n            Py_DECREF(pair);\n            return -1;\n        }\n        val = PyTuple_GET_ITEM(args, i + index);\n        if (kwds && PyDict_GetItem(kwds, name)) {\n            char *field = PyBytes_AsString(name);\n            if (field == NULL) {\n                PyErr_Clear();\n                field = \"???\";\n            }\n            PyErr_Format(PyExc_TypeError,\n                         \"duplicate values for field '%s'\",\n                         field);\n            Py_DECREF(pair);\n            Py_DECREF(name);\n            return -1;\n        }\n\n        res = PyObject_SetAttr(self, name, val);\n        Py_DECREF(pair);\n        Py_DECREF(name);\n        if (res == -1)\n            return -1;\n    }\n    return index + dict->length;\n}\n\nstatic int\nStruct_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n/* Optimization possible: Store the attribute names _fields_[x][0]\n * in C accessible fields somewhere ?\n */\n    if (!PyTuple_Check(args)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"args not a tuple?\");\n        return -1;\n    }\n    if (PyTuple_GET_SIZE(args)) {\n        int res = _init_pos_args(self, Py_TYPE(self),\n                                 args, kwds, 0);\n        if (res == -1)\n            return -1;\n        if (res < PyTuple_GET_SIZE(args)) {\n            PyErr_SetString(PyExc_TypeError,\n                            \"too many initializers\");\n            return -1;\n        }\n    }\n\n    if (kwds) {\n        PyObject *key, *value;\n        Py_ssize_t pos = 0;\n        while(PyDict_Next(kwds, &pos, &key, &value)) {\n            if (-1 == PyObject_SetAttr(self, key, value))\n                return -1;\n        }\n    }\n    return 0;\n}\n\nstatic PyTypeObject Struct_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Structure\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"Structure base class\",                     /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    Struct_init,                                /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\nstatic PyTypeObject Union_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Union\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"Union base class\",                         /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    Struct_init,                                /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n  PyCArray_Type\n*/\nstatic int\nArray_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    Py_ssize_t i;\n    Py_ssize_t n;\n\n    if (!PyTuple_Check(args)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"args not a tuple?\");\n        return -1;\n    }\n    n = PyTuple_GET_SIZE(args);\n    for (i = 0; i < n; ++i) {\n        PyObject *v;\n        v = PyTuple_GET_ITEM(args, i);\n        if (-1 == PySequence_SetItem((PyObject *)self, i, v))\n            return -1;\n    }\n    return 0;\n}\n\nstatic PyObject *\nArray_item(PyObject *_self, Py_ssize_t index)\n{\n    CDataObject *self = (CDataObject *)_self;\n    Py_ssize_t offset, size;\n    StgDictObject *stgdict;\n\n\n    if (index < 0 || index >= self->b_length) {\n        PyErr_SetString(PyExc_IndexError,\n                        \"invalid index\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for array instances */\n    /* Would it be clearer if we got the item size from\n       stgdict->proto's stgdict?\n    */\n    size = stgdict->size / stgdict->length;\n    offset = index * size;\n\n    return PyCData_get(stgdict->proto, stgdict->getfunc, (PyObject *)self,\n                     index, size, self->b_ptr + offset);\n}\n\nstatic PyObject *\nArray_subscript(PyObject *_self, PyObject *item)\n{\n    CDataObject *self = (CDataObject *)_self;\n\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n\n        if (i == -1 && PyErr_Occurred())\n            return NULL;\n        if (i < 0)\n            i += self->b_length;\n        return Array_item(_self, i);\n    }\n    else if PySlice_Check(item) {\n        StgDictObject *stgdict, *itemdict;\n        PyObject *proto;\n        PyObject *np;\n        Py_ssize_t start, stop, step, slicelen, cur, i;\n\n        if (PySlice_GetIndicesEx((PySliceObject *)item,\n                                 self->b_length, &start, &stop,\n                                 &step, &slicelen) < 0) {\n            return NULL;\n        }\n\n        stgdict = PyObject_stgdict((PyObject *)self);\n        assert(stgdict); /* Cannot be NULL for array object instances */\n        proto = stgdict->proto;\n        itemdict = PyType_stgdict(proto);\n        assert(itemdict); /* proto is the item type of the array, a\n                             ctypes type, so this cannot be NULL */\n\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n            char *ptr = (char *)self->b_ptr;\n            char *dest;\n\n            if (slicelen <= 0)\n                return PyBytes_FromStringAndSize(\"\", 0);\n            if (step == 1) {\n                return PyBytes_FromStringAndSize(ptr + start,\n                                                 slicelen);\n            }\n            dest = (char *)PyMem_Malloc(slicelen);\n\n            if (dest == NULL)\n                return PyErr_NoMemory();\n\n            for (cur = start, i = 0; i < slicelen;\n                 cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n\n            np = PyBytes_FromStringAndSize(dest, slicelen);\n            PyMem_Free(dest);\n            return np;\n        }\n#ifdef CTYPES_UNICODE\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n            wchar_t *ptr = (wchar_t *)self->b_ptr;\n            wchar_t *dest;\n\n            if (slicelen <= 0)\n                return PyUnicode_FromUnicode(NULL, 0);\n            if (step == 1) {\n                return PyUnicode_FromWideChar(ptr + start,\n                                              slicelen);\n            }\n\n            dest = (wchar_t *)PyMem_Malloc(\n                                    slicelen * sizeof(wchar_t));\n\n            for (cur = start, i = 0; i < slicelen;\n                 cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n\n            np = PyUnicode_FromWideChar(dest, slicelen);\n            PyMem_Free(dest);\n            return np;\n        }\n#endif\n\n        np = PyList_New(slicelen);\n        if (np == NULL)\n            return NULL;\n\n        for (cur = start, i = 0; i < slicelen;\n             cur += step, i++) {\n            PyObject *v = Array_item(_self, cur);\n            PyList_SET_ITEM(np, i, v);\n        }\n        return np;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"indices must be integers\");\n        return NULL;\n    }\n\n}\n\nstatic int\nArray_ass_item(PyObject *_self, Py_ssize_t index, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)_self;\n    Py_ssize_t size, offset;\n    StgDictObject *stgdict;\n    char *ptr;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Array does not support item deletion\");\n        return -1;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for array object instances */\n    if (index < 0 || index >= stgdict->length) {\n        PyErr_SetString(PyExc_IndexError,\n                        \"invalid index\");\n        return -1;\n    }\n    size = stgdict->size / stgdict->length;\n    offset = index * size;\n    ptr = self->b_ptr + offset;\n\n    return PyCData_set((PyObject *)self, stgdict->proto, stgdict->setfunc, value,\n                     index, size, ptr);\n}\n\nstatic int\nArray_ass_subscript(PyObject *_self, PyObject *item, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)_self;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Array does not support item deletion\");\n        return -1;\n    }\n\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n\n        if (i == -1 && PyErr_Occurred())\n            return -1;\n        if (i < 0)\n            i += self->b_length;\n        return Array_ass_item(_self, i, value);\n    }\n    else if (PySlice_Check(item)) {\n        Py_ssize_t start, stop, step, slicelen, otherlen, i, cur;\n\n        if (PySlice_GetIndicesEx((PySliceObject *)item,\n                                 self->b_length, &start, &stop,\n                                 &step, &slicelen) < 0) {\n            return -1;\n        }\n        if ((step < 0 && start < stop) ||\n            (step > 0 && start > stop))\n            stop = start;\n\n        otherlen = PySequence_Length(value);\n        if (otherlen != slicelen) {\n            PyErr_SetString(PyExc_ValueError,\n                \"Can only assign sequence of same size\");\n            return -1;\n        }\n        for (cur = start, i = 0; i < otherlen; cur += step, i++) {\n            PyObject *item = PySequence_GetItem(value, i);\n            int result;\n            if (item == NULL)\n                return -1;\n            result = Array_ass_item(_self, cur, item);\n            Py_DECREF(item);\n            if (result == -1)\n                return -1;\n        }\n        return 0;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"indices must be integer\");\n        return -1;\n    }\n}\n\nstatic Py_ssize_t\nArray_length(PyObject *_self)\n{\n    CDataObject *self = (CDataObject *)_self;\n    return self->b_length;\n}\n\nstatic PySequenceMethods Array_as_sequence = {\n    Array_length,                               /* sq_length; */\n    0,                                          /* sq_concat; */\n    0,                                          /* sq_repeat; */\n    Array_item,                                 /* sq_item; */\n    0,                                          /* sq_slice; */\n    Array_ass_item,                             /* sq_ass_item; */\n    0,                                          /* sq_ass_slice; */\n    0,                                          /* sq_contains; */\n\n    0,                                          /* sq_inplace_concat; */\n    0,                                          /* sq_inplace_repeat; */\n};\n\nstatic PyMappingMethods Array_as_mapping = {\n    Array_length,\n    Array_subscript,\n    Array_ass_subscript,\n};\n\nPyTypeObject PyCArray_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.Array\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    0,                                          /* tp_as_number */\n    &Array_as_sequence,                         /* tp_as_sequence */\n    &Array_as_mapping,                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    0,                                          /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Array_init,                       /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\nPyObject *\nPyCArrayType_from_ctype(PyObject *itemtype, Py_ssize_t length)\n{\n    static PyObject *cache;\n    PyObject *key;\n    PyObject *result;\n    char name[256];\n    PyObject *len;\n\n    if (cache == NULL) {\n        cache = PyDict_New();\n        if (cache == NULL)\n            return NULL;\n    }\n    len = PyLong_FromSsize_t(length);\n    if (len == NULL)\n        return NULL;\n    key = PyTuple_Pack(2, itemtype, len);\n    Py_DECREF(len);\n    if (!key)\n        return NULL;\n    result = PyDict_GetItemProxy(cache, key);\n    if (result) {\n        Py_INCREF(result);\n        Py_DECREF(key);\n        return result;\n    }\n\n    if (!PyType_Check(itemtype)) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Expected a type object\");\n        return NULL;\n    }\n#ifdef MS_WIN64\n    sprintf(name, \"%.200s_Array_%Id\",\n        ((PyTypeObject *)itemtype)->tp_name, length);\n#else\n    sprintf(name, \"%.200s_Array_%ld\",\n        ((PyTypeObject *)itemtype)->tp_name, (long)length);\n#endif\n\n    result = PyObject_CallFunction((PyObject *)&PyCArrayType_Type,\n                                   \"U(O){s:n,s:O}\",\n                                   name,\n                                   &PyCArray_Type,\n                                   \"_length_\",\n                                   length,\n                                   \"_type_\",\n                                   itemtype\n        );\n    if (result == NULL) {\n        Py_DECREF(key);\n        return NULL;\n    }\n    if (-1 == PyDict_SetItemProxy(cache, key, result)) {\n        Py_DECREF(key);\n        Py_DECREF(result);\n        return NULL;\n    }\n    Py_DECREF(key);\n    return result;\n}\n\n\n/******************************************************************/\n/*\n  Simple_Type\n*/\n\nstatic int\nSimple_set_value(CDataObject *self, PyObject *value)\n{\n    PyObject *result;\n    StgDictObject *dict = PyObject_stgdict((PyObject *)self);\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"can't delete attribute\");\n        return -1;\n    }\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    assert(dict->setfunc);\n    result = dict->setfunc(self->b_ptr, value, dict->size);\n    if (!result)\n        return -1;\n\n    /* consumes the refcount the setfunc returns */\n    return KeepRef(self, 0, result);\n}\n\nstatic int\nSimple_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    PyObject *value = NULL;\n    if (!PyArg_UnpackTuple(args, \"__init__\", 0, 1, &value))\n        return -1;\n    if (value)\n        return Simple_set_value(self, value);\n    return 0;\n}\n\nstatic PyObject *\nSimple_get_value(CDataObject *self)\n{\n    StgDictObject *dict;\n    dict = PyObject_stgdict((PyObject *)self);\n    assert(dict); /* Cannot be NULL for CDataObject instances */\n    assert(dict->getfunc);\n    return dict->getfunc(self->b_ptr, self->b_size);\n}\n\nstatic PyGetSetDef Simple_getsets[] = {\n    { \"value\", (getter)Simple_get_value, (setter)Simple_set_value,\n      \"current value\", NULL },\n    { NULL, NULL }\n};\n\nstatic PyObject *\nSimple_from_outparm(PyObject *self, PyObject *args)\n{\n    if (_ctypes_simple_instance((PyObject *)Py_TYPE(self))) {\n        Py_INCREF(self);\n        return self;\n    }\n    /* call stgdict->getfunc */\n    return Simple_get_value((CDataObject *)self);\n}\n\nstatic PyMethodDef Simple_methods[] = {\n    { \"__ctypes_from_outparam__\", Simple_from_outparm, METH_NOARGS, },\n    { NULL, NULL },\n};\n\nstatic int Simple_bool(CDataObject *self)\n{\n    return memcmp(self->b_ptr, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", self->b_size);\n}\n\nstatic PyNumberMethods Simple_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)Simple_bool, /* nb_bool */\n};\n\n/* \"%s(%s)\" % (self.__class__.__name__, self.value) */\nstatic PyObject *\nSimple_repr(CDataObject *self)\n{\n    PyObject *val, *name, *args, *result;\n    static PyObject *format;\n\n    if (Py_TYPE(self)->tp_base != &Simple_Type) {\n        return PyUnicode_FromFormat(\"<%s object at %p>\",\n                                   Py_TYPE(self)->tp_name, self);\n    }\n\n    if (format == NULL) {\n        format = PyUnicode_InternFromString(\"%s(%r)\");\n        if (format == NULL)\n            return NULL;\n    }\n\n    val = Simple_get_value(self);\n    if (val == NULL)\n        return NULL;\n\n    name = PyUnicode_FromString(Py_TYPE(self)->tp_name);\n    if (name == NULL) {\n        Py_DECREF(val);\n        return NULL;\n    }\n\n    args = PyTuple_Pack(2, name, val);\n    Py_DECREF(name);\n    Py_DECREF(val);\n    if (args == NULL)\n        return NULL;\n\n    result = PyUnicode_Format(format, args);\n    Py_DECREF(args);\n    return result;\n}\n\nstatic PyTypeObject Simple_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._SimpleCData\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    (reprfunc)&Simple_repr,                     /* tp_repr */\n    &Simple_as_number,                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    Simple_methods,                             /* tp_methods */\n    0,                                          /* tp_members */\n    Simple_getsets,                             /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Simple_init,                      /* tp_init */\n    0,                                          /* tp_alloc */\n    GenericPyCData_new,                         /* tp_new */\n    0,                                          /* tp_free */\n};\n\n/******************************************************************/\n/*\n  PyCPointer_Type\n*/\nstatic PyObject *\nPointer_item(PyObject *_self, Py_ssize_t index)\n{\n    CDataObject *self = (CDataObject *)_self;\n    Py_ssize_t size;\n    Py_ssize_t offset;\n    StgDictObject *stgdict, *itemdict;\n    PyObject *proto;\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL for pointer object instances */\n\n    proto = stgdict->proto;\n    assert(proto);\n    itemdict = PyType_stgdict(proto);\n    assert(itemdict); /* proto is the item type of the pointer, a ctypes\n                         type, so this cannot be NULL */\n\n    size = itemdict->size;\n    offset = index * itemdict->size;\n\n    return PyCData_get(proto, stgdict->getfunc, (PyObject *)self,\n                     index, size, (*(char **)self->b_ptr) + offset);\n}\n\nstatic int\nPointer_ass_item(PyObject *_self, Py_ssize_t index, PyObject *value)\n{\n    CDataObject *self = (CDataObject *)_self;\n    Py_ssize_t size;\n    Py_ssize_t offset;\n    StgDictObject *stgdict, *itemdict;\n    PyObject *proto;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer does not support item deletion\");\n        return -1;\n    }\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return -1;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL fr pointer instances */\n\n    proto = stgdict->proto;\n    assert(proto);\n\n    itemdict = PyType_stgdict(proto);\n    assert(itemdict); /* Cannot be NULL because the itemtype of a pointer\n                         is always a ctypes type */\n\n    size = itemdict->size;\n    offset = index * itemdict->size;\n\n    return PyCData_set((PyObject *)self, proto, stgdict->setfunc, value,\n                     index, size, (*(char **)self->b_ptr) + offset);\n}\n\nstatic PyObject *\nPointer_get_contents(CDataObject *self, void *closure)\n{\n    StgDictObject *stgdict;\n\n    if (*(void **)self->b_ptr == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"NULL pointer access\");\n        return NULL;\n    }\n\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL fr pointer instances */\n    return PyCData_FromBaseObj(stgdict->proto,\n                             (PyObject *)self, 0,\n                             *(void **)self->b_ptr);\n}\n\nstatic int\nPointer_set_contents(CDataObject *self, PyObject *value, void *closure)\n{\n    StgDictObject *stgdict;\n    CDataObject *dst;\n    PyObject *keep;\n\n    if (value == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer does not support item deletion\");\n        return -1;\n    }\n    stgdict = PyObject_stgdict((PyObject *)self);\n    assert(stgdict); /* Cannot be NULL fr pointer instances */\n    assert(stgdict->proto);\n    if (!CDataObject_Check(value)) {\n        int res = PyObject_IsInstance(value, stgdict->proto);\n        if (res == -1)\n            return -1;\n        if (!res) {\n            PyErr_Format(PyExc_TypeError,\n                         \"expected %s instead of %s\",\n                         ((PyTypeObject *)(stgdict->proto))->tp_name,\n                         Py_TYPE(value)->tp_name);\n            return -1;\n        }\n    }\n\n    dst = (CDataObject *)value;\n    *(void **)self->b_ptr = dst->b_ptr;\n\n    /*\n       A Pointer instance must keep a the value it points to alive.  So, a\n       pointer instance has b_length set to 2 instead of 1, and we set\n       'value' itself as the second item of the b_objects list, additionally.\n    */\n    Py_INCREF(value);\n    if (-1 == KeepRef(self, 1, value))\n        return -1;\n\n    keep = GetKeepedObjects(dst);\n    Py_INCREF(keep);\n    return KeepRef(self, 0, keep);\n}\n\nstatic PyGetSetDef Pointer_getsets[] = {\n    { \"contents\", (getter)Pointer_get_contents,\n      (setter)Pointer_set_contents,\n      \"the object this pointer points to (read-write)\", NULL },\n    { NULL, NULL }\n};\n\nstatic int\nPointer_init(CDataObject *self, PyObject *args, PyObject *kw)\n{\n    PyObject *value = NULL;\n\n    if (!PyArg_UnpackTuple(args, \"POINTER\", 0, 1, &value))\n        return -1;\n    if (value == NULL)\n        return 0;\n    return Pointer_set_contents(self, value, NULL);\n}\n\nstatic PyObject *\nPointer_new(PyTypeObject *type, PyObject *args, PyObject *kw)\n{\n    StgDictObject *dict = PyType_stgdict((PyObject *)type);\n    if (!dict || !dict->proto) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Cannot create instance: has no _type_\");\n        return NULL;\n    }\n    return GenericPyCData_new(type, args, kw);\n}\n\nstatic PyObject *\nPointer_subscript(PyObject *_self, PyObject *item)\n{\n    CDataObject *self = (CDataObject *)_self;\n    if (PyIndex_Check(item)) {\n        Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);\n        if (i == -1 && PyErr_Occurred())\n            return NULL;\n        return Pointer_item(_self, i);\n    }\n    else if (PySlice_Check(item)) {\n        PySliceObject *slice = (PySliceObject *)item;\n        Py_ssize_t start, stop, step;\n        PyObject *np;\n        StgDictObject *stgdict, *itemdict;\n        PyObject *proto;\n        Py_ssize_t i, len, cur;\n\n        /* Since pointers have no length, and we want to apply\n           different semantics to negative indices than normal\n           slicing, we have to dissect the slice object ourselves.*/\n        if (slice->step == Py_None) {\n            step = 1;\n        }\n        else {\n            step = PyNumber_AsSsize_t(slice->step,\n                                      PyExc_ValueError);\n            if (step == -1 && PyErr_Occurred())\n                return NULL;\n            if (step == 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"slice step cannot be zero\");\n                return NULL;\n            }\n        }\n        if (slice->start == Py_None) {\n            if (step < 0) {\n                PyErr_SetString(PyExc_ValueError,\n                                \"slice start is required \"\n                                \"for step < 0\");\n                return NULL;\n            }\n            start = 0;\n        }\n        else {\n            start = PyNumber_AsSsize_t(slice->start,\n                                       PyExc_ValueError);\n            if (start == -1 && PyErr_Occurred())\n                return NULL;\n        }\n        if (slice->stop == Py_None) {\n            PyErr_SetString(PyExc_ValueError,\n                            \"slice stop is required\");\n            return NULL;\n        }\n        stop = PyNumber_AsSsize_t(slice->stop,\n                                  PyExc_ValueError);\n        if (stop == -1 && PyErr_Occurred())\n            return NULL;\n        if ((step > 0 && start > stop) ||\n            (step < 0 && start < stop))\n            len = 0;\n        else if (step > 0)\n            len = (stop - start - 1) / step + 1;\n        else\n            len = (stop - start + 1) / step + 1;\n\n        stgdict = PyObject_stgdict((PyObject *)self);\n        assert(stgdict); /* Cannot be NULL for pointer instances */\n        proto = stgdict->proto;\n        assert(proto);\n        itemdict = PyType_stgdict(proto);\n        assert(itemdict);\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"c\")->getfunc) {\n            char *ptr = *(char **)self->b_ptr;\n            char *dest;\n\n            if (len <= 0)\n                return PyBytes_FromStringAndSize(\"\", 0);\n            if (step == 1) {\n                return PyBytes_FromStringAndSize(ptr + start,\n                                                 len);\n            }\n            dest = (char *)PyMem_Malloc(len);\n            if (dest == NULL)\n                return PyErr_NoMemory();\n            for (cur = start, i = 0; i < len; cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n            np = PyBytes_FromStringAndSize(dest, len);\n            PyMem_Free(dest);\n            return np;\n        }\n#ifdef CTYPES_UNICODE\n        if (itemdict->getfunc == _ctypes_get_fielddesc(\"u\")->getfunc) {\n            wchar_t *ptr = *(wchar_t **)self->b_ptr;\n            wchar_t *dest;\n\n            if (len <= 0)\n                return PyUnicode_FromUnicode(NULL, 0);\n            if (step == 1) {\n                return PyUnicode_FromWideChar(ptr + start,\n                                              len);\n            }\n            dest = (wchar_t *)PyMem_Malloc(len * sizeof(wchar_t));\n            if (dest == NULL)\n                return PyErr_NoMemory();\n            for (cur = start, i = 0; i < len; cur += step, i++) {\n                dest[i] = ptr[cur];\n            }\n            np = PyUnicode_FromWideChar(dest, len);\n            PyMem_Free(dest);\n            return np;\n        }\n#endif\n\n        np = PyList_New(len);\n        if (np == NULL)\n            return NULL;\n\n        for (cur = start, i = 0; i < len; cur += step, i++) {\n            PyObject *v = Pointer_item(_self, cur);\n            PyList_SET_ITEM(np, i, v);\n        }\n        return np;\n    }\n    else {\n        PyErr_SetString(PyExc_TypeError,\n                        \"Pointer indices must be integer\");\n        return NULL;\n    }\n}\n\nstatic PySequenceMethods Pointer_as_sequence = {\n    0,                                          /* inquiry sq_length; */\n    0,                                          /* binaryfunc sq_concat; */\n    0,                                          /* intargfunc sq_repeat; */\n    Pointer_item,                               /* intargfunc sq_item; */\n    0,                                          /* intintargfunc sq_slice; */\n    Pointer_ass_item,                           /* intobjargproc sq_ass_item; */\n    0,                                          /* intintobjargproc sq_ass_slice; */\n    0,                                          /* objobjproc sq_contains; */\n    /* Added in release 2.0 */\n    0,                                          /* binaryfunc sq_inplace_concat; */\n    0,                                          /* intargfunc sq_inplace_repeat; */\n};\n\nstatic PyMappingMethods Pointer_as_mapping = {\n    0,\n    Pointer_subscript,\n};\n\nstatic int\nPointer_bool(CDataObject *self)\n{\n    return (*(void **)self->b_ptr != NULL);\n}\n\nstatic PyNumberMethods Pointer_as_number = {\n    0, /* nb_add */\n    0, /* nb_subtract */\n    0, /* nb_multiply */\n    0, /* nb_remainder */\n    0, /* nb_divmod */\n    0, /* nb_power */\n    0, /* nb_negative */\n    0, /* nb_positive */\n    0, /* nb_absolute */\n    (inquiry)Pointer_bool, /* nb_bool */\n};\n\nPyTypeObject PyCPointer_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes._Pointer\",\n    sizeof(CDataObject),                        /* tp_basicsize */\n    0,                                          /* tp_itemsize */\n    0,                                          /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    0,                                          /* tp_repr */\n    &Pointer_as_number,                         /* tp_as_number */\n    &Pointer_as_sequence,                       /* tp_as_sequence */\n    &Pointer_as_mapping,                        /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    &PyCData_as_buffer,                         /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    \"XXX to be provided\",                       /* tp_doc */\n    (traverseproc)PyCData_traverse,             /* tp_traverse */\n    (inquiry)PyCData_clear,                     /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    0,                                          /* tp_members */\n    Pointer_getsets,                            /* tp_getset */\n    0,                                          /* tp_base */\n    0,                                          /* tp_dict */\n    0,                                          /* tp_descr_get */\n    0,                                          /* tp_descr_set */\n    0,                                          /* tp_dictoffset */\n    (initproc)Pointer_init,                     /* tp_init */\n    0,                                          /* tp_alloc */\n    Pointer_new,                                /* tp_new */\n    0,                                          /* tp_free */\n};\n\n\n/******************************************************************/\n/*\n *  Module initialization.\n */\n\nstatic const char module_docs[] =\n\"Create and manipulate C compatible data types in Python.\";\n\n#ifdef MS_WIN32\n\nstatic char comerror_doc[] = \"Raised when a COM method call failed.\";\n\nint\ncomerror_init(PyObject *self, PyObject *args, PyObject *kwds)\n{\n    PyObject *hresult, *text, *details;\n    PyBaseExceptionObject *bself;\n    PyObject *a;\n    int status;\n\n    if (!_PyArg_NoKeywords(Py_TYPE(self)->tp_name, kwds))\n    return -1;\n\n    if (!PyArg_ParseTuple(args, \"OOO:COMError\", &hresult, &text, &details))\n        return -1;\n\n    a = PySequence_GetSlice(args, 1, PySequence_Size(args));\n    if (!a)\n    return -1;\n    status = PyObject_SetAttrString(self, \"args\", a);\n    Py_DECREF(a);\n    if (status < 0)\n    return -1;\n\n    if (PyObject_SetAttrString(self, \"hresult\", hresult) < 0)\n        return -1;\n\n    if (PyObject_SetAttrString(self, \"text\", text) < 0)\n        return -1;\n\n    if (PyObject_SetAttrString(self, \"details\", details) < 0)\n        return -1;\n\n    bself = (PyBaseExceptionObject *)self;\n    Py_DECREF(bself->args);\n    bself->args = args;\n    Py_INCREF(bself->args);\n\n    return 0;\n}\n\nstatic PyTypeObject PyComError_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"_ctypes.COMError\",         /* tp_name */\n    sizeof(PyBaseExceptionObject), /* tp_basicsize */\n    0,                          /* tp_itemsize */\n    0,                          /* tp_dealloc */\n    0,                          /* tp_print */\n    0,                          /* tp_getattr */\n    0,                          /* tp_setattr */\n    0,                          /* tp_reserved */\n    0,                          /* tp_repr */\n    0,                          /* tp_as_number */\n    0,                          /* tp_as_sequence */\n    0,                          /* tp_as_mapping */\n    0,                          /* tp_hash */\n    0,                          /* tp_call */\n    0,                          /* tp_str */\n    0,                          /* tp_getattro */\n    0,                          /* tp_setattro */\n    0,                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */\n    PyDoc_STR(comerror_doc),    /* tp_doc */\n    0,                          /* tp_traverse */\n    0,                          /* tp_clear */\n    0,                          /* tp_richcompare */\n    0,                          /* tp_weaklistoffset */\n    0,                          /* tp_iter */\n    0,                          /* tp_iternext */\n    0,                          /* tp_methods */\n    0,                          /* tp_members */\n    0,                          /* tp_getset */\n    0,                          /* tp_base */\n    0,                          /* tp_dict */\n    0,                          /* tp_descr_get */\n    0,                          /* tp_descr_set */\n    0,                          /* tp_dictoffset */\n    (initproc)comerror_init,    /* tp_init */\n    0,                          /* tp_alloc */\n    0,                          /* tp_new */\n};\n\n\nstatic int\ncreate_comerror(void)\n{\n    PyComError_Type.tp_base = (PyTypeObject*)PyExc_Exception;\n    if (PyType_Ready(&PyComError_Type) < 0)\n        return -1;\n    Py_INCREF(&PyComError_Type);\n    ComError = (PyObject*)&PyComError_Type;\n    return 0;\n}\n\n#endif\n\nstatic PyObject *\nstring_at(const char *ptr, int size)\n{\n    if (size == -1)\n        return PyBytes_FromStringAndSize(ptr, strlen(ptr));\n    return PyBytes_FromStringAndSize(ptr, size);\n}\n\nstatic int\ncast_check_pointertype(PyObject *arg)\n{\n    StgDictObject *dict;\n\n    if (PyCPointerTypeObject_Check(arg))\n        return 1;\n    if (PyCFuncPtrTypeObject_Check(arg))\n        return 1;\n    dict = PyType_stgdict(arg);\n    if (dict) {\n        if (PyUnicode_Check(dict->proto)\n            && (strchr(\"sPzUZXO\", _PyUnicode_AsString(dict->proto)[0]))) {\n            /* simple pointer types, c_void_p, c_wchar_p, BSTR, ... */\n            return 1;\n        }\n    }\n    PyErr_Format(PyExc_TypeError,\n                 \"cast() argument 2 must be a pointer type, not %s\",\n                 PyType_Check(arg)\n                 ? ((PyTypeObject *)arg)->tp_name\n                 : Py_TYPE(arg)->tp_name);\n    return 0;\n}\n\nstatic PyObject *\ncast(void *ptr, PyObject *src, PyObject *ctype)\n{\n    CDataObject *result;\n    if (0 == cast_check_pointertype(ctype))\n        return NULL;\n    result = (CDataObject *)PyObject_CallFunctionObjArgs(ctype, NULL);\n    if (result == NULL)\n        return NULL;\n\n    /*\n      The casted objects '_objects' member:\n\n      It must certainly contain the source objects one.\n      It must contain the source object itself.\n     */\n    if (CDataObject_Check(src)) {\n        CDataObject *obj = (CDataObject *)src;\n        /* PyCData_GetContainer will initialize src.b_objects, we need\n           this so it can be shared */\n        PyCData_GetContainer(obj);\n        /* But we need a dictionary! */\n        if (obj->b_objects == Py_None) {\n            Py_DECREF(Py_None);\n            obj->b_objects = PyDict_New();\n            if (obj->b_objects == NULL)\n                goto failed;\n        }\n        Py_XINCREF(obj->b_objects);\n        result->b_objects = obj->b_objects;\n        if (result->b_objects && PyDict_CheckExact(result->b_objects)) {\n            PyObject *index;\n            int rc;\n            index = PyLong_FromVoidPtr((void *)src);\n            if (index == NULL)\n                goto failed;\n            rc = PyDict_SetItem(result->b_objects, index, src);\n            Py_DECREF(index);\n            if (rc == -1)\n                goto failed;\n        }\n    }\n    /* Should we assert that result is a pointer type? */\n    memcpy(result->b_ptr, &ptr, sizeof(void *));\n    return (PyObject *)result;\n\n  failed:\n    Py_DECREF(result);\n    return NULL;\n}\n\n#ifdef CTYPES_UNICODE\nstatic PyObject *\nwstring_at(const wchar_t *ptr, int size)\n{\n    Py_ssize_t ssize = size;\n    if (ssize == -1)\n        ssize = wcslen(ptr);\n    return PyUnicode_FromWideChar(ptr, ssize);\n}\n#endif\n\n\nstatic struct PyModuleDef _ctypesmodule = {\n    PyModuleDef_HEAD_INIT,\n    \"_ctypes\",\n    module_docs,\n    -1,\n    _ctypes_module_methods,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n};\n\nPyMODINIT_FUNC\nPyInit__ctypes(void)\n{\n    PyObject *m;\n\n/* Note:\n   ob_type is the metatype (the 'type'), defaults to PyType_Type,\n   tp_base is the base type, defaults to 'object' aka PyBaseObject_Type.\n*/\n#ifdef WITH_THREAD\n    PyEval_InitThreads();\n#endif\n    m = PyModule_Create(&_ctypesmodule);\n    if (!m)\n        return NULL;\n\n    _ctypes_ptrtype_cache = PyDict_New();\n    if (_ctypes_ptrtype_cache == NULL)\n        return NULL;\n\n    PyModule_AddObject(m, \"_pointer_type_cache\", (PyObject *)_ctypes_ptrtype_cache);\n\n    _unpickle = PyObject_GetAttrString(m, \"_unpickle\");\n    if (_unpickle == NULL)\n        return NULL;\n\n    if (PyType_Ready(&PyCArg_Type) < 0)\n        return NULL;\n\n    if (PyType_Ready(&PyCThunk_Type) < 0)\n        return NULL;\n\n    /* StgDict is derived from PyDict_Type */\n    PyCStgDict_Type.tp_base = &PyDict_Type;\n    if (PyType_Ready(&PyCStgDict_Type) < 0)\n        return NULL;\n\n    /*************************************************\n     *\n     * Metaclasses\n     */\n\n    PyCStructType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCStructType_Type) < 0)\n        return NULL;\n\n    UnionType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&UnionType_Type) < 0)\n        return NULL;\n\n    PyCPointerType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCPointerType_Type) < 0)\n        return NULL;\n\n    PyCArrayType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCArrayType_Type) < 0)\n        return NULL;\n\n    PyCSimpleType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCSimpleType_Type) < 0)\n        return NULL;\n\n    PyCFuncPtrType_Type.tp_base = &PyType_Type;\n    if (PyType_Ready(&PyCFuncPtrType_Type) < 0)\n        return NULL;\n\n    /*************************************************\n     *\n     * Classes using a custom metaclass\n     */\n\n    if (PyType_Ready(&PyCData_Type) < 0)\n        return NULL;\n\n    Py_TYPE(&Struct_Type) = &PyCStructType_Type;\n    Struct_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&Struct_Type) < 0)\n        return NULL;\n    Py_INCREF(&Struct_Type);\n    PyModule_AddObject(m, \"Structure\", (PyObject *)&Struct_Type);\n\n    Py_TYPE(&Union_Type) = &UnionType_Type;\n    Union_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&Union_Type) < 0)\n        return NULL;\n    Py_INCREF(&Union_Type);\n    PyModule_AddObject(m, \"Union\", (PyObject *)&Union_Type);\n\n    Py_TYPE(&PyCPointer_Type) = &PyCPointerType_Type;\n    PyCPointer_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&PyCPointer_Type) < 0)\n        return NULL;\n    Py_INCREF(&PyCPointer_Type);\n    PyModule_AddObject(m, \"_Pointer\", (PyObject *)&PyCPointer_Type);\n\n    Py_TYPE(&PyCArray_Type) = &PyCArrayType_Type;\n    PyCArray_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&PyCArray_Type) < 0)\n        return NULL;\n    Py_INCREF(&PyCArray_Type);\n    PyModule_AddObject(m, \"Array\", (PyObject *)&PyCArray_Type);\n\n    Py_TYPE(&Simple_Type) = &PyCSimpleType_Type;\n    Simple_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&Simple_Type) < 0)\n        return NULL;\n    Py_INCREF(&Simple_Type);\n    PyModule_AddObject(m, \"_SimpleCData\", (PyObject *)&Simple_Type);\n\n    Py_TYPE(&PyCFuncPtr_Type) = &PyCFuncPtrType_Type;\n    PyCFuncPtr_Type.tp_base = &PyCData_Type;\n    if (PyType_Ready(&PyCFuncPtr_Type) < 0)\n        return NULL;\n    Py_INCREF(&PyCFuncPtr_Type);\n    PyModule_AddObject(m, \"CFuncPtr\", (PyObject *)&PyCFuncPtr_Type);\n\n    /*************************************************\n     *\n     * Simple classes\n     */\n\n    /* PyCField_Type is derived from PyBaseObject_Type */\n    if (PyType_Ready(&PyCField_Type) < 0)\n        return NULL;\n\n    /*************************************************\n     *\n     * Other stuff\n     */\n\n    DictRemover_Type.tp_new = PyType_GenericNew;\n    if (PyType_Ready(&DictRemover_Type) < 0)\n        return NULL;\n\n#ifdef MS_WIN32\n    if (create_comerror() < 0)\n        return NULL;\n    PyModule_AddObject(m, \"COMError\", ComError);\n\n    PyModule_AddObject(m, \"FUNCFLAG_HRESULT\", PyLong_FromLong(FUNCFLAG_HRESULT));\n    PyModule_AddObject(m, \"FUNCFLAG_STDCALL\", PyLong_FromLong(FUNCFLAG_STDCALL));\n#endif\n    PyModule_AddObject(m, \"FUNCFLAG_CDECL\", PyLong_FromLong(FUNCFLAG_CDECL));\n    PyModule_AddObject(m, \"FUNCFLAG_USE_ERRNO\", PyLong_FromLong(FUNCFLAG_USE_ERRNO));\n    PyModule_AddObject(m, \"FUNCFLAG_USE_LASTERROR\", PyLong_FromLong(FUNCFLAG_USE_LASTERROR));\n    PyModule_AddObject(m, \"FUNCFLAG_PYTHONAPI\", PyLong_FromLong(FUNCFLAG_PYTHONAPI));\n    PyModule_AddStringConstant(m, \"__version__\", \"1.1.0\");\n\n    PyModule_AddObject(m, \"_memmove_addr\", PyLong_FromVoidPtr(memmove));\n    PyModule_AddObject(m, \"_memset_addr\", PyLong_FromVoidPtr(memset));\n    PyModule_AddObject(m, \"_string_at_addr\", PyLong_FromVoidPtr(string_at));\n    PyModule_AddObject(m, \"_cast_addr\", PyLong_FromVoidPtr(cast));\n#ifdef CTYPES_UNICODE\n    PyModule_AddObject(m, \"_wstring_at_addr\", PyLong_FromVoidPtr(wstring_at));\n#endif\n\n/* If RTLD_LOCAL is not defined (Windows!), set it to zero. */\n#ifndef RTLD_LOCAL\n#define RTLD_LOCAL 0\n#endif\n\n/* If RTLD_GLOBAL is not defined (cygwin), set it to the same value as\n   RTLD_LOCAL.\n*/\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL RTLD_LOCAL\n#endif\n\n    PyModule_AddObject(m, \"RTLD_LOCAL\", PyLong_FromLong(RTLD_LOCAL));\n    PyModule_AddObject(m, \"RTLD_GLOBAL\", PyLong_FromLong(RTLD_GLOBAL));\n\n    PyExc_ArgError = PyErr_NewException(\"ctypes.ArgumentError\", NULL, NULL);\n    if (PyExc_ArgError) {\n        Py_INCREF(PyExc_ArgError);\n        PyModule_AddObject(m, \"ArgumentError\", PyExc_ArgError);\n    }\n    return m;\n}\n\n/*\n Local Variables:\n compile-command: \"cd .. && python setup.py -q build -g && python setup.py -q build install --home ~\"\n End:\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_ctypes/callproc.c": "/*\n * History: First version dated from 3/97, derived from my SCMLIB version\n * for win16.\n */\n/*\n * Related Work:\n *      - calldll       http://www.nightmare.com/software.html\n *      - libffi        http://sourceware.cygnus.com/libffi/\n *      - ffcall        http://clisp.cons.org/~haible/packages-ffcall.html\n *   and, of course, Don Beaudry's MESS package, but this is more ctypes\n *   related.\n */\n\n\n/*\n  How are functions called, and how are parameters converted to C ?\n\n  1. _ctypes.c::PyCFuncPtr_call receives an argument tuple 'inargs' and a\n  keyword dictionary 'kwds'.\n\n  2. After several checks, _build_callargs() is called which returns another\n  tuple 'callargs'.  This may be the same tuple as 'inargs', a slice of\n  'inargs', or a completely fresh tuple, depending on several things (is is a\n  COM method, are 'paramflags' available).\n\n  3. _build_callargs also calculates bitarrays containing indexes into\n  the callargs tuple, specifying how to build the return value(s) of\n  the function.\n\n  4. _ctypes_callproc is then called with the 'callargs' tuple.  _ctypes_callproc first\n  allocates two arrays.  The first is an array of 'struct argument' items, the\n  second array has 'void *' entries.\n\n  5. If 'converters' are present (converters is a sequence of argtypes'\n  from_param methods), for each item in 'callargs' converter is called and the\n  result passed to ConvParam.  If 'converters' are not present, each argument\n  is directly passed to ConvParm.\n\n  6. For each arg, ConvParam stores the contained C data (or a pointer to it,\n  for structures) into the 'struct argument' array.\n\n  7. Finally, a loop fills the 'void *' array so that each item points to the\n  data contained in or pointed to by the 'struct argument' array.\n\n  8. The 'void *' argument array is what _call_function_pointer\n  expects. _call_function_pointer then has very little to do - only some\n  libffi specific stuff, then it calls ffi_call.\n\n  So, there are 4 data structures holding processed arguments:\n  - the inargs tuple (in PyCFuncPtr_call)\n  - the callargs tuple (in PyCFuncPtr_call)\n  - the 'struct arguments' array\n  - the 'void *' array\n\n */\n\n#include \"Python.h\"\n#include \"structmember.h\"\n\n#ifdef MS_WIN32\n#include <windows.h>\n#include <tchar.h>\n#else\n#include \"ctypes_dlfcn.h\"\n#endif\n\n#ifdef MS_WIN32\n#include <malloc.h>\n#endif\n\n#include <ffi.h>\n#include \"ctypes.h\"\n\n#if defined(_DEBUG) || defined(__MINGW32__)\n/* Don't use structured exception handling on Windows if this is defined.\n   MingW, AFAIK, doesn't support it.\n*/\n#define DONT_USE_SEH\n#endif\n\n#define CTYPES_CAPSULE_NAME_PYMEM \"_ctypes pymem\"\n\nstatic void pymem_destructor(PyObject *ptr)\n{\n    void *p = PyCapsule_GetPointer(ptr, CTYPES_CAPSULE_NAME_PYMEM);\n    if (p) {\n        PyMem_Free(p);\n    }\n}\n\n/*\n  ctypes maintains thread-local storage that has space for two error numbers:\n  private copies of the system 'errno' value and, on Windows, the system error code\n  accessed by the GetLastError() and SetLastError() api functions.\n\n  Foreign functions created with CDLL(..., use_errno=True), when called, swap\n  the system 'errno' value with the private copy just before the actual\n  function call, and swapped again immediately afterwards.  The 'use_errno'\n  parameter defaults to False, in this case 'ctypes_errno' is not touched.\n\n  On Windows, foreign functions created with CDLL(..., use_last_error=True) or\n  WinDLL(..., use_last_error=True) swap the system LastError value with the\n  ctypes private copy.\n\n  The values are also swapped immeditately before and after ctypes callback\n  functions are called, if the callbacks are constructed using the new\n  optional use_errno parameter set to True: CFUNCTYPE(..., use_errno=TRUE) or\n  WINFUNCTYPE(..., use_errno=True).\n\n  New ctypes functions are provided to access the ctypes private copies from\n  Python:\n\n  - ctypes.set_errno(value) and ctypes.set_last_error(value) store 'value' in\n    the private copy and returns the previous value.\n\n  - ctypes.get_errno() and ctypes.get_last_error() returns the current ctypes\n    private copies value.\n*/\n\n/*\n  This function creates and returns a thread-local Python object that has\n  space to store two integer error numbers; once created the Python object is\n  kept alive in the thread state dictionary as long as the thread itself.\n*/\nPyObject *\n_ctypes_get_errobj(int **pspace)\n{\n    PyObject *dict = PyThreadState_GetDict();\n    PyObject *errobj;\n    static PyObject *error_object_name;\n    if (dict == 0) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"cannot get thread state\");\n        return NULL;\n    }\n    if (error_object_name == NULL) {\n        error_object_name = PyUnicode_InternFromString(\"ctypes.error_object\");\n        if (error_object_name == NULL)\n            return NULL;\n    }\n    errobj = PyDict_GetItem(dict, error_object_name);\n    if (errobj) {\n        if (!PyCapsule_IsValid(errobj, CTYPES_CAPSULE_NAME_PYMEM)) {\n            PyErr_SetString(PyExc_RuntimeError,\n                \"ctypes.error_object is an invalid capsule\");\n            return NULL;\n        }\n        Py_INCREF(errobj);\n    }\n    else {\n        void *space = PyMem_Malloc(sizeof(int) * 2);\n        if (space == NULL)\n            return NULL;\n        memset(space, 0, sizeof(int) * 2);\n        errobj = PyCapsule_New(space, CTYPES_CAPSULE_NAME_PYMEM, pymem_destructor);\n        if (errobj == NULL)\n            return NULL;\n        if (-1 == PyDict_SetItem(dict, error_object_name,\n                                 errobj)) {\n            Py_DECREF(errobj);\n            return NULL;\n        }\n    }\n    *pspace = (int *)PyCapsule_GetPointer(errobj, CTYPES_CAPSULE_NAME_PYMEM);\n    return errobj;\n}\n\nstatic PyObject *\nget_error_internal(PyObject *self, PyObject *args, int index)\n{\n    int *space;\n    PyObject *errobj = _ctypes_get_errobj(&space);\n    PyObject *result;\n\n    if (errobj == NULL)\n        return NULL;\n    result = PyLong_FromLong(space[index]);\n    Py_DECREF(errobj);\n    return result;\n}\n\nstatic PyObject *\nset_error_internal(PyObject *self, PyObject *args, int index)\n{\n    int new_errno, old_errno;\n    PyObject *errobj;\n    int *space;\n\n    if (!PyArg_ParseTuple(args, \"i\", &new_errno))\n        return NULL;\n    errobj = _ctypes_get_errobj(&space);\n    if (errobj == NULL)\n        return NULL;\n    old_errno = space[index];\n    space[index] = new_errno;\n    Py_DECREF(errobj);\n    return PyLong_FromLong(old_errno);\n}\n\nstatic PyObject *\nget_errno(PyObject *self, PyObject *args)\n{\n    return get_error_internal(self, args, 0);\n}\n\nstatic PyObject *\nset_errno(PyObject *self, PyObject *args)\n{\n    return set_error_internal(self, args, 0);\n}\n\n#ifdef MS_WIN32\n\nstatic PyObject *\nget_last_error(PyObject *self, PyObject *args)\n{\n    return get_error_internal(self, args, 1);\n}\n\nstatic PyObject *\nset_last_error(PyObject *self, PyObject *args)\n{\n    return set_error_internal(self, args, 1);\n}\n\nPyObject *ComError;\n\nstatic WCHAR *FormatError(DWORD code)\n{\n    WCHAR *lpMsgBuf;\n    DWORD n;\n    n = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n                       NULL,\n                       code,\n                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), /* Default language */\n               (LPWSTR) &lpMsgBuf,\n               0,\n               NULL);\n    if (n) {\n        while (iswspace(lpMsgBuf[n-1]))\n            --n;\n        lpMsgBuf[n] = L'\\0'; /* rstrip() */\n    }\n    return lpMsgBuf;\n}\n\n#ifndef DONT_USE_SEH\nstatic void SetException(DWORD code, EXCEPTION_RECORD *pr)\n{\n    /* The 'code' is a normal win32 error code so it could be handled by\n    PyErr_SetFromWindowsErr(). However, for some errors, we have additional\n    information not included in the error code. We handle those here and\n    delegate all others to the generic function. */\n    switch (code) {\n    case EXCEPTION_ACCESS_VIOLATION:\n        /* The thread attempted to read from or write\n           to a virtual address for which it does not\n           have the appropriate access. */\n        if (pr->ExceptionInformation[0] == 0)\n            PyErr_Format(PyExc_WindowsError,\n                         \"exception: access violation reading %p\",\n                         pr->ExceptionInformation[1]);\n        else\n            PyErr_Format(PyExc_WindowsError,\n                         \"exception: access violation writing %p\",\n                         pr->ExceptionInformation[1]);\n        break;\n\n    case EXCEPTION_BREAKPOINT:\n        /* A breakpoint was encountered. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: breakpoint encountered\");\n        break;\n\n    case EXCEPTION_DATATYPE_MISALIGNMENT:\n        /* The thread attempted to read or write data that is\n           misaligned on hardware that does not provide\n           alignment. For example, 16-bit values must be\n           aligned on 2-byte boundaries, 32-bit values on\n           4-byte boundaries, and so on. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: datatype misalignment\");\n        break;\n\n    case EXCEPTION_SINGLE_STEP:\n        /* A trace trap or other single-instruction mechanism\n           signaled that one instruction has been executed. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: single step\");\n        break;\n\n    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n        /* The thread attempted to access an array element\n           that is out of bounds, and the underlying hardware\n           supports bounds checking. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: array bounds exceeded\");\n        break;\n\n    case EXCEPTION_FLT_DENORMAL_OPERAND:\n        /* One of the operands in a floating-point operation\n           is denormal. A denormal value is one that is too\n           small to represent as a standard floating-point\n           value. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: floating-point operand denormal\");\n        break;\n\n    case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n        /* The thread attempted to divide a floating-point\n           value by a floating-point divisor of zero. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: float divide by zero\");\n        break;\n\n    case EXCEPTION_FLT_INEXACT_RESULT:\n        /* The result of a floating-point operation cannot be\n           represented exactly as a decimal fraction. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: float inexact\");\n        break;\n\n    case EXCEPTION_FLT_INVALID_OPERATION:\n        /* This exception represents any floating-point\n           exception not included in this list. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: float invalid operation\");\n        break;\n\n    case EXCEPTION_FLT_OVERFLOW:\n        /* The exponent of a floating-point operation is\n           greater than the magnitude allowed by the\n           corresponding type. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: float overflow\");\n        break;\n\n    case EXCEPTION_FLT_STACK_CHECK:\n        /* The stack overflowed or underflowed as the result\n           of a floating-point operation. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: stack over/underflow\");\n        break;\n\n    case EXCEPTION_STACK_OVERFLOW:\n        /* The stack overflowed or underflowed as the result\n           of a floating-point operation. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: stack overflow\");\n        break;\n\n    case EXCEPTION_FLT_UNDERFLOW:\n        /* The exponent of a floating-point operation is less\n           than the magnitude allowed by the corresponding\n           type. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: float underflow\");\n        break;\n\n    case EXCEPTION_INT_DIVIDE_BY_ZERO:\n        /* The thread attempted to divide an integer value by\n           an integer divisor of zero. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: integer divide by zero\");\n        break;\n\n    case EXCEPTION_INT_OVERFLOW:\n        /* The result of an integer operation caused a carry\n           out of the most significant bit of the result. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: integer overflow\");\n        break;\n\n    case EXCEPTION_PRIV_INSTRUCTION:\n        /* The thread attempted to execute an instruction\n           whose operation is not allowed in the current\n           machine mode. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: priviledged instruction\");\n        break;\n\n    case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n        /* The thread attempted to continue execution after a\n           noncontinuable exception occurred. */\n        PyErr_SetString(PyExc_WindowsError,\n                        \"exception: nocontinuable\");\n        break;\n\n    default:\n        PyErr_SetFromWindowsErr(code);\n        break;\n    }\n}\n\nstatic DWORD HandleException(EXCEPTION_POINTERS *ptrs,\n                             DWORD *pdw, EXCEPTION_RECORD *record)\n{\n    *pdw = ptrs->ExceptionRecord->ExceptionCode;\n    *record = *ptrs->ExceptionRecord;\n    return EXCEPTION_EXECUTE_HANDLER;\n}\n#endif\n\nstatic PyObject *\ncheck_hresult(PyObject *self, PyObject *args)\n{\n    HRESULT hr;\n    if (!PyArg_ParseTuple(args, \"i\", &hr))\n        return NULL;\n    if (FAILED(hr))\n        return PyErr_SetFromWindowsErr(hr);\n    return PyLong_FromLong(hr);\n}\n\n#endif\n\n/**************************************************************/\n\nPyCArgObject *\nPyCArgObject_new(void)\n{\n    PyCArgObject *p;\n    p = PyObject_New(PyCArgObject, &PyCArg_Type);\n    if (p == NULL)\n        return NULL;\n    p->pffi_type = NULL;\n    p->tag = '\\0';\n    p->obj = NULL;\n    memset(&p->value, 0, sizeof(p->value));\n    return p;\n}\n\nstatic void\nPyCArg_dealloc(PyCArgObject *self)\n{\n    Py_XDECREF(self->obj);\n    PyObject_Del(self);\n}\n\nstatic PyObject *\nPyCArg_repr(PyCArgObject *self)\n{\n    char buffer[256];\n    switch(self->tag) {\n    case 'b':\n    case 'B':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.b);\n        break;\n    case 'h':\n    case 'H':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.h);\n        break;\n    case 'i':\n    case 'I':\n        sprintf(buffer, \"<cparam '%c' (%d)>\",\n            self->tag, self->value.i);\n        break;\n    case 'l':\n    case 'L':\n        sprintf(buffer, \"<cparam '%c' (%ld)>\",\n            self->tag, self->value.l);\n        break;\n\n#ifdef HAVE_LONG_LONG\n    case 'q':\n    case 'Q':\n        sprintf(buffer,\n#ifdef MS_WIN32\n            \"<cparam '%c' (%I64d)>\",\n#else\n            \"<cparam '%c' (%qd)>\",\n#endif\n            self->tag, self->value.q);\n        break;\n#endif\n    case 'd':\n        sprintf(buffer, \"<cparam '%c' (%f)>\",\n            self->tag, self->value.d);\n        break;\n    case 'f':\n        sprintf(buffer, \"<cparam '%c' (%f)>\",\n            self->tag, self->value.f);\n        break;\n\n    case 'c':\n        sprintf(buffer, \"<cparam '%c' (%c)>\",\n            self->tag, self->value.c);\n        break;\n\n/* Hm, are these 'z' and 'Z' codes useful at all?\n   Shouldn't they be replaced by the functionality of c_string\n   and c_wstring ?\n*/\n    case 'z':\n    case 'Z':\n    case 'P':\n        sprintf(buffer, \"<cparam '%c' (%p)>\",\n            self->tag, self->value.p);\n        break;\n\n    default:\n        sprintf(buffer, \"<cparam '%c' at %p>\",\n            self->tag, self);\n        break;\n    }\n    return PyUnicode_FromString(buffer);\n}\n\nstatic PyMemberDef PyCArgType_members[] = {\n    { \"_obj\", T_OBJECT,\n      offsetof(PyCArgObject, obj), READONLY,\n      \"the wrapped object\" },\n    { NULL },\n};\n\nPyTypeObject PyCArg_Type = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"CArgObject\",\n    sizeof(PyCArgObject),\n    0,\n    (destructor)PyCArg_dealloc,                 /* tp_dealloc */\n    0,                                          /* tp_print */\n    0,                                          /* tp_getattr */\n    0,                                          /* tp_setattr */\n    0,                                          /* tp_reserved */\n    (reprfunc)PyCArg_repr,                      /* tp_repr */\n    0,                                          /* tp_as_number */\n    0,                                          /* tp_as_sequence */\n    0,                                          /* tp_as_mapping */\n    0,                                          /* tp_hash */\n    0,                                          /* tp_call */\n    0,                                          /* tp_str */\n    0,                                          /* tp_getattro */\n    0,                                          /* tp_setattro */\n    0,                                          /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,                         /* tp_flags */\n    0,                                          /* tp_doc */\n    0,                                          /* tp_traverse */\n    0,                                          /* tp_clear */\n    0,                                          /* tp_richcompare */\n    0,                                          /* tp_weaklistoffset */\n    0,                                          /* tp_iter */\n    0,                                          /* tp_iternext */\n    0,                                          /* tp_methods */\n    PyCArgType_members,                         /* tp_members */\n};\n\n/****************************************************************/\n/*\n * Convert a PyObject * into a parameter suitable to pass to an\n * C function call.\n *\n * 1. Python integers are converted to C int and passed by value.\n *    Py_None is converted to a C NULL pointer.\n *\n * 2. 3-tuples are expected to have a format character in the first\n *    item, which must be 'i', 'f', 'd', 'q', or 'P'.\n *    The second item will have to be an integer, float, double, long long\n *    or integer (denoting an address void *), will be converted to the\n *    corresponding C data type and passed by value.\n *\n * 3. Other Python objects are tested for an '_as_parameter_' attribute.\n *    The value of this attribute must be an integer which will be passed\n *    by value, or a 2-tuple or 3-tuple which will be used according\n *    to point 2 above. The third item (if any), is ignored. It is normally\n *    used to keep the object alive where this parameter refers to.\n *    XXX This convention is dangerous - you can construct arbitrary tuples\n *    in Python and pass them. Would it be safer to use a custom container\n *    datatype instead of a tuple?\n *\n * 4. Other Python objects cannot be passed as parameters - an exception is raised.\n *\n * 5. ConvParam will store the converted result in a struct containing format\n *    and value.\n */\n\nunion result {\n    char c;\n    char b;\n    short h;\n    int i;\n    long l;\n#ifdef HAVE_LONG_LONG\n    PY_LONG_LONG q;\n#endif\n    long double D;\n    double d;\n    float f;\n    void *p;\n};\n\nstruct argument {\n    ffi_type *ffi_type;\n    PyObject *keep;\n    union result value;\n};\n\n/*\n * Convert a single Python object into a PyCArgObject and return it.\n */\nstatic int ConvParam(PyObject *obj, Py_ssize_t index, struct argument *pa)\n{\n    StgDictObject *dict;\n    pa->keep = NULL; /* so we cannot forget it later */\n\n    dict = PyObject_stgdict(obj);\n    if (dict) {\n        PyCArgObject *carg;\n        assert(dict->paramfunc);\n        /* If it has an stgdict, it is a CDataObject */\n        carg = dict->paramfunc((CDataObject *)obj);\n        pa->ffi_type = carg->pffi_type;\n        memcpy(&pa->value, &carg->value, sizeof(pa->value));\n        pa->keep = (PyObject *)carg;\n        return 0;\n    }\n\n    if (PyCArg_CheckExact(obj)) {\n        PyCArgObject *carg = (PyCArgObject *)obj;\n        pa->ffi_type = carg->pffi_type;\n        Py_INCREF(obj);\n        pa->keep = obj;\n        memcpy(&pa->value, &carg->value, sizeof(pa->value));\n        return 0;\n    }\n\n    /* check for None, integer, string or unicode and use directly if successful */\n    if (obj == Py_None) {\n        pa->ffi_type = &ffi_type_pointer;\n        pa->value.p = NULL;\n        return 0;\n    }\n\n    if (PyLong_Check(obj)) {\n        pa->ffi_type = &ffi_type_sint;\n        pa->value.i = (long)PyLong_AsUnsignedLong(obj);\n        if (pa->value.i == -1 && PyErr_Occurred()) {\n            PyErr_Clear();\n            pa->value.i = PyLong_AsLong(obj);\n            if (pa->value.i == -1 && PyErr_Occurred()) {\n                PyErr_SetString(PyExc_OverflowError,\n                                \"long int too long to convert\");\n                return -1;\n            }\n        }\n        return 0;\n    }\n\n    if (PyBytes_Check(obj)) {\n        pa->ffi_type = &ffi_type_pointer;\n        pa->value.p = PyBytes_AsString(obj);\n        Py_INCREF(obj);\n        pa->keep = obj;\n        return 0;\n    }\n\n#ifdef CTYPES_UNICODE\n    if (PyUnicode_Check(obj)) {\n#ifdef HAVE_USABLE_WCHAR_T\n        pa->ffi_type = &ffi_type_pointer;\n        pa->value.p = PyUnicode_AS_UNICODE(obj);\n        Py_INCREF(obj);\n        pa->keep = obj;\n        return 0;\n#else\n        int size = PyUnicode_GET_SIZE(obj);\n        pa->ffi_type = &ffi_type_pointer;\n        size += 1; /* terminating NUL */\n        size *= sizeof(wchar_t);\n        pa->value.p = PyMem_Malloc(size);\n        if (!pa->value.p) {\n            PyErr_NoMemory();\n            return -1;\n        }\n        memset(pa->value.p, 0, size);\n        pa->keep = PyCapsule_New(pa->value.p, CTYPES_CAPSULE_NAME_PYMEM, pymem_destructor);\n        if (!pa->keep) {\n            PyMem_Free(pa->value.p);\n            return -1;\n        }\n        if (-1 == PyUnicode_AsWideChar((PyUnicodeObject *)obj,\n                                       pa->value.p, PyUnicode_GET_SIZE(obj)))\n            return -1;\n        return 0;\n#endif\n    }\n#endif\n\n    {\n        PyObject *arg;\n        arg = PyObject_GetAttrString(obj, \"_as_parameter_\");\n        /* Which types should we exactly allow here?\n           integers are required for using Python classes\n           as parameters (they have to expose the '_as_parameter_'\n           attribute)\n        */\n        if (arg) {\n            int result;\n            result = ConvParam(arg, index, pa);\n            Py_DECREF(arg);\n            return result;\n        }\n        PyErr_Format(PyExc_TypeError,\n                     \"Don't know how to convert parameter %d\",\n                     Py_SAFE_DOWNCAST(index, Py_ssize_t, int));\n        return -1;\n    }\n}\n\n\nffi_type *_ctypes_get_ffi_type(PyObject *obj)\n{\n    StgDictObject *dict;\n    if (obj == NULL)\n        return &ffi_type_sint;\n    dict = PyType_stgdict(obj);\n    if (dict == NULL)\n        return &ffi_type_sint;\n#if defined(MS_WIN32) && !defined(_WIN32_WCE)\n    /* This little trick works correctly with MSVC.\n       It returns small structures in registers\n    */\n    if (dict->ffi_type_pointer.type == FFI_TYPE_STRUCT) {\n        if (dict->ffi_type_pointer.size <= 4)\n            return &ffi_type_sint32;\n        else if (dict->ffi_type_pointer.size <= 8)\n            return &ffi_type_sint64;\n    }\n#endif\n    return &dict->ffi_type_pointer;\n}\n\n\n/*\n * libffi uses:\n *\n * ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi,\n *                         unsigned int nargs,\n *                         ffi_type *rtype,\n *                         ffi_type **atypes);\n *\n * and then\n *\n * void ffi_call(ffi_cif *cif, void *fn, void *rvalue, void **avalues);\n */\nstatic int _call_function_pointer(int flags,\n                                  PPROC pProc,\n                                  void **avalues,\n                                  ffi_type **atypes,\n                                  ffi_type *restype,\n                                  void *resmem,\n                                  int argcount)\n{\n#ifdef WITH_THREAD\n    PyThreadState *_save = NULL; /* For Py_BLOCK_THREADS and Py_UNBLOCK_THREADS */\n#endif\n    PyObject *error_object = NULL;\n    int *space;\n    ffi_cif cif;\n    int cc;\n#ifdef MS_WIN32\n    int delta;\n#ifndef DONT_USE_SEH\n    DWORD dwExceptionCode = 0;\n    EXCEPTION_RECORD record;\n#endif\n#endif\n    /* XXX check before here */\n    if (restype == NULL) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"No ffi_type for result\");\n        return -1;\n    }\n\n    cc = FFI_DEFAULT_ABI;\n#if defined(MS_WIN32) && !defined(MS_WIN64) && !defined(_WIN32_WCE)\n    if ((flags & FUNCFLAG_CDECL) == 0)\n        cc = FFI_STDCALL;\n#endif\n    if (FFI_OK != ffi_prep_cif(&cif,\n                               cc,\n                               argcount,\n                               restype,\n                               atypes)) {\n        PyErr_SetString(PyExc_RuntimeError,\n                        \"ffi_prep_cif failed\");\n        return -1;\n    }\n\n    if (flags & (FUNCFLAG_USE_ERRNO | FUNCFLAG_USE_LASTERROR)) {\n        error_object = _ctypes_get_errobj(&space);\n        if (error_object == NULL)\n            return -1;\n    }\n#ifdef WITH_THREAD\n    if ((flags & FUNCFLAG_PYTHONAPI) == 0)\n        Py_UNBLOCK_THREADS\n#endif\n    if (flags & FUNCFLAG_USE_ERRNO) {\n        int temp = space[0];\n        space[0] = errno;\n        errno = temp;\n    }\n#ifdef MS_WIN32\n    if (flags & FUNCFLAG_USE_LASTERROR) {\n        int temp = space[1];\n        space[1] = GetLastError();\n        SetLastError(temp);\n    }\n#ifndef DONT_USE_SEH\n    __try {\n#endif\n        delta =\n#endif\n            ffi_call(&cif, (void *)pProc, resmem, avalues);\n#ifdef MS_WIN32\n#ifndef DONT_USE_SEH\n    }\n    __except (HandleException(GetExceptionInformation(),\n                              &dwExceptionCode, &record)) {\n        ;\n    }\n#endif\n    if (flags & FUNCFLAG_USE_LASTERROR) {\n        int temp = space[1];\n        space[1] = GetLastError();\n        SetLastError(temp);\n    }\n#endif\n    if (flags & FUNCFLAG_USE_ERRNO) {\n        int temp = space[0];\n        space[0] = errno;\n        errno = temp;\n    }\n    Py_XDECREF(error_object);\n#ifdef WITH_THREAD\n    if ((flags & FUNCFLAG_PYTHONAPI) == 0)\n        Py_BLOCK_THREADS\n#endif\n#ifdef MS_WIN32\n#ifndef DONT_USE_SEH\n    if (dwExceptionCode) {\n        SetException(dwExceptionCode, &record);\n        return -1;\n    }\n#endif\n#ifdef MS_WIN64\n    if (delta != 0) {\n        PyErr_Format(PyExc_RuntimeError,\n                     \"ffi_call failed with code %d\",\n                     delta);\n        return -1;\n    }\n#else\n    if (delta < 0) {\n        if (flags & FUNCFLAG_CDECL)\n            PyErr_Format(PyExc_ValueError,\n                         \"Procedure called with not enough \"\n                         \"arguments (%d bytes missing) \"\n                         \"or wrong calling convention\",\n                         -delta);\n        else\n            PyErr_Format(PyExc_ValueError,\n                         \"Procedure probably called with not enough \"\n                         \"arguments (%d bytes missing)\",\n                         -delta);\n        return -1;\n    } else if (delta > 0) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Procedure probably called with too many \"\n                     \"arguments (%d bytes in excess)\",\n                     delta);\n        return -1;\n    }\n#endif\n#endif\n    if ((flags & FUNCFLAG_PYTHONAPI) && PyErr_Occurred())\n        return -1;\n    return 0;\n}\n\n/*\n * Convert the C value in result into a Python object, depending on restype.\n *\n * - If restype is NULL, return a Python integer.\n * - If restype is None, return None.\n * - If restype is a simple ctypes type (c_int, c_void_p), call the type's getfunc,\n *   pass the result to checker and return the result.\n * - If restype is another ctypes type, return an instance of that.\n * - Otherwise, call restype and return the result.\n */\nstatic PyObject *GetResult(PyObject *restype, void *result, PyObject *checker)\n{\n    StgDictObject *dict;\n    PyObject *retval, *v;\n\n    if (restype == NULL)\n        return PyLong_FromLong(*(int *)result);\n\n    if (restype == Py_None) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    dict = PyType_stgdict(restype);\n    if (dict == NULL)\n        return PyObject_CallFunction(restype, \"i\", *(int *)result);\n\n    if (dict->getfunc && !_ctypes_simple_instance(restype)) {\n        retval = dict->getfunc(result, dict->size);\n        /* If restype is py_object (detected by comparing getfunc with\n           O_get), we have to call Py_DECREF because O_get has already\n           called Py_INCREF.\n        */\n        if (dict->getfunc == _ctypes_get_fielddesc(\"O\")->getfunc) {\n            Py_DECREF(retval);\n        }\n    } else\n        retval = PyCData_FromBaseObj(restype, NULL, 0, result);\n\n    if (!checker || !retval)\n        return retval;\n\n    v = PyObject_CallFunctionObjArgs(checker, retval, NULL);\n    if (v == NULL)\n        _ctypes_add_traceback(\"GetResult\", \"_ctypes/callproc.c\", __LINE__-2);\n    Py_DECREF(retval);\n    return v;\n}\n\n/*\n * Raise a new exception 'exc_class', adding additional text to the original\n * exception string.\n */\nvoid _ctypes_extend_error(PyObject *exc_class, char *fmt, ...)\n{\n    va_list vargs;\n    PyObject *tp, *v, *tb, *s, *cls_str, *msg_str;\n\n    va_start(vargs, fmt);\n    s = PyUnicode_FromFormatV(fmt, vargs);\n    va_end(vargs);\n    if (!s)\n        return;\n\n    PyErr_Fetch(&tp, &v, &tb);\n    PyErr_NormalizeException(&tp, &v, &tb);\n    cls_str = PyObject_Str(tp);\n    if (cls_str) {\n        PyUnicode_AppendAndDel(&s, cls_str);\n        PyUnicode_AppendAndDel(&s, PyUnicode_FromString(\": \"));\n        if (s == NULL)\n            goto error;\n    } else\n        PyErr_Clear();\n    msg_str = PyObject_Str(v);\n    if (msg_str)\n        PyUnicode_AppendAndDel(&s, msg_str);\n    else {\n        PyErr_Clear();\n        PyUnicode_AppendAndDel(&s, PyUnicode_FromString(\"???\"));\n        if (s == NULL)\n            goto error;\n    }\n    PyErr_SetObject(exc_class, s);\nerror:\n    Py_XDECREF(tp);\n    Py_XDECREF(v);\n    Py_XDECREF(tb);\n    Py_XDECREF(s);\n}\n\n\n#ifdef MS_WIN32\n\nstatic PyObject *\nGetComError(HRESULT errcode, GUID *riid, IUnknown *pIunk)\n{\n    HRESULT hr;\n    ISupportErrorInfo *psei = NULL;\n    IErrorInfo *pei = NULL;\n    BSTR descr=NULL, helpfile=NULL, source=NULL;\n    GUID guid;\n    DWORD helpcontext=0;\n    LPOLESTR progid;\n    PyObject *obj;\n    LPOLESTR text;\n\n    /* We absolutely have to release the GIL during COM method calls,\n       otherwise we may get a deadlock!\n    */\n#ifdef WITH_THREAD\n    Py_BEGIN_ALLOW_THREADS\n#endif\n\n    hr = pIunk->lpVtbl->QueryInterface(pIunk, &IID_ISupportErrorInfo, (void **)&psei);\n    if (FAILED(hr))\n        goto failed;\n\n    hr = psei->lpVtbl->InterfaceSupportsErrorInfo(psei, riid);\n    psei->lpVtbl->Release(psei);\n    if (FAILED(hr))\n        goto failed;\n\n    hr = GetErrorInfo(0, &pei);\n    if (hr != S_OK)\n        goto failed;\n\n    pei->lpVtbl->GetDescription(pei, &descr);\n    pei->lpVtbl->GetGUID(pei, &guid);\n    pei->lpVtbl->GetHelpContext(pei, &helpcontext);\n    pei->lpVtbl->GetHelpFile(pei, &helpfile);\n    pei->lpVtbl->GetSource(pei, &source);\n\n    pei->lpVtbl->Release(pei);\n\n  failed:\n#ifdef WITH_THREAD\n    Py_END_ALLOW_THREADS\n#endif\n\n    progid = NULL;\n    ProgIDFromCLSID(&guid, &progid);\n\n    text = FormatError(errcode);\n    obj = Py_BuildValue(\n        \"iu(uuuiu)\",\n        errcode,\n        text,\n        descr, source, helpfile, helpcontext,\n        progid);\n    if (obj) {\n        PyErr_SetObject(ComError, obj);\n        Py_DECREF(obj);\n    }\n    LocalFree(text);\n\n    if (descr)\n        SysFreeString(descr);\n    if (helpfile)\n        SysFreeString(helpfile);\n    if (source)\n        SysFreeString(source);\n\n    return NULL;\n}\n#endif\n\n/*\n * Requirements, must be ensured by the caller:\n * - argtuple is tuple of arguments\n * - argtypes is either NULL, or a tuple of the same size as argtuple\n *\n * - XXX various requirements for restype, not yet collected\n */\nPyObject *_ctypes_callproc(PPROC pProc,\n                    PyObject *argtuple,\n#ifdef MS_WIN32\n                    IUnknown *pIunk,\n                    GUID *iid,\n#endif\n                    int flags,\n                    PyObject *argtypes, /* misleading name: This is a tuple of\n                                           methods, not types: the .from_param\n                                           class methods of the types */\n            PyObject *restype,\n            PyObject *checker)\n{\n    Py_ssize_t i, n, argcount, argtype_count;\n    void *resbuf;\n    struct argument *args, *pa;\n    ffi_type **atypes;\n    ffi_type *rtype;\n    void **avalues;\n    PyObject *retval = NULL;\n\n    n = argcount = PyTuple_GET_SIZE(argtuple);\n#ifdef MS_WIN32\n    /* an optional COM object this pointer */\n    if (pIunk)\n        ++argcount;\n#endif\n\n    args = (struct argument *)alloca(sizeof(struct argument) * argcount);\n    if (!args) {\n        PyErr_NoMemory();\n        return NULL;\n    }\n    memset(args, 0, sizeof(struct argument) * argcount);\n    argtype_count = argtypes ? PyTuple_GET_SIZE(argtypes) : 0;\n#ifdef MS_WIN32\n    if (pIunk) {\n        args[0].ffi_type = &ffi_type_pointer;\n        args[0].value.p = pIunk;\n        pa = &args[1];\n    } else\n#endif\n        pa = &args[0];\n\n    /* Convert the arguments */\n    for (i = 0; i < n; ++i, ++pa) {\n        PyObject *converter;\n        PyObject *arg;\n        int err;\n\n        arg = PyTuple_GET_ITEM(argtuple, i);            /* borrowed ref */\n        /* For cdecl functions, we allow more actual arguments\n           than the length of the argtypes tuple.\n           This is checked in _ctypes::PyCFuncPtr_Call\n        */\n        if (argtypes && argtype_count > i) {\n            PyObject *v;\n            converter = PyTuple_GET_ITEM(argtypes, i);\n            v = PyObject_CallFunctionObjArgs(converter,\n                                               arg,\n                                               NULL);\n            if (v == NULL) {\n                _ctypes_extend_error(PyExc_ArgError, \"argument %d: \", i+1);\n                goto cleanup;\n            }\n\n            err = ConvParam(v, i+1, pa);\n            Py_DECREF(v);\n            if (-1 == err) {\n                _ctypes_extend_error(PyExc_ArgError, \"argument %d: \", i+1);\n                goto cleanup;\n            }\n        } else {\n            err = ConvParam(arg, i+1, pa);\n            if (-1 == err) {\n                _ctypes_extend_error(PyExc_ArgError, \"argument %d: \", i+1);\n                goto cleanup; /* leaking ? */\n            }\n        }\n    }\n\n    rtype = _ctypes_get_ffi_type(restype);\n    resbuf = alloca(max(rtype->size, sizeof(ffi_arg)));\n\n    avalues = (void **)alloca(sizeof(void *) * argcount);\n    atypes = (ffi_type **)alloca(sizeof(ffi_type *) * argcount);\n    if (!resbuf || !avalues || !atypes) {\n        PyErr_NoMemory();\n        goto cleanup;\n    }\n    for (i = 0; i < argcount; ++i) {\n        atypes[i] = args[i].ffi_type;\n        if (atypes[i]->type == FFI_TYPE_STRUCT\n#ifdef _WIN64\n            && atypes[i]->size <= sizeof(void *)\n#endif\n            )\n            avalues[i] = (void *)args[i].value.p;\n        else\n            avalues[i] = (void *)&args[i].value;\n    }\n\n    if (-1 == _call_function_pointer(flags, pProc, avalues, atypes,\n                                     rtype, resbuf,\n                                     Py_SAFE_DOWNCAST(argcount,\n                                                      Py_ssize_t,\n                                                      int)))\n        goto cleanup;\n\n#ifdef WORDS_BIGENDIAN\n    /* libffi returns the result in a buffer with sizeof(ffi_arg). This\n       causes problems on big endian machines, since the result buffer\n       address cannot simply be used as result pointer, instead we must\n       adjust the pointer value:\n     */\n    /*\n      XXX I should find out and clarify why this is needed at all,\n      especially why adjusting for ffi_type_float must be avoided on\n      64-bit platforms.\n     */\n    if (rtype->type != FFI_TYPE_FLOAT\n        && rtype->type != FFI_TYPE_STRUCT\n        && rtype->size < sizeof(ffi_arg))\n        resbuf = (char *)resbuf + sizeof(ffi_arg) - rtype->size;\n#endif\n\n#ifdef MS_WIN32\n    if (iid && pIunk) {\n        if (*(int *)resbuf & 0x80000000)\n            retval = GetComError(*(HRESULT *)resbuf, iid, pIunk);\n        else\n            retval = PyLong_FromLong(*(int *)resbuf);\n    } else if (flags & FUNCFLAG_HRESULT) {\n        if (*(int *)resbuf & 0x80000000)\n            retval = PyErr_SetFromWindowsErr(*(int *)resbuf);\n        else\n            retval = PyLong_FromLong(*(int *)resbuf);\n    } else\n#endif\n        retval = GetResult(restype, resbuf, checker);\n  cleanup:\n    for (i = 0; i < argcount; ++i)\n        Py_XDECREF(args[i].keep);\n    return retval;\n}\n\nstatic int\n_parse_voidp(PyObject *obj, void **address)\n{\n    *address = PyLong_AsVoidPtr(obj);\n    if (*address == NULL)\n        return 0;\n    return 1;\n}\n\n#ifdef MS_WIN32\n\nstatic char format_error_doc[] =\n\"FormatError([integer]) -> string\\n\\\n\\n\\\nConvert a win32 error code into a string. If the error code is not\\n\\\ngiven, the return value of a call to GetLastError() is used.\\n\";\nstatic PyObject *format_error(PyObject *self, PyObject *args)\n{\n    PyObject *result;\n    wchar_t *lpMsgBuf;\n    DWORD code = 0;\n    if (!PyArg_ParseTuple(args, \"|i:FormatError\", &code))\n        return NULL;\n    if (code == 0)\n        code = GetLastError();\n    lpMsgBuf = FormatError(code);\n    if (lpMsgBuf) {\n        result = PyUnicode_FromWideChar(lpMsgBuf, wcslen(lpMsgBuf));\n        LocalFree(lpMsgBuf);\n    } else {\n        result = PyUnicode_FromString(\"<no description>\");\n    }\n    return result;\n}\n\nstatic char load_library_doc[] =\n\"LoadLibrary(name) -> handle\\n\\\n\\n\\\nLoad an executable (usually a DLL), and return a handle to it.\\n\\\nThe handle may be used to locate exported functions in this\\n\\\nmodule.\\n\";\nstatic PyObject *load_library(PyObject *self, PyObject *args)\n{\n    WCHAR *name;\n    PyObject *nameobj;\n    PyObject *ignored;\n    HMODULE hMod;\n    if (!PyArg_ParseTuple(args, \"O|O:LoadLibrary\", &nameobj, &ignored))\n        return NULL;\n\n    name = PyUnicode_AsUnicode(nameobj);\n    if (!name)\n        return NULL;\n\n    hMod = LoadLibraryW(name);\n    if (!hMod)\n        return PyErr_SetFromWindowsErr(GetLastError());\n#ifdef _WIN64\n    return PyLong_FromVoidPtr(hMod);\n#else\n    return Py_BuildValue(\"i\", hMod);\n#endif\n}\n\nstatic char free_library_doc[] =\n\"FreeLibrary(handle) -> void\\n\\\n\\n\\\nFree the handle of an executable previously loaded by LoadLibrary.\\n\";\nstatic PyObject *free_library(PyObject *self, PyObject *args)\n{\n    void *hMod;\n    if (!PyArg_ParseTuple(args, \"O&:FreeLibrary\", &_parse_voidp, &hMod))\n        return NULL;\n    if (!FreeLibrary((HMODULE)hMod))\n        return PyErr_SetFromWindowsErr(GetLastError());\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\n/* obsolete, should be removed */\n/* Only used by sample code (in samples\\Windows\\COM.py) */\nstatic PyObject *\ncall_commethod(PyObject *self, PyObject *args)\n{\n    IUnknown *pIunk;\n    int index;\n    PyObject *arguments;\n    PPROC *lpVtbl;\n    PyObject *result;\n    CDataObject *pcom;\n    PyObject *argtypes = NULL;\n\n    if (!PyArg_ParseTuple(args,\n                          \"OiO!|O!\",\n                          &pcom, &index,\n                          &PyTuple_Type, &arguments,\n                          &PyTuple_Type, &argtypes))\n        return NULL;\n\n    if (argtypes && (PyTuple_GET_SIZE(arguments) != PyTuple_GET_SIZE(argtypes))) {\n        PyErr_Format(PyExc_TypeError,\n                     \"Method takes %d arguments (%d given)\",\n                     PyTuple_GET_SIZE(argtypes), PyTuple_GET_SIZE(arguments));\n        return NULL;\n    }\n\n    if (!CDataObject_Check(pcom) || (pcom->b_size != sizeof(void *))) {\n        PyErr_Format(PyExc_TypeError,\n                     \"COM Pointer expected instead of %s instance\",\n                     Py_TYPE(pcom)->tp_name);\n        return NULL;\n    }\n\n    if ((*(void **)(pcom->b_ptr)) == NULL) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"The COM 'this' pointer is NULL\");\n        return NULL;\n    }\n\n    pIunk = (IUnknown *)(*(void **)(pcom->b_ptr));\n    lpVtbl = (PPROC *)(pIunk->lpVtbl);\n\n    result =  _ctypes_callproc(lpVtbl[index],\n                        arguments,\n#ifdef MS_WIN32\n                        pIunk,\n                        NULL,\n#endif\n                        FUNCFLAG_HRESULT, /* flags */\n                argtypes, /* self->argtypes */\n                NULL, /* self->restype */\n                NULL); /* checker */\n    return result;\n}\n\nstatic char copy_com_pointer_doc[] =\n\"CopyComPointer(src, dst) -> HRESULT value\\n\";\n\nstatic PyObject *\ncopy_com_pointer(PyObject *self, PyObject *args)\n{\n    PyObject *p1, *p2, *r = NULL;\n    struct argument a, b;\n    IUnknown *src, **pdst;\n    if (!PyArg_ParseTuple(args, \"OO:CopyComPointer\", &p1, &p2))\n        return NULL;\n    a.keep = b.keep = NULL;\n\n    if (-1 == ConvParam(p1, 0, &a) || -1 == ConvParam(p2, 1, &b))\n        goto done;\n    src = (IUnknown *)a.value.p;\n    pdst = (IUnknown **)b.value.p;\n\n    if (pdst == NULL)\n        r = PyLong_FromLong(E_POINTER);\n    else {\n        if (src)\n            src->lpVtbl->AddRef(src);\n        *pdst = src;\n        r = PyLong_FromLong(S_OK);\n    }\n  done:\n    Py_XDECREF(a.keep);\n    Py_XDECREF(b.keep);\n    return r;\n}\n#else\n\nstatic PyObject *py_dl_open(PyObject *self, PyObject *args)\n{\n    PyObject *name, *name2;\n    char *name_str;\n    void * handle;\n#ifdef RTLD_LOCAL\n    int mode = RTLD_NOW | RTLD_LOCAL;\n#else\n    /* cygwin doesn't define RTLD_LOCAL */\n    int mode = RTLD_NOW;\n#endif\n    if (!PyArg_ParseTuple(args, \"O|i:dlopen\", &name, &mode))\n        return NULL;\n    mode |= RTLD_NOW;\n    if (name != Py_None) {\n        if (PyUnicode_FSConverter(name, &name2) == 0)\n            return NULL;\n        if (PyBytes_Check(name2))\n            name_str = PyBytes_AS_STRING(name2);\n        else\n            name_str = PyByteArray_AS_STRING(name2);\n    } else {\n        name_str = NULL;\n        name2 = NULL;\n    }\n    handle = ctypes_dlopen(name_str, mode);\n    Py_XDECREF(name2);\n    if (!handle) {\n        char *errmsg = ctypes_dlerror();\n        if (!errmsg)\n            errmsg = \"dlopen() error\";\n        PyErr_SetString(PyExc_OSError,\n                               errmsg);\n        return NULL;\n    }\n    return PyLong_FromVoidPtr(handle);\n}\n\nstatic PyObject *py_dl_close(PyObject *self, PyObject *args)\n{\n    void *handle;\n\n    if (!PyArg_ParseTuple(args, \"O&:dlclose\", &_parse_voidp, &handle))\n        return NULL;\n    if (dlclose(handle)) {\n        PyErr_SetString(PyExc_OSError,\n                               ctypes_dlerror());\n        return NULL;\n    }\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *py_dl_sym(PyObject *self, PyObject *args)\n{\n    char *name;\n    void *handle;\n    void *ptr;\n\n    if (!PyArg_ParseTuple(args, \"O&s:dlsym\",\n                          &_parse_voidp, &handle, &name))\n        return NULL;\n    ptr = ctypes_dlsym((void*)handle, name);\n    if (!ptr) {\n        PyErr_SetString(PyExc_OSError,\n                               ctypes_dlerror());\n        return NULL;\n    }\n    return PyLong_FromVoidPtr(ptr);\n}\n#endif\n\n/*\n * Only for debugging so far: So that we can call CFunction instances\n *\n * XXX Needs to accept more arguments: flags, argtypes, restype\n */\nstatic PyObject *\ncall_function(PyObject *self, PyObject *args)\n{\n    void *func;\n    PyObject *arguments;\n    PyObject *result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O!\",\n                          &_parse_voidp, &func,\n                          &PyTuple_Type, &arguments))\n        return NULL;\n\n    result =  _ctypes_callproc((PPROC)func,\n                        arguments,\n#ifdef MS_WIN32\n                        NULL,\n                        NULL,\n#endif\n                        0, /* flags */\n                NULL, /* self->argtypes */\n                NULL, /* self->restype */\n                NULL); /* checker */\n    return result;\n}\n\n/*\n * Only for debugging so far: So that we can call CFunction instances\n *\n * XXX Needs to accept more arguments: flags, argtypes, restype\n */\nstatic PyObject *\ncall_cdeclfunction(PyObject *self, PyObject *args)\n{\n    void *func;\n    PyObject *arguments;\n    PyObject *result;\n\n    if (!PyArg_ParseTuple(args,\n                          \"O&O!\",\n                          &_parse_voidp, &func,\n                          &PyTuple_Type, &arguments))\n        return NULL;\n\n    result =  _ctypes_callproc((PPROC)func,\n                        arguments,\n#ifdef MS_WIN32\n                        NULL,\n                        NULL,\n#endif\n                        FUNCFLAG_CDECL, /* flags */\n                NULL, /* self->argtypes */\n                NULL, /* self->restype */\n                NULL); /* checker */\n    return result;\n}\n\n/*****************************************************************\n * functions\n */\nstatic char sizeof_doc[] =\n\"sizeof(C type) -> integer\\n\"\n\"sizeof(C instance) -> integer\\n\"\n\"Return the size in bytes of a C instance\";\n\nstatic PyObject *\nsizeof_func(PyObject *self, PyObject *obj)\n{\n    StgDictObject *dict;\n\n    dict = PyType_stgdict(obj);\n    if (dict)\n        return PyLong_FromSsize_t(dict->size);\n\n    if (CDataObject_Check(obj))\n        return PyLong_FromSsize_t(((CDataObject *)obj)->b_size);\n    PyErr_SetString(PyExc_TypeError,\n                    \"this type has no size\");\n    return NULL;\n}\n\nstatic char alignment_doc[] =\n\"alignment(C type) -> integer\\n\"\n\"alignment(C instance) -> integer\\n\"\n\"Return the alignment requirements of a C instance\";\n\nstatic PyObject *\nalign_func(PyObject *self, PyObject *obj)\n{\n    StgDictObject *dict;\n\n    dict = PyType_stgdict(obj);\n    if (dict)\n        return PyLong_FromSsize_t(dict->align);\n\n    dict = PyObject_stgdict(obj);\n    if (dict)\n        return PyLong_FromSsize_t(dict->align);\n\n    PyErr_SetString(PyExc_TypeError,\n                    \"no alignment info\");\n    return NULL;\n}\n\nstatic char byref_doc[] =\n\"byref(C instance[, offset=0]) -> byref-object\\n\"\n\"Return a pointer lookalike to a C instance, only usable\\n\"\n\"as function argument\";\n\n/*\n * We must return something which can be converted to a parameter,\n * but still has a reference to self.\n */\nstatic PyObject *\nbyref(PyObject *self, PyObject *args)\n{\n    PyCArgObject *parg;\n    PyObject *obj;\n    PyObject *pyoffset = NULL;\n    Py_ssize_t offset = 0;\n\n    if (!PyArg_UnpackTuple(args, \"byref\", 1, 2,\n                           &obj, &pyoffset))\n        return NULL;\n    if (pyoffset) {\n        offset = PyNumber_AsSsize_t(pyoffset, NULL);\n        if (offset == -1 && PyErr_Occurred())\n            return NULL;\n    }\n    if (!CDataObject_Check(obj)) {\n        PyErr_Format(PyExc_TypeError,\n                     \"byref() argument must be a ctypes instance, not '%s'\",\n                     Py_TYPE(obj)->tp_name);\n        return NULL;\n    }\n\n    parg = PyCArgObject_new();\n    if (parg == NULL)\n        return NULL;\n\n    parg->tag = 'P';\n    parg->pffi_type = &ffi_type_pointer;\n    Py_INCREF(obj);\n    parg->obj = obj;\n    parg->value.p = (char *)((CDataObject *)obj)->b_ptr + offset;\n    return (PyObject *)parg;\n}\n\nstatic char addressof_doc[] =\n\"addressof(C instance) -> integer\\n\"\n\"Return the address of the C instance internal buffer\";\n\nstatic PyObject *\naddressof(PyObject *self, PyObject *obj)\n{\n    if (CDataObject_Check(obj))\n        return PyLong_FromVoidPtr(((CDataObject *)obj)->b_ptr);\n    PyErr_SetString(PyExc_TypeError,\n                    \"invalid type\");\n    return NULL;\n}\n\nstatic int\nconverter(PyObject *obj, void **address)\n{\n    *address = PyLong_AsVoidPtr(obj);\n    return *address != NULL;\n}\n\nstatic PyObject *\nMy_PyObj_FromPtr(PyObject *self, PyObject *args)\n{\n    PyObject *ob;\n    if (!PyArg_ParseTuple(args, \"O&:PyObj_FromPtr\", converter, &ob))\n        return NULL;\n    Py_INCREF(ob);\n    return ob;\n}\n\nstatic PyObject *\nMy_Py_INCREF(PyObject *self, PyObject *arg)\n{\n    Py_INCREF(arg); /* that's what this function is for */\n    Py_INCREF(arg); /* that for returning it */\n    return arg;\n}\n\nstatic PyObject *\nMy_Py_DECREF(PyObject *self, PyObject *arg)\n{\n    Py_DECREF(arg); /* that's what this function is for */\n    Py_INCREF(arg); /* that's for returning it */\n    return arg;\n}\n\n#ifdef CTYPES_UNICODE\n\nstatic char set_conversion_mode_doc[] =\n\"set_conversion_mode(encoding, errors) -> (previous-encoding, previous-errors)\\n\\\n\\n\\\nSet the encoding and error handling ctypes uses when converting\\n\\\nbetween unicode and strings.  Returns the previous values.\\n\";\n\nstatic PyObject *\nset_conversion_mode(PyObject *self, PyObject *args)\n{\n    char *coding, *mode;\n    PyObject *result;\n\n    if (!PyArg_ParseTuple(args, \"zs:set_conversion_mode\", &coding, &mode))\n        return NULL;\n    result = Py_BuildValue(\"(zz)\", _ctypes_conversion_encoding, _ctypes_conversion_errors);\n    if (coding) {\n        PyMem_Free(_ctypes_conversion_encoding);\n        _ctypes_conversion_encoding = PyMem_Malloc(strlen(coding) + 1);\n        strcpy(_ctypes_conversion_encoding, coding);\n    } else {\n        _ctypes_conversion_encoding = NULL;\n    }\n    PyMem_Free(_ctypes_conversion_errors);\n    _ctypes_conversion_errors = PyMem_Malloc(strlen(mode) + 1);\n    strcpy(_ctypes_conversion_errors, mode);\n    return result;\n}\n#endif\n\nstatic PyObject *\nresize(PyObject *self, PyObject *args)\n{\n    CDataObject *obj;\n    StgDictObject *dict;\n    Py_ssize_t size;\n\n    if (!PyArg_ParseTuple(args,\n                          \"On:resize\",\n                          &obj, &size))\n        return NULL;\n\n    dict = PyObject_stgdict((PyObject *)obj);\n    if (dict == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"excepted ctypes instance\");\n        return NULL;\n    }\n    if (size < dict->size) {\n        PyErr_Format(PyExc_ValueError,\n                     \"minimum size is %zd\",\n                     dict->size);\n        return NULL;\n    }\n    if (obj->b_needsfree == 0) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Memory cannot be resized because this object doesn't own it\");\n        return NULL;\n    }\n    if (size <= sizeof(obj->b_value)) {\n        /* internal default buffer is large enough */\n        obj->b_size = size;\n        goto done;\n    }\n    if (obj->b_size <= sizeof(obj->b_value)) {\n        /* We are currently using the objects default buffer, but it\n           isn't large enough any more. */\n        void *ptr = PyMem_Malloc(size);\n        if (ptr == NULL)\n            return PyErr_NoMemory();\n        memset(ptr, 0, size);\n        memmove(ptr, obj->b_ptr, obj->b_size);\n        obj->b_ptr = ptr;\n        obj->b_size = size;\n    } else {\n        void * ptr = PyMem_Realloc(obj->b_ptr, size);\n        if (ptr == NULL)\n            return PyErr_NoMemory();\n        obj->b_ptr = ptr;\n        obj->b_size = size;\n    }\n  done:\n    Py_INCREF(Py_None);\n    return Py_None;\n}\n\nstatic PyObject *\nunpickle(PyObject *self, PyObject *args)\n{\n    PyObject *typ;\n    PyObject *state;\n    PyObject *result;\n    PyObject *tmp;\n\n    if (!PyArg_ParseTuple(args, \"OO\", &typ, &state))\n        return NULL;\n    result = PyObject_CallMethod(typ, \"__new__\", \"O\", typ);\n    if (result == NULL)\n        return NULL;\n    tmp = PyObject_CallMethod(result, \"__setstate__\", \"O\", state);\n    if (tmp == NULL) {\n        Py_DECREF(result);\n        return NULL;\n    }\n    Py_DECREF(tmp);\n    return result;\n}\n\nstatic PyObject *\nPOINTER(PyObject *self, PyObject *cls)\n{\n    PyObject *result;\n    PyTypeObject *typ;\n    PyObject *key;\n    char *buf;\n\n    result = PyDict_GetItem(_ctypes_ptrtype_cache, cls);\n    if (result) {\n        Py_INCREF(result);\n        return result;\n    }\n    if (PyUnicode_CheckExact(cls)) {\n        char *name = _PyUnicode_AsString(cls);\n        buf = alloca(strlen(name) + 3 + 1);\n        sprintf(buf, \"LP_%s\", name);\n        result = PyObject_CallFunction((PyObject *)Py_TYPE(&PyCPointer_Type),\n                                       \"s(O){}\",\n                                       buf,\n                                       &PyCPointer_Type);\n        if (result == NULL)\n            return result;\n        key = PyLong_FromVoidPtr(result);\n    } else if (PyType_Check(cls)) {\n        typ = (PyTypeObject *)cls;\n        buf = alloca(strlen(typ->tp_name) + 3 + 1);\n        sprintf(buf, \"LP_%s\", typ->tp_name);\n        result = PyObject_CallFunction((PyObject *)Py_TYPE(&PyCPointer_Type),\n                                       \"s(O){sO}\",\n                                       buf,\n                                       &PyCPointer_Type,\n                                       \"_type_\", cls);\n        if (result == NULL)\n            return result;\n        Py_INCREF(cls);\n        key = cls;\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"must be a ctypes type\");\n        return NULL;\n    }\n    if (-1 == PyDict_SetItem(_ctypes_ptrtype_cache, key, result)) {\n        Py_DECREF(result);\n        Py_DECREF(key);\n        return NULL;\n    }\n    Py_DECREF(key);\n    return result;\n}\n\nstatic PyObject *\npointer(PyObject *self, PyObject *arg)\n{\n    PyObject *result;\n    PyObject *typ;\n\n    typ = PyDict_GetItem(_ctypes_ptrtype_cache, (PyObject *)Py_TYPE(arg));\n    if (typ)\n        return PyObject_CallFunctionObjArgs(typ, arg, NULL);\n    typ = POINTER(NULL, (PyObject *)Py_TYPE(arg));\n    if (typ == NULL)\n                    return NULL;\n    result = PyObject_CallFunctionObjArgs(typ, arg, NULL);\n    Py_DECREF(typ);\n    return result;\n}\n\nstatic PyObject *\nbuffer_info(PyObject *self, PyObject *arg)\n{\n    StgDictObject *dict = PyType_stgdict(arg);\n    PyObject *shape;\n    Py_ssize_t i;\n\n    if (dict == NULL)\n        dict = PyObject_stgdict(arg);\n    if (dict == NULL) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"not a ctypes type or object\");\n        return NULL;\n    }\n    shape = PyTuple_New(dict->ndim);\n    if (shape == NULL)\n        return NULL;\n    for (i = 0; i < (int)dict->ndim; ++i)\n        PyTuple_SET_ITEM(shape, i, PyLong_FromSsize_t(dict->shape[i]));\n\n    if (PyErr_Occurred()) {\n        Py_DECREF(shape);\n        return NULL;\n    }\n    return Py_BuildValue(\"siN\", dict->format, dict->ndim, shape);\n}\n\nPyMethodDef _ctypes_module_methods[] = {\n    {\"get_errno\", get_errno, METH_NOARGS},\n    {\"set_errno\", set_errno, METH_VARARGS},\n    {\"POINTER\", POINTER, METH_O },\n    {\"pointer\", pointer, METH_O },\n    {\"_unpickle\", unpickle, METH_VARARGS },\n    {\"buffer_info\", buffer_info, METH_O, \"Return buffer interface information\"},\n    {\"resize\", resize, METH_VARARGS, \"Resize the memory buffer of a ctypes instance\"},\n#ifdef CTYPES_UNICODE\n    {\"set_conversion_mode\", set_conversion_mode, METH_VARARGS, set_conversion_mode_doc},\n#endif\n#ifdef MS_WIN32\n    {\"get_last_error\", get_last_error, METH_NOARGS},\n    {\"set_last_error\", set_last_error, METH_VARARGS},\n    {\"CopyComPointer\", copy_com_pointer, METH_VARARGS, copy_com_pointer_doc},\n    {\"FormatError\", format_error, METH_VARARGS, format_error_doc},\n    {\"LoadLibrary\", load_library, METH_VARARGS, load_library_doc},\n    {\"FreeLibrary\", free_library, METH_VARARGS, free_library_doc},\n    {\"call_commethod\", call_commethod, METH_VARARGS },\n    {\"_check_HRESULT\", check_hresult, METH_VARARGS},\n#else\n    {\"dlopen\", py_dl_open, METH_VARARGS,\n     \"dlopen(name, flag={RTLD_GLOBAL|RTLD_LOCAL}) open a shared library\"},\n    {\"dlclose\", py_dl_close, METH_VARARGS, \"dlclose a library\"},\n    {\"dlsym\", py_dl_sym, METH_VARARGS, \"find symbol in shared library\"},\n#endif\n    {\"alignment\", align_func, METH_O, alignment_doc},\n    {\"sizeof\", sizeof_func, METH_O, sizeof_doc},\n    {\"byref\", byref, METH_VARARGS, byref_doc},\n    {\"addressof\", addressof, METH_O, addressof_doc},\n    {\"call_function\", call_function, METH_VARARGS },\n    {\"call_cdeclfunction\", call_cdeclfunction, METH_VARARGS },\n    {\"PyObj_FromPtr\", My_PyObj_FromPtr, METH_VARARGS },\n    {\"Py_INCREF\", My_Py_INCREF, METH_O },\n    {\"Py_DECREF\", My_Py_DECREF, METH_O },\n    {NULL,      NULL}        /* Sentinel */\n};\n\n/*\n Local Variables:\n compile-command: \"cd .. && python setup.py -q build -g && python setup.py -q build install --home ~\"\n End:\n*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_ctypes/darwin/dlfcn.h": "/*\nCopyright (c) 2002 Jorge Acereda  <jacereda@users.sourceforge.net> &\n                   Peter O'Gorman <ogorman@users.sourceforge.net>\n                   \nPortions may be copyright others, see the AUTHORS file included with this\ndistribution.\n\nMaintained by Peter O'Gorman <ogorman@users.sourceforge.net>\n\nBug Reports and other queries should go to <ogorman@users.sourceforge.net>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n#ifndef _DLFCN_H_\n#define _DLFCN_H_\n\n#include <AvailabilityMacros.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/*\n * Structure filled in by dladdr().\n */\n\ntypedef struct dl_info {\n        const char      *dli_fname;     /* Pathname of shared object */\n        void            *dli_fbase;     /* Base address of shared object */\n        const char      *dli_sname;     /* Name of nearest symbol */\n        void            *dli_saddr;     /* Address of nearest symbol */\n} Dl_info;\n\n\n#if MAC_OS_X_VERSION_MIN_REQUIRED <= MAC_OS_X_VERSION_10_2\n#warning CTYPES_DARWIN_DLFCN\n#define CTYPES_DARWIN_DLFCN\nextern void * (*ctypes_dlopen)(const char *path, int mode);\nextern void * (*ctypes_dlsym)(void * handle, const char *symbol);\nextern const char * (*ctypes_dlerror)(void);\nextern int (*ctypes_dlclose)(void * handle);\nextern int (*ctypes_dladdr)(const void *, Dl_info *);\n#else\nextern void * dlopen(const char *path, int mode);\nextern void * dlsym(void * handle, const char *symbol);\nextern const char * dlerror(void);\nextern int dlclose(void * handle);\nextern int dladdr(const void *, Dl_info *);\n#endif\n\n#define RTLD_LAZY\t0x1\n#define RTLD_NOW\t0x2\n#define RTLD_LOCAL\t0x4\n#define RTLD_GLOBAL\t0x8\n#define RTLD_NOLOAD\t0x10\n#define RTLD_NODELETE\t0x80\n\n/* These are from the Mac OS X 10.4 headers */\n#define RTLD_NEXT       ((void *) -1)   /* Search subsequent objects. */\n#define RTLD_DEFAULT    ((void *) -2)   /* Use default search algorithm. */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _DLFCN_H_ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_ctypes/darwin/dlfcn_simple.c": "/*\nCopyright (c) 2002 Peter O'Gorman <ogorman@users.sourceforge.net>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/* Just to prove that it isn't that hard to add Mac calls to your code :)\n   This works with pretty much everything, including kde3 xemacs and the gimp,\n   I'd guess that it'd work in at least 95% of cases, use this as your starting\n   point, rather than the mess that is dlfcn.c, assuming that your code does not\n   require ref counting or symbol lookups in dependent libraries\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <limits.h>\n#include <mach-o/dyld.h>\n#include <AvailabilityMacros.h>\n#include \"dlfcn.h\"\n\n#ifdef CTYPES_DARWIN_DLFCN\n\n#define ERR_STR_LEN 256\n\n#ifndef MAC_OS_X_VERSION_10_3\n#define MAC_OS_X_VERSION_10_3 1030\n#endif\n\n#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_3\n#define DARWIN_HAS_DLOPEN\nextern void * dlopen(const char *path, int mode) __attribute__((weak_import));\nextern void * dlsym(void * handle, const char *symbol) __attribute__((weak_import));\nextern const char * dlerror(void) __attribute__((weak_import));\nextern int dlclose(void * handle) __attribute__((weak_import));\nextern int dladdr(const void *, Dl_info *) __attribute__((weak_import));\n#endif /* MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_3 */\n\n#ifndef DARWIN_HAS_DLOPEN\n#define dlopen darwin_dlopen\n#define dlsym darwin_dlsym\n#define dlerror darwin_dlerror\n#define dlclose darwin_dlclose\n#define dladdr darwin_dladdr\n#endif\n\nvoid * (*ctypes_dlopen)(const char *path, int mode);\nvoid * (*ctypes_dlsym)(void * handle, const char *symbol);\nconst char * (*ctypes_dlerror)(void);\nint (*ctypes_dlclose)(void * handle);\nint (*ctypes_dladdr)(const void *, Dl_info *);\n\n#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3\n/* Mac OS X 10.3+ has dlopen, so strip all this dead code to avoid warnings */\n\nstatic void *dlsymIntern(void *handle, const char *symbol);\n\nstatic const char *error(int setget, const char *str, ...);\n\n/* Set and get the error string for use by dlerror */\nstatic const char *error(int setget, const char *str, ...)\n{\n    static char errstr[ERR_STR_LEN];\n    static int err_filled = 0;\n    const char *retval;\n    va_list arg;\n    if (setget == 0)\n    {\n        va_start(arg, str);\n        strncpy(errstr, \"dlcompat: \", ERR_STR_LEN);\n        vsnprintf(errstr + 10, ERR_STR_LEN - 10, str, arg);\n        va_end(arg);\n        err_filled = 1;\n        retval = NULL;\n    }\n    else\n    {\n        if (!err_filled)\n            retval = NULL;\n        else\n            retval = errstr;\n        err_filled = 0;\n    }\n    return retval;\n}\n\n/* darwin_dlopen */\nstatic void *darwin_dlopen(const char *path, int mode)\n{\n    void *module = 0;\n    NSObjectFileImage ofi = 0;\n    NSObjectFileImageReturnCode ofirc;\n\n    /* If we got no path, the app wants the global namespace, use -1 as the marker\n       in this case */\n    if (!path)\n        return (void *)-1;\n\n    /* Create the object file image, works for things linked with the -bundle arg to ld */\n    ofirc = NSCreateObjectFileImageFromFile(path, &ofi);\n    switch (ofirc)\n    {\n        case NSObjectFileImageSuccess:\n            /* It was okay, so use NSLinkModule to link in the image */\n            module = NSLinkModule(ofi, path,\n                                                      NSLINKMODULE_OPTION_RETURN_ON_ERROR\n                                                      | (mode & RTLD_GLOBAL) ? 0 : NSLINKMODULE_OPTION_PRIVATE\n                                                      | (mode & RTLD_LAZY) ? 0 : NSLINKMODULE_OPTION_BINDNOW);\n            NSDestroyObjectFileImage(ofi);\n            break;\n        case NSObjectFileImageInappropriateFile:\n            /* It may have been a dynamic library rather than a bundle, try to load it */\n            module = (void *)NSAddImage(path, NSADDIMAGE_OPTION_RETURN_ON_ERROR);\n            break;\n        default:\n            /* God knows what we got */\n            error(0, \"Can not open \\\"%s\\\"\", path);\n            return 0;\n    }\n    if (!module)\n        error(0, \"Can not open \\\"%s\\\"\", path);\n    return module;\n\n}\n\n/* dlsymIntern is used by dlsym to find the symbol */\nstatic void *dlsymIntern(void *handle, const char *symbol)\n{\n    NSSymbol nssym = 0;\n    /* If the handle is -1, if is the app global context */\n    if (handle == (void *)-1)\n    {\n        /* Global context, use NSLookupAndBindSymbol */\n        if (NSIsSymbolNameDefined(symbol))\n        {\n            nssym = NSLookupAndBindSymbol(symbol);\n        }\n\n    }\n    /* Now see if the handle is a struch mach_header* or not, use NSLookupSymbol in image\n       for libraries, and NSLookupSymbolInModule for bundles */\n    else\n    {\n        /* Check for both possible magic numbers depending on x86/ppc byte order */\n        if ((((struct mach_header *)handle)->magic == MH_MAGIC) ||\n            (((struct mach_header *)handle)->magic == MH_CIGAM))\n        {\n            if (NSIsSymbolNameDefinedInImage((struct mach_header *)handle, symbol))\n            {\n                nssym = NSLookupSymbolInImage((struct mach_header *)handle,\n                                                                          symbol,\n                                                                          NSLOOKUPSYMBOLINIMAGE_OPTION_BIND\n                                                                          | NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);\n            }\n\n        }\n        else\n        {\n            nssym = NSLookupSymbolInModule(handle, symbol);\n        }\n    }\n    if (!nssym)\n    {\n        error(0, \"Symbol \\\"%s\\\" Not found\", symbol);\n        return NULL;\n    }\n    return NSAddressOfSymbol(nssym);\n}\n\nstatic const char *darwin_dlerror(void)\n{\n    return error(1, (char *)NULL);\n}\n\nstatic int darwin_dlclose(void *handle)\n{\n    if ((((struct mach_header *)handle)->magic == MH_MAGIC) ||\n        (((struct mach_header *)handle)->magic == MH_CIGAM))\n    {\n        error(0, \"Can't remove dynamic libraries on darwin\");\n        return 0;\n    }\n    if (!NSUnLinkModule(handle, 0))\n    {\n        error(0, \"unable to unlink module %s\", NSNameOfModule(handle));\n        return 1;\n    }\n    return 0;\n}\n\n\n/* dlsym, prepend the underscore and call dlsymIntern */\nstatic void *darwin_dlsym(void *handle, const char *symbol)\n{\n    static char undersym[257];          /* Saves calls to malloc(3) */\n    int sym_len = strlen(symbol);\n    void *value = NULL;\n    char *malloc_sym = NULL;\n\n    if (sym_len < 256)\n    {\n        snprintf(undersym, 256, \"_%s\", symbol);\n        value = dlsymIntern(handle, undersym);\n    }\n    else\n    {\n        malloc_sym = malloc(sym_len + 2);\n        if (malloc_sym)\n        {\n            sprintf(malloc_sym, \"_%s\", symbol);\n            value = dlsymIntern(handle, malloc_sym);\n            free(malloc_sym);\n        }\n        else\n        {\n            error(0, \"Unable to allocate memory\");\n        }\n    }\n    return value;\n}\n\nstatic int darwin_dladdr(const void *handle, Dl_info *info) {\n    return 0;\n}\n#endif /* MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3 */\n\n#if __GNUC__ < 4\n#pragma CALL_ON_LOAD ctypes_dlfcn_init\n#else\nstatic void __attribute__ ((constructor)) ctypes_dlfcn_init(void);\nstatic\n#endif\nvoid ctypes_dlfcn_init(void) {\n    if (dlopen != NULL) {\n        ctypes_dlsym = dlsym;\n        ctypes_dlopen = dlopen;\n        ctypes_dlerror = dlerror;\n        ctypes_dlclose = dlclose;\n        ctypes_dladdr = dladdr;\n    } else {\n#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3\n        ctypes_dlsym = darwin_dlsym;\n        ctypes_dlopen = darwin_dlopen;\n        ctypes_dlerror = darwin_dlerror;\n        ctypes_dlclose = darwin_dlclose;\n        ctypes_dladdr = darwin_dladdr;\n#endif /* MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3 */\n    }\n}\n\n#endif /* CTYPES_DARWIN_DLFCN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_ctypes/libffi/aclocal.m4": "# generated automatically by aclocal 1.10 -*- Autoconf -*-\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n# 2005, 2006  Free Software Foundation, Inc.\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n# PARTICULAR PURPOSE.\n\nm4_if(m4_PACKAGE_VERSION, [2.61],,\n[m4_fatal([this file was generated for autoconf 2.61.\nYou have another version of autoconf.  If you want to use that,\nyou should regenerate the build system entirely.], [63])])\n\n# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n\n# serial 51 AC_PROG_LIBTOOL\n\n\n# AC_PROVIDE_IFELSE(MACRO-NAME, IF-PROVIDED, IF-NOT-PROVIDED)\n# -----------------------------------------------------------\n# If this macro is not defined by Autoconf, define it here.\nm4_ifdef([AC_PROVIDE_IFELSE],\n         [],\n         [m4_define([AC_PROVIDE_IFELSE],\n\t         [m4_ifdef([AC_PROVIDE_$1],\n\t\t           [$2], [$3])])])\n\n\n# AC_PROG_LIBTOOL\n# ---------------\nAC_DEFUN([AC_PROG_LIBTOOL],\n[AC_REQUIRE([_AC_PROG_LIBTOOL])dnl\ndnl If AC_PROG_CXX has already been expanded, run AC_LIBTOOL_CXX\ndnl immediately, otherwise, hook it in at the end of AC_PROG_CXX.\n  AC_PROVIDE_IFELSE([AC_PROG_CXX],\n    [AC_LIBTOOL_CXX],\n    [define([AC_PROG_CXX], defn([AC_PROG_CXX])[AC_LIBTOOL_CXX\n  ])])\ndnl And a similar setup for Fortran 77 support\n  AC_PROVIDE_IFELSE([AC_PROG_F77],\n    [AC_LIBTOOL_F77],\n    [define([AC_PROG_F77], defn([AC_PROG_F77])[AC_LIBTOOL_F77\n])])\n\ndnl Quote A][M_PROG_GCJ so that aclocal doesn't bring it in needlessly.\ndnl If either AC_PROG_GCJ or A][M_PROG_GCJ have already been expanded, run\ndnl AC_LIBTOOL_GCJ immediately, otherwise, hook it in at the end of both.\n  AC_PROVIDE_IFELSE([AC_PROG_GCJ],\n    [AC_LIBTOOL_GCJ],\n    [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n      [AC_LIBTOOL_GCJ],\n      [AC_PROVIDE_IFELSE([LT_AC_PROG_GCJ],\n\t[AC_LIBTOOL_GCJ],\n      [ifdef([AC_PROG_GCJ],\n\t     [define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[AC_LIBTOOL_GCJ])])\n       ifdef([A][M_PROG_GCJ],\n\t     [define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[AC_LIBTOOL_GCJ])])\n       ifdef([LT_AC_PROG_GCJ],\n\t     [define([LT_AC_PROG_GCJ],\n\t\tdefn([LT_AC_PROG_GCJ])[AC_LIBTOOL_GCJ])])])])\n])])# AC_PROG_LIBTOOL\n\n\n# _AC_PROG_LIBTOOL\n# ----------------\nAC_DEFUN([_AC_PROG_LIBTOOL],\n[AC_REQUIRE([AC_LIBTOOL_SETUP])dnl\nAC_BEFORE([$0],[AC_LIBTOOL_CXX])dnl\nAC_BEFORE([$0],[AC_LIBTOOL_F77])dnl\nAC_BEFORE([$0],[AC_LIBTOOL_GCJ])dnl\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=\"$ac_aux_dir/ltmain.sh\"\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n# Prevent multiple expansion\ndefine([AC_PROG_LIBTOOL], [])\n])# _AC_PROG_LIBTOOL\n\n\n# AC_LIBTOOL_SETUP\n# ----------------\nAC_DEFUN([AC_LIBTOOL_SETUP],\n[AC_PREREQ(2.50)dnl\nAC_REQUIRE([AC_ENABLE_SHARED])dnl\nAC_REQUIRE([AC_ENABLE_STATIC])dnl\nAC_REQUIRE([AC_ENABLE_FAST_INSTALL])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_LD])dnl\nAC_REQUIRE([AC_PROG_LD_RELOAD_FLAG])dnl\nAC_REQUIRE([AC_PROG_NM])dnl\n\nAC_REQUIRE([AC_PROG_LN_S])dnl\nAC_REQUIRE([AC_DEPLIBS_CHECK_METHOD])dnl\n# Autoconf 2.13's AC_OBJEXT and AC_EXEEXT macros only works for C compilers!\nAC_REQUIRE([AC_OBJEXT])dnl\nAC_REQUIRE([AC_EXEEXT])dnl\ndnl\n\nAC_LIBTOOL_SYS_MAX_CMD_LEN\nAC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE\nAC_LIBTOOL_OBJDIR\n\nAC_REQUIRE([_LT_AC_SYS_COMPILER])dnl\n_LT_AC_PROG_ECHO_BACKSLASH\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test \"X${COLLECT_NAMES+set}\" != Xset; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed='sed -e 1s/^X//'\n[sed_quote_subst='s/\\([\\\\\"\\\\`$\\\\\\\\]\\)/\\\\\\1/g']\n\n# Same as above, but do not quote variable references.\n[double_quote_subst='s/\\([\\\\\"\\\\`\\\\\\\\]\\)/\\\\\\1/g']\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n\n# Constants:\nrm=\"rm -f\"\n\n# Global variables:\ndefault_ofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a `.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\nltmain=\"$ac_aux_dir/ltmain.sh\"\nofile=\"$default_ofile\"\nwith_gnu_ld=\"$lt_cv_prog_gnu_ld\"\n\nAC_CHECK_TOOL(AR, ar, false)\nAC_CHECK_TOOL(RANLIB, ranlib, :)\nAC_CHECK_TOOL(STRIP, strip, :)\n\nold_CC=\"$CC\"\nold_CFLAGS=\"$CFLAGS\"\n\n# Set sane defaults for various variables\ntest -z \"$AR\" && AR=ar\ntest -z \"$AR_FLAGS\" && AR_FLAGS=cru\ntest -z \"$AS\" && AS=as\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\ntest -z \"$LD\" && LD=ld\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ntest -z \"$NM\" && NM=nm\ntest -z \"$SED\" && SED=sed\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\ntest -z \"$RANLIB\" && RANLIB=:\ntest -z \"$STRIP\" && STRIP=:\ntest -z \"$ac_objext\" && ac_objext=o\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$oldlib\"\nfi\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    AC_PATH_MAGIC\n  fi\n  ;;\nesac\n\nAC_PROVIDE_IFELSE([AC_LIBTOOL_DLOPEN], enable_dlopen=yes, enable_dlopen=no)\nAC_PROVIDE_IFELSE([AC_LIBTOOL_WIN32_DLL],\nenable_win32_dll=yes, enable_win32_dll=no)\n\nAC_ARG_ENABLE([libtool-lock],\n    [AC_HELP_STRING([--disable-libtool-lock],\n\t[avoid locking (might break parallel builds)])])\ntest \"x$enable_libtool_lock\" != xno && enable_libtool_lock=yes\n\nAC_ARG_WITH([pic],\n    [AC_HELP_STRING([--with-pic],\n\t[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],\n    [pic_mode=\"$withval\"],\n    [pic_mode=default])\ntest -z \"$pic_mode\" && pic_mode=default\n\n# Use C for the default configuration in the libtool script\ntagname=\nAC_LIBTOOL_LANG_C_CONFIG\n_LT_AC_TAGCONFIG\n])# AC_LIBTOOL_SETUP\n\n\n# _LT_AC_SYS_COMPILER\n# -------------------\nAC_DEFUN([_LT_AC_SYS_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_AC_SYS_COMPILER\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nAC_DEFUN([_LT_CC_BASENAME],\n[for cc_temp in $1\"\"; do\n  case $cc_temp in\n    compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n    distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n    \\-*) ;;\n    *) break;;\n  esac\ndone\ncc_basename=`$echo \"X$cc_temp\" | $Xsed -e 's%.*/%%' -e \"s%^$host_alias-%%\"`\n])\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nAC_DEFUN([_LT_COMPILER_BOILERPLATE],\n[AC_REQUIRE([LT_AC_PROG_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$rm conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nAC_DEFUN([_LT_LINKER_BOILERPLATE],\n[AC_REQUIRE([LT_AC_PROG_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$rm conftest*\n])# _LT_LINKER_BOILERPLATE\n\n\n# _LT_AC_SYS_LIBPATH_AIX\n# ----------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\nAC_DEFUN([_LT_AC_SYS_LIBPATH_AIX],\n[AC_REQUIRE([LT_AC_PROG_SED])dnl\nAC_LINK_IFELSE(AC_LANG_PROGRAM,[\nlt_aix_libpath_sed='\n    /Import File Strings/,/^$/ {\n\t/^0/ {\n\t    s/^0  *\\(.*\\)$/\\1/\n\t    p\n\t}\n    }'\naix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n# Check for a 64-bit object if we didn't find anything.\nif test -z \"$aix_libpath\"; then\n  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\nfi],[])\nif test -z \"$aix_libpath\"; then aix_libpath=\"/usr/lib:/lib\"; fi\n])# _LT_AC_SYS_LIBPATH_AIX\n\n\n# _LT_AC_SHELL_INIT(ARG)\n# ----------------------\nAC_DEFUN([_LT_AC_SHELL_INIT],\n[ifdef([AC_DIVERSION_NOTICE],\n\t     [AC_DIVERT_PUSH(AC_DIVERSION_NOTICE)],\n\t [AC_DIVERT_PUSH(NOTICE)])\n$1\nAC_DIVERT_POP\n])# _LT_AC_SHELL_INIT\n\n\n# _LT_AC_PROG_ECHO_BACKSLASH\n# --------------------------\n# Add some code to the start of the generated configure script which\n# will find an echo command which doesn't interpret backslashes.\nAC_DEFUN([_LT_AC_PROG_ECHO_BACKSLASH],\n[_LT_AC_SHELL_INIT([\n# Check that we are running under the correct shell.\nSHELL=${CONFIG_SHELL-/bin/sh}\n\ncase X$ECHO in\nX*--fallback-echo)\n  # Remove one level of quotation (which was required for Make).\n  ECHO=`echo \"$ECHO\" | sed 's,\\\\\\\\\\[$]\\\\[$]0,'[$]0','`\n  ;;\nesac\n\necho=${ECHO-echo}\nif test \"X[$]1\" = X--no-reexec; then\n  # Discard the --no-reexec flag, and continue.\n  shift\nelif test \"X[$]1\" = X--fallback-echo; then\n  # Avoid inline document here, it may be left over\n  :\nelif test \"X`($echo '\\t') 2>/dev/null`\" = 'X\\t' ; then\n  # Yippee, $echo works!\n  :\nelse\n  # Restart under the correct shell.\n  exec $SHELL \"[$]0\" --no-reexec ${1+\"[$]@\"}\nfi\n\nif test \"X[$]1\" = X--fallback-echo; then\n  # used as fallback echo\n  shift\n  cat <<EOF\n[$]*\nEOF\n  exit 0\nfi\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nif test -z \"$ECHO\"; then\nif test \"X${echo_test_string+set}\" != Xset; then\n# find a string as large as possible, as long as the shell can cope with it\n  for cmd in 'sed 50q \"[$]0\"' 'sed 20q \"[$]0\"' 'sed 10q \"[$]0\"' 'sed 2q \"[$]0\"' 'echo test'; do\n    # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...\n    if (echo_test_string=`eval $cmd`) 2>/dev/null &&\n       echo_test_string=`eval $cmd` &&\n       (test \"X$echo_test_string\" = \"X$echo_test_string\") 2>/dev/null\n    then\n      break\n    fi\n  done\nfi\n\nif test \"X`($echo '\\t') 2>/dev/null`\" = 'X\\t' &&\n   echo_testing_string=`($echo \"$echo_test_string\") 2>/dev/null` &&\n   test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n  :\nelse\n  # The Solaris, AIX, and Digital Unix default echo programs unquote\n  # backslashes.  This makes it impossible to quote backslashes using\n  #   echo \"$something\" | sed 's/\\\\/\\\\\\\\/g'\n  #\n  # So, first we look for a working echo in the user's PATH.\n\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for dir in $PATH /usr/ucb; do\n    IFS=\"$lt_save_ifs\"\n    if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&\n       test \"X`($dir/echo '\\t') 2>/dev/null`\" = 'X\\t' &&\n       echo_testing_string=`($dir/echo \"$echo_test_string\") 2>/dev/null` &&\n       test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n      echo=\"$dir/echo\"\n      break\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n\n  if test \"X$echo\" = Xecho; then\n    # We didn't find a better echo, so look for alternatives.\n    if test \"X`(print -r '\\t') 2>/dev/null`\" = 'X\\t' &&\n       echo_testing_string=`(print -r \"$echo_test_string\") 2>/dev/null` &&\n       test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n      # This shell has a builtin print -r that does the trick.\n      echo='print -r'\n    elif (test -f /bin/ksh || test -f /bin/ksh$ac_exeext) &&\n\t test \"X$CONFIG_SHELL\" != X/bin/ksh; then\n      # If we have ksh, try running configure again with it.\n      ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}\n      export ORIGINAL_CONFIG_SHELL\n      CONFIG_SHELL=/bin/ksh\n      export CONFIG_SHELL\n      exec $CONFIG_SHELL \"[$]0\" --no-reexec ${1+\"[$]@\"}\n    else\n      # Try using printf.\n      echo='printf %s\\n'\n      if test \"X`($echo '\\t') 2>/dev/null`\" = 'X\\t' &&\n\t echo_testing_string=`($echo \"$echo_test_string\") 2>/dev/null` &&\n\t test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\t# Cool, printf works\n\t:\n      elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL \"[$]0\" --fallback-echo '\\t') 2>/dev/null` &&\n\t   test \"X$echo_testing_string\" = 'X\\t' &&\n\t   echo_testing_string=`($ORIGINAL_CONFIG_SHELL \"[$]0\" --fallback-echo \"$echo_test_string\") 2>/dev/null` &&\n\t   test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\tCONFIG_SHELL=$ORIGINAL_CONFIG_SHELL\n\texport CONFIG_SHELL\n\tSHELL=\"$CONFIG_SHELL\"\n\texport SHELL\n\techo=\"$CONFIG_SHELL [$]0 --fallback-echo\"\n      elif echo_testing_string=`($CONFIG_SHELL \"[$]0\" --fallback-echo '\\t') 2>/dev/null` &&\n\t   test \"X$echo_testing_string\" = 'X\\t' &&\n\t   echo_testing_string=`($CONFIG_SHELL \"[$]0\" --fallback-echo \"$echo_test_string\") 2>/dev/null` &&\n\t   test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\techo=\"$CONFIG_SHELL [$]0 --fallback-echo\"\n      else\n\t# maybe with a smaller string...\n\tprev=:\n\n\tfor cmd in 'echo test' 'sed 2q \"[$]0\"' 'sed 10q \"[$]0\"' 'sed 20q \"[$]0\"' 'sed 50q \"[$]0\"'; do\n\t  if (test \"X$echo_test_string\" = \"X`eval $cmd`\") 2>/dev/null\n\t  then\n\t    break\n\t  fi\n\t  prev=\"$cmd\"\n\tdone\n\n\tif test \"$prev\" != 'sed 50q \"[$]0\"'; then\n\t  echo_test_string=`eval $prev`\n\t  export echo_test_string\n\t  exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} \"[$]0\" ${1+\"[$]@\"}\n\telse\n\t  # Oops.  We lost completely, so just stick with echo.\n\t  echo=echo\n\tfi\n      fi\n    fi\n  fi\nfi\nfi\n\n# Copy echo and quote the copy suitably for passing to libtool from\n# the Makefile, instead of quoting the original, which is used later.\nECHO=$echo\nif test \"X$ECHO\" = \"X$CONFIG_SHELL [$]0 --fallback-echo\"; then\n   ECHO=\"$CONFIG_SHELL \\\\\\$\\[$]0 --fallback-echo\"\nfi\n\nAC_SUBST(ECHO)\n])])# _LT_AC_PROG_ECHO_BACKSLASH\n\n\n# _LT_AC_LOCK\n# -----------\nAC_DEFUN([_LT_AC_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n    [AC_HELP_STRING([--disable-libtool-lock],\n\t[avoid locking (might break parallel builds)])])\ntest \"x$enable_libtool_lock\" != xno && enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n    *ELF-32*)\n      HPUX_IA64_MODE=\"32\"\n      ;;\n    *ELF-64*)\n      HPUX_IA64_MODE=\"64\"\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out which ABI we are using.\n  echo '[#]line __oline__ \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n   if test \"$lt_cv_prog_gnu_ld\" = yes; then\n    case `/usr/bin/file conftest.$ac_objext` in\n    *32-bit*)\n      LD=\"${LD-ld} -melf32bsmip\"\n      ;;\n    *N32*)\n      LD=\"${LD-ld} -melf32bmipn32\"\n      ;;\n    *64-bit*)\n      LD=\"${LD-ld} -melf64bmip\"\n      ;;\n    esac\n   else\n    case `/usr/bin/file conftest.$ac_objext` in\n    *32-bit*)\n      LD=\"${LD-ld} -32\"\n      ;;\n    *N32*)\n      LD=\"${LD-ld} -n32\"\n      ;;\n    *64-bit*)\n      LD=\"${LD-ld} -64\"\n      ;;\n    esac\n   fi\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|sparc*-*linux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *32-bit*)\n      case $host in\n        x86_64-*kfreebsd*-gnu)\n          LD=\"${LD-ld} -m elf_i386_fbsd\"\n          ;;\n        x86_64-*linux*)\n          LD=\"${LD-ld} -m elf_i386\"\n          ;;\n        ppc64-*linux*|powerpc64-*linux*)\n          LD=\"${LD-ld} -m elf32ppclinux\"\n          ;;\n        s390x-*linux*)\n          LD=\"${LD-ld} -m elf_s390\"\n          ;;\n        sparc64-*linux*)\n          LD=\"${LD-ld} -m elf32_sparc\"\n          ;;\n      esac\n      ;;\n    *64-bit*)\n      libsuff=64\n      case $host in\n        x86_64-*kfreebsd*-gnu)\n          LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n          ;;\n        x86_64-*linux*)\n          LD=\"${LD-ld} -m elf_x86_64\"\n          ;;\n        ppc*-*linux*|powerpc*-*linux*)\n          LD=\"${LD-ld} -m elf64ppc\"\n          ;;\n        s390*-*linux*)\n          LD=\"${LD-ld} -m elf64_s390\"\n          ;;\n        sparc*-*linux*)\n          LD=\"${LD-ld} -m elf64_sparc\"\n          ;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_TRY_LINK([],[],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=\"$SAVE_CFLAGS\"\n  fi\n  ;;\nsparc*-*solaris*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*) LD=\"${LD-ld} -m elf64_sparc\" ;;\n      *)    LD=\"${LD-ld} -64\" ;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\nAC_PROVIDE_IFELSE([AC_LIBTOOL_WIN32_DLL],\n[*-*-cygwin* | *-*-mingw* | *-*-pw32*)\n  AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n  AC_CHECK_TOOL(AS, as, false)\n  AC_CHECK_TOOL(OBJDUMP, objdump, false)\n  ;;\n  ])\nesac\n\nneed_locks=\"$enable_libtool_lock\"\n\n])# _LT_AC_LOCK\n\n\n# AC_LIBTOOL_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([AC_LIBTOOL_COMPILER_OPTION],\n[AC_REQUIRE([LT_AC_PROG_SED])\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n  ifelse([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:__oline__: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:__oline__: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $echo \"X$_lt_compiler_boilerplate\" | $Xsed -e '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $rm conftest*\n])\n\nif test x\"[$]$2\" = xyes; then\n    ifelse([$5], , :, [$5])\nelse\n    ifelse([$6], , :, [$6])\nfi\n])# AC_LIBTOOL_COMPILER_OPTION\n\n\n# AC_LIBTOOL_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                          [ACTION-SUCCESS], [ACTION-FAILURE])\n# ------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([AC_LIBTOOL_LINKER_OPTION],\n[AC_REQUIRE([LT_AC_PROG_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=\"$LDFLAGS\"\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $echo \"X$_lt_linker_boilerplate\" | $Xsed -e '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $rm conftest*\n   LDFLAGS=\"$save_LDFLAGS\"\n])\n\nif test x\"[$]$2\" = xyes; then\n    ifelse([$4], , :, [$4])\nelse\n    ifelse([$5], , :, [$5])\nfi\n])# AC_LIBTOOL_LINKER_OPTION\n\n\n# AC_LIBTOOL_SYS_MAX_CMD_LEN\n# --------------------------\nAC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN],\n[# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=\"ABCD\"\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[ \t]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      while (test \"X\"`$SHELL [$]0 --fallback-echo \"X$teststring\" 2>/dev/null` \\\n\t       = \"XX$teststring\") >/dev/null 2>&1 &&\n\t      new_result=`expr \"X$teststring\" : \".*\" 2>&1` &&\n\t      lt_cv_sys_max_cmd_len=$new_result &&\n\t      test $i != 17 # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on massive\n      # amounts of additional arguments before passing them to the linker.\n      # It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n $lt_cv_sys_max_cmd_len ; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\n])# AC_LIBTOOL_SYS_MAX_CMD_LEN\n\n\n# _LT_AC_CHECK_DLFCN\n# ------------------\nAC_DEFUN([_LT_AC_CHECK_DLFCN],\n[AC_CHECK_HEADERS(dlfcn.h)dnl\n])# _LT_AC_CHECK_DLFCN\n\n\n# _LT_AC_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                           ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ---------------------------------------------------------------------\nAC_DEFUN([_LT_AC_TRY_DLOPEN_SELF],\n[AC_REQUIRE([_LT_AC_CHECK_DLFCN])dnl\nif test \"$cross_compiling\" = yes; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<EOF\n[#line __oline__ \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" void exit (int);\n#endif\n\nvoid fnord() { int i=42;}\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else if (dlsym( self,\"_fnord\")) status = $lt_dlneed_uscore;\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n    exit (status);\n}]\nEOF\n  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_AC_TRY_DLOPEN_SELF\n\n\n# AC_LIBTOOL_DLOPEN_SELF\n# ----------------------\nAC_DEFUN([AC_LIBTOOL_DLOPEN_SELF],\n[AC_REQUIRE([_LT_AC_CHECK_DLFCN])dnl\nif test \"x$enable_dlopen\" != xyes; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=\"load_add_on\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32*)\n    lt_cv_dlopen=\"LoadLibrary\"\n    lt_cv_dlopen_libs=\n   ;;\n\n  cygwin*)\n    lt_cv_dlopen=\"dlopen\"\n    lt_cv_dlopen_libs=\n   ;;\n\n  darwin*)\n  # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],[\n    lt_cv_dlopen=\"dyld\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n   ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=\"shl_load\"],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=\"shl_load\" lt_cv_dlopen_libs=\"-dld\"],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=\"dlopen\"],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-lsvld\"],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=\"dld_link\" lt_cv_dlopen_libs=\"-dld\"])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test \"x$lt_cv_dlopen\" != xno; then\n    enable_dlopen=yes\n  else\n    enable_dlopen=no\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    test \"x$ac_cv_header_dlfcn_h\" = xyes && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=\"$LDFLAGS\"\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_AC_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test \"x$lt_cv_dlopen_self\" = xyes; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n    \t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_AC_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n])# AC_LIBTOOL_DLOPEN_SELF\n\n\n# AC_LIBTOOL_PROG_CC_C_O([TAGNAME])\n# ---------------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler\nAC_DEFUN([AC_LIBTOOL_PROG_CC_C_O],\n[AC_REQUIRE([LT_AC_PROG_SED])dnl\nAC_REQUIRE([_LT_AC_SYS_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_AC_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_AC_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $rm -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:__oline__: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:__oline__: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $echo \"X$_lt_compiler_boilerplate\" | $Xsed -e '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_AC_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $rm conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $rm out/ii_files/* && rmdir out/ii_files\n   $rm out/* && rmdir out\n   cd ..\n   rmdir conftest\n   $rm conftest*\n])\n])# AC_LIBTOOL_PROG_CC_C_O\n\n\n# AC_LIBTOOL_SYS_HARD_LINK_LOCKS([TAGNAME])\n# -----------------------------------------\n# Check to see if we can do hard links to lock some files if needed\nAC_DEFUN([AC_LIBTOOL_SYS_HARD_LINK_LOCKS],\n[AC_REQUIRE([_LT_AC_LOCK])dnl\n\nhard_links=\"nottested\"\nif test \"$_LT_AC_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" = no && test \"$need_locks\" != no; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $rm conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test \"$hard_links\" = no; then\n    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n])# AC_LIBTOOL_SYS_HARD_LINK_LOCKS\n\n\n# AC_LIBTOOL_OBJDIR\n# -----------------\nAC_DEFUN([AC_LIBTOOL_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n])# AC_LIBTOOL_OBJDIR\n\n\n# AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH([TAGNAME])\n# ----------------------------------------------\n# Check hardcoding attributes.\nAC_DEFUN([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_AC_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)\" || \\\n   test -n \"$_LT_AC_TAGVAR(runpath_var, $1)\" || \\\n   test \"X$_LT_AC_TAGVAR(hardcode_automatic, $1)\" = \"Xyes\" ; then\n\n  # We can hardcode non-existent directories.\n  if test \"$_LT_AC_TAGVAR(hardcode_direct, $1)\" != no &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test \"$_LT_AC_TAGVAR(hardcode_shlibpath_var, $1)\" != no &&\n     test \"$_LT_AC_TAGVAR(hardcode_minus_L, $1)\" != no; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_AC_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_AC_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_AC_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_AC_TAGVAR(hardcode_action, $1)])\n\nif test \"$_LT_AC_TAGVAR(hardcode_action, $1)\" = relink; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test \"$shlibpath_overrides_runpath\" = yes ||\n     test \"$enable_shared\" = no; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n])# AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH\n\n\n# AC_LIBTOOL_SYS_LIB_STRIP\n# ------------------------\nAC_DEFUN([AC_LIBTOOL_SYS_LIB_STRIP],\n[striplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | grep \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n   darwin*)\n       if test -n \"$STRIP\" ; then\n         striplib=\"$STRIP -x\"\n         old_striplib=\"$STRIP -S\"\n         AC_MSG_RESULT([yes])\n       else\n  AC_MSG_RESULT([no])\nfi\n       ;;\n   *)\n  AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n])# AC_LIBTOOL_SYS_LIB_STRIP\n\n\n# AC_LIBTOOL_SYS_DYNAMIC_LINKER\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nAC_DEFUN([AC_LIBTOOL_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([LT_AC_PROG_SED])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=\".so\"\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nm4_if($1,[],[\nif test \"$GCC\" = yes; then\n  case $host_os in\n    darwin*) lt_awk_arg=\"/^libraries:/,/LR/\" ;;\n    *) lt_awk_arg=\"/^libraries:/\" ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e \"s,=/,/,g\"`\n  if echo \"$lt_search_path_spec\" | grep ';' >/dev/null ; then\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`echo \"$lt_search_path_spec\" | $SED -e 's/;/ /g'`\n  else\n    lt_search_path_spec=`echo \"$lt_search_path_spec\" | $SED  -e \"s/$PATH_SEPARATOR/ /g\"`\n  fi\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary.\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path/$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir\"\n    else\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`echo $lt_tmp_lt_search_path_spec | awk '\nBEGIN {RS=\" \"; FS=\"/|\\n\";} {\n  lt_foo=\"\";\n  lt_count=0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo=\"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  sys_lib_search_path_spec=`echo $lt_search_path_spec`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\ncase $host_os in\naix3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='${libname}${release}${shared_ext}$major'\n  ;;\n\naix4* | aix5*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test \"$host_cpu\" = ia64; then\n    # AIX 5 supports IA64\n    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line `#! .'.  This would cause the generated library to\n    # depend on `.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | ${CC} -E - | grep yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    if test \"$aix_use_runtimelinking\" = yes; then\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    else\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='${libname}${release}.a $libname.a'\n      soname_spec='${libname}${release}${shared_ext}$major'\n    fi\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  library_names_spec='$libname.ixlibrary $libname.a'\n  # Create ${libname}_ixlibrary.a entries in /sys/libs.\n  finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$echo \"X$lib\" | $Xsed -e '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; test $rm /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n  ;;\n\nbeos*)\n  library_names_spec='${libname}${shared_ext}'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32*)\n  version_type=windows\n  shrext_cmds=\".dll\"\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$host_os in\n  yes,cygwin* | yes,mingw* | yes,pw32*)\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i;echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $rm \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      sys_lib_search_path_spec=\"/usr/lib /lib/w32api /lib /usr/local/lib\"\n      ;;\n    mingw*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      sys_lib_search_path_spec=`$CC -print-search-dirs | grep \"^libraries:\" | $SED -e \"s/^libraries://\" -e \"s,=/,/,g\"`\n      if echo \"$sys_lib_search_path_spec\" | [grep ';[c-zC-Z]:/' >/dev/null]; then\n        # It is most probably a Windows format PATH printed by\n        # mingw gcc, but we are running on Cygwin. Gcc prints its search\n        # path with ; separators, and with drive letters. We can handle the\n        # drive letters (cygwin fileutils understands them), so leave them,\n        # especially as we might pass files found there to a mingw objdump,\n        # which wouldn't understand a cygwinified path. Ahh.\n        sys_lib_search_path_spec=`echo \"$sys_lib_search_path_spec\" | $SED -e 's/;/ /g'`\n      else\n        sys_lib_search_path_spec=`echo \"$sys_lib_search_path_spec\" | $SED  -e \"s/$PATH_SEPARATOR/ /g\"`\n      fi\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    esac\n    ;;\n\n  *)\n    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'\n    ;;\n  esac\n  dynamic_linker='Win32 ld.exe'\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${versuffix}$shared_ext ${libname}${release}${major}$shared_ext ${libname}$shared_ext'\n  soname_spec='${libname}${release}${major}$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\n  m4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"]) \n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd1*)\n  dynamic_linker=no\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[123]]*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\ngnu*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    if test \"X$HPUX_IA64_MODE\" = X32; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n    fi\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n   hppa*64*)\n     shrext_cmds='.sl'\n     hardcode_into_libs=yes\n     dynamic_linker=\"$host_os dld.sl\"\n     shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n     shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n     library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n     soname_spec='${libname}${release}${shared_ext}$major'\n     sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n     sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n     ;;\n   *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555.\n  postinstall_cmds='chmod 555 $lib'\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test \"$lt_cv_prog_gnu_ld\" = yes; then\n\t\tversion_type=linux\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib${libsuff} /lib${libsuff}\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n  sys_lib_search_path_spec=\"/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib${libsuff} /lib${libsuff}\"\n\n  # Append ld.so.conf contents to the search path\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[ \t]*hwcap[ \t]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"$sys_lib_dlsearch_path_spec $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\nnto-qnx*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\nopenbsd*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=\"/usr/lib\"\n  need_lib_prefix=no\n  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.\n  case $host_os in\n    openbsd3.3 | openbsd3.3.*) need_version=yes ;;\n    *)                         need_version=no  ;;\n  esac\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    case $host_os in\n      openbsd2.[[89]] | openbsd2.[[89]].*)\n\tshlibpath_overrides_runpath=no\n\t;;\n      *)\n\tshlibpath_overrides_runpath=yes\n\t;;\n      esac\n  else\n    shlibpath_overrides_runpath=yes\n  fi\n  ;;\n\nos2*)\n  libname_spec='$name'\n  shrext_cmds=\".dll\"\n  need_lib_prefix=no\n  library_names_spec='$libname${shared_ext} $libname.a'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=LIBPATH\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=\"$sys_lib_search_path_spec\"\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test \"$with_gnu_ld\" = yes; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      export_dynamic_flag_spec='${wl}-Blargedynsym'\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec ;then\n    version_type=linux\n    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'\n    soname_spec='$libname${shared_ext}.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=freebsd-elf\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  hardcode_into_libs=yes\n  if test \"$with_gnu_ld\" = yes; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n    shlibpath_overrides_runpath=no\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    shlibpath_overrides_runpath=yes\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\nuts4*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest \"$dynamic_linker\" = no && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test \"$GCC\" = yes; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n])# AC_LIBTOOL_SYS_DYNAMIC_LINKER\n\n\n# _LT_AC_TAGCONFIG\n# ----------------\nAC_DEFUN([_LT_AC_TAGCONFIG],\n[AC_REQUIRE([LT_AC_PROG_SED])dnl\nAC_ARG_WITH([tags],\n    [AC_HELP_STRING([--with-tags@<:@=TAGS@:>@],\n        [include additional configurations @<:@automatic@:>@])],\n    [tagnames=\"$withval\"])\n\nif test -f \"$ltmain\" && test -n \"$tagnames\"; then\n  if test ! -f \"${ofile}\"; then\n    AC_MSG_WARN([output file `$ofile' does not exist])\n  fi\n\n  if test -z \"$LTCC\"; then\n    eval \"`$SHELL ${ofile} --config | grep '^LTCC='`\"\n    if test -z \"$LTCC\"; then\n      AC_MSG_WARN([output file `$ofile' does not look like a libtool script])\n    else\n      AC_MSG_WARN([using `LTCC=$LTCC', extracted from `$ofile'])\n    fi\n  fi\n  if test -z \"$LTCFLAGS\"; then\n    eval \"`$SHELL ${ofile} --config | grep '^LTCFLAGS='`\"\n  fi\n\n  # Extract list of available tagged configurations in $ofile.\n  # Note that this assumes the entire list is on one line.\n  available_tags=`grep \"^available_tags=\" \"${ofile}\" | $SED -e 's/available_tags=\\(.*$\\)/\\1/' -e 's/\\\"//g'`\n\n  lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n  for tagname in $tagnames; do\n    IFS=\"$lt_save_ifs\"\n    # Check whether tagname contains only valid characters\n    case `$echo \"X$tagname\" | $Xsed -e 's:[[-_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890,/]]::g'` in\n    \"\") ;;\n    *)  AC_MSG_ERROR([invalid tag name: $tagname])\n\t;;\n    esac\n\n    if grep \"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname$\" < \"${ofile}\" > /dev/null\n    then\n      AC_MSG_ERROR([tag name \\\"$tagname\\\" already exists])\n    fi\n\n    # Update the list of available tags.\n    if test -n \"$tagname\"; then\n      echo appending configuration tag \\\"$tagname\\\" to $ofile\n\n      case $tagname in\n      CXX)\n\tif test -n \"$CXX\" && ( test \"X$CXX\" != \"Xno\" &&\n\t    ( (test \"X$CXX\" = \"Xg++\" && `g++ -v >/dev/null 2>&1` ) ||\n\t    (test \"X$CXX\" != \"Xg++\"))) ; then\n\t  AC_LIBTOOL_LANG_CXX_CONFIG\n\telse\n\t  tagname=\"\"\n\tfi\n\t;;\n\n      F77)\n\tif test -n \"$F77\" && test \"X$F77\" != \"Xno\"; then\n\t  AC_LIBTOOL_LANG_F77_CONFIG\n\telse\n\t  tagname=\"\"\n\tfi\n\t;;\n\n      GCJ)\n\tif test -n \"$GCJ\" && test \"X$GCJ\" != \"Xno\"; then\n\t  AC_LIBTOOL_LANG_GCJ_CONFIG\n\telse\n\t  tagname=\"\"\n\tfi\n\t;;\n\n      RC)\n\tAC_LIBTOOL_LANG_RC_CONFIG\n\t;;\n\n      *)\n\tAC_MSG_ERROR([Unsupported tag name: $tagname])\n\t;;\n      esac\n\n      # Append the new tag name to the list of available tags.\n      if test -n \"$tagname\" ; then\n      available_tags=\"$available_tags $tagname\"\n    fi\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n\n  # Now substitute the updated list of available tags.\n  if eval \"sed -e 's/^available_tags=.*\\$/available_tags=\\\"$available_tags\\\"/' \\\"$ofile\\\" > \\\"${ofile}T\\\"\"; then\n    mv \"${ofile}T\" \"$ofile\"\n    chmod +x \"$ofile\"\n  else\n    rm -f \"${ofile}T\"\n    AC_MSG_ERROR([unable to update list of available tagged configurations.])\n  fi\nfi\n])# _LT_AC_TAGCONFIG\n\n\n# AC_LIBTOOL_DLOPEN\n# -----------------\n# enable checks for dlopen support\nAC_DEFUN([AC_LIBTOOL_DLOPEN],\n [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])\n])# AC_LIBTOOL_DLOPEN\n\n\n# AC_LIBTOOL_WIN32_DLL\n# --------------------\n# declare package support for building win32 DLLs\nAC_DEFUN([AC_LIBTOOL_WIN32_DLL],\n[AC_BEFORE([$0], [AC_LIBTOOL_SETUP])\n])# AC_LIBTOOL_WIN32_DLL\n\n\n# AC_ENABLE_SHARED([DEFAULT])\n# ---------------------------\n# implement the --enable-shared flag\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nAC_DEFUN([AC_ENABLE_SHARED],\n[define([AC_ENABLE_SHARED_DEFAULT], ifelse($1, no, no, yes))dnl\nAC_ARG_ENABLE([shared],\n    [AC_HELP_STRING([--enable-shared@<:@=PKGS@:>@],\n\t[build shared libraries @<:@default=]AC_ENABLE_SHARED_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_shared=yes ;;\n    no) enable_shared=no ;;\n    *)\n      enable_shared=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_shared=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_shared=]AC_ENABLE_SHARED_DEFAULT)\n])# AC_ENABLE_SHARED\n\n\n# AC_DISABLE_SHARED\n# -----------------\n# set the default shared flag to --disable-shared\nAC_DEFUN([AC_DISABLE_SHARED],\n[AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\nAC_ENABLE_SHARED(no)\n])# AC_DISABLE_SHARED\n\n\n# AC_ENABLE_STATIC([DEFAULT])\n# ---------------------------\n# implement the --enable-static flag\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nAC_DEFUN([AC_ENABLE_STATIC],\n[define([AC_ENABLE_STATIC_DEFAULT], ifelse($1, no, no, yes))dnl\nAC_ARG_ENABLE([static],\n    [AC_HELP_STRING([--enable-static@<:@=PKGS@:>@],\n\t[build static libraries @<:@default=]AC_ENABLE_STATIC_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_static=yes ;;\n    no) enable_static=no ;;\n    *)\n     enable_static=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_static=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_static=]AC_ENABLE_STATIC_DEFAULT)\n])# AC_ENABLE_STATIC\n\n\n# AC_DISABLE_STATIC\n# -----------------\n# set the default static flag to --disable-static\nAC_DEFUN([AC_DISABLE_STATIC],\n[AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\nAC_ENABLE_STATIC(no)\n])# AC_DISABLE_STATIC\n\n\n# AC_ENABLE_FAST_INSTALL([DEFAULT])\n# ---------------------------------\n# implement the --enable-fast-install flag\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nAC_DEFUN([AC_ENABLE_FAST_INSTALL],\n[define([AC_ENABLE_FAST_INSTALL_DEFAULT], ifelse($1, no, no, yes))dnl\nAC_ARG_ENABLE([fast-install],\n    [AC_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],\n    [optimize for fast installation @<:@default=]AC_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_fast_install=yes ;;\n    no) enable_fast_install=no ;;\n    *)\n      enable_fast_install=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_fast_install=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_fast_install=]AC_ENABLE_FAST_INSTALL_DEFAULT)\n])# AC_ENABLE_FAST_INSTALL\n\n\n# AC_DISABLE_FAST_INSTALL\n# -----------------------\n# set the default to --disable-fast-install\nAC_DEFUN([AC_DISABLE_FAST_INSTALL],\n[AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\nAC_ENABLE_FAST_INSTALL(no)\n])# AC_DISABLE_FAST_INSTALL\n\n\n# AC_LIBTOOL_PICMODE([MODE])\n# --------------------------\n# implement the --with-pic flag\n# MODE is either `yes' or `no'.  If omitted, it defaults to `both'.\nAC_DEFUN([AC_LIBTOOL_PICMODE],\n[AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\npic_mode=ifelse($#,1,$1,default)\n])# AC_LIBTOOL_PICMODE\n\n\n# AC_PROG_EGREP\n# -------------\n# This is predefined starting with Autoconf 2.54, so this conditional\n# definition can be removed once we require Autoconf 2.54 or later.\nm4_ifndef([AC_PROG_EGREP], [AC_DEFUN([AC_PROG_EGREP],\n[AC_CACHE_CHECK([for egrep], [ac_cv_prog_egrep],\n   [if echo a | (grep -E '(a|b)') >/dev/null 2>&1\n    then ac_cv_prog_egrep='grep -E'\n    else ac_cv_prog_egrep='egrep'\n    fi])\n EGREP=$ac_cv_prog_egrep\n AC_SUBST([EGREP])\n])])\n\n\n# AC_PATH_TOOL_PREFIX\n# -------------------\n# find a file program which can recognize shared library\nAC_DEFUN([AC_PATH_TOOL_PREFIX],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=\"$MAGIC_CMD\" # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=\"$MAGIC_CMD\"\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"ifelse([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f $ac_dir/$1; then\n      lt_cv_path_MAGIC_CMD=\"$ac_dir/$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\nEOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n  MAGIC_CMD=\"$lt_save_MAGIC_CMD\"\n  ;;\nesac])\nMAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n])# AC_PATH_TOOL_PREFIX\n\n\n# AC_PATH_MAGIC\n# -------------\n# find a file program which can recognize a shared library\nAC_DEFUN([AC_PATH_MAGIC],\n[AC_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    AC_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# AC_PATH_MAGIC\n\n\n# AC_PROG_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([AC_PROG_LD],\n[AC_ARG_WITH([gnu-ld],\n    [AC_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test \"$withval\" = no || with_gnu_ld=yes],\n    [with_gnu_ld=no])\nAC_REQUIRE([LT_AC_PROG_SED])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`echo $ac_prog| $SED 's%\\\\\\\\%/%g'`\n      while echo $ac_prog | grep \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`echo $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest \"$with_gnu_ld\" != no && break\n\t;;\n      *)\n\ttest \"$with_gnu_ld\" != yes && break\n\t;;\n      esac\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\nelse\n  lt_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$lt_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\nAC_PROG_LD_GNU\n])# AC_PROG_LD\n\n\n# AC_PROG_LD_GNU\n# --------------\nAC_DEFUN([AC_PROG_LD_GNU],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# AC_PROG_LD_GNU\n\n\n# AC_PROG_LD_RELOAD_FLAG\n# ----------------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nAC_DEFUN([AC_PROG_LD_RELOAD_FLAG],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  darwin*)\n    if test \"$GCC\" = yes; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n])# AC_PROG_LD_RELOAD_FLAG\n\n\n# AC_DEPLIBS_CHECK_METHOD\n# -----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nAC_DEFUN([AC_DEPLIBS_CHECK_METHOD],\n[AC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# `unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# which responds to the $file_magic_cmd with a given extended regex.\n# If you have `file' or equivalent on your system and you're not sure\n# whether `pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix4* | aix5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  if ( file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\ngnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - PA-RISC [0-9].[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]].[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd*)\n  if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\nnto-qnx*)\n  lt_cv_deplibs_check_method=unknown\n  ;;\n\nopenbsd*)\n  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n])# AC_DEPLIBS_CHECK_METHOD\n\n\n# AC_PROG_NM\n# ----------\n# find the pathname to a BSD-compatible name lister\nAC_DEFUN([AC_PROG_NM],\n[AC_CACHE_CHECK([for BSD-compatible nm], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=\"$NM\"\nelse\n  lt_nm_to_check=\"${ac_tool_prefix}nm\"\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=\"$lt_save_ifs\"\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=\"$ac_dir/$lt_tmp_nm\"\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\" ; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the `sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\tcase `\"$tmp_nm\" -B /dev/null 2>&1 | sed '1q'` in\n\t*/dev/null* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n  done\n  test -z \"$lt_cv_path_NM\" && lt_cv_path_NM=nm\nfi])\nNM=\"$lt_cv_path_NM\"\n])# AC_PROG_NM\n\n\n# AC_CHECK_LIBM\n# -------------\n# check for math library\nAC_DEFUN([AC_CHECK_LIBM],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cygwin* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=\"-lm\")\n  ;;\nesac\n])# AC_CHECK_LIBM\n\n\n# AC_LIBLTDL_CONVENIENCE([DIRECTORY])\n# -----------------------------------\n# sets LIBLTDL to the link flags for the libltdl convenience library and\n# LTDLINCL to the include flags for the libltdl header and adds\n# --enable-ltdl-convenience to the configure arguments.  Note that\n# AC_CONFIG_SUBDIRS is not called here.  If DIRECTORY is not provided,\n# it is assumed to be `libltdl'.  LIBLTDL will be prefixed with\n# '${top_builddir}/' and LTDLINCL will be prefixed with '${top_srcdir}/'\n# (note the single quotes!).  If your package is not flat and you're not\n# using automake, define top_builddir and top_srcdir appropriately in\n# the Makefiles.\nAC_DEFUN([AC_LIBLTDL_CONVENIENCE],\n[AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n  case $enable_ltdl_convenience in\n  no) AC_MSG_ERROR([this package needs a convenience libltdl]) ;;\n  \"\") enable_ltdl_convenience=yes\n      ac_configure_args=\"$ac_configure_args --enable-ltdl-convenience\" ;;\n  esac\n  LIBLTDL='${top_builddir}/'ifelse($#,1,[$1],['libltdl'])/libltdlc.la\n  LTDLINCL='-I${top_srcdir}/'ifelse($#,1,[$1],['libltdl'])\n  # For backwards non-gettext consistent compatibility...\n  INCLTDL=\"$LTDLINCL\"\n])# AC_LIBLTDL_CONVENIENCE\n\n\n# AC_LIBLTDL_INSTALLABLE([DIRECTORY])\n# -----------------------------------\n# sets LIBLTDL to the link flags for the libltdl installable library and\n# LTDLINCL to the include flags for the libltdl header and adds\n# --enable-ltdl-install to the configure arguments.  Note that\n# AC_CONFIG_SUBDIRS is not called here.  If DIRECTORY is not provided,\n# and an installed libltdl is not found, it is assumed to be `libltdl'.\n# LIBLTDL will be prefixed with '${top_builddir}/'# and LTDLINCL with\n# '${top_srcdir}/' (note the single quotes!).  If your package is not\n# flat and you're not using automake, define top_builddir and top_srcdir\n# appropriately in the Makefiles.\n# In the future, this macro may have to be called after AC_PROG_LIBTOOL.\nAC_DEFUN([AC_LIBLTDL_INSTALLABLE],\n[AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n  AC_CHECK_LIB(ltdl, lt_dlinit,\n  [test x\"$enable_ltdl_install\" != xyes && enable_ltdl_install=no],\n  [if test x\"$enable_ltdl_install\" = xno; then\n     AC_MSG_WARN([libltdl not installed, but installation disabled])\n   else\n     enable_ltdl_install=yes\n   fi\n  ])\n  if test x\"$enable_ltdl_install\" = x\"yes\"; then\n    ac_configure_args=\"$ac_configure_args --enable-ltdl-install\"\n    LIBLTDL='${top_builddir}/'ifelse($#,1,[$1],['libltdl'])/libltdl.la\n    LTDLINCL='-I${top_srcdir}/'ifelse($#,1,[$1],['libltdl'])\n  else\n    ac_configure_args=\"$ac_configure_args --enable-ltdl-install=no\"\n    LIBLTDL=\"-lltdl\"\n    LTDLINCL=\n  fi\n  # For backwards non-gettext consistent compatibility...\n  INCLTDL=\"$LTDLINCL\"\n])# AC_LIBLTDL_INSTALLABLE\n\n\n# AC_LIBTOOL_CXX\n# --------------\n# enable support for C++ libraries\nAC_DEFUN([AC_LIBTOOL_CXX],\n[AC_REQUIRE([_LT_AC_LANG_CXX])\n])# AC_LIBTOOL_CXX\n\n\n# _LT_AC_LANG_CXX\n# ---------------\nAC_DEFUN([_LT_AC_LANG_CXX],\n[AC_REQUIRE([AC_PROG_CXX])\nAC_REQUIRE([_LT_AC_PROG_CXXCPP])\n_LT_AC_SHELL_INIT([tagnames=${tagnames+${tagnames},}CXX])\n])# _LT_AC_LANG_CXX\n\n# _LT_AC_PROG_CXXCPP\n# ------------------\nAC_DEFUN([_LT_AC_PROG_CXXCPP],\n[\nAC_REQUIRE([AC_PROG_CXX])\nif test -n \"$CXX\" && ( test \"X$CXX\" != \"Xno\" &&\n    ( (test \"X$CXX\" = \"Xg++\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test \"X$CXX\" != \"Xg++\"))) ; then\n  AC_PROG_CXXCPP\nfi\n])# _LT_AC_PROG_CXXCPP\n\n# AC_LIBTOOL_F77\n# --------------\n# enable support for Fortran 77 libraries\nAC_DEFUN([AC_LIBTOOL_F77],\n[AC_REQUIRE([_LT_AC_LANG_F77])\n])# AC_LIBTOOL_F77\n\n\n# _LT_AC_LANG_F77\n# ---------------\nAC_DEFUN([_LT_AC_LANG_F77],\n[AC_REQUIRE([AC_PROG_F77])\n_LT_AC_SHELL_INIT([tagnames=${tagnames+${tagnames},}F77])\n])# _LT_AC_LANG_F77\n\n\n# AC_LIBTOOL_GCJ\n# --------------\n# enable support for GCJ libraries\nAC_DEFUN([AC_LIBTOOL_GCJ],\n[AC_REQUIRE([_LT_AC_LANG_GCJ])\n])# AC_LIBTOOL_GCJ\n\n\n# _LT_AC_LANG_GCJ\n# ---------------\nAC_DEFUN([_LT_AC_LANG_GCJ],\n[AC_PROVIDE_IFELSE([AC_PROG_GCJ],[],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],[],\n    [AC_PROVIDE_IFELSE([LT_AC_PROG_GCJ],[],\n      [ifdef([AC_PROG_GCJ],[AC_REQUIRE([AC_PROG_GCJ])],\n\t [ifdef([A][M_PROG_GCJ],[AC_REQUIRE([A][M_PROG_GCJ])],\n\t   [AC_REQUIRE([A][C_PROG_GCJ_OR_A][M_PROG_GCJ])])])])])])\n_LT_AC_SHELL_INIT([tagnames=${tagnames+${tagnames},}GCJ])\n])# _LT_AC_LANG_GCJ\n\n\n# AC_LIBTOOL_RC\n# -------------\n# enable support for Windows resource files\nAC_DEFUN([AC_LIBTOOL_RC],\n[AC_REQUIRE([LT_AC_PROG_RC])\n_LT_AC_SHELL_INIT([tagnames=${tagnames+${tagnames},}RC])\n])# AC_LIBTOOL_RC\n\n\n# AC_LIBTOOL_LANG_C_CONFIG\n# ------------------------\n# Ensure that the configuration vars for the C compiler are\n# suitably defined.  Those variables are subsequently used by\n# AC_LIBTOOL_CONFIG to write the compiler configuration to `libtool'.\nAC_DEFUN([AC_LIBTOOL_LANG_C_CONFIG], [_LT_AC_LANG_C_CONFIG])\nAC_DEFUN([_LT_AC_LANG_C_CONFIG],\n[lt_save_CC=\"$CC\"\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_AC_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_AC_SYS_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\nAC_LIBTOOL_PROG_COMPILER_NO_RTTI($1)\nAC_LIBTOOL_PROG_COMPILER_PIC($1)\nAC_LIBTOOL_PROG_CC_C_O($1)\nAC_LIBTOOL_SYS_HARD_LINK_LOCKS($1)\nAC_LIBTOOL_PROG_LD_SHLIBS($1)\nAC_LIBTOOL_SYS_DYNAMIC_LINKER($1)\nAC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH($1)\nAC_LIBTOOL_SYS_LIB_STRIP\nAC_LIBTOOL_DLOPEN_SELF\n\n# Report which library types will actually be built\nAC_MSG_CHECKING([if libtool supports shared libraries])\nAC_MSG_RESULT([$can_build_shared])\n\nAC_MSG_CHECKING([whether to build shared libraries])\ntest \"$can_build_shared\" = \"no\" && enable_shared=no\n\n# On AIX, shared libraries and static libraries use the same namespace, and\n# are all built from PIC.\ncase $host_os in\naix3*)\n  test \"$enable_shared\" = yes && enable_static=no\n  if test -n \"$RANLIB\"; then\n    archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n    postinstall_cmds='$RANLIB $lib'\n  fi\n  ;;\n\naix4* | aix5*)\n  if test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n    test \"$enable_shared\" = yes && enable_static=no\n  fi\n    ;;\nesac\nAC_MSG_RESULT([$enable_shared])\n\nAC_MSG_CHECKING([whether to build static libraries])\n# Make sure either enable_shared or enable_static is yes.\ntest \"$enable_shared\" = yes || enable_static=yes\nAC_MSG_RESULT([$enable_static])\n\nAC_LIBTOOL_CONFIG($1)\n\nAC_LANG_POP\nCC=\"$lt_save_CC\"\n])# AC_LIBTOOL_LANG_C_CONFIG\n\n\n# AC_LIBTOOL_LANG_CXX_CONFIG\n# --------------------------\n# Ensure that the configuration vars for the C compiler are\n# suitably defined.  Those variables are subsequently used by\n# AC_LIBTOOL_CONFIG to write the compiler configuration to `libtool'.\nAC_DEFUN([AC_LIBTOOL_LANG_CXX_CONFIG], [_LT_AC_LANG_CXX_CONFIG(CXX)])\nAC_DEFUN([_LT_AC_LANG_CXX_CONFIG],\n[AC_LANG_PUSH(C++)\nAC_REQUIRE([AC_PROG_CXX])\nAC_REQUIRE([_LT_AC_PROG_CXXCPP])\n\n_LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_AC_TAGVAR(allow_undefined_flag, $1)=\n_LT_AC_TAGVAR(always_export_symbols, $1)=no\n_LT_AC_TAGVAR(archive_expsym_cmds, $1)=\n_LT_AC_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_AC_TAGVAR(hardcode_direct, $1)=no\n_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_AC_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_AC_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_AC_TAGVAR(hardcode_minus_L, $1)=no\n_LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_AC_TAGVAR(hardcode_automatic, $1)=no\n_LT_AC_TAGVAR(module_cmds, $1)=\n_LT_AC_TAGVAR(module_expsym_cmds, $1)=\n_LT_AC_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_AC_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_AC_TAGVAR(no_undefined_flag, $1)=\n_LT_AC_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_AC_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Dependencies to place before and after the object being linked:\n_LT_AC_TAGVAR(predep_objects, $1)=\n_LT_AC_TAGVAR(postdep_objects, $1)=\n_LT_AC_TAGVAR(predeps, $1)=\n_LT_AC_TAGVAR(postdeps, $1)=\n_LT_AC_TAGVAR(compiler_lib_search_path, $1)=\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_AC_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_AC_SYS_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_LD=$LD\nlt_save_GCC=$GCC\nGCC=$GXX\nlt_save_with_gnu_ld=$with_gnu_ld\nlt_save_path_LD=$lt_cv_path_LD\nif test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n  lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\nelse\n  $as_unset lt_cv_prog_gnu_ld\nfi\nif test -n \"${lt_cv_path_LDCXX+set}\"; then\n  lt_cv_path_LD=$lt_cv_path_LDCXX\nelse\n  $as_unset lt_cv_path_LD\nfi\ntest -z \"${LDCXX+set}\" || LD=$LDCXX\nCC=${CXX-\"c++\"}\ncompiler=$CC\n_LT_AC_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n\n# We don't want -fno-exception wen compiling C++ code, so set the\n# no_builtin_flag separately\nif test \"$GXX\" = yes; then\n  _LT_AC_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\nelse\n  _LT_AC_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\nfi\n\nif test \"$GXX\" = yes; then\n  # Set up default GNU C++ configuration\n\n  AC_PROG_LD\n\n  # Check if GNU C++ uses GNU ld as the underlying linker, since the\n  # archiving commands below assume that GNU ld is being used.\n  if test \"$with_gnu_ld\" = yes; then\n    _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n    _LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\n    _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n    _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n    #     investigate it a little bit more. (MM)\n    wlarc='${wl}'\n\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if eval \"`$CC -print-prog-name=ld` --help 2>&1\" | \\\n\tgrep 'no-whole-archive' > /dev/null; then\n      _LT_AC_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n    else\n      _LT_AC_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    with_gnu_ld=no\n    wlarc=\n\n    # A generic and very simple default shared library creation\n    # command for GNU C++ for the case where it uses the native\n    # linker, instead of GNU ld.  If possible, this setting should\n    # overridden to take advantage of the native linker features on\n    # the platform it is being used on.\n    _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n  fi\n\n  # Commands to make compiler produce verbose output that lists\n  # what \"hidden\" libraries, object files and flags are used when\n  # linking a shared library.\n  output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep \"\\-L\"'\n\nelse\n  GXX=no\n  with_gnu_ld=no\n  wlarc=\nfi\n\n# PORTME: fill in a description of your system's C++ link characteristics\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n_LT_AC_TAGVAR(ld_shlibs, $1)=yes\ncase $host_os in\n  aix3*)\n    # FIXME: insert proper C++ library support\n    _LT_AC_TAGVAR(ld_shlibs, $1)=no\n    ;;\n  aix4* | aix5*)\n    if test \"$host_cpu\" = ia64; then\n      # On IA64, the linker does run time linking by default, so we don't\n      # have to do anything special.\n      aix_use_runtimelinking=no\n      exp_sym_flag='-Bexport'\n      no_entry_flag=\"\"\n    else\n      aix_use_runtimelinking=no\n\n      # Test if we are trying to use run time linking or normal\n      # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n      # need to do runtime linking.\n      case $host_os in aix4.[[23]]|aix4.[[23]].*|aix5*)\n\tfor ld_flag in $LDFLAGS; do\n\t  case $ld_flag in\n\t  *-brtl*)\n\t    aix_use_runtimelinking=yes\n\t    break\n\t    ;;\n\t  esac\n\tdone\n\t;;\n      esac\n\n      exp_sym_flag='-bexport'\n      no_entry_flag='-bnoentry'\n    fi\n\n    # When large executables or shared objects are built, AIX ld can\n    # have problems creating the table of contents.  If linking a library\n    # or program results in \"error TOC overflow\" add -mminimal-toc to\n    # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n    # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n    _LT_AC_TAGVAR(archive_cmds, $1)=''\n    _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n    _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=':'\n    _LT_AC_TAGVAR(link_all_deplibs, $1)=yes\n\n    if test \"$GXX\" = yes; then\n      case $host_os in aix4.[[012]]|aix4.[[012]].*)\n      # We only want to do this on AIX 4.2 and lower, the check\n      # below for broken collect2 doesn't work under 4.3+\n\tcollect2name=`${CC} -print-prog-name=collect2`\n\tif test -f \"$collect2name\" && \\\n\t   strings \"$collect2name\" | grep resolve_lib_name >/dev/null\n\tthen\n\t  # We have reworked collect2\n\t  :\n\telse\n\t  # We have old collect2\n\t  _LT_AC_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=\n\tfi\n\t;;\n      esac\n      shared_flag='-shared'\n      if test \"$aix_use_runtimelinking\" = yes; then\n\tshared_flag=\"$shared_flag \"'${wl}-G'\n      fi\n    else\n      # not using gcc\n      if test \"$host_cpu\" = ia64; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\tshared_flag='-G'\n      else\n\tif test \"$aix_use_runtimelinking\" = yes; then\n\t  shared_flag='${wl}-G'\n\telse\n\t  shared_flag='${wl}-bM:SRE'\n\tfi\n      fi\n    fi\n\n    # It seems that -bexpall does not export symbols beginning with\n    # underscore (_), so it is better to generate a list of symbols to export.\n    _LT_AC_TAGVAR(always_export_symbols, $1)=yes\n    if test \"$aix_use_runtimelinking\" = yes; then\n      # Warning - without using the other runtime loading flags (-brtl),\n      # -berok will link without error, but may produce a broken library.\n      _LT_AC_TAGVAR(allow_undefined_flag, $1)='-berok'\n      # Determine the default libpath from the value encoded in an empty executable.\n      _LT_AC_SYS_LIBPATH_AIX\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\n      _LT_AC_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then echo \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n     else\n      if test \"$host_cpu\" = ia64; then\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t_LT_AC_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n      else\n\t# Determine the default libpath from the value encoded in an empty executable.\n\t_LT_AC_SYS_LIBPATH_AIX\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t# Warning - without using the other run time loading flags,\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_AC_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t_LT_AC_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t# Exported symbols can be pulled into shared objects from archives\n\t_LT_AC_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t_LT_AC_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t# This is similar to how AIX traditionally builds its shared libraries.\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n      fi\n    fi\n    ;;\n\n  beos*)\n    if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then\n      _LT_AC_TAGVAR(allow_undefined_flag, $1)=unsupported\n      # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n      # support --undefined.  This deserves some investigation.  FIXME\n      _LT_AC_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n    else\n      _LT_AC_TAGVAR(ld_shlibs, $1)=no\n    fi\n    ;;\n\n  chorus*)\n    case $cc_basename in\n      *)\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n    esac\n    ;;\n\n  cygwin* | mingw* | pw32*)\n    # _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n    # as there is no search path for DLLs.\n    _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n    _LT_AC_TAGVAR(allow_undefined_flag, $1)=unsupported\n    _LT_AC_TAGVAR(always_export_symbols, $1)=no\n    _LT_AC_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n    if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then\n      _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      # If the export-symbols file already is a .def file (1st line\n      # is EXPORTS), use it as is; otherwise, prepend...\n      _LT_AC_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\tcp $export_symbols $output_objdir/$soname.def;\n      else\n\techo EXPORTS > $output_objdir/$soname.def;\n\tcat $export_symbols >> $output_objdir/$soname.def;\n      fi~\n      $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n    else\n      _LT_AC_TAGVAR(ld_shlibs, $1)=no\n    fi\n  ;;\n      darwin* | rhapsody*)\n        case $host_os in\n        rhapsody* | darwin1.[[012]])\n         _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-undefined ${wl}suppress'\n         ;;\n       *) # Darwin 1.3 on\n         if test -z ${MACOSX_DEPLOYMENT_TARGET} ; then\n           _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'\n         else\n           case ${MACOSX_DEPLOYMENT_TARGET} in\n             10.[[012]])\n               _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'\n               ;;\n             10.*)\n               _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-undefined ${wl}dynamic_lookup'\n               ;;\n           esac\n         fi\n         ;;\n        esac\n      _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_AC_TAGVAR(hardcode_direct, $1)=no\n      _LT_AC_TAGVAR(hardcode_automatic, $1)=yes\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n      _LT_AC_TAGVAR(whole_archive_flag_spec, $1)=''\n      _LT_AC_TAGVAR(link_all_deplibs, $1)=yes\n\n    if test \"$GXX\" = yes ; then\n      lt_int_apple_cc_single_mod=no\n      output_verbose_link_cmd='echo'\n      if $CC -dumpspecs 2>&1 | $EGREP 'single_module' >/dev/null ; then\n       lt_int_apple_cc_single_mod=yes\n      fi\n      if test \"X$lt_int_apple_cc_single_mod\" = Xyes ; then\n       _LT_AC_TAGVAR(archive_cmds, $1)='$CC -dynamiclib -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'\n      else\n          _LT_AC_TAGVAR(archive_cmds, $1)='$CC -r -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs~$CC -dynamiclib $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'\n        fi\n        _LT_AC_TAGVAR(module_cmds, $1)='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'\n        # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds\n          if test \"X$lt_int_apple_cc_single_mod\" = Xyes ; then\n            _LT_AC_TAGVAR(archive_expsym_cmds, $1)='sed -e \"s,#.*,,\" -e \"s,^[    ]*,,\" -e \"s,^\\(..*\\),_&,\" < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -dynamiclib -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'\n          else\n            _LT_AC_TAGVAR(archive_expsym_cmds, $1)='sed -e \"s,#.*,,\" -e \"s,^[    ]*,,\" -e \"s,^\\(..*\\),_&,\" < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -r -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs~$CC -dynamiclib $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'\n          fi\n            _LT_AC_TAGVAR(module_expsym_cmds, $1)='sed -e \"s,#.*,,\" -e \"s,^[    ]*,,\" -e \"s,^\\(..*\\),_&,\" < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'\n      else\n      case $cc_basename in\n        xlc*)\n         output_verbose_link_cmd='echo'\n          _LT_AC_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj ${wl}-single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}`echo $rpath/$soname` $xlcverstring'\n          _LT_AC_TAGVAR(module_cmds, $1)='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'\n          # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds\n          _LT_AC_TAGVAR(archive_expsym_cmds, $1)='sed -e \"s,#.*,,\" -e \"s,^[    ]*,,\" -e \"s,^\\(..*\\),_&,\" < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -qmkshrobj ${wl}-single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}$rpath/$soname $xlcverstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'\n          _LT_AC_TAGVAR(module_expsym_cmds, $1)='sed -e \"s,#.*,,\" -e \"s,^[    ]*,,\" -e \"s,^\\(..*\\),_&,\" < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'\n          ;;\n       *)\n         _LT_AC_TAGVAR(ld_shlibs, $1)=no\n          ;;\n      esac\n      fi\n        ;;\n\n  dgux*)\n    case $cc_basename in\n      ec++*)\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n      ghcx*)\n\t# Green Hills C++ Compiler\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n      *)\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n    esac\n    ;;\n  freebsd[[12]]*)\n    # C++ shared libraries reported to be fairly broken before switch to ELF\n    _LT_AC_TAGVAR(ld_shlibs, $1)=no\n    ;;\n  freebsd-elf*)\n    _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n    ;;\n  freebsd* | dragonfly*)\n    # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n    # conventions\n    _LT_AC_TAGVAR(ld_shlibs, $1)=yes\n    ;;\n  gnu*)\n    ;;\n  hpux9*)\n    _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n    _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n    _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n    _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n    _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t# but as the default\n\t\t\t\t# location of the library.\n\n    case $cc_basename in\n    CC*)\n      # FIXME: insert proper C++ library support\n      _LT_AC_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    aCC*)\n      _LT_AC_TAGVAR(archive_cmds, $1)='$rm $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      #\n      # There doesn't appear to be a way to prevent this compiler from\n      # explicitly linking system object files so we need to strip them\n      # from the output so that they don't get included in the library\n      # dependencies.\n      output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | grep \"[[-]]L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; echo $list'\n      ;;\n    *)\n      if test \"$GXX\" = yes; then\n        _LT_AC_TAGVAR(archive_cmds, $1)='$rm $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      else\n        # FIXME: insert proper C++ library support\n        _LT_AC_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n    ;;\n  hpux10*|hpux11*)\n    if test $with_gnu_ld = no; then\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n      _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n\n      case $host_cpu in\n      hppa*64*|ia64*) ;;\n      *)\n\t_LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n        ;;\n      esac\n    fi\n    case $host_cpu in\n    hppa*64*|ia64*)\n      _LT_AC_TAGVAR(hardcode_direct, $1)=no\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n    *)\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n      _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t      # but as the default\n\t\t\t\t\t      # location of the library.\n      ;;\n    esac\n\n    case $cc_basename in\n      CC*)\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n      aCC*)\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t  ;;\n\tesac\n\t# Commands to make compiler produce verbose output that lists\n\t# what \"hidden\" libraries, object files and flags are used when\n\t# linking a shared library.\n\t#\n\t# There doesn't appear to be a way to prevent this compiler from\n\t# explicitly linking system object files so we need to strip them\n\t# from the output so that they don't get included in the library\n\t# dependencies.\n\toutput_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | grep \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; echo $list'\n\t;;\n      *)\n\tif test \"$GXX\" = yes; then\n\t  if test $with_gnu_ld = no; then\n\t    case $host_cpu in\n\t    hppa*64*)\n\t      _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      ;;\n\t    ia64*)\n\t      _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      ;;\n\t    *)\n\t      _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      ;;\n\t    esac\n\t  fi\n\telse\n\t  # FIXME: insert proper C++ library support\n\t  _LT_AC_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n    esac\n    ;;\n  interix[[3-9]]*)\n    _LT_AC_TAGVAR(hardcode_direct, $1)=no\n    _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n    _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n    _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n    # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n    # Instead, shared libraries are loaded at an image base (0x10000000 by\n    # default) and relocated if they conflict, which is a slow very memory\n    # consuming and fragmenting process.  To avoid this, we pick a random,\n    # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n    # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n    _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n    _LT_AC_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n    ;;\n  irix5* | irix6*)\n    case $cc_basename in\n      CC*)\n\t# SGI C++\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'\n\n\t# Archives containing C++ object files must be created using\n\t# \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t# necessary to make sure instantiated templates are included\n\t# in the archive.\n\t_LT_AC_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t;;\n      *)\n\tif test \"$GXX\" = yes; then\n\t  if test \"$with_gnu_ld\" = no; then\n\t    _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t  else\n\t    _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && echo ${wl}-set_version ${wl}$verstring` -o $lib'\n\t  fi\n\tfi\n\t_LT_AC_TAGVAR(link_all_deplibs, $1)=yes\n\t;;\n    esac\n    _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n    _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n    ;;\n  linux* | k*bsd*-gnu)\n    case $cc_basename in\n      KCC*)\n\t# Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t# KCC will only create a shared library if the output file\n\t# ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t# to its proper name (with version) after linking.\n\t_LT_AC_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib ${wl}-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t# Commands to make compiler produce verbose output that lists\n\t# what \"hidden\" libraries, object files and flags are used when\n\t# linking a shared library.\n\t#\n\t# There doesn't appear to be a way to prevent this compiler from\n\t# explicitly linking system object files so we need to strip them\n\t# from the output so that they don't get included in the library\n\t# dependencies.\n\toutput_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | grep \"ld\"`; rm -f libconftest$shared_ext; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; echo $list'\n\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath,$libdir'\n\t_LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n\t# Archives containing C++ object files must be created using\n\t# \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t_LT_AC_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t;;\n      icpc*)\n\t# Intel C++\n\twith_gnu_ld=yes\n\t# version 8.0 and above of icpc choke on multiply defined symbols\n\t# if we add $predep_objects and $postdep_objects, however 7.1 and\n\t# earlier do not add the objects themselves.\n\tcase `$CC -V 2>&1` in\n\t*\"Version 7.\"*)\n  \t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n  \t  _LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t  ;;\n\t*)  # Version 8.0 or newer\n\t  tmp_idyn=\n\t  case $host_cpu in\n\t    ia64*) tmp_idyn=' -i_dynamic';;\n\t  esac\n  \t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t  _LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t  ;;\n\tesac\n\t_LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t_LT_AC_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t;;\n      pgCC*)\n        # Portland Group C++ compiler\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n  \t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n\t_LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t_LT_AC_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $echo \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n        ;;\n      cxx*)\n\t# Compaq C++\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'\n\n\trunpath_var=LD_RUN_PATH\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t_LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t# Commands to make compiler produce verbose output that lists\n\t# what \"hidden\" libraries, object files and flags are used when\n\t# linking a shared library.\n\t#\n\t# There doesn't appear to be a way to prevent this compiler from\n\t# explicitly linking system object files so we need to strip them\n\t# from the output so that they don't get included in the library\n\t# dependencies.\n\toutput_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep \"ld\"`; templist=`echo $templist | $SED \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; echo $list'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\n\t  # Sun C++ 5.9\n\t  _LT_AC_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t  _LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'\n\t  _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_AC_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; $echo \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\n\t  # Not sure whether something based on\n\t  # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t  # would be better.\n\t  output_verbose_link_cmd='echo'\n\n\t  # Archives containing C++ object files must be created using\n\t  # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t  # necessary to make sure instantiated templates are included\n\t  # in the archive.\n\t  _LT_AC_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t  ;;\n\tesac\n\t;;\n    esac\n    ;;\n  lynxos*)\n    # FIXME: insert proper C++ library support\n    _LT_AC_TAGVAR(ld_shlibs, $1)=no\n    ;;\n  m88k*)\n    # FIXME: insert proper C++ library support\n    _LT_AC_TAGVAR(ld_shlibs, $1)=no\n    ;;\n  mvs*)\n    case $cc_basename in\n      cxx*)\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n      *)\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n    esac\n    ;;\n  netbsd*)\n    if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then\n      _LT_AC_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n      wlarc=\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n    fi\n    # Workaround some broken pre-1.5 toolchains\n    output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n    ;;\n  openbsd2*)\n    # C++ shared libraries are fairly broken\n    _LT_AC_TAGVAR(ld_shlibs, $1)=no\n    ;;\n  openbsd*)\n    if test -f /usr/libexec/ld.so; then\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n      if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'\n\t_LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t_LT_AC_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n      fi\n      output_verbose_link_cmd='echo'\n    else\n      _LT_AC_TAGVAR(ld_shlibs, $1)=no\n    fi\n    ;;\n  osf3*)\n    case $cc_basename in\n      KCC*)\n\t# Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t# KCC will only create a shared library if the output file\n\t# ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t# to its proper name (with version) after linking.\n\t_LT_AC_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t# Archives containing C++ object files must be created using\n\t# \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t_LT_AC_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\n\t;;\n      RCC*)\n\t# Rational C++ 2.4.1\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n      cxx*)\n\t_LT_AC_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n \"$verstring\" && echo ${wl}-set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'\n\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t_LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t# Commands to make compiler produce verbose output that lists\n\t# what \"hidden\" libraries, object files and flags are used when\n\t# linking a shared library.\n\t#\n\t# There doesn't appear to be a way to prevent this compiler from\n\t# explicitly linking system object files so we need to strip them\n\t# from the output so that they don't get included in the library\n\t# dependencies.\n\toutput_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep \"ld\" | grep -v \"ld:\"`; templist=`echo $templist | $SED \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; echo $list'\n\t;;\n      *)\n\tif test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t  _LT_AC_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\n\t  _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t  _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t  # Commands to make compiler produce verbose output that lists\n\t  # what \"hidden\" libraries, object files and flags are used when\n\t  # linking a shared library.\n\t  output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep \"\\-L\"'\n\n\telse\n\t  # FIXME: insert proper C++ library support\n\t  _LT_AC_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n    esac\n    ;;\n  osf4* | osf5*)\n    case $cc_basename in\n      KCC*)\n\t# Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t# KCC will only create a shared library if the output file\n\t# ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t# to its proper name (with version) after linking.\n\t_LT_AC_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t# Archives containing C++ object files must be created using\n\t# the KAI C++ compiler.\n\t_LT_AC_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs'\n\t;;\n      RCC*)\n\t# Rational C++ 2.4.1\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n      cxx*)\n\t_LT_AC_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n\t  echo \"-hidden\">> $lib.exp~\n\t  $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname -Wl,-input -Wl,$lib.exp  `test -n \"$verstring\" && echo -set_version\t$verstring` -update_registry ${output_objdir}/so_locations -o $lib~\n\t  $rm $lib.exp'\n\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t_LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t# Commands to make compiler produce verbose output that lists\n\t# what \"hidden\" libraries, object files and flags are used when\n\t# linking a shared library.\n\t#\n\t# There doesn't appear to be a way to prevent this compiler from\n\t# explicitly linking system object files so we need to strip them\n\t# from the output so that they don't get included in the library\n\t# dependencies.\n\toutput_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep \"ld\" | grep -v \"ld:\"`; templist=`echo $templist | $SED \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; echo $list'\n\t;;\n      *)\n\tif test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t  _LT_AC_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\n\t  _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t  _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t  # Commands to make compiler produce verbose output that lists\n\t  # what \"hidden\" libraries, object files and flags are used when\n\t  # linking a shared library.\n\t  output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep \"\\-L\"'\n\n\telse\n\t  # FIXME: insert proper C++ library support\n\t  _LT_AC_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n    esac\n    ;;\n  psos*)\n    # FIXME: insert proper C++ library support\n    _LT_AC_TAGVAR(ld_shlibs, $1)=no\n    ;;\n  sunos4*)\n    case $cc_basename in\n      CC*)\n\t# Sun C++ 4.x\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n      lcc*)\n\t# Lucid\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n      *)\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n    esac\n    ;;\n  solaris*)\n    case $cc_basename in\n      CC*)\n\t# Sun C++ 4.2, 5.x and Centerline C++\n        _LT_AC_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t_LT_AC_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~$echo \"local: *; };\" >> $lib.exp~\n\t$CC -G${allow_undefined_flag}  ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$rm $lib.exp'\n\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t_LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tcase $host_os in\n\t  solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t  *)\n\t    # The compiler driver will combine and reorder linker options,\n\t    # but understands `-z linker_flag'.\n\t    # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t    _LT_AC_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t    ;;\n\tesac\n\t_LT_AC_TAGVAR(link_all_deplibs, $1)=yes\n\n\toutput_verbose_link_cmd='echo'\n\n\t# Archives containing C++ object files must be created using\n\t# \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t# necessary to make sure instantiated templates are included\n\t# in the archive.\n\t_LT_AC_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t;;\n      gcx*)\n\t# Green Hills C++ Compiler\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\n\t# The C++ compiler must be used to create the archive.\n\t_LT_AC_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t;;\n      *)\n\t# GNU C++ compiler with Solaris linker\n\tif test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t  _LT_AC_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'\n\t  if $CC --version | grep -v '^2\\.7' > /dev/null; then\n\t    _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t    _LT_AC_TAGVAR(archive_expsym_cmds, $1)='$echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~$echo \"local: *; };\" >> $lib.exp~\n\t\t$CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$rm $lib.exp'\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    output_verbose_link_cmd=\"$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep \\\"\\-L\\\"\"\n\t  else\n\t    # g++ 2.7 appears to require `-G' NOT `-shared' on this\n\t    # platform.\n\t    _LT_AC_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t    _LT_AC_TAGVAR(archive_expsym_cmds, $1)='$echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~$echo \"local: *; };\" >> $lib.exp~\n\t\t$CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$rm $lib.exp'\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    output_verbose_link_cmd=\"$CC -G $CFLAGS -v conftest.$objext 2>&1 | grep \\\"\\-L\\\"\"\n\t  fi\n\n\t  _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'\n\t  case $host_os in\n\t  solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t  *)\n\t    _LT_AC_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\t    ;;\n\t  esac\n\tfi\n\t;;\n    esac\n    ;;\n  sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n    _LT_AC_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n    _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n    _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n    runpath_var='LD_RUN_PATH'\n\n    case $cc_basename in\n      CC*)\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t;;\n      *)\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t;;\n    esac\n    ;;\n  sysv5* | sco3.2v5* | sco5v6*)\n    # Note: We can NOT use -z defs as we might desire, because we do not\n    # link with -lc, and that would cause any symbols used from libc to\n    # always be unresolved, which means just about no library would\n    # ever link correctly.  If we're not using GNU ld we use -z text\n    # though, which does catch some bad symbols but isn't as heavy-handed\n    # as -z defs.\n    # For security reasons, it is highly recommended that you always\n    # use absolute paths for naming shared libraries, and exclude the\n    # DT_RUNPATH tag from executables and libraries.  But doing so\n    # requires that you compile everything twice, which is a pain.\n    # So that behaviour is only enabled if SCOABSPATH is set to a\n    # non-empty value in the environment.  Most likely only useful for\n    # creating official distributions of packages.\n    # This is a hack until libtool officially supports absolute path\n    # names for shared libraries.\n    _LT_AC_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n    _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n    _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n    _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n    _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='`test -z \"$SCOABSPATH\" && echo ${wl}-R,$libdir`'\n    _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=':'\n    _LT_AC_TAGVAR(link_all_deplibs, $1)=yes\n    _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n    runpath_var='LD_RUN_PATH'\n\n    case $cc_basename in\n      CC*)\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,\\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,\\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t;;\n      *)\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,\\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,\\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t;;\n    esac\n    ;;\n  tandem*)\n    case $cc_basename in\n      NCC*)\n\t# NonStop-UX NCC 3.20\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n      *)\n\t# FIXME: insert proper C++ library support\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t;;\n    esac\n    ;;\n  vxworks*)\n    # FIXME: insert proper C++ library support\n    _LT_AC_TAGVAR(ld_shlibs, $1)=no\n    ;;\n  *)\n    # FIXME: insert proper C++ library support\n    _LT_AC_TAGVAR(ld_shlibs, $1)=no\n    ;;\nesac\nAC_MSG_RESULT([$_LT_AC_TAGVAR(ld_shlibs, $1)])\ntest \"$_LT_AC_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n_LT_AC_TAGVAR(GCC, $1)=\"$GXX\"\n_LT_AC_TAGVAR(LD, $1)=\"$LD\"\n\nAC_LIBTOOL_POSTDEP_PREDEP($1)\nAC_LIBTOOL_PROG_COMPILER_PIC($1)\nAC_LIBTOOL_PROG_CC_C_O($1)\nAC_LIBTOOL_SYS_HARD_LINK_LOCKS($1)\nAC_LIBTOOL_PROG_LD_SHLIBS($1)\nAC_LIBTOOL_SYS_DYNAMIC_LINKER($1)\nAC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH($1)\n\nAC_LIBTOOL_CONFIG($1)\n\nAC_LANG_POP\nCC=$lt_save_CC\nLDCXX=$LD\nLD=$lt_save_LD\nGCC=$lt_save_GCC\nwith_gnu_ldcxx=$with_gnu_ld\nwith_gnu_ld=$lt_save_with_gnu_ld\nlt_cv_path_LDCXX=$lt_cv_path_LD\nlt_cv_path_LD=$lt_save_path_LD\nlt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\nlt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\n])# AC_LIBTOOL_LANG_CXX_CONFIG\n\n# AC_LIBTOOL_POSTDEP_PREDEP([TAGNAME])\n# ------------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nAC_DEFUN([AC_LIBTOOL_POSTDEP_PREDEP],[\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nifelse([$1],[],[cat > conftest.$ac_ext <<EOF\nint a;\nvoid foo (void) { a = 0; }\nEOF\n],[$1],[CXX],[cat > conftest.$ac_ext <<EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\nEOF\n],[$1],[F77],[cat > conftest.$ac_ext <<EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\nEOF\n],[$1],[GCJ],[cat > conftest.$ac_ext <<EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\nEOF\n])\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  # The `*' in the case matches for architectures that use `case' in\n  # $output_verbose_cmd can trigger glob expansion during the loop\n  # eval without this substitution.\n  output_verbose_link_cmd=`$echo \"X$output_verbose_link_cmd\" | $Xsed -e \"$no_glob_subst\"`\n\n  for p in `eval $output_verbose_link_cmd`; do\n    case $p in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test $p = \"-L\" \\\n\t  || test $p = \"-R\"; then\n\t prev=$p\n\t continue\n       else\n\t prev=\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t case $p in\n\t -L* | -R*)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_AC_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_AC_TAGVAR(compiler_lib_search_path, $1)=\"${prev}${p}\"\n\t   else\n\t     _LT_AC_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_AC_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_AC_TAGVAR(postdeps, $1)\"; then\n\t   _LT_AC_TAGVAR(postdeps, $1)=\"${prev}${p}\"\n\t else\n\t   _LT_AC_TAGVAR(postdeps, $1)=\"${_LT_AC_TAGVAR(postdeps, $1)} ${prev}${p}\"\n\t fi\n       fi\n       ;;\n\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t if test -z \"$_LT_AC_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_AC_TAGVAR(predep_objects, $1)=\"$p\"\n\t else\n\t   _LT_AC_TAGVAR(predep_objects, $1)=\"$_LT_AC_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_AC_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_AC_TAGVAR(postdep_objects, $1)=\"$p\"\n\t else\n\t   _LT_AC_TAGVAR(postdep_objects, $1)=\"$_LT_AC_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$rm -f confest.$objext\n\n# PORTME: override above test on systems where it is broken\nifelse([$1],[CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_AC_TAGVAR(predep_objects,$1)=\n  _LT_AC_TAGVAR(postdep_objects,$1)=\n  _LT_AC_TAGVAR(postdeps,$1)=\n  ;;\n\nlinux*)\n  case `$CC -V 2>&1 | sed 5q` in\n  *Sun\\ C*)\n    # Sun C++ 5.9\n    #\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_AC_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\n\nsolaris*)\n  case $cc_basename in\n  CC*)\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    # Adding this requires a known-good setup of shared libraries for\n    # Sun compiler versions before 5.6, else PIC objects from an old\n    # archive will be linked into the output, leading to subtle bugs.\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_AC_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\nesac\n])\n\ncase \" $_LT_AC_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n])# AC_LIBTOOL_POSTDEP_PREDEP\n\n# AC_LIBTOOL_LANG_F77_CONFIG\n# --------------------------\n# Ensure that the configuration vars for the C compiler are\n# suitably defined.  Those variables are subsequently used by\n# AC_LIBTOOL_CONFIG to write the compiler configuration to `libtool'.\nAC_DEFUN([AC_LIBTOOL_LANG_F77_CONFIG], [_LT_AC_LANG_F77_CONFIG(F77)])\nAC_DEFUN([_LT_AC_LANG_F77_CONFIG],\n[AC_REQUIRE([AC_PROG_F77])\nAC_LANG_PUSH(Fortran 77)\n\n_LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_AC_TAGVAR(allow_undefined_flag, $1)=\n_LT_AC_TAGVAR(always_export_symbols, $1)=no\n_LT_AC_TAGVAR(archive_expsym_cmds, $1)=\n_LT_AC_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_AC_TAGVAR(hardcode_direct, $1)=no\n_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_AC_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_AC_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_AC_TAGVAR(hardcode_minus_L, $1)=no\n_LT_AC_TAGVAR(hardcode_automatic, $1)=no\n_LT_AC_TAGVAR(module_cmds, $1)=\n_LT_AC_TAGVAR(module_expsym_cmds, $1)=\n_LT_AC_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_AC_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_AC_TAGVAR(no_undefined_flag, $1)=\n_LT_AC_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_AC_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_AC_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_AC_SYS_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nCC=${F77-\"f77\"}\ncompiler=$CC\n_LT_AC_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n\nAC_MSG_CHECKING([if libtool supports shared libraries])\nAC_MSG_RESULT([$can_build_shared])\n\nAC_MSG_CHECKING([whether to build shared libraries])\ntest \"$can_build_shared\" = \"no\" && enable_shared=no\n\n# On AIX, shared libraries and static libraries use the same namespace, and\n# are all built from PIC.\ncase $host_os in\naix3*)\n  test \"$enable_shared\" = yes && enable_static=no\n  if test -n \"$RANLIB\"; then\n    archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n    postinstall_cmds='$RANLIB $lib'\n  fi\n  ;;\naix4* | aix5*)\n  if test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n    test \"$enable_shared\" = yes && enable_static=no\n  fi\n  ;;\nesac\nAC_MSG_RESULT([$enable_shared])\n\nAC_MSG_CHECKING([whether to build static libraries])\n# Make sure either enable_shared or enable_static is yes.\ntest \"$enable_shared\" = yes || enable_static=yes\nAC_MSG_RESULT([$enable_static])\n\n_LT_AC_TAGVAR(GCC, $1)=\"$G77\"\n_LT_AC_TAGVAR(LD, $1)=\"$LD\"\n\nAC_LIBTOOL_PROG_COMPILER_PIC($1)\nAC_LIBTOOL_PROG_CC_C_O($1)\nAC_LIBTOOL_SYS_HARD_LINK_LOCKS($1)\nAC_LIBTOOL_PROG_LD_SHLIBS($1)\nAC_LIBTOOL_SYS_DYNAMIC_LINKER($1)\nAC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH($1)\n\nAC_LIBTOOL_CONFIG($1)\n\nAC_LANG_POP\nCC=\"$lt_save_CC\"\n])# AC_LIBTOOL_LANG_F77_CONFIG\n\n\n# AC_LIBTOOL_LANG_GCJ_CONFIG\n# --------------------------\n# Ensure that the configuration vars for the C compiler are\n# suitably defined.  Those variables are subsequently used by\n# AC_LIBTOOL_CONFIG to write the compiler configuration to `libtool'.\nAC_DEFUN([AC_LIBTOOL_LANG_GCJ_CONFIG], [_LT_AC_LANG_GCJ_CONFIG(GCJ)])\nAC_DEFUN([_LT_AC_LANG_GCJ_CONFIG],\n[AC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_AC_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_AC_SYS_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nCC=${GCJ-\"gcj\"}\ncompiler=$CC\n_LT_AC_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_AC_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n\nAC_LIBTOOL_PROG_COMPILER_NO_RTTI($1)\nAC_LIBTOOL_PROG_COMPILER_PIC($1)\nAC_LIBTOOL_PROG_CC_C_O($1)\nAC_LIBTOOL_SYS_HARD_LINK_LOCKS($1)\nAC_LIBTOOL_PROG_LD_SHLIBS($1)\nAC_LIBTOOL_SYS_DYNAMIC_LINKER($1)\nAC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH($1)\n\nAC_LIBTOOL_CONFIG($1)\n\nAC_LANG_RESTORE\nCC=\"$lt_save_CC\"\n])# AC_LIBTOOL_LANG_GCJ_CONFIG\n\n\n# AC_LIBTOOL_LANG_RC_CONFIG\n# -------------------------\n# Ensure that the configuration vars for the Windows resource compiler are\n# suitably defined.  Those variables are subsequently used by\n# AC_LIBTOOL_CONFIG to write the compiler configuration to `libtool'.\nAC_DEFUN([AC_LIBTOOL_LANG_RC_CONFIG], [_LT_AC_LANG_RC_CONFIG(RC)])\nAC_DEFUN([_LT_AC_LANG_RC_CONFIG],\n[AC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_AC_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=\"$lt_simple_compile_test_code\"\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_AC_SYS_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nCC=${RC-\"windres\"}\ncompiler=$CC\n_LT_AC_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_AC_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nAC_LIBTOOL_CONFIG($1)\n\nAC_LANG_RESTORE\nCC=\"$lt_save_CC\"\n])# AC_LIBTOOL_LANG_RC_CONFIG\n\n\n# AC_LIBTOOL_CONFIG([TAGNAME])\n# ----------------------------\n# If TAGNAME is not passed, then create an initial libtool script\n# with a default configuration from the untagged config vars.  Otherwise\n# add code to config.status for appending the configuration named by\n# TAGNAME from the matching tagged config vars.\nAC_DEFUN([AC_LIBTOOL_CONFIG],\n[# The else clause should only fire when bootstrapping the\n# libtool distribution, otherwise you forgot to ship ltmain.sh\n# with your package, and you will get complaints that there are\n# no rules to generate ltmain.sh.\nif test -f \"$ltmain\"; then\n  # See if we are running on zsh, and set the options which allow our commands through\n  # without removal of \\ escapes.\n  if test -n \"${ZSH_VERSION+set}\" ; then\n    setopt NO_GLOB_SUBST\n  fi\n  # Now quote all the things that may contain metacharacters while being\n  # careful not to overquote the AC_SUBSTed values.  We take copies of the\n  # variables and quote the copies for generation of the libtool script.\n  for var in echo old_CC old_CFLAGS AR AR_FLAGS EGREP RANLIB LN_S LTCC LTCFLAGS NM \\\n    SED SHELL STRIP \\\n    libname_spec library_names_spec soname_spec extract_expsyms_cmds \\\n    old_striplib striplib file_magic_cmd finish_cmds finish_eval \\\n    deplibs_check_method reload_flag reload_cmds need_locks \\\n    lt_cv_sys_global_symbol_pipe lt_cv_sys_global_symbol_to_cdecl \\\n    lt_cv_sys_global_symbol_to_c_name_address \\\n    sys_lib_search_path_spec sys_lib_dlsearch_path_spec \\\n    old_postinstall_cmds old_postuninstall_cmds \\\n    _LT_AC_TAGVAR(compiler, $1) \\\n    _LT_AC_TAGVAR(CC, $1) \\\n    _LT_AC_TAGVAR(LD, $1) \\\n    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1) \\\n    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1) \\\n    _LT_AC_TAGVAR(lt_prog_compiler_static, $1) \\\n    _LT_AC_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) \\\n    _LT_AC_TAGVAR(export_dynamic_flag_spec, $1) \\\n    _LT_AC_TAGVAR(thread_safe_flag_spec, $1) \\\n    _LT_AC_TAGVAR(whole_archive_flag_spec, $1) \\\n    _LT_AC_TAGVAR(enable_shared_with_static_runtimes, $1) \\\n    _LT_AC_TAGVAR(old_archive_cmds, $1) \\\n    _LT_AC_TAGVAR(old_archive_from_new_cmds, $1) \\\n    _LT_AC_TAGVAR(predep_objects, $1) \\\n    _LT_AC_TAGVAR(postdep_objects, $1) \\\n    _LT_AC_TAGVAR(predeps, $1) \\\n    _LT_AC_TAGVAR(postdeps, $1) \\\n    _LT_AC_TAGVAR(compiler_lib_search_path, $1) \\\n    _LT_AC_TAGVAR(archive_cmds, $1) \\\n    _LT_AC_TAGVAR(archive_expsym_cmds, $1) \\\n    _LT_AC_TAGVAR(postinstall_cmds, $1) \\\n    _LT_AC_TAGVAR(postuninstall_cmds, $1) \\\n    _LT_AC_TAGVAR(old_archive_from_expsyms_cmds, $1) \\\n    _LT_AC_TAGVAR(allow_undefined_flag, $1) \\\n    _LT_AC_TAGVAR(no_undefined_flag, $1) \\\n    _LT_AC_TAGVAR(export_symbols_cmds, $1) \\\n    _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1) \\\n    _LT_AC_TAGVAR(hardcode_libdir_flag_spec_ld, $1) \\\n    _LT_AC_TAGVAR(hardcode_libdir_separator, $1) \\\n    _LT_AC_TAGVAR(hardcode_automatic, $1) \\\n    _LT_AC_TAGVAR(module_cmds, $1) \\\n    _LT_AC_TAGVAR(module_expsym_cmds, $1) \\\n    _LT_AC_TAGVAR(lt_cv_prog_compiler_c_o, $1) \\\n    _LT_AC_TAGVAR(fix_srcfile_path, $1) \\\n    _LT_AC_TAGVAR(exclude_expsyms, $1) \\\n    _LT_AC_TAGVAR(include_expsyms, $1); do\n\n    case $var in\n    _LT_AC_TAGVAR(old_archive_cmds, $1) | \\\n    _LT_AC_TAGVAR(old_archive_from_new_cmds, $1) | \\\n    _LT_AC_TAGVAR(archive_cmds, $1) | \\\n    _LT_AC_TAGVAR(archive_expsym_cmds, $1) | \\\n    _LT_AC_TAGVAR(module_cmds, $1) | \\\n    _LT_AC_TAGVAR(module_expsym_cmds, $1) | \\\n    _LT_AC_TAGVAR(old_archive_from_expsyms_cmds, $1) | \\\n    _LT_AC_TAGVAR(export_symbols_cmds, $1) | \\\n    extract_expsyms_cmds | reload_cmds | finish_cmds | \\\n    postinstall_cmds | postuninstall_cmds | \\\n    old_postinstall_cmds | old_postuninstall_cmds | \\\n    sys_lib_search_path_spec | sys_lib_dlsearch_path_spec)\n      # Double-quote double-evaled strings.\n      eval \"lt_$var=\\\\\\\"\\`\\$echo \\\"X\\$$var\\\" | \\$Xsed -e \\\"\\$double_quote_subst\\\" -e \\\"\\$sed_quote_subst\\\" -e \\\"\\$delay_variable_subst\\\"\\`\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_$var=\\\\\\\"\\`\\$echo \\\"X\\$$var\\\" | \\$Xsed -e \\\"\\$sed_quote_subst\\\"\\`\\\\\\\"\"\n      ;;\n    esac\n  done\n\n  case $lt_echo in\n  *'\\[$]0 --fallback-echo\"')\n    lt_echo=`$echo \"X$lt_echo\" | $Xsed -e 's/\\\\\\\\\\\\\\[$]0 --fallback-echo\"[$]/[$]0 --fallback-echo\"/'`\n    ;;\n  esac\n\nifelse([$1], [],\n  [cfgfile=\"${ofile}T\"\n  trap \"$rm \\\"$cfgfile\\\"; exit 1\" 1 2 15\n  $rm -f \"$cfgfile\"\n  AC_MSG_NOTICE([creating $ofile])],\n  [cfgfile=\"$ofile\"])\n\n  cat <<__EOF__ >> \"$cfgfile\"\nifelse([$1], [],\n[#! $SHELL\n\n# `$echo \"$cfgfile\" | sed 's%^.*/%%'` - Provide generalized library-building support services.\n# Generated automatically by $PROGRAM (GNU $PACKAGE $VERSION$TIMESTAMP)\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n#\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n# Free Software Foundation, Inc.\n#\n# This file is part of GNU Libtool:\n# Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program that contains a\n# configuration script generated by Autoconf, you may include it under\n# the same distribution terms that you use for the rest of that program.\n\n# A sed program that does not truncate output.\nSED=$lt_SED\n\n# Sed that helps us avoid accidentally triggering echo(1) options like -n.\nXsed=\"$SED -e 1s/^X//\"\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\n# The names of the tagged configurations supported by this script.\navailable_tags=\n\n# ### BEGIN LIBTOOL CONFIG],\n[# ### BEGIN LIBTOOL TAG CONFIG: $tagname])\n\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n\n# Shell to use when invoking shell scripts.\nSHELL=$lt_SHELL\n\n# Whether or not to build shared libraries.\nbuild_libtool_libs=$enable_shared\n\n# Whether or not to build static libraries.\nbuild_old_libs=$enable_static\n\n# Whether or not to add -lc for building shared libraries.\nbuild_libtool_need_lc=$_LT_AC_TAGVAR(archive_cmds_need_lc, $1)\n\n# Whether or not to disallow shared libs when runtime libs are static\nallow_libtool_libs_with_static_runtimes=$_LT_AC_TAGVAR(enable_shared_with_static_runtimes, $1)\n\n# Whether or not to optimize for fast installation.\nfast_install=$enable_fast_install\n\n# The host system.\nhost_alias=$host_alias\nhost=$host\nhost_os=$host_os\n\n# The build system.\nbuild_alias=$build_alias\nbuild=$build\nbuild_os=$build_os\n\n# An echo program that does not interpret backslashes.\necho=$lt_echo\n\n# The archiver.\nAR=$lt_AR\nAR_FLAGS=$lt_AR_FLAGS\n\n# A C compiler.\nLTCC=$lt_LTCC\n\n# LTCC compiler flags.\nLTCFLAGS=$lt_LTCFLAGS\n\n# A language-specific compiler.\nCC=$lt_[]_LT_AC_TAGVAR(compiler, $1)\n\n# Is the compiler the GNU C compiler?\nwith_gcc=$_LT_AC_TAGVAR(GCC, $1)\n\n# An ERE matcher.\nEGREP=$lt_EGREP\n\n# The linker used to build libraries.\nLD=$lt_[]_LT_AC_TAGVAR(LD, $1)\n\n# Whether we need hard or soft links.\nLN_S=$lt_LN_S\n\n# A BSD-compatible nm program.\nNM=$lt_NM\n\n# A symbol stripping program\nSTRIP=$lt_STRIP\n\n# Used to examine libraries when file_magic_cmd begins \"file\"\nMAGIC_CMD=$MAGIC_CMD\n\n# Used on cygwin: DLL creation program.\nDLLTOOL=\"$DLLTOOL\"\n\n# Used on cygwin: object dumper.\nOBJDUMP=\"$OBJDUMP\"\n\n# Used on cygwin: assembler.\nAS=\"$AS\"\n\n# The name of the directory that contains temporary libtool files.\nobjdir=$objdir\n\n# How to create reloadable object files.\nreload_flag=$lt_reload_flag\nreload_cmds=$lt_reload_cmds\n\n# How to pass a linker flag through the compiler.\nwl=$lt_[]_LT_AC_TAGVAR(lt_prog_compiler_wl, $1)\n\n# Object file suffix (normally \"o\").\nobjext=\"$ac_objext\"\n\n# Old archive suffix (normally \"a\").\nlibext=\"$libext\"\n\n# Shared library suffix (normally \".so\").\nshrext_cmds='$shrext_cmds'\n\n# Executable file suffix (normally \"\").\nexeext=\"$exeext\"\n\n# Additional compiler flags for building library objects.\npic_flag=$lt_[]_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)\npic_mode=$pic_mode\n\n# What is the maximum length of a command?\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n\n# Does compiler simultaneously support -c and -o options?\ncompiler_c_o=$lt_[]_LT_AC_TAGVAR(lt_cv_prog_compiler_c_o, $1)\n\n# Must we lock files when doing compilation?\nneed_locks=$lt_need_locks\n\n# Do we need the lib prefix for modules?\nneed_lib_prefix=$need_lib_prefix\n\n# Do we need a version for libraries?\nneed_version=$need_version\n\n# Whether dlopen is supported.\ndlopen_support=$enable_dlopen\n\n# Whether dlopen of programs is supported.\ndlopen_self=$enable_dlopen_self\n\n# Whether dlopen of statically linked programs is supported.\ndlopen_self_static=$enable_dlopen_self_static\n\n# Compiler flag to prevent dynamic linking.\nlink_static_flag=$lt_[]_LT_AC_TAGVAR(lt_prog_compiler_static, $1)\n\n# Compiler flag to turn off builtin functions.\nno_builtin_flag=$lt_[]_LT_AC_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\n\n# Compiler flag to allow reflexive dlopens.\nexport_dynamic_flag_spec=$lt_[]_LT_AC_TAGVAR(export_dynamic_flag_spec, $1)\n\n# Compiler flag to generate shared objects directly from archives.\nwhole_archive_flag_spec=$lt_[]_LT_AC_TAGVAR(whole_archive_flag_spec, $1)\n\n# Compiler flag to generate thread-safe objects.\nthread_safe_flag_spec=$lt_[]_LT_AC_TAGVAR(thread_safe_flag_spec, $1)\n\n# Library versioning type.\nversion_type=$version_type\n\n# Format of library name prefix.\nlibname_spec=$lt_libname_spec\n\n# List of archive names.  First name is the real one, the rest are links.\n# The last name is the one that the linker finds with -lNAME.\nlibrary_names_spec=$lt_library_names_spec\n\n# The coded name of the library, if different from the real name.\nsoname_spec=$lt_soname_spec\n\n# Commands used to build and install an old-style archive.\nRANLIB=$lt_RANLIB\nold_archive_cmds=$lt_[]_LT_AC_TAGVAR(old_archive_cmds, $1)\nold_postinstall_cmds=$lt_old_postinstall_cmds\nold_postuninstall_cmds=$lt_old_postuninstall_cmds\n\n# Create an old-style archive from a shared archive.\nold_archive_from_new_cmds=$lt_[]_LT_AC_TAGVAR(old_archive_from_new_cmds, $1)\n\n# Create a temporary old-style archive to link instead of a shared archive.\nold_archive_from_expsyms_cmds=$lt_[]_LT_AC_TAGVAR(old_archive_from_expsyms_cmds, $1)\n\n# Commands used to build and install a shared archive.\narchive_cmds=$lt_[]_LT_AC_TAGVAR(archive_cmds, $1)\narchive_expsym_cmds=$lt_[]_LT_AC_TAGVAR(archive_expsym_cmds, $1)\npostinstall_cmds=$lt_postinstall_cmds\npostuninstall_cmds=$lt_postuninstall_cmds\n\n# Commands used to build a loadable module (assumed same as above if empty)\nmodule_cmds=$lt_[]_LT_AC_TAGVAR(module_cmds, $1)\nmodule_expsym_cmds=$lt_[]_LT_AC_TAGVAR(module_expsym_cmds, $1)\n\n# Commands to strip libraries.\nold_striplib=$lt_old_striplib\nstriplib=$lt_striplib\n\n# Dependencies to place before the objects being linked to create a\n# shared library.\npredep_objects=$lt_[]_LT_AC_TAGVAR(predep_objects, $1)\n\n# Dependencies to place after the objects being linked to create a\n# shared library.\npostdep_objects=$lt_[]_LT_AC_TAGVAR(postdep_objects, $1)\n\n# Dependencies to place before the objects being linked to create a\n# shared library.\npredeps=$lt_[]_LT_AC_TAGVAR(predeps, $1)\n\n# Dependencies to place after the objects being linked to create a\n# shared library.\npostdeps=$lt_[]_LT_AC_TAGVAR(postdeps, $1)\n\n# The library search path used internally by the compiler when linking\n# a shared library.\ncompiler_lib_search_path=$lt_[]_LT_AC_TAGVAR(compiler_lib_search_path, $1)\n\n# Method to check whether dependent libraries are shared objects.\ndeplibs_check_method=$lt_deplibs_check_method\n\n# Command to use when deplibs_check_method == file_magic.\nfile_magic_cmd=$lt_file_magic_cmd\n\n# Flag that allows shared libraries with undefined symbols to be built.\nallow_undefined_flag=$lt_[]_LT_AC_TAGVAR(allow_undefined_flag, $1)\n\n# Flag that forces no undefined symbols.\nno_undefined_flag=$lt_[]_LT_AC_TAGVAR(no_undefined_flag, $1)\n\n# Commands used to finish a libtool library installation in a directory.\nfinish_cmds=$lt_finish_cmds\n\n# Same as above, but a single script fragment to be evaled but not shown.\nfinish_eval=$lt_finish_eval\n\n# Take the output of nm and produce a listing of raw symbols and C names.\nglobal_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe\n\n# Transform the output of nm in a proper C declaration\nglobal_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl\n\n# Transform the output of nm in a C name address pair\nglobal_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address\n\n# This is the shared library runtime path variable.\nrunpath_var=$runpath_var\n\n# This is the shared library path variable.\nshlibpath_var=$shlibpath_var\n\n# Is shlibpath searched before the hard-coded library search path?\nshlibpath_overrides_runpath=$shlibpath_overrides_runpath\n\n# How to hardcode a shared library path into an executable.\nhardcode_action=$_LT_AC_TAGVAR(hardcode_action, $1)\n\n# Whether we should hardcode library paths into libraries.\nhardcode_into_libs=$hardcode_into_libs\n\n# Flag to hardcode \\$libdir into a binary during linking.\n# This must work even if \\$libdir does not exist.\nhardcode_libdir_flag_spec=$lt_[]_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)\n\n# If ld is used when linking, flag to hardcode \\$libdir into\n# a binary during linking. This must work even if \\$libdir does\n# not exist.\nhardcode_libdir_flag_spec_ld=$lt_[]_LT_AC_TAGVAR(hardcode_libdir_flag_spec_ld, $1)\n\n# Whether we need a single -rpath flag with a separated argument.\nhardcode_libdir_separator=$lt_[]_LT_AC_TAGVAR(hardcode_libdir_separator, $1)\n\n# Set to yes if using DIR/libNAME${shared_ext} during linking hardcodes DIR into the\n# resulting binary.\nhardcode_direct=$_LT_AC_TAGVAR(hardcode_direct, $1)\n\n# Set to yes if using the -LDIR flag during linking hardcodes DIR into the\n# resulting binary.\nhardcode_minus_L=$_LT_AC_TAGVAR(hardcode_minus_L, $1)\n\n# Set to yes if using SHLIBPATH_VAR=DIR during linking hardcodes DIR into\n# the resulting binary.\nhardcode_shlibpath_var=$_LT_AC_TAGVAR(hardcode_shlibpath_var, $1)\n\n# Set to yes if building a shared library automatically hardcodes DIR into the library\n# and all subsequent libraries and executables linked against it.\nhardcode_automatic=$_LT_AC_TAGVAR(hardcode_automatic, $1)\n\n# Variables whose values should be saved in libtool wrapper scripts and\n# restored at relink time.\nvariables_saved_for_relink=\"$variables_saved_for_relink\"\n\n# Whether libtool must link a program against all its dependency libraries.\nlink_all_deplibs=$_LT_AC_TAGVAR(link_all_deplibs, $1)\n\n# Compile-time system search path for libraries\nsys_lib_search_path_spec=$lt_sys_lib_search_path_spec\n\n# Run-time system search path for libraries\nsys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec\n\n# Fix the shell variable \\$srcfile for the compiler.\nfix_srcfile_path=$lt_fix_srcfile_path\n\n# Set to yes if exported symbols are required.\nalways_export_symbols=$_LT_AC_TAGVAR(always_export_symbols, $1)\n\n# The commands to list exported symbols.\nexport_symbols_cmds=$lt_[]_LT_AC_TAGVAR(export_symbols_cmds, $1)\n\n# The commands to extract the exported symbol list from a shared archive.\nextract_expsyms_cmds=$lt_extract_expsyms_cmds\n\n# Symbols that should not be listed in the preloaded symbols.\nexclude_expsyms=$lt_[]_LT_AC_TAGVAR(exclude_expsyms, $1)\n\n# Symbols that must always be exported.\ninclude_expsyms=$lt_[]_LT_AC_TAGVAR(include_expsyms, $1)\n\nifelse([$1],[],\n[# ### END LIBTOOL CONFIG],\n[# ### END LIBTOOL TAG CONFIG: $tagname])\n\n__EOF__\n\nifelse([$1],[], [\n  case $host_os in\n  aix3*)\n    cat <<\\EOF >> \"$cfgfile\"\n\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test \"X${COLLECT_NAMES+set}\" != Xset; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\nEOF\n    ;;\n  esac\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '$q' \"$ltmain\" >> \"$cfgfile\" || (rm -f \"$cfgfile\"; exit 1)\n\n  mv -f \"$cfgfile\" \"$ofile\" || \\\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n])\nelse\n  # If there is no Makefile yet, we rely on a make rule to execute\n  # `config.status --recheck' to rerun these tests and create the\n  # libtool script then.\n  ltmain_in=`echo $ltmain | sed -e 's/\\.sh$/.in/'`\n  if test -f \"$ltmain_in\"; then\n    test -f Makefile && make \"$ltmain\"\n  fi\nfi\n])# AC_LIBTOOL_CONFIG\n\n\n# AC_LIBTOOL_PROG_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------------------\nAC_DEFUN([AC_LIBTOOL_PROG_COMPILER_NO_RTTI],\n[AC_REQUIRE([_LT_AC_SYS_COMPILER])dnl\n\n_LT_AC_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test \"$GCC\" = yes; then\n  _LT_AC_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n\n  AC_LIBTOOL_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_AC_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_AC_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n])# AC_LIBTOOL_PROG_COMPILER_NO_RTTI\n\n\n# AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE\n# ---------------------------------\nAC_DEFUN([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE],\n[AC_REQUIRE([AC_CANONICAL_HOST])\nAC_REQUIRE([LT_AC_PROG_SED])\nAC_REQUIRE([AC_PROG_NM])\nAC_REQUIRE([AC_OBJEXT])\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Transform an extracted symbol line into a proper C declaration\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^. .* \\(.*\\)$/extern int \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (lt_ptr) 0},/p' -e 's/^$symcode \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (lt_ptr) \\&\\2},/p'\"\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*) # Its linker distinguishes data from code symbols\n  if test \"$host_cpu\" = ia64; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  lt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern int \\1();/p' -e 's/^$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n  lt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (lt_ptr) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (lt_ptr) \\&\\2},/p'\"\n  ;;\nlinux* | k*bsd*-gnu)\n  if test \"$host_cpu\" = ia64; then\n    symcode='[[ABCDGIRSTW]]'\n    lt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern int \\1();/p' -e 's/^$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n    lt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (lt_ptr) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (lt_ptr) \\&\\2},/p'\"\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`echo 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\n# Try without a prefix undercore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[ \t]]\\($symcode$symcode*\\)[[ \t]][[ \t]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\nEOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| $lt_cv_sys_global_symbol_pipe \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if grep ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif grep ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<EOF > conftest.$ac_ext\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nEOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | grep -v main >> conftest.$ac_ext'\n\n\t  cat <<EOF >> conftest.$ac_ext\n#if defined (__STDC__) && __STDC__\n# define lt_ptr_t void *\n#else\n# define lt_ptr_t char *\n# define const\n#endif\n\n/* The mapping between symbol names and symbols. */\nconst struct {\n  const char *name;\n  lt_ptr_t address;\n}\nlt_preloaded_symbols[[]] =\n{\nEOF\n\t  $SED \"s/^$symcode$symcode* \\(.*\\) \\(.*\\)$/  {\\\"\\2\\\", (lt_ptr_t) \\&\\2},/\" < \"$nlist\" | grep -v main >> conftest.$ac_ext\n\t  cat <<\\EOF >> conftest.$ac_ext\n  {0, (lt_ptr_t) 0}\n};\n\n#ifdef __cplusplus\n}\n#endif\nEOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_save_LIBS=\"$LIBS\"\n\t  lt_save_CFLAGS=\"$CFLAGS\"\n\t  LIBS=\"conftstm.$ac_objext\"\n\t  CFLAGS=\"$CFLAGS$_LT_AC_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=\"$lt_save_LIBS\"\n\t  CFLAGS=\"$lt_save_CFLAGS\"\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -f conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test \"$pipe_works\" = yes; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n]) # AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE\n\n\n# AC_LIBTOOL_PROG_COMPILER_PIC([TAGNAME])\n# ---------------------------------------\nAC_DEFUN([AC_LIBTOOL_PROG_COMPILER_PIC],\n[_LT_AC_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_AC_TAGVAR(lt_prog_compiler_static, $1)=\n\nAC_MSG_CHECKING([for $compiler option to produce PIC])\n ifelse([$1],[CXX],[\n  # C++ specific cases for pic, static, wl, etc.\n  if test \"$GXX\" = yes; then\n    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n    amigaos*)\n      # FIXME: we need at least 68020 code to build shared libraries, but\n      # adding the `-m68020' flag to GCC prevents building anything better,\n      # like `-m68040'.\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n      ;;\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t;;\n      *)\n\t_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *)\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix4* | aix5*)\n\t# All AIX code is PIC.\n\tif test \"$host_cpu\" = ia64; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_AC_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n       darwin*)\n         # PIC is the default on this platform\n         # Common symbols not allowed in MH_DYLIB files\n         case $cc_basename in\n           xlc*)\n           _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-qnocommon'\n           _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n           ;;\n         esac\n       ;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    if test \"$host_cpu\" != ia64; then\n\t      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  icpc* | ecpc*)\n\t    # Intel C++\n\t    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC*)\n\t    # Portland Group C++ compiler.\n\t    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd*)\n\t;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_AC_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test \"$GCC\" = yes; then\n    _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      # FIXME: we need at least 68020 code to build shared libraries, but\n      # adding the `-m68020' flag to GCC prevents building anything better,\n      # like `-m68040'.\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_AC_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    hpux*)\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    *)\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n      darwin*)\n        # PIC is the default on this platform\n        # Common symbols not allowed in MH_DYLIB files\n       case $cc_basename in\n         xlc*)\n         _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-qnocommon'\n         _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n         ;;\n       esac\n       ;;\n\n    mingw* | cygwin* | pw32* | os2*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    newsos6)\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    linux* | k*bsd*-gnu)\n      case $cc_basename in\n      icc* | ecc*)\n\t_LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      pgcc* | pgf77* | pgf90* | pgf95*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      *)\n        case `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n\t*Sun\\ F*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95*)\n\t_LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec ;then\n\t_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_AC_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_AC_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_AC_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_AC_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\nAC_MSG_RESULT([$_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)])\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  AC_LIBTOOL_COMPILER_OPTION([if $compiler PIC flag $_LT_AC_TAGVAR(lt_prog_compiler_pic, $1) works],\n    _LT_AC_TAGVAR(lt_prog_compiler_pic_works, $1),\n    [$_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)ifelse([$1],[],[ -DPIC],[ifelse([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_AC_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_AC_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\ncase $host_os in\n  # For platforms which do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_AC_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)ifelse([$1],[],[ -DPIC],[ifelse([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\n\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_AC_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_AC_TAGVAR(lt_prog_compiler_static, $1)\\\"\nAC_LIBTOOL_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_AC_TAGVAR(lt_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_AC_TAGVAR(lt_prog_compiler_static, $1)=])\n])\n\n\n# AC_LIBTOOL_PROG_LD_SHLIBS([TAGNAME])\n# ------------------------------------\n# See if the linker supports building shared libraries.\nAC_DEFUN([AC_LIBTOOL_PROG_LD_SHLIBS],\n[AC_REQUIRE([LT_AC_PROG_SED])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nifelse([$1],[CXX],[\n  _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  case $host_os in\n  aix4* | aix5*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to AIX nm, but means don't demangle with GNU nm\n    if $NM -V 2>&1 | grep 'GNU' > /dev/null; then\n      _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\[$]2 == \"T\") || (\\[$]2 == \"D\") || (\\[$]2 == \"B\")) && ([substr](\\[$]3,1,1) != \".\")) { print \\[$]3 } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\[$]2 == \"T\") || (\\[$]2 == \"D\") || (\\[$]2 == \"B\")) && ([substr](\\[$]3,1,1) != \".\")) { print \\[$]3 } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_AC_TAGVAR(export_symbols_cmds, $1)=\"$ltdll_cmds\"\n  ;;\n  cygwin* | mingw*)\n    _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;/^.*[[ ]]__nm__/s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n  ;;\n  *)\n    _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  ;;\n  esac\n],[\n  runpath_var=\n  _LT_AC_TAGVAR(allow_undefined_flag, $1)=\n  _LT_AC_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_AC_TAGVAR(archive_cmds, $1)=\n  _LT_AC_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_AC_TAGVAR(old_archive_From_new_cmds, $1)=\n  _LT_AC_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_AC_TAGVAR(whole_archive_flag_spec, $1)=\n  _LT_AC_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_AC_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n  _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_AC_TAGVAR(hardcode_direct, $1)=no\n  _LT_AC_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_AC_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_AC_TAGVAR(hardcode_automatic, $1)=no\n  _LT_AC_TAGVAR(module_cmds, $1)=\n  _LT_AC_TAGVAR(module_expsym_cmds, $1)=\n  _LT_AC_TAGVAR(always_export_symbols, $1)=no\n  _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_AC_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ` (' and `)$', so one must not match beginning or\n  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',\n  # as well as any symbol that contains `d'.\n  _LT_AC_TAGVAR(exclude_expsyms, $1)=\"_GLOBAL_OFFSET_TABLE_\"\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  extract_expsyms_cmds=\n  # Just being paranoid about ensuring that cc_basename is set.\n  _LT_CC_BASENAME([$compiler])\n  case $host_os in\n  cygwin* | mingw* | pw32*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test \"$GCC\" != yes; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd*)\n    with_gnu_ld=no\n    ;;\n  esac\n\n  _LT_AC_TAGVAR(ld_shlibs, $1)=yes\n  if test \"$with_gnu_ld\" = yes; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='${wl}'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n    _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | grep 'no-whole-archive' > /dev/null; then\n\t_LT_AC_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n      else\n  \t_LT_AC_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v 2>/dev/null` in\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix3* | aix4* | aix5*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test \"$host_cpu\" != ia64; then\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\tcat <<EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.9.1, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to modify your PATH\n*** so that a non-GNU linker is found, and then restart.\n\nEOF\n      fi\n      ;;\n\n    amigaos*)\n      _LT_AC_TAGVAR(archive_cmds, $1)='$rm $output_objdir/a2ixlibrary.data~$echo \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$echo \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$echo \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$echo \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes\n\n      # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports\n      # that the semantics of dynamic libraries on AmigaOS, at least up\n      # to version 4, is to share data among multiple programs linked\n      # with the same dynamic library.  Since this doesn't match the\n      # behavior of shared libraries on other platforms, we can't use\n      # them.\n      _LT_AC_TAGVAR(ld_shlibs, $1)=no\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then\n\t_LT_AC_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      else\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32*)\n      # _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_AC_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_AC_TAGVAR(always_export_symbols, $1)=no\n      _LT_AC_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/'\\'' -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\n      if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then\n        _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file (1st line\n\t# is EXPORTS), use it as is; otherwise, prepend...\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t  cp $export_symbols $output_objdir/$soname.def;\n\telse\n\t  echo EXPORTS > $output_objdir/$soname.def;\n\t  cat $export_symbols >> $output_objdir/$soname.def;\n\tfi~\n\t$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    interix[[3-9]]*)\n      _LT_AC_TAGVAR(hardcode_direct, $1)=no\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n      _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_AC_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | k*bsd*-gnu)\n      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then\n\ttmp_addflag=\n\tcase $cc_basename,$host_cpu in\n\tpgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_AC_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $echo \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95*)\t# Portland Group f77 and f90 compilers\n\t  _LT_AC_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $echo \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_AC_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; $echo \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\t*)\n\t  tmp_sharedflag='-shared' ;;\n\tesac\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\n\tif test $supports_anon_versioning = yes; then\n\t  _LT_AC_TAGVAR(archive_expsym_cmds, $1)='$echo \"{ global:\" > $output_objdir/$libname.ver~\n  cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n  $echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t  $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n\tfi\n      else\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | grep 'BFD 2\\.8' > /dev/null; then\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\tcat <<EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\nEOF\n      elif $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then\n\t    _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='`test -z \"$SCOABSPATH\" && echo ${wl}-rpath,$libdir`'\n\t    _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname,\\${SCOABSPATH:+${install_libdir}/}$soname -o $lib'\n\t    _LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname,\\${SCOABSPATH:+${install_libdir}/}$soname,-retain-symbols-file,$export_symbols -o $lib'\n\t  else\n\t    _LT_AC_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_AC_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test \"$_LT_AC_TAGVAR(ld_shlibs, $1)\" = no; then\n      runpath_var=\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_AC_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_AC_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_AC_TAGVAR(always_export_symbols, $1)=yes\n      _LT_AC_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes\n      if test \"$GCC\" = yes && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_AC_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix4* | aix5*)\n      if test \"$host_cpu\" = ia64; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\"\"\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to AIX nm, but means don't demangle with GNU nm\n\tif $NM -V 2>&1 | grep 'GNU' > /dev/null; then\n\t  _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\[$]2 == \"T\") || (\\[$]2 == \"D\") || (\\[$]2 == \"B\")) && ([substr](\\[$]3,1,1) != \".\")) { print \\[$]3 } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_AC_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\[$]2 == \"T\") || (\\[$]2 == \"D\") || (\\[$]2 == \"B\")) && ([substr](\\[$]3,1,1) != \".\")) { print \\[$]3 } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# need to do runtime linking.\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix5*)\n\t  for ld_flag in $LDFLAGS; do\n  \t  if (test $ld_flag = \"-brtl\" || test $ld_flag = \"-Wl,-brtl\"); then\n  \t    aix_use_runtimelinking=yes\n  \t    break\n  \t  fi\n\t  done\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_AC_TAGVAR(archive_cmds, $1)=''\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n      _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_AC_TAGVAR(link_all_deplibs, $1)=yes\n\n      if test \"$GCC\" = yes; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" && \\\n  \t   strings \"$collect2name\" | grep resolve_lib_name >/dev/null\n\t  then\n  \t  # We have reworked collect2\n  \t  :\n\t  else\n  \t  # We have old collect2\n  \t  _LT_AC_TAGVAR(hardcode_direct, $1)=unsupported\n  \t  # It fails to find uninstalled libraries when the uninstalled\n  \t  # path is not listed in the libpath.  Setting hardcode_minus_L\n  \t  # to unsupported forces relinking\n  \t  _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes\n  \t  _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n  \t  _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test \"$aix_use_runtimelinking\" = yes; then\n\t  shared_flag=\"$shared_flag \"'${wl}-G'\n\tfi\n      else\n\t# not using gcc\n\tif test \"$host_cpu\" = ia64; then\n  \t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n  \t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag='${wl}-G'\n\t  else\n\t    shared_flag='${wl}-bM:SRE'\n\t  fi\n\tfi\n      fi\n\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_AC_TAGVAR(always_export_symbols, $1)=yes\n      if test \"$aix_use_runtimelinking\" = yes; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_AC_TAGVAR(allow_undefined_flag, $1)='-berok'\n       # Determine the default libpath from the value encoded in an empty executable.\n       _LT_AC_SYS_LIBPATH_AIX\n       _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then echo \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n       else\n\tif test \"$host_cpu\" = ia64; then\n\t  _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t  _LT_AC_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_AC_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an empty executable.\n\t _LT_AC_SYS_LIBPATH_AIX\n\t _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_AC_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t  _LT_AC_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t  # Exported symbols can be pulled into shared objects from archives\n\t  _LT_AC_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  # This is similar to how AIX traditionally builds its shared libraries.\n\t  _LT_AC_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      _LT_AC_TAGVAR(archive_cmds, $1)='$rm $output_objdir/a2ixlibrary.data~$echo \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$echo \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$echo \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$echo \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes\n      # see comment about different semantics on the GNU ld section\n      _LT_AC_TAGVAR(ld_shlibs, $1)=no\n      ;;\n\n    bsdi[[45]]*)\n      _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n      _LT_AC_TAGVAR(allow_undefined_flag, $1)=unsupported\n      # Tell ltmain to make .lib files, not .a files.\n      libext=lib\n      # Tell ltmain to make .dll files, not .so files.\n      shrext_cmds=\".dll\"\n      # FIXME: Setting linknames here is a bad hack.\n      _LT_AC_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `echo \"$deplibs\" | $SED -e '\\''s/ -lc$//'\\''` -link -dll~linknames='\n      # The linker will automatically build a .lib file if we build a DLL.\n      _LT_AC_TAGVAR(old_archive_From_new_cmds, $1)='true'\n      # FIXME: Should let the user specify the lib program.\n      _LT_AC_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n      _LT_AC_TAGVAR(fix_srcfile_path, $1)='`cygpath -w \"$srcfile\"`'\n      _LT_AC_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    darwin* | rhapsody*)\n      case $host_os in\n        rhapsody* | darwin1.[[012]])\n         _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-undefined ${wl}suppress'\n         ;;\n       *) # Darwin 1.3 on\n         if test -z ${MACOSX_DEPLOYMENT_TARGET} ; then\n           _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'\n         else\n           case ${MACOSX_DEPLOYMENT_TARGET} in\n             10.[[012]])\n               _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'\n               ;;\n             10.*)\n               _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-undefined ${wl}dynamic_lookup'\n               ;;\n           esac\n         fi\n         ;;\n      esac\n      _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_AC_TAGVAR(hardcode_direct, $1)=no\n      _LT_AC_TAGVAR(hardcode_automatic, $1)=yes\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n      _LT_AC_TAGVAR(whole_archive_flag_spec, $1)=''\n      _LT_AC_TAGVAR(link_all_deplibs, $1)=yes\n    if test \"$GCC\" = yes ; then\n    \toutput_verbose_link_cmd='echo'\n        _LT_AC_TAGVAR(archive_cmds, $1)='$CC -dynamiclib $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'\n      _LT_AC_TAGVAR(module_cmds, $1)='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'\n      # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds\n      _LT_AC_TAGVAR(archive_expsym_cmds, $1)='sed -e \"s,#.*,,\" -e \"s,^[    ]*,,\" -e \"s,^\\(..*\\),_&,\" < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -dynamiclib $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'\n      _LT_AC_TAGVAR(module_expsym_cmds, $1)='sed -e \"s,#.*,,\" -e \"s,^[    ]*,,\" -e \"s,^\\(..*\\),_&,\" < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'\n    else\n      case $cc_basename in\n        xlc*)\n         output_verbose_link_cmd='echo'\n         _LT_AC_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}`echo $rpath/$soname` $xlcverstring'\n         _LT_AC_TAGVAR(module_cmds, $1)='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'\n          # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds\n         _LT_AC_TAGVAR(archive_expsym_cmds, $1)='sed -e \"s,#.*,,\" -e \"s,^[    ]*,,\" -e \"s,^\\(..*\\),_&,\" < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -qmkshrobj $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}$rpath/$soname $xlcverstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'\n          _LT_AC_TAGVAR(module_expsym_cmds, $1)='sed -e \"s,#.*,,\" -e \"s,^[    ]*,,\" -e \"s,^\\(..*\\),_&,\" < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'\n          ;;\n       *)\n         _LT_AC_TAGVAR(ld_shlibs, $1)=no\n          ;;\n      esac\n    fi\n      ;;\n\n    dgux*)\n      _LT_AC_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    freebsd1*)\n      _LT_AC_TAGVAR(ld_shlibs, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_AC_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2*)\n      _LT_AC_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n      _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test \"$GCC\" = yes; then\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$rm $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      else\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$rm $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      fi\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n      _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      ;;\n\n    hpux10*)\n      if test \"$GCC\" = yes -a \"$with_gnu_ld\" = no; then\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t_LT_AC_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_AC_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test \"$GCC\" = yes -a \"$with_gnu_ld\" = no; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_AC_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='+b $libdir'\n\t  _LT_AC_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test \"$GCC\" = yes; then\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n      else\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname `test -n \"$verstring\" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='-rpath $libdir'\n      fi\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_AC_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_AC_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    openbsd*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_AC_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tif test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'\n\t  _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\telse\n\t  case $host_os in\n\t   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)\n\t     _LT_AC_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n\t     _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t     ;;\n\t   *)\n\t     _LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t     _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t     ;;\n\t  esac\n        fi\n      else\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_AC_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_AC_TAGVAR(archive_cmds, $1)='$echo \"LIBRARY $libname INITINSTANCE\" > $output_objdir/$libname.def~$echo \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~$echo DATA >> $output_objdir/$libname.def~$echo \" SINGLE NONSHARED\" >> $output_objdir/$libname.def~$echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'\n      _LT_AC_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'\n      ;;\n\n    osf3*)\n      if test \"$GCC\" = yes; then\n\t_LT_AC_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n      else\n\t_LT_AC_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -soname $soname `test -n \"$verstring\" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'\n      fi\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test \"$GCC\" = yes; then\n\t_LT_AC_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      else\n\t_LT_AC_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -msym -soname $soname `test -n \"$verstring\" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; echo \"-hidden\">> $lib.exp~\n\t$LD -shared${allow_undefined_flag} -input $lib.exp $linker_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib~$rm $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_AC_TAGVAR(no_undefined_flag, $1)=' -z text'\n      if test \"$GCC\" = yes; then\n\twlarc='${wl}'\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~$echo \"local: *; };\" >> $lib.exp~\n\t  $CC -shared ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$rm $lib.exp'\n      else\n\twlarc=''\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~$echo \"local: *; };\" >> $lib.exp~\n  \t$LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$rm $lib.exp'\n      fi\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands `-z linker_flag'.  GCC discards it without `$wl',\n\t# but is careful enough not to reorder.\n \t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test \"$GCC\" = yes; then\n\t  _LT_AC_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\telse\n\t  _LT_AC_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_AC_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test \"x$host_vendor\" = xsequent; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_AC_TAGVAR(hardcode_direct, $1)=yes\n      _LT_AC_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_AC_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_AC_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_AC_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_AC_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_AC_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_AC_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_AC_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_AC_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We can NOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_AC_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_AC_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n      _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='`test -z \"$SCOABSPATH\" && echo ${wl}-R,$libdir`'\n      _LT_AC_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_AC_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_AC_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,\\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,\\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_AC_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,\\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_AC_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,\\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_AC_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_AC_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_AC_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_AC_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n  fi\n])\nAC_MSG_RESULT([$_LT_AC_TAGVAR(ld_shlibs, $1)])\ntest \"$_LT_AC_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_AC_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test \"$enable_shared\" = yes && test \"$GCC\" = yes; then\n    case $_LT_AC_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_MSG_CHECKING([whether -lc should be explicitly linked in])\n      $rm conftest*\n      echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n      if AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n        soname=conftest\n        lib=conftest\n        libobjs=conftest.$ac_objext\n        deplibs=\n        wl=$_LT_AC_TAGVAR(lt_prog_compiler_wl, $1)\n\tpic_flag=$_LT_AC_TAGVAR(lt_prog_compiler_pic, $1)\n        compiler_flags=-v\n        linker_flags=-v\n        verstring=\n        output_objdir=.\n        libname=conftest\n        lt_save_allow_undefined_flag=$_LT_AC_TAGVAR(allow_undefined_flag, $1)\n        _LT_AC_TAGVAR(allow_undefined_flag, $1)=\n        if AC_TRY_EVAL(_LT_AC_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| grep \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n        then\n\t  _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=no\n        else\n\t  _LT_AC_TAGVAR(archive_cmds_need_lc, $1)=yes\n        fi\n        _LT_AC_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n      else\n        cat conftest.err 1>&5\n      fi\n      $rm conftest*\n      AC_MSG_RESULT([$_LT_AC_TAGVAR(archive_cmds_need_lc, $1)])\n      ;;\n    esac\n  fi\n  ;;\nesac\n])# AC_LIBTOOL_PROG_LD_SHLIBS\n\n\n# _LT_AC_FILE_LTDLL_C\n# -------------------\n# Be careful that the start marker always follows a newline.\nAC_DEFUN([_LT_AC_FILE_LTDLL_C], [\n# /* ltdll.c starts here */\n# #define WIN32_LEAN_AND_MEAN\n# #include <windows.h>\n# #undef WIN32_LEAN_AND_MEAN\n# #include <stdio.h>\n#\n# #ifndef __CYGWIN__\n# #  ifdef __CYGWIN32__\n# #    define __CYGWIN__ __CYGWIN32__\n# #  endif\n# #endif\n#\n# #ifdef __cplusplus\n# extern \"C\" {\n# #endif\n# BOOL APIENTRY DllMain (HINSTANCE hInst, DWORD reason, LPVOID reserved);\n# #ifdef __cplusplus\n# }\n# #endif\n#\n# #ifdef __CYGWIN__\n# #include <cygwin/cygwin_dll.h>\n# DECLARE_CYGWIN_DLL( DllMain );\n# #endif\n# HINSTANCE __hDllInstance_base;\n#\n# BOOL APIENTRY\n# DllMain (HINSTANCE hInst, DWORD reason, LPVOID reserved)\n# {\n#   __hDllInstance_base = hInst;\n#   return TRUE;\n# }\n# /* ltdll.c ends here */\n])# _LT_AC_FILE_LTDLL_C\n\n\n# _LT_AC_TAGVAR(VARNAME, [TAGNAME])\n# ---------------------------------\nAC_DEFUN([_LT_AC_TAGVAR], [ifelse([$2], [], [$1], [$1_$2])])\n\n\n# old names\nAC_DEFUN([AM_PROG_LIBTOOL],   [AC_PROG_LIBTOOL])\nAC_DEFUN([AM_ENABLE_SHARED],  [AC_ENABLE_SHARED($@)])\nAC_DEFUN([AM_ENABLE_STATIC],  [AC_ENABLE_STATIC($@)])\nAC_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])\nAC_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])\nAC_DEFUN([AM_PROG_LD],        [AC_PROG_LD])\nAC_DEFUN([AM_PROG_NM],        [AC_PROG_NM])\n\n# This is just to silence aclocal about the macro not being used\nifelse([AC_DISABLE_FAST_INSTALL])\n\nAC_DEFUN([LT_AC_PROG_GCJ],\n[AC_CHECK_TOOL(GCJ, gcj, no)\n  test \"x${GCJFLAGS+set}\" = xset || GCJFLAGS=\"-g -O2\"\n  AC_SUBST(GCJFLAGS)\n])\n\nAC_DEFUN([LT_AC_PROG_RC],\n[AC_CHECK_TOOL(RC, windres, no)\n])\n\n\n# Cheap backport of AS_EXECUTABLE_P and required macros\n# from Autoconf 2.59; we should not use $as_executable_p directly.\n\n# _AS_TEST_PREPARE\n# ----------------\nm4_ifndef([_AS_TEST_PREPARE],\n[m4_defun([_AS_TEST_PREPARE],\n[if test -x / >/dev/null 2>&1; then\n  as_executable_p='test -x'\nelse\n  as_executable_p='test -f'\nfi\n])])# _AS_TEST_PREPARE\n\n# AS_EXECUTABLE_P\n# ---------------\n# Check whether a file is executable.\nm4_ifndef([AS_EXECUTABLE_P],\n[m4_defun([AS_EXECUTABLE_P],\n[AS_REQUIRE([_AS_TEST_PREPARE])dnl\n$as_executable_p $1[]dnl\n])])# AS_EXECUTABLE_P\n\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n# LT_AC_PROG_SED\n# --------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nAC_DEFUN([LT_AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if AS_EXECUTABLE_P([\"$as_dir/$lt_ac_prog$ac_exec_ext\"]); then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f $lt_ac_sed && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test $lt_ac_count -gt 10 && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test $lt_ac_count -gt $lt_ac_max; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])\n\n# Copyright (C) 2002, 2003, 2005, 2006  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# AM_AUTOMAKE_VERSION(VERSION)\n# ----------------------------\n# Automake X.Y traces this macro to ensure aclocal.m4 has been\n# generated from the m4 files accompanying Automake X.Y.\n# (This private macro should not be called outside this file.)\nAC_DEFUN([AM_AUTOMAKE_VERSION],\n[am__api_version='1.10'\ndnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\ndnl require some minimum version.  Point them to the right macro.\nm4_if([$1], [1.10], [],\n      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n])\n\n# _AM_AUTOCONF_VERSION(VERSION)\n# -----------------------------\n# aclocal traces this macro to find the Autoconf version.\n# This is a private macro too.  Using m4_define simplifies\n# the logic in aclocal, which can simply ignore this definition.\nm4_define([_AM_AUTOCONF_VERSION], [])\n\n# AM_SET_CURRENT_AUTOMAKE_VERSION\n# -------------------------------\n# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n# This function is AC_REQUIREd by AC_INIT_AUTOMAKE.\nAC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n[AM_AUTOMAKE_VERSION([1.10])dnl\n_AM_AUTOCONF_VERSION(m4_PACKAGE_VERSION)])\n\n# Figure out how to run the assembler.                      -*- Autoconf -*-\n\n# Copyright (C) 2001, 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 5\n\n# AM_PROG_AS\n# ----------\nAC_DEFUN([AM_PROG_AS],\n[# By default we simply use the C compiler to build assembly code.\nAC_REQUIRE([AC_PROG_CC])\ntest \"${CCAS+set}\" = set || CCAS=$CC\ntest \"${CCASFLAGS+set}\" = set || CCASFLAGS=$CFLAGS\nAC_ARG_VAR([CCAS],      [assembler compiler command (defaults to CC)])\nAC_ARG_VAR([CCASFLAGS], [assembler compiler flags (defaults to CFLAGS)])\n_AM_IF_OPTION([no-dependencies],, [_AM_DEPENDENCIES([CCAS])])dnl\n])\n\n# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n\n# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n#\n# Of course, Automake must honor this variable whenever it calls a\n# tool from the auxiliary directory.  The problem is that $srcdir (and\n# therefore $ac_aux_dir as well) can be either absolute or relative,\n# depending on how configure is run.  This is pretty annoying, since\n# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n# source directory, any form will work fine, but in subdirectories a\n# relative path needs to be adjusted first.\n#\n# $ac_aux_dir/missing\n#    fails when called from a subdirectory if $ac_aux_dir is relative\n# $top_srcdir/$ac_aux_dir/missing\n#    fails if $ac_aux_dir is absolute,\n#    fails when called from a subdirectory in a VPATH build with\n#          a relative $ac_aux_dir\n#\n# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n# are both prefixed by $srcdir.  In an in-source build this is usually\n# harmless because $srcdir is `.', but things will broke when you\n# start a VPATH build or use an absolute $srcdir.\n#\n# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n# and then we would define $MISSING as\n#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n# This will work as long as MISSING is not called from configure, because\n# unfortunately $(top_srcdir) has no meaning in configure.\n# However there are other variables, like CC, which are often used in\n# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n#\n# Another solution, used here, is to always expand $ac_aux_dir to an\n# absolute PATH.  The drawback is that using absolute paths prevent a\n# configured tree to be moved without reconfiguration.\n\nAC_DEFUN([AM_AUX_DIR_EXPAND],\n[dnl Rely on autoconf to set up CDPATH properly.\nAC_PREREQ([2.50])dnl\n# expand $ac_aux_dir to an absolute path\nam_aux_dir=`cd $ac_aux_dir && pwd`\n])\n\n# AM_CONDITIONAL                                            -*- Autoconf -*-\n\n# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 8\n\n# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n# -------------------------------------\n# Define a conditional.\nAC_DEFUN([AM_CONDITIONAL],\n[AC_PREREQ(2.52)dnl\n ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\nAC_SUBST([$1_TRUE])dnl\nAC_SUBST([$1_FALSE])dnl\n_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n_AM_SUBST_NOTMAKE([$1_FALSE])dnl\nif $2; then\n  $1_TRUE=\n  $1_FALSE='#'\nelse\n  $1_TRUE='#'\n  $1_FALSE=\nfi\nAC_CONFIG_COMMANDS_PRE(\n[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n  AC_MSG_ERROR([[conditional \"$1\" was never defined.\nUsually this means the macro was only invoked conditionally.]])\nfi])])\n\n# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 9\n\n# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n# written in clear, in which case automake, when reading aclocal.m4,\n# will think it sees a *use*, and therefore will trigger all it's\n# C support machinery.  Also note that it means that autoscan, seeing\n# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n\n\n# _AM_DEPENDENCIES(NAME)\n# ----------------------\n# See how the compiler implements dependency checking.\n# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n# We try a few techniques and use that to set a single cache variable.\n#\n# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n# dependency, and given that the user is not expected to run this macro,\n# just rely on AC_PROG_CC.\nAC_DEFUN([_AM_DEPENDENCIES],\n[AC_REQUIRE([AM_SET_DEPDIR])dnl\nAC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\nAC_REQUIRE([AM_MAKE_INCLUDE])dnl\nAC_REQUIRE([AM_DEP_TRACK])dnl\n\nifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n                   [depcc=\"$$1\"   am_compiler_list=])\n\nAC_CACHE_CHECK([dependency style of $depcc],\n               [am_cv_$1_dependencies_compiler_type],\n[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n  # We make a subdir and do the tests there.  Otherwise we can end up\n  # making bogus files that we don't know about and never remove.  For\n  # instance it was reported that on HP-UX the gcc test will end up\n  # making a dummy file named `D' -- because `-MD' means `put the output\n  # in D'.\n  mkdir conftest.dir\n  # Copy depcomp to subdir because otherwise we won't find it if we're\n  # using a relative directory.\n  cp \"$am_depcomp\" conftest.dir\n  cd conftest.dir\n  # We will build objects and dependencies in a subdirectory because\n  # it helps to detect inapplicable dependency modes.  For instance\n  # both Tru64's cc and ICC support -MD to output dependencies as a\n  # side effect of compilation, but ICC will put the dependencies in\n  # the current directory while Tru64 will put them in the object\n  # directory.\n  mkdir sub\n\n  am_cv_$1_dependencies_compiler_type=none\n  if test \"$am_compiler_list\" = \"\"; then\n     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n  fi\n  for depmode in $am_compiler_list; do\n    # Setup a source with many dependencies, because some compilers\n    # like to wrap large dependency lists on column 80 (with \\), and\n    # we should not choose a depcomp mode which is confused by this.\n    #\n    # We need to recreate these files for each test, as the compiler may\n    # overwrite some of them when testing with obscure command lines.\n    # This happens at least with the AIX C compiler.\n    : > sub/conftest.c\n    for i in 1 2 3 4 5 6; do\n      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n      # Solaris 8's {/usr,}/bin/sh.\n      touch sub/conftst$i.h\n    done\n    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n\n    case $depmode in\n    nosideeffect)\n      # after this tag, mechanisms are not by side-effect, so they'll\n      # only be used when explicitly requested\n      if test \"x$enable_dependency_tracking\" = xyes; then\n\tcontinue\n      else\n\tbreak\n      fi\n      ;;\n    none) break ;;\n    esac\n    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n    # mode.  It turns out that the SunPro C++ compiler does not properly\n    # handle `-M -o', and we need to detect this.\n    if depmode=$depmode \\\n       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \\\n       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \\\n         >/dev/null 2>conftest.err &&\n       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&\n       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n      # icc doesn't choke on unknown options, it will just issue warnings\n      # or remarks (even with -Werror).  So we grep stderr for any message\n      # that says an option was ignored or not supported.\n      # When given -MP, icc 7.0 and 7.1 complain thusly:\n      #   icc: Command line warning: ignoring option '-M'; no argument required\n      # The diagnosis changed in icc 8.0:\n      #   icc: Command line remark: option '-MP' not supported\n      if (grep 'ignoring option' conftest.err ||\n          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n        am_cv_$1_dependencies_compiler_type=$depmode\n        break\n      fi\n    fi\n  done\n\n  cd ..\n  rm -rf conftest.dir\nelse\n  am_cv_$1_dependencies_compiler_type=none\nfi\n])\nAC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\nAM_CONDITIONAL([am__fastdep$1], [\n  test \"x$enable_dependency_tracking\" != xno \\\n  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n])\n\n\n# AM_SET_DEPDIR\n# -------------\n# Choose a directory name for dependency files.\n# This macro is AC_REQUIREd in _AM_DEPENDENCIES\nAC_DEFUN([AM_SET_DEPDIR],\n[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\nAC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n])\n\n\n# AM_DEP_TRACK\n# ------------\nAC_DEFUN([AM_DEP_TRACK],\n[AC_ARG_ENABLE(dependency-tracking,\n[  --disable-dependency-tracking  speeds up one-time build\n  --enable-dependency-tracking   do not reject slow dependency extractors])\nif test \"x$enable_dependency_tracking\" != xno; then\n  am_depcomp=\"$ac_aux_dir/depcomp\"\n  AMDEPBACKSLASH='\\'\nfi\nAM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\nAC_SUBST([AMDEPBACKSLASH])dnl\n_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n])\n\n# Generate code to set up dependency tracking.              -*- Autoconf -*-\n\n# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n#serial 3\n\n# _AM_OUTPUT_DEPENDENCY_COMMANDS\n# ------------------------------\nAC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n[for mf in $CONFIG_FILES; do\n  # Strip MF so we end up with the name of the file.\n  mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n  # Check whether this is an Automake generated Makefile or not.\n  # We used to match only the files named `Makefile.in', but\n  # some people rename them; so instead we look at the file content.\n  # Grep'ing the first line is not enough: some people post-process\n  # each Makefile.in and add a new line on top of each file to say so.\n  # Grep'ing the whole file is not good either: AIX grep has a line\n  # limit of 2048, but all sed's we know have understand at least 4000.\n  if sed 10q \"$mf\" | grep '^#.*generated by automake' > /dev/null 2>&1; then\n    dirpart=`AS_DIRNAME(\"$mf\")`\n  else\n    continue\n  fi\n  # Extract the definition of DEPDIR, am__include, and am__quote\n  # from the Makefile without running `make'.\n  DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n  test -z \"$DEPDIR\" && continue\n  am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n  test -z \"am__include\" && continue\n  am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n  # When using ansi2knr, U may be empty or an underscore; expand it\n  U=`sed -n 's/^U = //p' < \"$mf\"`\n  # Find all dependency output files, they are included files with\n  # $(DEPDIR) in their names.  We invoke sed twice because it is the\n  # simplest approach to changing $(DEPDIR) to its actual value in the\n  # expansion.\n  for file in `sed -n \"\n    s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n       sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n    # Make sure the directory exists.\n    test -f \"$dirpart/$file\" && continue\n    fdir=`AS_DIRNAME([\"$file\"])`\n    AS_MKDIR_P([$dirpart/$fdir])\n    # echo \"creating $dirpart/$file\"\n    echo '# dummy' > \"$dirpart/$file\"\n  done\ndone\n])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n\n\n# AM_OUTPUT_DEPENDENCY_COMMANDS\n# -----------------------------\n# This macro should only be invoked once -- use via AC_REQUIRE.\n#\n# This code is only required when automatic dependency tracking\n# is enabled.  FIXME.  This creates each `.P' file that we will\n# need in order to bootstrap the dependency handling code.\nAC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n[AC_CONFIG_COMMANDS([depfiles],\n     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n])\n\n# Do all the work for Automake.                             -*- Autoconf -*-\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n# 2005, 2006 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 12\n\n# This macro actually does too much.  Some checks are only needed if\n# your package does certain things.  But this isn't really a big deal.\n\n# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n# AM_INIT_AUTOMAKE([OPTIONS])\n# -----------------------------------------------\n# The call with PACKAGE and VERSION arguments is the old style\n# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n# and VERSION should now be passed to AC_INIT and removed from\n# the call to AM_INIT_AUTOMAKE.\n# We support both call styles for the transition.  After\n# the next Automake release, Autoconf can make the AC_INIT\n# arguments mandatory, and then we can depend on a new Autoconf\n# release and drop the old call support.\nAC_DEFUN([AM_INIT_AUTOMAKE],\n[AC_PREREQ([2.60])dnl\ndnl Autoconf wants to disallow AM_ names.  We explicitly allow\ndnl the ones we care about.\nm4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\nAC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\nAC_REQUIRE([AC_PROG_INSTALL])dnl\nif test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n  # is not polluted with repeated \"-I.\"\n  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n  # test to see if srcdir already configured\n  if test -f $srcdir/config.status; then\n    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n  fi\nfi\n\n# test whether we have cygpath\nif test -z \"$CYGPATH_W\"; then\n  if (cygpath --version) >/dev/null 2>/dev/null; then\n    CYGPATH_W='cygpath -w'\n  else\n    CYGPATH_W=echo\n  fi\nfi\nAC_SUBST([CYGPATH_W])\n\n# Define the identity of the package.\ndnl Distinguish between old-style and new-style calls.\nm4_ifval([$2],\n[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n AC_SUBST([PACKAGE], [$1])dnl\n AC_SUBST([VERSION], [$2])],\n[_AM_SET_OPTIONS([$1])dnl\ndnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\nm4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n\n_AM_IF_OPTION([no-define],,\n[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n\n# Some tools Automake needs.\nAC_REQUIRE([AM_SANITY_CHECK])dnl\nAC_REQUIRE([AC_ARG_PROGRAM])dnl\nAM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\nAM_MISSING_PROG(AUTOCONF, autoconf)\nAM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\nAM_MISSING_PROG(AUTOHEADER, autoheader)\nAM_MISSING_PROG(MAKEINFO, makeinfo)\nAM_PROG_INSTALL_SH\nAM_PROG_INSTALL_STRIP\nAC_REQUIRE([AM_PROG_MKDIR_P])dnl\n# We need awk for the \"check\" target.  The system \"awk\" is bad on\n# some platforms.\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([AC_PROG_MAKE_SET])dnl\nAC_REQUIRE([AM_SET_LEADING_DOT])dnl\n_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n              [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n\t      \t\t     [_AM_PROG_TAR([v7])])])\n_AM_IF_OPTION([no-dependencies],,\n[AC_PROVIDE_IFELSE([AC_PROG_CC],\n                  [_AM_DEPENDENCIES(CC)],\n                  [define([AC_PROG_CC],\n                          defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\nAC_PROVIDE_IFELSE([AC_PROG_CXX],\n                  [_AM_DEPENDENCIES(CXX)],\n                  [define([AC_PROG_CXX],\n                          defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\nAC_PROVIDE_IFELSE([AC_PROG_OBJC],\n                  [_AM_DEPENDENCIES(OBJC)],\n                  [define([AC_PROG_OBJC],\n                          defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n])\n])\n\n\n# When config.status generates a header, we must update the stamp-h file.\n# This file resides in the same directory as the config header\n# that is generated.  The stamp files are numbered to have different names.\n\n# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n# loop where config.status creates the headers, so we can generate\n# our stamp files there.\nAC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n[# Compute $1's index in $config_headers.\n_am_stamp_count=1\nfor _am_header in $config_headers :; do\n  case $_am_header in\n    $1 | $1:* )\n      break ;;\n    * )\n      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n  esac\ndone\necho \"timestamp for $1\" >`AS_DIRNAME([$1])`/stamp-h[]$_am_stamp_count])\n\n# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# AM_PROG_INSTALL_SH\n# ------------------\n# Define $install_sh.\nAC_DEFUN([AM_PROG_INSTALL_SH],\n[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\ninstall_sh=${install_sh-\"\\$(SHELL) $am_aux_dir/install-sh\"}\nAC_SUBST(install_sh)])\n\n# Copyright (C) 2003, 2005  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 2\n\n# Check whether the underlying file-system supports filenames\n# with a leading dot.  For instance MS-DOS doesn't.\nAC_DEFUN([AM_SET_LEADING_DOT],\n[rm -rf .tst 2>/dev/null\nmkdir .tst 2>/dev/null\nif test -d .tst; then\n  am__leading_dot=.\nelse\n  am__leading_dot=_\nfi\nrmdir .tst 2>/dev/null\nAC_SUBST([am__leading_dot])])\n\n# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n# From Jim Meyering\n\n# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 4\n\nAC_DEFUN([AM_MAINTAINER_MODE],\n[AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n  dnl maintainer-mode is disabled by default\n  AC_ARG_ENABLE(maintainer-mode,\n[  --enable-maintainer-mode  enable make rules and dependencies not useful\n\t\t\t  (and sometimes confusing) to the casual installer],\n      USE_MAINTAINER_MODE=$enableval,\n      USE_MAINTAINER_MODE=no)\n  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n  AM_CONDITIONAL(MAINTAINER_MODE, [test $USE_MAINTAINER_MODE = yes])\n  MAINT=$MAINTAINER_MODE_TRUE\n  AC_SUBST(MAINT)dnl\n]\n)\n\nAU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n\n# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n\n# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 3\n\n# AM_MAKE_INCLUDE()\n# -----------------\n# Check to see how make treats includes.\nAC_DEFUN([AM_MAKE_INCLUDE],\n[am_make=${MAKE-make}\ncat > confinc << 'END'\nam__doit:\n\t@echo done\n.PHONY: am__doit\nEND\n# If we don't find an include directive, just comment out the code.\nAC_MSG_CHECKING([for style of include used by $am_make])\nam__include=\"#\"\nam__quote=\n_am_result=none\n# First try GNU make style include.\necho \"include confinc\" > confmf\n# We grep out `Entering directory' and `Leaving directory'\n# messages which can occur if `w' ends up in MAKEFLAGS.\n# In particular we don't look at `^make:' because GNU make might\n# be invoked under some other name (usually \"gmake\"), in which\n# case it prints its new name instead of `make'.\nif test \"`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`\" = \"done\"; then\n   am__include=include\n   am__quote=\n   _am_result=GNU\nfi\n# Now try BSD make style include.\nif test \"$am__include\" = \"#\"; then\n   echo '.include \"confinc\"' > confmf\n   if test \"`$am_make -s -f confmf 2> /dev/null`\" = \"done\"; then\n      am__include=.include\n      am__quote=\"\\\"\"\n      _am_result=BSD\n   fi\nfi\nAC_SUBST([am__include])\nAC_SUBST([am__quote])\nAC_MSG_RESULT([$_am_result])\nrm -f confinc confmf\n])\n\n# Copyright (C) 1999, 2000, 2001, 2003, 2004, 2005\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 5\n\n# AM_PROG_CC_C_O\n# --------------\n# Like AC_PROG_CC_C_O, but changed for automake.\nAC_DEFUN([AM_PROG_CC_C_O],\n[AC_REQUIRE([AC_PROG_CC_C_O])dnl\nAC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\nAC_REQUIRE_AUX_FILE([compile])dnl\n# FIXME: we rely on the cache variable name because\n# there is no other way.\nset dummy $CC\nac_cc=`echo $[2] | sed ['s/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/']`\nif eval \"test \\\"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\\\" != yes\"; then\n   # Losing compiler, so override with the script.\n   # FIXME: It is wrong to rewrite CC.\n   # But if we don't then we get into trouble of one sort or another.\n   # A longer-term fix would be to have automake use am__CC in this case,\n   # and then we could set am__CC=\"\\$(top_srcdir)/compile \\$(CC)\"\n   CC=\"$am_aux_dir/compile $CC\"\nfi\ndnl Make sure AC_PROG_CC is never called again, or it will override our\ndnl setting of CC.\nm4_define([AC_PROG_CC],\n          [m4_fatal([AC_PROG_CC cannot be called after AM_PROG_CC_C_O])])\n])\n\n# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n\n# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 5\n\n# AM_MISSING_PROG(NAME, PROGRAM)\n# ------------------------------\nAC_DEFUN([AM_MISSING_PROG],\n[AC_REQUIRE([AM_MISSING_HAS_RUN])\n$1=${$1-\"${am_missing_run}$2\"}\nAC_SUBST($1)])\n\n\n# AM_MISSING_HAS_RUN\n# ------------------\n# Define MISSING if not defined so far and test if it supports --run.\n# If it does, set am_missing_run to use it, otherwise, to nothing.\nAC_DEFUN([AM_MISSING_HAS_RUN],\n[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\nAC_REQUIRE_AUX_FILE([missing])dnl\ntest x\"${MISSING+set}\" = xset || MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n# Use eval to expand $SHELL\nif eval \"$MISSING --run true\"; then\n  am_missing_run=\"$MISSING --run \"\nelse\n  am_missing_run=\n  AC_MSG_WARN([`missing' script is too old or missing])\nfi\n])\n\n# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# AM_PROG_MKDIR_P\n# ---------------\n# Check for `mkdir -p'.\nAC_DEFUN([AM_PROG_MKDIR_P],\n[AC_PREREQ([2.60])dnl\nAC_REQUIRE([AC_PROG_MKDIR_P])dnl\ndnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\ndnl while keeping a definition of mkdir_p for backward compatibility.\ndnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\ndnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\ndnl Makefile.ins that do not define MKDIR_P, so we do our own\ndnl adjustment using top_builddir (which is defined more often than\ndnl MKDIR_P).\nAC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\ncase $mkdir_p in\n  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\nesac\n])\n\n# Helper functions for option handling.                     -*- Autoconf -*-\n\n# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 3\n\n# _AM_MANGLE_OPTION(NAME)\n# -----------------------\nAC_DEFUN([_AM_MANGLE_OPTION],\n[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n\n# _AM_SET_OPTION(NAME)\n# ------------------------------\n# Set option NAME.  Presently that only means defining a flag for this option.\nAC_DEFUN([_AM_SET_OPTION],\n[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n\n# _AM_SET_OPTIONS(OPTIONS)\n# ----------------------------------\n# OPTIONS is a space-separated list of Automake options.\nAC_DEFUN([_AM_SET_OPTIONS],\n[AC_FOREACH([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n\n# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n# -------------------------------------------\n# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\nAC_DEFUN([_AM_IF_OPTION],\n[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n\n# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n\n# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 4\n\n# AM_SANITY_CHECK\n# ---------------\nAC_DEFUN([AM_SANITY_CHECK],\n[AC_MSG_CHECKING([whether build environment is sane])\n# Just in case\nsleep 1\necho timestamp > conftest.file\n# Do `set' in a subshell so we don't clobber the current shell's\n# arguments.  Must try -L first in case configure is actually a\n# symlink; some systems play weird games with the mod time of symlinks\n# (eg FreeBSD returns the mod time of the symlink's containing\n# directory).\nif (\n   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`\n   if test \"$[*]\" = \"X\"; then\n      # -L didn't work.\n      set X `ls -t $srcdir/configure conftest.file`\n   fi\n   rm -f conftest.file\n   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n\n      # If neither matched, then we have a broken ls.  This can happen\n      # if, for instance, CONFIG_SHELL is bash and it inherits a\n      # broken ls alias from the environment.  This has actually\n      # happened.  Such a system could not be considered \"sane\".\n      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\nalias in your environment])\n   fi\n\n   test \"$[2]\" = conftest.file\n   )\nthen\n   # Ok.\n   :\nelse\n   AC_MSG_ERROR([newly created file is older than distributed files!\nCheck your system clock])\nfi\nAC_MSG_RESULT(yes)])\n\n# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# AM_PROG_INSTALL_STRIP\n# ---------------------\n# One issue with vendor `install' (even GNU) is that you can't\n# specify the program used to strip binaries.  This is especially\n# annoying in cross-compiling environments, where the build's strip\n# is unlikely to handle the host's binaries.\n# Fortunately install-sh will honor a STRIPPROG variable, so we\n# always use install-sh in `make install-strip', and initialize\n# STRIPPROG with the value of the STRIP variable (set by the user).\nAC_DEFUN([AM_PROG_INSTALL_STRIP],\n[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n# Installed binaries are usually stripped using `strip' when the user\n# run `make install-strip'.  However `strip' might not be the right\n# tool to use in cross-compilation environments, therefore Automake\n# will honor the `STRIP' environment variable to overrule this program.\ndnl Don't test for $cross_compiling = yes, because it might be `maybe'.\nif test \"$cross_compiling\" != no; then\n  AC_CHECK_TOOL([STRIP], [strip], :)\nfi\nINSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\nAC_SUBST([INSTALL_STRIP_PROGRAM])])\n\n# Copyright (C) 2006  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# _AM_SUBST_NOTMAKE(VARIABLE)\n# ---------------------------\n# Prevent Automake from outputing VARIABLE = @VARIABLE@ in Makefile.in.\n# This macro is traced by Automake.\nAC_DEFUN([_AM_SUBST_NOTMAKE])\n\n# Check how to create a tarball.                            -*- Autoconf -*-\n\n# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 2\n\n# _AM_PROG_TAR(FORMAT)\n# --------------------\n# Check how to create a tarball in format FORMAT.\n# FORMAT should be one of `v7', `ustar', or `pax'.\n#\n# Substitute a variable $(am__tar) that is a command\n# writing to stdout a FORMAT-tarball containing the directory\n# $tardir.\n#     tardir=directory && $(am__tar) > result.tar\n#\n# Substitute a variable $(am__untar) that extract such\n# a tarball read from stdin.\n#     $(am__untar) < result.tar\nAC_DEFUN([_AM_PROG_TAR],\n[# Always define AMTAR for backward compatibility.\nAM_MISSING_PROG([AMTAR], [tar])\nm4_if([$1], [v7],\n     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n     [m4_case([$1], [ustar],, [pax],,\n              [m4_fatal([Unknown tar format])])\nAC_MSG_CHECKING([how to create a $1 tar archive])\n# Loop over all known methods to create a tar archive until one works.\n_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n# Do not fold the above two line into one, because Tru64 sh and\n# Solaris sh will not grok spaces in the rhs of `-'.\nfor _am_tool in $_am_tools\ndo\n  case $_am_tool in\n  gnutar)\n    for _am_tar in tar gnutar gtar;\n    do\n      AM_RUN_LOG([$_am_tar --version]) && break\n    done\n    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n    am__untar=\"$_am_tar -xf -\"\n    ;;\n  plaintar)\n    # Must skip GNU tar: if it does not support --format= it doesn't create\n    # ustar tarball either.\n    (tar --version) >/dev/null 2>&1 && continue\n    am__tar='tar chf - \"$$tardir\"'\n    am__tar_='tar chf - \"$tardir\"'\n    am__untar='tar xf -'\n    ;;\n  pax)\n    am__tar='pax -L -x $1 -w \"$$tardir\"'\n    am__tar_='pax -L -x $1 -w \"$tardir\"'\n    am__untar='pax -r'\n    ;;\n  cpio)\n    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n    am__untar='cpio -i -H $1 -d'\n    ;;\n  none)\n    am__tar=false\n    am__tar_=false\n    am__untar=false\n    ;;\n  esac\n\n  # If the value was cached, stop now.  We just wanted to have am__tar\n  # and am__untar set.\n  test -n \"${am_cv_prog_tar_$1}\" && break\n\n  # tar/untar a dummy directory, and stop if the command works\n  rm -rf conftest.dir\n  mkdir conftest.dir\n  echo GrepMe > conftest.dir/file\n  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n  rm -rf conftest.dir\n  if test -s conftest.tar; then\n    AM_RUN_LOG([$am__untar <conftest.tar])\n    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n  fi\ndone\nrm -rf conftest.dir\n\nAC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\nAC_MSG_RESULT([$am_cv_prog_tar_$1])])\nAC_SUBST([am__tar])\nAC_SUBST([am__untar])\n]) # _AM_PROG_TAR\n\nm4_include([acinclude.m4])\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/heapq.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/sqlite3/__init__.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/sqlite3/dbapi2.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/sqlite3/test/transactions.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/sqlite3/test/hooks.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/sqlite3/test/types.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/sqlite3/test/factory.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/sqlite3/test/dbapi.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/sqlite3/test/userfunctions.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/sqlite3/test/regression.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/idlelib/CREDITS.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/idlelib/Icons/plusnode.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/idlelib/Icons/folder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/idlelib/Icons/openfolder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/idlelib/Icons/minusnode.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/idlelib/Icons/tk.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/idlelib/Icons/python.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/idlelib/Icons/idle.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/testtar.tar",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/zip_cp437_header.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/zipdir.zip",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/test_pep263.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/badsyntax_pep3120.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/sgml_input.html",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/Sine-1000Hz-300ms.aif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/audiotest.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/185test.db",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/sndhdrdata/sndhdr.voc",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/sndhdrdata/sndhdr.wav",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/sndhdrdata/sndhdr.8svx",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/sndhdrdata/sndhdr.aifc",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/sndhdrdata/sndhdr.sndt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/sndhdrdata/sndhdr.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/sndhdrdata/sndhdr.aiff",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/sndhdrdata/sndhdr.hcom",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/johab.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/shift_jis.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/gb18030.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/euc_jp.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/big5.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/euc_jisx0213.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/big5hkscs.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/euc_kr.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/shift_jisx0213.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/gb2312.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/gbk.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/test/cjkencodings/cp949.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/email/test/data/PyBanner048.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/email/test/data/audiotest.au",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/distutils/command/wininst-9.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/distutils/command/wininst-8.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/distutils/command/wininst-6.0.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/distutils/command/wininst-7.1.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Lib/distutils/command/wininst-9.0-amd64.exe",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/BuildScript/resources/background.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/IDLE/IDLE.app/Contents/Resources/PythonSource.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/IDLE/IDLE.app/Contents/Resources/PythonCompiled.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/IDLE/IDLE.app/Contents/Resources/IDLE.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Resources/app/Resources/PythonApplet.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Resources/app/Resources/PythonInterpreter.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Resources/iconsrc/IDE.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Resources/iconsrc/PythonApplet.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Resources/iconsrc/PythonSource.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Resources/iconsrc/PackageManager.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Resources/iconsrc/PythonCompiled.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Resources/iconsrc/PythonWSource.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Resources/iconsrc/PythonIcon.psd",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/PythonLauncher/English.lproj/MyDocument.nib/objects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/PythonLauncher/English.lproj/MainMenu.nib/objects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/PythonLauncher/English.lproj/PreferenceWindow.nib/objects.nib",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Icons/Python Folder.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Icons/PythonSource.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Icons/Disk Image.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Icons/PythonLauncher.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Icons/PythonCompiled.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Mac/Icons/IDLE.icns",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Tools/i18n/msgfmt.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Tools/i18n/pygettext.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Objects/listsort.txt",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Doc/tools/sphinxext/static/py.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Doc/faq/python-video-icon.png",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/py.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/python_nt.rc",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/_msi.c",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/pyc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/pycon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/icons/source.xar",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/bdist_wininst/PythonPowered.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/VS7.1/python.iss",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/VS7.1/python20.wse",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PC/VS7.1/installer.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/PCbuild/installer.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Demo/tkinter/ttk/img/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Demo/tkinter/ttk/img/close_active.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Demo/tkinter/ttk/img/close_pressed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Demo/distutils/test2to3/setup.py",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Demo/tix/bitmaps/tix.gif",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/unicodedata.c",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/prepare_protocol.h",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/connection.c",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/cache.h",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/statement.h",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/sqlitecompat.h",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/statement.c",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/cache.c",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/util.h",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/module.c",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/row.c",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/util.c",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/prepare_protocol.c",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/module.h",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/row.h",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/connection.h",
        "/tmp/vanessa/spack-stage/spack-stage-python-3.1.5-hsszy4w5op4gb4posjcwcz6p3a3kbb6l/spack-src/Modules/_sqlite/cursor.h"
    ],
    "total_files": 3314
}