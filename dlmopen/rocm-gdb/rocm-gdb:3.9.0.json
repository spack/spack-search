{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gdb/solib-svr4.c": "/* Handle SVR4 shared libraries for GDB, the GNU Debugger.\n\n   Copyright (C) 1990-2020 Free Software Foundation, Inc.\n\n   This file is part of GDB.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n#include \"defs.h\"\n\n#include \"elf/external.h\"\n#include \"elf/common.h\"\n#include \"elf/mips.h\"\n\n#include \"symtab.h\"\n#include \"bfd.h\"\n#include \"symfile.h\"\n#include \"objfiles.h\"\n#include \"gdbcore.h\"\n#include \"target.h\"\n#include \"inferior.h\"\n#include \"infrun.h\"\n#include \"regcache.h\"\n#include \"gdbthread.h\"\n#include \"observable.h\"\n\n#include \"solist.h\"\n#include \"solib.h\"\n#include \"solib-svr4.h\"\n\n#include \"bfd-target.h\"\n#include \"elf-bfd.h\"\n#include \"exec.h\"\n#include \"auxv.h\"\n#include \"gdb_bfd.h\"\n#include \"probe.h\"\n\nstatic struct link_map_offsets *svr4_fetch_link_map_offsets (void);\nstatic int svr4_have_link_map_offsets (void);\nstatic void svr4_relocate_main_executable (void);\nstatic void svr4_free_library_list (void *p_list);\nstatic void probes_table_remove_objfile_probes (struct objfile *objfile);\nstatic void svr4_iterate_over_objfiles_in_search_order (\n  struct gdbarch *gdbarch, iterate_over_objfiles_in_search_order_cb_ftype *cb,\n  void *cb_data, struct objfile *objfile);\n\n\n/* On SVR4 systems, a list of symbols in the dynamic linker where\n   GDB can try to place a breakpoint to monitor shared library\n   events.\n\n   If none of these symbols are found, or other errors occur, then\n   SVR4 systems will fall back to using a symbol as the \"startup\n   mapping complete\" breakpoint address.  */\n\nstatic const char * const solib_break_names[] =\n{\n  \"r_debug_state\",\n  \"_r_debug_state\",\n  \"_dl_debug_state\",\n  \"rtld_db_dlactivity\",\n  \"__dl_rtld_db_dlactivity\",\n  \"_rtld_debug_state\",\n\n  NULL\n};\n\nstatic const char * const bkpt_names[] =\n{\n  \"_start\",\n  \"__start\",\n  \"main\",\n  NULL\n};\n\nstatic const  char * const main_name_list[] =\n{\n  \"main_$main\",\n  NULL\n};\n\n/* What to do when a probe stop occurs.  */\n\nenum probe_action\n{\n  /* Something went seriously wrong.  Stop using probes and\n     revert to using the older interface.  */\n  PROBES_INTERFACE_FAILED,\n\n  /* No action is required.  The shared object list is still\n     valid.  */\n  DO_NOTHING,\n\n  /* The shared object list should be reloaded entirely.  */\n  FULL_RELOAD,\n\n  /* Attempt to incrementally update the shared object list. If\n     the update fails or is not possible, fall back to reloading\n     the list in full.  */\n  UPDATE_OR_RELOAD,\n};\n\n/* A probe's name and its associated action.  */\n\nstruct probe_info\n{\n  /* The name of the probe.  */\n  const char *name;\n\n  /* What to do when a probe stop occurs.  */\n  enum probe_action action;\n};\n\n/* A list of named probes and their associated actions.  If all\n   probes are present in the dynamic linker then the probes-based\n   interface will be used.  */\n\nstatic const struct probe_info probe_info[] =\n{\n  { \"init_start\", DO_NOTHING },\n  { \"init_complete\", FULL_RELOAD },\n  { \"map_start\", DO_NOTHING },\n  { \"map_failed\", DO_NOTHING },\n  { \"reloc_complete\", UPDATE_OR_RELOAD },\n  { \"unmap_start\", DO_NOTHING },\n  { \"unmap_complete\", FULL_RELOAD },\n};\n\n#define NUM_PROBES ARRAY_SIZE (probe_info)\n\n/* Return non-zero if GDB_SO_NAME and INFERIOR_SO_NAME represent\n   the same shared library.  */\n\nstatic int\nsvr4_same_1 (const char *gdb_so_name, const char *inferior_so_name)\n{\n  if (strcmp (gdb_so_name, inferior_so_name) == 0)\n    return 1;\n\n  /* On Solaris, when starting inferior we think that dynamic linker is\n     /usr/lib/ld.so.1, but later on, the table of loaded shared libraries\n     contains /lib/ld.so.1.  Sometimes one file is a link to another, but\n     sometimes they have identical content, but are not linked to each\n     other.  We don't restrict this check for Solaris, but the chances\n     of running into this situation elsewhere are very low.  */\n  if (strcmp (gdb_so_name, \"/usr/lib/ld.so.1\") == 0\n      && strcmp (inferior_so_name, \"/lib/ld.so.1\") == 0)\n    return 1;\n\n  /* Similarly, we observed the same issue with amd64 and sparcv9, but with\n     different locations.  */\n  if (strcmp (gdb_so_name, \"/usr/lib/amd64/ld.so.1\") == 0\n      && strcmp (inferior_so_name, \"/lib/amd64/ld.so.1\") == 0)\n    return 1;\n\n  if (strcmp (gdb_so_name, \"/usr/lib/sparcv9/ld.so.1\") == 0\n      && strcmp (inferior_so_name, \"/lib/sparcv9/ld.so.1\") == 0)\n    return 1;\n\n  return 0;\n}\n\nstatic int\nsvr4_same (struct so_list *gdb, struct so_list *inferior)\n{\n  return (svr4_same_1 (gdb->so_original_name, inferior->so_original_name));\n}\n\nstatic std::unique_ptr<lm_info_svr4>\nlm_info_read (CORE_ADDR lm_addr)\n{\n  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();\n  std::unique_ptr<lm_info_svr4> lm_info;\n\n  gdb::byte_vector lm (lmo->link_map_size);\n\n  if (target_read_memory (lm_addr, lm.data (), lmo->link_map_size) != 0)\n    warning (_(\"Error reading shared library list entry at %s\"),\n\t     paddress (target_gdbarch (), lm_addr));\n  else\n    {\n      struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n\n      lm_info.reset (new lm_info_svr4);\n      lm_info->lm_addr = lm_addr;\n\n      lm_info->l_addr_inferior = extract_typed_address (&lm[lmo->l_addr_offset],\n\t\t\t\t\t\t\tptr_type);\n      lm_info->l_ld = extract_typed_address (&lm[lmo->l_ld_offset], ptr_type);\n      lm_info->l_next = extract_typed_address (&lm[lmo->l_next_offset],\n\t\t\t\t\t       ptr_type);\n      lm_info->l_prev = extract_typed_address (&lm[lmo->l_prev_offset],\n\t\t\t\t\t       ptr_type);\n      lm_info->l_name = extract_typed_address (&lm[lmo->l_name_offset],\n\t\t\t\t\t       ptr_type);\n    }\n\n  return lm_info;\n}\n\nstatic int\nhas_lm_dynamic_from_link_map (void)\n{\n  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();\n\n  return lmo->l_ld_offset >= 0;\n}\n\nstatic CORE_ADDR\nlm_addr_check (const struct so_list *so, bfd *abfd)\n{\n  lm_info_svr4 *li = (lm_info_svr4 *) so->lm_info;\n\n  if (!li->l_addr_p)\n    {\n      struct bfd_section *dyninfo_sect;\n      CORE_ADDR l_addr, l_dynaddr, dynaddr;\n\n      l_addr = li->l_addr_inferior;\n\n      if (! abfd || ! has_lm_dynamic_from_link_map ())\n\tgoto set_addr;\n\n      l_dynaddr = li->l_ld;\n\n      dyninfo_sect = bfd_get_section_by_name (abfd, \".dynamic\");\n      if (dyninfo_sect == NULL)\n\tgoto set_addr;\n\n      dynaddr = bfd_section_vma (dyninfo_sect);\n\n      if (dynaddr + l_addr != l_dynaddr)\n\t{\n\t  CORE_ADDR align = 0x1000;\n\t  CORE_ADDR minpagesize = align;\n\n\t  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)\n\t    {\n\t      Elf_Internal_Ehdr *ehdr = elf_tdata (abfd)->elf_header;\n\t      Elf_Internal_Phdr *phdr = elf_tdata (abfd)->phdr;\n\t      int i;\n\n\t      align = 1;\n\n\t      for (i = 0; i < ehdr->e_phnum; i++)\n\t\tif (phdr[i].p_type == PT_LOAD && phdr[i].p_align > align)\n\t\t  align = phdr[i].p_align;\n\n\t      minpagesize = get_elf_backend_data (abfd)->minpagesize;\n\t    }\n\n\t  /* Turn it into a mask.  */\n\t  align--;\n\n\t  /* If the changes match the alignment requirements, we\n\t     assume we're using a core file that was generated by the\n\t     same binary, just prelinked with a different base offset.\n\t     If it doesn't match, we may have a different binary, the\n\t     same binary with the dynamic table loaded at an unrelated\n\t     location, or anything, really.  To avoid regressions,\n\t     don't adjust the base offset in the latter case, although\n\t     odds are that, if things really changed, debugging won't\n\t     quite work.\n\n\t     One could expect more the condition\n\t       ((l_addr & align) == 0 && ((l_dynaddr - dynaddr) & align) == 0)\n\t     but the one below is relaxed for PPC.  The PPC kernel supports\n\t     either 4k or 64k page sizes.  To be prepared for 64k pages,\n\t     PPC ELF files are built using an alignment requirement of 64k.\n\t     However, when running on a kernel supporting 4k pages, the memory\n\t     mapping of the library may not actually happen on a 64k boundary!\n\n\t     (In the usual case where (l_addr & align) == 0, this check is\n\t     equivalent to the possibly expected check above.)\n\n\t     Even on PPC it must be zero-aligned at least for MINPAGESIZE.  */\n\n\t  l_addr = l_dynaddr - dynaddr;\n\n\t  if ((l_addr & (minpagesize - 1)) == 0\n\t      && (l_addr & align) == ((l_dynaddr - dynaddr) & align))\n\t    {\n\t      if (info_verbose)\n\t\tprintf_unfiltered (_(\"Using PIC (Position Independent Code) \"\n\t\t\t\t     \"prelink displacement %s for \\\"%s\\\".\\n\"),\n\t\t\t\t   paddress (target_gdbarch (), l_addr),\n\t\t\t\t   so->so_name);\n\t    }\n\t  else\n\t    {\n\t      /* There is no way to verify the library file matches.  prelink\n\t\t can during prelinking of an unprelinked file (or unprelinking\n\t\t of a prelinked file) shift the DYNAMIC segment by arbitrary\n\t\t offset without any page size alignment.  There is no way to\n\t\t find out the ELF header and/or Program Headers for a limited\n\t\t verification if it they match.  One could do a verification\n\t\t of the DYNAMIC segment.  Still the found address is the best\n\t\t one GDB could find.  */\n\n\t      warning (_(\".dynamic section for \\\"%s\\\" \"\n\t\t\t \"is not at the expected address \"\n\t\t\t \"(wrong library or version mismatch?)\"), so->so_name);\n\t    }\n\t}\n\n    set_addr:\n      li->l_addr = l_addr;\n      li->l_addr_p = 1;\n    }\n\n  return li->l_addr;\n}\n\n/* Per pspace SVR4 specific data.  */\n\nstruct svr4_info\n{\n  svr4_info () = default;\n  ~svr4_info ();\n\n  /* Base of dynamic linker structures.  */\n  CORE_ADDR debug_base = 0;\n\n  /* Validity flag for debug_loader_offset.  */\n  int debug_loader_offset_p = 0;\n\n  /* Load address for the dynamic linker, inferred.  */\n  CORE_ADDR debug_loader_offset = 0;\n\n  /* Name of the dynamic linker, valid if debug_loader_offset_p.  */\n  char *debug_loader_name = nullptr;\n\n  /* Load map address for the main executable.  */\n  CORE_ADDR main_lm_addr = 0;\n\n  CORE_ADDR interp_text_sect_low = 0;\n  CORE_ADDR interp_text_sect_high = 0;\n  CORE_ADDR interp_plt_sect_low = 0;\n  CORE_ADDR interp_plt_sect_high = 0;\n\n  /* Nonzero if the list of objects was last obtained from the target\n     via qXfer:libraries-svr4:read.  */\n  int using_xfer = 0;\n\n  /* Table of struct probe_and_action instances, used by the\n     probes-based interface to map breakpoint addresses to probes\n     and their associated actions.  Lookup is performed using\n     probe_and_action->prob->address.  */\n  htab_up probes_table;\n\n  /* List of objects loaded into the inferior, used by the probes-\n     based interface.  */\n  struct so_list *solib_list = nullptr;\n};\n\n/* Per-program-space data key.  */\nstatic const struct program_space_key<svr4_info> solib_svr4_pspace_data;\n\n/* Free the probes table.  */\n\nstatic void\nfree_probes_table (struct svr4_info *info)\n{\n  info->probes_table.reset (nullptr);\n}\n\n/* Free the solib list.  */\n\nstatic void\nfree_solib_list (struct svr4_info *info)\n{\n  svr4_free_library_list (&info->solib_list);\n  info->solib_list = NULL;\n}\n\nsvr4_info::~svr4_info ()\n{\n  free_solib_list (this);\n}\n\n/* Get the svr4 data for program space PSPACE.  If none is found yet, add it now.\n   This function always returns a valid object.  */\n\nstatic struct svr4_info *\nget_svr4_info (program_space *pspace)\n{\n  struct svr4_info *info = solib_svr4_pspace_data.get (pspace);\n\n  if (info == NULL)\n    info = solib_svr4_pspace_data.emplace (pspace);\n\n  return info;\n}\n\n/* Local function prototypes */\n\nstatic int match_main (const char *);\n\n/* Read program header TYPE from inferior memory.  The header is found\n   by scanning the OS auxiliary vector.\n\n   If TYPE == -1, return the program headers instead of the contents of\n   one program header.\n\n   Return vector of bytes holding the program header contents, or an empty\n   optional on failure.  If successful and P_ARCH_SIZE is non-NULL, the target\n   architecture size (32-bit or 64-bit) is returned to *P_ARCH_SIZE.  Likewise,\n   the base address of the section is returned in *BASE_ADDR.  */\n\nstatic gdb::optional<gdb::byte_vector>\nread_program_header (int type, int *p_arch_size, CORE_ADDR *base_addr)\n{\n  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n  CORE_ADDR at_phdr, at_phent, at_phnum, pt_phdr = 0;\n  int arch_size, sect_size;\n  CORE_ADDR sect_addr;\n  int pt_phdr_p = 0;\n\n  /* Get required auxv elements from target.  */\n  if (target_auxv_search (current_top_target (), AT_PHDR, &at_phdr) <= 0)\n    return {};\n  if (target_auxv_search (current_top_target (), AT_PHENT, &at_phent) <= 0)\n    return {};\n  if (target_auxv_search (current_top_target (), AT_PHNUM, &at_phnum) <= 0)\n    return {};\n  if (!at_phdr || !at_phnum)\n    return {};\n\n  /* Determine ELF architecture type.  */\n  if (at_phent == sizeof (Elf32_External_Phdr))\n    arch_size = 32;\n  else if (at_phent == sizeof (Elf64_External_Phdr))\n    arch_size = 64;\n  else\n    return {};\n\n  /* Find the requested segment.  */\n  if (type == -1)\n    {\n      sect_addr = at_phdr;\n      sect_size = at_phent * at_phnum;\n    }\n  else if (arch_size == 32)\n    {\n      Elf32_External_Phdr phdr;\n      int i;\n\n      /* Search for requested PHDR.  */\n      for (i = 0; i < at_phnum; i++)\n\t{\n\t  int p_type;\n\n\t  if (target_read_memory (at_phdr + i * sizeof (phdr),\n\t\t\t\t  (gdb_byte *)&phdr, sizeof (phdr)))\n\t    return {};\n\n\t  p_type = extract_unsigned_integer ((gdb_byte *) phdr.p_type,\n\t\t\t\t\t     4, byte_order);\n\n\t  if (p_type == PT_PHDR)\n\t    {\n\t      pt_phdr_p = 1;\n\t      pt_phdr = extract_unsigned_integer ((gdb_byte *) phdr.p_vaddr,\n\t\t\t\t\t\t  4, byte_order);\n\t    }\n\n\t  if (p_type == type)\n\t    break;\n\t}\n\n      if (i == at_phnum)\n\treturn {};\n\n      /* Retrieve address and size.  */\n      sect_addr = extract_unsigned_integer ((gdb_byte *)phdr.p_vaddr,\n\t\t\t\t\t    4, byte_order);\n      sect_size = extract_unsigned_integer ((gdb_byte *)phdr.p_memsz,\n\t\t\t\t\t    4, byte_order);\n    }\n  else\n    {\n      Elf64_External_Phdr phdr;\n      int i;\n\n      /* Search for requested PHDR.  */\n      for (i = 0; i < at_phnum; i++)\n\t{\n\t  int p_type;\n\n\t  if (target_read_memory (at_phdr + i * sizeof (phdr),\n\t\t\t\t  (gdb_byte *)&phdr, sizeof (phdr)))\n\t    return {};\n\n\t  p_type = extract_unsigned_integer ((gdb_byte *) phdr.p_type,\n\t\t\t\t\t     4, byte_order);\n\n\t  if (p_type == PT_PHDR)\n\t    {\n\t      pt_phdr_p = 1;\n\t      pt_phdr = extract_unsigned_integer ((gdb_byte *) phdr.p_vaddr,\n\t\t\t\t\t\t  8, byte_order);\n\t    }\n\n\t  if (p_type == type)\n\t    break;\n\t}\n\n      if (i == at_phnum)\n\treturn {};\n\n      /* Retrieve address and size.  */\n      sect_addr = extract_unsigned_integer ((gdb_byte *)phdr.p_vaddr,\n\t\t\t\t\t    8, byte_order);\n      sect_size = extract_unsigned_integer ((gdb_byte *)phdr.p_memsz,\n\t\t\t\t\t    8, byte_order);\n    }\n\n  /* PT_PHDR is optional, but we really need it\n     for PIE to make this work in general.  */\n\n  if (pt_phdr_p)\n    {\n      /* at_phdr is real address in memory. pt_phdr is what pheader says it is.\n\t Relocation offset is the difference between the two. */\n      sect_addr = sect_addr + (at_phdr - pt_phdr);\n    }\n\n  /* Read in requested program header.  */\n  gdb::byte_vector buf (sect_size);\n  if (target_read_memory (sect_addr, buf.data (), sect_size))\n    return {};\n\n  if (p_arch_size)\n    *p_arch_size = arch_size;\n  if (base_addr)\n    *base_addr = sect_addr;\n\n  return buf;\n}\n\n\n/* Return program interpreter string.  */\nstatic gdb::optional<gdb::byte_vector>\nfind_program_interpreter (void)\n{\n  /* If we have an exec_bfd, use its section table.  */\n  if (exec_bfd\n      && bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)\n   {\n     struct bfd_section *interp_sect;\n\n     interp_sect = bfd_get_section_by_name (exec_bfd, \".interp\");\n     if (interp_sect != NULL)\n      {\n\tint sect_size = bfd_section_size (interp_sect);\n\n\tgdb::byte_vector buf (sect_size);\n\tbfd_get_section_contents (exec_bfd, interp_sect, buf.data (), 0,\n\t\t\t\t  sect_size);\n\treturn buf;\n      }\n   }\n\n  /* If we didn't find it, use the target auxiliary vector.  */\n  return read_program_header (PT_INTERP, NULL, NULL);\n}\n\n\n/* Scan for DESIRED_DYNTAG in .dynamic section of ABFD.  If DESIRED_DYNTAG is\n   found, 1 is returned and the corresponding PTR is set.  */\n\nstatic int\nscan_dyntag (const int desired_dyntag, bfd *abfd, CORE_ADDR *ptr,\n\t     CORE_ADDR *ptr_addr)\n{\n  int arch_size, step, sect_size;\n  long current_dyntag;\n  CORE_ADDR dyn_ptr, dyn_addr;\n  gdb_byte *bufend, *bufstart, *buf;\n  Elf32_External_Dyn *x_dynp_32;\n  Elf64_External_Dyn *x_dynp_64;\n  struct bfd_section *sect;\n  struct target_section *target_section;\n\n  if (abfd == NULL)\n    return 0;\n\n  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)\n    return 0;\n\n  arch_size = bfd_get_arch_size (abfd);\n  if (arch_size == -1)\n    return 0;\n\n  /* Find the start address of the .dynamic section.  */\n  sect = bfd_get_section_by_name (abfd, \".dynamic\");\n  if (sect == NULL)\n    return 0;\n\n  for (target_section = current_target_sections->sections;\n       target_section < current_target_sections->sections_end;\n       target_section++)\n    if (sect == target_section->the_bfd_section)\n      break;\n  if (target_section < current_target_sections->sections_end)\n    dyn_addr = target_section->addr;\n  else\n    {\n      /* ABFD may come from OBJFILE acting only as a symbol file without being\n\t loaded into the target (see add_symbol_file_command).  This case is\n\t such fallback to the file VMA address without the possibility of\n\t having the section relocated to its actual in-memory address.  */\n\n      dyn_addr = bfd_section_vma (sect);\n    }\n\n  /* Read in .dynamic from the BFD.  We will get the actual value\n     from memory later.  */\n  sect_size = bfd_section_size (sect);\n  buf = bufstart = (gdb_byte *) alloca (sect_size);\n  if (!bfd_get_section_contents (abfd, sect,\n\t\t\t\t buf, 0, sect_size))\n    return 0;\n\n  /* Iterate over BUF and scan for DYNTAG.  If found, set PTR and return.  */\n  step = (arch_size == 32) ? sizeof (Elf32_External_Dyn)\n\t\t\t   : sizeof (Elf64_External_Dyn);\n  for (bufend = buf + sect_size;\n       buf < bufend;\n       buf += step)\n  {\n    if (arch_size == 32)\n      {\n\tx_dynp_32 = (Elf32_External_Dyn *) buf;\n\tcurrent_dyntag = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp_32->d_tag);\n\tdyn_ptr = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp_32->d_un.d_ptr);\n      }\n    else\n      {\n\tx_dynp_64 = (Elf64_External_Dyn *) buf;\n\tcurrent_dyntag = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_tag);\n\tdyn_ptr = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_un.d_ptr);\n      }\n     if (current_dyntag == DT_NULL)\n       return 0;\n     if (current_dyntag == desired_dyntag)\n       {\n\t /* If requested, try to read the runtime value of this .dynamic\n\t    entry.  */\n\t if (ptr)\n\t   {\n\t     struct type *ptr_type;\n\t     gdb_byte ptr_buf[8];\n\t     CORE_ADDR ptr_addr_1;\n\n\t     ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n\t     ptr_addr_1 = dyn_addr + (buf - bufstart) + arch_size / 8;\n\t     if (target_read_memory (ptr_addr_1, ptr_buf, arch_size / 8) == 0)\n\t       dyn_ptr = extract_typed_address (ptr_buf, ptr_type);\n\t     *ptr = dyn_ptr;\n\t     if (ptr_addr)\n\t       *ptr_addr = dyn_addr + (buf - bufstart);\n\t   }\n\t return 1;\n       }\n  }\n\n  return 0;\n}\n\n/* Scan for DESIRED_DYNTAG in .dynamic section of the target's main executable,\n   found by consulting the OS auxillary vector.  If DESIRED_DYNTAG is found, 1\n   is returned and the corresponding PTR is set.  */\n\nstatic int\nscan_dyntag_auxv (const int desired_dyntag, CORE_ADDR *ptr,\n\t\t  CORE_ADDR *ptr_addr)\n{\n  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n  int arch_size, step;\n  long current_dyntag;\n  CORE_ADDR dyn_ptr;\n  CORE_ADDR base_addr;\n\n  /* Read in .dynamic section.  */\n  gdb::optional<gdb::byte_vector> ph_data\n    = read_program_header (PT_DYNAMIC, &arch_size, &base_addr);\n  if (!ph_data)\n    return 0;\n\n  /* Iterate over BUF and scan for DYNTAG.  If found, set PTR and return.  */\n  step = (arch_size == 32) ? sizeof (Elf32_External_Dyn)\n\t\t\t   : sizeof (Elf64_External_Dyn);\n  for (gdb_byte *buf = ph_data->data (), *bufend = buf + ph_data->size ();\n       buf < bufend; buf += step)\n  {\n    if (arch_size == 32)\n      {\n\tElf32_External_Dyn *dynp = (Elf32_External_Dyn *) buf;\n\n\tcurrent_dyntag = extract_unsigned_integer ((gdb_byte *) dynp->d_tag,\n\t\t\t\t\t    4, byte_order);\n\tdyn_ptr = extract_unsigned_integer ((gdb_byte *) dynp->d_un.d_ptr,\n\t\t\t\t\t    4, byte_order);\n      }\n    else\n      {\n\tElf64_External_Dyn *dynp = (Elf64_External_Dyn *) buf;\n\n\tcurrent_dyntag = extract_unsigned_integer ((gdb_byte *) dynp->d_tag,\n\t\t\t\t\t    8, byte_order);\n\tdyn_ptr = extract_unsigned_integer ((gdb_byte *) dynp->d_un.d_ptr,\n\t\t\t\t\t    8, byte_order);\n      }\n    if (current_dyntag == DT_NULL)\n      break;\n\n    if (current_dyntag == desired_dyntag)\n      {\n\tif (ptr)\n\t  *ptr = dyn_ptr;\n\n\tif (ptr_addr)\n\t  *ptr_addr = base_addr + buf - ph_data->data ();\n\n\treturn 1;\n      }\n  }\n\n  return 0;\n}\n\n/* Locate the base address of dynamic linker structs for SVR4 elf\n   targets.\n\n   For SVR4 elf targets the address of the dynamic linker's runtime\n   structure is contained within the dynamic info section in the\n   executable file.  The dynamic section is also mapped into the\n   inferior address space.  Because the runtime loader fills in the\n   real address before starting the inferior, we have to read in the\n   dynamic info section from the inferior address space.\n   If there are any errors while trying to find the address, we\n   silently return 0, otherwise the found address is returned.  */\n\nstatic CORE_ADDR\nelf_locate_base (void)\n{\n  struct bound_minimal_symbol msymbol;\n  CORE_ADDR dyn_ptr, dyn_ptr_addr;\n\n  /* Look for DT_MIPS_RLD_MAP first.  MIPS executables use this\n     instead of DT_DEBUG, although they sometimes contain an unused\n     DT_DEBUG.  */\n  if (scan_dyntag (DT_MIPS_RLD_MAP, exec_bfd, &dyn_ptr, NULL)\n      || scan_dyntag_auxv (DT_MIPS_RLD_MAP, &dyn_ptr, NULL))\n    {\n      struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n      gdb_byte *pbuf;\n      int pbuf_size = TYPE_LENGTH (ptr_type);\n\n      pbuf = (gdb_byte *) alloca (pbuf_size);\n      /* DT_MIPS_RLD_MAP contains a pointer to the address\n\t of the dynamic link structure.  */\n      if (target_read_memory (dyn_ptr, pbuf, pbuf_size))\n\treturn 0;\n      return extract_typed_address (pbuf, ptr_type);\n    }\n\n  /* Then check DT_MIPS_RLD_MAP_REL.  MIPS executables now use this form\n     because of needing to support PIE.  DT_MIPS_RLD_MAP will also exist\n     in non-PIE.  */\n  if (scan_dyntag (DT_MIPS_RLD_MAP_REL, exec_bfd, &dyn_ptr, &dyn_ptr_addr)\n      || scan_dyntag_auxv (DT_MIPS_RLD_MAP_REL, &dyn_ptr, &dyn_ptr_addr))\n    {\n      struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n      gdb_byte *pbuf;\n      int pbuf_size = TYPE_LENGTH (ptr_type);\n\n      pbuf = (gdb_byte *) alloca (pbuf_size);\n      /* DT_MIPS_RLD_MAP_REL contains an offset from the address of the\n\t DT slot to the address of the dynamic link structure.  */\n      if (target_read_memory (dyn_ptr + dyn_ptr_addr, pbuf, pbuf_size))\n\treturn 0;\n      return extract_typed_address (pbuf, ptr_type);\n    }\n\n  /* Find DT_DEBUG.  */\n  if (scan_dyntag (DT_DEBUG, exec_bfd, &dyn_ptr, NULL)\n      || scan_dyntag_auxv (DT_DEBUG, &dyn_ptr, NULL))\n    return dyn_ptr;\n\n  /* This may be a static executable.  Look for the symbol\n     conventionally named _r_debug, as a last resort.  */\n  msymbol = lookup_minimal_symbol (\"_r_debug\", NULL, symfile_objfile);\n  if (msymbol.minsym != NULL)\n    return BMSYMBOL_VALUE_ADDRESS (msymbol);\n\n  /* DT_DEBUG entry not found.  */\n  return 0;\n}\n\n/* Locate the base address of dynamic linker structs.\n\n   For both the SunOS and SVR4 shared library implementations, if the\n   inferior executable has been linked dynamically, there is a single\n   address somewhere in the inferior's data space which is the key to\n   locating all of the dynamic linker's runtime structures.  This\n   address is the value of the debug base symbol.  The job of this\n   function is to find and return that address, or to return 0 if there\n   is no such address (the executable is statically linked for example).\n\n   For SunOS, the job is almost trivial, since the dynamic linker and\n   all of it's structures are statically linked to the executable at\n   link time.  Thus the symbol for the address we are looking for has\n   already been added to the minimal symbol table for the executable's\n   objfile at the time the symbol file's symbols were read, and all we\n   have to do is look it up there.  Note that we explicitly do NOT want\n   to find the copies in the shared library.\n\n   The SVR4 version is a bit more complicated because the address\n   is contained somewhere in the dynamic info section.  We have to go\n   to a lot more work to discover the address of the debug base symbol.\n   Because of this complexity, we cache the value we find and return that\n   value on subsequent invocations.  Note there is no copy in the\n   executable symbol tables.  */\n\nstatic CORE_ADDR\nlocate_base (struct svr4_info *info)\n{\n  /* Check to see if we have a currently valid address, and if so, avoid\n     doing all this work again and just return the cached address.  If\n     we have no cached address, try to locate it in the dynamic info\n     section for ELF executables.  There's no point in doing any of this\n     though if we don't have some link map offsets to work with.  */\n\n  if (info->debug_base == 0 && svr4_have_link_map_offsets ())\n    info->debug_base = elf_locate_base ();\n  return info->debug_base;\n}\n\n/* Find the first element in the inferior's dynamic link map, and\n   return its address in the inferior.  Return zero if the address\n   could not be determined.\n\n   FIXME: Perhaps we should validate the info somehow, perhaps by\n   checking r_version for a known version number, or r_state for\n   RT_CONSISTENT.  */\n\nstatic CORE_ADDR\nsolib_svr4_r_map (struct svr4_info *info)\n{\n  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();\n  struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n  CORE_ADDR addr = 0;\n\n  try\n    {\n      addr = read_memory_typed_address (info->debug_base + lmo->r_map_offset,\n                                        ptr_type);\n    }\n  catch (const gdb_exception_error &ex)\n    {\n      exception_print (gdb_stderr, ex);\n    }\n\n  return addr;\n}\n\n/* Find r_brk from the inferior's debug base.  */\n\nstatic CORE_ADDR\nsolib_svr4_r_brk (struct svr4_info *info)\n{\n  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();\n  struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n\n  return read_memory_typed_address (info->debug_base + lmo->r_brk_offset,\n\t\t\t\t    ptr_type);\n}\n\n/* Find the link map for the dynamic linker (if it is not in the\n   normal list of loaded shared objects).  */\n\nstatic CORE_ADDR\nsolib_svr4_r_ldsomap (struct svr4_info *info)\n{\n  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();\n  struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n  enum bfd_endian byte_order = type_byte_order (ptr_type);\n  ULONGEST version = 0;\n\n  try\n    {\n      /* Check version, and return zero if `struct r_debug' doesn't have\n\t the r_ldsomap member.  */\n      version\n\t= read_memory_unsigned_integer (info->debug_base + lmo->r_version_offset,\n\t\t\t\t\tlmo->r_version_size, byte_order);\n    }\n  catch (const gdb_exception_error &ex)\n    {\n      exception_print (gdb_stderr, ex);\n    }\n\n  if (version < 2 || lmo->r_ldsomap_offset == -1)\n    return 0;\n\n  return read_memory_typed_address (info->debug_base + lmo->r_ldsomap_offset,\n\t\t\t\t    ptr_type);\n}\n\n/* On Solaris systems with some versions of the dynamic linker,\n   ld.so's l_name pointer points to the SONAME in the string table\n   rather than into writable memory.  So that GDB can find shared\n   libraries when loading a core file generated by gcore, ensure that\n   memory areas containing the l_name string are saved in the core\n   file.  */\n\nstatic int\nsvr4_keep_data_in_core (CORE_ADDR vaddr, unsigned long size)\n{\n  struct svr4_info *info;\n  CORE_ADDR ldsomap;\n  CORE_ADDR name_lm;\n\n  info = get_svr4_info (current_program_space);\n\n  info->debug_base = 0;\n  locate_base (info);\n  if (!info->debug_base)\n    return 0;\n\n  ldsomap = solib_svr4_r_ldsomap (info);\n  if (!ldsomap)\n    return 0;\n\n  std::unique_ptr<lm_info_svr4> li = lm_info_read (ldsomap);\n  name_lm = li != NULL ? li->l_name : 0;\n\n  return (name_lm >= vaddr && name_lm < vaddr + size);\n}\n\n/* See solist.h.  */\n\nstatic int\nopen_symbol_file_object (int from_tty)\n{\n  CORE_ADDR lm, l_name;\n  gdb::unique_xmalloc_ptr<char> filename;\n  int errcode;\n  struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();\n  struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n  int l_name_size = TYPE_LENGTH (ptr_type);\n  gdb::byte_vector l_name_buf (l_name_size);\n  struct svr4_info *info = get_svr4_info (current_program_space);\n  symfile_add_flags add_flags = 0;\n\n  if (from_tty)\n    add_flags |= SYMFILE_VERBOSE;\n\n  if (symfile_objfile)\n    if (!query (_(\"Attempt to reload symbols from process? \")))\n      return 0;\n\n  /* Always locate the debug struct, in case it has moved.  */\n  info->debug_base = 0;\n  if (locate_base (info) == 0)\n    return 0;\t/* failed somehow...  */\n\n  /* First link map member should be the executable.  */\n  lm = solib_svr4_r_map (info);\n  if (lm == 0)\n    return 0;\t/* failed somehow...  */\n\n  /* Read address of name from target memory to GDB.  */\n  read_memory (lm + lmo->l_name_offset, l_name_buf.data (), l_name_size);\n\n  /* Convert the address to host format.  */\n  l_name = extract_typed_address (l_name_buf.data (), ptr_type);\n\n  if (l_name == 0)\n    return 0;\t\t/* No filename.  */\n\n  /* Now fetch the filename from target memory.  */\n  target_read_string (l_name, &filename, SO_NAME_MAX_PATH_SIZE - 1, &errcode);\n\n  if (errcode)\n    {\n      warning (_(\"failed to read exec filename from attached file: %s\"),\n\t       safe_strerror (errcode));\n      return 0;\n    }\n\n  /* Have a pathname: read the symbol file.  */\n  symbol_file_add_main (filename.get (), add_flags);\n\n  return 1;\n}\n\n/* Data exchange structure for the XML parser as returned by\n   svr4_current_sos_via_xfer_libraries.  */\n\nstruct svr4_library_list\n{\n  struct so_list *head, **tailp;\n\n  /* Inferior address of struct link_map used for the main executable.  It is\n     NULL if not known.  */\n  CORE_ADDR main_lm;\n};\n\n/* This module's 'free_objfile' observer.  */\n\nstatic void\nsvr4_free_objfile_observer (struct objfile *objfile)\n{\n  probes_table_remove_objfile_probes (objfile);\n}\n\n/* Implementation for target_so_ops.free_so.  */\n\nstatic void\nsvr4_free_so (struct so_list *so)\n{\n  lm_info_svr4 *li = (lm_info_svr4 *) so->lm_info;\n\n  delete li;\n}\n\n/* Implement target_so_ops.clear_so.  */\n\nstatic void\nsvr4_clear_so (struct so_list *so)\n{\n  lm_info_svr4 *li = (lm_info_svr4 *) so->lm_info;\n\n  if (li != NULL)\n    li->l_addr_p = 0;\n}\n\n/* Free so_list built so far (called via cleanup).  */\n\nstatic void\nsvr4_free_library_list (void *p_list)\n{\n  struct so_list *list = *(struct so_list **) p_list;\n\n  while (list != NULL)\n    {\n      struct so_list *next = list->next;\n\n      free_so (list);\n      list = next;\n    }\n}\n\n/* Copy library list.  */\n\nstatic struct so_list *\nsvr4_copy_library_list (struct so_list *src)\n{\n  struct so_list *dst = NULL;\n  struct so_list **link = &dst;\n\n  while (src != NULL)\n    {\n      struct so_list *newobj;\n\n      newobj = XNEW (struct so_list);\n      memcpy (newobj, src, sizeof (struct so_list));\n\n      lm_info_svr4 *src_li = (lm_info_svr4 *) src->lm_info;\n      newobj->lm_info = new lm_info_svr4 (*src_li);\n\n      newobj->next = NULL;\n      *link = newobj;\n      link = &newobj->next;\n\n      src = src->next;\n    }\n\n  return dst;\n}\n\n#ifdef HAVE_LIBEXPAT\n\n#include \"xml-support.h\"\n\n/* Handle the start of a <library> element.  Note: new elements are added\n   at the tail of the list, keeping the list in order.  */\n\nstatic void\nlibrary_list_start_library (struct gdb_xml_parser *parser,\n\t\t\t    const struct gdb_xml_element *element,\n\t\t\t    void *user_data,\n\t\t\t    std::vector<gdb_xml_value> &attributes)\n{\n  struct svr4_library_list *list = (struct svr4_library_list *) user_data;\n  const char *name\n    = (const char *) xml_find_attribute (attributes, \"name\")->value.get ();\n  ULONGEST *lmp\n    = (ULONGEST *) xml_find_attribute (attributes, \"lm\")->value.get ();\n  ULONGEST *l_addrp\n    = (ULONGEST *) xml_find_attribute (attributes, \"l_addr\")->value.get ();\n  ULONGEST *l_ldp\n    = (ULONGEST *) xml_find_attribute (attributes, \"l_ld\")->value.get ();\n  struct so_list *new_elem;\n\n  new_elem = XCNEW (struct so_list);\n  lm_info_svr4 *li = new lm_info_svr4;\n  new_elem->lm_info = li;\n  li->lm_addr = *lmp;\n  li->l_addr_inferior = *l_addrp;\n  li->l_ld = *l_ldp;\n\n  strncpy (new_elem->so_name, name, sizeof (new_elem->so_name) - 1);\n  new_elem->so_name[sizeof (new_elem->so_name) - 1] = 0;\n  strcpy (new_elem->so_original_name, new_elem->so_name);\n\n  *list->tailp = new_elem;\n  list->tailp = &new_elem->next;\n}\n\n/* Handle the start of a <library-list-svr4> element.  */\n\nstatic void\nsvr4_library_list_start_list (struct gdb_xml_parser *parser,\n\t\t\t      const struct gdb_xml_element *element,\n\t\t\t      void *user_data,\n\t\t\t      std::vector<gdb_xml_value> &attributes)\n{\n  struct svr4_library_list *list = (struct svr4_library_list *) user_data;\n  const char *version\n    = (const char *) xml_find_attribute (attributes, \"version\")->value.get ();\n  struct gdb_xml_value *main_lm = xml_find_attribute (attributes, \"main-lm\");\n\n  if (strcmp (version, \"1.0\") != 0)\n    gdb_xml_error (parser,\n\t\t   _(\"SVR4 Library list has unsupported version \\\"%s\\\"\"),\n\t\t   version);\n\n  if (main_lm)\n    list->main_lm = *(ULONGEST *) main_lm->value.get ();\n}\n\n/* The allowed elements and attributes for an XML library list.\n   The root element is a <library-list>.  */\n\nstatic const struct gdb_xml_attribute svr4_library_attributes[] =\n{\n  { \"name\", GDB_XML_AF_NONE, NULL, NULL },\n  { \"lm\", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },\n  { \"l_addr\", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },\n  { \"l_ld\", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },\n  { NULL, GDB_XML_AF_NONE, NULL, NULL }\n};\n\nstatic const struct gdb_xml_element svr4_library_list_children[] =\n{\n  {\n    \"library\", svr4_library_attributes, NULL,\n    GDB_XML_EF_REPEATABLE | GDB_XML_EF_OPTIONAL,\n    library_list_start_library, NULL\n  },\n  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }\n};\n\nstatic const struct gdb_xml_attribute svr4_library_list_attributes[] =\n{\n  { \"version\", GDB_XML_AF_NONE, NULL, NULL },\n  { \"main-lm\", GDB_XML_AF_OPTIONAL, gdb_xml_parse_attr_ulongest, NULL },\n  { NULL, GDB_XML_AF_NONE, NULL, NULL }\n};\n\nstatic const struct gdb_xml_element svr4_library_list_elements[] =\n{\n  { \"library-list-svr4\", svr4_library_list_attributes, svr4_library_list_children,\n    GDB_XML_EF_NONE, svr4_library_list_start_list, NULL },\n  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }\n};\n\n/* Parse qXfer:libraries:read packet into *SO_LIST_RETURN.  Return 1 if\n\n   Return 0 if packet not supported, *SO_LIST_RETURN is not modified in such\n   case.  Return 1 if *SO_LIST_RETURN contains the library list, it may be\n   empty, caller is responsible for freeing all its entries.  */\n\nstatic int\nsvr4_parse_libraries (const char *document, struct svr4_library_list *list)\n{\n  auto cleanup = make_scope_exit ([&] ()\n    {\n      svr4_free_library_list (&list->head);\n    });\n\n  memset (list, 0, sizeof (*list));\n  list->tailp = &list->head;\n  if (gdb_xml_parse_quick (_(\"target library list\"), \"library-list-svr4.dtd\",\n\t\t\t   svr4_library_list_elements, document, list) == 0)\n    {\n      /* Parsed successfully, keep the result.  */\n      cleanup.release ();\n      return 1;\n    }\n\n  return 0;\n}\n\n/* Attempt to get so_list from target via qXfer:libraries-svr4:read packet.\n\n   Return 0 if packet not supported, *SO_LIST_RETURN is not modified in such\n   case.  Return 1 if *SO_LIST_RETURN contains the library list, it may be\n   empty, caller is responsible for freeing all its entries.\n\n   Note that ANNEX must be NULL if the remote does not explicitly allow\n   qXfer:libraries-svr4:read packets with non-empty annexes.  Support for\n   this can be checked using target_augmented_libraries_svr4_read ().  */\n\nstatic int\nsvr4_current_sos_via_xfer_libraries (struct svr4_library_list *list,\n\t\t\t\t     const char *annex)\n{\n  gdb_assert (annex == NULL || target_augmented_libraries_svr4_read ());\n\n  /* Fetch the list of shared libraries.  */\n  gdb::optional<gdb::char_vector> svr4_library_document\n    = target_read_stralloc (current_top_target (), TARGET_OBJECT_LIBRARIES_SVR4,\n\t\t\t    annex);\n  if (!svr4_library_document)\n    return 0;\n\n  return svr4_parse_libraries (svr4_library_document->data (), list);\n}\n\n#else\n\nstatic int\nsvr4_current_sos_via_xfer_libraries (struct svr4_library_list *list,\n\t\t\t\t     const char *annex)\n{\n  return 0;\n}\n\n#endif\n\n/* If no shared library information is available from the dynamic\n   linker, build a fallback list from other sources.  */\n\nstatic struct so_list *\nsvr4_default_sos (svr4_info *info)\n{\n  struct so_list *newobj;\n\n  if (!info->debug_loader_offset_p)\n    return NULL;\n\n  newobj = XCNEW (struct so_list);\n  lm_info_svr4 *li = new lm_info_svr4;\n  newobj->lm_info = li;\n\n  /* Nothing will ever check the other fields if we set l_addr_p.  */\n  li->l_addr = info->debug_loader_offset;\n  li->l_addr_p = 1;\n\n  strncpy (newobj->so_name, info->debug_loader_name, SO_NAME_MAX_PATH_SIZE - 1);\n  newobj->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\\0';\n  strcpy (newobj->so_original_name, newobj->so_name);\n\n  return newobj;\n}\n\n/* Read the whole inferior libraries chain starting at address LM.\n   Expect the first entry in the chain's previous entry to be PREV_LM.\n   Add the entries to the tail referenced by LINK_PTR_PTR.  Ignore the\n   first entry if IGNORE_FIRST and set global MAIN_LM_ADDR according\n   to it.  Returns nonzero upon success.  If zero is returned the\n   entries stored to LINK_PTR_PTR are still valid although they may\n   represent only part of the inferior library list.  */\n\nstatic int\nsvr4_read_so_list (svr4_info *info, CORE_ADDR lm, CORE_ADDR prev_lm,\n\t\t   struct so_list ***link_ptr_ptr, int ignore_first)\n{\n  CORE_ADDR first_l_name = 0;\n  CORE_ADDR next_lm;\n\n  for (; lm != 0; prev_lm = lm, lm = next_lm)\n    {\n      int errcode;\n      gdb::unique_xmalloc_ptr<char> buffer;\n\n      so_list_up newobj (XCNEW (struct so_list));\n\n      lm_info_svr4 *li = lm_info_read (lm).release ();\n      newobj->lm_info = li;\n      if (li == NULL)\n\treturn 0;\n\n      next_lm = li->l_next;\n\n      if (li->l_prev != prev_lm)\n\t{\n\t  warning (_(\"Corrupted shared library list: %s != %s\"),\n\t\t   paddress (target_gdbarch (), prev_lm),\n\t\t   paddress (target_gdbarch (), li->l_prev));\n\t  return 0;\n\t}\n\n      /* For SVR4 versions, the first entry in the link map is for the\n         inferior executable, so we must ignore it.  For some versions of\n         SVR4, it has no name.  For others (Solaris 2.3 for example), it\n         does have a name, so we can no longer use a missing name to\n         decide when to ignore it.  */\n      if (ignore_first && li->l_prev == 0)\n\t{\n\t  first_l_name = li->l_name;\n\t  info->main_lm_addr = li->lm_addr;\n\t  continue;\n\t}\n\n      /* Extract this shared object's name.  */\n      target_read_string (li->l_name, &buffer, SO_NAME_MAX_PATH_SIZE - 1,\n\t\t\t  &errcode);\n      if (errcode != 0)\n\t{\n\t  /* If this entry's l_name address matches that of the\n\t     inferior executable, then this is not a normal shared\n\t     object, but (most likely) a vDSO.  In this case, silently\n\t     skip it; otherwise emit a warning. */\n\t  if (first_l_name == 0 || li->l_name != first_l_name)\n\t    warning (_(\"Can't read pathname for load map: %s.\"),\n\t\t     safe_strerror (errcode));\n\t  continue;\n\t}\n\n      strncpy (newobj->so_name, buffer.get (), SO_NAME_MAX_PATH_SIZE - 1);\n      newobj->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\\0';\n      strcpy (newobj->so_original_name, newobj->so_name);\n\n      /* If this entry has no name, or its name matches the name\n\t for the main executable, don't include it in the list.  */\n      if (! newobj->so_name[0] || match_main (newobj->so_name))\n\tcontinue;\n\n      newobj->next = 0;\n      /* Don't free it now.  */\n      **link_ptr_ptr = newobj.release ();\n      *link_ptr_ptr = &(**link_ptr_ptr)->next;\n    }\n\n  return 1;\n}\n\n/* Read the full list of currently loaded shared objects directly\n   from the inferior, without referring to any libraries read and\n   stored by the probes interface.  Handle special cases relating\n   to the first elements of the list.  */\n\nstatic struct so_list *\nsvr4_current_sos_direct (struct svr4_info *info)\n{\n  CORE_ADDR lm;\n  struct so_list *head = NULL;\n  struct so_list **link_ptr = &head;\n  int ignore_first;\n  struct svr4_library_list library_list;\n\n  /* Fall back to manual examination of the target if the packet is not\n     supported or gdbserver failed to find DT_DEBUG.  gdb.server/solib-list.exp\n     tests a case where gdbserver cannot find the shared libraries list while\n     GDB itself is able to find it via SYMFILE_OBJFILE.\n\n     Unfortunately statically linked inferiors will also fall back through this\n     suboptimal code path.  */\n\n  info->using_xfer = svr4_current_sos_via_xfer_libraries (&library_list,\n\t\t\t\t\t\t\t  NULL);\n  if (info->using_xfer)\n    {\n      if (library_list.main_lm)\n\tinfo->main_lm_addr = library_list.main_lm;\n\n      return library_list.head ? library_list.head : svr4_default_sos (info);\n    }\n\n  /* Always locate the debug struct, in case it has moved.  */\n  info->debug_base = 0;\n  locate_base (info);\n\n  /* If we can't find the dynamic linker's base structure, this\n     must not be a dynamically linked executable.  Hmm.  */\n  if (! info->debug_base)\n    return svr4_default_sos (info);\n\n  /* Assume that everything is a library if the dynamic loader was loaded\n     late by a static executable.  */\n  if (exec_bfd && bfd_get_section_by_name (exec_bfd, \".dynamic\") == NULL)\n    ignore_first = 0;\n  else\n    ignore_first = 1;\n\n  auto cleanup = make_scope_exit ([&] ()\n    {\n      svr4_free_library_list (&head);\n    });\n\n  /* Walk the inferior's link map list, and build our list of\n     `struct so_list' nodes.  */\n  lm = solib_svr4_r_map (info);\n  if (lm)\n    svr4_read_so_list (info, lm, 0, &link_ptr, ignore_first);\n\n  /* On Solaris, the dynamic linker is not in the normal list of\n     shared objects, so make sure we pick it up too.  Having\n     symbol information for the dynamic linker is quite crucial\n     for skipping dynamic linker resolver code.  */\n  lm = solib_svr4_r_ldsomap (info);\n  if (lm)\n    svr4_read_so_list (info, lm, 0, &link_ptr, 0);\n\n  cleanup.release ();\n\n  if (head == NULL)\n    return svr4_default_sos (info);\n\n  return head;\n}\n\n/* Implement the main part of the \"current_sos\" target_so_ops\n   method.  */\n\nstatic struct so_list *\nsvr4_current_sos_1 (svr4_info *info)\n{\n  /* If the solib list has been read and stored by the probes\n     interface then we return a copy of the stored list.  */\n  if (info->solib_list != NULL)\n    return svr4_copy_library_list (info->solib_list);\n\n  /* Otherwise obtain the solib list directly from the inferior.  */\n  return svr4_current_sos_direct (info);\n}\n\n/* Implement the \"current_sos\" target_so_ops method.  */\n\nstatic struct so_list *\nsvr4_current_sos (void)\n{\n  svr4_info *info = get_svr4_info (current_program_space);\n  struct so_list *so_head = svr4_current_sos_1 (info);\n  struct mem_range vsyscall_range;\n\n  /* Filter out the vDSO module, if present.  Its symbol file would\n     not be found on disk.  The vDSO/vsyscall's OBJFILE is instead\n     managed by symfile-mem.c:add_vsyscall_page.  */\n  if (gdbarch_vsyscall_range (target_gdbarch (), &vsyscall_range)\n      && vsyscall_range.length != 0)\n    {\n      struct so_list **sop;\n\n      sop = &so_head;\n      while (*sop != NULL)\n\t{\n\t  struct so_list *so = *sop;\n\n\t  /* We can't simply match the vDSO by starting address alone,\n\t     because lm_info->l_addr_inferior (and also l_addr) do not\n\t     necessarily represent the real starting address of the\n\t     ELF if the vDSO's ELF itself is \"prelinked\".  The l_ld\n\t     field (the \".dynamic\" section of the shared object)\n\t     always points at the absolute/resolved address though.\n\t     So check whether that address is inside the vDSO's\n\t     mapping instead.\n\n\t     E.g., on Linux 3.16 (x86_64) the vDSO is a regular\n\t     0-based ELF, and we see:\n\n\t      (gdb) info auxv\n\t      33  AT_SYSINFO_EHDR  System-supplied DSO's ELF header 0x7ffff7ffb000\n\t      (gdb)  p/x *_r_debug.r_map.l_next\n\t      $1 = {l_addr = 0x7ffff7ffb000, ..., l_ld = 0x7ffff7ffb318, ...}\n\n\t     And on Linux 2.6.32 (x86_64) we see:\n\n\t      (gdb) info auxv\n\t      33  AT_SYSINFO_EHDR  System-supplied DSO's ELF header 0x7ffff7ffe000\n\t      (gdb) p/x *_r_debug.r_map.l_next\n\t      $5 = {l_addr = 0x7ffff88fe000, ..., l_ld = 0x7ffff7ffe580, ... }\n\n\t     Dumping that vDSO shows:\n\n\t      (gdb) info proc mappings\n\t      0x7ffff7ffe000  0x7ffff7fff000  0x1000  0  [vdso]\n\t      (gdb) dump memory vdso.bin 0x7ffff7ffe000 0x7ffff7fff000\n\t      # readelf -Wa vdso.bin\n\t      [...]\n\t\tEntry point address: 0xffffffffff700700\n\t      [...]\n\t      Section Headers:\n\t\t[Nr] Name     Type    Address\t       Off    Size\n\t\t[ 0]\t      NULL    0000000000000000 000000 000000\n\t\t[ 1] .hash    HASH    ffffffffff700120 000120 000038\n\t\t[ 2] .dynsym  DYNSYM  ffffffffff700158 000158 0000d8\n\t      [...]\n\t\t[ 9] .dynamic DYNAMIC ffffffffff700580 000580 0000f0\n\t  */\n\n\t  lm_info_svr4 *li = (lm_info_svr4 *) so->lm_info;\n\n\t  if (address_in_mem_range (li->l_ld, &vsyscall_range))\n\t    {\n\t      *sop = so->next;\n\t      free_so (so);\n\t      break;\n\t    }\n\n\t  sop = &so->next;\n\t}\n    }\n\n  return so_head;\n}\n\n/* Get the address of the link_map for a given OBJFILE.  */\n\nCORE_ADDR\nsvr4_fetch_objfile_link_map (struct objfile *objfile)\n{\n  struct so_list *so;\n  struct svr4_info *info = get_svr4_info (objfile->pspace);\n\n  /* Cause svr4_current_sos() to be run if it hasn't been already.  */\n  if (info->main_lm_addr == 0)\n    solib_add (NULL, 0, auto_solib_add);\n\n  /* svr4_current_sos() will set main_lm_addr for the main executable.  */\n  if (objfile == symfile_objfile)\n    return info->main_lm_addr;\n\n  /* If OBJFILE is a separate debug object file, look for the\n     original object file.  */\n  if (objfile->separate_debug_objfile_backlink != NULL)\n    objfile = objfile->separate_debug_objfile_backlink;\n\n  /* The other link map addresses may be found by examining the list\n     of shared libraries.  */\n  for (so = master_so_list (); so; so = so->next)\n    if (so->objfile == objfile)\n      {\n\tlm_info_svr4 *li = (lm_info_svr4 *) so->lm_info;\n\n\treturn li->lm_addr;\n      }\n\n  /* Not found!  */\n  return 0;\n}\n\n/* On some systems, the only way to recognize the link map entry for\n   the main executable file is by looking at its name.  Return\n   non-zero iff SONAME matches one of the known main executable names.  */\n\nstatic int\nmatch_main (const char *soname)\n{\n  const char * const *mainp;\n\n  for (mainp = main_name_list; *mainp != NULL; mainp++)\n    {\n      if (strcmp (soname, *mainp) == 0)\n\treturn (1);\n    }\n\n  return (0);\n}\n\n/* Return 1 if PC lies in the dynamic symbol resolution code of the\n   SVR4 run time loader.  */\n\nint\nsvr4_in_dynsym_resolve_code (CORE_ADDR pc)\n{\n  struct svr4_info *info = get_svr4_info (current_program_space);\n\n  return ((pc >= info->interp_text_sect_low\n\t   && pc < info->interp_text_sect_high)\n\t  || (pc >= info->interp_plt_sect_low\n\t      && pc < info->interp_plt_sect_high)\n\t  || in_plt_section (pc)\n\t  || in_gnu_ifunc_stub (pc));\n}\n\n/* Given an executable's ABFD and target, compute the entry-point\n   address.  */\n\nstatic CORE_ADDR\nexec_entry_point (struct bfd *abfd, struct target_ops *targ)\n{\n  CORE_ADDR addr;\n\n  /* KevinB wrote ... for most targets, the address returned by\n     bfd_get_start_address() is the entry point for the start\n     function.  But, for some targets, bfd_get_start_address() returns\n     the address of a function descriptor from which the entry point\n     address may be extracted.  This address is extracted by\n     gdbarch_convert_from_func_ptr_addr().  The method\n     gdbarch_convert_from_func_ptr_addr() is the merely the identify\n     function for targets which don't use function descriptors.  */\n  addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),\n\t\t\t\t\t     bfd_get_start_address (abfd),\n\t\t\t\t\t     targ);\n  return gdbarch_addr_bits_remove (target_gdbarch (), addr);\n}\n\n/* A probe and its associated action.  */\n\nstruct probe_and_action\n{\n  /* The probe.  */\n  probe *prob;\n\n  /* The relocated address of the probe.  */\n  CORE_ADDR address;\n\n  /* The action.  */\n  enum probe_action action;\n\n  /* The objfile where this probe was found.  */\n  struct objfile *objfile;\n};\n\n/* Returns a hash code for the probe_and_action referenced by p.  */\n\nstatic hashval_t\nhash_probe_and_action (const void *p)\n{\n  const struct probe_and_action *pa = (const struct probe_and_action *) p;\n\n  return (hashval_t) pa->address;\n}\n\n/* Returns non-zero if the probe_and_actions referenced by p1 and p2\n   are equal.  */\n\nstatic int\nequal_probe_and_action (const void *p1, const void *p2)\n{\n  const struct probe_and_action *pa1 = (const struct probe_and_action *) p1;\n  const struct probe_and_action *pa2 = (const struct probe_and_action *) p2;\n\n  return pa1->address == pa2->address;\n}\n\n/* Traversal function for probes_table_remove_objfile_probes.  */\n\nstatic int\nprobes_table_htab_remove_objfile_probes (void **slot, void *info)\n{\n  probe_and_action *pa = (probe_and_action *) *slot;\n  struct objfile *objfile = (struct objfile *) info;\n\n  if (pa->objfile == objfile)\n    htab_clear_slot (get_svr4_info (objfile->pspace)->probes_table.get (),\n\t\t     slot);\n\n  return 1;\n}\n\n/* Remove all probes that belong to OBJFILE from the probes table.  */\n\nstatic void\nprobes_table_remove_objfile_probes (struct objfile *objfile)\n{\n  svr4_info *info = get_svr4_info (objfile->pspace);\n  if (info->probes_table != nullptr)\n    htab_traverse_noresize (info->probes_table.get (),\n\t\t\t    probes_table_htab_remove_objfile_probes, objfile);\n}\n\n/* Register a solib event probe and its associated action in the\n   probes table.  */\n\nstatic void\nregister_solib_event_probe (svr4_info *info, struct objfile *objfile,\n\t\t\t    probe *prob, CORE_ADDR address,\n\t\t\t    enum probe_action action)\n{\n  struct probe_and_action lookup, *pa;\n  void **slot;\n\n  /* Create the probes table, if necessary.  */\n  if (info->probes_table == NULL)\n    info->probes_table.reset (htab_create_alloc (1, hash_probe_and_action,\n\t\t\t\t\t\t equal_probe_and_action,\n\t\t\t\t\t\t xfree, xcalloc, xfree));\n\n  lookup.address = address;\n  slot = htab_find_slot (info->probes_table.get (), &lookup, INSERT);\n  gdb_assert (*slot == HTAB_EMPTY_ENTRY);\n\n  pa = XCNEW (struct probe_and_action);\n  pa->prob = prob;\n  pa->address = address;\n  pa->action = action;\n  pa->objfile = objfile;\n\n  *slot = pa;\n}\n\n/* Get the solib event probe at the specified location, and the\n   action associated with it.  Returns NULL if no solib event probe\n   was found.  */\n\nstatic struct probe_and_action *\nsolib_event_probe_at (struct svr4_info *info, CORE_ADDR address)\n{\n  struct probe_and_action lookup;\n  void **slot;\n\n  lookup.address = address;\n  slot = htab_find_slot (info->probes_table.get (), &lookup, NO_INSERT);\n\n  if (slot == NULL)\n    return NULL;\n\n  return (struct probe_and_action *) *slot;\n}\n\n/* Decide what action to take when the specified solib event probe is\n   hit.  */\n\nstatic enum probe_action\nsolib_event_probe_action (struct probe_and_action *pa)\n{\n  enum probe_action action;\n  unsigned probe_argc = 0;\n  struct frame_info *frame = get_current_frame ();\n\n  action = pa->action;\n  if (action == DO_NOTHING || action == PROBES_INTERFACE_FAILED)\n    return action;\n\n  gdb_assert (action == FULL_RELOAD || action == UPDATE_OR_RELOAD);\n\n  /* Check that an appropriate number of arguments has been supplied.\n     We expect:\n       arg0: Lmid_t lmid (mandatory)\n       arg1: struct r_debug *debug_base (mandatory)\n       arg2: struct link_map *new (optional, for incremental updates)  */\n  try\n    {\n      probe_argc = pa->prob->get_argument_count (get_frame_arch (frame));\n    }\n  catch (const gdb_exception_error &ex)\n    {\n      exception_print (gdb_stderr, ex);\n      probe_argc = 0;\n    }\n\n  /* If get_argument_count throws an exception, probe_argc will be set\n     to zero.  However, if pa->prob does not have arguments, then\n     get_argument_count will succeed but probe_argc will also be zero.\n     Both cases happen because of different things, but they are\n     treated equally here: action will be set to\n     PROBES_INTERFACE_FAILED.  */\n  if (probe_argc == 2)\n    action = FULL_RELOAD;\n  else if (probe_argc < 2)\n    action = PROBES_INTERFACE_FAILED;\n\n  return action;\n}\n\n/* Populate the shared object list by reading the entire list of\n   shared objects from the inferior.  Handle special cases relating\n   to the first elements of the list.  Returns nonzero on success.  */\n\nstatic int\nsolist_update_full (struct svr4_info *info)\n{\n  free_solib_list (info);\n  info->solib_list = svr4_current_sos_direct (info);\n\n  return 1;\n}\n\n/* Update the shared object list starting from the link-map entry\n   passed by the linker in the probe's third argument.  Returns\n   nonzero if the list was successfully updated, or zero to indicate\n   failure.  */\n\nstatic int\nsolist_update_incremental (struct svr4_info *info, CORE_ADDR lm)\n{\n  struct so_list *tail;\n  CORE_ADDR prev_lm;\n\n  /* svr4_current_sos_direct contains logic to handle a number of\n     special cases relating to the first elements of the list.  To\n     avoid duplicating this logic we defer to solist_update_full\n     if the list is empty.  */\n  if (info->solib_list == NULL)\n    return 0;\n\n  /* Fall back to a full update if we are using a remote target\n     that does not support incremental transfers.  */\n  if (info->using_xfer && !target_augmented_libraries_svr4_read ())\n    return 0;\n\n  /* Walk to the end of the list.  */\n  for (tail = info->solib_list; tail->next != NULL; tail = tail->next)\n    /* Nothing.  */;\n\n  lm_info_svr4 *li = (lm_info_svr4 *) tail->lm_info;\n  prev_lm = li->lm_addr;\n\n  /* Read the new objects.  */\n  if (info->using_xfer)\n    {\n      struct svr4_library_list library_list;\n      char annex[64];\n\n      xsnprintf (annex, sizeof (annex), \"start=%s;prev=%s\",\n\t\t phex_nz (lm, sizeof (lm)),\n\t\t phex_nz (prev_lm, sizeof (prev_lm)));\n      if (!svr4_current_sos_via_xfer_libraries (&library_list, annex))\n\treturn 0;\n\n      tail->next = library_list.head;\n    }\n  else\n    {\n      struct so_list **link = &tail->next;\n\n      /* IGNORE_FIRST may safely be set to zero here because the\n\t above check and deferral to solist_update_full ensures\n\t that this call to svr4_read_so_list will never see the\n\t first element.  */\n      if (!svr4_read_so_list (info, lm, prev_lm, &link, 0))\n\treturn 0;\n    }\n\n  return 1;\n}\n\n/* Disable the probes-based linker interface and revert to the\n   original interface.  We don't reset the breakpoints as the\n   ones set up for the probes-based interface are adequate.  */\n\nstatic void\ndisable_probes_interface (svr4_info *info)\n{\n  warning (_(\"Probes-based dynamic linker interface failed.\\n\"\n\t     \"Reverting to original interface.\"));\n\n  free_probes_table (info);\n  free_solib_list (info);\n}\n\n/* Update the solib list as appropriate when using the\n   probes-based linker interface.  Do nothing if using the\n   standard interface.  */\n\nstatic void\nsvr4_handle_solib_event (void)\n{\n  struct svr4_info *info = get_svr4_info (current_program_space);\n  struct probe_and_action *pa;\n  enum probe_action action;\n  struct value *val = NULL;\n  CORE_ADDR pc, debug_base, lm = 0;\n  struct frame_info *frame = get_current_frame ();\n\n  /* Do nothing if not using the probes interface.  */\n  if (info->probes_table == NULL)\n    return;\n\n  /* If anything goes wrong we revert to the original linker\n     interface.  */\n  auto cleanup = make_scope_exit ([info] ()\n    {\n      disable_probes_interface (info);\n    });\n\n  pc = regcache_read_pc (get_current_regcache ());\n  pa = solib_event_probe_at (info, pc);\n  if (pa == NULL)\n    return;\n\n  action = solib_event_probe_action (pa);\n  if (action == PROBES_INTERFACE_FAILED)\n    return;\n\n  if (action == DO_NOTHING)\n    {\n      cleanup.release ();\n      return;\n    }\n\n  /* evaluate_argument looks up symbols in the dynamic linker\n     using find_pc_section.  find_pc_section is accelerated by a cache\n     called the section map.  The section map is invalidated every\n     time a shared library is loaded or unloaded, and if the inferior\n     is generating a lot of shared library events then the section map\n     will be updated every time svr4_handle_solib_event is called.\n     We called find_pc_section in svr4_create_solib_event_breakpoints,\n     so we can guarantee that the dynamic linker's sections are in the\n     section map.  We can therefore inhibit section map updates across\n     these calls to evaluate_argument and save a lot of time.  */\n  {\n    scoped_restore inhibit_updates\n      = inhibit_section_map_updates (current_program_space);\n\n    try\n      {\n\tval = pa->prob->evaluate_argument (1, frame);\n      }\n    catch (const gdb_exception_error &ex)\n      {\n\texception_print (gdb_stderr, ex);\n\tval = NULL;\n      }\n\n    if (val == NULL)\n      return;\n\n    debug_base = value_as_address (val);\n    if (debug_base == 0)\n      return;\n\n    /* Always locate the debug struct, in case it moved.  */\n    info->debug_base = 0;\n    if (locate_base (info) == 0)\n      return;\n\n    /* GDB does not currently support libraries loaded via dlmopen\n       into namespaces other than the initial one.  We must ignore\n       any namespace other than the initial namespace here until\n       support for this is added to GDB.  */\n    if (debug_base != info->debug_base)\n      action = DO_NOTHING;\n\n    if (action == UPDATE_OR_RELOAD)\n      {\n\ttry\n\t  {\n\t    val = pa->prob->evaluate_argument (2, frame);\n\t  }\n\tcatch (const gdb_exception_error &ex)\n\t  {\n\t    exception_print (gdb_stderr, ex);\n\t    return;\n\t  }\n\n\tif (val != NULL)\n\t  lm = value_as_address (val);\n\n\tif (lm == 0)\n\t  action = FULL_RELOAD;\n      }\n\n    /* Resume section map updates.  Closing the scope is\n       sufficient.  */\n  }\n\n  if (action == UPDATE_OR_RELOAD)\n    {\n      if (!solist_update_incremental (info, lm))\n\taction = FULL_RELOAD;\n    }\n\n  if (action == FULL_RELOAD)\n    {\n      if (!solist_update_full (info))\n\treturn;\n    }\n\n  cleanup.release ();\n}\n\n/* Helper function for svr4_update_solib_event_breakpoints.  */\n\nstatic bool\nsvr4_update_solib_event_breakpoint (struct breakpoint *b)\n{\n  struct bp_location *loc;\n\n  if (b->type != bp_shlib_event)\n    {\n      /* Continue iterating.  */\n      return false;\n    }\n\n  for (loc = b->loc; loc != NULL; loc = loc->next)\n    {\n      struct svr4_info *info;\n      struct probe_and_action *pa;\n\n      info = solib_svr4_pspace_data.get (loc->pspace);\n      if (info == NULL || info->probes_table == NULL)\n\tcontinue;\n\n      pa = solib_event_probe_at (info, loc->address);\n      if (pa == NULL)\n\tcontinue;\n\n      if (pa->action == DO_NOTHING)\n\t{\n\t  if (b->enable_state == bp_disabled && stop_on_solib_events)\n\t    enable_breakpoint (b);\n\t  else if (b->enable_state == bp_enabled && !stop_on_solib_events)\n\t    disable_breakpoint (b);\n\t}\n\n      break;\n    }\n\n  /* Continue iterating.  */\n  return false;\n}\n\n/* Enable or disable optional solib event breakpoints as appropriate.\n   Called whenever stop_on_solib_events is changed.  */\n\nstatic void\nsvr4_update_solib_event_breakpoints (void)\n{\n  iterate_over_breakpoints (svr4_update_solib_event_breakpoint);\n}\n\n/* Create and register solib event breakpoints.  PROBES is an array\n   of NUM_PROBES elements, each of which is vector of probes.  A\n   solib event breakpoint will be created and registered for each\n   probe.  */\n\nstatic void\nsvr4_create_probe_breakpoints (svr4_info *info, struct gdbarch *gdbarch,\n\t\t\t       const std::vector<probe *> *probes,\n\t\t\t       struct objfile *objfile)\n{\n  for (int i = 0; i < NUM_PROBES; i++)\n    {\n      enum probe_action action = probe_info[i].action;\n\n      for (probe *p : probes[i])\n\t{\n\t  CORE_ADDR address = p->get_relocated_address (objfile);\n\n\t  create_solib_event_breakpoint (gdbarch, address);\n\t  register_solib_event_probe (info, objfile, p, address, action);\n\t}\n    }\n\n  svr4_update_solib_event_breakpoints ();\n}\n\n/* Find all the glibc named probes.  Only if all of the probes are found, then\n   create them and return true.  Otherwise return false.  If WITH_PREFIX is set\n   then add \"rtld\" to the front of the probe names.  */\nstatic bool\nsvr4_find_and_create_probe_breakpoints (svr4_info *info,\n\t\t\t\t\tstruct gdbarch *gdbarch,\n\t\t\t\t\tstruct obj_section *os,\n\t\t\t\t\tbool with_prefix)\n{\n  std::vector<probe *> probes[NUM_PROBES];\n\n  for (int i = 0; i < NUM_PROBES; i++)\n    {\n      const char *name = probe_info[i].name;\n      char buf[32];\n\n      /* Fedora 17 and Red Hat Enterprise Linux 6.2-6.4 shipped with an early\n\t version of the probes code in which the probes' names were prefixed\n\t with \"rtld_\" and the \"map_failed\" probe did not exist.  The locations\n\t of the probes are otherwise the same, so we check for probes with\n\t prefixed names if probes with unprefixed names are not present.  */\n      if (with_prefix)\n\t{\n\t  xsnprintf (buf, sizeof (buf), \"rtld_%s\", name);\n\t  name = buf;\n\t}\n\n      probes[i] = find_probes_in_objfile (os->objfile, \"rtld\", name);\n\n      /* The \"map_failed\" probe did not exist in early\n\t versions of the probes code in which the probes'\n\t names were prefixed with \"rtld_\".  */\n      if (with_prefix && streq (name, \"rtld_map_failed\"))\n\tcontinue;\n\n      /* Ensure at least one probe for the current name was found.  */\n      if (probes[i].empty ())\n\treturn false;\n\n      /* Ensure probe arguments can be evaluated.  */\n      for (probe *p : probes[i])\n\t{\n\t  if (!p->can_evaluate_arguments ())\n\t    return false;\n\t  /* This will fail if the probe is invalid.  This has been seen on Arm\n\t     due to references to symbols that have been resolved away.  */\n\t  try\n\t    {\n\t      p->get_argument_count (gdbarch);\n\t    }\n\t  catch (const gdb_exception_error &ex)\n\t    {\n\t      exception_print (gdb_stderr, ex);\n\t      warning (_(\"Initializing probes-based dynamic linker interface \"\n\t\t\t \"failed.\\nReverting to original interface.\"));\n\t      return false;\n\t    }\n\t}\n    }\n\n  /* All probes found.  Now create them.  */\n  svr4_create_probe_breakpoints (info, gdbarch, probes, os->objfile);\n  return true;\n}\n\n/* Both the SunOS and the SVR4 dynamic linkers call a marker function\n   before and after mapping and unmapping shared libraries.  The sole\n   purpose of this method is to allow debuggers to set a breakpoint so\n   they can track these changes.\n\n   Some versions of the glibc dynamic linker contain named probes\n   to allow more fine grained stopping.  Given the address of the\n   original marker function, this function attempts to find these\n   probes, and if found, sets breakpoints on those instead.  If the\n   probes aren't found, a single breakpoint is set on the original\n   marker function.  */\n\nstatic void\nsvr4_create_solib_event_breakpoints (svr4_info *info, struct gdbarch *gdbarch,\n\t\t\t\t     CORE_ADDR address)\n{\n  struct obj_section *os = find_pc_section (address);\n\n  if (os == nullptr\n      || (!svr4_find_and_create_probe_breakpoints (info, gdbarch, os, false)\n\t  && !svr4_find_and_create_probe_breakpoints (info, gdbarch, os, true)))\n    create_solib_event_breakpoint (gdbarch, address);\n}\n\n/* Helper function for gdb_bfd_lookup_symbol.  */\n\nstatic int\ncmp_name_and_sec_flags (const asymbol *sym, const void *data)\n{\n  return (strcmp (sym->name, (const char *) data) == 0\n\t  && (sym->section->flags & (SEC_CODE | SEC_DATA)) != 0);\n}\n/* Arrange for dynamic linker to hit breakpoint.\n\n   Both the SunOS and the SVR4 dynamic linkers have, as part of their\n   debugger interface, support for arranging for the inferior to hit\n   a breakpoint after mapping in the shared libraries.  This function\n   enables that breakpoint.\n\n   For SunOS, there is a special flag location (in_debugger) which we\n   set to 1.  When the dynamic linker sees this flag set, it will set\n   a breakpoint at a location known only to itself, after saving the\n   original contents of that place and the breakpoint address itself,\n   in it's own internal structures.  When we resume the inferior, it\n   will eventually take a SIGTRAP when it runs into the breakpoint.\n   We handle this (in a different place) by restoring the contents of\n   the breakpointed location (which is only known after it stops),\n   chasing around to locate the shared libraries that have been\n   loaded, then resuming.\n\n   For SVR4, the debugger interface structure contains a member (r_brk)\n   which is statically initialized at the time the shared library is\n   built, to the offset of a function (_r_debug_state) which is guaran-\n   teed to be called once before mapping in a library, and again when\n   the mapping is complete.  At the time we are examining this member,\n   it contains only the unrelocated offset of the function, so we have\n   to do our own relocation.  Later, when the dynamic linker actually\n   runs, it relocates r_brk to be the actual address of _r_debug_state().\n\n   The debugger interface structure also contains an enumeration which\n   is set to either RT_ADD or RT_DELETE prior to changing the mapping,\n   depending upon whether or not the library is being mapped or unmapped,\n   and then set to RT_CONSISTENT after the library is mapped/unmapped.  */\n\nstatic int\nenable_break (struct svr4_info *info, int from_tty)\n{\n  struct bound_minimal_symbol msymbol;\n  const char * const *bkpt_namep;\n  asection *interp_sect;\n  CORE_ADDR sym_addr;\n\n  info->interp_text_sect_low = info->interp_text_sect_high = 0;\n  info->interp_plt_sect_low = info->interp_plt_sect_high = 0;\n\n  /* If we already have a shared library list in the target, and\n     r_debug contains r_brk, set the breakpoint there - this should\n     mean r_brk has already been relocated.  Assume the dynamic linker\n     is the object containing r_brk.  */\n\n  solib_add (NULL, from_tty, auto_solib_add);\n  sym_addr = 0;\n  if (info->debug_base && solib_svr4_r_map (info) != 0)\n    sym_addr = solib_svr4_r_brk (info);\n\n  if (sym_addr != 0)\n    {\n      struct obj_section *os;\n\n      sym_addr = gdbarch_addr_bits_remove\n\t(target_gdbarch (),\n\t gdbarch_convert_from_func_ptr_addr (target_gdbarch (),\n\t\t\t\t\t     sym_addr,\n\t\t\t\t\t     current_top_target ()));\n\n      /* On at least some versions of Solaris there's a dynamic relocation\n\t on _r_debug.r_brk and SYM_ADDR may not be relocated yet, e.g., if\n\t we get control before the dynamic linker has self-relocated.\n\t Check if SYM_ADDR is in a known section, if it is assume we can\n\t trust its value.  This is just a heuristic though, it could go away\n\t or be replaced if it's getting in the way.\n\n\t On ARM we need to know whether the ISA of rtld_db_dlactivity (or\n\t however it's spelled in your particular system) is ARM or Thumb.\n\t That knowledge is encoded in the address, if it's Thumb the low bit\n\t is 1.  However, we've stripped that info above and it's not clear\n\t what all the consequences are of passing a non-addr_bits_remove'd\n\t address to svr4_create_solib_event_breakpoints.  The call to\n\t find_pc_section verifies we know about the address and have some\n\t hope of computing the right kind of breakpoint to use (via\n\t symbol info).  It does mean that GDB needs to be pointed at a\n\t non-stripped version of the dynamic linker in order to obtain\n\t information it already knows about.  Sigh.  */\n\n      os = find_pc_section (sym_addr);\n      if (os != NULL)\n\t{\n\t  /* Record the relocated start and end address of the dynamic linker\n\t     text and plt section for svr4_in_dynsym_resolve_code.  */\n\t  bfd *tmp_bfd;\n\t  CORE_ADDR load_addr;\n\n\t  tmp_bfd = os->objfile->obfd;\n\t  load_addr = ANOFFSET (os->objfile->section_offsets,\n\t\t\t\tSECT_OFF_TEXT (os->objfile));\n\n\t  interp_sect = bfd_get_section_by_name (tmp_bfd, \".text\");\n\t  if (interp_sect)\n\t    {\n\t      info->interp_text_sect_low\n\t\t= bfd_section_vma (interp_sect) + load_addr;\n\t      info->interp_text_sect_high\n\t\t= info->interp_text_sect_low + bfd_section_size (interp_sect);\n\t    }\n\t  interp_sect = bfd_get_section_by_name (tmp_bfd, \".plt\");\n\t  if (interp_sect)\n\t    {\n\t      info->interp_plt_sect_low\n\t\t= bfd_section_vma (interp_sect) + load_addr;\n\t      info->interp_plt_sect_high\n\t\t= info->interp_plt_sect_low + bfd_section_size (interp_sect);\n\t    }\n\n\t  svr4_create_solib_event_breakpoints (info, target_gdbarch (), sym_addr);\n\t  return 1;\n\t}\n    }\n\n  /* Find the program interpreter; if not found, warn the user and drop\n     into the old breakpoint at symbol code.  */\n  gdb::optional<gdb::byte_vector> interp_name_holder\n    = find_program_interpreter ();\n  if (interp_name_holder)\n    {\n      const char *interp_name = (const char *) interp_name_holder->data ();\n      CORE_ADDR load_addr = 0;\n      int load_addr_found = 0;\n      int loader_found_in_list = 0;\n      struct so_list *so;\n      struct target_ops *tmp_bfd_target;\n\n      sym_addr = 0;\n\n      /* Now we need to figure out where the dynamic linker was\n         loaded so that we can load its symbols and place a breakpoint\n         in the dynamic linker itself.\n\n         This address is stored on the stack.  However, I've been unable\n         to find any magic formula to find it for Solaris (appears to\n         be trivial on GNU/Linux).  Therefore, we have to try an alternate\n         mechanism to find the dynamic linker's base address.  */\n\n      gdb_bfd_ref_ptr tmp_bfd;\n      try\n        {\n\t  tmp_bfd = solib_bfd_open (interp_name);\n\t}\n      catch (const gdb_exception &ex)\n\t{\n\t}\n\n      if (tmp_bfd == NULL)\n\tgoto bkpt_at_symbol;\n\n      /* Now convert the TMP_BFD into a target.  That way target, as\n         well as BFD operations can be used.  target_bfd_reopen\n         acquires its own reference.  */\n      tmp_bfd_target = target_bfd_reopen (tmp_bfd.get ());\n\n      /* On a running target, we can get the dynamic linker's base\n         address from the shared library table.  */\n      so = master_so_list ();\n      while (so)\n\t{\n\t  if (svr4_same_1 (interp_name, so->so_original_name))\n\t    {\n\t      load_addr_found = 1;\n\t      loader_found_in_list = 1;\n\t      load_addr = lm_addr_check (so, tmp_bfd.get ());\n\t      break;\n\t    }\n\t  so = so->next;\n\t}\n\n      /* If we were not able to find the base address of the loader\n         from our so_list, then try using the AT_BASE auxilliary entry.  */\n      if (!load_addr_found)\n\tif (target_auxv_search (current_top_target (), AT_BASE, &load_addr) > 0)\n\t  {\n\t    int addr_bit = gdbarch_addr_bit (target_gdbarch ());\n\n\t    /* Ensure LOAD_ADDR has proper sign in its possible upper bits so\n\t       that `+ load_addr' will overflow CORE_ADDR width not creating\n\t       invalid addresses like 0x101234567 for 32bit inferiors on 64bit\n\t       GDB.  */\n\n\t    if (addr_bit < (sizeof (CORE_ADDR) * HOST_CHAR_BIT))\n\t      {\n\t\tCORE_ADDR space_size = (CORE_ADDR) 1 << addr_bit;\n\t\tCORE_ADDR tmp_entry_point = exec_entry_point (tmp_bfd.get (),\n\t\t\t\t\t\t\t      tmp_bfd_target);\n\n\t\tgdb_assert (load_addr < space_size);\n\n\t\t/* TMP_ENTRY_POINT exceeding SPACE_SIZE would be for prelinked\n\t\t   64bit ld.so with 32bit executable, it should not happen.  */\n\n\t\tif (tmp_entry_point < space_size\n\t\t    && tmp_entry_point + load_addr >= space_size)\n\t\t  load_addr -= space_size;\n\t      }\n\n\t    load_addr_found = 1;\n\t  }\n\n      /* Otherwise we find the dynamic linker's base address by examining\n\t the current pc (which should point at the entry point for the\n\t dynamic linker) and subtracting the offset of the entry point.\n\n         This is more fragile than the previous approaches, but is a good\n         fallback method because it has actually been working well in\n         most cases.  */\n      if (!load_addr_found)\n\t{\n\t  struct regcache *regcache\n\t    = get_thread_arch_regcache (inferior_ptid, target_gdbarch ());\n\n\t  load_addr = (regcache_read_pc (regcache)\n\t\t       - exec_entry_point (tmp_bfd.get (), tmp_bfd_target));\n\t}\n\n      if (!loader_found_in_list)\n\t{\n\t  info->debug_loader_name = xstrdup (interp_name);\n\t  info->debug_loader_offset_p = 1;\n\t  info->debug_loader_offset = load_addr;\n\t  solib_add (NULL, from_tty, auto_solib_add);\n\t}\n\n      /* Record the relocated start and end address of the dynamic linker\n         text and plt section for svr4_in_dynsym_resolve_code.  */\n      interp_sect = bfd_get_section_by_name (tmp_bfd.get (), \".text\");\n      if (interp_sect)\n\t{\n\t  info->interp_text_sect_low\n\t    = bfd_section_vma (interp_sect) + load_addr;\n\t  info->interp_text_sect_high\n\t    = info->interp_text_sect_low + bfd_section_size (interp_sect);\n\t}\n      interp_sect = bfd_get_section_by_name (tmp_bfd.get (), \".plt\");\n      if (interp_sect)\n\t{\n\t  info->interp_plt_sect_low\n\t    = bfd_section_vma (interp_sect) + load_addr;\n\t  info->interp_plt_sect_high\n\t    = info->interp_plt_sect_low + bfd_section_size (interp_sect);\n\t}\n\n      /* Now try to set a breakpoint in the dynamic linker.  */\n      for (bkpt_namep = solib_break_names; *bkpt_namep != NULL; bkpt_namep++)\n\t{\n\t  sym_addr = gdb_bfd_lookup_symbol (tmp_bfd.get (),\n\t\t\t\t\t    cmp_name_and_sec_flags,\n\t\t\t\t\t    *bkpt_namep);\n\t  if (sym_addr != 0)\n\t    break;\n\t}\n\n      if (sym_addr != 0)\n\t/* Convert 'sym_addr' from a function pointer to an address.\n\t   Because we pass tmp_bfd_target instead of the current\n\t   target, this will always produce an unrelocated value.  */\n\tsym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),\n\t\t\t\t\t\t       sym_addr,\n\t\t\t\t\t\t       tmp_bfd_target);\n\n      /* We're done with both the temporary bfd and target.  Closing\n         the target closes the underlying bfd, because it holds the\n         only remaining reference.  */\n      target_close (tmp_bfd_target);\n\n      if (sym_addr != 0)\n\t{\n\t  svr4_create_solib_event_breakpoints (info, target_gdbarch (),\n\t\t\t\t\t       load_addr + sym_addr);\n\t  return 1;\n\t}\n\n      /* For whatever reason we couldn't set a breakpoint in the dynamic\n         linker.  Warn and drop into the old code.  */\n    bkpt_at_symbol:\n      warning (_(\"Unable to find dynamic linker breakpoint function.\\n\"\n               \"GDB will be unable to debug shared library initializers\\n\"\n               \"and track explicitly loaded dynamic code.\"));\n    }\n\n  /* Scan through the lists of symbols, trying to look up the symbol and\n     set a breakpoint there.  Terminate loop when we/if we succeed.  */\n\n  for (bkpt_namep = solib_break_names; *bkpt_namep != NULL; bkpt_namep++)\n    {\n      msymbol = lookup_minimal_symbol (*bkpt_namep, NULL, symfile_objfile);\n      if ((msymbol.minsym != NULL)\n\t  && (BMSYMBOL_VALUE_ADDRESS (msymbol) != 0))\n\t{\n\t  sym_addr = BMSYMBOL_VALUE_ADDRESS (msymbol);\n\t  sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),\n\t\t\t\t\t\t\t sym_addr,\n\t\t\t\t\t\t\t current_top_target ());\n\t  svr4_create_solib_event_breakpoints (info, target_gdbarch (),\n\t\t\t\t\t       sym_addr);\n\t  return 1;\n\t}\n    }\n\n  if (interp_name_holder && !current_inferior ()->attach_flag)\n    {\n      for (bkpt_namep = bkpt_names; *bkpt_namep != NULL; bkpt_namep++)\n\t{\n\t  msymbol = lookup_minimal_symbol (*bkpt_namep, NULL, symfile_objfile);\n\t  if ((msymbol.minsym != NULL)\n\t      && (BMSYMBOL_VALUE_ADDRESS (msymbol) != 0))\n\t    {\n\t      sym_addr = BMSYMBOL_VALUE_ADDRESS (msymbol);\n\t      sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),\n\t\t\t\t\t\t\t     sym_addr,\n\t\t\t\t\t\t\t     current_top_target ());\n\t      svr4_create_solib_event_breakpoints (info, target_gdbarch (),\n\t\t\t\t\t\t   sym_addr);\n\t      return 1;\n\t    }\n\t}\n    }\n  return 0;\n}\n\n/* Read the ELF program headers from ABFD.  */\n\nstatic gdb::optional<gdb::byte_vector>\nread_program_headers_from_bfd (bfd *abfd)\n{\n  Elf_Internal_Ehdr *ehdr = elf_elfheader (abfd);\n  int phdrs_size = ehdr->e_phnum * ehdr->e_phentsize;\n  if (phdrs_size == 0)\n    return {};\n\n  gdb::byte_vector buf (phdrs_size);\n  if (bfd_seek (abfd, ehdr->e_phoff, SEEK_SET) != 0\n      || bfd_bread (buf.data (), phdrs_size, abfd) != phdrs_size)\n    return {};\n\n  return buf;\n}\n\n/* Return 1 and fill *DISPLACEMENTP with detected PIE offset of inferior\n   exec_bfd.  Otherwise return 0.\n\n   We relocate all of the sections by the same amount.  This\n   behavior is mandated by recent editions of the System V ABI.\n   According to the System V Application Binary Interface,\n   Edition 4.1, page 5-5:\n\n     ...  Though the system chooses virtual addresses for\n     individual processes, it maintains the segments' relative\n     positions.  Because position-independent code uses relative\n     addressing between segments, the difference between\n     virtual addresses in memory must match the difference\n     between virtual addresses in the file.  The difference\n     between the virtual address of any segment in memory and\n     the corresponding virtual address in the file is thus a\n     single constant value for any one executable or shared\n     object in a given process.  This difference is the base\n     address.  One use of the base address is to relocate the\n     memory image of the program during dynamic linking.\n\n   The same language also appears in Edition 4.0 of the System V\n   ABI and is left unspecified in some of the earlier editions.\n\n   Decide if the objfile needs to be relocated.  As indicated above, we will\n   only be here when execution is stopped.  But during attachment PC can be at\n   arbitrary address therefore regcache_read_pc can be misleading (contrary to\n   the auxv AT_ENTRY value).  Moreover for executable with interpreter section\n   regcache_read_pc would point to the interpreter and not the main executable.\n\n   So, to summarize, relocations are necessary when the start address obtained\n   from the executable is different from the address in auxv AT_ENTRY entry.\n\n   [ The astute reader will note that we also test to make sure that\n     the executable in question has the DYNAMIC flag set.  It is my\n     opinion that this test is unnecessary (undesirable even).  It\n     was added to avoid inadvertent relocation of an executable\n     whose e_type member in the ELF header is not ET_DYN.  There may\n     be a time in the future when it is desirable to do relocations\n     on other types of files as well in which case this condition\n     should either be removed or modified to accomodate the new file\n     type.  - Kevin, Nov 2000. ]  */\n\nstatic int\nsvr4_exec_displacement (CORE_ADDR *displacementp)\n{\n  /* ENTRY_POINT is a possible function descriptor - before\n     a call to gdbarch_convert_from_func_ptr_addr.  */\n  CORE_ADDR entry_point, exec_displacement;\n\n  if (exec_bfd == NULL)\n    return 0;\n\n  /* Therefore for ELF it is ET_EXEC and not ET_DYN.  Both shared libraries\n     being executed themselves and PIE (Position Independent Executable)\n     executables are ET_DYN.  */\n\n  if ((bfd_get_file_flags (exec_bfd) & DYNAMIC) == 0)\n    return 0;\n\n  if (target_auxv_search (current_top_target (), AT_ENTRY, &entry_point) <= 0)\n    return 0;\n\n  exec_displacement = entry_point - bfd_get_start_address (exec_bfd);\n\n  /* Verify the EXEC_DISPLACEMENT candidate complies with the required page\n     alignment.  It is cheaper than the program headers comparison below.  */\n\n  if (bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)\n    {\n      const struct elf_backend_data *elf = get_elf_backend_data (exec_bfd);\n\n      /* p_align of PT_LOAD segments does not specify any alignment but\n\t only congruency of addresses:\n\t   p_offset % p_align == p_vaddr % p_align\n\t Kernel is free to load the executable with lower alignment.  */\n\n      if ((exec_displacement & (elf->minpagesize - 1)) != 0)\n\treturn 0;\n    }\n\n  /* Verify that the auxilliary vector describes the same file as exec_bfd, by\n     comparing their program headers.  If the program headers in the auxilliary\n     vector do not match the program headers in the executable, then we are\n     looking at a different file than the one used by the kernel - for\n     instance, \"gdb program\" connected to \"gdbserver :PORT ld.so program\".  */\n\n  if (bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)\n    {\n      /* Be optimistic and return 0 only if GDB was able to verify the headers\n\t really do not match.  */\n      int arch_size;\n\n      gdb::optional<gdb::byte_vector> phdrs_target\n\t= read_program_header (-1, &arch_size, NULL);\n      gdb::optional<gdb::byte_vector> phdrs_binary\n\t= read_program_headers_from_bfd (exec_bfd);\n      if (phdrs_target && phdrs_binary)\n\t{\n\t  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n\n\t  /* We are dealing with three different addresses.  EXEC_BFD\n\t     represents current address in on-disk file.  target memory content\n\t     may be different from EXEC_BFD as the file may have been prelinked\n\t     to a different address after the executable has been loaded.\n\t     Moreover the address of placement in target memory can be\n\t     different from what the program headers in target memory say -\n\t     this is the goal of PIE.\n\n\t     Detected DISPLACEMENT covers both the offsets of PIE placement and\n\t     possible new prelink performed after start of the program.  Here\n\t     relocate BUF and BUF2 just by the EXEC_BFD vs. target memory\n\t     content offset for the verification purpose.  */\n\n\t  if (phdrs_target->size () != phdrs_binary->size ()\n\t      || bfd_get_arch_size (exec_bfd) != arch_size)\n\t    return 0;\n\t  else if (arch_size == 32\n\t\t   && phdrs_target->size () >= sizeof (Elf32_External_Phdr)\n\t           && phdrs_target->size () % sizeof (Elf32_External_Phdr) == 0)\n\t    {\n\t      Elf_Internal_Ehdr *ehdr2 = elf_tdata (exec_bfd)->elf_header;\n\t      Elf_Internal_Phdr *phdr2 = elf_tdata (exec_bfd)->phdr;\n\t      CORE_ADDR displacement = 0;\n\t      int i;\n\n\t      /* DISPLACEMENT could be found more easily by the difference of\n\t\t ehdr2->e_entry.  But we haven't read the ehdr yet, and we\n\t\t already have enough information to compute that displacement\n\t\t with what we've read.  */\n\n\t      for (i = 0; i < ehdr2->e_phnum; i++)\n\t\tif (phdr2[i].p_type == PT_LOAD)\n\t\t  {\n\t\t    Elf32_External_Phdr *phdrp;\n\t\t    gdb_byte *buf_vaddr_p, *buf_paddr_p;\n\t\t    CORE_ADDR vaddr, paddr;\n\t\t    CORE_ADDR displacement_vaddr = 0;\n\t\t    CORE_ADDR displacement_paddr = 0;\n\n\t\t    phdrp = &((Elf32_External_Phdr *) phdrs_target->data ())[i];\n\t\t    buf_vaddr_p = (gdb_byte *) &phdrp->p_vaddr;\n\t\t    buf_paddr_p = (gdb_byte *) &phdrp->p_paddr;\n\n\t\t    vaddr = extract_unsigned_integer (buf_vaddr_p, 4,\n\t\t\t\t\t\t      byte_order);\n\t\t    displacement_vaddr = vaddr - phdr2[i].p_vaddr;\n\n\t\t    paddr = extract_unsigned_integer (buf_paddr_p, 4,\n\t\t\t\t\t\t      byte_order);\n\t\t    displacement_paddr = paddr - phdr2[i].p_paddr;\n\n\t\t    if (displacement_vaddr == displacement_paddr)\n\t\t      displacement = displacement_vaddr;\n\n\t\t    break;\n\t\t  }\n\n\t      /* Now compare program headers from the target and the binary\n\t         with optional DISPLACEMENT.  */\n\n\t      for (i = 0;\n\t\t   i < phdrs_target->size () / sizeof (Elf32_External_Phdr);\n\t\t   i++)\n\t\t{\n\t\t  Elf32_External_Phdr *phdrp;\n\t\t  Elf32_External_Phdr *phdr2p;\n\t\t  gdb_byte *buf_vaddr_p, *buf_paddr_p;\n\t\t  CORE_ADDR vaddr, paddr;\n\t\t  asection *plt2_asect;\n\n\t\t  phdrp = &((Elf32_External_Phdr *) phdrs_target->data ())[i];\n\t\t  buf_vaddr_p = (gdb_byte *) &phdrp->p_vaddr;\n\t\t  buf_paddr_p = (gdb_byte *) &phdrp->p_paddr;\n\t\t  phdr2p = &((Elf32_External_Phdr *) phdrs_binary->data ())[i];\n\n\t\t  /* PT_GNU_STACK is an exception by being never relocated by\n\t\t     prelink as its addresses are always zero.  */\n\n\t\t  if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)\n\t\t    continue;\n\n\t\t  /* Check also other adjustment combinations - PR 11786.  */\n\n\t\t  vaddr = extract_unsigned_integer (buf_vaddr_p, 4,\n\t\t\t\t\t\t    byte_order);\n\t\t  vaddr -= displacement;\n\t\t  store_unsigned_integer (buf_vaddr_p, 4, byte_order, vaddr);\n\n\t\t  paddr = extract_unsigned_integer (buf_paddr_p, 4,\n\t\t\t\t\t\t    byte_order);\n\t\t  paddr -= displacement;\n\t\t  store_unsigned_integer (buf_paddr_p, 4, byte_order, paddr);\n\n\t\t  if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)\n\t\t    continue;\n\n\t\t  /* Strip modifies the flags and alignment of PT_GNU_RELRO.\n\t\t     CentOS-5 has problems with filesz, memsz as well.\n\t\t     Strip also modifies memsz of PT_TLS.\n\t\t     See PR 11786.  */\n\t\t  if (phdr2[i].p_type == PT_GNU_RELRO\n\t\t      || phdr2[i].p_type == PT_TLS)\n\t\t    {\n\t\t      Elf32_External_Phdr tmp_phdr = *phdrp;\n\t\t      Elf32_External_Phdr tmp_phdr2 = *phdr2p;\n\n\t\t      memset (tmp_phdr.p_filesz, 0, 4);\n\t\t      memset (tmp_phdr.p_memsz, 0, 4);\n\t\t      memset (tmp_phdr.p_flags, 0, 4);\n\t\t      memset (tmp_phdr.p_align, 0, 4);\n\t\t      memset (tmp_phdr2.p_filesz, 0, 4);\n\t\t      memset (tmp_phdr2.p_memsz, 0, 4);\n\t\t      memset (tmp_phdr2.p_flags, 0, 4);\n\t\t      memset (tmp_phdr2.p_align, 0, 4);\n\n\t\t      if (memcmp (&tmp_phdr, &tmp_phdr2, sizeof (tmp_phdr))\n\t\t\t  == 0)\n\t\t\tcontinue;\n\t\t    }\n\n\t\t  /* prelink can convert .plt SHT_NOBITS to SHT_PROGBITS.  */\n\t\t  plt2_asect = bfd_get_section_by_name (exec_bfd, \".plt\");\n\t\t  if (plt2_asect)\n\t\t    {\n\t\t      int content2;\n\t\t      gdb_byte *buf_filesz_p = (gdb_byte *) &phdrp->p_filesz;\n\t\t      CORE_ADDR filesz;\n\n\t\t      content2 = (bfd_section_flags (plt2_asect)\n\t\t\t\t  & SEC_HAS_CONTENTS) != 0;\n\n\t\t      filesz = extract_unsigned_integer (buf_filesz_p, 4,\n\t\t\t\t\t\t\t byte_order);\n\n\t\t      /* PLT2_ASECT is from on-disk file (exec_bfd) while\n\t\t\t FILESZ is from the in-memory image.  */\n\t\t      if (content2)\n\t\t\tfilesz += bfd_section_size (plt2_asect);\n\t\t      else\n\t\t\tfilesz -= bfd_section_size (plt2_asect);\n\n\t\t      store_unsigned_integer (buf_filesz_p, 4, byte_order,\n\t\t\t\t\t      filesz);\n\n\t\t      if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)\n\t\t\tcontinue;\n\t\t    }\n\n\t\t  return 0;\n\t\t}\n\t    }\n\t  else if (arch_size == 64\n\t\t   && phdrs_target->size () >= sizeof (Elf64_External_Phdr)\n\t           && phdrs_target->size () % sizeof (Elf64_External_Phdr) == 0)\n\t    {\n\t      Elf_Internal_Ehdr *ehdr2 = elf_tdata (exec_bfd)->elf_header;\n\t      Elf_Internal_Phdr *phdr2 = elf_tdata (exec_bfd)->phdr;\n\t      CORE_ADDR displacement = 0;\n\t      int i;\n\n\t      /* DISPLACEMENT could be found more easily by the difference of\n\t\t ehdr2->e_entry.  But we haven't read the ehdr yet, and we\n\t\t already have enough information to compute that displacement\n\t\t with what we've read.  */\n\n\t      for (i = 0; i < ehdr2->e_phnum; i++)\n\t\tif (phdr2[i].p_type == PT_LOAD)\n\t\t  {\n\t\t    Elf64_External_Phdr *phdrp;\n\t\t    gdb_byte *buf_vaddr_p, *buf_paddr_p;\n\t\t    CORE_ADDR vaddr, paddr;\n\t\t    CORE_ADDR displacement_vaddr = 0;\n\t\t    CORE_ADDR displacement_paddr = 0;\n\n\t\t    phdrp = &((Elf64_External_Phdr *) phdrs_target->data ())[i];\n\t\t    buf_vaddr_p = (gdb_byte *) &phdrp->p_vaddr;\n\t\t    buf_paddr_p = (gdb_byte *) &phdrp->p_paddr;\n\n\t\t    vaddr = extract_unsigned_integer (buf_vaddr_p, 8,\n\t\t\t\t\t\t      byte_order);\n\t\t    displacement_vaddr = vaddr - phdr2[i].p_vaddr;\n\n\t\t    paddr = extract_unsigned_integer (buf_paddr_p, 8,\n\t\t\t\t\t\t      byte_order);\n\t\t    displacement_paddr = paddr - phdr2[i].p_paddr;\n\n\t\t    if (displacement_vaddr == displacement_paddr)\n\t\t      displacement = displacement_vaddr;\n\n\t\t    break;\n\t\t  }\n\n\t      /* Now compare BUF and BUF2 with optional DISPLACEMENT.  */\n\n\t      for (i = 0;\n\t\t   i < phdrs_target->size () / sizeof (Elf64_External_Phdr);\n\t\t   i++)\n\t\t{\n\t\t  Elf64_External_Phdr *phdrp;\n\t\t  Elf64_External_Phdr *phdr2p;\n\t\t  gdb_byte *buf_vaddr_p, *buf_paddr_p;\n\t\t  CORE_ADDR vaddr, paddr;\n\t\t  asection *plt2_asect;\n\n\t\t  phdrp = &((Elf64_External_Phdr *) phdrs_target->data ())[i];\n\t\t  buf_vaddr_p = (gdb_byte *) &phdrp->p_vaddr;\n\t\t  buf_paddr_p = (gdb_byte *) &phdrp->p_paddr;\n\t\t  phdr2p = &((Elf64_External_Phdr *) phdrs_binary->data ())[i];\n\n\t\t  /* PT_GNU_STACK is an exception by being never relocated by\n\t\t     prelink as its addresses are always zero.  */\n\n\t\t  if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)\n\t\t    continue;\n\n\t\t  /* Check also other adjustment combinations - PR 11786.  */\n\n\t\t  vaddr = extract_unsigned_integer (buf_vaddr_p, 8,\n\t\t\t\t\t\t    byte_order);\n\t\t  vaddr -= displacement;\n\t\t  store_unsigned_integer (buf_vaddr_p, 8, byte_order, vaddr);\n\n\t\t  paddr = extract_unsigned_integer (buf_paddr_p, 8,\n\t\t\t\t\t\t    byte_order);\n\t\t  paddr -= displacement;\n\t\t  store_unsigned_integer (buf_paddr_p, 8, byte_order, paddr);\n\n\t\t  if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)\n\t\t    continue;\n\n\t\t  /* Strip modifies the flags and alignment of PT_GNU_RELRO.\n\t\t     CentOS-5 has problems with filesz, memsz as well.\n\t\t     Strip also modifies memsz of PT_TLS.\n\t\t     See PR 11786.  */\n\t\t  if (phdr2[i].p_type == PT_GNU_RELRO\n\t\t      || phdr2[i].p_type == PT_TLS)\n\t\t    {\n\t\t      Elf64_External_Phdr tmp_phdr = *phdrp;\n\t\t      Elf64_External_Phdr tmp_phdr2 = *phdr2p;\n\n\t\t      memset (tmp_phdr.p_filesz, 0, 8);\n\t\t      memset (tmp_phdr.p_memsz, 0, 8);\n\t\t      memset (tmp_phdr.p_flags, 0, 4);\n\t\t      memset (tmp_phdr.p_align, 0, 8);\n\t\t      memset (tmp_phdr2.p_filesz, 0, 8);\n\t\t      memset (tmp_phdr2.p_memsz, 0, 8);\n\t\t      memset (tmp_phdr2.p_flags, 0, 4);\n\t\t      memset (tmp_phdr2.p_align, 0, 8);\n\n\t\t      if (memcmp (&tmp_phdr, &tmp_phdr2, sizeof (tmp_phdr))\n\t\t\t  == 0)\n\t\t\tcontinue;\n\t\t    }\n\n\t\t  /* prelink can convert .plt SHT_NOBITS to SHT_PROGBITS.  */\n\t\t  plt2_asect = bfd_get_section_by_name (exec_bfd, \".plt\");\n\t\t  if (plt2_asect)\n\t\t    {\n\t\t      int content2;\n\t\t      gdb_byte *buf_filesz_p = (gdb_byte *) &phdrp->p_filesz;\n\t\t      CORE_ADDR filesz;\n\n\t\t      content2 = (bfd_section_flags (plt2_asect)\n\t\t\t\t  & SEC_HAS_CONTENTS) != 0;\n\n\t\t      filesz = extract_unsigned_integer (buf_filesz_p, 8,\n\t\t\t\t\t\t\t byte_order);\n\n\t\t      /* PLT2_ASECT is from on-disk file (exec_bfd) while\n\t\t\t FILESZ is from the in-memory image.  */\n\t\t      if (content2)\n\t\t\tfilesz += bfd_section_size (plt2_asect);\n\t\t      else\n\t\t\tfilesz -= bfd_section_size (plt2_asect);\n\n\t\t      store_unsigned_integer (buf_filesz_p, 8, byte_order,\n\t\t\t\t\t      filesz);\n\n\t\t      if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)\n\t\t\tcontinue;\n\t\t    }\n\n\t\t  return 0;\n\t\t}\n\t    }\n\t  else\n\t    return 0;\n\t}\n    }\n\n  if (info_verbose)\n    {\n      /* It can be printed repeatedly as there is no easy way to check\n\t the executable symbols/file has been already relocated to\n\t displacement.  */\n\n      printf_unfiltered (_(\"Using PIE (Position Independent Executable) \"\n\t\t\t   \"displacement %s for \\\"%s\\\".\\n\"),\n\t\t\t paddress (target_gdbarch (), exec_displacement),\n\t\t\t bfd_get_filename (exec_bfd));\n    }\n\n  *displacementp = exec_displacement;\n  return 1;\n}\n\n/* Relocate the main executable.  This function should be called upon\n   stopping the inferior process at the entry point to the program.\n   The entry point from BFD is compared to the AT_ENTRY of AUXV and if they are\n   different, the main executable is relocated by the proper amount.  */\n\nstatic void\nsvr4_relocate_main_executable (void)\n{\n  CORE_ADDR displacement;\n\n  /* If we are re-running this executable, SYMFILE_OBJFILE->SECTION_OFFSETS\n     probably contains the offsets computed using the PIE displacement\n     from the previous run, which of course are irrelevant for this run.\n     So we need to determine the new PIE displacement and recompute the\n     section offsets accordingly, even if SYMFILE_OBJFILE->SECTION_OFFSETS\n     already contains pre-computed offsets.\n\n     If we cannot compute the PIE displacement, either:\n\n       - The executable is not PIE.\n\n       - SYMFILE_OBJFILE does not match the executable started in the target.\n\t This can happen for main executable symbols loaded at the host while\n\t `ld.so --ld-args main-executable' is loaded in the target.\n\n     Then we leave the section offsets untouched and use them as is for\n     this run.  Either:\n\n       - These section offsets were properly reset earlier, and thus\n\t already contain the correct values.  This can happen for instance\n\t when reconnecting via the remote protocol to a target that supports\n\t the `qOffsets' packet.\n\n       - The section offsets were not reset earlier, and the best we can\n\t hope is that the old offsets are still applicable to the new run.  */\n\n  if (! svr4_exec_displacement (&displacement))\n    return;\n\n  /* Even DISPLACEMENT 0 is a valid new difference of in-memory vs. in-file\n     addresses.  */\n\n  if (symfile_objfile)\n    {\n      struct section_offsets *new_offsets;\n      int i;\n\n      new_offsets = XALLOCAVEC (struct section_offsets,\n\t\t\t\tsymfile_objfile->num_sections);\n\n      for (i = 0; i < symfile_objfile->num_sections; i++)\n\tnew_offsets->offsets[i] = displacement;\n\n      objfile_relocate (symfile_objfile, new_offsets);\n    }\n  else if (exec_bfd)\n    {\n      asection *asect;\n\n      for (asect = exec_bfd->sections; asect != NULL; asect = asect->next)\n\texec_set_section_address (bfd_get_filename (exec_bfd), asect->index,\n\t\t\t\t  bfd_section_vma (asect) + displacement);\n    }\n}\n\n/* Implement the \"create_inferior_hook\" target_solib_ops method.\n\n   For SVR4 executables, this first instruction is either the first\n   instruction in the dynamic linker (for dynamically linked\n   executables) or the instruction at \"start\" for statically linked\n   executables.  For dynamically linked executables, the system\n   first exec's /lib/libc.so.N, which contains the dynamic linker,\n   and starts it running.  The dynamic linker maps in any needed\n   shared libraries, maps in the actual user executable, and then\n   jumps to \"start\" in the user executable.\n\n   We can arrange to cooperate with the dynamic linker to discover the\n   names of shared libraries that are dynamically linked, and the base\n   addresses to which they are linked.\n\n   This function is responsible for discovering those names and\n   addresses, and saving sufficient information about them to allow\n   their symbols to be read at a later time.  */\n\nstatic void\nsvr4_solib_create_inferior_hook (int from_tty)\n{\n  struct svr4_info *info;\n\n  info = get_svr4_info (current_program_space);\n\n  /* Clear the probes-based interface's state.  */\n  free_probes_table (info);\n  free_solib_list (info);\n\n  /* Relocate the main executable if necessary.  */\n  svr4_relocate_main_executable ();\n\n  /* No point setting a breakpoint in the dynamic linker if we can't\n     hit it (e.g., a core file, or a trace file).  */\n  if (!target_has_execution)\n    return;\n\n  if (!svr4_have_link_map_offsets ())\n    return;\n\n  if (!enable_break (info, from_tty))\n    return;\n}\n\nstatic void\nsvr4_clear_solib (void)\n{\n  struct svr4_info *info;\n\n  info = get_svr4_info (current_program_space);\n  info->debug_base = 0;\n  info->debug_loader_offset_p = 0;\n  info->debug_loader_offset = 0;\n  xfree (info->debug_loader_name);\n  info->debug_loader_name = NULL;\n}\n\n/* Clear any bits of ADDR that wouldn't fit in a target-format\n   data pointer.  \"Data pointer\" here refers to whatever sort of\n   address the dynamic linker uses to manage its sections.  At the\n   moment, we don't support shared libraries on any processors where\n   code and data pointers are different sizes.\n\n   This isn't really the right solution.  What we really need here is\n   a way to do arithmetic on CORE_ADDR values that respects the\n   natural pointer/address correspondence.  (For example, on the MIPS,\n   converting a 32-bit pointer to a 64-bit CORE_ADDR requires you to\n   sign-extend the value.  There, simply truncating the bits above\n   gdbarch_ptr_bit, as we do below, is no good.)  This should probably\n   be a new gdbarch method or something.  */\nstatic CORE_ADDR\nsvr4_truncate_ptr (CORE_ADDR addr)\n{\n  if (gdbarch_ptr_bit (target_gdbarch ()) == sizeof (CORE_ADDR) * 8)\n    /* We don't need to truncate anything, and the bit twiddling below\n       will fail due to overflow problems.  */\n    return addr;\n  else\n    return addr & (((CORE_ADDR) 1 << gdbarch_ptr_bit (target_gdbarch ())) - 1);\n}\n\n\nstatic void\nsvr4_relocate_section_addresses (struct so_list *so,\n                                 struct target_section *sec)\n{\n  bfd *abfd = sec->the_bfd_section->owner;\n\n  sec->addr = svr4_truncate_ptr (sec->addr + lm_addr_check (so, abfd));\n  sec->endaddr = svr4_truncate_ptr (sec->endaddr + lm_addr_check (so, abfd));\n}\n\f\n\n/* Architecture-specific operations.  */\n\n/* Per-architecture data key.  */\nstatic struct gdbarch_data *solib_svr4_data;\n\nstruct solib_svr4_ops\n{\n  /* Return a description of the layout of `struct link_map'.  */\n  struct link_map_offsets *(*fetch_link_map_offsets)(void);\n};\n\n/* Return a default for the architecture-specific operations.  */\n\nstatic void *\nsolib_svr4_init (struct obstack *obstack)\n{\n  struct solib_svr4_ops *ops;\n\n  ops = OBSTACK_ZALLOC (obstack, struct solib_svr4_ops);\n  ops->fetch_link_map_offsets = NULL;\n  return ops;\n}\n\n/* Set the architecture-specific `struct link_map_offsets' fetcher for\n   GDBARCH to FLMO.  Also, install SVR4 solib_ops into GDBARCH.  */\n\nvoid\nset_solib_svr4_fetch_link_map_offsets (struct gdbarch *gdbarch,\n                                       struct link_map_offsets *(*flmo) (void))\n{\n  struct solib_svr4_ops *ops\n    = (struct solib_svr4_ops *) gdbarch_data (gdbarch, solib_svr4_data);\n\n  ops->fetch_link_map_offsets = flmo;\n\n  set_solib_ops (gdbarch, &svr4_so_ops);\n  set_gdbarch_iterate_over_objfiles_in_search_order\n    (gdbarch, svr4_iterate_over_objfiles_in_search_order);\n}\n\n/* Fetch a link_map_offsets structure using the architecture-specific\n   `struct link_map_offsets' fetcher.  */\n\nstatic struct link_map_offsets *\nsvr4_fetch_link_map_offsets (void)\n{\n  struct solib_svr4_ops *ops\n    = (struct solib_svr4_ops *) gdbarch_data (target_gdbarch (),\n\t\t\t\t\t      solib_svr4_data);\n\n  gdb_assert (ops->fetch_link_map_offsets);\n  return ops->fetch_link_map_offsets ();\n}\n\n/* Return 1 if a link map offset fetcher has been defined, 0 otherwise.  */\n\nstatic int\nsvr4_have_link_map_offsets (void)\n{\n  struct solib_svr4_ops *ops\n    = (struct solib_svr4_ops *) gdbarch_data (target_gdbarch (),\n\t\t\t\t\t      solib_svr4_data);\n\n  return (ops->fetch_link_map_offsets != NULL);\n}\n\f\n\n/* Most OS'es that have SVR4-style ELF dynamic libraries define a\n   `struct r_debug' and a `struct link_map' that are binary compatible\n   with the original SVR4 implementation.  */\n\n/* Fetch (and possibly build) an appropriate `struct link_map_offsets'\n   for an ILP32 SVR4 system.  */\n\nstruct link_map_offsets *\nsvr4_ilp32_fetch_link_map_offsets (void)\n{\n  static struct link_map_offsets lmo;\n  static struct link_map_offsets *lmp = NULL;\n\n  if (lmp == NULL)\n    {\n      lmp = &lmo;\n\n      lmo.r_version_offset = 0;\n      lmo.r_version_size = 4;\n      lmo.r_map_offset = 4;\n      lmo.r_brk_offset = 8;\n      lmo.r_ldsomap_offset = 20;\n\n      /* Everything we need is in the first 20 bytes.  */\n      lmo.link_map_size = 20;\n      lmo.l_addr_offset = 0;\n      lmo.l_name_offset = 4;\n      lmo.l_ld_offset = 8;\n      lmo.l_next_offset = 12;\n      lmo.l_prev_offset = 16;\n    }\n\n  return lmp;\n}\n\n/* Fetch (and possibly build) an appropriate `struct link_map_offsets'\n   for an LP64 SVR4 system.  */\n\nstruct link_map_offsets *\nsvr4_lp64_fetch_link_map_offsets (void)\n{\n  static struct link_map_offsets lmo;\n  static struct link_map_offsets *lmp = NULL;\n\n  if (lmp == NULL)\n    {\n      lmp = &lmo;\n\n      lmo.r_version_offset = 0;\n      lmo.r_version_size = 4;\n      lmo.r_map_offset = 8;\n      lmo.r_brk_offset = 16;\n      lmo.r_ldsomap_offset = 40;\n\n      /* Everything we need is in the first 40 bytes.  */\n      lmo.link_map_size = 40;\n      lmo.l_addr_offset = 0;\n      lmo.l_name_offset = 8;\n      lmo.l_ld_offset = 16;\n      lmo.l_next_offset = 24;\n      lmo.l_prev_offset = 32;\n    }\n\n  return lmp;\n}\n\f\n\nstruct target_so_ops svr4_so_ops;\n\n/* Search order for ELF DSOs linked with -Bsymbolic.  Those DSOs have a\n   different rule for symbol lookup.  The lookup begins here in the DSO, not in\n   the main executable.  */\n\nstatic void\nsvr4_iterate_over_objfiles_in_search_order\n  (struct gdbarch *gdbarch,\n   iterate_over_objfiles_in_search_order_cb_ftype *cb,\n   void *cb_data, struct objfile *current_objfile)\n{\n  bool checked_current_objfile = false;\n  if (current_objfile != nullptr)\n    {\n      bfd *abfd;\n\n      if (current_objfile->separate_debug_objfile_backlink != nullptr)\n        current_objfile = current_objfile->separate_debug_objfile_backlink;\n\n      if (current_objfile == symfile_objfile)\n\tabfd = exec_bfd;\n      else\n\tabfd = current_objfile->obfd;\n\n      if (abfd != nullptr\n\t  && scan_dyntag (DT_SYMBOLIC, abfd, nullptr, nullptr) == 1)\n\t{\n\t  checked_current_objfile = true;\n\t  if (cb (current_objfile, cb_data) != 0)\n\t    return;\n\t}\n    }\n\n  for (objfile *objfile : current_program_space->objfiles ())\n    {\n      if (checked_current_objfile && objfile == current_objfile)\n\tcontinue;\n      if (cb (objfile, cb_data) != 0)\n\treturn;\n    }\n}\n\nvoid\n_initialize_svr4_solib (void)\n{\n  solib_svr4_data = gdbarch_data_register_pre_init (solib_svr4_init);\n\n  svr4_so_ops.relocate_section_addresses = svr4_relocate_section_addresses;\n  svr4_so_ops.free_so = svr4_free_so;\n  svr4_so_ops.clear_so = svr4_clear_so;\n  svr4_so_ops.clear_solib = svr4_clear_solib;\n  svr4_so_ops.solib_create_inferior_hook = svr4_solib_create_inferior_hook;\n  svr4_so_ops.current_sos = svr4_current_sos;\n  svr4_so_ops.open_symbol_file_object = open_symbol_file_object;\n  svr4_so_ops.in_dynsym_resolve_code = svr4_in_dynsym_resolve_code;\n  svr4_so_ops.bfd_open = solib_bfd_open;\n  svr4_so_ops.same = svr4_same;\n  svr4_so_ops.keep_data_in_core = svr4_keep_data_in_core;\n  svr4_so_ops.update_breakpoints = svr4_update_solib_event_breakpoints;\n  svr4_so_ops.handle_event = svr4_handle_solib_event;\n\n  gdb::observers::free_objfile.attach (svr4_free_objfile_observer);\n}\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/puff/zeros.raw",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/masmx86/inffas32.obj",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/masmx86/gvmat32.obj",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/masmx64/inffasx64.obj",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/masmx64/gvmat64.obj",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/dotzlib/DotZLib.chm",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/dotzlib/DotZLib/Inflater.cs",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/dotzlib/DotZLib/GZipStream.cs",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/dotzlib/DotZLib/DotZLib.cs",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/dotzlib/DotZLib/Deflater.cs",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/dotzlib/DotZLib/CodecBase.cs",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/zlib/contrib/blast/test.pk",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/sim/m32c/mem.c",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/readline/readline/examples/rl-fgets.c",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/opcodes/po/ro.po",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/opcodes/po/da.po",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/libiberty/strverscmp.c",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/ld/po/da.po",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/intl/locale.alias",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gprof/po/ro.po",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gprof/po/ga.po",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gprof/po/da.po",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gdb/testsuite/gdb.arch/i386-biarch-core.core.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gdb/testsuite/gdb.arch/cordic.ko.debug.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gdb/testsuite/gdb.arch/cordic.ko.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gdb/doc/stack_frame.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gdb/doc/stack_frame.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gas/testsuite/gas/cris/bork.s",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gas/config/obj-evax.h",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/gas/config/obj-evax.c",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/binutils/testsuite/binutils-all/strings-1.bin",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/binutils/testsuite/binutils-all/x86-64/pr22451.o.bz2",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/binutils/testsuite/binutils-all/windres/bmp1.bmp",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/binutils/testsuite/binutils-all/nfp/test2_nfp6000.nffw",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/binutils/testsuite/binutils-all/nfp/test1_nfp6000.nffw",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/binutils/po/ro.po",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/binutils/po/da.po",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/bfd/configure.com",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/bfd/po/ro.po",
        "/var/tmp/sochat1/spack-stage/spack-stage-rocm-gdb-3.9.0-orzumz7fwnmrxznq5cb4j764kiqr674d/spack-src/bfd/hosts/alphavms.h"
    ],
    "total_files": 33677
}