{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cffi-1.14.3-4vai5rywo6vzaxjed5i5qykx4dlzfd5g/spack-src/doc/source/cdef.rst": "======================================\nPreparing and Distributing modules\n======================================\n\n.. contents::\n\nThere are three or four different ways to use CFFI in a project.\nIn order of complexity:\n\n* The **\"in-line\", \"ABI mode\"**:\n\n  .. code-block:: python\n\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"C-like declarations\")\n    lib = ffi.dlopen(\"libpath\")\n\n    # use ffi and lib here\n\n.. _out-of-line-abi:\n\n* The **\"out-of-line\",** but still **\"ABI mode\",** useful to organize\n  the code and reduce the import time:\n\n  .. code-block:: python\n\n    # in a separate file \"package/foo_build.py\"\n    import cffi\n\n    ffibuilder = cffi.FFI()\n    ffibuilder.set_source(\"package._foo\", None)\n    ffibuilder.cdef(\"C-like declarations\")\n\n    if __name__ == \"__main__\":\n        ffibuilder.compile()\n\n  Running ``python foo_build.py`` produces a file ``_foo.py``, which\n  can then be imported in the main program:\n\n  .. code-block:: python\n\n    from package._foo import ffi\n    lib = ffi.dlopen(\"libpath\")\n\n    # use ffi and lib here\n\n.. _out-of-line-api:\n\n* The **\"out-of-line\", \"API mode\"** gives you the most flexibility\n  and speed to access a C library at the level of C, instead of at the\n  binary level:\n\n  .. code-block:: python\n\n    # in a separate file \"package/foo_build.py\"\n    import cffi\n\n    ffibuilder = cffi.FFI()\n    ffibuilder.set_source(\"package._foo\", r\"\"\"real C code\"\"\")   # <=\n    ffibuilder.cdef(\"C-like declarations with '...'\")\n\n    if __name__ == \"__main__\":\n        ffibuilder.compile(verbose=True)\n\n  Running ``python foo_build.py`` produces a file ``_foo.c`` and\n  invokes the C compiler to turn it into a file ``_foo.so`` (or\n  ``_foo.pyd`` or ``_foo.dylib``).  It is a C extension module which\n  can be imported in the main program:\n\n  .. code-block:: python\n\n    from package._foo import ffi, lib\n    # no ffi.dlopen()\n\n    # use ffi and lib here\n\n.. _distutils-setuptools:\n\n* Finally, you can (but don't have to) use CFFI's **Distutils** or\n  **Setuptools integration** when writing a ``setup.py``.  For\n  Distutils (only in out-of-line API mode):\n\n  .. code-block:: python\n\n    # setup.py (requires CFFI to be installed first)\n    from distutils.core import setup\n\n    import foo_build   # possibly with sys.path tricks to find it\n\n    setup(\n        ...,\n        ext_modules=[foo_build.ffibuilder.distutils_extension()],\n    )\n\n  For Setuptools (out-of-line, but works in ABI or API mode;\n  recommended):\n\n  .. code-block:: python\n\n    # setup.py (with automatic dependency tracking)\n    from setuptools import setup\n\n    setup(\n        ...,\n        setup_requires=[\"cffi>=1.0.0\"],\n        cffi_modules=[\"package/foo_build.py:ffibuilder\"],\n        install_requires=[\"cffi>=1.0.0\"],\n    )\n\n  Note again that the ``foo_build.py`` example contains the following\n  lines, which mean that the ``ffibuilder`` is not actually compiled\n  when ``package.foo_build`` is merely imported---it will be compiled\n  independently by the Setuptools logic, using compilation parameters\n  provided by Setuptools:\n\n  .. code-block:: python\n\n    if __name__ == \"__main__\":    # not when running with setuptools\n        ffibuilder.compile(verbose=True)\n\n* Note that some bundler tools that try to find all modules used by a\n  project, like PyInstaller, will miss ``_cffi_backend`` in the\n  out-of-line mode because your program contains no explicit ``import\n  cffi`` or ``import _cffi_backend``.  You need to add\n  ``_cffi_backend`` explicitly (as a \"hidden import\" in PyInstaller,\n  but it can also be done more generally by adding the line ``import\n  _cffi_backend`` in your main program).\n\nNote that CFFI actually contains two different ``FFI`` classes.  The\npage `Using the ffi/lib objects`_ describes the common functionality.\nIt is what you get in the ``from package._foo import ffi`` lines above.\nOn the other hand, the extended ``FFI`` class is the one you get from\n``import cffi; ffi_or_ffibuilder = cffi.FFI()``.  It has the same\nfunctionality (for in-line use), but also the extra methods described\nbelow (to prepare the FFI).  NOTE: We use the name ``ffibuilder``\ninstead of ``ffi`` in the out-of-line context, when the code is about\nproducing a ``_foo.so`` file; this is an attempt to distinguish it\nfrom the different ``ffi`` object that you get by later saying\n``from _foo import ffi``.\n\n.. _`Using the ffi/lib objects`: using.html\n\nThe reason for this split of functionality is that a regular program\nusing CFFI out-of-line does not need to import the ``cffi`` pure\nPython package at all.  (Internally it still needs ``_cffi_backend``,\na C extension module that comes with CFFI; this is why CFFI is also\nlisted in ``install_requires=..`` above.  In the future this might be\nsplit into a different PyPI package that only installs\n``_cffi_backend``.)\n\nNote that a few small differences do exist: notably, ``from _foo import\nffi`` returns an object of a type written in C, which does not let you\nadd random attributes to it (nor does it have all the\nunderscore-prefixed internal attributes of the Python version).\nSimilarly, the ``lib`` objects returned by the C version are read-only,\napart from writes to global variables.  Also, ``lib.__dict__`` does\nnot work before version 1.2 or if ``lib`` happens to declare a name\ncalled ``__dict__`` (use instead ``dir(lib)``).  The same is true\nfor ``lib.__class__``, ``lib.__all__`` and ``lib.__name__`` added\nin successive versions.\n\n\n.. _cdef:\n\nffi/ffibuilder.cdef(): declaring types and functions\n----------------------------------------------------\n\n**ffi/ffibuilder.cdef(source)**: parses the given C source.\nIt registers all the functions, types, constants and global variables in\nthe C source.  The types can be used immediately in ``ffi.new()`` and\nother functions.  Before you can access the functions and global\nvariables, you need to give ``ffi`` another piece of information: where\nthey actually come from (which you do with either ``ffi.dlopen()`` or\n``ffi.set_source()``).\n\n.. _`all types listed above`:\n\nThe C source is parsed internally (using ``pycparser``).  This code\ncannot contain ``#include``.  It should typically be a self-contained\npiece of declarations extracted from a man page.  The only things it\ncan assume to exist are the standard types:\n\n* char, short, int, long, long long (both signed and unsigned)\n\n* float, double, long double\n\n* intN_t, uintN_t (for N=8,16,32,64), intptr_t, uintptr_t, ptrdiff_t,\n  size_t, ssize_t\n\n* wchar_t (if supported by the backend).  *New in version 1.11:*\n  char16_t and char32_t.\n\n* _Bool and bool (equivalent).  If not directly supported by the C\n  compiler, this is declared with the size of ``unsigned char``.\n\n* FILE.  `See here.`__\n\n* all `common Windows types`_ are defined if you run\n  on Windows (``DWORD``, ``LPARAM``, etc.).  Exception:\n  ``TBYTE TCHAR LPCTSTR PCTSTR LPTSTR PTSTR PTBYTE PTCHAR`` are\n  not automatically defined; see `ffi.set_unicode()`_.\n\n* the other standard integer types from\n  stdint.h, like ``intmax_t``, as long as they map to integers of 1,\n  2, 4 or 8 bytes.  Larger integers are not supported.\n\n.. __: ref.html#file\n.. _`common Windows types`: http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx\n\nThe declarations can also contain \"``...``\" at various places; these are\nplaceholders that will be completed by the compiler.  More information\nabout it below in `Letting the C compiler fill the gaps`_.\n\nNote that all standard type names listed above are handled as\n*defaults* only (apart from the ones that are keywords in the C\nlanguage).  If your ``cdef`` contains an explicit typedef that\nredefines one of the types above, then the default described above is\nignored.  (This is a bit hard to implement cleanly, so in some corner\ncases it might fail, notably with the error ``Multiple type specifiers\nwith a type tag``.  Please report it as a bug if it does.)\n\nMultiple calls to ``ffi.cdef()`` are possible.  Beware that it can be\nslow to call ``ffi.cdef()`` a lot of times, a consideration that is\nimportant mainly in in-line mode.\n\nThe ``ffi.cdef()`` call optionally takes an extra argument: either\n``packed`` or ``pack``.  If you pass ``packed=True``,\nthen all structs declared within\nthis cdef are \"packed\".  (If you need both packed and non-packed\nstructs, use several cdefs in sequence.)  This\nhas a meaning similar to ``__attribute__((packed))`` in GCC.  It\nspecifies that all structure fields should have an alignment of one\nbyte.  (Note that the packed attribute has no effect on bit fields so\nfar, which mean that they may be packed differently than on GCC.\nAlso, this has no effect on structs declared with ``\"...;\"``---more\nabout it later in `Letting the C compiler fill the gaps`_.  In\nparticular, if your C source uses other attributes like\n``__attribute__((aligned(16)))``, there is no way to declare this fact\nin the ``cdef()``, but you can generally just declare the struct with\n``\"...;\"`` as the last field.)\n\n*New in version 1.12:*  In ABI mode, you can also pass ``pack=n``,\nwith an integer ``n`` which must be a power of two.  Then the\nalignment of any field is limited to ``n`` if it would otherwise be\ngreater than ``n``.  Passing ``pack=1`` is equivalent to passing\n``packed=True``.  This is meant to emulate ``#pragma pack(n)`` from\nthe MSVC compiler.  On Windows, the default is ``pack=8`` (from cffi\n1.12 onwards); on other platforms, the default is ``pack=None``.\n\nNote that you can use the type-qualifiers ``const`` and ``restrict``\n(but not ``__restrict`` or ``__restrict__``) in the ``cdef()``, but\nthis has no effect on the cdata objects that you get at run-time (they\nare never ``const``).  The effect is limited to knowing if a global\nvariable is meant to be a constant or not.  Also, *new in version\n1.3:* when using ``set_source()`` or ``verify()``, these two\nqualifiers are copied from the cdef to the generated C code; this\nfixes warnings by the C compiler.\n\nNote a trick if you copy-paste code from sources in which there are\nextra macros (for example, the Windows documentation uses SAL\nannotations like ``_In_`` or ``_Out_``).  These hints must be removed\nin the string given to cdef(), but it can be done programmatically\nlike this::\n\n    ffi.cdef(re.sub(r\"\\b(_In_|_Inout_|_Out_|_Outptr_)(opt_)?\\b\", \" \",\n      \"\"\"\n        DWORD WINAPI GetModuleFileName(\n          _In_opt_ HMODULE hModule,\n          _Out_    LPTSTR  lpFilename,\n          _In_     DWORD   nSize\n        );\n      \"\"\"))\n\nNote also that pycparser, the underlying C parser, recognizes\npreprocessor-like directives in the following format: ``# NUMBER\n\"FILE\"``.  For example, if you put ``# 42 \"foo.h\"`` in the middle of the\nstring passed to ``cdef()`` and there is an error two lines later, then\nit is reported with an error message that starts with ``foo.h:43:`` (the\nline which is given the number 42 is the line immediately after the\ndirective).  *New in version 1.10.1:*  CFFI automatically puts the line\n``# 1 \"<cdef source string>\"`` just before the string you give to\n``cdef()``.\n\n\n.. _`ffi.set_unicode()`:\n\n**ffi.set_unicode(enabled_flag)**: Windows: if ``enabled_flag`` is\nTrue, enable the ``UNICODE`` and ``_UNICODE`` defines in C, and\ndeclare the types ``TBYTE TCHAR LPCTSTR PCTSTR LPTSTR PTSTR PTBYTE\nPTCHAR`` to be (pointers to) ``wchar_t``.  If ``enabled_flag`` is\nFalse, declare these types to be (pointers to) plain 8-bit characters.\n(These types are not predeclared at all if you don't call\n``set_unicode()``.)\n\nThe reason behind this method is that a lot of standard functions have\ntwo versions, like ``MessageBoxA()`` and ``MessageBoxW()``.  The\nofficial interface is ``MessageBox()`` with arguments like\n``LPTCSTR``.  Depending on whether ``UNICODE`` is defined or not, the\nstandard header renames the generic function name to one of the two\nspecialized versions, and declares the correct (unicode or not) types.\n\nUsually, the right thing to do is to call this method with True.  Be\naware (particularly on Python 2) that, afterwards, you need to pass unicode\nstrings as arguments instead of byte strings.\n\n\n.. _loading-libraries:\n\nffi.dlopen(): loading libraries in ABI mode\n-------------------------------------------\n\n``ffi.dlopen(libpath, [flags])``: this function opens a shared library and\nreturns a module-like library object.  Use this when you are fine with\nthe limitations of ABI-level access to the system (dependency on ABI\ndetails, getting crashes instead of C compiler errors/warnings, and\nhigher overhead to call the C functions).  In case of doubt, read again\n`ABI versus API`_ in the overview.\n\n.. _`ABI versus API`: overview.html#abi-versus-api\n\nYou can use the library object to call the functions previously\ndeclared by ``ffi.cdef()``, to read constants, and to read or write\nglobal variables.  Note that you can use a single ``cdef()`` to\ndeclare functions from multiple libraries, as long as you load each of\nthem with ``dlopen()`` and access the functions from the correct one.\n\nThe ``libpath`` is the file name of the shared library, which can\ncontain a full path or not (in which case it is searched in standard\nlocations, as described in ``man dlopen``), with extensions or not.\nAlternatively, if ``libpath`` is None, it returns the standard C library\n(which can be used to access the functions of glibc, on Linux).  Note\nthat ``libpath`` `cannot be None`__ on Windows with Python 3.\n\n.. __: http://bugs.python.org/issue23606\n\nLet me state it again: this gives ABI-level access to the library, so\nyou need to have all types declared manually exactly as they were\nwhile the library was made.  No checking is done.  Mismatches can\ncause random crashes.  API-level access, on the other hand, is safer.\nSpeed-wise, API-level access is much faster (it is common to have\nthe opposite misconception about performance).\n\nNote that only functions and global variables live in library objects;\nthe types exist in the ``ffi`` instance independently of library objects.\nThis is due to the C model: the types you declare in C are not tied to a\nparticular library, as long as you ``#include`` their headers; but you\ncannot call functions from a library without linking it in your program,\nas ``dlopen()`` does dynamically in C.\n\nFor the optional ``flags`` argument, see ``man dlopen`` (ignored on\nWindows).  It defaults to ``ffi.RTLD_NOW``.\n\nThis function returns a \"library\" object that gets closed when it goes\nout of scope.  Make sure you keep the library object around as long as\nneeded.  (Alternatively, the out-of-line FFIs have a method\n``ffi.dlclose(lib)``.)\n\n.. _dlopen-note:\n\nNote: the old version of ``ffi.dlopen()`` from the in-line ABI mode\ntries to use ``ctypes.util.find_library()`` if it cannot directly find\nthe library.  The newer out-of-line ``ffi.dlopen()`` no longer does it\nautomatically; it simply passes the argument it receives to the\nunderlying ``dlopen()`` or ``LoadLibrary()`` function.  If needed, it\nis up to you to use ``ctypes.util.find_library()`` or any other way to\nlook for the library's filename.  This also means that\n``ffi.dlopen(None)`` no longer work on Windows; try instead\n``ffi.dlopen(ctypes.util.find_library('c'))``.\n\n*New in version 1.14:* ``ffi.dlopen(handle)``: instead of a file path,\nyou can give an already-opened library handle, as a cdata of type\n``void *``.  Such a call converts this handle into a regular FFI object\nwith the functions and global variables declared by ``ffi.cdef()``.\nUseful if you have special needs (e.g. you need the GNU extension\n``dlmopen()``, which you can itself declare and call using a different\n``ffi`` object).  Note that in this variant, ``dlclose()`` is not called\nautomatically if the FFI object is garbage-collected (but you can still\ncall ``ffi.dlclose()`` explicitly if needed).\n\n\nffibuilder.set_source(): preparing out-of-line modules\n------------------------------------------------------\n\n**ffibuilder.set_source(module_name, c_header_source, [\\*\\*keywords...])**:\nprepare the ffi for producing out-of-line an external module called\n``module_name``.\n\n``ffibuilder.set_source()`` by itself does not write any file, but merely\nrecords its arguments for later.  It can therefore be called before or\nafter ``ffibuilder.cdef()``.\n\nIn **ABI mode,** you call ``ffibuilder.set_source(module_name, None)``.  The\nargument is the name (or dotted name inside a package) of the Python\nmodule to generate.  In this mode, no C compiler is called.\n\nIn **API mode,** the ``c_header_source`` argument is a string that\nwill be pasted into the .c file generated.  Typically, it is specified as\n``r\"\"\" ...multiple lines of C code... \"\"\"`` (the ``r`` prefix allows these\nlines to contain a literal ``\\n``, for example).  This piece of C code\ntypically contains some ``#include``, but may also contain more,\nlike definitions for custom \"wrapper\" C functions.  The goal is that\nthe .c file can be generated like this::\n\n    // C file \"module_name.c\"\n    #include <Python.h>\n\n    ...c_header_source...\n\n    ...magic code...\n\nwhere the \"magic code\" is automatically generated from the ``cdef()``.\nFor example, if the ``cdef()`` contains ``int foo(int x);`` then the\nmagic code will contain logic to call the function ``foo()`` with an\ninteger argument, itself wrapped inside some CPython or PyPy-specific\ncode.\n\nThe keywords arguments to ``set_source()`` control how the C compiler\nwill be called.  They are passed directly to distutils_ or setuptools_\nand include at least ``sources``, ``include_dirs``, ``define_macros``,\n``undef_macros``, ``libraries``, ``library_dirs``, ``extra_objects``,\n``extra_compile_args`` and ``extra_link_args``.  You typically need at\nleast ``libraries=['foo']`` in order to link with ``libfoo.so`` or\n``libfoo.so.X.Y``, or ``foo.dll`` on Windows.  The ``sources`` is a\nlist of extra .c files compiled and linked together (the file\n``module_name.c`` shown above is always generated and automatically added as the\nfirst argument to ``sources``).  See the distutils documentations for\n`more information about the other arguments`__.\n\n.. __: http://docs.python.org/distutils/setupscript.html#library-options\n.. _distutils: http://docs.python.org/distutils/setupscript.html#describing-extension-modules\n.. _setuptools: https://pythonhosted.org/setuptools/setuptools.html\n\nAn extra keyword argument processed internally is\n``source_extension``, defaulting to ``\".c\"``.  The file generated will\nbe actually called ``module_name + source_extension``.  Example for\nC++ (but note that there are still a few known issues of C-versus-C++\ncompatibility):\n\n.. code-block:: python\n\n    ffibuilder.set_source(\"mymodule\", r'''\n    extern \"C\" {\n        int somefunc(int somearg) { return real_cpp_func(somearg); }\n    }\n    ''', source_extension='.cpp')\n\n.. _pkgconfig:\n\n**ffibuilder.set_source_pkgconfig(module_name, pkgconfig_libs,\nc_header_source, [\\*\\*keywords...])**:\n\n*New in version 1.12.*  This is equivalent to ``set_source()`` but it\nfirst calls the system utility ``pkg-config`` with the package names\ngiven in the list ``pkgconfig_libs``.  It collects the information\nobtained in this way and adds it to the explicitly-provided\n``**keywords`` (if any).  This should probably not be used on Windows.\n\nIf the ``pkg-config`` program is not installed or does not know about\nthe requested library, the call fails with ``cffi.PkgConfigError``.  If\nnecessary, you can catch this error and try to call ``set_source()``\ndirectly.  (Ideally, you should also do that if the ``ffibuilder``\ninstance has no method ``set_source_pkgconfig()``, to support older\nversions of cffi.)\n\n\nLetting the C compiler fill the gaps\n------------------------------------\n\nIf you are using a C compiler (\"API mode\"), then:\n\n*  functions taking or returning integer or float-point arguments can be\n   misdeclared: if e.g. a function is declared by ``cdef()`` as taking a\n   ``int``, but actually takes a ``long``, then the C compiler handles the\n   difference.\n\n*  other arguments are checked: you get a compilation warning or error\n   if you pass a ``int *`` argument to a function expecting a ``long *``.\n\n*  similarly, most other things declared in the ``cdef()`` are checked,\n   to the best we implemented so far; mistakes give compilation\n   warnings or errors.\n\nMoreover, you can use \"``...``\" (literally, dot-dot-dot) in the\n``cdef()`` at various places, in order to ask the C compiler to fill\nin the details.  These places are:\n\n*  structure declarations: any ``struct { }`` or ``union { }`` that ends\n   with \"``...;``\" as the last \"field\" is partial: it may be missing\n   fields, have them declared out of order, use non-standard alignment,\n   etc.  Precisely, the field offsets, total struct size, and total\n   struct alignment deduced by looking at the ``cdef`` are not relied\n   upon and will instead be corrected by the compiler.  (But note that you\n   can only access fields that you declared, not others.)  Any ``struct``\n   declaration which doesn't use \"``...``\" is assumed to be exact, but this is\n   checked: you get an error if it is not correct.\n\n*  integer types: the syntax \"``typedef\n   int... foo_t;``\" declares the type ``foo_t`` as an integer type\n   whose exact size and signedness is not specified.  The compiler will\n   figure it out.  (Note that this requires ``set_source()``; it does\n   not work with ``verify()``.)  The ``int...`` can be replaced with\n   ``long...`` or ``unsigned long long...`` or any other primitive\n   integer type, with no effect.  The type will always map to one of\n   ``(u)int(8,16,32,64)_t`` in Python, but in the generated C code,\n   only ``foo_t`` is used.\n\n* *New in version 1.3:* floating-point types: \"``typedef\n  float... foo_t;``\" (or equivalently \"``typedef double... foo_t;``\")\n  declares ``foo_t`` as a-float-or-a-double; the compiler will figure\n  out which it is.  Note that if the actual C type is even larger\n  (``long double`` on some platforms), then compilation will fail.\n  The problem is that the Python \"float\" type cannot be used to store\n  the extra precision.  (Use the non-dot-dot-dot syntax ``typedef long\n  double foo_t;`` as usual, which returns values that are not Python\n  floats at all but cdata \"long double\" objects.)\n\n*  unknown types: the syntax \"``typedef ... foo_t;``\" declares the type\n   ``foo_t`` as opaque.  Useful mainly for when the API takes and returns\n   ``foo_t *`` without you needing to look inside the ``foo_t``.  Also\n   works with \"``typedef ... *foo_p;``\" which declares the pointer type\n   ``foo_p`` without giving a name to the opaque type itself.  Note that\n   such an opaque struct has no known size, which prevents some operations\n   from working (mostly like in C).  *You cannot use this syntax to\n   declare a specific type, like an integer type!  It declares opaque\n   struct-like types only.*  In some cases you need to say that\n   ``foo_t`` is not opaque, but just a struct where you don't know any\n   field; then you would use \"``typedef struct { ...; } foo_t;``\".\n\n*  array lengths: when used as structure fields or in global variables,\n   arrays can have an unspecified length, as in \"``extern int n[...];``\".  The\n   length is completed by the C compiler.\n   This is slightly different from \"``extern int n[];``\", because the latter\n   means that the length is not known even to the C compiler, and thus\n   no attempt is made to complete it.  This supports\n   multidimensional arrays: \"``extern int n[...][...];``\".\n\n   *New in version 1.2:* \"``extern int m[][...];``\", i.e. ``...`` can be used\n   in the innermost dimensions without being also used in the outermost\n   dimension.  In the example given, the length of the ``m`` array is\n   assumed not to be known to the C compiler, but the length of every\n   item (like the sub-array ``m[0]``) is always known the C compiler.\n   In other words, only the outermost dimension can be specified as\n   ``[]``, both in C and in CFFI, but any dimension can be given as\n   ``[...]`` in CFFI.\n\n*  enums: if you don't know the exact order (or values) of the declared\n   constants, then use this syntax: \"``enum foo { A, B, C, ... };``\"\n   (with a trailing \"``...``\").  The C compiler will be used to figure\n   out the exact values of the constants.  An alternative syntax is\n   \"``enum foo { A=..., B, C };``\" or even\n   \"``enum foo { A=..., B=..., C=... };``\".  Like\n   with structs, an ``enum`` without \"``...``\" is assumed to\n   be exact, and this is checked.\n\n*  integer constants and macros: you can write in the ``cdef`` the line\n   \"``#define FOO ...``\", with any macro name FOO but with ``...`` as\n   a value.  Provided the macro\n   is defined to be an integer value, this value will be available via\n   an attribute of the library object.  The\n   same effect can be achieved by writing a declaration\n   ``static const int FOO;``.  The latter is more general because it\n   supports other types than integer types (note: the C syntax is then\n   to write the ``const`` together with the variable name, as in\n   ``static char *const FOO;``).\n\nCurrently, it is not supported to find automatically which of the\nvarious integer or float types you need at which place---except in the\nfollowing case: if such a type is explicitly named.  For an integer\ntype, use ``typedef int... the_type_name;``, or another type like\n``typedef unsigned long... the_type_name;``.  Both are equivalent and\nreplaced by the real C type, which must be an integer type.\nSimilarly, for floating-point types, use ``typedef float...\nthe_type_name;`` or equivalently ``typedef double...  the_type_name;``.\nNote that ``long double`` cannot be detected this way.\n\nIn the case of function arguments or return types, when it is a simple\ninteger/float type, you can simply misdeclare it.  If you misdeclare a\nfunction ``void f(long)`` as ``void f(int)``, it still works (but you\nhave to call it with arguments that fit an int).  It works because the C\ncompiler will do the casting for us.  This C-level casting of arguments\nand return types only works for regular function, and not for function\npointer types; currently, it also does not work for variadic functions.\n\nFor more complex types, you have no choice but be precise.  For example,\nyou cannot misdeclare a ``int *`` argument as ``long *``, or a global\narray ``extern int a[5];`` as ``extern long a[5];``.  CFFI considers `all types listed\nabove`_ as primitive (so ``extern long long a[5];`` and ``extern int64_t a[5]`` are\ndifferent declarations).  The reason for that is detailed in `a comment\nabout an issue.`__\n\n.. __: https://foss.heptapod.net/pypy/cffi/-/issues/265#note_50393\n\n\nffibuilder.compile() etc.: compiling out-of-line modules\n--------------------------------------------------------\n\nYou can use one of the following functions to actually generate the\n.py or .c file prepared with ``ffibuilder.set_source()`` and\n``ffibuilder.cdef()``.\n\nNote that these function won't overwrite a .py/.c file with exactly\nthe same content, to preserve the mtime.  In some cases where you need\nthe mtime to be updated anyway, delete the file before calling the\nfunctions.\n\n*New in version 1.8:* the C code produced by ``emit_c_code()`` or\n``compile()`` contains ``#define Py_LIMITED_API``.  This means that on\nCPython >= 3.2, compiling this source produces a binary .so/.dll that\nshould work for any version of CPython >= 3.2 (as opposed to only for\nthe same version of CPython x.y).  However, the standard ``distutils``\npackage will still produce a file called e.g.\n``NAME.cpython-35m-x86_64-linux-gnu.so``.  You can manually rename it to\n``NAME.abi3.so``, or use setuptools version 26 or later.  Also, note\nthat compiling with a debug version of Python will not actually define\n``Py_LIMITED_API``, as doing so makes ``Python.h`` unhappy.\n\n*New in version 1.12:* ``Py_LIMITED_API`` is now defined on Windows too.\nIf you use ``virtualenv``, you need a recent version of it: versions\nolder than 16.0.0 forgot to copy ``python3.dll`` into the virtual\nenvironment.  In case upgrading ``virtualenv`` is a real problem, you\ncan manually edit the C code to remove the first line ``# define\nPy_LIMITED_API``.\n\n**ffibuilder.compile(tmpdir='.', verbose=False, debug=None):**\nexplicitly generate the .py or .c file,\nand (if .c) compile it.  The output file is (or are) put in the\ndirectory given by ``tmpdir``.  In the examples given here, we use\n``if __name__ == \"__main__\": ffibuilder.compile()`` in the build scripts---if\nthey are directly executed, this makes them rebuild the .py/.c file in\nthe current directory.  (Note: if a package is specified in the call\nto ``set_source()``, then a corresponding subdirectory of the ``tmpdir``\nis used.)\n\n*New in version 1.4:* ``verbose`` argument.  If True, it prints the\nusual distutils output, including the command lines that call the\ncompiler.  (This parameter might be changed to True by default in a\nfuture release.)\n\n*New in version 1.8.1:* ``debug`` argument.  If set to a bool, it\ncontrols whether the C code is compiled in debug mode or not.  The\ndefault None means to use the host Python's ``sys.flags.debug``.\nStarting with version 1.8.1, if you are running a debug-mode Python, the\nC code is thus compiled in debug mode by default (note that it is anyway\nnecessary to do so on Windows).\n\n**ffibuilder.emit_python_code(filename):** generate the given .py file (same\nas ``ffibuilder.compile()`` for ABI mode, with an explicitly-named file to\nwrite).  If you choose, you can include this .py file pre-packaged in\nyour own distributions: it is identical for any Python version (2 or\n3).\n\n**ffibuilder.emit_c_code(filename):** generate the given .c file (for API\nmode) without compiling it.  Can be used if you have some other method\nto compile it, e.g. if you want to integrate with some larger build\nsystem that will compile this file for you.  You can also distribute\nthe .c file: unless the build script you used depends on the OS or\nplatform, the .c file itself is generic (it would be exactly the same\nif produced on a different OS, with a different version of CPython, or\nwith PyPy; it is done with generating the appropriate ``#ifdef``).\n\n**ffibuilder.distutils_extension(tmpdir='build', verbose=True):** for\ndistutils-based ``setup.py`` files.  Calling this creates the .c file\nif needed in the given ``tmpdir``, and returns a\n``distutils.core.Extension`` instance.\n\nFor Setuptools, you use instead the line\n``cffi_modules=[\"path/to/foo_build.py:ffibuilder\"]`` in ``setup.py``.  This\nline asks Setuptools to import and use a helper provided by CFFI,\nwhich in turn executes the file ``path/to/foo_build.py`` (as with\n``execfile()``) and looks up its global variable called ``ffibuilder``.  You\ncan also say ``cffi_modules=[\"path/to/foo_build.py:maker\"]``, where\n``maker`` names a global function; it is called with no argument and\nis supposed to return a ``FFI`` object.\n\n\nffi/ffibuilder.include(): combining multiple CFFI interfaces\n------------------------------------------------------------\n\n**ffi/ffibuilder.include(other_ffi)**: includes the typedefs, structs, unions,\nenums and constants defined in another FFI instance.  This is meant\nfor large projects where one CFFI-based interface depends on some\ntypes declared in a different CFFI-based interface.\n\n*Note that you should only use one ffi object per library; the intended\nusage of ffi.include() is if you want to interface with several\ninter-dependent libraries.*  For only one library, make one ``ffi``\nobject.  (You can write several ``cdef()`` calls over the same ``ffi``\nfrom several Python files, if one file would be too large.)\n\nFor out-of-line modules, the ``ffibuilder.include(other_ffibuilder)``\nline should\noccur in the build script, and the ``other_ffibuilder`` argument should be\nanother FFI instance that comes from another build script.  When the two build\nscripts are turned into generated files, say ``_ffi.so`` and\n``_other_ffi.so``, then importing ``_ffi.so`` will internally cause\n``_other_ffi.so`` to be imported.  At that point, the real\ndeclarations from ``_other_ffi.so`` are combined with the real\ndeclarations from ``_ffi.so``.\n\nThe usage of ``ffi.include()`` is the cdef-level equivalent of a\n``#include`` in C, where a part of the program might include types and\nfunctions defined in another part for its own usage.  You can see on\nthe ``ffi`` object (and associated ``lib`` objects on the *including*\nside) the types and constants declared on the included side.  In API\nmode, you can also see the functions and global variables directly.\nIn ABI mode, these must be accessed via the original ``other_lib``\nobject returned by the ``dlopen()`` method on ``other_ffi``.\n\n\nffi.cdef() limitations\n----------------------\n\nAll of the ANSI C *declarations* should be supported in ``cdef()``,\nand some of C99.  (This excludes any ``#include`` or ``#ifdef``.)\nKnown missing features that are either in C99, or are GCC or MSVC\nextensions:\n\n* Any ``__attribute__`` or ``#pragma pack(n)``\n\n* Additional types: special-size floating and fixed\n  point types, vector types, and so on.\n\n* The C99 types ``float _Complex`` and ``double _Complex`` are supported\n  by cffi since version 1.11, but not libffi: you cannot call C\n  functions with complex arguments or return value, except if they are\n  directly API-mode functions.  The type ``long double _Complex`` is not\n  supported at all (declare and use it as if it were an array of two\n  ``long double``, and write wrapper functions in C with set_source()).\n\n* ``__restrict__`` or ``__restrict`` are extensions of, respectively,\n   GCC and MSVC.  They are not recognized.  But ``restrict`` is a C\n   keyword and is accepted (and ignored).\n\nNote that declarations like ``int field[];`` in\nstructures are interpreted as variable-length structures.  Declarations\nlike ``int field[...];`` on the other hand are arrays whose length is\ngoing to be completed by the compiler.  You can use ``int field[];``\nfor array fields that are not, in fact, variable-length; it works too,\nbut in this case, as CFFI\nbelieves it cannot ask the C compiler for the length of the array, you\nget reduced safety checks: for example, you risk overwriting the\nfollowing fields by passing too many array items in the constructor.\n\n*New in version 1.2:*\nThread-local variables (``__thread``) can be accessed, as well as\nvariables defined as dynamic macros (``#define myvar  (*fetchme())``).\nBefore version 1.2, you need to write getter/setter functions.\n\nNote that if you declare a variable in ``cdef()`` without using\n``const``, CFFI assumes it is a read-write variable and generates two\npieces of code, one to read it and one to write it.  If the variable\ncannot in fact be written to in C code, for one reason or another, it\nwill not compile.  In this case, you can declare it as a constant: for\nexample, instead of ``foo_t *myglob;`` you would use ``foo_t *const\nmyglob;``.  Note also that ``const foo_t *myglob;``  is a *variable;* it\ncontains a variable pointer to a constant ``foo_t``.\n\n\nDebugging dlopen'ed C libraries\n-------------------------------\n\nA few C libraries are actually hard to use correctly in a ``dlopen()``\nsetting.  This is because most C libraries are intended for, and tested\nwith, a situation where they are *linked* with another program, using\neither static linking or dynamic linking --- but from a program written\nin C, at start-up, using the linker's capabilities instead of\n``dlopen()``.\n\nThis can occasionally create issues.  You would have the same issues in\nanother setting than CFFI, like with ``ctypes`` or even plain C code that\ncalls ``dlopen()``.  This section contains a few generally useful\nenvironment variables (on Linux) that can help when debugging these\nissues.\n\n**export LD_TRACE_LOADED_OBJECTS=all**\n\n    provides a lot of information, sometimes too much depending on the\n    setting.  Output verbose debugging information about the dynamic\n    linker. If set to ``all`` prints all debugging information it has, if\n    set to ``help`` prints a help message about which categories can be\n    specified in this environment variable\n\n**export LD_VERBOSE=1**\n\n    (glibc since 2.1) If set to a nonempty string, output symbol\n    versioning information about the program if querying information\n    about the program (i.e., either ``LD_TRACE_LOADED_OBJECTS`` has been set,\n    or ``--list`` or ``--verify`` options have been given to the dynamic\n    linker).\n\n**export LD_WARN=1**\n\n    (ELF only)(glibc since 2.1.3) If set to a nonempty string, warn\n    about unresolved symbols.\n\n\nffi.verify(): in-line API-mode\n------------------------------\n\n**ffi.verify()** is supported for backward compatibility, but is\ndeprecated.  ``ffi.verify(c_header_source, tmpdir=.., ext_package=..,\nmodulename=.., flags=.., **kwargs)`` makes and compiles a C file from\nthe ``ffi.cdef()``, like ``ffi.set_source()`` in API mode, and then\nimmediately loads and returns the dynamic library object.  Some\nnon-trivial logic is used to decide if the dynamic library must be\nrecompiled or not; see below for ways to control it.\n\nThe ``c_header_source`` and the extra keyword arguments have the\nsame meaning as in ``ffi.set_source()``.\n\nOne remaining use case for ``ffi.verify()`` would be the following\nhack to find explicitly the size of any type, in bytes, and have it\navailable in Python immediately (e.g. because it is needed in order to\nwrite the rest of the build script):\n\n.. code-block:: python\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"const int mysize;\")\n    lib = ffi.verify(\"const int mysize = sizeof(THE_TYPE);\")\n    print lib.mysize\n\nExtra arguments to ``ffi.verify()``:\n    \n*  ``tmpdir`` controls where the C\n   files are created and compiled. Unless the ``CFFI_TMPDIR`` environment\n   variable is set, the default is\n   ``directory_containing_the_py_file/__pycache__`` using the\n   directory name of the .py file that contains the actual call to\n   ``ffi.verify()``.  (This is a bit of a hack but is generally\n   consistent with the location of the .pyc files for your library.\n   The name ``__pycache__`` itself comes from Python 3.)\n\n*  ``ext_package`` controls in which package the\n   compiled extension module should be looked from.  This is\n   only useful after distributing ffi.verify()-based modules.\n\n*  The ``tag`` argument gives an extra string inserted in the\n   middle of the extension module's name: ``_cffi_<tag>_<hash>``.\n   Useful to give a bit more context, e.g. when debugging.\n\n*  The ``modulename`` argument can be used to force a specific module\n   name, overriding the name ``_cffi_<tag>_<hash>``.  Use with care,\n   e.g. if you are passing variable information to ``verify()`` but\n   still want the module name to be always the same (e.g. absolute\n   paths to local files).  In this case, no hash is computed and if\n   the module name already exists it will be reused without further\n   check.  Be sure to have other means of clearing the ``tmpdir``\n   whenever you change your sources.\n\n* ``source_extension`` has the same meaning as in ``ffibuilder.set_source()``.\n\n*  The optional ``flags`` argument (ignored on Windows) defaults to\n   ``ffi.RTLD_NOW``; see ``man dlopen``.  (With\n   ``ffibuilder.set_source()``, you would use ``sys.setdlopenflags()``.)\n\n*  The optional ``relative_to`` argument is useful if you need to list\n   local files passed to the C compiler::\n\n     ext = ffi.verify(..., sources=['foo.c'], relative_to=__file__)\n\n   The line above is roughly the same as::\n\n     ext = ffi.verify(..., sources=['/path/to/this/file/foo.c'])\n\n   except that the default name of the produced library is built from\n   the CRC checkum of the argument ``sources``, as well as most other\n   arguments you give to ``ffi.verify()`` -- but not ``relative_to``.\n   So if you used the second line, it would stop finding the\n   already-compiled library after your project is installed, because\n   the ``'/path/to/this/file'`` suddenly changed.  The first line does\n   not have this problem.\n\nNote that during development, every time you change the C sources that\nyou pass to ``cdef()`` or ``verify()``, then the latter will create a\nnew module file name, based on two CRC32 hashes computed from these\nstrings.  This creates more and more files in the ``__pycache__``\ndirectory.  It is recommended that you clean it up from time to time.\nA nice way to do that is to add, in your test suite, a call to\n``cffi.verifier.cleanup_tmpdir()``.  Alternatively, you can manually\nremove the whole ``__pycache__`` directory.\n\nAn alternative cache directory can be given as the ``tmpdir`` argument\nto ``verify()``, via the environment variable ``CFFI_TMPDIR``, or by\ncalling ``cffi.verifier.set_tmpdir(path)`` prior to calling\n``verify``.\n\n\nUpgrading from CFFI 0.9 to CFFI 1.0\n-----------------------------------\n\nCFFI 1.0 is backward-compatible, but it is still a good idea to\nconsider moving to the out-of-line approach new in 1.0.  Here are the\nsteps.\n\n**ABI mode** if your CFFI project uses ``ffi.dlopen()``:\n\n.. code-block:: python\n\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"stuff\")\n    lib = ffi.dlopen(\"libpath\")\n\nand *if* the \"stuff\" part is big enough that import time is a concern,\nthen rewrite it as described in `the out-of-line but still ABI mode`__\nabove.  Optionally, see also the `setuptools integration`__ paragraph.\n\n.. __: out-of-line-abi_\n.. __: distutils-setuptools_\n\n\n**API mode** if your CFFI project uses ``ffi.verify()``:\n\n.. code-block:: python\n\n    import cffi\n\n    ffi = cffi.FFI()\n    ffi.cdef(\"stuff\")\n    lib = ffi.verify(\"real C code\")\n\nthen you should really rewrite it as described in `the out-of-line,\nAPI mode`__ above.  It avoids a number of issues that have caused\n``ffi.verify()`` to grow a number of extra arguments over time.  Then\nsee the `distutils or setuptools`__ paragraph.  Also, remember to\nremove the ``ext_package=\"..\"`` from your ``setup.py``, which was\nsometimes needed with ``verify()`` but is just creating confusion with\n``set_source()``.\n\n.. __: out-of-line-api_\n.. __: distutils-setuptools_\n\nThe following example should work both with old (pre-1.0) and new\nversions of CFFI---supporting both is important to run on old\nversions of PyPy (CFFI 1.0 does not work in PyPy < 2.6):\n\n.. code-block:: python\n\n    # in a separate file \"package/foo_build.py\"\n    import cffi\n\n    ffi = cffi.FFI()\n    C_HEADER_SRC = r'''\n        #include \"somelib.h\"\n    '''\n    C_KEYWORDS = dict(libraries=['somelib'])\n\n    if hasattr(ffi, 'set_source'):\n        ffi.set_source(\"package._foo\", C_HEADER_SRC, **C_KEYWORDS)\n\n    ffi.cdef('''\n        int foo(int);\n    ''')\n\n    if __name__ == \"__main__\":\n        ffi.compile()\n\nAnd in the main program:\n\n.. code-block:: python\n\n    try:\n        from package._foo import ffi, lib\n    except ImportError:\n        from package.foo_build import ffi, C_HEADER_SRC, C_KEYWORDS\n        lib = ffi.verify(C_HEADER_SRC, **C_KEYWORDS)\n\n(FWIW, this latest trick can be used more generally to allow the\nimport to \"work\" even if the ``_foo`` module was not generated.)\n\nWriting a ``setup.py`` script that works both with CFFI 0.9 and 1.0\nrequires explicitly checking the version of CFFI that we can have---it\nis hard-coded as a built-in module in PyPy:\n\n.. code-block:: python\n\n    if '_cffi_backend' in sys.builtin_module_names:   # PyPy\n        import _cffi_backend\n        requires_cffi = \"cffi==\" + _cffi_backend.__version__\n    else:\n        requires_cffi = \"cffi>=1.0.0\"\n\nThen we use the ``requires_cffi`` variable to give different arguments to\n``setup()`` as needed, e.g.:\n\n.. code-block:: python\n\n    if requires_cffi.startswith(\"cffi==0.\"):\n        # backward compatibility: we have \"cffi==0.*\"\n        from package.foo_build import ffi\n        extra_args = dict(\n            ext_modules=[ffi.verifier.get_extension()],\n            ext_package=\"...\",    # if needed\n        )\n    else:\n        extra_args = dict(\n            setup_requires=[requires_cffi],\n            cffi_modules=['package/foo_build.py:ffi'],\n        )\n    setup(\n        name=...,\n        ...,\n        install_requires=[requires_cffi],\n        **extra_args\n    )\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-py-cffi-1.14.3-4vai5rywo6vzaxjed5i5qykx4dlzfd5g/spack-src/c/libffi_msvc/win64.obj"
    ],
    "total_files": 185
}