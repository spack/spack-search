{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/src/scripts/configure.ac": "# Numerical representation of Charm++ release line and API revision\n# Essentially just the version number stripped of decimal points with minor\n#   fields padded to 2 digits each. (e.g. 6.10.1 -> 61001)\n# Ensure that this number is always numerically and lexicographically increasing.\n#\n# Increment the last 2 digits when making a bugfix release\n# Increment the second and third digits when making a minor feature release\n# Increment the first digit when making a major feature release\n\nAC_INIT([Charm++], [61002], [charm@cs.illinois.edu], [charm], [https://charm.cs.illinois.edu/])\n\nAC_CONFIG_SRCDIR(./Makefile)\n\nAC_CONFIG_HEADER(conv-autoconfig.h)\n\nAC_CONFIG_COMMANDS([config-cleanup],\n                   [sed -i -e 's:^#define\\s\\+PACKAGE://&:' conv-autoconfig.h])\n\nget_full_command_name()\n{\n    if test \"$(basename \"$*\")\" != \"$*\"; then\n        echo \"$(cd \"$(dirname \"$*\")\" && pwd)/$(basename \"$*\")\"\n    else\n        echo \"$*\"\n    fi\n}\n\nConvSh='../tmp/conv-mach-opt.sh'\nConvMak='../tmp/conv-mach-opt.mak'\n\n#clean up conv-mach-opt.sh\nsed -e '/Option added by configure/d' \"$ConvSh\" | sed -e '/^$/d' > conv-mach-opt.sh.clean\ncp -f conv-mach-opt.sh.clean   \"$ConvSh\"\nrm -f conv-mach-opt.sh.clean\n\n#clean up conv-mach-opt.mak\nsed -e '/Option added by configure/d' \"$ConvMak\" | sed -e '/^$/d' > conv-mach-opt.mak.clean\ncp -f conv-mach-opt.mak.clean   \"$ConvMak\"\nrm -f conv-mach-opt.mak.clean\n\nCHARMINC=\".\"\nCHARMBIN=\"../bin\"\ntest -r ./conv-config.sh && . ./conv-config.sh\n\nCHARM_VERSION=AC_PACKAGE_VERSION\nCHARM_VERSION_MAJOR=`echo $CHARM_VERSION | cut -c1`\nCHARM_VERSION_MINOR=`echo $CHARM_VERSION | cut -c2-3`\nCHARM_VERSION_PATCH=`echo $CHARM_VERSION | cut -c4-5`\n\nif test \"$CHARM_VERSION_PATCH\" -lt 10 ; then\n  CHARM_VERSION_PATCH=${CHARM_VERSION_PATCH#0} # remove leading '0'\nfi\n\necho \"#define CHARM_VERSION $CHARM_VERSION\" > ../include/charm-version.h\necho \"#define CHARM_VERSION_MAJOR $CHARM_VERSION_MAJOR\" >> ../include/charm-version.h\necho \"#define CHARM_VERSION_MINOR $CHARM_VERSION_MINOR\" >> ../include/charm-version.h\necho \"#define CHARM_VERSION_PATCH $CHARM_VERSION_PATCH\" >> ../include/charm-version.h\n\ncharmout=\"charmconfig.out\"\n/bin/rm -rf $charmout\nMAKEFILE_EXT=Make.extlib\n\nEcho() {\n\techo $* \n\techo $* >> $charmout\n}\n\n# add into conv-mach-opt.sh\n# add_flag $1 $2\n# $2 is description\nadd_flag() {\n        key=$1\n        key=\"${key%%=*}\"\n        last=`grep -w \"$key\" \"$ConvSh\" 2>/dev/null | tail -1 | sed -e 's/ *#.*$//'`\n        skip=0\n\tif test -n \"$last\" -a  \"$last\" = \"$1\" \n\tthen\n\t  skip=1\n        fi\n\tif test $skip = 0\n        then\n\t  cat >> \"$ConvSh\" << EOT\n\n$1   # Option added by configure script's $2 section\nEOT\n\tfi\n}\n\n# remove_flag $1\nremove_flag() {\n     sed -e '/^'\"$1\"'=/d' \"$ConvSh\" > tmp.$$\n     cp tmp.$$ \"$ConvSh\"\n     /bin/rm -f tmp.$$\n}\n\n# add into conv-mach-opt.mak\n# add_make_flag $1 $2\n# $2 is description\nadd_make_flag() {\n        key=$1\n        key=\"${key%%=*}\"\n        key=\"${key%%:*}\"\n        last=`grep -w \"$key\" \"$ConvMak\" 2>/dev/null | tail -1 | sed -e 's/ *#.*$//'`\n        skip=0\n\tif test -n \"$last\" -a  \"$last\" = \"$1\"\n\tthen\n\t  skip=1\n        fi\n\tif test $skip = 0\n        then\n\t  # The lack of whitespace around $1 here is necessary.\n\t  cat >> \"$ConvMak\" << EOT\n\n$1# Option added by configure script's $2 section\nEOT\n\tfi\n}\n\n# remove_make_flag $1\nremove_make_flag() {\n     sed -e '/^'\"$1\"'=/d' \"$ConvMak\" > tmp.$$\n     cp tmp.$$ \"$ConvMak\"\n     /bin/rm -f tmp.$$\n}\n\nadd_flag \"OPTS_CC='$OPTS_CC'\"   'Pass through user-provided C compiler options'\nadd_flag \"OPTS_CXX='$OPTS_CXX'\" 'Pass through user-provided C++ compiler options'\nadd_flag \"CMK_MACOSX='$CMK_MACOSX'\" 'basic setup'\nadd_flag \"CMK_WINDOWS='$CMK_WINDOWS'\" 'basic setup'\nadd_flag \"CMK_BLUEGENEQ='$CMK_BLUEGENEQ'\" 'basic setup'\nadd_flag \"CMK_POST_EXE='$CMK_POST_EXE'\" 'basic setup'\nadd_flag \"CMK_SHARED_SUF='$CMK_SHARED_SUF'\" 'basic setup'\nadd_flag \"CMK_USER_SUFFIX='$CMK_USER_SUFFIX'\" 'basic setup'\nadd_make_flag \"CMK_COMPILER:=$CMK_COMPILER\" 'basic setup'\nadd_make_flag \"CMK_SMP:=$CMK_SMP\" 'basic setup'\nadd_make_flag \"CMK_SHARED_SUF:=$CMK_SHARED_SUF\" 'basic setup'\nadd_make_flag \"CMK_USER_SUFFIX:=$CMK_USER_SUFFIX\" 'basic setup'\nadd_make_flag \"CMK_NO_PARTITIONS:=$CMK_NO_PARTITIONS\" 'basic setup'\nadd_make_flag \"CMK_MACOSX:=$CMK_MACOSX\" 'basic setup'\nadd_make_flag \"CMK_WINDOWS:=$CMK_WINDOWS\" 'basic setup'\nadd_make_flag \"CMK_BLUEGENEQ:=$CMK_BLUEGENEQ\" 'basic setup'\nadd_make_flag \"CMK_MULTICORE:=$CMK_MULTICORE\" 'basic setup'\nadd_make_flag \"CMK_USE_LRTS:=$CMK_USE_LRTS\" 'basic setup'\nadd_make_flag \"BUILD_CUDA:=$BUILD_CUDA\" 'basic setup'\nAC_DEFINE_UNQUOTED(CMK_POST_EXE, $CMK_POST_EXE, [basic setup])\nAC_DEFINE_UNQUOTED(CMK_SHARED_SUF, $CMK_SHARED_SUF, [basic setup])\nAC_DEFINE_UNQUOTED(CMK_USER_SUFFIX, $CMK_USER_SUFFIX, [basic setup])\n\n# enable/disable error checking\nAC_ARG_ENABLE([error-checking],\n            [AS_HELP_STRING([--enable-error-checking],\n              [enable error checking])], ,\n            [enable_error_checking=yes])\n\nif test \"$enable_error_checking\" = \"no\"\nthen\n  Echo \"Charm++/LIBS error checking is disabled\" \n  AC_DEFINE_UNQUOTED(CMK_ERROR_CHECKING, 0, [disable error checking])\n  add_flag 'OPTS_CC=\"$OPTS_CC -U_FORTIFY_SOURCE\"' 'error checking'\n  add_flag 'OPTS_CXX=\"$OPTS_CXX -U_FORTIFY_SOURCE\"' 'error checking'\nelse\n  Echo \"Charm++/LIBS error checking is enabled\" \n  AC_DEFINE_UNQUOTED(CMK_ERROR_CHECKING, 1, [enable error checking])\nfi\n\n# enable/disable AMPI error checking\nAC_ARG_ENABLE([ampi-error-checking],\n            [AS_HELP_STRING([--enable-ampi-error-checking],\n              [enable AMPI error checking])], ,\n            [enable_ampi_error_checking=yes])\n\nif test \"$enable_ampi_error_checking\" = \"no\"\nthen\n  Echo \"AMPI error checking is disabled\"\n  AC_DEFINE_UNQUOTED(AMPI_ERROR_CHECKING, 0, [disable ampi error checking])\nelse\n  Echo \"AMPI error checking is enabled\"\n  AC_DEFINE_UNQUOTED(AMPI_ERROR_CHECKING, 1, [enable ampi error checking])\nfi\n\n# enable/disable statistics collection\nAC_ARG_ENABLE([stats],\n            [AS_HELP_STRING([--enable-stats],\n              [enable statistics collection])], ,\n            [enable_stats=yes])\n\nif test \"$enable_stats\" = \"no\"\nthen\n  Echo \"Statistics collection is disabled\" \n  AC_DEFINE_UNQUOTED(CMK_WITH_STATS, 0, [disable statistics collection])\nelse\n  Echo \"Statistics collection is enabled\" \n  AC_DEFINE_UNQUOTED(CMK_WITH_STATS, 1, [enable statistics collection])\nfi\n\n# check enable/disable\nAC_ARG_ENABLE([tracing],\n            [AS_HELP_STRING([--enable-tracing],\n              [enable tracing modules])], ,\n            [enable_tracing=yes])\n\nif test \"$enable_tracing\" = \"no\"\nthen\n  Echo \"Charm tracing is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_TRACE_ENABLED, 0, [disable tracing])\n  add_flag CMK_TRACE_ENABLED=0\n  add_make_flag 'CMK_TRACE_ENABLED:=0' 'tracing'\nelse\n  Echo \"Charm tracing is enabled\"\n  AC_DEFINE_UNQUOTED(CMK_TRACE_ENABLED, 1, [enable tracing])\n  add_flag CMK_TRACE_ENABLED=1\n  add_make_flag 'CMK_TRACE_ENABLED:=1' 'tracing'\nfi\n\nAC_ARG_ENABLE([tracing-commthread],\n            [AS_HELP_STRING([--enable-tracing-commthread],\n              [enable tracing communication thread])], ,\n            [enable_tracing_commthread=no])\n\nif test \"$enable_tracing_commthread\" = \"yes\"\nthen\n  Echo \"Charm tracing communication thread is enabled\"\n  AC_DEFINE_UNQUOTED(CMK_SMP_TRACE_COMMTHREAD, 1, [enable tracing comm thread])\nelse\n  Echo \"Charm tracing communication thread is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_SMP_TRACE_COMMTHREAD, 0, [disable tracing comm thread])\nfi\n\n\n# enable task queue\nAC_ARG_ENABLE([task_queue],\n            [AS_HELP_STRING([--enable-task-queue],\n              [enable task queue])],\n            [enable_task_queue=$enableval],\n            [enable_task_queue=no])\n\nif test \"$enable_task_queue\" = \"no\"\nthen\n  Echo \"Task Queue is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_TASKQUEUE, 0, [disable task queue])\nelse\n  Echo \"Task Queue is enabled\"\n  AC_DEFINE_UNQUOTED(CMK_TASKQUEUE, 1, [enable task queue])\nfi\n\n# enable drone mode\nAC_ARG_ENABLE([drone_mode],\n            [AS_HELP_STRING([--enable-drone-mode],\n              [enable drone mode])],\n            [enable_drone_mode=$enableval],\n            [enable_drone_mode=no])\n\nif test \"$enable_drone_mode\" = \"no\"\nthen\n  Echo \"Drone mode is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_DRONE_MODE, 0, [disable drone mode])\nelse\n  Echo \"Drone mode is enabled\"\n  AC_DEFINE_UNQUOTED(CMK_DRONE_MODE, 1, [enable drone mode])\nfi\n\nAC_ARG_ENABLE([charmdebug],\n            [AS_HELP_STRING([--enable-charmdebug],\n              [enable charmDebug])], ,\n            [enable_charmdebug=yes])\n\nif test \"$enable_charmdebug\" = \"no\" -o \"$CMK_CCS_AVAILABLE\" = '0'\nthen\n  Echo \"CharmDebug is disabled\" \n  AC_DEFINE_UNQUOTED(CMK_CHARMDEBUG, 0, [disable charmdebug])\n  add_flag CMK_CHARMDEBUG=0\n  add_make_flag 'CMK_CHARMDEBUG:=0'\nelse\n  Echo \"CharmDebug is enabled\" \n  AC_DEFINE_UNQUOTED(CMK_CHARMDEBUG, 1, [enable charmdebug])\n  add_flag CMK_CHARMDEBUG=1\n  add_make_flag 'CMK_CHARMDEBUG:=1'\nfi\n\nAC_ARG_ENABLE([replay],\n            [AS_HELP_STRING([--enable-replay],\n              [enable record/replay])],\n            [enable_replay=$enableval],\n            [enable_replay=yes])\n\nif test \"$enable_replay\" = \"no\"\nthen\n  Echo \"Charm record/replay is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_REPLAYSYSTEM, 0, [disable replay])\nelse\n  if test \"$enable_tracing\" = \"no\"\n  then\n    Echo \"Charm record/replay is disabled because tracing is disabled\"\n    AC_DEFINE_UNQUOTED(CMK_REPLAYSYSTEM, 0, [disable replay])\n  else\n    Echo \"Charm record/replay is enabled\"\n    AC_DEFINE_UNQUOTED(CMK_REPLAYSYSTEM, 1, [enable replay])\n  fi\nfi\n\nAC_ARG_ENABLE([ccs],\n            [AS_HELP_STRING([--enable-ccs],\n              [enable CCS])], ,\n            [enable_ccs=yes])\n\nif test \"$enable_ccs\" = \"no\" -o \"$CMK_CCS_AVAILABLE\" = '0'\nthen\n  Echo \"CCS is disabled\" \n  AC_DEFINE_UNQUOTED(CMK_CCS_AVAILABLE, 0, [disable ccs])\nelse\n  Echo \"CCS is enabled\" \n  AC_DEFINE_UNQUOTED(CMK_CCS_AVAILABLE, 1, [enable ccs])\nfi\n\nAC_ARG_ENABLE([controlpoint],\n            [AS_HELP_STRING([--enable-controlpoint],\n              [enable control point])],\n            [enable_controlpoint=$enableval],\n            [enable_controlpoint=yes])\n\nif test \"$enable_controlpoint\" = \"yes\"\nthen\n  Echo \"Charm control point is enabled\"\n  AC_DEFINE_UNQUOTED(CMK_WITH_CONTROLPOINT, 1, [enable controlpoint])\nelse\n  Echo \"Charm control point is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_WITH_CONTROLPOINT, 0, [disable controlpoint])\nfi\n\nAC_ARG_ENABLE([lbuserdata],\n            [AS_HELP_STRING([--enable-lbuserdata],\n              [enable LB user data])],\n            [enable_lbuserdata=$enableval],\n            [enable_lbuserdata=no])\n\nif test \"$enable_lbuserdata\" = \"yes\"\nthen\n  Echo \"Charm LB user data is enabled\"\n  AC_DEFINE_UNQUOTED(CMK_LB_USER_DATA, 1, [enable lb user data])\nelse\n  Echo \"Charm LB user data  is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_LB_USER_DATA, 0, [disable lb user data])\nfi\n\nAC_ARG_ENABLE([lockless-queue],\n            [AS_HELP_STRING([--enable-lockless-queue],\n              [enable lockless queue for PE local and node queue])],\n            [enable_lockless_queue=$enableval],\n            [enable_lockless_queue=no])\n\nif test \"$enable_lockless_queue\" = \"no\"\nthen\n  Echo \"Lockless queue for PE local and node queue is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_LOCKLESS_QUEUE, 0, [disable lockless queue for pe/node queue])\nelse\n  Echo \"Lockless queue for PE local and node queue is enabled\"\n  AC_DEFINE_UNQUOTED(CMK_LOCKLESS_QUEUE, 1, [enable lockless queue for pe/node queue])\nfi\n\n\nAC_ARG_ENABLE([shrinkexpand],\n            [AS_HELP_STRING([--enable-shrinkexpand],\n              [enable malleable jobs / shrink expand])],\n            [enable_shrinkexpand=$enableval],\n            [enable_shrinkexpand=no])\n\nif test \"$enable_shrinkexpand\" = \"yes\"\nthen\n  if test \"$enable_ccs\" = \"no\"\n  then\n    Echo \"CCS cannot be disabled when enabling shrink-expand\"\n    test_finish 1\n  else\n    Echo \"Charm shrink expand is enabled - Controlpoint is disabled.\"\n    AC_DEFINE_UNQUOTED(CMK_SHRINK_EXPAND, 1, [enable shrinkexpand])\n    AC_DEFINE_UNQUOTED(CMK_WITH_CONTROLPOINT, 0, [disable controlpoint])\n  fi\nelse\n  Echo \"Charm shrink expand is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_SHRINK_EXPAND, 0, [disable shrinkexpand])\nfi\n\nAC_ARG_ENABLE([charm4py],\n            [AS_HELP_STRING([--enable-charm4py],\n              [enable charm4py support])],\n            [enable_charm4py=$enableval],\n            [enable_charm4py=no])\n\nif test \"$enable_charm4py\" = \"yes\"\nthen\n  Echo \"charm4py support is enabled\"\n  AC_DEFINE_UNQUOTED(CMK_CHARM4PY, 1, [enable charm4py])\nelse\n  Echo \"charm4py support is disabled\"\n  AC_DEFINE_UNQUOTED(CMK_CHARM4PY, 0, [disable charm4py])\nfi\n\nAC_ARG_WITH([numa],\n            [AS_HELP_STRING([--with-numa],\n              [support memory affinity with NUMA])],\n            [],\n            [with_numa=no])\n\nWITH_NUMA=no\nif test \"$with_numa\" = \"yes\"\nthen\n  Echo \"Charm NUMA support is builtin\"\n  WITH_NUMA=yes\nfi\n\nAC_ARG_WITH([lbtime-type],\n            [AS_HELP_STRING([--with-lbtime-type=type],\n                            [load balancing timer type])],\n            [], [with_lbtime_type=double])\n\nif test \"$with_lbtime_type\" = \"float\" -o \"$with_lbtime_type\" = \"double\"\nthen\n  Echo \"Setting load balancing timer type as '$with_lbtime_type'\"\n  AC_DEFINE_UNQUOTED(CMK_LBTIME_TYPE, $with_lbtime_type, [Setting load balancing timer type])\nelse\n  Echo \"Invalid type specified for load balancing timer type\"\n  test_finish 1\nfi\n\nAC_DEFINE_UNQUOTED(CMK_LBID_64BIT, 1, [enable 64 bit LB ID])\n\nAC_DEFINE_UNQUOTED(CMK_CKSECTIONINFO_STL, 1, [enable STL CkSectionInfo])\n\nAC_ARG_WITH([qlogic],\n            [AS_HELP_STRING([--with-qlogic],\n              [QLogic based Infiniband])],[with_qlogic=yes],\n            [with_qlogic=no])\n\nif test \"$with_qlogic\" = \"no\"\nthen\n  AC_DEFINE_UNQUOTED(QLOGIC, 0, [disable qlogic])\nelse\n  Echo \"QLogic based Infiniband\"\n  AC_DEFINE_UNQUOTED(QLOGIC, 1, [enable qlogic])\nfi\n\n#\nAC_MSG_CHECKING(machine name)\nversion=`pwd | awk -F/ '{print $(NF-1)}'`\nbase_version=\"$CMK_VDIR\"\nAC_DEFINE_UNQUOTED(CMK_MACHINE_NAME, \"$version\",[machine name])\nAC_MSG_RESULT($version)\nAC_SUBST(base_version)\n\nt=\"test.cpp\"\ntc=\"test.c\"\n\n# test result passed in $1\n# If the test suceeded, print $3 and set \"pass\"/clear \"fail\"\n# If the test failed, print $2 and clear \"pass\"/set \"fail\"\ntest_result() {\n\tif test $1 -eq 0\n\tthen\n                AC_MSG_RESULT(\"$3\")\n\t\tpass=\"1\"\n\t\tfail=\"0\"\n\telse\n                AC_MSG_RESULT(\"$4\")\n\t\tpass=\"0\"\n\t\tfail=\"1\"\n# For debugging the configure script, just \"export autoconf_debug=1\"\n#  to get this verbose data on any failed tests:\n\t\tif test ! -z \"$autoconf_debug\"\n\t\tthen\n\t\t\techo \"------- test script for $2 failed:\"\n\t\t\tcat out\n\t\t\techo \"------- the test program was:\"\n\t\t\tcat $t\n\t\t\techo \"-------\"\n\t\tfi\n\tfi\n}\n\n# Test: tries to compile C file $t (described by $1).\n#  If successful, prints $2 and sets $pass/clears $fail\n#  If failure, prints $3 and sets $pass/clears $fail\n#  additional arguments to c++ compiler are passed as $4\ntest_cc() {\n        AC_MSG_CHECKING(\"$1\")\n\techo \"### $1\" >> $charmout\n\tcat $tc >> $charmout\n\techo $CMK_CC $CMK_CC_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CC -c $tc -o test.o $4 >> $charmout\n\t$CMK_CC $CMK_CC_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CC -c $tc -o test.o $4 > out 2>&1\n\ttest_result $? \"$1\" \"$2\" \"$3\"\n \tstrictpass=$pass\n\tstrictfail=$fail\n        if test $pass -eq 1\n\tthen \n          if grep -i \"warn\" out > /dev/null 2>&1 || grep -i \"(W)\" out > /dev/null 2>&1\n\t  then \n\t    strictpass=\"0\" && strictfail=\"1\"\n          fi\n        fi\n\tcat out >> $charmout\n\t/bin/rm -f out\n}\n\n# Test: tries to compile C++ file $t (described by $1).\n#  If successful, prints $2 and sets $pass/clears $fail\n#  If failure, prints $3 and sets $pass/clears $fail\n#  additional arguments to c++ compiler are passed as $4\ntest_cxx() {\n        AC_MSG_CHECKING(\"$1\")\n\techo \"### $1\" >> $charmout\n\tcat $t >> $charmout\n\techo $CMK_CXX $CMK_CXX_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX -c $t -o test.o $4 >> $charmout\n\t$CMK_CXX $CMK_CXX_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX -c $t -o test.o $4 > out 2>&1\n\ttest_result $? \"$1\" \"$2\" \"$3\"\n \tstrictpass=$pass\n\tstrictfail=$fail\n        if test $pass -eq 1\n\tthen \n          if grep -i \"warn\" out > /dev/null 2>&1 || grep -i \"(W)\" out > /dev/null 2>&1\n\t  then \n\t    strictpass=\"0\" && strictfail=\"1\"\n          fi\n        fi\n\tcat out >> $charmout\n\t/bin/rm -f out\n}\n\n# Test: tries to compile C++ file $t (described by $1) using native compiler.\n#  If successful, prints $2 and sets $pass/clears $fail\n#  If failure, prints $3 and sets $pass/clears $fail\n#  additional arguments to c++ compiler are passed as $4\ntest_native_cxx() {\n        AC_MSG_CHECKING(\"$1\")\n\techo \"### $1\" >> $charmout\n\tcat $t >> $charmout\n\techo $CMK_NATIVE_CXX $CMK_NATIVE_CXX_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX -c $t -o test.o $4 >> $charmout\n\t$CMK_NATIVE_CXX $CMK_NATIVE_CXX_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX -c $t -o test.o $4 > out 2>&1\n\ttest_result $? \"$1\" \"$2\" \"$3\"\n\tstrictpass=$pass\n\tstrictfail=$fail\n        if test $pass -eq 1\n\tthen\n          if grep -i \"warn\" out > /dev/null 2>&1 || grep -i \"(W)\" out > /dev/null 2>&1\n\t  then\n\t    strictpass=\"0\" && strictfail=\"1\"\n          fi\n        fi\n\tcat out >> $charmout\n\t/bin/rm -f out\n}\n\n# Testlink: tries to compile and link a C++ file $t (described by $1).\n#  If successful, prints $2 and sets $pass/clears $fail\n#  If failure, prints $3 and sets $pass/clears $fail\n#  additional arguments to c++ compiler are passed as $4\ntest_link() {\n        AC_MSG_CHECKING(\"$1\")\n\techo \"### $1\" >> $charmout\n\tcat $t >> $charmout\n\techo $CMK_CXX $CMK_CXX_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX -c $t -o test.o $4 >> $charmout\n\t$CMK_CXX $CMK_CXX_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX -c $t -o test.o $4 > out 2>&1\n        if test $? -ne 0\n        then\n          test_result 1 \"$1\" \"$2\" \"$3\"\n        else\n          echo $CMK_LDXX $CMK_LDXX_FLAGS $CMK_LINK_BINARY -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 $5 >> $charmout\n          $CMK_LDXX $CMK_LDXX_FLAGS $CMK_LINK_BINARY -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 $5 >> out 2>&1\n          ret=$?\n\t  test ! -x testlink && ret=1\n          test_result $ret \"$1\" \"$2\" \"$3\"\n        fi\n \tstrictpass=$pass\n\tstrictfail=$fail\n        if test $pass -eq 1\n\tthen \n \t  if cat out | grep -i \"warn\" > /dev/null 2>&1\n\t  then \n\t    strictpass=\"0\" && strictfail=\"1\"\n          fi\n        fi\n\tcat out >> $charmout\n\t/bin/rm -f out\n}\n\n# Testlinkc: tries to compile and link a C file $t (described by $1).\n#  If successful, prints $2 and sets $pass/clears $fail\n#  If failure, prints $3 and sets $pass/clears $fail\n#  additional arguments to c++ compiler are passed as $4\ntest_linkc() {\n        AC_MSG_CHECKING(\"$1\")\n\techo \"### $1\" >> $charmout\n\tcat $tc >> $charmout\n\techo $CMK_CC $CMK_CC_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CC -c $tc -o test.o $4 >> $charmout\n\t$CMK_CC $CMK_CC_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CC -c $tc -o test.o $4 > out 2>&1\n        if test $? -ne 0\n        then\n          test_result 1 \"$1\" \"$2\" \"$3\"\n        else\n          echo $CMK_LD $CMK_LD_FLAGS $CMK_LINK_BINARY -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> $charmout\n          $CMK_LD $CMK_LD_FLAGS $CMK_LINK_BINARY -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> out 2>&1\n          test_result $? \"$1\" \"$2\" \"$3\"\n        fi\n \tstrictpass=$pass\n\tstrictfail=$fail\n        if test $pass -eq 1\n\tthen \n \t  if cat out | grep -i \"warn\" > /dev/null 2>&1\n\t  then \n\t    strictpass=\"0\" && strictfail=\"1\"\n          fi\n        fi\n\tcat out >> $charmout\n\t/bin/rm -f out\n}\n\n# test_linkso $1 $2 $3 $4, where\n# $1: debug msg\n# $2: yes msg\n# $3: no msg\n# $4: extra link option\ntest_linkso() {\n        AC_MSG_CHECKING(\"$1\")\n\techo $1 >> $charmout\n\tcat $t >> $charmout\n\techo $CMK_CXX $CMK_CXX_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX $CMK_PIC -c $t -o test.o $4 >> $charmout\n\t$CMK_CXX $CMK_CXX_FLAGS -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX -c $CMK_PIC $t -o test.o $4 > out 2>&1\n        if test $? = 1\n        then\n          test_result 1 \"$1\" \"$2\" \"$3\"\n        else\n\t  echo $CMK_LD $CMK_LD_FLAGS $CMK_LIBDIR $OPTS_LD $CMK_LD_SHARED $CMK_SYSLIBS test.o -o testlink.$CMK_SHARED_SUF $4 >> $charmout\n\t  $CMK_LD $CMK_LD_FLAGS $CMK_LIBDIR $OPTS_LD $CMK_LD_SHARED $CMK_SYSLIBS test.o -o testlink.$CMK_SHARED_SUF $4 > out 2>&1\n\t  test_result $? \"$1\" \"$2\" \"$3\"\n\tfi\n\tcat out >> $charmout\n\t/bin/rm -f out testlink.$CMK_SHARED_SUF\n}\n\ntest_finish() {\n\trm -f $t $tc testlink test.o\t> /dev/null 2>&1\n\t/bin/rm -f out\n\ttest $1 -eq 1 && echo \"*** Please find detailed output in tmp/charmconfig.out ***\"\n\texit $1\n}\n\n# detect certain architectures\nif cat /proc/cpuinfo 2>/dev/null | grep 'POWER7'  > /dev/null\nthen\n  AC_DEFINE_UNQUOTED(CMK_POWER7, 1, [whether is power7])\nfi\n\n# detect OS\nOSNAME=`uname -s`\nif test $OSNAME = \"Linux\"\nthen\n  AC_DEFINE_UNQUOTED(CMK_OS_IS_LINUX, 1, [OS is Linux])\nelse\n  AC_DEFINE_UNQUOTED(CMK_OS_IS_LINUX, 0, [OS is Linux])\nfi\n\n# test cp -p\nAC_MSG_CHECKING(\"cp command as\")\nCP=\"cp -p\"\ntouch test_file\nif ! $CP test_file test_file.cp 2>err\nthen\n  CP=\"cp\"\nfi\nrm -f test_file test_file.cp\nAC_MSG_RESULT($CP)\nadd_flag CP=\\\"\"$CP\"\\\" \"cp command\"\n \n\ncat > $t <<EOT\n#include <stdio.h>\nvoid foo(void) {\n\tprintf(\"Hello, world!\\n\");\n}\nEOT\n\nif test \"$CMK_BUILD_CRAY\" = \"1\"\nthen\n#echo \"Test for known incompatible compiler versions\"\n\n if test \"$CRAY_CC_VERSION\" = \"8.1.4\"\n then\n\techo \"CCE 8.1.4 produces incorrect Charm++ code\"\n\techo \"Please use a newer version of the CCE compiler\"\n\techo \"e.g. module load cce/8.1.7\"\n\ttest_finish 1\n fi\nfi\n\n#echo \"set C++ compiler as: $CMK_CXX $OPTS_CXX $OPTS\"\nAC_MSG_CHECKING(\"C++ compiler as\")\nAC_MSG_RESULT(\"$CMK_CXX $OPTS_CXX\")\ntest_cxx \"whether C++ compiler works\" \"ok\" \"no\" \"\"\nif test $fail -eq 1\nthen\n\techo \"Cannot compile C++ programs with $CMK_CXX\"\n\techo \" (check your charm++ version)\"\n\ttest_finish 1\nfi\n\ncat > $t <<EOT\n#include <stdio.h>\nint main() {\n\tprintf(\"Hello, world!\\n\");\n\treturn 0;\n}\nEOT\n#echo \"set C++ linker as: $CMK_LDXX $OPTS_LD\"\nAC_MSG_CHECKING(\"C++ linker as\")\nAC_MSG_RESULT(\"$CMK_LDXX $OPTS_LD\")\ntest_link \"whether linker works\" \"ok\" \"no\" \"\"\nif test $fail -eq 1\nthen\n\techo \"Cannot link C++ programs with $CMK_LDXX\"\n\techo \" (check your charm++ version)\"\n\ttest_finish 1\nfi\n\nAC_MSG_CHECKING(\"Native C++ compiler as\")\nAC_MSG_RESULT(\"$CMK_NATIVE_CXX\")\nAC_MSG_CHECKING(\"Sequential C++ compiler as\")\nAC_MSG_RESULT(\"$CMK_SEQ_CXX\")\n\n# Needed to avoid migratable threads failing the stack check\n# See https://github.com/UIUC-PPL/charm/pull/3174 for details.\ntest_link \"whether compiler accepts -fno-stack-protector\" \"ok\" \"no\" \"-fno-stack-protector\"\nif test $strictpass -eq 1\nthen\n  add_flag OPTS_CC='\"$OPTS_CC -fno-stack-protector\"' \"stack-protection disabling\"\n  add_flag OPTS_CXX='\"$OPTS_CXX -fno-stack-protector\"' \"stack-protection disabling\"\nfi\n\n#### check if C++ compiler will accept C++11 features without warning ####\ncat > $t <<EOT\n// Check for Intel compiler incompatibility with the active g++/libstdc++ by\n// including an arbitrary standard library header (cf bug #1560)\n#include <map>\n\n// Check for an excessively old g++/libstdc++ that can't handle features we use\n#include <memory>\n#include <vector>\nstd::unique_ptr<int> i;\n\nclass CkMigrateMessage;\n\nstruct base {\n  base(void) { }\n  base(CkMigrateMessage *) { }\n};\n\ntemplate <class Parent>\nstruct CBaseT1 : Parent {\n  std::vector<int> v; // check for C++11's shrink_to_fit()\n\n  CBaseT1(void) :Parent()  { v.shrink_to_fit(); }\n  CBaseT1(CkMigrateMessage *m) :Parent(m) { }\n  CBaseT1(CBaseT1&& rhs) :Parent() { }\n\n  template <typename... Args>\n    CBaseT1(Args... args) : Parent(args...) { }\n};\n\ntemplate struct CBaseT1<base>;\nEOT\ngot_cpp11=\"\"\ntest_cxx \"whether C++ compiler supports C++11 without flags\" \"yes\" \"no\" \"\"\nif test $strictpass -eq 1\nthen\n  got_cpp11=\"true\"\nelse\n# Flags for g++/clang++/icpc/xlC++, pgCC, and CrayCC respectively\nfor i in \"-std=c++11\" \"--c++11\" \"-h std=c++11\" \"-hstd=c++11\"; do\n    test_cxx \"whether C++ compiler supports C++11 with '$i'\" \"yes\" \"no\" \"$i\"\n    if test $strictpass -eq 1\n    then\n      add_flag \"$(echo OPTS_CXX=\\\"\\$OPTS_CXX $i\\\")\" \"Enable C++11 support\"\n      OPTS_CXX=\"$OPTS_CXX $i\"\n      got_cpp11=\"true\"\n      break\n    fi\ndone\nfi\n\nif test -z $got_cpp11\nthen\n  echo \"Charm++ requires C++11 support, but doesn't know the flag to enable it\"\n  echo\n  echo \"For Intel's compiler please see\"\n  echo \"https://github.com/UIUC-PPL/charm/issues/1560\"\n  echo \"about making a suitable version of gcc/g++/libstdc++ available\"\n  echo\n  echo \"For Blue Gene/Q please use the Clang compiler\"\n  test_finish 1\nfi\n\ntest_native_cxx \"whether native C++ compiler supports C++11 without flags\" \"yes\" \"no\" \"\"\nif test $strictpass -ne 1\nthen\n  # Flags for g++/clang++/icpc/xlC++, pgCC, and CrayCC respectively\n  for i in \"-std=c++11\" \"--c++11\" \"-h std=c++11\" \"-hstd=c++11\"; do\n    test_native_cxx \"whether C++ compiler supports C++11 with '$i'\" \"yes\" \"no\" \"$i\"\n    if test $strictpass -eq 1\n    then\n      add_flag \"$(echo CMK_NATIVE_CXX_FLAGS=\\\"\\$CMK_NATIVE_CXX_FLAGS $i\\\")\" \"Enable C++11 support\"\n      break\n    fi\ndone\nfi\n\n# Workaround for bug #1045 appearing in GCC >6.x\ntest_cxx \"whether C++ compiler accepts -fno-lifetime-dse\" \"yes\" \"no\" \"-fno-lifetime-dse\"\nif test $strictpass -eq 1\nthen\n    add_flag \"$(echo OPTS_CXX=\\\"\\$OPTS_CXX -fno-lifetime-dse\\\")\" \"Disable 'Lifetime DSE' optimization to work around bug #1045 in GCC >6.x\"\n    OPTS_CXX=\"$OPTS_CXX -fno-lifetime-dse\"\nfi\n\n# Test for a flag tlsglobals sometimes depends on\ntest_cxx \"whether C++ compiler accepts -mno-tls-direct-seg-refs\" \"yes\" \"no\" \"-mno-tls-direct-seg-refs\"\nif test $strictpass -eq 1\nthen\n    add_flag 'CMK_COMPILER_KNOWS_TLSDIRECTSEGREFS=\"1\"' \"tlsglobals\"\nfi\n\n# Needed so that tlsglobals works correctly with --build-shared\n# See https://github.com/UIUC-PPL/charm/issues/3168 for details.\ntest_cxx \"whether C++ compiler accepts -ftls-model=initial-exec\" \"yes\" \"no\" \"-ftls-model=initial-exec\"\nif test $strictpass -eq 1\nthen\n    add_flag 'CMK_COMPILER_KNOWS_FTLS_MODEL=\"1\"' \"tlsglobals\"\n    OPTS_CC=\"$OPTS_CC -ftls-model=initial-exec\"\n    OPTS_CXX=\"$OPTS_CXX -ftls-model=initial-exec\"\n    OPTS_LD=\"$OPTS_LD -ftls-model=initial-exec\"\nfi\n\n# Test for a flag important for shared linking\ntest_cxx \"whether C++ compiler accepts -fvisibility=hidden\" \"yes\" \"no\" \"-fvisibility=hidden\"\nif test $strictpass -eq 1\nthen\n    add_flag 'CMK_COMPILER_KNOWS_FVISIBILITY=\"1\"' \"-fvisibility=hidden\"\nfi\n\n# Determine compiler/linker flags to build libcharm.so for charm4py\nif test \"$enable_charm4py\" = \"yes\"\nthen\n\n  cat > $t <<EOT\nint main() { return 0; }\nEOT\n\n  test_cxx \"whether C++ compiler accepts --no-as-needed\" \"yes\" \"no\" \"--no-as-needed\"\n  if test $strictpass -eq 1\n  then\n      add_flag \"$(echo CXX_NO_AS_NEEDED=\\\"--no-as-needed\\\")\" \"--no-as-needed flag necessary for compilers that default to linking with --as-needed\"\n  fi\n\n  got_opt_whole_archive=\"\"\n  # Flags for g++/clang++/icpc, Apple-LLVM respectively\n  for i in \"-Wl,--whole-archive -Wl,--no-whole-archive\" \"-Wl,-all_load\"; do\n      test_link \"whether linker supports '$i'\" \"yes\" \"no\" \"\" \"$i\"\n      if test $strictpass -eq 1\n      then\n        got_opt_whole_archive=\"true\"\n        IFS=' ' read LDXX_WHOLE_ARCHIVE_PRE LDXX_WHOLE_ARCHIVE_POST <<EOF\n        $i\nEOF\n        add_flag \"$(echo LDXX_WHOLE_ARCHIVE_PRE=\\\"$LDXX_WHOLE_ARCHIVE_PRE\\\")\" \"Flags to link whole archives into libcharm.so\"\n        add_flag \"$(echo LDXX_WHOLE_ARCHIVE_POST=\\\"$LDXX_WHOLE_ARCHIVE_POST\\\")\" \"Flags to link whole archives into libcharm.so\"\n        break\n      fi\n  done\n\n  if test -z $got_opt_whole_archive\n  then\n    echo \"Don't know how to build libcharm.so for Charm4py\"\n    test_finish 1\n  fi\nfi\n\n# Figure out if the user has asked to enable the latest language standards\nUSER_ASKED_FOR_NEW_STD=`echo \"$BUILDOPTS\" | grep \"\\-use-new-std\" | wc -l`\n\n# If the user has asked for the newer standards, check if the compilers know about them\nif test $USER_ASKED_FOR_NEW_STD -ge 1\nthen\n\n#### check if c compiler supports c11 compilation flags ####\ncat > $tc <<EOT\n#include <stdio.h>\n\nint foo()\n{\n  return 0;\n}\nEOT\ntest_cc \"whether c compiler knows of the c11 standard\" \"ok\" \"no\" \"$CMK_ENABLE_C11\"\nAC_DEFINE_UNQUOTED(CMK_COMPILER_KNOWS_C11, $pass, [whether c compiler knows of the c11 standard] )\nif test $pass -eq 1\nthen\n        # Record results for charmc's future use\n        add_flag 'CMK_COMPILER_KNOWS_C11=\"1\"' \"c11\"\n        # For the rest of configure, append this to compilation flags\n        OPTS_CC=\"$CMK_ENABLE_C11 $OPTS_CC\"\nfi\nfi # endif USER_ASKED_FOR_NEW_STD\n\n# Perform the tests\n\nAC_ARG_WITH([refnum-type],\n            [AS_HELP_STRING([--with-refnum-type=type],\n                            [size of the envelope refnum field])],\n            [], [with_refnum_type=no])\n\nif test \"$with_refnum_type\" = \"no\" -o \"$with_refnum_type\" = \"short\"\nthen\n  Echo \"Setting charm++ envelope refnum field to unsigned short\"\n  AC_DEFINE_UNQUOTED(CMK_REFNUM_TYPE, unsigned short, [envelope refnum field set to UShort])\nelif test \"$with_refnum_type\" = \"int\"\nthen\n  Echo \"Setting charm++ envelope refnum field to unsigned int\"\n  AC_DEFINE_UNQUOTED(CMK_REFNUM_TYPE, unsigned int, [envelope refnum field set to UInt])\nelse\n  Echo \"Invalid size specified for refnum field\"\n  test_finish 1\nfi\n\n\nAC_ARG_WITH([prio-type],\n            [AS_HELP_STRING([--with-prio-type=type],\n                            [size of expected message priorities])],\n            [], [with_prio_type=bitvec])\n\nif test \"$with_prio_type\" = \"char\" -o \"$with_prio_type\" = \"short\" -o \"$with_prio_type\" = \"int\" -o \"$with_prio_type\" = \"long\" -o \"$with_prio_type\" = \"float\" -o \"$with_prio_type\" = \"double\"\nthen\n  Echo \"Configuring support for message priorities of sizeof type $with_prio_type\"\n  AC_DEFINE_UNQUOTED(CMK_USE_STL_MSGQ, 1, [whether charm scheduler should use an STL-based msg q])\n  AC_DEFINE_UNQUOTED(CMK_MSG_PRIO_TYPE, $with_prio_type, [expected message priorities are sizeof $with_prio_type])\nelif test \"$with_prio_type\" = \"bitvec\"\nthen\n  Echo \"Configuring support for message priorities of arbitrary size (bitvectors)\"\n  AC_DEFINE_UNQUOTED(CMK_USE_STL_MSGQ, 0, [whether charm scheduler should use an STL-based msg q])\n  AC_DEFINE_UNQUOTED(CMK_MSG_PRIO_TYPE, $with_prio_type, [expected message priorities are arbitrarily sized])\nelse\n  Echo \"Invalid size ($with_prio_type) specified for message priorities. Can only accept char, short, int, long, float, double and bitvec\"\n  test_finish 1\nfi\n\n# enable/disable randomized scheduler queue\nAC_ARG_ENABLE([randomized-msgq],\n            [AS_HELP_STRING([--enable-randomized-msgq],\n              [enable a randomized msg queue (for debugging etc)])], ,\n            [enable_randomized_msgq=no])\n\nif test \"$enable_randomized_msgq\" = \"yes\" -a \"$with_prio_type\" != \"bitvec\"\nthen\n  Echo \"The charm message queue will be randomized (and will not respect priorities)\"\n  AC_DEFINE_UNQUOTED(CMK_RANDOMIZED_MSGQ, 1, [enable the randomized msgq in the scheduler])\nelse\n  AC_DEFINE_UNQUOTED(CMK_RANDOMIZED_MSGQ, 0, [disable the randomized msgq in the scheduler])\n  if test \"$enable_randomized_msgq\" = \"yes\"\n  then\n    Echo 'A randomized message queue is only available when --with-prio-type != bitvec.'\n    Echo \"Specify prio-type to be a data type long enough to hold the message priorities in your application\"\n    Echo \"for example: --with-prio-type=int (or short / long etc).\"\n    test_finish 1\n  fi\nfi\n\nAC_ARG_WITH([mempool-cutoff],\n            [AS_HELP_STRING([--with-mempool-cutoff=N],\n                            [exponent of the maximum power of two to use for bin sizes in the mempool])],\n            [], [with_mempool_cutoff=26])\n\nif test \"$((6 < $with_mempool_cutoff && $with_mempool_cutoff < 32))\" = '1'\nthen\n  Echo \"Using mempool cutoff... 2^$with_mempool_cutoff\"\n  AC_DEFINE_UNQUOTED(CMK_MEMPOOL_CUTOFFNUM, $((with_mempool_cutoff - 6)), [mempool cutoff])\nelse\n  Echo \"Invalid number ($with_mempool_cutoff) specified for mempool cutoff. Valid range: 7 <= N <= 31\"\n  test_finish 1\nfi\n\n# enable mpich tests\nAC_ARG_ENABLE([ampi-mpich-tests],\n            [AS_HELP_STRING([--enable-ampi-mpich-tests],\n            [enable mpich tests for ampi])],\n            [enable_ampi_mpich_tests=yes],\n            [enable_ampi_mpich_tests=no])\n\nif test \"$enable_ampi_mpich_tests\" = \"yes\"\nthen\n  AC_DEFINE([AMPI_ERRHANDLER_RETURN], [1], [enable ampi fatal error return])\n  add_make_flag \"BUILD_MPICH_TESTS:=true\" 'mpich tests setup'\nelse\n  AC_DEFINE([AMPI_ERRHANDLER_RETURN], [0], [disable ampi fatal error return])\nfi\n\n#### Check if compiler is 64 bit ####\ncat > $t <<EOT\n#include <stdio.h>\n\nint foo()\n{\nint x[[(int)(sizeof(void *) - 7)]]={0};\nreturn x[[0]];\n}\nEOT\ntest_cxx \"whether compiler generates code for 64-bit\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_SIZET_64BIT, $strictpass, [whether size_t 64bit])\nin64bit=$strictpass\n\n### Check if compiler supports std::is_constructible<> ###\ncat > $t <<EOT\n#include <type_traits>\n\nstruct s {\n       s(int a) { }\n};\n\nbool foo()\n{\n  return std::is_constructible<s, int>::value;\n}\nEOT\ntest_cxx \"whether compiler supports std::is_constructible\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_IS_CONSTRUCTIBLE, $strictpass, [whether compiler supports std::is_constructible])\n\n### Check if compiler supports std::alignment_of<> ###\ncat > $t <<EOT\n#include <type_traits>\n\nint foo()\n{\n  return std::alignment_of<int>::value;\n}\nEOT\ntest_cxx \"whether compiler supports std::alignment_of\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_ALIGNMENT_OF, $strictpass, [whether compiler supports std::alignment_of])\n\n### Check if compiler implements regex ###\ncat > $t <<EOT\n#include <regex>\nvoid foo()\n{\n#if __cplusplus >= 201103L &&                             \\\n    (!defined(__GLIBCXX__) || (__cplusplus >= 201402L) || \\\n        (defined(_GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT) || \\\n         defined(_GLIBCXX_REGEX_STATE_LIMIT)           || \\\n             (defined(_GLIBCXX_RELEASE)                && \\\n             _GLIBCXX_RELEASE > 4)))\n// compiler has regex support, continue\n#else\n// force compilation to fail\nstatic_assert(false, \"compiler has no regex implementation\");\n#endif\n}\nEOT\ntest_cxx \"whether compiler implements regex\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_REGEX, $pass, [whether compiler implements regex])\n\n#### test if has values.h ####\ncat > $t <<EOT\n#include <values.h>\nint main() { \n  double d = MAXDOUBLE;\n  return 0;\n}\nEOT\ntest_cxx \"whether has values.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_VALUES_H, $pass, [whether has values.h])\n\n#### test if has stdint.h ####\ncat > $t <<EOT\n#include <stdint.h>\nint main() { \n  return 0;\n}\nEOT\ntest_cxx \"whether has stdint.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_STDINT_H, $pass, [whether has stdint.h])\n\n#### test if has malloc.h ####\ncat > $t <<EOT\n#include <malloc.h>\nint main() { \n  return 0;\n}\nEOT\ntest_cxx \"whether has malloc.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MALLOC_H, $pass, [whether has malloc.h])\n\n#### test if has strings.h ####\ncat > $t <<EOT\n#include <strings.h>\nint main() {\n  return 0;\n}\nEOT\ntest_cxx \"whether has strings.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_STRINGS_H, $pass, [whether has strings.h])\n\n#### test if has alloca.h ####\ncat > $t <<EOT\n#include <alloca.h>\nint main() {\n  double *s=(double *)alloca(sizeof(double));\n  *s=1.0;\n  return 0;\n}\nEOT\ntest_cxx \"whether has alloca.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_ALLOCA_H, $pass, [whether has alloca.h])\n\n#### test if has regex.h ####\ncat > $t <<EOT\n#include <regex.h>\nint main() {\n  regex_t re;\n  regcomp(&re, \".*MOD.*\", REG_EXTENDED|REG_NOSUB);\n  return 0;\n}\nEOT\ntest_cxx \"whether has regex.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_REGEX_H, $pass, [whether has regex.h])\n\n#### Check long long ####\ncat > $t <<EOT\n#include <stdlib.h>\nlong long foo(void) { return 17; }\nEOT\ntest_cxx \"whether long long works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_LONG_LONG_DEFINED, $pass, [whether long long works])\n\n#### Check __int64 ####\ncat > $t <<EOT\n#include <stdlib.h>\n__int64 foo(void) { return 17; }\nEOT\ntest_cxx \"whether __int64 works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK___int64_DEFINED], $pass, [whether __int64 works])\n\n\nCMK_HAS_INT16=0\n\n#### Check __int128 ####\ncat > $t <<EOT\n#include <stdlib.h>\nint foo(void) {\n  __int128   a;\n  int x[[(int)(sizeof(__int128) - 15)]]={0};\n  return x[[0]];\n}\nEOT\ntest_cxx \"whether __int128 (128-bit integer) works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK___int128_DEFINED], $pass, [whether __int128 works])\nif test $pass -eq 1\nthen\n  CMK_HAS_INT16=1\n  add_flag CMK_HAS_INT16=1\nfi\n\n#### Check __int128_t ####\ncat > $t <<EOT\n#include <stdlib.h>\nint foo(void) {\n  __int128_t   a;\n  __uint128_t   b;\n  a = a + a;\n  int x[[(int)(sizeof(__int128_t) - 15)]]={0};\n  return x[[0]];\n}\nEOT\ntest_cxx \"whether __int128_t (128-bit integer) works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK___int128_t_DEFINED], $pass, [whether __int128_t works])\nif test $pass -eq 1\nthen\n  CMK_HAS_INT16=1\n  add_flag CMK_HAS_INT16=1\nfi\n\n#### Summarize *int128* ####\n\nAC_DEFINE_UNQUOTED([CMK_HAS_INT16], $CMK_HAS_INT16, [whether any 128-bit integer works])\n\n\n### Check if we have C++11 <atomic> ###\ncat > $t <<EOT\n#include <atomic>\nint main(int argc, char** argv) { \n  return 0;\n}\nEOT\ntest_cxx \"whether C++ library has <atomic> \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_CXX11_ATOMIC, $pass, [whether C++ library has <atomic>])\n\nif test $pass -ne 1\nthen\n### Check if we have pre-C++11 <cstdatomic> ###\ncat > $t <<EOT\n#include <cstdatomic>\nint main(int argc, char** argv) { \n  return 0;\n}\nEOT\ntest_cxx \"whether C++ library has <cstdatomic> \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_CXX0X_CSTDATOMIC, $pass, [whether C++ library has <cstdatomic>])\nfi\n\nif test $pass -ne 1 -a \"$CMK_COMPILER\" != \"bgxlc\"\nthen\n\techo \"Charm++ requires C++11 atomic support\"\n\ttest_finish 1\nfi\n\n#### Check long double ####\ncat > $t <<EOT\n#include <stdlib.h>\nlong double foo(void) { return 17.0; }\nEOT\ntest_cxx \"whether long double works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_LONG_DOUBLE_DEFINED, $strictpass, [whether long double works])\n\n#### Check ucontext and FPU pointer ####\ncat > $t <<EOT\n#include <ucontext.h>\nstruct _libc_fpstate   fpstate;\nfpregset_t *fp;\nint main() {\n  ucontext_t context;\n  context.uc_mcontext.fpregs = 0;\n}\nEOT\ntest_cxx \"whether ucontext has FPU pointer\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_CONTEXT_FPU_POINTER, $pass, [whether ucontext has pointer])\n\nif test $pass -eq 1\nthen\ncat > $t <<EOT\n#include <ucontext.h>\n\nint main()\n{\n  ucontext_t context;\n  context.uc_mcontext.uc_regs = 0;\n}\nEOT\ntest_cxx \"whether ucontext uses uc_regs\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_CONTEXT_FPU_POINTER_UCREGS, $pass, [whether ucontext uses uc_regs union])\nfi\n\ncat > $t <<EOT\n#include <ucontext.h>\nvrregset_t *v_regs;\nucontext_t  uc;\n\nvoid foo()\n{\n  vrregset_t *ptr = uc.uc_mcontext.v_regs;\n}\nEOT\ntest_cxx \"whether ucontext has pointer (v_regs) of vector type\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_CONTEXT_V_REGS, $pass, [whether ucontext has pointer (v_regs) of vector type])\n\n#### Check ucontext and FPU pointer ####\ncat > $t <<EOT\n#include <infiniband/verbs.h>\nvoid test()\n{\n    struct ibv_context    *context;\n    int ibPort;\n    struct ibv_port_attr attr;\n    if (ibv_query_port(context, ibPort, &attr) != 0) return;\n    if (attr.link_layer == IBV_LINK_LAYER_INFINIBAND)  return;\n}\nEOT\ntest_cxx \"whether ibverbs ibv_port_attr has link_layer field\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_IBV_PORT_ATTR_HAS_LINK_LAYER, $pass, [whether ibv_port_attr has link_layer field])\n\n\n###################### C++ Compiler Features #####################\n\n#### check C inline ####\ncat > $tc <<EOT\ninline static int foo()\n{\n  return 1;\n}\nEOT\ntest_cc \"whether inline works in C\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_C_INLINE, $strictpass, [whether C inline works in C])\n\n#### check if signed char is same as char ####\ncat > $t <<EOT\n#include <stdlib.h>\nclass er {\n protected:\n   void operator()(char &v,const char *desc=NULL) {};\n   void operator()(signed char &v,const char *desc=NULL) {};\n};\nEOT\ntest_cxx \"whether C++ signed char and char differ\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_SIGNEDCHAR_DIFF_CHAR, $pass, [whether C++ signed char and char differ])\n\n#### check if typeinfo exists and works #####\ncat > $t <<EOT\n#include <typeinfo>\nconst char *foo(void) {\n\tint x;\n\treturn typeid(x).name();\n}\nEOT\ntest_cxx \"whether typeinfo/typeid works\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_TYPEINFO, $pass, [whether typeinfo/typeid works])\n\n#### check if iterator_traits is defined #####\ncat > $t <<EOT\n#include <iterator>\n\ntemplate <typename T> // T models Input Iterator\ntypename std::iterator_traits<T>::value_type accumulate(T first, T last)\n{\n      typename std::iterator_traits<T>::value_type result = 0;\n      while(first != last)\n            result += *first++;\n      return result;\n}\nEOT\ntest_cxx \"whether std::iterator_traits is defined\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_ITERATOR_TRAITS, $pass, [whether iterator_traits works])\n\n#### check if std::distance is defined #####\ncat > $t <<EOT\n#include <vector>\n#include <iterator>\n\nint foo()\n{\n  std::vector<int> tree;\n  return std::distance(tree.begin(), tree.end());\n}\nEOT\ntest_cxx \"whether std::distance is defined\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_STD_DISTANCE, $pass, [whether std::distance works])\n\n#### check if std::inserter is defined #####\ncat > $t <<EOT\n#include <list>\n#include <iterator>\n\nvoid foo()\n{\n  using namespace std;\n  list<int> L;\n  inserter ( L, L.end ( ) ) = 500;\n}\nEOT\ntest_cxx \"whether std::inserter is defined\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_STD_INSERTER, $pass, [whether std::inserter works])\n\n#### check if C++17's std::void_t is defined #####\ncat > $t <<EOT\n#include <type_traits>\n\ntemplate<typename T, typename = std::void_t<>>\nstruct has_pup_member : std::false_type {};\n\nEOT\ntest_cxx \"whether std::void_t is defined\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_STD_VOID_T, $pass, [whether std::void_t works])\n\n####### Check support for features added by the new C11 and CPP11 standards ########\n\n#### test if we can have multiple delete like this ####\ncat > $t <<EOT\nclass foo {\npublic:\n  void operator delete(void*p){};\n  void operator delete(void*p,int*){};\n};\nEOT\ntest_cxx \"whether operator delete can be overloaded in same class\" \"ok\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_MULTIPLE_DELETE, $strictpass, [whether operator delete can be overloaded in same class])\n\n#### test if offsetof exists ####\ncat > $t <<EOT\n#include <stddef.h>\n\nstruct FooType {\n        int f1;\n        int f2;\n        double f3;\n};\n\nvoid foo()\n{\n  int off = offsetof(FooType, f2);\n}\nEOT\ntest_cxx \"whether offsetof is defined\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_OFFSETOF, $pass, [whether offsetof exists])\n\n#### test if we can use gcc x86 assembly like this ####\ncat > $t <<EOT\ndouble foo(void)\n{\n  unsigned long long int v=0;\n  int *lo=0+(int *)&v;\n  int *hi=1+(int *)&v;\n  __asm__ __volatile__(\n      \"rdtsc; movl %%edx,%0; movl %%eax,%1\"\n      : /* output  */ \"=m\" (*hi), \"=m\" (*lo)\n      : /* input */\n      : /* trashes */ \"%edx\", \"%eax\"\n  );\n  return v;\n}\nEOT\ntest_cxx \"whether GCC x86 assembly works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_GCC_X86_ASM, $strictpass, [Allows gcc x86 assembly.])\n\n#### test if we can use gcc x86 assembly like this ####\nif test $strictpass = 1\nthen\ncat > $t <<EOT\nint foo(void)\n{\n  int x;\n  asm(\"lock incl %0\" :: \"m\" (x));\n  asm(\"lock decl %0\" :: \"m\" (x));\n  return x;\n}\nEOT\ntest_cxx \"whether GCC x86 assembly for atomic increment works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_GCC_X86_ASM_ATOMICINCREMENT, $strictpass, [Allows gcc x86 assembly for atomic increment.])\nfi\n\n#### test if we can use asm eieio assembly like this ####\ncat > $t <<EOT\ndouble foo(void)\n{\n        unsigned long long int x;\n\tasm volatile(\"eieio\" ::: \"memory\");\n        return x;\n}\nEOT\ntest_cxx \"whether asm eieio assembly works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_PPC_ASM, $strictpass, [Allows asm eieio assembly.])\n\n\n\n#### test if we can use __thread ####\ncat > $t <<EOT\n__thread unsigned long long int x;\nstatic __thread  int y;\nvoid foo(void)\n{\n\tx = 1;\n\ty = 1;\n}\nEOT\ntest_cxx \"whether __thread (Thread Local Storage) is supported\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_TLS_VARIABLES, $strictpass, [Allows __thread.])\n\n#### check __sync_add_and_fetch ####\ncat > $tc <<EOT\n#include <stdio.h>\nint main()\n{\n  int t=1;\n  __sync_add_and_fetch(&t, 1);\n  return 1;\n}\nEOT\ntest_linkc \"whether synchronization primitives (__sync_add_and_fetch) works in C\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_C_SYNC_ADD_AND_FETCH_PRIMITIVE, $pass, [whether sync_add_and_fetch primitive works in C])\n\n#### check __sync_synchronize ####\ncat > $tc <<EOT\n#include <stdio.h>\nint main()\n{\n  __sync_synchronize();\n}\nEOT\n\ntest_linkc \"whether synchronization primitives (__sync_synchronize) works in C\" \"yes\" \"no\" \"\"\n\nAC_DEFINE_UNQUOTED(CMK_C_SYNC_SYNCHRONIZE_PRIMITIVE, $pass, [whether sync_synchronize primitives works in C])\n\n\n### test for _IO_file_overflow ###\n\ncat > $tc <<EOT\n#include <stdio.h>\nextern int _IO_file_overflow(FILE *, int);\nint main()\n{\n  return _IO_file_overflow(stdout, -1);\n}\nEOT\ntest_linkc \"whether has _IO_file_overflow\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK_HAS_IO_FILE_OVERFLOW], $pass, [whether has _IO_file_overflow])\n\n\n### test for __executable_start ###\n\ncat > $tc <<EOT\nextern int __executable_start;\nint main()\n{\n  return __executable_start;\n}\nEOT\ntest_linkc \"whether has __executable_start\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK_HAS_EXECUTABLE_START], $pass, [whether has __executable_start])\n\n### test if switching TLS register ###\nif test $in64bit = 1\nthen\ncat > $t <<EOT\nvoid switchTLS() {\n  void * m1, * m2;\n  asm volatile (\"movq %%fs:0x0, %0\\n\\t\"\n                \"movq %1, %%fs:0x0\\n\\t\"\n                : \"=&r\"(m1)\n                : \"r\"(m2));\n}\nEOT\ntest_cxx \"whether switching TLS register (64-bit) is supported\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_TLS_SWITCHING_X86_64, $strictpass, [Allows switching TLS on x86_64.])\nelse\ncat > $t <<EOT\nvoid switchTLS() {\n  void * m1, * m2;\n  asm volatile (\"movl %%gs:0x0, %0\\n\\t\"\n                \"movl %1, %%gs:0x0\\n\\t\"\n                : \"=&r\"(m1)\n                : \"r\"(m2));\n}\nEOT\ntest_cxx \"whether switching TLS register (32-bit) is supported\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_TLS_SWITCHING_X86, $strictpass, [Allows switching TLS on x86.])\nfi\n\n### test for dl_iterate_phdr ###\n\ncat > $tc <<EOT\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#ifndef __USE_GNU\n# define __USE_GNU\n#endif\n#include <link.h>\n#include <stddef.h>\nstatic int callback(struct dl_phdr_info* info, size_t size, void* data)\n{\n  return 0;\n}\nint main()\n{\n  dl_iterate_phdr(callback, NULL);\n  return 0;\n}\nEOT\ntest_linkc \"whether has dl_iterate_phdr\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK_HAS_DL_ITERATE_PHDR], $pass, [whether has dl_iterate_phdr])\n\n\n### test for __malloc_hook ###\n\ncat > $tc <<EOT\nextern int __malloc_hook;\nint main()\n{\n  return __malloc_hook;\n}\nEOT\ntest_linkc \"whether has __malloc_hook\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK_HAS_MALLOC_HOOK], $pass, [whether has __malloc_hook])\nadd_make_flag \"CMK_HAS_MALLOC_HOOK:=$pass\" 'whether has __malloc_hook'\n\n\n#### test if we can build OFI ####\nif test \"$CMK_BUILD_OFI\" = 1\nthen\ncat > $tc <<EOT\n#include <rdma/fabric.h>\nint main(int argc, char **argv)\n{\n  struct fi_info *providers;\n  int ret = fi_getinfo(FI_VERSION(1,0), NULL, NULL, 0ULL, NULL, &providers);\n  return 0;\n}\nEOT\ntest_cc \"whether build on OFI\" \"yes\" \"no\" \"-lfabric\"\nAC_DEFINE_UNQUOTED(CMK_BUILD_ON_OFI, $strictpass, [build OFI.])\nBUILD_OFI=$strictpass\n\nif test $BUILD_OFI -eq 0\nthen\n  echo \"Error: Unable to compile OFI\"\n  test_finish 1\nelse\n  test_linkc \"whether -lfabric\" \"ok\" \"no\" \"-lfabric\"\n  if test $pass -eq 0\n  then\n    #test for psm incompatibility\n    PSM_COMPAT_DIR=/usr/lib64/psm2-compat\n    if test -d $PSM_COMPAT_DIR\n    then\n      add_flag CMK_LIBDIR='\"$CMK_LIBDIR -Wl,-rpath=/usr/lib64/psm2-compat\"' \"psm2-compat lib\"\n      CMK_LIBDIR=\"$CMK_LIBDIR -Wl,-rpath=/usr/lib64/psm2-compat\"\n      test_linkc \"whether -lfabric after adding psm2-compatible library\" \"ok\" \"no\" \"-lfabric\"\n      if test $pass -eq 0\n      then\n        echo \"Error: -lfabric not found or not working. Pass '--basedir=/path/to/dir/' if -lfabric is located in a different directory\"\n        test_finish 1\n      fi\n    else\n      echo \"Error: -lfabric not working, $PSM_COMPAT_DIR not found\"\n      echo \"Pass '--basedir=/path/to/dir/' if -lfabric is located in a different directory\"\n      test_finish 1\n    fi\n  fi\nfi\n\nfi\n\n#### test if we can build UCX ####\nif test \"$CMK_BUILD_UCX\" = 1\nthen\ncat > $tc <<EOT\n#include <ucp/api/ucp.h>\nint main(int argc, char **argv)\n{\n  unsigned major, minor, number;\n  ucp_get_version(&major, &minor, &number);\n  return 0;\n}\nEOT\ntest_cc \"whether build on UCX\" \"yes\" \"no\" \"-lucp\"\nAC_DEFINE_UNQUOTED(CMK_BUILD_ON_UCX, $strictpass, [build UCX.])\nBUILD_UCX=$strictpass\n\nif test $BUILD_UCX -eq 0\nthen\n  echo \"Error: Unable to compile UCX\"\n  test_finish 1\nelse\n  test_linkc \"whether -lucp\" \"ok\" \"no\" \"-lucp\"\nfi\n\nfi\n\n#### test if we can build MPI ####\nif test \"$CMK_BUILD_MPI\" = 1\nthen\n\ncat > $tc <<EOT\n#include \"mpi.h\"\nint main(int argc, char **argv)\n{\n  MPI_Init(&argc, &argv);\n  return 0;\n}\nEOT\nmv -f ../include/mpi.h ../include/mpi.h.bak 2>/dev/null\ntest_cc \"whether build on MPI\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_BUILD_ON_MPI, $strictpass, [build MPI.])\nBUILD_MPI=$strictpass\n\nif test $BUILD_MPI -eq 0\nthen\n  echo \"Error: Cannot compile an MPI program\"\n  test_finish 1\nfi\n\nif test $BUILD_MPI -eq 1\nthen\n  test_linkc \"whether need to specify MPI library\" \"no\" \"yes\" \"\"\n  if test $pass -ne 1\n  then\n    if test -z \"$CMK_MPI_LIB\"\n    then\n      test_linkc \"whether -lmpich\" \"ok\" \"no\" \"-lmpich\"\n      if test $pass -eq 1\n      then\n        add_flag CMK_SYSLIBS='\"$CMK_SYSLIBS -lmpich\"' \"mpi lib\"\n      else\n        test_linkc \"whether -lmpi\" \"ok\" \"no\" \"-lmpi\"\n        if test $pass -eq 1\n        then\n                add_flag CMK_SYSLIBS='\"$CMK_SYSLIBS -lmpi\"' \"mpi lib\"\n        else\n                echo \"Error: Cannot find MPI library\"\n                test_finish 1\n        fi\n      fi\n    else\n      add_flag CMK_SYSLIBS='\"$CMK_SYSLIBS $CMK_MPI_LIB\"' \"mpi lib\"\n    fi\n  fi\nfi\n\nif test \"$BUILD_MPI\" = \"1\"\nthen\ncat > $t <<EOT\n#include \"mpi.h\"\nint main(int argc, char **argv)\n{\n  int thread_level, provided;\n  thread_level = MPI_THREAD_FUNNELED;\n  MPI_Init_thread(&argc, &argv, thread_level, &provided);\n}\nEOT\ntest_cxx \"whether MPI_Init_thread is supported\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_MPI_INIT_THREAD, $strictpass, [Allows MPI_Init_thread.])\nfi\nmv -f ../include/mpi.h.bak ../include/mpi.h 2>/dev/null\n\nfi\n\nif test \"$BUILD_MPI\" = \"1\"\nthen\n\ncat > $t <<EOT\n#include <stdio.h>\n#include <mpi.h>\n\nint main (int argc, char** argv) {\n  return 0;\n}\nEOT\ntest_cxx \"whether macro conflicts occurs due to C++ MPI bindings\" \"no\" \"yes\" \"\"\nAC_DEFINE_UNQUOTED(CMK_CXX_MPI_BINDINGS, $strictpass, [Disables conflicting macros.])\nfi\n\n\n################### Syscalls and Libraries ###################\n\n#### test for getrusage with RUSAGE_THREAD ###\ncat > $tc <<EOT\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#ifndef __USE_GNU\n# define __USE_GNU\n#endif\n#include <sys/time.h>\n#include <sys/resource.h>\nint main() {\n  struct rusage usage;\n  getrusage(RUSAGE_THREAD, &usage);\n  return 0;\n}\nEOT\ntest_linkc \"whether getrusage accepts RUSAGE_THREAD\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_RUSAGE_THREAD, $pass, [whether getrusage accepts RUSAGE_THREAD])\n\n#### test for asctime ###\n\ncat > $tc <<EOT\n#include <time.h>\nint main() {\n  struct tm *local;\n  time_t t;\n  t = time(NULL);\n  local = localtime(&t);\n  asctime(local);\n  return 0;\n}\nEOT\ntest_linkc \"whether has asctime\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_ASCTIME, $pass, [whether has asctime])\n\n#### test for log2 ###\ncat > $t <<EOT\n#include <math.h>\nint main() {\n  int i = log2(10);\n  return 0;\n}\nEOT\ntest_link \"whether has log2\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_LOG2, $pass, [whether has log2])\n\n#### test for sqrtf ###\ncat > $t <<EOT\n#include <math.h>\nint main() {\n  float i = sqrtf((float)10.0);\n  return 0;\n}\nEOT\ntest_link \"whether has sqrtf\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SQRTF, $pass, [whether has sqrtf])\n\n#### test for fabsf ###\ncat > $t <<EOT\n#include <math.h>\nint main() {\n  float i = fabsf((float)10.0);\n  return 0;\n}\nEOT\ntest_link \"whether has fabsf\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_FABSF, $pass, [whether has fabsf])\n\n#### test for mkstemp ###\ncat > $t <<EOT\n#include <stdlib.h>\n#include <string.h>\nint main() {\n  char fname[[128]];\n  strcpy(fname, \"/tmp/fdXXX.XXX\");\n  mkstemp(fname);\n  return 0;\n}\nEOT\ntest_link \"whether has mkstemp\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_USE_MKSTEMP, $pass, [whether has mkstemp])\n\n#### test for system ###\ncat > $t <<EOT\n#include <stdlib.h>\nint main() {\n  system(\"/bin/ls\");\n  return 0;\n}\nEOT\ntest_link \"whether has system\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SYSTEM, $pass, [whether has system])\n\n#### test for sync() ###\ncat > $t <<EOT\n#include <unistd.h>\nint main() {\n  sync();\n  return 0;\n}\nEOT\ntest_link \"whether has sync()\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SYNC_FUNC, $pass, [whether has sync])\n\n#### test for fsync() ###\ncat > $t <<EOT\n#include <unistd.h>\nint main() {\n  fsync(0);\n  return 0;\n}\nEOT\ntest_link \"whether has fsync()\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_FSYNC_FUNC, $pass, [whether has fsync])\n\n#### test for fdatasync() ###\ncat > $t <<EOT\n#include <unistd.h>\nint main() {\n  fdatasync(0);\n  return 0;\n}\nEOT\ntest_link \"whether has fdatasync()\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_FDATASYNC_FUNC, $pass, [whether has fdatasync])\n\n#### test for sbrk ###\ncat > $t <<EOT\n#include <unistd.h>\nint main() {\n  void *ptr  = sbrk(0); \n}\nEOT\ntest_link \"whether has sbrk\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SBRK, $pass, [whether has sbrk])\n\n#### test for _setjmp/_longjmp ###\ncat > $t <<EOT\n#include <setjmp.h>\nint main() {\n  jmp_buf buf;\n  _setjmp(buf);\n  _longjmp(buf, 0);\n}\nEOT\ntest_link \"whether has _setjmp/_longjmp\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_UNDERSCORE_SETJMP, $pass, [whether has _setjmp/_longjmp])\n\n#### test for mstats ###\ncat > $t <<EOT\n#include <malloc.h>\nint main() {\n  struct mstats ms = mstats();\n}\nEOT\ntest_link \"whether has mstats\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MSTATS, $pass, [whether has mstats])\n\n#### test for mallinfo ###\ncat > $t <<EOT\n#include <malloc.h>\nint main() {\n  struct mallinfo mi = mallinfo();\n}\nEOT\ntest_link \"whether has mallinfo\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MALLINFO, $pass, [whether has mallinfo])\n\n#### test for __morecore ###\ncat > $t <<EOT\n#include <cstddef>\nint main() {\n  extern void *(*__morecore)(ptrdiff_t);\n  __morecore(0);\n  return 0;\n}\nEOT\ntest_link \"whether expects __morecore symbol\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_EXPECTS_MORECORE, $pass, [whether expects __morecore symbol])\n\n#### test for popen ###\ncat > $t <<EOT\n#include <stdio.h>\nint main() {\n  FILE *p = popen(\"/bin/ps\", \"r\");\n  pclose(p);\n}\nEOT\ntest_link \"whether has popen\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_POPEN, $pass, [whether has popen])\n\n#### test for poll ###\ncat > $t <<EOT\n#include <poll.h>\nvoid foo(void) { \n  struct pollfd pos[[3]];\n  poll(pos, 1, 1);\n}\nEOT\ntest_cxx \"whether has poll\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_USE_POLL, $pass, [whether the poll syscall exists])\n\n#### check if getpagesize exists ####\ncat > $tc <<EOT\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int s = getpagesize();\n}\nEOT\ntest_linkc \"whether has getpagesize\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_GETPAGESIZE, $pass, [whether getpagesize exists])\n\n#### check if getpid exists ####\ncat > $tc <<EOT\n#include <sys/types.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    pid_t pid = getpid();\n}\nEOT\ntest_linkc \"whether has getpid\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_GETPID, $pass, [whether getpid exists])\n\n#### check if kill exists ####\ncat > $tc <<EOT\n#include <sys/types.h>\n#include <unistd.h>\n#include <signal.h>\n\nint main(int argc, char**argv) \n{\n    pid_t pid = getpid();\n    kill(pid, 9);\n}\nEOT\ntest_linkc \"whether has kill\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_KILL, $pass, [whether kill exists])\n\n#### test for setpriority ###\ncat > $t <<EOT\n#include <sys/time.h>\n#include <sys/resource.h>\nvoid foo(void) { \n  setpriority(PRIO_PROCESS, 0, 0);\n}\nEOT\ntest_cxx \"whether has setpriority\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SETPRIORITY, $pass, [whether the setpriority exists])\n\n#### test for system ###\ncat > $t <<EOT\n#include \"ckdll_system.C\"\nEOT\ntest_cxx \"whether to use signal-safe system() \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_SIGSAFE_SYSTEM, $pass, [whether to use signal-safe system()])\n\n### test sched_setaffinity ####\ncat > $tc <<EOT\n#define _GNU_SOURCE\n#include <sched.h>\n\nint main()\n{\n  cpu_set_t cpuset;\n  CPU_ZERO(&cpuset);\n  CPU_SET(0, &cpuset);\n  if (sched_setaffinity(0, sizeof(cpuset), &cpuset) < 0) {\n    return -1;\n  }\n  return 0;\n}\nEOT\ntest_linkc \"whether sched_setaffinity call exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SETAFFINITY, $pass, [whether the sched_setaffinity() exists])\n\n### test pthread_setaffinity_np ####\ncat > $tc <<EOT\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n\nint main()\n{\n  unsigned long mask = 0xffffffff;\n  unsigned int len = sizeof(mask);\n\n  if (pthread_setaffinity_np(pthread_self(), len, &mask) < 0) {\n    return -1;\n  }\n  return 0;\n}\nEOT\ntest_linkc \"whether pthread_setaffinity_np call exists\" \"yes\" \"no\" \"-lpthread\"\nAC_DEFINE_UNQUOTED(CMK_HAS_PTHREAD_SETAFFINITY, $pass, [whether the pthread_setaffinity_np() exists])\n\n### test pthread_spin_lock ####\ncat > $tc <<EOT\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n\nint main()\n{\n  pthread_spinlock_t  lock;\n\n  pthread_spin_init(&lock, 0);\n\n  pthread_spin_lock(&lock);\n\n  return 0;\n}\nEOT\ntest_linkc \"whether pthread_spin_lock exists\" \"yes\" \"no\" \"-lpthread\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SPINLOCK, $pass, [whether the pthread_spin_lock exists])\n\n### check libnuma on Linux ####\nif test \"$WITH_NUMA\" = \"yes\"\nthen\ncat > $tc <<EOT\n#include <stdlib.h>\n#include <stdio.h>\n#include <linux/mempolicy.h>\n#include <numaif.h>\n#include <numa.h>\n\nint main()\n{\n  if (get_mempolicy(NULL, NULL, 0, 0, 0) == 0) return 0;\n  return -1;\n}\nEOT\ntest_linkc \"whether libnuma exists\" \"yes\" \"no\" \"-lnuma\"\nAC_DEFINE_UNQUOTED(CMK_HAS_NUMACTRL, $pass, [whether NUMA control related functions exist])\nif test $pass -eq 1\nthen\n        add_flag 'CMK_SYSLIBS=\"$CMK_SYSLIBS -lnuma\"' \"libnuma\"\nfi\nfi\n\n#### check bindprocessors on AIX ####\ncat > $tc <<EOT\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include <sys/processor.h>\n\nint main()\n{\n  int retValue = 0;\n  int pid;\n  pid = getpid();\n  if (bindprocessor(BINDPROCESS, pid, 0) == -1) return -1;\n  return 0;\n}\nEOT\ntest_linkc \"whether bindprocessor call exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_BINDPROCESSOR, $pass, [whether the bindprocessor()\nexists])\n\n\n#### check if visibility attribute works ####\ncat > $t <<EOT\n__attribute__((visibility(\"default\"))) int myfunc();\nint myfunc()\n{\n  return 0;\n}\nEOT\ntest_cxx 'whether has __attribute__((visibility(\"default\")))' \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_ATTRIBUTE_VISIBILITY_DEFAULT, $pass, [whether has __attribute__((visibility(\"default\")))])\n\n#### check if dlopen works ####\nskip_dl=0\ntest -n \"$CMK_NO_DL\" && skip_dl=1\ndl_opt='-ldl'\n#workaround for pgcc 4.0, -ldl crash linking, so use -Wl,-ldl to skip the prelinker.\ncase \"$CMK_CXX\" in\npgCC*) dl_opt='-Wl,-ldl' ;;\nesac\n\nif test $skip_dl -eq 0 \nthen\n\ncat > $t <<EOT\n#include \"ckdll_dlopen.C\"\nint main() {\n\tCkDll dll(\"foo.so\");\n\treturn 0;\n}\nEOT\ntest_link \"whether dlopen links without $dl_opt\" \"yes\" \"no\" \"\"\nnoldl=$pass\ntest_link \"whether dlopen links with $dl_opt\" \"yes\" \"no\" \"$dl_opt\"\nif test $pass -eq 1\nthen \n#dlopen requires -ldl: add it to our link line\n\tadd_flag CMK_LIBS='\"$CMK_LIBS '$dl_opt'\"' \"dlopen\"\nfi\n\nif test $pass -eq 1 -o $noldl -eq 1\nthen\n\tCMK_HAS_DLOPEN='1'\n# One version or another of dlopen worked: compile it in\n\tAC_DEFINE_UNQUOTED(CMK_DLL_USE_DLOPEN, 1, [dlopen])\nfi\n\ncat > $tc <<EOT\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#ifndef __USE_GNU\n# define __USE_GNU\n#endif\n#include <dlfcn.h>\n#include <stddef.h>\nint main()\n{\n  return dlsym(RTLD_DEFAULT, \"main\") != NULL;\n}\nEOT\ntest_cc \"whether has RTLD_DEFAULT\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_RTLD_DEFAULT, $pass, [whether has RTLD_DEFAULT])\n\ncat > $tc <<EOT\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#ifndef __USE_GNU\n# define __USE_GNU\n#endif\n#include <dlfcn.h>\n#include <stddef.h>\nint main()\n{\n  return dlsym(RTLD_NEXT, \"main\") != NULL;\n}\nEOT\ntest_cc \"whether has RTLD_NEXT\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_RTLD_NEXT, $pass, [whether has RTLD_NEXT])\n\ncat > $tc <<EOT\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#ifndef __USE_GNU\n# define __USE_GNU\n#endif\n#include <dlfcn.h>\n#include <stddef.h>\nint main()\n{\n  return dlmopen(LM_ID_NEWLM, \"foo.so\", 0) == NULL;\n}\nEOT\ntest_cc \"whether has dlmopen\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_DLMOPEN, $pass, [whether has dlmopen])\nCMK_HAS_DLMOPEN=\"$pass\"\n\ncat > $tc <<EOT\n#include <unistd.h>\nint main()\n{\n  char exe[[1024]];\n  return readlink(\"/proc/self/exe\", exe, sizeof(exe)-1) == -1;\n}\nEOT\ntest_cc \"whether has readlink\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_READLINK, $pass, [whether has readlink])\nCMK_HAS_READLINK=\"$pass\"\n\ncat > $tc <<EOT\n#include <limits.h>\n#include <stdlib.h>\nint main()\n{\n  return realpath(\"/proc/self/exe\", NULL) == NULL;\n}\nEOT\ntest_cc \"whether has realpath\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_REALPATH, $pass, [whether has realpath])\nCMK_HAS_REALPATH=\"$pass\"\n\ncase \"$CMK_VDIR\" in\n  *-win-*)\n    CMK_CAN_GET_BINARY_PATH='1'\n    CMK_CAN_OPEN_SHARED_OBJECTS_DYNAMICALLY='1'\n    ;;\n  *-darwin*)\n    CMK_CAN_GET_BINARY_PATH='1'\n    CMK_CAN_OPEN_SHARED_OBJECTS_DYNAMICALLY=\"$CMK_HAS_DLOPEN\"\n    ;;\n  *)\n    if test \"$CMK_HAS_READLINK\" = '1' -o \"$CMK_HAS_REALPATH\" = '1'\n    then\n      CMK_CAN_GET_BINARY_PATH='1'\n    else\n      CMK_CAN_GET_BINARY_PATH='0'\n    fi\n    CMK_CAN_OPEN_SHARED_OBJECTS_DYNAMICALLY=\"$CMK_HAS_DLOPEN\"\n    ;;\nesac\n\nif test \"$CMK_CAN_OPEN_SHARED_OBJECTS_DYNAMICALLY\" = '1' -a \"$CMK_CAN_GET_BINARY_PATH\" = '1'\nthen\n  CMK_SUPPORTS_FSGLOBALS='1'\nelse\n  CMK_SUPPORTS_FSGLOBALS='0'\nfi\nAC_DEFINE_UNQUOTED(CMK_SUPPORTS_FSGLOBALS, $CMK_SUPPORTS_FSGLOBALS, [whether supports filesystem globals])\nadd_flag \"CMK_SUPPORTS_FSGLOBALS=$CMK_SUPPORTS_FSGLOBALS\" 'filesystem globals'\nadd_make_flag \"CMK_SUPPORTS_FSGLOBALS:=$CMK_SUPPORTS_FSGLOBALS\" 'filesystem globals'\n\nif test \"$CMK_HAS_DLMOPEN\" = '1' -a \"$CMK_CAN_GET_BINARY_PATH\" = '1'\nthen\n  CMK_SUPPORTS_PIPGLOBALS='1'\nelse\n  CMK_SUPPORTS_PIPGLOBALS='0'\nfi\nAC_DEFINE_UNQUOTED(CMK_SUPPORTS_PIPGLOBALS, $CMK_SUPPORTS_PIPGLOBALS, [whether supports PiP globals])\nadd_flag \"CMK_SUPPORTS_PIPGLOBALS=$CMK_SUPPORTS_PIPGLOBALS\" 'PiP globals'\nadd_make_flag \"CMK_SUPPORTS_PIPGLOBALS:=$CMK_SUPPORTS_PIPGLOBALS\" 'PiP globals'\n\n#### check if getProcAddress works ####\ncat > $t <<EOT\n#include \"ckdll_win32.C\"\nEOT\ntest_cxx \"whether getProcAddress works\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_DLL_USE_WIN32, $pass, [whether getProcAddress works])\n\nfi    # end of skip_dl\n\n#### check if socklen_t exists ####\ncat > $t <<EOT\n#include <sys/types.h>\n#include <sys/socket.h>\n\nvoid foo(void) {\n\tint i;\n\tsocklen_t s=sizeof(i);\n}\nEOT\ntest_cxx \"whether has socklen_t\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SOCKLEN, $pass, [whether has socklen_t])\n\n### test getifaddrs ####\ncat > $tc <<EOT\n#include <netinet/in.h> /* for sockaddr_in */\n#include <ifaddrs.h> /* for getifaddrs */\n#include <net/if.h> /* for IFF_RUNNING */\n\nint main()\n{\n  struct ifaddrs *interfaces=0;\n  if( getifaddrs(&interfaces) == 0 ) {\n        struct ifaddrs *interface;\n        for( interface=interfaces; interface; interface=interface->ifa_next ) {\n            if( (interface->ifa_flags & IFF_UP) && ! (interface->ifa_flags & IFF_LOOPBACK) ) {\n                const struct sockaddr_in *addr = (const struct sockaddr_in*)interface->ifa_addr;\n                if( addr && addr->sin_family==AF_INET ) {\n                    break;\n                }\n            }\n        }\n        freeifaddrs(interfaces);\n  }\n}\nEOT\ntest_linkc \"whether getifaddrs call exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_GETIFADDRS, $pass, [whether getifaddrs() exists])\n\n#### check if mmap exists ####\ncat > $t <<EOT\n#include <sys/types.h>\n#include <sys/mman.h>\n\nvoid *foo(void *a,int l,int fd) {\n\treturn mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,\n                 MAP_FIXED+MAP_PRIVATE,fd,0);\n}\nEOT\ntest_cxx \"whether the mmap() syscall exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MMAP, $pass, [whether the mmap() syscall exists])\nadd_flag \"CMK_HAS_MMAP=$pass\"\nadd_make_flag \"CMK_HAS_MMAP:=$pass\"\n\n#### check if mmap accepts MAP_ANON ####\ncat > $t <<EOT\n#include <sys/types.h>\n#include <sys/mman.h>\n\nvoid *foo(void *a,int l) {\n\treturn mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,\n                MAP_FIXED+MAP_PRIVATE+MAP_ANON,-1,0);\n}\nEOT\ntest_cxx \"whether mmap() accepts MAP_ANON\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MMAP_ANON, $pass, [whether mmap() accepts MAP_ANON])\n\n#### check if mmap accepts MAP_NORESERVE ####\ncat > $t <<EOT\n#include <sys/types.h>\n#include <sys/mman.h>\n\nvoid *foo(void *a,int l) {\n\treturn mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,\n                MAP_FIXED+MAP_PRIVATE+MAP_NORESERVE,-1,0);\n}\nEOT\ntest_cxx \"whether mmap() accepts MAP_NORESERVE\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MMAP_NORESERVE, $pass, [whether mmap() accepts MAP_NORESERVE])\n\n#### check if get_myaddress exists ####\ncat > $t <<EOT\n#include <rpc/rpc.h>\n\nvoid foo(void *a) {\n    get_myaddress((struct sockaddr_in*)a);\n}\nEOT\ntest_cxx \"whether has get_myaddress\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_GET_MYADDRESS, $pass, [whether has get_myaddress])\n\n#### check if mprotect exists ####\ncat > $t <<EOT\n#include <stdio.h>\n#include <sys/mman.h>\n\nvoid foo(void *a,int l,int fd) {\n     void *pg = NULL;\n     size_t pagesize = 4096;\n     mprotect(pg, pagesize, PROT_READ | PROT_WRITE);\n}\nEOT\ntest_cxx \"whether has mprotect\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_MPROTECT, $pass, [whether has mprotect])\n\n#### check if support for SHM through CMA exists ####\ncat > $t <<EOT\n#define _GNU_SOURCE\n#include <sys/uio.h>\n#include <errno.h>\nint main() {\n  pid_t pid;\n  struct iovec *local, *remote;\n  int nread = process_vm_readv(pid, local, 1, remote, 1, 0);\n  nread = process_vm_writev(pid, local, 1, remote, 1, 0);\n  return errno;\n}\nEOT\ntest_link \"whether has support for shm transport using Cross Memory Attach\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_CMA, $pass, [whether supports cma])\nCMK_HAS_CMA=\"$pass\"\n\ntest \"$CMK_HAS_CMA\" = '1' -a \"$CMK_MULTICORE\" != '1' -a \"$CMK_BLUEGENEQ\" != '1' && CMK_USE_CMA='1' || CMK_USE_CMA='0'\nadd_make_flag \"CMK_USE_CMA:=$CMK_USE_CMA\" 'Cross Memory Attach'\n\ntest \"$CMK_WINDOWS\" != '1' -a \"$CMK_BLUEGENEQ\" != '1' && CMK_SUPPORTS_MEMORY_ISOMALLOC='1' || CMK_SUPPORTS_MEMORY_ISOMALLOC='0'\nadd_flag \"CMK_SUPPORTS_MEMORY_ISOMALLOC='$CMK_SUPPORTS_MEMORY_ISOMALLOC'\" '-memory isomalloc'\nadd_make_flag \"CMK_SUPPORTS_MEMORY_ISOMALLOC:=$CMK_SUPPORTS_MEMORY_ISOMALLOC\" '-memory isomalloc'\n\n#### check if -rdynamic works ####\ncat > $t <<EOT\nint main() {\n  return 0;\n}\nEOT\nTRACE_LINK_FLAG=''\nCAN_EXPORT_SYMBOLS='0'\nfor i in '-rdynamic' '-Wl,--export-dynamic'; do\n  test_link \"whether has $i\" \"yes\" \"no\" \"\" \"$i\"\n  if test \"$strictpass\" = '1'; then\n    TRACE_LINK_FLAG=\"$i\"\n    CAN_EXPORT_SYMBOLS='1'\n    break\n  fi\ndone\n\nif test \"$CAN_EXPORT_SYMBOLS\" = '1'; then\n  add_flag 'CMK_LD=\"$CMK_LD '$TRACE_LINK_FLAG'\"' \"exporting program symbols to shared objects\"\n  add_flag 'CMK_LDXX=\"$CMK_LDXX '$TRACE_LINK_FLAG'\"' \"exporting program symbols to shared objects\"\nfi\n\ntest_link \"whether has -Wl,-undefined,dynamic_lookup\" \"yes\" \"no\" \"\" \"-Wl,-undefined,dynamic_lookup\"\nadd_flag \"CMK_LINKER_KNOWS_UNDEFINED='$strictpass'\" \"importing program symbols from shared objects\"\n\n#### check if glibc backtrace exists ####\ncat > $t <<EOT\n#include \"cmibacktrace.C\"\n\nint main() {\n\tint nLevels=1;\n\tvoid *stack;\n\tCmiBacktraceRecord(&stack,0,&nLevels);\n\treturn 0;\n}\nEOT\ntest_link \"whether glibc backtrace works\" \"yes\" \"no\" \"-DCMK_USE_BACKTRACE=1 $TRACE_LINK_FLAG\"\nAC_DEFINE_UNQUOTED(CMK_USE_BACKTRACE, $pass, [whether glibc backtrace works])\n\n#### test sleep ####\ncat > $t <<EOT\n#include <unistd.h>\nint main() {\n  sleep(1);\n  return 0;\n}\nEOT\ntest_cxx \"whether has sleep \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_SLEEP, $pass, [whether has sleep])\n\n#### test usleep ####\ncat > $t <<EOT\n#include <unistd.h>\nint main() {\n  usleep(100);\n  return 0;\n}\nEOT\ntest_cxx \"whether has usleep \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_USLEEP, $pass, [whether has usleep])\n\n#### test personality() and ADDR_NO_RANDOMIZE ####\n# Only works on modern Linux systems\ncat > $t <<EOT\n#include <sys/personality.h>\nint main() {\n    int orig_persona = personality(0xffffffff);\n    personality(orig_persona | ADDR_NO_RANDOMIZE);\n    return 0;\n}\nEOT\ntest_cxx \"whether personality() and ADDR_NO_RANDOMIZE exist\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_ADDR_NO_RANDOMIZE, $pass, [whether personality() and ADDR_NO_RANDOMIZE exist])\n\n#### test posix_spawn() ####\ncat > $t <<EOT\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <spawn.h>\nint main() {\n    return posix_spawn(nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);\n}\nEOT\ntest_cxx \"whether posix_spawn() exists\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_POSIX_SPAWN, $pass, [whether posix_spawn() exists])\n\n\n# enable/disable zlib\nAC_ARG_ENABLE([zlib],\n            [AS_HELP_STRING([--enable-zlib],\n              [enable zlib support])],\n            [enable_zlib=$enableval],\n            [enable_zlib=yes])\n\n#### test if has zlib ####\nif test \"$enable_zlib\" = \"yes\"\nthen\n\ncat > $t <<EOT\n#include <zlib.h>\nint main() { \n  gzFile f = gzopen(\"/tmp/x\",\"r\");\n  gzprintf(f, \"test...\\n\");\n  gzclose(f);\n  return 0;\n}\nEOT\ntest_link \"whether has zlib\" \"yes\" \"no\" \"-lz\"\nAC_DEFINE_UNQUOTED(CMK_USE_ZLIB, $pass, [whether has zlib])\nif test $pass -eq 1\nthen \n\tadd_flag 'CMK_SYSLIBS=\"$CMK_SYSLIBS -lz\"' \"zlib\"\nfi\n\nfi\n\n#### test if has elf.h ####\ncat > $t <<EOT\n#include <elf.h>\ntypedef Elf32_Addr ELF_TYPE_Addr;\nint main() { \n}\nEOT\ntest_cxx \"whether has elf.h \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK_HAS_ELF_H], $pass, [whether has elf.h])\nif test $pass -eq 1\nthen\n\tadd_flag \"CMK_HAS_ELF_H='1'\" \"elf.h\"\nfi\n\n#### test if has Multiprocessing.h for apple ####\ncat > $t <<EOT\n#include <Carbon/Carbon.h>\n#include <Multiprocessing.h>\nint main() {\n  int a = MPProcessorsScheduled();\n}\nEOT\ntest_cxx \"whether has Multiprocessing.h for Apple \" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED([CMK_HAS_MULTIPROCESSING_H], $pass, [whether has Multiprocessing.h])\n\n#### test if \"ntohl\" is available ####\ncat > $tc <<EOT\n#ifdef _WIN32\n#include <Winsock2.h>\n#else\n#include <stdint.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#endif\n\nint main() {\n  int i = 100;\n  i = ntohl(i);\n  return 0;\n}\nEOT\ntest_cc \"whether ntohl is available\" \"yes\" \"no\" \"\"\nAC_DEFINE_UNQUOTED(CMK_HAS_NTOHL, $pass, [whether ntohl is available])\n\n### test for libjpeg ####\ncat > $t <<EOT\n#include <stdio.h>\n#include <stdlib.h>\n#include \"jpeglib.h\"\n\nint main()\n{\n  struct jpeg_compress_struct cinfo;\n  jpeg_create_compress(&cinfo);\n  return 0;\n}\nEOT\ntest_link \"whether has libjpeg\" \"yes\" \"no\" \"-ljpeg\"\nAC_DEFINE_UNQUOTED(CMK_USE_LIBJPEG, $pass, [whether has libjpeg])\nif test $pass -eq 1\nthen\n        add_flag 'CMK_LIBJPEG=\"-ljpeg\"' \"libjpeg\"\n        add_make_flag 'CMK_LIBJPEG:=-ljpeg' 'libjpeg'\nfi\n\n#### check if PAPI exists ####\nif test -n \"$CMK_USE_PAPI\"\nthen\ncat > $t <<EOT\n#include <stdio.h>\n#include <papi.h>\n                                                                                \nint main() {\n    if (PAPI_library_init(PAPI_VER_CURRENT) != PAPI_VER_CURRENT) return 1;\n    return 0;\n}\nEOT\ntest_link \"whether PAPI exists\" \"yes\" \"no\" \"-lpapi\"\nAC_DEFINE_UNQUOTED(CMK_HAS_COUNTER_PAPI, $pass, [whether PAPI exists])\nif test \"$enable_tracing\" = \"no\"\nthen\n\techo \"Error: Cannot build papi version when tracing is disabled, build with --enable-tracing\"\n\ttest_finish 1\nelif test $fail -eq 1\nthen\n\techo \"Error: Cannot find papi library\"\n\ttest_finish 1\nelse\n\tadd_flag 'CMK_LIBS=\"$CMK_LIBS -lpapi\"' \"papi\"\nfi\nfi\n\n#### test if Python headers are installed ####\nPYTHON_VERSION=`python -V 2>&1 | awk {'print $2'} | awk -F. {'print $1\".\"$2'}`\ncat > $t <<EOT\n#include \"python${PYTHON_VERSION}/Python.h\"\n#include \"python${PYTHON_VERSION}/compile.h\"\n#include \"python${PYTHON_VERSION}/eval.h\"\n#include \"python${PYTHON_VERSION}/node.h\"\n\nint main() {\n    Py_Initialize();\n    PyEval_InitThreads();\n    struct _node* programNode = PyParser_SimpleParseString(\"return 1\\n\",Py_file_input);\n    PyCodeObject *program = PyNode_Compile(programNode, \"\");\n}\nEOT\ntest_link \"whether Python is installed\" \"yes\" \"no\" \"-lpython$PYTHON_VERSION -lpthread -lutil -ldl\"\nAC_DEFINE_UNQUOTED(CMK_HAS_PYTHON, $pass, [whether Python is installed])\nAC_DEFINE_UNQUOTED(CMK_PYTHON_VERSION, ${PYTHON_VERSION}, [Python version])\nif test $pass -eq 1\nthen\n\tadd_flag \"CMK_BUILD_PYTHON=$PYTHON_VERSION\" \"python\"\n\tadd_make_flag \"CMK_BUILD_PYTHON:=$PYTHON_VERSION\" 'python'\nfi\n\n## Cray specific test\nif test \"$CMK_BUILD_CRAY\" = \"1\"\nthen\n#echo \"Test for known incompatible compiler versions\"\n\n if test \"$CRAY_CC_VERSION\" = \"8.1.4\"\n then\n\techo \"CCE 8.1.4 produces incorrect Charm++ code\"\n\techo \"Please use a newer version of the CCE compiler\"\n\techo \"e.g. module load cce/8.1.7\"\n\ttest_finish 1\n fi\n\n#### test if Cray node topology will work ####\ncat > $tc <<EOT\n#include <pmi.h>\n\nint main() {\n    int nid;\n    PMI_Get_nid(0, &nid);\n\n    return 0;\n}\nEOT\ntest_linkc \"whether PMI_Get_nid exists\" \"yes\" \"no\" \"$CMK_CRAY_LIBS\"\nAC_DEFINE_UNQUOTED(CMK_HAS_PMI_GET_NID, $pass, [whether PMI_Get_nid exists])\n\n#### test if Cray mesh topology will work ####\ncat > $tc <<EOT\n#include <rca_lib.h>\n\nint main() {\n    rca_mesh_coord_t xyz;\n    rca_get_meshcoord(0, &xyz);\n\n    return 0;\n}\nEOT\ntest_linkc \"whether Cray rca library is available\" \"yes\" \"no\" \"$CRAY_RCA_POST_LINK_OPTS -lrca\"\nAC_DEFINE_UNQUOTED(CMK_HAS_RCALIB, $pass, [whether Cray rca library is available])\n\n#### test if Cray mesh dimension query function will work ####\ncat > $tc <<EOT\n#include <rca_lib.h>\n\nint main() {\n    rca_mesh_coord_t xyz;\n    rca_get_max_dimension(&xyz);\n\n    return 0;\n}\nEOT\ntest_linkc \"whether Cray rca_has get_max_dimension\" \"yes\" \"no\" \"$CRAY_RCA_POST_LINK_OPTS -lrca\"\nAC_DEFINE_UNQUOTED(CMK_HAS_RCA_MAX_DIMENSION, $pass, [whether Cray rca has rca_get_max_dimension])\n\n#### query Cray machine max NID if get_max_dimension not exist ####\n\nif test $pass -eq 0\nthen\ncmd=`which xtprocadmin 2>/dev/null`\nif test -n \"$cmd\"\nthen\n    #maxnid=`xtprocadmin  | tail -1  | awk '{print $1}'`\n    # workaround for hopper\n    (export SHELL=/bin/csh; xtprocadmin >& t.$$)\n    maxnid=`cat t.$$  | tail -1  | awk '{print $1}'`\n    /bin/rm -f t.$$\n    AC_MSG_CHECKING(Cray machine maxnid)\n    AC_MSG_RESULT(\"$maxnid\")\n    if test -n \"$maxnid\"\n    then\n    AC_DEFINE_UNQUOTED(CMK_CRAY_MAXNID, $maxnid, [Cray MAXNID])\n    fi\nfi\nfi\n\n\n\n\n#### query Cray machine supports BANDWIDTH_INJECTION controls####\n\nif test \"$CMK_BUILD_MPI\" = \"1\"\nthen\necho \"BALANCED_INJECTION test disabled on MPI\"\nelif test \"$GNI_CRAYXC\" = \"1\"\nthen\necho \"BALANCED_INJECTION test disabled on Aries network\"\nelse\ncat > $tc <<EOT\n#include <stdint.h>\n#include <gni_pub.h>\n\nint main() {\n    gni_bi_desc_t gni_bi_desc;\n    uint32_t gni_device_id = 0;\n    gni_return_t gni_rc = GNI_GetBIConfig(gni_device_id, &gni_bi_desc);\n    if (gni_rc == GNI_RC_SUCCESS) {\n    }\n    return 0;\n}\nEOT\ntest_linkc \"whether GNI_GetBIConfig exists\" \"yes\" \"no\" \"$CMK_CRAY_LIBS\"\nAC_DEFINE_UNQUOTED(CMK_BALANCED_INJECTION_API, $pass, [whether Cray gni_pub has GNI_GetBIConfig])\nfi # end of BIConfig test\n\n\nfi  # end of Cray specific test\n\n#### test if it can build shared library ####\ncat > $t <<EOT\n#include \"stdlib.h\"\nextern int foo();\nint foo1() { \n  void * t= malloc(2);\n  foo();\n  return 0;\n}\nEOT\ntest_linkso \"whether can build shared library\" \"yes\" \"no\" \"\"\nif test $pass -eq 0\nthen \n\tadd_flag 'CMK_NO_BUILD_SHARED=\"true\"' \"build-shared\"\n\tadd_make_flag 'CMK_NO_BUILD_SHARED:=true' 'build-shared'\n\tCMK_NO_BUILD_SHARED='true'\nelse\n\tBUILD_SHARED=1\n        if test \"$BUILD_MPI\" = \"1\"\n\tthen\ncat > $t <<EOT\n#include \"stdlib.h\"\n#include \"mpi.h\"\nextern int foo();\nint foo(int argc, char ** argv) {\n  void * t= malloc(2);\n  foo();\n  MPI_Init(&argc, &argv);\n  return 0;\n}\nEOT\n\t\ttest_linkso \"whether can build shared library with MPI\" \"yes\" \"no\" \"\"\n\t\tBUILD_SHARED=$pass\n\tfi\n\tif test $BUILD_SHARED -eq 0\n\tthen\n\t\tadd_flag 'CMK_NO_BUILD_SHARED=\"true\"' \"build-shared\"\n\t\tadd_make_flag 'CMK_NO_BUILD_SHARED:=true' 'build-shared'\n\t\tCMK_NO_BUILD_SHARED='true'\n\tfi\nfi\n\n#### test the if command sync exists ####\nAC_CHECK_PROG(SYNC, sync, sync )\nif test -n \"$SYNC\"\nthen\nAC_DEFINE_UNQUOTED(CMK_HAS_SYNC, 1, [sync program])\nfi\n\n################## Fortran #########################\n\n#echo \"set F77 compiler as: $CMK_CF77\"\nAC_MSG_CHECKING(\"F77 compiler as\")\nAC_MSG_RESULT(\"$CMK_CF77\")\n\nAC_MSG_CHECKING(\"whether Fortran 77 compiler works\")\n### test fortran 77 compiler ###\ncat > conftest.f <<EOF\n      SUBROUTINE FOO_foo\n      END\nEOF\n$CMK_CF77 -c conftest.f > /dev/null 2> /dev/null\nif test ! -r conftest.o\nthen\n  AC_MSG_RESULT(\"no\")\nelse\n  AC_MSG_RESULT(\"yes\")\nfi\n\n### test fortran 90 compiler ###\n#echo \"set F90 compiler as: $CMK_CF90\"\nAC_MSG_CHECKING(\"F90 compiler as\")\nAC_MSG_RESULT(\"$CMK_CF90\")\n\nAC_MSG_CHECKING(\"whether Fortran 90 compiler works\")\ncat > conftest2.f90 <<EOF\n      SUBROUTINE FOO_foo\n      END\nEOF\n$CMK_CF90 -c conftest2.f90 > /dev/null 2> /dev/null\nif test ! -r conftest2.o\nthen\n  AC_MSG_RESULT(\"no\")\nelse\n  AC_MSG_RESULT(\"yes\")\n  mv -f conftest2.o conftest.o\n  USE_FORTRAN90=1\nfi\n\n### check fortran name mangling\nAC_MSG_CHECKING(subroutine name used by Fortran 90 compiler)\n\nif test -r conftest.o\nthen\n  AC_CACHE_VAL(_cv_fortran_postfix,\n\n  NAME=`$CMK_NM conftest.o | grep \"foo_foo__\"`\n  if test \"$NAME\" != \"\"\n  then\n    _cv_fortran_postfix=TWOSCORE\n    AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_TWOSCORE, 1, [TWOSCORE])\n  else\n    NAME=`$CMK_NM conftest.o | grep \"foo_foo_\"`\n    if test \"$NAME\" != \"\"\n    then\n      _cv_fortran_postfix=ONESCORE\n      AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_ONESCORE, 1, [ONESCORE])\n    else\n      NAME=`$CMK_NM conftest.o | grep \"foo_foo\"`\n      if test \"$NAME\" != \"\"\n      then\n        _cv_fortran_postfix=NOSCORE\n        AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_NOSCORE, 1, [NOSCORE])\n      else\n        NAME=`$CMK_NM conftest.o | grep \"FOO_FOO\"`\n        if test \"$NAME\" != \"\"\n        then\n          _cv_fortran_postfix=ALLCAPS\n          AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_ALLCAPS, 1, [ALLCAPS])\n        else\n          echo \"#################################################\"\n          echo \"FORTRAN compiler generated name not supported yet\"\n          echo \"#################################################\"\n        fi\n      fi\n    fi\n  fi\n  rm -f conftest.f conftest.o\n  )\n  AC_MSG_RESULT($_cv_fortran_postfix)\nelse\n  AC_MSG_RESULT(\"Fortran compiler not working\")\nfi\n\n### check module name ###\n\nif test \"$USE_FORTRAN90\" = 1\nthen\n  cat > conftest.f90 <<EOF\n      MODULE testmod\n        interface \n          function fpup_issizing(p)\n          INTEGER :: p\n          logical fpup_issizing\n          end function\n        end interface\n      END MODULE\nEOF\n  AC_MSG_CHECKING(Fortran 90 mod name is capital)\n  $CMK_CF90 -c conftest.f90 > /dev/null 2> /dev/null\n  name=`ls TESTMOD.* 2>/dev/null`\n  if test -n \"$name\"\n  then\n        AC_MSG_RESULT(\"yes\")\n\tadd_flag 'CMK_MOD_NAME_ALLCAPS=1' \"mod name capital\"\n  else\n        AC_MSG_RESULT(\"no\")\n\tname=`ls testmod.* 2>/dev/null`\n  fi\n  if test -n \"$name\"\n  then\n  \tAC_MSG_CHECKING(Fortran 90 mod name extension)\n    \text=`echo $name | sed -e 's/^[[^.]]*\\.//'`\n\tadd_flag 'CMK_MOD_EXT=\"'$ext'\"' \"mod name extension\"\n        AC_MSG_RESULT(\"$ext\")\n        /bin/rm -f $name\n  fi\n  /bin/rm -f conftest.f90\nfi\n\n### test if the C++ linker succeeds with a Fortran entry point ##\n\ncat > conftest.f90 <<EOF\n      PROGRAM empty\n      END PROGRAM\nEOF\ntest_link_fortran_main() {\n  AC_MSG_CHECKING(\"$1\")\n  echo \"### $1\" >> $charmout\n  cat conftest.f90 >> $charmout\n  echo $CMK_CF90 -c conftest.f90 -o test.o $4 >> $charmout\n  $CMK_CF90 -c conftest.f90 -o test.o $4 > out 2>&1\n  if test $? -ne 0\n  then\n    test_result 1 \"$1\" \"$2\" \"$3\"\n  else\n    echo $CMK_LDXX $CMK_LDXX_FLAGS $CMK_LINK_BINARY -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $CMK_F90LIBS $CMK_F90MAINLIBS $4 $5 >> $charmout\n    $CMK_LDXX $CMK_LDXX_FLAGS $CMK_LINK_BINARY -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $CMK_F90LIBS $CMK_F90MAINLIBS $4 $5 >> out 2>&1\n    ret=$?\n    test ! -x testlink && ret=1\n    test_result $ret \"$1\" \"$2\" \"$3\"\n  fi\n  cat out >> $charmout\n}\ntest_link_fortran_main \"whether the C++ linker succeeds with a Fortran entry point\" \"yes\" \"no\" \"\"\n/bin/rm -f conftest.f90 test.o testlink out\nif test $pass -eq 1\nthen\n  add_flag \"CMK_CAN_LINK_FORTRAN='1'\" \"Fortran\"\n  add_make_flag \"CMK_CAN_LINK_FORTRAN:=1\" \"Fortran\"\nfi\n\n### check for OpenMP availability ###\ncat > $tc <<EOT\n#include <stdio.h>\n#include <omp.h>\n\nint main(void)\n{\n  int iam = 0, np = 1;\n\n  #pragma omp parallel default(shared) private(iam, np)\n  {\n    np = omp_get_num_threads();\n    iam = omp_get_thread_num();\n    printf(\"Hello from thread %d of %d\\n\", iam, np);\n  }\n\n  return 0;\n}\nEOT\ntest_linkc \"whether OpenMP is supported\" \"yes\" \"no\" \"$CMK_C_OPENMP\"\nif test $pass -eq 1\nthen\n\tadd_flag \"CMK_HAS_OPENMP='1'\" \"OpenMP\"\nfi\n\n### check for Lustre FS availability ###\ncat > $tc <<EOT\n#include <stdio.h>\n#include <lustre/lustreapi.h>\n#include <lustre/lustre_user.h>\n\nint main() {\n  llapi_printf(LLAPI_MSG_NORMAL, \"Lustre FS is available\");\n  return 0;\n}\nEOT\ntest_linkc \"whether has lustre fs\" \"yes\" \"no\" \"-llustreapi\"\nAC_DEFINE_UNQUOTED(CMK_HAS_LUSTREFS, $pass, [whether has lustrefs])\nif test $pass -eq 1\nthen\n  add_make_flag 'CMK_LUSTREAPI:=-llustreapi' \"lustreapi\"\nelse\n  add_make_flag 'CMK_LUSTREAPI:=' \"lustreapi\"\nfi\n\n\neval `\"$CHARMBIN/charmc\" $OPTS -print-building-blocks -standalone`\nadd_make_flag \"HWLOC_CC:=$(get_full_command_name \"$CHARM_CC\")\" \"hwloc\"\nadd_make_flag \"HWLOC_CC_FLAGS:=$CHARM_CC_FLAGS\" \"hwloc\"\n\nAC_OUTPUT\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/src/libs/ck-libs/ampi/ampi_globals_pip.C": "\n#include \"ampi_funcptr_loader.h\"\n\n#include <string>\n#include <atomic>\n\nstatic std::atomic<size_t> rank_count{};\n\nint main(int argc, char ** argv)\n{\n  const size_t myrank = rank_count++;\n  if (CmiMyNode() == 0 && myrank == 0 && !quietModeRequested)\n    CmiPrintf(\"AMPI> Using pipglobals privatization method.\\n\");\n\n  SharedObject myexe;\n\n  // open the user binary for this rank in a unique namespace\n  {\n    static const char exe_suffix[] = STRINGIFY(CMK_POST_EXE);\n    static const char suffix[] = STRINGIFY(CMK_USER_SUFFIX) \".\" STRINGIFY(CMK_SHARED_SUF);\n    static constexpr size_t exe_suffix_len = sizeof(exe_suffix)-1;\n\n    std::string binary_path{ampi_binary_path};\n    if (exe_suffix_len > 0)\n    {\n      size_t pos = binary_path.length() - exe_suffix_len;\n      if (!binary_path.compare(pos, exe_suffix_len, exe_suffix))\n        binary_path.resize(pos);\n    }\n    binary_path += suffix;\n\n    const Lmid_t lmid = myrank == 0 ? LM_ID_BASE : LM_ID_NEWLM;\n    myexe = dlmopen(lmid, binary_path.c_str(), RTLD_NOW|RTLD_LOCAL);\n  }\n\n  if (myexe == nullptr)\n  {\n    CkError(\"dlmopen error: %s\\n\", dlerror());\n    CkAbort(\"Could not open pipglobals user program!\");\n  }\n\n  return AMPI_FuncPtr_Loader(myexe, argc, argv);\n}\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/ampi/03-using.rst": "Using Existing MPI Codes with AMPI\n==================================\n\nDue to the nature of AMPI's virtualized ranks, some changes to existing\nMPI codes may be necessary for them to function correctly with AMPI.\n\nEntry Point\n-----------\n\nTo convert an existing program to use AMPI, the main function or program\nmay need to be renamed. The changes should be made as follows:\n\nFortran\n~~~~~~~\n\nYou must declare the main program as a subroutine called \"MPI_MAIN\". Do\nnot declare the main subroutine as a *program* because it will never be\ncalled by the AMPI runtime.\n\n.. code-block:: fortran\n\n   program pgm -> subroutine MPI_Main\n       ...                       ...\n   end program -> end subroutine\n\nC or C++\n~~~~~~~~\n\nThe main function can be left as is, if ``mpi.h`` is included before the\nmain function. This header file has a preprocessor macro that renames\nmain, and the renamed version is called by the AMPI runtime for each\nrank.\n\nCommand Line Argument Parsing\n-----------------------------\n\nFortran\n~~~~~~~\n\nFor parsing Fortran command line arguments, AMPI Fortran programs should\nuse our extension APIs, which are similar to Fortran 2003\u2019s standard\nAPIs. For example:\n\n.. code-block:: fortran\n\n   integer :: i, argc, ierr\n   integer, parameter :: arg_len = 128\n   character(len=arg_len), dimension(:), allocatable :: raw_arguments\n\n   call AMPI_Command_argument_count(argc)\n   allocate(raw_arguments(argc))\n   do i = 1, size(raw_arguments)\n       call AMPI_Get_command_argument(i, raw_arguments(i), arg_len, ierr)\n   end do\n\nC or C++\n~~~~~~~~\n\nExisting code for parsing ``argc`` and ``argv`` should be sufficient,\nprovided that it takes place *after* ``MPI_Init``.\n\nGlobal Variable Privatization\n-----------------------------\n\nIn AMPI, ranks are implemented as user-level threads that coexist\nwithin OS processes or OS threads, depending on how the Charm++\nruntime was built. Traditional MPI\nprograms assume that each rank has an entire OS process to itself,\nand that only one thread of control exists within its address space.\nThis allows them to safely use global and static variables in their\ncode. However, global and static variables are problematic for\nmulti-threaded environments such as AMPI or OpenMP. This is because\nthere is a single instance of those variables, so they will be shared\namong different ranks in the single address space, and this could lead\nto the program producing an incorrect result or crashing.\n\nThe following code is an example of this problem. Each rank queries its\nnumeric ID, stores it in a global variable, waits on a global barrier,\nand then prints the value that was stored. If this code is run with\nmultiple ranks virtualized inside one OS process, each rank will store\nits ID in the same single location in memory. The result is that all\nranks will print the ID of whichever one was the last to successfully\nupdate that location. For this code to be semantically valid with AMPI,\neach rank needs its own separate instance of the variable. This is\nwhere the need arises for some special handling of these unsafe\nvariables in existing MPI applications, which we call *privatization*.\n\n.. code-block:: c++\n\n  int rank_global;\n\n  void print_ranks(void)\n  {\n    MPI_Comm_rank(MPI_COMM_WORLD, &rank_global);\n\n    MPI_Barrier(MPI_COMM_WORLD);\n\n    printf(\"rank: %d\\n\", rank_global);\n  }\n\nThe basic transformation needed to port MPI programs to AMPI is\nprivatization of global and static variables. Module variables, \"saved\"\nsubroutine local variables, and common blocks in Fortran90 also belong to\nthis category. Certain API calls use global variables internally, such as\n``strtok`` in the C standard library, and as a result they are also\nunsafe. If such a program is executed without privatization on AMPI, all\nthe AMPI ranks that reside in the same process will access the same\ncopy of such variables, which is clearly not the desired semantics. Note\nthat global variables that are constant or are only written to once\nduring initialization with the same value across all ranks are already\nthread-safe.\n\nTo ensure AMPI programs execute correctly, it is necessary to make such\nvariables \"private\" to individual ranks. We provide several options to\nachieve this with varying degrees of portability and required developer\neffort.\n\n.. warning::\n\n   If you are writing a new MPI application from scratch and would like\n   to support AMPI as a first-class target, it is highly recommended to\n   follow certain guidelines for writing your code to avoid the global\n   variable problem entirely, eliminating the need for time-consuming\n   refactoring or platform-specific privatization methods later on. See\n   the Manual Code Editing section below for an example of how to\n   structure your code in order to accomplish this.\n\nManual Code Editing\n~~~~~~~~~~~~~~~~~~~\n\nWith regard to performance and portability, the ideal approach to resolve\nthe global variable problem is to refactor your code to avoid use of\nglobals entirely. However, this comes with the obvious caveat that it\nrequires developer time to implement and can involve invasive changes\nacross the entire codebase, similar to converting a shared library to be\nreentrant in order to allow multiple instantiations from the same OS\nprocess. If these costs are a significant barrier to entry, it can be\nhelpful to instead explore one of the simpler transformations or fully\nautomated methods described below.\n\nWe have employed a strategy of argument passing to do this privatization\ntransformation. That is, the global variables are bunched together in a\nsingle user-defined type, which is allocated by each thread dynamically\nor on the stack. Then a pointer to this type is passed from subroutine\nto subroutine as an argument. Since the subroutine arguments are passed\non the stack, which is not shared across all threads, each subroutine\nwhen executing within a thread operates on a private copy of the global\nvariables.\n\nThis scheme is demonstrated in the following examples. The original\nFortran90 code contains a module ``shareddata``. This module is used in\nthe ``MPI_MAIN`` subroutine and a subroutine ``subA``. Note that\n``PROGRAM PGM`` was renamed to ``SUBROUTINE MPI_MAIN`` and ``END PROGRAM``\nwas renamed to ``END SUBROUTINE``.\n\n.. code-block:: fortran\n\n   !FORTRAN EXAMPLE\n   MODULE shareddata\n     INTEGER :: myrank\n     DOUBLE PRECISION :: xyz(100)\n   END MODULE\n\n   SUBROUTINE MPI_MAIN                               ! Previously PROGRAM PGM\n     USE shareddata\n     include 'mpif.h'\n     INTEGER :: i, ierr\n     CALL MPI_Init(ierr)\n     CALL MPI_Comm_rank(MPI_COMM_WORLD, myrank, ierr)\n     DO i = 1, 100\n       xyz(i) =  i + myrank\n     END DO\n     CALL subA\n     CALL MPI_Finalize(ierr)\n   END SUBROUTINE                                    ! Previously END PROGRAM\n\n   SUBROUTINE subA\n     USE shareddata\n     INTEGER :: i\n     DO i = 1, 100\n       xyz(i) = xyz(i) + 1.0\n     END DO\n   END SUBROUTINE\n\n.. code-block:: c++\n\n   //C Example\n   #include <mpi.h>\n\n   int myrank;\n   double xyz[100];\n\n   void subA();\n   int main(int argc, char** argv){\n     int i;\n     MPI_Init(&argc, &argv);\n     MPI_Comm_rank(MPI_COMM_WORLD, &myrank);\n     for(i=0;i<100;i++)\n       xyz[i] = i + myrank;\n     subA();\n     MPI_Finalize();\n   }\n\n   void subA(){\n     int i;\n     for(i=0;i<100;i++)\n       xyz[i] = xyz[i] + 1.0;\n   }\n\nAMPI executes the main subroutine inside a user-level thread as a\nsubroutine.\n\nNow we transform this program using the argument passing strategy. We\nfirst group the shared data into a user-defined type.\n\n.. code-block:: fortran\n\n   !FORTRAN EXAMPLE\n   MODULE shareddata\n     TYPE chunk ! modified\n       INTEGER :: myrank\n       DOUBLE PRECISION :: xyz(100)\n     END TYPE ! modified\n   END MODULE\n\n.. code-block:: c++\n\n   //C Example\n   struct shareddata{\n     int myrank;\n     double xyz[100];\n   };\n\nNow we modify the main subroutine to dynamically allocate this data and\nchange the references to them. Subroutine ``subA`` is then modified to\ntake this data as argument.\n\n.. code-block:: fortran\n\n   !FORTRAN EXAMPLE\n   SUBROUTINE MPI_Main\n     USE shareddata\n     USE AMPI\n     INTEGER :: i, ierr\n     TYPE(chunk), pointer :: c ! modified\n     CALL MPI_Init(ierr)\n     ALLOCATE(c) ! modified\n     CALL MPI_Comm_rank(MPI_COMM_WORLD, c%myrank, ierr)\n     DO i = 1, 100\n       c%xyz(i) =  i + c%myrank ! modified\n     END DO\n     CALL subA(c)\n     CALL MPI_Finalize(ierr)\n   END SUBROUTINE\n\n   SUBROUTINE subA(c)\n     USE shareddata\n     TYPE(chunk) :: c ! modified\n     INTEGER :: i\n     DO i = 1, 100\n       c%xyz(i) = c%xyz(i) + 1.0 ! modified\n     END DO\n   END SUBROUTINE\n\n.. code-block:: c++\n\n   //C Example\n   void MPI_Main{\n     int i,ierr;\n     struct shareddata *c;\n     ierr = MPI_Init();\n     c = (struct shareddata*)malloc(sizeof(struct shareddata));\n     ierr = MPI_Comm_rank(MPI_COMM_WORLD, c.myrank);\n     for(i=0;i<100;i++)\n       c.xyz[i] = i + c.myrank;\n     subA(c);\n     ierr = MPI_Finalize();\n   }\n\n   void subA(struct shareddata *c){\n     int i;\n     for(i=0;i<100;i++)\n       c.xyz[i] = c.xyz[i] + 1.0;\n   }\n\nWith these changes, the above program can be made thread-safe. Note that\nit is not really necessary to dynamically allocate ``chunk``. One could\nhave declared it as a local variable in subroutine ``MPI_Main``. (Or for\na small example such as this, one could have just removed the\n``shareddata`` module, and instead declared both variables ``xyz`` and\n``myrank`` as local variables). This is indeed a good idea if shared\ndata are small in size. For large shared data, it would be better to do\nheap allocation because in AMPI, the stack sizes are fixed at the\nbeginning (and can be specified from the command line) and stacks do not\ngrow dynamically.\n\nAutomatic Thread-Local Storage Swapping\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThread Local Store (TLS) was originally employed in kernel threads to\nlocalize variables to threads and provide thread safety. It can be used\nby annotating global/static variable declarations in C with\n*thread_local*, in C with *__thread* or C11 with *thread_local* or\n*_Thread_local*, and in Fortran with OpenMP\u2019s *threadprivate*\nattribute. OpenMP is required for using tlsglobals in Fortran code since\nFortran has no other method of using TLS. The *__thread* keyword is not\nan official extension of the C language, though compiler writers are\nencouraged to implement this feature.\n\nIt handles both global and static variables and has no context-switching\noverhead. AMPI provides runtime support for privatizing thread-local\nvariables to user-level threads by changing the TLS segment register\nwhen context switching between user-level threads. The runtime overhead\nis that of changing a single pointer per user-level thread context\nswitch. Currently, Charm++ supports it for x86/x86_64 platforms when\nusing GNU compilers.\n\n.. code-block:: c++\n\n   // C/C++ example:\n   int myrank;\n   double xyz[100];\n\n.. code-block:: fortran\n\n   ! Fortran example:\n   integer :: myrank\n   real*8, dimension(100) :: xyz\n\nFor the example above, the following changes to the code handle the\nglobal variables:\n\n.. code-block:: c++\n\n   // C++ example:\n   thread_local int myrank;\n   thread_local double xyz[100];\n\n   // C example:\n   __thread int myrank;\n   __thread double xyz[100];\n\n.. code-block:: fortran\n\n   ! Fortran example:\n   integer :: myrank\n   real*8, dimension(100) :: xyz\n   !$omp threadprivate(myrank)\n   !$omp threadprivate(xyz)\n\nThe runtime system also should know that TLS-Globals is used at both\ncompile and link time:\n\n.. code-block:: bash\n\n   $ ampicxx -o example example.C -tlsglobals\n\nAutomatic Process-in-Process Runtime Linking Privatization\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nProcess-in-Process (PiP) [PiP2018]_ Globals allows fully automatic\nprivatization of global variables on GNU/Linux systems without\nmodification of user code. All languages (C, C++, Fortran, etc.) are\nsupported. This method currently lacks support for checkpointing and\nmigration, which are necessary for load balancing and fault tolerance.\nAdditionally, overdecomposition is limited to approximately 12 virtual\nranks per logical node, though this can be resolved by building a\npatched version of glibc.\n\nThis method works by combining a specific method of building binaries\nwith a GNU extension to the dynamic linker. First, AMPI's toolchain\nwrapper compiles your user program as a Position Independent Executable\n(PIE) and links it against a special shim of function pointers instead\nof the normal AMPI runtime. It then builds a small loader utility that\nlinks directly against AMPI. For each rank, this loader calls the\nglibc-specific function ``dlmopen`` on the PIE binary with a unique\nnamespace index. The loader uses ``dlsym`` to populate the PIE binary's\nfunction pointers and then it calls the entry point. This ``dlmopen``\nand ``dlsym`` process repeats for each rank. As soon as execution jumps\ninto the PIE binary, any global variables referenced within will appear\nprivatized. This is because PIE binaries locate the global data segment\nimmediately after the code segment so that PIE global variables are\naccessed relative to the instruction pointer, and because ``dlmopen``\ncreates a separate copy of these segments in memory for each unique\nnamespace index.\n\nOptionally, the first step in using PiP-Globals is to build PiP-glibc to\novercome the limitation on rank count per process. Use the instructions\nat https://github.com/RIKEN-SysSoft/PiP/blob/pip-1/INSTALL.md to download\nan installable PiP package or build PiP-glibc from source by following\nthe ``Patched GLIBC`` section. AMPI may be able to automatically detect\nPiP's location if installed as a package, but otherwise set and export\nthe environment variable ``PIP_GLIBC_INSTALL_DIR`` to the value of\n``<GLIBC_INSTALL_DIR>`` as used in the above instructions. For example:\n\n.. code-block:: bash\n\n   $ export PIP_GLIBC_INSTALL_DIR=~/pip\n\nTo use PiP-Globals in your AMPI program (with or without PiP-glibc),\ncompile and link with the ``-pipglobals`` parameter:\n\n.. code-block:: bash\n\n   $ ampicxx -o example.o -c example.cpp -pipglobals\n   $ ampicxx -o example example.o -pipglobals\n\nNo further effort is needed. Global variables in ``example.cpp`` will be\nautomatically privatized when the program is run. Any libraries and\nshared objects compiled as PIE will also be privatized. However, if\nthese objects call MPI functions, it will be necessary to build them\nwith the AMPI toolchain wrappers, ``-pipglobals``, and potentially also\nthe ``-standalone`` parameter in the case of shared objects. It is\nrecommended to do this in any case so that AMPI can ensure everything is\nbuilt as PIE.\n\nPotential future support for checkpointing and migration will require\nmodification of the ``ld-linux.so`` runtime loader to intercept mmap\nallocations of the previously mentioned segments and redirect them\nthrough Isomalloc. The present lack of support for these features mean\nPiP-Globals is best suited for testing AMPI during exploratory phases\nof development, and for production jobs not requiring load balancing or\nfault tolerance.\n\nAutomatic Filesystem-Based Runtime Linking Privatization\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFilesystem Globals (FS-Globals) was discovered during the development of\nPiP-Globals and the two are highly similar. Like PiP-Globals, it\nrequires no modification of user code and works with any language.\nIt also currently lacks support for checkpointing and migration,\npreventing use of load balancing and fault tolerance. Unlike PiP-Globals,\nit is portable beyond GNU/Linux and has no limits to overdecomposition\nbeyond available disk space.\n\nFS-Globals works in the same way as PiP-Globals except that instead of\nspecifying namespaces using ``dlmopen``, which is a GNU/Linux-specific\nfeature, this method creates copies of the user's PIE binary on the\nfilesystem for each rank and calls the POSIX-standard ``dlopen``.\n\nTo use FS-Globals, compile and link with the ``-fsglobals`` parameter:\n\n.. code-block:: bash\n\n   $ ampicxx -o example.o -c example.cpp -fsglobals\n   $ ampicxx -o example example.o -fsglobals\n\nNo additional steps are required. Global variables in ``example.cpp``\nwill be automatically privatized when the program is run. Variables in\nstatically linked libraries will also be privatized if compiled as PIE.\nIt is recommended to achieve this by building with the AMPI toolchain\nwrappers and ``-fsglobals``, and this is necessary if the libraries call\nMPI functions. Shared objects are currently not supported by FS-Globals\ndue to the extra overhead of iterating through all dependencies and\ncopying each one per rank while avoiding system components, plus the\ncomplexity of ensuring each rank's program binary sees the proper set of\nobjects.\n\nThis method's use of the filesystem is a drawback in that it is slow\nduring startup and can be considered wasteful. Additionally, support for\nload balancing and fault tolerance would require further development in\nthe future, using the same infrastructure as what PiP-Globals would\nrequire. For these reasons FS-Globals is best suited for the R&D phase\nof AMPI program development and for small jobs, and it may be less\nsuitable for large production environments.\n\nAutomatic Global Offset Table Swapping\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThanks to the ELF Object Format, we have successfully automated the\nprocedure of switching the set of user global variables when switching\nthread contexts. Executable and Linkable Format (ELF) is a common\nstandard file format for Object Files in Unix-like operating systems.\nELF maintains a Global Offset Table (GOT) for globals so it is possible\nto switch GOT contents at thread context-switch by the runtime system.\n\nThe only thing that the user needs to do is pass the flag\n``-swapglobals`` at both compile and link time (e.g. \"ampicc -o prog\nprog.c -swapglobals\"). This method does not require any changes to the\nsource code and works with any language (C, C++, Fortran, etc). However,\nit does not handle static variables, has a context switching overhead\nthat grows with the number of global variables, and is incompatible with\nSMP builds of AMPI, where multiple virtual ranks can execute\nsimultaneously on different scheduler threads within an OS process.\n\nCurrently, this feature only works on x86 and x86_64 platforms that\nfully support ELF, and it requires ld version 2.23 or older, or else a\npatched version of ld 2.24+ that we provide here:\nhttps://charm.cs.illinois.edu/gerrit/gitweb?p=libbfd-patches.git;a=tree;f=swapglobals\n\nFor these reasons, and because more robust privatization methods are\navailable, swapglobals is considered deprecated.\n\nSource-to-Source Transformation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOne final approach is to use a tool to transform your program's source\ncode, implementing the changes described in one of the sections above in\nan automated fashion.\n\nWe have multiple tools for automating these transformations for different\nlanguages.\nCurrently, there is a tool called *Photran*\n(http://www.eclipse.org/photran) for refactoring Fortran codes\nthat can do this transformation. It is Eclipse-based and works by\nconstructing Abstract Syntax Trees (ASTs) of the program.\nWe also have a tool built with *LLVM/LibTooling* that applies the\nTLS-Globals transformation to C/C++ codes, available upon request.\n\nSummary\n~~~~~~~\n\nTable :numref:`tab:portability` shows portability of\ndifferent schemes.\n\n.. _tab:portability:\n.. table:: Portability of current implementations of three privatization schemes. \"Yes\" means we have implemented this technique. \"Maybe\" indicates there are no theoretical problems, but no implementation exists. \"No\" indicates the technique is impossible on this platform.\n\n   ==================== ===== ====== ==== ======= === ====== ===== =====\n   Privatization Scheme Linux Mac OS BG/Q Windows x86 x86_64 PPC   ARM7\n   ==================== ===== ====== ==== ======= === ====== ===== =====\n   Manual Code Editing  Yes   Yes    Yes  Yes     Yes Yes    Yes   Yes\n   TLS-Globals          Yes   Yes    No   Maybe   Yes Yes    Maybe Maybe\n   PiP-Globals          Yes   No     No   No      Yes Yes    Yes   Yes\n   FS-Globals           Yes   Yes    No   Yes     Yes Yes    Yes   Yes\n   GOT-Globals          Yes   No     No   No      Yes Yes    Yes   Yes\n   ==================== ===== ====== ==== ======= === ====== ===== =====\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/cmake/detect-features-c.cmake": "include(CheckTypeSize)\ninclude(CheckFunctionExists)\ninclude(CheckCSourceCompiles)\ninclude(CheckSymbolExists)\n\nif(NOT CHARM_OS STREQUAL \"win\")\n  set(CMAKE_EXTRA_INCLUDE_FILES sys/types.h sys/socket.h)\n  set(CMAKE_REQUIRED_LIBRARIES -lm ${CMAKE_DL_LIBS} -pthread)\nelse()\n  set(CMAKE_REQUIRED_LIBRARIES -lm -pthread)\nendif()\nset(CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE)\n\n# C types and type sizes\ncheck_type_size(\"size_t\" size_t_size)\nif(${size_t_size} EQUAL 8)\n    set(CMK_SIZET_64BIT 1)\nelse()\n    set(CMK_SIZET_64BIT 0)\nendif()\n\ncheck_type_size(\"GROUP_AFFINITY\" HAVE_GROUP_AFFINITY)\ncheck_type_size(\"GROUP_RELATIONSHIP\" HAVE_GROUP_RELATIONSHIP)\ncheck_type_size(\"KAFFINITY\" HAVE_KAFFINITY)\ncheck_type_size(\"long double\" CMK_LONG_DOUBLE_DEFINED)\ncheck_type_size(\"long long\" CMK_LONG_LONG_DEFINED)\ncheck_type_size(\"pthread_t\" HAVE_PTHREAD_T)\ncheck_type_size(\"socklen_t\" CMK_HAS_SOCKLEN)\ncheck_type_size(\"ssize_t\" HAVE_SSIZE_T)\ncheck_type_size(\"unsigned int\" SIZEOF_UNSIGNED_INT)\ncheck_type_size(\"unsigned long\" SIZEOF_UNSIGNED_LONG)\ncheck_type_size(\"void *\" SIZEOF_VOID_P)\ncheck_type_size(\"__int64\" CMK___int64_DEFINED)\ncheck_type_size(\"__int128_t\" CMK___int128_t_DEFINED)\ncheck_type_size(\"__int128\" CMK___int128_DEFINED)\ncheck_type_size(\"__int128\" CMK_HAS_INT16)\n\n# C header files\ncheck_include_file(alloca.h CMK_HAS_ALLOCA_H)\ncheck_include_file(ctype.h HAVE_CTYPE_H)\ncheck_include_file(cuda.h HAVE_CUDA_H)\ncheck_include_file(dirent.h HAVE_DIRENT_H)\ncheck_include_file(dlfcn.h HAVE_DLFCN_H)\ncheck_include_file(elf.h CMK_HAS_ELF_H)\ncheck_include_file(inttypes.h HAVE_INTTYPES_H)\ncheck_include_file(kstat.h HAVE_KSTAT_H)\ncheck_include_file(libudev.h HAVE_LIBUDEV_H)\ncheck_include_file(malloc.h HAVE_MALLOC_H)\ncheck_include_file(malloc.h CMK_HAS_MALLOC_H)\ncheck_include_file(memory.h HAVE_MEMORY_H)\ncheck_include_file(numaif.h HAVE_NUMAIF_H)\ncheck_include_file(pthread_np.h HAVE_PTHREAD_NP_H)\ncheck_include_file(stdlib.h HAVE_STDLIB_H)\ncheck_include_file(string.h HAVE_STRING_H)\ncheck_include_file(strings.h HAVE_STRINGS_H)\nset(CMK_HAS_STRINGS_H ${HAVE_STRINGS_H})\ncheck_include_file(unistd.h HAVE_UNISTD_H)\ncheck_include_file(regex.h CMK_HAS_REGEX_H)\ncheck_include_file(values.h CMK_HAS_VALUES_H)\ncheck_include_file(stdint.h CMK_HAS_STDINT_H)\ncheck_include_file(sys/utsname.h HAVE_SYS_UTSNAME_H)\ncheck_include_file(sys/sysctl.h HAVE_SYS_SYSCTL_H)\ncheck_include_file(sys/stat.h HAVE_SYS_STAT_H)\ncheck_include_file(sys/param.h HAVE_SYS_PARAM_H)\ncheck_include_file(sys/mman.h HAVE_SYS_MMAN_H)\ncheck_include_file(sys/lgrp_user.h HAVE_SYS_LGRP_USER_H)\ncheck_include_file(sys/cpuset.h HAVE_SYS_CPUSET_H)\ncheck_include_file(valgrind/valgrind.h HAVE_VALGRIND_VALGRIND_H)\ncheck_include_file(Multiprocessing.h CMK_HAS_MULTIPROCESSING_H) # for Apple\n\n# C functions\ncheck_function_exists(_putenv HAVE__PUTENV)\ncheck_function_exists(_strdup HAVE__STRDUP)\ncheck_function_exists(asctime CMK_HAS_ASCTIME)\ncheck_function_exists(backtrace CMK_USE_BACKTRACE)\ncheck_function_exists(bindprocessor CMK_HAS_BINDPROCESSOR)\ncheck_function_exists(clz HAVE_CLZ)\ncheck_function_exists(clzl HAVE_CLZL)\ncheck_symbol_exists(dlopen dlfcn.h CMK_DLL_USE_DLOPEN)\nset(CMK_HAS_DLOPEN ${CMK_DLL_USE_DLOPEN})\ncheck_symbol_exists(dlmopen dlfcn.h CMK_HAS_DLMOPEN)\ncheck_symbol_exists(fabsf \"math.h\" HAVE_DECL_FABSF)\nset(CMK_HAS_FABSF ${HAVE_DECL_FABSF})\ncheck_symbol_exists(fdatasync unistd.h CMK_HAS_FDATASYNC_FUNC)\ncheck_function_exists(fsync CMK_HAS_FSYNC_FUNC)\ncheck_symbol_exists(ffs \"strings.h\" HAVE_FFS)\ncheck_function_exists(ffsl HAVE_FFSL)\ncheck_function_exists(fls HAVE_FLS)\ncheck_function_exists(flsl HAVE_FLSL)\ncheck_function_exists(getexecname HAVE_DECL_GETEXECNAME)\ncheck_function_exists(getifaddrs CMK_HAS_GETIFADDRS)\ncheck_function_exists(getpagesize HAVE_GETPAGESIZE)\ncheck_function_exists(getpagesize CMK_HAS_GETPAGESIZE)\ncheck_function_exists(getpid CMK_HAS_GETPID)\ncheck_type_size(pid_t MY_HAS_PID_T)\nif(NOT MY_HAS_PID_T)\n  set(CMK_HAS_GETPID 0)\nendif()\ncheck_function_exists(getprogname HAVE_DECL_GETPROGNAME)\ncheck_symbol_exists(get_myaddress rpc/rpc.h CMK_HAS_GET_MYADDRESS)\ncheck_function_exists(host_info HAVE_HOST_INFO)\ncheck_function_exists(kill CMK_HAS_KILL)\ncheck_symbol_exists(log2 math.h CMK_HAS_LOG2)\ncheck_function_exists(mallinfo CMK_HAS_MALLINFO)\ncheck_function_exists(mkstemp CMK_USE_MKSTEMP)\ncheck_function_exists(mmap CMK_HAS_MMAP)\ncheck_symbol_exists(MAP_ANON sys/mman.h CMK_HAS_MMAP_ANON)\ncheck_symbol_exists(MAP_NORESERVE sys/mman.h CMK_HAS_MMAP_NORESERVE)\ncheck_function_exists(mprotect CMK_HAS_MPROTECT)\ncheck_symbol_exists(MPI_Init_thread mpi.h CMK_MPI_INIT_THREAD)\ncheck_function_exists(mstats CMK_HAS_MSTATS)\ncheck_function_exists(ntohl CMK_HAS_NTOHL)\ncheck_function_exists(offsetof CMK_HAS_OFFSETOF)\ncheck_function_exists(openat HAVE_OPENAT)\ncheck_function_exists(poll CMK_USE_POLL)\ncheck_function_exists(popen CMK_HAS_POPEN)\ncheck_function_exists(posix_memalign HAVE_POSIX_MEMALIGN)\ncheck_symbol_exists(pthread_getaffinity_np pthread.h HAVE_DECL_PTHREAD_GETAFFINITY_NP)\ncheck_symbol_exists(pthread_setaffinity_np pthread.h HAVE_DECL_PTHREAD_SETAFFINITY_NP)\nset(CMK_HAS_PTHREAD_SETAFFINITY ${HAVE_DECL_PTHREAD_SETAFFINITY_NP})\ncheck_symbol_exists(pthread_spin_lock pthread.h CMK_HAS_SPINLOCK)\ncheck_symbol_exists(RTLD_DEFAULT dlfcn.h CMK_HAS_RTLD_DEFAULT)\ncheck_symbol_exists(RTLD_NEXT dlfcn.h CMK_HAS_RTLD_NEXT)\ncheck_function_exists(readlink CMK_HAS_READLINK)\ncheck_function_exists(realpath CMK_HAS_REALPATH)\ncheck_symbol_exists(RUSAGE_THREAD sys/resource.h CMK_HAS_RUSAGE_THREAD)\ncheck_function_exists(sbrk CMK_HAS_SBRK)\ncheck_function_exists(sched_setaffinity CMK_HAS_SETAFFINITY)\ncheck_function_exists(setlocale HAVE_SETLOCALE)\ncheck_symbol_exists(setpriority sys/resource.h CMK_HAS_SETPRIORITY)\ncheck_function_exists(sleep CMK_HAS_SLEEP)\ncheck_function_exists(snprintf HAVE_DECL_SNPRINTF)\ncheck_function_exists(sqrtf CMK_HAS_SQRTF)\ncheck_function_exists(strcasecmp HAVE_DECL_STRCASECMP)\ncheck_function_exists(strftime HAVE_STRFTIME)\ncheck_function_exists(strncasecmp HAVE_STRNCASECMP)\ncheck_function_exists(strtoull HAVE_DECL_STRTOULL)\ncheck_function_exists(strtoull HAVE_STRTOULL)\ncheck_function_exists(sync CMK_HAS_SYNC_FUNC)\ncheck_function_exists(system CMK_HAS_SYSTEM)\ncheck_function_exists(sysctl HAVE_SYSCTL)\ncheck_function_exists(sysctlbyname HAVE_SYSCTLBYNAME)\ncheck_function_exists(uname HAVE_UNAME)\ncheck_function_exists(usleep CMK_HAS_USLEEP)\n\n\n# Complex tests\n\nif(CMK_WINDOWS OR CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n  set(CMK_CAN_GET_BINARY_PATH 1)\nelseif(${CMK_HAS_READLINK} OR ${CMK_HAS_REALPATH})\n  set(CMK_CAN_GET_BINARY_PATH 1)\nelse()\n  set(CMK_CAN_GET_BINARY_PATH 0)\nendif()\n\nfile(WRITE ${CMAKE_BINARY_DIR}/test_file \"\")\nexecute_process(COMMAND cp -p test_file test_file2 ERROR_VARIABLE CP_P_OPTION_ERROR)\nif(NOT ${CP_P_OPTION_ERROR} STREQUAL \"\")\n  set(CP \"cp\")\nelse()\n  set(CP \"cp -p\")\nendif()\nfile(REMOVE ${CMAKE_BINARY_DIR}/test_file ${CMAKE_BINARY_DIR}/test_file2)\n\n\ncheck_c_source_compiles(\"\n#include <stdio.h>\n#include <lustre/lustreapi.h>\n#include <lustre/lustre_user.h>\n\nint main() {\n  llapi_printf(LLAPI_MSG_NORMAL, \\\"Lustre FS is available\\\");\n  return 0;\n}\n\" CMK_HAS_LUSTREFS)\n\n\nif(CMK_HAS_LUSTREFS)\n  set(CMK_LUSTREAPI \"-llustreapi\")\nelse()\n  set(CMK_LUSTREAPI \"\")\nendif()\n\n\ncheck_c_source_compiles(\"\nint main()\n{\n  asm volatile(\\\"eieio\\\" ::: \\\"memory\\\");\n}\n\" CMK_PPC_ASM)\n\ncheck_c_source_compiles(\"\nint main()\n{\n  __sync_synchronize();\n}\n\" CMK_C_SYNC_SYNCHRONIZE_PRIMITIVE)\n\ncheck_c_source_compiles(\"\nint main()\n{\n  int t=1;\n  __sync_add_and_fetch(&t, 1);\n}\n\" CMK_C_SYNC_ADD_AND_FETCH_PRIMITIVE)\n\ncheck_c_source_compiles(\"\n#include <sys/personality.h>\nint main() {\n    int orig_persona = personality(0xffffffff);\n    personality(orig_persona | ADDR_NO_RANDOMIZE);\n    return 0;\n}\n\" CMK_HAS_ADDR_NO_RANDOMIZE)\n\ncheck_c_source_compiles(\"\n__attribute__((visibility(\\\"default\\\"))) int myfunc();\nint myfunc()\n{\n  return 0;\n}\nint main()\n{\n  return 0;\n}\n\" CMK_HAS_ATTRIBUTE_VISIBILITY_DEFAULT)\n\ncheck_c_source_compiles(\"\n#define _GNU_SOURCE\n#include <sys/uio.h>\n#include <errno.h>\nint main() {\n  pid_t pid;\n  struct iovec *local, *remote;\n  int nread = process_vm_readv(pid, local, 1, remote, 1, 0);\n  nread = process_vm_writev(pid, local, 1, remote, 1, 0);\n  return errno;\n}\n\" CMK_HAS_CMA)\n\ncheck_c_source_compiles(\"\n#include <stdio.h>\n#include <papi.h>\nint main() {\n    if (PAPI_library_init(PAPI_VER_CURRENT) != PAPI_VER_CURRENT) return 1;\n    return 0;\n}\n\" CMK_HAS_COUNTER_PAPI)\n\ncheck_c_source_compiles(\"\n#define _GNU_SOURCE\n#define __USE_GNU\n#include <link.h>\n#include <stddef.h>\nstatic int callback(struct dl_phdr_info* info, size_t size, void* data)\n{\n  return 0;\n}\nint main()\n{\n  dl_iterate_phdr(callback, NULL);\n  return 0;\n}\n\" CMK_HAS_DL_ITERATE_PHDR)\n\ncheck_c_source_compiles(\"\nextern int __executable_start;\nint main()\n{\n  return __executable_start;\n}\n\" CMK_HAS_EXECUTABLE_START)\n\ncheck_c_source_compiles(\"\n#include <stdio.h>\nextern int _IO_file_overflow(FILE *, int);\nint main()\n{\n  return _IO_file_overflow(stdout, -1);\n}\n\" CMK_HAS_IO_FILE_OVERFLOW)\n\ncheck_c_source_compiles(\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <linux/mempolicy.h>\n#include <numaif.h>\n#include <numa.h>\n\nint main()\n{\n  if (get_mempolicy(NULL, NULL, 0, 0, 0) == 0) return 0;\n  return -1;\n}\n\" CMK_HAS_NUMACTRL)\n\nset(tmp ${CMAKE_REQUIRED_LIBRARIES})\nset(CMAKE_REQUIRED_LIBRARIES $ENV{CRAY_PMI_POST_LINK_OPTS} $ENV{CRAY_UGNI_POST_LINK_OPTS} -lugni -lpmi)\ncheck_c_source_compiles(\"\n#include <pmi.h>\nint main() {\n    int nid;\n    PMI_Get_nid(0, &nid);\n\n    return 0;\n}\n\" CMK_HAS_PMI_GET_NID)\nset(CMAKE_REQUIRED_LIBRARIES ${tmp})\n\ncheck_c_source_compiles(\"\n#include <rca_lib.h>\nint main() {\n    rca_mesh_coord_t xyz;\n    rca_get_meshcoord(0, &xyz);\n\n    return 0;\n}\n\" CMK_HAS_RCALIB)\n\ncheck_c_source_compiles(\"\n#include <rca_lib.h>\nint main() {\n    rca_mesh_coord_t xyz;\n    rca_get_max_dimension(&xyz);\n\n    return 0;\n}\n\" CMK_HAS_RCA_MAX_DIMENSION)\n\ncheck_c_source_compiles(\"\n__thread unsigned long long int x;\nstatic __thread  int y;\nint main(void)\n{\n  x = 1;\n  y = 1;\n}\n\" CMK_HAS_TLS_VARIABLES )\n\ncheck_c_source_compiles(\"\n#include <setjmp.h>\nint main() {\n  jmp_buf buf;\n  _setjmp(buf);\n  _longjmp(buf, 0);\n}\n\" CMK_HAS_UNDERSCORE_SETJMP )\n\ncheck_c_source_compiles(\"\n#include <infiniband/verbs.h>\nvoid test()\n{\n    struct ibv_context    *context;\n    int ibPort;\n    struct ibv_port_attr attr;\n    if (ibv_query_port(context, ibPort, &attr) != 0) return;\n    if (attr.link_layer == IBV_LINK_LAYER_INFINIBAND)  return;\n}\n\" CMK_IBV_PORT_ATTR_HAS_LINK_LAYER)\n\ncheck_c_source_compiles([=[\nvoid main() {\n  void * m1, * m2;\n  asm volatile (\"movq %%fs:0x0, %0\\\\n\\t\"\n                \"movq %1, %%fs:0x0\\\\n\\t\"\n                : \"=&r\"(m1)\n                : \"r\"(m2));\n}\n]=] CMK_TLS_SWITCHING_X86_64)\n\ncheck_c_source_compiles([=[\nvoid main() {\n  void * m1, * m2;\n  asm volatile (\"movl %%gs:0x0, %0\\\\n\\t\"\n                \"movl %1, %%gs:0x0\\\\n\\t\"\n                : \"=&r\"(m1)\n                : \"r\"(m2));\n}\n]=] CMK_TLS_SWITCHING_X86)\n\ncheck_c_source_compiles(\"\n#include <stdint.h>\n#include <gni_pub.h>\nint main() {\n    gni_bi_desc_t gni_bi_desc;\n    uint32_t gni_device_id = 0;\n    gni_return_t gni_rc = GNI_GetBIConfig(gni_device_id, &gni_bi_desc);\n    if (gni_rc == GNI_RC_SUCCESS) {\n    }\n    return 0;\n}\n\" CMK_BALANCED_INJECTION_API)\n\nif(NOT CMK_BALANCED_INJECTION_API)\n  # Since it is often checked via #ifdef, CMK_BALANCED_INJECTION_API\n  # can't be set to zero, but must be unset.\n  unset(CMK_BALANCED_INJECTION_API CACHE)\nendif()\n\nif(${CMK_BUILD_OFI} EQUAL 1)\n  set(tmp ${CMAKE_REQUIRED_LIBRARIES})\n  set(CMAKE_REQUIRED_LIBRARIES \"${CMAKE_REQUIRED_LIBRARIES} -lfabric\")\n  check_c_source_compiles(\"\n    #include <rdma/fabric.h>\n    int main(int argc, char **argv)\n    {\n      struct fi_info *providers;\n      int ret = fi_getinfo(FI_VERSION(1,0), NULL, NULL, 0ULL, NULL, &providers);\n      return 0;\n    }\n  \" CMK_BUILD_ON_OFI)\n  set(CMAKE_REQUIRED_LIBRARIES ${tmp})\n  if(\"${CMK_BUILD_ON_OFI}\" STREQUAL \"\")\n    message(FATAL_ERROR \"Unable to build ofi.\")\n  endif()\nendif()\n\ncheck_c_source_compiles(\"\n#include <ucontext.h>\nstruct _libc_fpstate   fpstate;\nfpregset_t *fp;\nint main()\n{\n  ucontext_t context;\n  context.uc_mcontext.fpregs = 0;\n}\n\" CMK_CONTEXT_FPU_POINTER)\n\ncheck_c_source_compiles(\"\n#include <ucontext.h>\nint main()\n{\n  ucontext_t context;\n  context.uc_mcontext.uc_regs = 0;\n}\n\" CMK_CONTEXT_FPU_POINTER_UCREGS)\n\ncheck_c_source_compiles(\"\n#include <ucontext.h>\nvrregset_t *v_regs;\nucontext_t  uc;\n\nint main()\n{\n  vrregset_t *ptr = uc.uc_mcontext.v_regs;\n}\n\" CMK_CONTEXT_V_REGS)\n\ncheck_c_source_compiles(\"\ninline static int foo()\n{\n  return 1;\n}\nint main() {}\n\" CMK_C_INLINE)\n\ncheck_c_source_compiles(\"\nint main(void)\n{\n  unsigned long long int v=0;\n  int *lo=0+(int *)&v;\n  int *hi=1+(int *)&v;\n  __asm__ __volatile__(\n      \\\"rdtsc; movl %%edx,%0; movl %%eax,%1\\\"\n      : /* output  */ \\\"=m\\\" (*hi), \\\"=m\\\" (*lo)\n      : /* input */\n      : /* trashes */ \\\"%edx\\\", \\\"%eax\\\"\n  );\n  return v;\n}\n\" CMK_GCC_X86_ASM)\n\ncheck_c_source_compiles(\"\nint main(void)\n{\n  int x;\n  asm(\\\"lock incl %0\\\" :: \\\"m\\\" (x));\n  asm(\\\"lock decl %0\\\" :: \\\"m\\\" (x));\n  return x;\n}\n\" CMK_GCC_X86_ASM_ATOMICINCREMENT)\n"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/src/libs/ck-libs/metis/manual/manual.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/src/libs/ck-libs/ampi/romio/doc/users-guide.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/src/libs/ck-libs/ampi/romio/doc/source-guide.tex",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/src/libs/ck-libs/ampi/romio/adio/common/ad_iwrite_coll.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/src/libs/ck-libs/ampi/romio/adio/common/ad_iread_coll.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/src/ck-ldb/rf_model/big_weakmodel.txt.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/src/ck-ldb/rf_model/big_leafdist.txt.gz",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/src/ck-cp/NelderMeadStateDiagram.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/examples/pose/LBSim/sample-graph.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/examples/charm++/wave2d/screenshot.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/examples/charm++/satisfiability/TNM/TNM.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/examples/charm++/satisfiability/TNM/TNM.C",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/viewlog.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/userevent.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/usageprofile.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/timeprofile.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/timeline.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/standard_dialog.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/piechart.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/performancecounters.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/overview.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/outlier_dialog.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/mainwindow.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/histogram.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/graph.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/front-with-summary.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/commhistogram.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/apoa1_512_overviewEPColored.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/apoa1_512_overview.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/apoa1_512_outlierWithClusters.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/apoa1_512_CommTimeProfile.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/apoa1_512_CommProcessorProfile.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/apoa1_128_userEventsView.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/animation.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/NoiseMiner2.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/projections/fig/NoiseMiner1.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/parfum/fig/parfum_structure.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/netfem/fig/example.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/mblock/fig/terminology.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/mblock/fig/nodeloc.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/mblock/fig/indexing.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/mblock/fig/ghostwidth.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/mblock/fig/decompose.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/sym_ghost.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/simple_mesh.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/partitioned_mesh.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/layout.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/indexlists.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/ghost_pre.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/ghost_node.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/ghost_edge.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/forcedecomp.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/create_field.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/conn_indexing_old.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/fem/fig/conn_indexing.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/debugger/figs/snapshot4.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/debugger/figs/snapshot4-crop.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/debugger/figs/snapshot3.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/debugger/figs/snapshot2.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/debugger/figs/snapshot1.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/debugger/figs/menu.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/debugger/figs/memoryView.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/debugger/figs/memoryStatistics.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/debugger/figs/memoryLeaking.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/debugger/figs/memoryInspector.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/debugger/figs/arrayelement.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/charm++/fig/pup.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/charm++/fig/ckgraph.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/ampi/figs/virtualization.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/ampi/figs/prac.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/doc/ampi/figs/migrate.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/.git/objects/pack/pack-5b41c15c37bc2d6c8f72f1b38e122b9037351428.idx",
        "/var/tmp/sochat1/spack-stage/spack-stage-charmpp-master-x5krssskyi7vrxeyshcg7n7igihza7kp/spack-src/.git/objects/pack/pack-5b41c15c37bc2d6c8f72f1b38e122b9037351428.pack"
    ],
    "total_files": 5970
}