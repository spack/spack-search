{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/doxygen/community.doc": "/**\n@page community The SimGrid Community\n\n@tableofcontents\n\nSimGrid is a free software, written by a community of people. It\nstarted as a little software to help ourselves in our own research,\nand as more people put their input into the pot, it turned into\nsomething that we hope to be valuable to many people. So yes. We hope\nthat SimGrid is helping you doing what you want, and that you will\njoin our community of happy simgriders.\n\n@section community_contact Contacting the community\n\nThere are several locations where you can connect and discuss about\nSimGrid. If you have a question, please have a look at the\ndocumentation and examples first, but if some remain don't hesitate to\nask the community for help. If you do not have a question, just come to us\nand say hello! We love earing about how people use SimGrid.\n\n - For questions or remarks, drop us an email on the \n   <a href=\"mailto:simgrid-user@lists.gforge.inria.fr\">User Mailing list</a> (to subscribe, visit the [webinterface](http://lists.gforge.inria.fr/mailman/listinfo/simgrid-user));\n   you can also check out [our archives](http://lists.gforge.inria.fr/pipermail/simgrid-user/).\n   We prefer you to <b>not use private emails</b>. SimGrid is an open\n   framework, and you never know who have the time and knowledge to\n   answer your question, so please keep messages on the public mailing list.\n - Join us on IRC and ask your question directly on the channel \\#simgrid at\n   \\b irc.debian.org. Be warned that even if many people are connected to\n   the chanel, they may not be staring at their IRC windows.\n   So don't be surprised if you don't get an answer in the \n   second, and turn to the mailing lists if nobody seems to be there.\n - Asking your question on [StackOverflow](http://stackoverflow.com/questions/tagged/simgrid) is also a good idea, as this\n   site is very well indexed. We answer questions there too (don't\n   forget to use the SimGrid tag in your question so that we can see\n   it), and they remain usable for the next users. \n\n@section community_giveback Giving back to SimGrid\n\nWe are sometimes asked by users how to give back to the project. Here\nare some ideas, but if you have new ones, feel free to share them with us.\n\n@subsection contributing_spread Spread the word\n\nThere are many ways to help the SimGrid project. The first and most\nnatural one is to <b>use it for your research, and say so</b>. Cite\nthe SimGrid framework in your papers and discuss of its advantages with\nyour colleagues to spread the word. When we ask for new fundings to\nsustain the project, the amount of publications enabled by SimGrid is\nalways the first question we get. The more you use the framework,\nthe better for us. \n\nMake sure that your scientific publications using SimGrid actually\ncite the <a href=\"http://simgrid.gforge.inria.fr/Publications.html\">right paper</a>.\nAlso make sure that these citations are correctly listed on \n<a href=\"http://simgrid.gforge.inria.fr/Usages.html\">our list</a>.\n\nYou can also <b>help us constituting an active and welcoming user\ncommunity</b>. Subscribe to the mailing lists, and answer the\nquestions that newscomers have if you can. Point them (gently ;) to\nthe relevant part of the documentation on need, and help them becoming\npart of our community too. \n\nAnother easy way to help the project is to add a link to the <a\nhref=\"http://simgrid.gforge.inria.fr\">SimGrid homepage</a> on your\nsite to <b>improve SimGrid's ranking in search engines</b>.\n\nFinally, if you organize a scientific event where you expect many\npotential users, <b>you can invite us to give a tutorial on SimGrid</b>. We\nfound that 45 minutes to one hour is very sharp, but doable. It\nallows us to explain the main motivations and outcomes of the project in\norder to motivate the attendees get more information on SimGrid, and\neventually improve their scientific habits by using a sound simulation\nframework.  \n<a href=\"http://people.irisa.fr/Martin.Quinson/blog/2012/1120/Simgrid_at_Louvain/\">Here</a>\nis an example of such a presentation.\n\n@subsection contributing_bugs Reporting (and fixing) any issue you find\n\nBecause of its size and complexity, SimGrid is not perfect and\ncontains a large amount of glitches and issues. When you find one,\ndon't assume that it's here because we don't care. It survived only\nbecause nobody told us. We unfortunately cannot endlessly review our\nlarge code and documentation base. So please, <b>report any issue you\nfind</b>, be it a typo in the documentation, a paragraph that needs to\nbe reworded, a bug in the code, or any other problem. The best way to\ndo so is to open an issue on our GitHub's \n<a href=\"https://github.com/simgrid/simgrid/issues\">Bug Tracker</a> so\nthat we don't forget about it (if you want to put some attachment, you\ncan use \n<a https://gforge.inria.fr/tracker/?atid=165&group_id=12&func=browse\">this\nother bugtracker</a> instead). \n\nThe worst way to report such issues is to go through private emails.\nThese are unreliable, and we are trying to develop SimGrid openly, so\nprivate discussions are to be avoided if possible. \n\nIf you can provide a patch fixing the issue you report, that's even\nbetter. If you cannot, then you need to give us a minimal working\nexample (MWE), that is a ready to use solution that reproduces the\nproblem you face. Your bug will take much more time\nfor us to reproduce and fix if you don't give us the MWE, so you want\nto help us helping you to get things efficient.\n\nOf course, a very good way to give back to the SimGrid community is to\n<b>triage and fix the bugs in the Bug Tracking Systems</b>. If you\ncan come up with a patch fixing them, we will be more than happy to\napply your changes so that the whole community enjoys them.\n\n@section community_extend Extending SimGrid and its Ecosystem\n\n@subsection contributing_contrib Contributing features and associated tools\n\nIf you deeply miss a feature in the framework, you should consider\nimplementing it yourself. SimGrid is free software, meaning that you are\nfree to help yourself. Of course, we'll do our best to assist you in\nthis task, so don't hesitate to contact us with your idea.\n\nYou could write a new plugin extending SimGrid in some way, or a\nrouting model for another kind of network. But even if you write your own\nplatform file, this is probably interesting to other users too, and\ncould be included to SimGrid. Modeling accurately a given platform is\na difficult work, which outcome is very precious to us.\n\nOr maybe you developed an independent tool on top of SimGrid. We'd\nlove helping you gaining visibility by listing it in our \n<a href=\"http://simgrid.gforge.inria.fr/contrib.html\">Contrib\nsection</a>. \n\n@subsection contributing_todo Possible Enhancements\n\nIf you want to start working on the SimGrid codebase, here are a few\nideas of things that could be done to improve the current code (not all of them\nare difficult, do trust yourself ;)\n\n@subsubsection contributing_todo_cxxification Migration to C++\n\nThe code is being migrated to C++ but a large part is still C (or C++ with\nC idioms). It would be valuable to replace C idioms with C++ ones:\n\n - replace XBT structures and C dynamic arrays with C++ containers;\n\n - replace `char*` strings with `std::string`;\n\n - use exception-safe RAII (`std::unique_ptr`, etc.) instead of explicit\n   `malloc/free` or `new/delete`;\n\n - use `std::function` (or template functionoid arguments) instead of function\n   pointers;\n\n#### Exceptions\n\nSimGrid used to implement exceptions in C. This has been replaced with C++\nexceptions but some bits of the C exceptions are still remaining:\n\n - `xbt_ex` was the type of C exceptions. It is now a standard C++ exception.\n    We might want to remove this exception and use a more idiomatic C++\n    solution with dedicated exception classes for different errors.\n    `std::system_error` might be used as well by replacing some `xbt_errcat_t`\n    with custom subclasses of `std::error_category`.\n\n - The C API currently throws exceptions. Throwing exceptions out of a C API is\n   not very friendly. C code does not expect them, cannot catch them and cannot\n   handle resource management properly in face of exceptions. We should clearly\n   separate the C++ API and the C API and catch all exceptions before they get\n   ouf of C APIs.\n\n#### Time and duration\n\nSome support for C++11-style time/duration is implemented (see `chrono.hpp`)\nbut only available in some (S4U) APIs. It would be nice to add support for\nthem in the rest of the C++ code.\n\nA related change would be to avoid using \"-1\" to mean \"forever\" at least in S4U\nand in the internal code. For compatibility, MSG should probably keep this\nsemantic. We should probably always use separate functions\n(`wait` vs `wait_for`).\n\n#### Futures and Promises\n\n - Some features are missing in the Maestro future implementation\n  (`simgrid::kernel::Future`, `simgrid::kernel::Promise`)\n  could be extended to support additional features:\n  `when_any`, `shared_future`, etc.\n\n - The corresponding feature might then be implemented in the user process\n   futures (`simgrid::simix::Future`).\n\n - Currently `.then()` is not available for user futures. We would need to add\n   a basic user event loop in order to queue the pending continuations.\n\n - We might need to provide an option to cancel a pending operation. This\n   might be achieved by defining some `Action` or `Operation` class with an\n   API compatible with `Future` (and convertible to it) but with an\n   additional `.cancel()` method.\n\n@subsubsection contributing_todo_smpi SMPI\n\n#### Process-based privatization\n\nCurrently, all the simulated processes live in the same process as the SimGrid\nsimulator. The benefit is that we don't have to do context switches and IPC\nbetween the simulator and the processes.\n\nThe fact that they share the same address space means that one memory corruption\nin one simulated process can propagate to the other ones and to the SimGrid\nsimulator itself.\n\nMoreover, the current design for SMPI applications is to compile the MPI code\nnormally and execute it once per simulated process in the same system process:\nThis means that all the existing simulated MPI processes share the same virtual\naddress space and share by default the same global variables. This is not\ncorrect as each MPI process is expected to use its own address space and have\nits own global variables. In order to fix, this problem we have an optional\nSMPI privatization feature which creates an instanciation of the executable\ndata segment per MPI process and map the correct one (using `mmap`) at each\ncontext switch.\n\nThis approach has many problems:\n\n 1. It is not completely safe. We only handle SMPI privatization for the global\n    variables in the execute data segment. Shared objects are ignored but some\n    may contain global variables which may need to be privatized:\n\n    - libsimgrid for example must not be privatized because it contains\n      shared state for the simulator;\n\n    - libc must not be privatized for the same reason (but some global variables\n      in the libc may not be privatized);\n\n    - if we use global variables of some shared object in the executable, this\n      global variable will be instanciated in the executable (because of copy\n      relocation) and will be privatized even if it shoud not.\n\n 2. We cannot execute the MPI processes in parallel. Only one can execute at\n    the same time because only one privatization segment can be mapped at a\n    given time.\n\nIn order to fix this, the standard solution is to move each MPI process in its\nown system process and use IPC to communicate with the simulator. One concern would\nbe the impact on performance and memory consumption:\n\n - It would introduce a lot of context switches and IPC communications between\n   the MPI processes and the SimGrid simulator. However, currently every context\n   switch needs a `mmap` for SMPI privatization which is costly as well\n   (TLB flush).\n\n - Instanciating a lot of processes might consume more memory which might be a\n   problem if we want to simulate a lot of MPI processes. Compiling MPI programs\n   as static executables with a lightweight libc might help and we might want to\n   support that. The SMPI processes should probably not embed all the SimGrid\n   simulator and its dependencies, the C++ runtime, etc.\n\nWe would need to modify the model-checker as well which currently can only\nmanage on model-checked process. For the model-checker we can expect some\nbenefits from this approach: if a process did not execute, we know its state\ndid not change and we don't need to take its snapshot and compare its state.\n\nOther solutions for this might include:\n\n - Mapping each MPI process in the process of the simulator but in a different\n   symbol namespace (see `dlmopen`). Each process would have its own separate\n   instanciation and would not share libraries.\n\n - Instanciate each MPI process in a separate lightweight VM (for example based\n   on WebAssembly) in the simualtor process.\n\n@subsubsection contributing_todo_mc Model-checker\n\n#### Overhaul the state comparison code\n\nThe state comparison code is quite complicated. It has very long functions and\nis programmed mostly using C idioms and is difficult to understand and debug.\nIt is in need of an overhaul:\n\n  - cleanup, refactoring, usage of C++ features.\n\n  - The state comparison code works by infering types of blocks allocated on the\n    heap by following pointers from known roots (global variables, local\n    variables). Usually the first type found for a given block is used even if\n    a better one could be found later. By using a first pass of type inference,\n    on each snapshot before comparing the states, we might use a better type\n    information on the different blocks.\n\n  - We might benefit from adding logic for handling some known types. For\n    example, both `std::string` and `std::vector` have a capacity which might\n    be larger than the current size of the container. We should ignore\n    the corresponding elements when comparing the states and infering the types.\n\n  - Another difficulty in the state comparison code is the detection of\n    dangling pointers. We cannot easily know if a pointer is dangling and\n    dangling pointers might lead us to choose the wrong type when infering\n    heap blocks. We might mitigate this problem by delaying the reallocation of\n    a freed block until there is no blocks pointing to it anymore using some\n    sort of basic garbage-collector.\n\n#### Hashing the states\n\nIn order to speed up the state comparison an idea was to create a hash of the\nstate. Only states with the same hash would need to be compared using the\nstate comparison algorithm. Some information should not be inclueded in the\nhash in order to avoid considering different states which would otherwise\nwould have been considered equal.\n\nThe states could be indexed by their hash. Currently they are indexed\nby the number of processes and the amount of heap currently allocated\n(see `DerefAndCompareByNbProcessesAndUsedHeap`).\n\nGood candidate informations for the state hashing:\n\n - number of processes;\n\n - their backtraces (instruction addresses);\n\n - their current simcall numbers;\n\n - some simcall arguments (eg. number of elements in a waitany);\n\n - number of pending communications;\n\n - etc.\n\nSome basic infrastructure for this is already in the code (see `mc_hash.cpp`)\nbut it is currently disabled.\n\n#### Separate the model-checker code from libsimgrid\n\n#### Interface with the model-checked processes\n\nThe model-checker reads many information about the model-checked process\nby `process_vm_readv()`-ing brutally the data structure of the model-checked\nprocess leading to some horrible code such as walking a swag from another\nprocess. It prevents us as well from replacing some XBT data structures with\nstandard C++ ones. We need a sane way to expose the relevant information to\nthe model-checker.\n\n#### Generic simcalls\n\nWe have introduced some generic simcalls which can be used to execute a\ncallback in SimGrid Maestro context. It makes it a lot easier to interface\nthe simulated process with the maestro. However, the callbacks for the\nmodel-checker which cannot decide how it should handle them. We would need a\nsolution for this if we want to be able to replace the simcalls the\nmodel-checker cares about by generic simcalls.\n\n#### Defining an API for writing Model-Checking algorithms\n\nCurrently, writing a new model-checking algorithms in SimGridMC is quite\ndifficult: the logic of the model-checking algorithm is mixed with a lot of\nlow-level concerns about the way the model-checker is implemented. This makes it\ndifficult to write new algorithms and difficult to understand, debug, and modify\nthe existing ones. We need a clean API to express the model-checking algorithms\nin a form which is closer to the text-book/paper description. This API must\nbe exposed in a a language which is more adequate to this task.\n\nTasks:\n\n  1. Design and implement a clean API to express model-checking algorithms.\n     A `Session` class currently exists for this but is not feature complete\n     and should probably be rewritten. It should be easy to create bindings\n     for different languages on top of this API.\n\n  2. Create a binding to some better suited, dynamic, scripting language\n     (e.g., Lua).\n\n  3. Rewrite the existing model-checking algorithms in this language using the\n     new API.\n\n*/"
    },
    "skipped": [
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/sc3-description.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/triva-time_interval.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/triva-graph_configuration.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/surf++.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/surf++.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/triva-graph_visualization.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/Paje_MSG_screenshot_thn.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/poster_thumbnail.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/SGicon.ico",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/Paje_MSG_screenshot.jpg",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/smpi_simgrid_alltoall_pair_16.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/simgrid_logo_2011.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/simgrid_logo_2011.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/simgrid_logo_win_2011.bmp",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/awstats_logo3.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/AS_hierarchy.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/storage_sample_scenario.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/simgrid_logo_2011_small.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/SGicon.gif",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/output.goal.pdf",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/smpi_simgrid_alltoall_ring_16.png",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/SGicon.icns",
        "/var/tmp/sochat1/spack-stage/spack-stage-simgrid-3.14.159-kvzh5v6bzvorrnv2zep3ja3o3ekauve4/spack-src/doc/webcruft/simgrid_logo_win.bmp"
    ],
    "total_files": 2234
}